<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
   3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4 *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6 *  Copyright (C) 2007 Maks Orlovich
   7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2012 Igalia, S.L.
   9 *
  10 *  This library is free software; you can redistribute it and/or
  11 *  modify it under the terms of the GNU Library General Public
  12 *  License as published by the Free Software Foundation; either
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;JIT.h&quot;
  35 #include &quot;JSCInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSGeneratorFunction.h&quot;
  38 #include &quot;JSGlobalObject.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;LabelScope.h&quot;
  41 #include &quot;Lexer.h&quot;
  42 #include &quot;Parser.h&quot;
  43 #include &quot;StackAlignment.h&quot;
  44 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  45 #include &quot;YarrFlags.h&quot;
  46 #include &lt;wtf/Assertions.h&gt;
  47 #include &lt;wtf/Threading.h&gt;
  48 #include &lt;wtf/text/StringBuilder.h&gt;
  49 
  50 namespace JSC {
  51 
  52 /*
  53     Details of the emitBytecode function.
  54 
  55     Return value: The register holding the production&#39;s value.
  56              dst: An optional parameter specifying the most efficient destination at
  57                   which to store the production&#39;s value. The callee must honor dst.
  58 
  59     The dst argument provides for a crude form of copy propagation. For example,
  60 
  61         x = 1
  62 
  63     becomes
  64 
  65         load r[x], 1
  66 
  67     instead of
  68 
  69         load r0, 1
  70         mov r[x], r0
  71 
  72     because the assignment node, &quot;x =&quot;, passes r[x] as dst to the number node, &quot;1&quot;.
  73 */
  74 
  75 void ExpressionNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
  76 {
  77     RegisterID* result = generator.emitNode(this);
  78     if (fallThroughMode == FallThroughMeansTrue)
  79         generator.emitJumpIfFalse(result, falseTarget);
  80     else
  81         generator.emitJumpIfTrue(result, trueTarget);
  82 }
  83 
  84 // ------------------------------ ThrowableExpressionData --------------------------------
  85 
  86 RegisterID* ThrowableExpressionData::emitThrowReferenceError(BytecodeGenerator&amp; generator, const String&amp; message)
  87 {
  88     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
  89     generator.emitThrowReferenceError(message);
  90     return generator.newTemporary();
  91 }
  92 
  93 // ------------------------------ ConstantNode ----------------------------------
  94 
  95 void ConstantNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
  96 {
  97     TriState value = jsValue(generator).pureToBoolean();
  98 
  99     if (UNLIKELY(needsDebugHook())) {
 100         if (value != MixedTriState)
 101             generator.emitDebugHook(this);
 102     }
 103 
 104     if (value == MixedTriState)
 105         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
 106     else if (value == TrueTriState &amp;&amp; fallThroughMode == FallThroughMeansFalse)
 107         generator.emitJump(trueTarget);
 108     else if (value == FalseTriState &amp;&amp; fallThroughMode == FallThroughMeansTrue)
 109         generator.emitJump(falseTarget);
 110 
 111     // All other cases are unconditional fall-throughs, like &quot;if (true)&quot;.
 112 }
 113 
 114 RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 115 {
 116     if (dst == generator.ignoredResult())
 117         return 0;
 118     return generator.emitLoad(dst, jsValue(generator));
 119 }
 120 
 121 JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
 122 {
 123     return generator.addStringConstant(m_value);
 124 }
 125 
 126 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 127 {
 128     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 129 }
 130 
 131 // ------------------------------ NumberNode ----------------------------------
 132 
 133 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 134 {
 135     if (dst == generator.ignoredResult())
 136         return nullptr;
 137     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 138 }
 139 
 140 // ------------------------------ RegExpNode -----------------------------------
 141 
 142 RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 143 {
 144     if (dst == generator.ignoredResult())
 145         return nullptr;
 146 
 147     auto flags = Yarr::parseFlags(m_flags.string());
 148     ASSERT(flags.hasValue());
 149     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());
 150     if (regExp-&gt;isValid())
 151         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
 152 
 153     const char* messageCharacters = regExp-&gt;errorMessage();
 154     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 155     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 156     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 157 }
 158 
 159 // ------------------------------ ThisNode -------------------------------------
 160 
 161 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 162 {
 163     generator.ensureThis();
 164     if (dst == generator.ignoredResult())
 165         return 0;
 166 
 167     RegisterID* result = generator.move(dst, generator.thisRegister());
 168     static const unsigned thisLength = 4;
 169     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));
 170     return result;
 171 }
 172 
 173 // ------------------------------ SuperNode -------------------------------------
 174 
 175 static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
 176 {
 177     if (generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) {
 178         RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 179         return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
 180     }
 181 
 182     RegisterID callee;
 183     callee.setIndex(CallFrameSlot::callee);
 184     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().builtinNames().homeObjectPrivateName());
 185 }
 186 
 187 static RegisterID* emitSuperBaseForCallee(BytecodeGenerator&amp; generator)
 188 {
 189     RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
 190     return generator.emitGetById(generator.newTemporary(), homeObject.get(), generator.propertyNames().underscoreProto);
 191 }
 192 
 193 static RegisterID* emitGetSuperFunctionForConstruct(BytecodeGenerator&amp; generator)
 194 {
 195     if (generator.isDerivedConstructorContext())
 196         return generator.emitGetById(generator.newTemporary(), generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment(), generator.propertyNames().underscoreProto);
 197 
 198     RegisterID callee;
 199     callee.setIndex(CallFrameSlot::callee);
 200     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().underscoreProto);
 201 }
 202 
 203 RegisterID* SuperNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 204 {
 205     RegisterID* result = emitSuperBaseForCallee(generator);
 206     return generator.move(generator.finalDestination(dst), result);
 207 }
 208 
 209 // ------------------------------ ImportNode -------------------------------------
 210 
 211 RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 212 {
 213     RefPtr&lt;RegisterID&gt; importModule = generator.emitGetGlobalPrivate(generator.newTemporary(), generator.propertyNames().builtinNames().importModulePrivateName());
 214     CallArguments arguments(generator, nullptr, 1);
 215     generator.emitLoad(arguments.thisRegister(), jsUndefined());
 216     generator.emitNode(arguments.argumentRegister(0), m_expr);
 217     return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 218 }
 219 
 220 // ------------------------------ NewTargetNode ----------------------------------
 221 
 222 RegisterID* NewTargetNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 223 {
 224     if (dst == generator.ignoredResult())
 225         return nullptr;
 226 
 227     return generator.move(dst, generator.newTarget());
 228 }
 229 
 230 // ------------------------------ ImportMetaNode ---------------------------------
 231 
 232 RegisterID* ImportMetaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 233 {
 234     return generator.emitNode(dst, m_expr);
 235 }
 236 
 237 // ------------------------------ ResolveNode ----------------------------------
 238 
 239 bool ResolveNode::isPure(BytecodeGenerator&amp; generator) const
 240 {
 241     return generator.variable(m_ident).offset().isStack();
 242 }
 243 
 244 RegisterID* ResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 245 {
 246     Variable var = generator.variable(m_ident);
 247     if (RegisterID* local = var.local()) {
 248         generator.emitTDZCheckIfNecessary(var, local, nullptr);
 249         if (dst == generator.ignoredResult())
 250             return nullptr;
 251 
 252         generator.emitProfileType(local, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));
 253         return generator.move(dst, local);
 254     }
 255 
 256     JSTextPosition divot = m_start + m_ident.length();
 257     generator.emitExpressionInfo(divot, m_start, divot);
 258     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
 259     RegisterID* finalDest = generator.finalDestination(dst);
 260     RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
 261     generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
 262     generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
 263     generator.move(finalDest, uncheckedResult.get());
 264     generator.emitProfileType(finalDest, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));
 265     return finalDest;
 266 }
 267 
 268 // ------------------------------ TemplateStringNode -----------------------------------
 269 
 270 RegisterID* TemplateStringNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 271 {
 272     if (dst == generator.ignoredResult())
 273         return nullptr;
 274     ASSERT(cooked());
 275     return generator.emitLoad(dst, JSValue(generator.addStringConstant(*cooked())));
 276 }
 277 
 278 // ------------------------------ TemplateLiteralNode -----------------------------------
 279 
 280 RegisterID* TemplateLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 281 {
 282     if (!m_templateExpressions) {
 283         TemplateStringNode* templateString = m_templateStrings-&gt;value();
 284         ASSERT_WITH_MESSAGE(!m_templateStrings-&gt;next(), &quot;Only one template element exists because there&#39;s no expression in a given template literal.&quot;);
 285         return generator.emitNode(dst, templateString);
 286     }
 287 
 288     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
 289 
 290     TemplateStringListNode* templateString = m_templateStrings;
 291     TemplateExpressionListNode* templateExpression = m_templateExpressions;
 292     for (; templateExpression; templateExpression = templateExpression-&gt;next(), templateString = templateString-&gt;next()) {
 293         // Evaluate TemplateString.
 294         ASSERT(templateString-&gt;value()-&gt;cooked());
 295         if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 296             temporaryRegisters.append(generator.newTemporary());
 297             generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 298         }
 299 
 300         // Evaluate Expression.
 301         temporaryRegisters.append(generator.newTemporary());
 302         generator.emitNode(temporaryRegisters.last().get(), templateExpression-&gt;value());
 303         generator.emitToString(temporaryRegisters.last().get(), temporaryRegisters.last().get());
 304     }
 305 
 306     // Evaluate tail TemplateString.
 307     ASSERT(templateString-&gt;value()-&gt;cooked());
 308     if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 309         temporaryRegisters.append(generator.newTemporary());
 310         generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 311     }
 312 
 313     if (temporaryRegisters.size() == 1)
 314         return generator.emitToString(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get());
 315 
 316     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
 317 }
 318 
 319 // ------------------------------ TaggedTemplateNode -----------------------------------
 320 
 321 RegisterID* TaggedTemplateNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 322 {
 323     ExpectedFunction expectedFunction = NoExpectedFunction;
 324     RefPtr&lt;RegisterID&gt; tag = nullptr;
 325     RefPtr&lt;RegisterID&gt; base = nullptr;
 326     if (!m_tag-&gt;isLocation()) {
 327         tag = generator.newTemporary();
 328         tag = generator.emitNode(tag.get(), m_tag);
 329     } else if (m_tag-&gt;isResolveNode()) {
 330         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_tag);
 331         const Identifier&amp; identifier = resolve-&gt;identifier();
 332         expectedFunction = generator.expectedFunctionForIdentifier(identifier);
 333 
 334         Variable var = generator.variable(identifier);
 335         if (RegisterID* local = var.local()) {
 336             generator.emitTDZCheckIfNecessary(var, local, nullptr);
 337             tag = generator.move(generator.newTemporary(), local);
 338         } else {
 339             tag = generator.newTemporary();
 340             base = generator.newTemporary();
 341 
 342             JSTextPosition newDivot = divotStart() + identifier.length();
 343             generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 344             generator.move(base.get(), generator.emitResolveScope(base.get(), var));
 345             generator.emitGetFromScope(tag.get(), base.get(), var, ThrowIfNotFound);
 346             generator.emitTDZCheckIfNecessary(var, tag.get(), nullptr);
 347         }
 348     } else if (m_tag-&gt;isBracketAccessorNode()) {
 349         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(m_tag);
 350         base = generator.newTemporary();
 351         base = generator.emitNode(base.get(), bracket-&gt;base());
 352         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(bracket-&gt;subscript());
 353         if (bracket-&gt;base()-&gt;isSuperNode()) {
 354             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 355             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
 356         } else
 357             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
 358     } else {
 359         ASSERT(m_tag-&gt;isDotAccessorNode());
 360         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(m_tag);
 361         base = generator.newTemporary();
 362         base = generator.emitNode(base.get(), dot-&gt;base());
 363         if (dot-&gt;base()-&gt;isSuperNode()) {
 364             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 365             tag = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), dot-&gt;identifier());
 366         } else
 367             tag = generator.emitGetById(generator.newTemporary(), base.get(), dot-&gt;identifier());
 368     }
 369 
 370     RefPtr&lt;RegisterID&gt; templateObject = generator.emitGetTemplateObject(nullptr, this);
 371 
 372     unsigned expressionsCount = 0;
 373     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 374         ++expressionsCount;
 375 
 376     CallArguments callArguments(generator, nullptr, 1 + expressionsCount);
 377     if (base)
 378         generator.move(callArguments.thisRegister(), base.get());
 379     else
 380         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 381 
 382     unsigned argumentIndex = 0;
 383     generator.move(callArguments.argumentRegister(argumentIndex++), templateObject.get());
 384     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 385         generator.emitNode(callArguments.argumentRegister(argumentIndex++), templateExpression-&gt;value());
 386 
 387     return generator.emitCallInTailPosition(generator.finalDestination(dst, tag.get()), tag.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 388 }
 389 
 390 // ------------------------------ ArrayNode ------------------------------------
 391 
 392 RegisterID* ArrayNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 393 {
 394     bool hadVariableExpression = false;
 395     unsigned length = 0;
 396 
 397     IndexingType recommendedIndexingType = ArrayWithUndecided;
 398     ElementNode* firstPutElement;
 399     for (firstPutElement = m_element; firstPutElement; firstPutElement = firstPutElement-&gt;next()) {
 400         if (firstPutElement-&gt;elision() || firstPutElement-&gt;value()-&gt;isSpreadExpression())
 401             break;
 402         if (!firstPutElement-&gt;value()-&gt;isConstant())
 403             hadVariableExpression = true;
 404         else
 405             recommendedIndexingType = leastUpperBoundOfIndexingTypeAndValue(recommendedIndexingType, static_cast&lt;ConstantNode*&gt;(firstPutElement-&gt;value())-&gt;jsValue(generator));
 406 
 407         ++length;
 408     }
 409 
 410     auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
 411         if (length &amp;&amp; !hadVariableExpression) {
 412             recommendedIndexingType |= CopyOnWrite;
 413             ASSERT(generator.vm().heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.
 414             auto* array = JSImmutableButterfly::create(generator.vm(), recommendedIndexingType, length);
 415             unsigned index = 0;
 416             for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
 417                 ASSERT(element-&gt;value()-&gt;isConstant());
 418                 array-&gt;setIndex(generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));
 419             }
 420             return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
 421         }
 422         return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
 423     };
 424 
 425     if (!firstPutElement &amp;&amp; !m_elision)
 426         return newArray(generator.finalDestination(dst), m_element, length, hadVariableExpression);
 427 
 428     if (firstPutElement &amp;&amp; firstPutElement-&gt;value()-&gt;isSpreadExpression()) {
 429         bool hasElision = m_elision;
 430         if (!hasElision) {
 431             for (ElementNode* node = firstPutElement; node; node = node-&gt;next()) {
 432                 if (node-&gt;elision()) {
 433                     hasElision = true;
 434                     break;
 435                 }
 436             }
 437         }
 438 
 439         if (!hasElision)
 440             return generator.emitNewArrayWithSpread(generator.finalDestination(dst), m_element);
 441     }
 442 
 443     RefPtr&lt;RegisterID&gt; array = newArray(generator.tempDestination(dst), m_element, length, hadVariableExpression);
 444     ElementNode* n = firstPutElement;
 445     for (; n; n = n-&gt;next()) {
 446         if (n-&gt;value()-&gt;isSpreadExpression())
 447             goto handleSpread;
 448         RefPtr&lt;RegisterID&gt; value = generator.emitNode(n-&gt;value());
 449         length += n-&gt;elision();
 450 
 451         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(length++));
 452         generator.emitDirectPutByVal(array.get(), index.get(), value.get());
 453     }
 454 
 455     if (m_elision) {
 456         RegisterID* value = generator.emitLoad(0, jsNumber(m_elision + length));
 457         generator.emitPutById(array.get(), generator.propertyNames().length, value);
 458     }
 459 
 460     return generator.move(dst, array.get());
 461 
 462 handleSpread:
 463     RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(length));
 464     auto spreader = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([array, index](BytecodeGenerator&amp; generator, RegisterID* value)
 465     {
 466         generator.emitDirectPutByVal(array.get(), index.get(), value);
 467         generator.emitInc(index.get());
 468     });
 469     for (; n; n = n-&gt;next()) {
 470         if (n-&gt;elision())
 471             generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(n-&gt;elision())), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 472         if (n-&gt;value()-&gt;isSpreadExpression()) {
 473             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;value());
 474             generator.emitEnumeration(spread, spread-&gt;expression(), spreader);
 475         } else {
 476             generator.emitDirectPutByVal(array.get(), index.get(), generator.emitNode(n-&gt;value()));
 477             generator.emitInc(index.get());
 478         }
 479     }
 480 
 481     if (m_elision) {
 482         generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(m_elision)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 483         generator.emitPutById(array.get(), generator.propertyNames().length, index.get());
 484     }
 485     return generator.move(dst, array.get());
 486 }
 487 
 488 bool ArrayNode::isSimpleArray() const
 489 {
 490     if (m_elision || m_optional)
 491         return false;
 492     for (ElementNode* ptr = m_element; ptr; ptr = ptr-&gt;next()) {
 493         if (ptr-&gt;elision())
 494             return false;
 495         if (ptr-&gt;value()-&gt;isSpreadExpression())
 496             return false;
 497     }
 498     return true;
 499 }
 500 
 501 ArgumentListNode* ArrayNode::toArgumentList(ParserArena&amp; parserArena, int lineNumber, int startPosition) const
 502 {
 503     ASSERT(!m_elision &amp;&amp; !m_optional);
 504     ElementNode* ptr = m_element;
 505     if (!ptr)
 506         return 0;
 507     JSTokenLocation location;
 508     location.line = lineNumber;
 509     location.startOffset = startPosition;
 510     ArgumentListNode* head = new (parserArena) ArgumentListNode(location, ptr-&gt;value());
 511     ArgumentListNode* tail = head;
 512     ptr = ptr-&gt;next();
 513     for (; ptr; ptr = ptr-&gt;next()) {
 514         ASSERT(!ptr-&gt;elision());
 515         tail = new (parserArena) ArgumentListNode(location, tail, ptr-&gt;value());
 516     }
 517     return head;
 518 }
 519 
 520 // ------------------------------ ObjectLiteralNode ----------------------------
 521 
 522 RegisterID* ObjectLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 523 {
 524     if (!m_list) {
 525         if (dst == generator.ignoredResult())
 526             return 0;
 527         return generator.emitNewObject(generator.finalDestination(dst));
 528     }
 529     RefPtr&lt;RegisterID&gt; newObj = generator.emitNewObject(generator.tempDestination(dst));
 530     generator.emitNode(newObj.get(), m_list);
 531     return generator.move(dst, newObj.get());
 532 }
 533 
 534 // ------------------------------ PropertyListNode -----------------------------
 535 
 536 static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
 537 {
 538     generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
 539 }
 540 
 541 RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype)
 542 {
 543     // Fast case: this loop just handles regular value properties.
 544     PropertyListNode* p = this;
 545     RegisterID* dst = nullptr;
 546     for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
 547         dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 548         emitPutConstantProperty(generator, dst, *p-&gt;m_node);
 549     }
 550 
 551     // Were there any get/set properties?
 552     if (p) {
 553         // Build a list of getter/setter pairs to try to put them at the same time. If we encounter
 554         // a computed property or a spread, just emit everything as that may override previous values.
 555         bool canOverrideProperties = false;
 556 
 557         typedef std::pair&lt;PropertyNode*, PropertyNode*&gt; GetterSetterPair;
 558         typedef HashMap&lt;UniquedStringImpl*, GetterSetterPair, IdentifierRepHash&gt; GetterSetterMap;
 559         GetterSetterMap instanceMap;
 560         GetterSetterMap staticMap;
 561 
 562         // Build a map, pairing get/set values together.
 563         for (PropertyListNode* q = p; q; q = q-&gt;m_next) {
 564             PropertyNode* node = q-&gt;m_node;
 565             if (node-&gt;m_type &amp; PropertyNode::Computed || node-&gt;m_type &amp; PropertyNode::Spread) {
 566                 canOverrideProperties = true;
 567                 break;
 568             }
 569 
 570             if (node-&gt;m_type &amp; PropertyNode::Constant)
 571                 continue;
 572 
 573             // Duplicates are possible.
 574             GetterSetterPair pair(node, static_cast&lt;PropertyNode*&gt;(nullptr));
 575             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 576             GetterSetterMap::AddResult result = map.add(node-&gt;name()-&gt;impl(), pair);
 577             auto&amp; resultPair = result.iterator-&gt;value;
 578             if (!result.isNewEntry) {
 579                 if (resultPair.first-&gt;m_type == node-&gt;m_type) {
 580                     resultPair.first-&gt;setIsOverriddenByDuplicate();
 581                     resultPair.first = node;
 582                 } else {
 583                     if (resultPair.second)
 584                         resultPair.second-&gt;setIsOverriddenByDuplicate();
 585                     resultPair.second = node;
 586                 }
 587             }
 588         }
 589 
 590         // Iterate over the remaining properties in the list.
 591         for (; p; p = p-&gt;m_next) {
 592             PropertyNode* node = p-&gt;m_node;
 593             dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 594 
 595             // Handle regular values.
 596             if (node-&gt;m_type &amp; PropertyNode::Constant) {
 597                 emitPutConstantProperty(generator, dst, *node);
 598                 continue;
 599             } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
 600                 generator.emitNode(dst, node-&gt;m_assign);
 601                 continue;
 602             }
 603 
 604             RefPtr&lt;RegisterID&gt; value = generator.emitNode(node-&gt;m_assign);
 605             bool needsSuperBinding = node-&gt;needsSuperBinding();
 606             if (needsSuperBinding)
 607                 emitPutHomeObject(generator, value.get(), dst);
 608 
 609             unsigned attributes = node-&gt;isClassProperty() ? (PropertyAttribute::Accessor | PropertyAttribute::DontEnum) : static_cast&lt;unsigned&gt;(PropertyAttribute::Accessor);
 610 
 611             ASSERT(node-&gt;m_type &amp; (PropertyNode::Getter | PropertyNode::Setter));
 612 
 613             // This is a get/set property which may be overridden by a computed property or spread later.
 614             if (canOverrideProperties) {
 615                 // Computed accessors.
 616                 if (node-&gt;m_type &amp; PropertyNode::Computed) {
 617                     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node-&gt;m_expression);
 618                     generator.emitSetFunctionNameIfNeeded(node-&gt;m_assign, value.get(), propertyName.get());
 619                     if (node-&gt;m_type &amp; PropertyNode::Getter)
 620                         generator.emitPutGetterByVal(dst, propertyName.get(), attributes, value.get());
 621                     else
 622                         generator.emitPutSetterByVal(dst, propertyName.get(), attributes, value.get());
 623                     continue;
 624                 }
 625 
 626                 if (node-&gt;m_type &amp; PropertyNode::Getter)
 627                     generator.emitPutGetterById(dst, *node-&gt;name(), attributes, value.get());
 628                 else
 629                     generator.emitPutSetterById(dst, *node-&gt;name(), attributes, value.get());
 630                 continue;
 631             }
 632 
 633             // This is a get/set property pair.
 634             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 635             GetterSetterMap::iterator it = map.find(node-&gt;name()-&gt;impl());
 636             ASSERT(it != map.end());
 637             GetterSetterPair&amp; pair = it-&gt;value;
 638 
 639             // Was this already generated as a part of its partner?
 640             if (pair.second == node || node-&gt;isOverriddenByDuplicate())
 641                 continue;
 642 
 643             // Generate the paired node now.
 644             RefPtr&lt;RegisterID&gt; getterReg;
 645             RefPtr&lt;RegisterID&gt; setterReg;
 646             RegisterID* secondReg = nullptr;
 647 
 648             if (node-&gt;m_type &amp; PropertyNode::Getter) {
 649                 getterReg = value;
 650                 if (pair.second) {
 651                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Setter);
 652                     setterReg = generator.emitNode(pair.second-&gt;m_assign);
 653                     secondReg = setterReg.get();
 654                 } else {
 655                     setterReg = generator.newTemporary();
 656                     generator.emitLoad(setterReg.get(), jsUndefined());
 657                 }
 658             } else {
 659                 ASSERT(node-&gt;m_type &amp; PropertyNode::Setter);
 660                 setterReg = value;
 661                 if (pair.second) {
 662                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Getter);
 663                     getterReg = generator.emitNode(pair.second-&gt;m_assign);
 664                     secondReg = getterReg.get();
 665                 } else {
 666                     getterReg = generator.newTemporary();
 667                     generator.emitLoad(getterReg.get(), jsUndefined());
 668                 }
 669             }
 670 
 671             ASSERT(!pair.second || needsSuperBinding == pair.second-&gt;needsSuperBinding());
 672             if (needsSuperBinding &amp;&amp; pair.second)
 673                 emitPutHomeObject(generator, secondReg, dst);
 674 
 675             generator.emitPutGetterSetter(dst, *node-&gt;name(), attributes, getterReg.get(), setterReg.get());
 676         }
 677     }
 678 
 679     return dstOrConstructor;
 680 }
 681 
 682 void PropertyListNode::emitPutConstantProperty(BytecodeGenerator&amp; generator, RegisterID* newObj, PropertyNode&amp; node)
 683 {
 684     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node.m_assign);
 685     if (node.needsSuperBinding())
 686         emitPutHomeObject(generator, value.get(), newObj);
 687 
 688     if (node.isClassProperty()) {
 689         ASSERT(node.needsSuperBinding());
 690         RefPtr&lt;RegisterID&gt; propertyNameRegister;
 691         if (node.name())
 692             propertyNameRegister = generator.emitLoad(nullptr, *node.name());
 693         else
 694             propertyNameRegister = generator.emitNode(node.m_expression);
 695 
 696         generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyNameRegister.get());
 697         generator.emitCallDefineProperty(newObj, propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
 698         return;
 699     }
 700     if (const auto* identifier = node.name()) {
 701         Optional&lt;uint32_t&gt; optionalIndex = parseIndex(*identifier);
 702         if (!optionalIndex) {
 703             generator.emitDirectPutById(newObj, *identifier, value.get(), node.putType());
 704             return;
 705         }
 706 
 707         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
 708         generator.emitDirectPutByVal(newObj, index.get(), value.get());
 709         return;
 710     }
 711     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
 712     generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
 713     generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
 714 }
 715 
 716 // ------------------------------ BracketAccessorNode --------------------------------
 717 
 718 static bool isNonIndexStringElement(ExpressionNode&amp; element)
 719 {
 720     return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
 721 }
 722 
 723 RegisterID* BracketAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 724 {
 725     if (m_base-&gt;isSuperNode()) {
 726         RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 727         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 728         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 729 
 730         if (isNonIndexStringElement(*m_subscript)) {
 731             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 732             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 733             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 734         } else  {
 735             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
 736             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 737             generator.emitGetByVal(finalDest.get(), superBase.get(), thisValue.get(), subscript.get());
 738         }
 739 
 740         generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 741         return finalDest.get();
 742     }
 743 
 744     RegisterID* ret;
 745     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 746 
 747     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
 748     RefPtr&lt;RegisterID&gt; base = subscriptIsNonIndexString
 749         ? generator.emitNode(m_base)
 750         : generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
 751 
 752     if (m_base-&gt;isOptionalChainBase())
 753         generator.emitOptionalCheck(base.get());
 754 
 755     if (subscriptIsNonIndexString) {
 756         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 757         ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
 758     } else {
 759         RegisterID* property = generator.emitNodeForProperty(m_subscript);
 760         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 761         ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
 762     }
 763 
 764     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 765     return ret;
 766 }
 767 
 768 // ------------------------------ DotAccessorNode --------------------------------
 769 
 770 RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 771 {
 772     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 773     bool baseIsSuper = m_base-&gt;isSuperNode();
 774 
 775     RefPtr&lt;RegisterID&gt; base;
 776     if (baseIsSuper)
 777         base = emitSuperBaseForCallee(generator);
 778     else {
 779         base = generator.emitNode(m_base);
 780         if (m_base-&gt;isOptionalChainBase())
 781             generator.emitOptionalCheck(base.get());
 782     }
 783 
 784     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 785     RegisterID* ret;
 786     if (baseIsSuper) {
 787         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 788         ret = generator.emitGetById(finalDest.get(), base.get(), thisValue.get(), m_ident);
 789     } else
 790         ret = generator.emitGetById(finalDest.get(), base.get(), m_ident);
 791     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 792     return ret;
 793 }
 794 
 795 // ------------------------------ ArgumentListNode -----------------------------
 796 
 797 RegisterID* ArgumentListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 798 {
 799     ASSERT(m_expr);
 800     return generator.emitNode(dst, m_expr);
 801 }
 802 
 803 // ------------------------------ NewExprNode ----------------------------------
 804 
 805 RegisterID* NewExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 806 {
 807     ExpectedFunction expectedFunction;
 808     if (m_expr-&gt;isResolveNode())
 809         expectedFunction = generator.expectedFunctionForIdentifier(static_cast&lt;ResolveNode*&gt;(m_expr)-&gt;identifier());
 810     else
 811         expectedFunction = NoExpectedFunction;
 812     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 813     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 814     CallArguments callArguments(generator, m_args);
 815     return generator.emitConstruct(returnValue.get(), func.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd());
 816 }
 817 
 818 CallArguments::CallArguments(BytecodeGenerator&amp; generator, ArgumentsNode* argumentsNode, unsigned additionalArguments)
 819     : m_argumentsNode(argumentsNode)
 820     , m_padding(0)
 821 {
 822     size_t argumentCountIncludingThis = 1 + additionalArguments; // &#39;this&#39; register.
 823     if (argumentsNode) {
 824         for (ArgumentListNode* node = argumentsNode-&gt;m_listNode; node; node = node-&gt;m_next)
 825             ++argumentCountIncludingThis;
 826     }
 827 
 828     m_argv.grow(argumentCountIncludingThis);
 829     for (int i = argumentCountIncludingThis - 1; i &gt;= 0; --i) {
 830         m_argv[i] = generator.newTemporary();
 831         ASSERT(static_cast&lt;size_t&gt;(i) == m_argv.size() - 1 || m_argv[i]-&gt;index() == m_argv[i + 1]-&gt;index() - 1);
 832     }
 833 
 834     // We need to ensure that the frame size is stack-aligned
 835     while ((CallFrame::headerSizeInRegisters + m_argv.size()) % stackAlignmentRegisters()) {
 836         m_argv.insert(0, generator.newTemporary());
 837         m_padding++;
 838     }
 839 
 840     while (stackOffset() % stackAlignmentRegisters()) {
 841         m_argv.insert(0, generator.newTemporary());
 842         m_padding++;
 843     }
 844 }
 845 
 846 // ------------------------------ EvalFunctionCallNode ----------------------------------
 847 
 848 RegisterID* EvalFunctionCallNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 849 {
 850     // We need try to load &#39;this&#39; before call eval in constructor, because &#39;this&#39; can created by &#39;super&#39; in some of the arrow function
 851     // var A = class A {
 852     //   constructor () { this.id = &#39;A&#39;; }
 853     // }
 854     //
 855     // var B = class B extend A {
 856     //    constructor () {
 857     //       var arrow = () =&gt; super();
 858     //       arrow();
 859     //       eval(&quot;this.id = &#39;B&#39;&quot;);
 860     //    }
 861     // }
 862     if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
 863         generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 864 
 865     Variable var = generator.variable(generator.propertyNames().eval);
 866     RefPtr&lt;RegisterID&gt; local = var.local();
 867     RefPtr&lt;RegisterID&gt; func;
 868     if (local) {
 869         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
 870         func = generator.move(generator.tempDestination(dst), local.get());
 871     } else
 872         func = generator.newTemporary();
 873     CallArguments callArguments(generator, m_args);
 874 
 875     if (local)
 876         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 877     else {
 878         JSTextPosition newDivot = divotStart() + 4;
 879         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 880         generator.move(
 881             callArguments.thisRegister(),
 882             generator.emitResolveScope(callArguments.thisRegister(), var));
 883         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
 884         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
 885     }
 886 
 887     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 888     if (isOptionalChainBase())
 889         generator.emitOptionalCheck(func.get());
 890 
 891     return generator.emitCallEval(returnValue.get(), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 892 }
 893 
 894 // ------------------------------ FunctionCallValueNode ----------------------------------
 895 
 896 RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 897 {
 898     if (m_expr-&gt;isSuperNode()) {
 899         RefPtr&lt;RegisterID&gt; func = emitGetSuperFunctionForConstruct(generator);
 900         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 901         CallArguments callArguments(generator, m_args);
 902 
 903         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 904         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 905         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 906 
 907         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 908         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 909 
 910         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 911             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 912 
 913         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 914         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 915         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 916         generator.emitLabel(thisIsEmptyLabel.get());
 917 
 918         generator.move(generator.thisRegister(), ret);
 919 
 920         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 921             generator.emitPutThisToArrowFunctionContextScope();
 922 
 923         return ret;
 924     }
 925 
 926     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 927     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 928     if (isOptionalChainBase())
 929         generator.emitOptionalCheck(func.get());
 930 
 931     CallArguments callArguments(generator, m_args);
 932     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 933     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 934     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 935     return ret;
 936 }
 937 
 938 // ------------------------------ FunctionCallResolveNode ----------------------------------
 939 
 940 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 941 {
 942     if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName())) {
 943         if (ASSERT_DISABLED)
 944             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 945     }
 946 
 947     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
 948 
 949     Variable var = generator.variable(m_ident);
 950     RefPtr&lt;RegisterID&gt; local = var.local();
 951     RefPtr&lt;RegisterID&gt; func;
 952     if (local) {
 953         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
 954         func = generator.move(generator.tempDestination(dst), local.get());
 955     } else
 956         func = generator.newTemporary();
 957     CallArguments callArguments(generator, m_args);
 958 
 959     if (local) {
 960         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 961         // This passes NoExpectedFunction because we expect that if the function is in a
 962         // local variable, then it&#39;s not one of our built-in constructors.
 963         expectedFunction = NoExpectedFunction;
 964     } else {
 965         JSTextPosition newDivot = divotStart() + m_ident.length();
 966         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 967         generator.move(
 968             callArguments.thisRegister(),
 969             generator.emitResolveScope(callArguments.thisRegister(), var));
 970         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
 971         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
 972     }
 973 
 974     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 975     if (isOptionalChainBase())
 976         generator.emitOptionalCheck(func.get());
 977 
 978     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 979     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 980     return ret;
 981 }
 982 
 983 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
 984 
 985 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 986 {
 987     return (this-&gt;*m_emitter)(generator, dst);
 988 }
 989 
 990 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
 991 {
 992     ArgumentListNode* node = m_args-&gt;m_listNode;
 993     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
 994     node = node-&gt;m_next;
 995     ASSERT(node-&gt;m_expr-&gt;isString());
 996     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
 997     ASSERT(!node-&gt;m_next);
 998     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
 999 }
1000 
1001 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1002 {
1003     ArgumentListNode* node = m_args-&gt;m_listNode;
1004     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1005     node = node-&gt;m_next;
1006     ASSERT(node-&gt;m_expr-&gt;isString());
1007     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1008     ASSERT(symbol);
1009     ASSERT(!node-&gt;m_next);
1010     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
1011 }
1012 
1013 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
1014 {
1015     ArgumentListNode* node = m_args-&gt;m_listNode;
1016     ASSERT(node-&gt;m_expr-&gt;isNumber());
1017     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
1018     int32_t index = static_cast&lt;int32_t&gt;(value);
1019     ASSERT(value == index);
1020     ASSERT(index &gt;= 0);
1021     ASSERT(!node-&gt;m_next);
1022 
1023     // The body functions of generator and async have different mechanism for arguments.
1024     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
1025     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
1026 
1027     return generator.emitGetArgument(generator.finalDestination(dst), index);
1028 }
1029 
1030 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argumentCount(BytecodeGenerator&amp; generator, RegisterID* dst)
1031 {
1032     ASSERT(!m_args-&gt;m_listNode);
1033 
1034     return generator.emitArgumentCount(generator.finalDestination(dst));
1035 }
1036 
1037 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1038 {
1039     ArgumentListNode* node = m_args-&gt;m_listNode;
1040     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1041     node = node-&gt;m_next;
1042     ASSERT(node-&gt;m_expr-&gt;isString());
1043     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1044     node = node-&gt;m_next;
1045     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1046 
1047     ASSERT(!node-&gt;m_next);
1048 
1049     return generator.move(dst, generator.emitDirectPutById(base.get(), ident, value.get(), PropertyNode::KnownDirect));
1050 }
1051 
1052 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1053 {
1054     ArgumentListNode* node = m_args-&gt;m_listNode;
1055     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1056     node = node-&gt;m_next;
1057     ASSERT(node-&gt;m_expr-&gt;isString());
1058     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1059     ASSERT(symbol);
1060     node = node-&gt;m_next;
1061     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1062 
1063     ASSERT(!node-&gt;m_next);
1064 
1065     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1066 }
1067 
1068 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1069 {
1070     ArgumentListNode* node = m_args-&gt;m_listNode;
1071     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1072     node = node-&gt;m_next;
1073     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1074     node = node-&gt;m_next;
1075     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1076 
1077     ASSERT(!node-&gt;m_next);
1078 
1079     return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
1080 }
1081 
1082 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
1083 {
1084     ArgumentListNode* node = m_args-&gt;m_listNode;
1085     RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
1086     node = node-&gt;m_next;
1087     RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(node);
1088     ASSERT(!node-&gt;m_next);
1089 
1090     RefPtr&lt;RegisterID&gt; finalDst = generator.finalDestination(dst);
1091     return generator.emitCallForwardArgumentsInTailPosition(finalDst.get(), function.get(), thisRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::No);
1092 }
1093 
1094 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwTypeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1095 {
1096     ArgumentListNode* node = m_args-&gt;m_listNode;
1097     ASSERT(!node-&gt;m_next);
1098     if (node-&gt;m_expr-&gt;isString()) {
1099         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1100         generator.emitThrowTypeError(ident);
1101     } else {
1102         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1103         generator.emitThrowStaticError(ErrorType::TypeError, message.get());
1104     }
1105     return dst;
1106 }
1107 
1108 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwRangeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1109 {
1110     ArgumentListNode* node = m_args-&gt;m_listNode;
1111     ASSERT(!node-&gt;m_next);
1112     if (node-&gt;m_expr-&gt;isString()) {
1113         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1114         generator.emitThrowRangeError(ident);
1115     } else {
1116         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1117         generator.emitThrowStaticError(ErrorType::RangeError, message.get());
1118     }
1119 
1120     return dst;
1121 }
1122 
1123 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwOutOfMemoryError(BytecodeGenerator&amp; generator, RegisterID* dst)
1124 {
1125     ASSERT(!m_args-&gt;m_listNode);
1126 
1127     generator.emitThrowOutOfMemoryError();
1128     return dst;
1129 }
1130 
1131 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tryGetById(BytecodeGenerator&amp; generator, RegisterID* dst)
1132 {
1133     ArgumentListNode* node = m_args-&gt;m_listNode;
1134     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1135     node = node-&gt;m_next;
1136 
1137     // Since this is a builtin we expect the creator to use a string literal as the second argument.
1138     ASSERT(node-&gt;m_expr-&gt;isString());
1139     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1140     ASSERT(!node-&gt;m_next);
1141 
1142     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
1143     return generator.emitTryGetById(finalDest.get(), base.get(), ident);
1144 }
1145 
1146 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toNumber(BytecodeGenerator&amp; generator, RegisterID* dst)
1147 {
1148     ArgumentListNode* node = m_args-&gt;m_listNode;
1149     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1150     ASSERT(!node-&gt;m_next);
1151 
1152     return generator.move(dst, generator.emitToNumber(generator.tempDestination(dst), src.get()));
1153 }
1154 
1155 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toString(BytecodeGenerator&amp; generator, RegisterID* dst)
1156 {
1157     ArgumentListNode* node = m_args-&gt;m_listNode;
1158     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1159     ASSERT(!node-&gt;m_next);
1160 
1161     return generator.move(dst, generator.emitToString(generator.tempDestination(dst), src.get()));
1162 }
1163 
1164 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1165 {
1166     ArgumentListNode* node = m_args-&gt;m_listNode;
1167     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1168     node = node-&gt;m_next;
1169 
1170     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
1171     if (node) {
1172         ASSERT(node-&gt;m_expr-&gt;isString());
1173         const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1174         ASSERT(!node-&gt;m_next);
1175         return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
1176     }
1177     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));
1178 }
1179 
1180 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1181 {
1182     ArgumentListNode* node = m_args-&gt;m_listNode;
1183     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1184     generator.emitNode(idValue.get(), node);
1185     SpeculatedType speculation = SpecNone;
1186     while (node-&gt;m_next) {
1187         node = node-&gt;m_next;
1188         ASSERT(node-&gt;m_expr-&gt;isString());
1189         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1190         speculation |= speculationFromString(ident.utf8().data());
1191     }
1192 
1193     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1194 }
1195 
1196 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1197 {
1198     ArgumentListNode* node = m_args-&gt;m_listNode;
1199     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1200     ASSERT(!node-&gt;m_next);
1201 
1202     return generator.move(dst, generator.emitIsJSArray(generator.tempDestination(dst), src.get()));
1203 }
1204 
1205 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isProxyObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1206 {
1207     ArgumentListNode* node = m_args-&gt;m_listNode;
1208     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1209     ASSERT(!node-&gt;m_next);
1210 
1211     return generator.move(dst, generator.emitIsProxyObject(generator.tempDestination(dst), src.get()));
1212 }
1213 
1214 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isRegExpObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1215 {
1216     ArgumentListNode* node = m_args-&gt;m_listNode;
1217     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1218     ASSERT(!node-&gt;m_next);
1219 
1220     return generator.move(dst, generator.emitIsRegExpObject(generator.tempDestination(dst), src.get()));
1221 }
1222 
1223 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1224 {
1225     ArgumentListNode* node = m_args-&gt;m_listNode;
1226     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1227     ASSERT(!node-&gt;m_next);
1228 
1229     return generator.move(dst, generator.emitIsObject(generator.tempDestination(dst), src.get()));
1230 }
1231 
1232 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isDerivedArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1233 {
1234     ArgumentListNode* node = m_args-&gt;m_listNode;
1235     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1236     ASSERT(!node-&gt;m_next);
1237 
1238     return generator.move(dst, generator.emitIsDerivedArray(generator.tempDestination(dst), src.get()));
1239 }
1240 
1241 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isMap(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1242 {
1243     ArgumentListNode* node = m_args-&gt;m_listNode;
1244     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1245     ASSERT(!node-&gt;m_next);
1246 
1247     return generator.move(dst, generator.emitIsMap(generator.tempDestination(dst), src.get()));
1248 }
1249 
1250 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isSet(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1251 {
1252     ArgumentListNode* node = m_args-&gt;m_listNode;
1253     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1254     ASSERT(!node-&gt;m_next);
1255 
1256     return generator.move(dst, generator.emitIsSet(generator.tempDestination(dst), src.get()));
1257 }
1258 
1259 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isUndefinedOrNull(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1260 {
1261     ArgumentListNode* node = m_args-&gt;m_listNode;
1262     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1263     ASSERT(!node-&gt;m_next);
1264 
1265     return generator.move(dst, generator.emitIsUndefinedOrNull(generator.tempDestination(dst), src.get()));
1266 }
1267 
1268 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1269 {
1270     ArgumentListNode* node = m_args-&gt;m_listNode;
1271     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);
1272     ASSERT(!node-&gt;m_next);
1273 
1274     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);
1275     generator.emitNewArrayWithSize(finalDestination.get(), size.get());
1276     return finalDestination.get();
1277 }
1278 
1279 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1280 {
1281     ArgumentListNode* node = m_args-&gt;m_listNode;
1282     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1283     node = node-&gt;m_next;
1284     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1285     node = node-&gt;m_next;
1286     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1287     ASSERT(!node-&gt;m_next);
1288 
1289     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1290     return dst;
1291 }
1292 
1293 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1294     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1295     { \
1296         ASSERT(!m_args); \
1297         ASSERT(type() == Type::Constant); \
1298         if (dst == generator.ignoredResult()) \
1299             return nullptr; \
1300         return generator.emitLoad(dst, generator.vm().bytecodeIntrinsicRegistry().name##Value(generator)); \
1301     }
1302     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
1303 #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
1304 
1305 // ------------------------------ FunctionCallBracketNode ----------------------------------
1306 
1307 RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1308 {
1309     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1310     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1311     bool baseIsSuper = m_base-&gt;isSuperNode();
1312     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
1313 
1314     RefPtr&lt;RegisterID&gt; base;
1315     if (baseIsSuper)
1316         base = emitSuperBaseForCallee(generator);
1317     else {
1318         if (subscriptIsNonIndexString)
1319             base = generator.emitNode(m_base);
1320         else
1321             base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
1322 
1323         if (m_base-&gt;isOptionalChainBase())
1324             generator.emitOptionalCheck(base.get());
1325     }
1326 
1327     RefPtr&lt;RegisterID&gt; thisRegister;
1328     if (baseIsSuper) {
1329         // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
1330         thisRegister = generator.ensureThis();
1331     }
1332     if (subscriptIsNonIndexString) {
1333         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1334         if (baseIsSuper)
1335             generator.emitGetById(function.get(), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
1336         else
1337             generator.emitGetById(function.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
1338     } else {
1339         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
1340         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1341         if (baseIsSuper)
1342             generator.emitGetByVal(function.get(), base.get(), thisRegister.get(), property.get());
1343         else
1344             generator.emitGetByVal(function.get(), base.get(), property.get());
1345     }
1346     if (isOptionalChainBase())
1347         generator.emitOptionalCheck(function.get());
1348 
1349     CallArguments callArguments(generator, m_args);
1350     if (baseIsSuper) {
1351         generator.emitTDZCheck(generator.thisRegister());
1352         generator.move(callArguments.thisRegister(), thisRegister.get());
1353     } else
1354         generator.move(callArguments.thisRegister(), base.get());
1355     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1356     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1357     return ret;
1358 }
1359 
1360 // ------------------------------ FunctionCallDotNode ----------------------------------
1361 
1362 RegisterID* FunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1363 {
1364     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1365     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1366     CallArguments callArguments(generator, m_args);
1367     bool baseIsSuper = m_base-&gt;isSuperNode();
1368     if (baseIsSuper)
1369         generator.move(callArguments.thisRegister(), generator.ensureThis());
1370     else {
1371         generator.emitNode(callArguments.thisRegister(), m_base);
1372         if (m_base-&gt;isOptionalChainBase())
1373             generator.emitOptionalCheck(callArguments.thisRegister());
1374     }
1375     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1376     if (baseIsSuper) {
1377         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
1378         generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
1379     } else
1380         generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
1381 
1382     if (isOptionalChainBase())
1383         generator.emitOptionalCheck(function.get());
1384 
1385     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1386     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1387     return ret;
1388 }
1389 
1390 static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
1391 
1392 RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1393 {
1394     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
1395     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
1396 
1397     if (m_base-&gt;isOptionalChainBase())
1398         generator.emitOptionalCheck(base.get());
1399 
1400     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1401 
1402     RefPtr&lt;RegisterID&gt; function;
1403     auto makeFunction = [&amp;] {
1404         if (m_base-&gt;isSuperNode()) {
1405             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1406             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
1407         } else
1408             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
1409 
1410         if (isOptionalChainBase())
1411             generator.emitOptionalCheck(function.get());
1412     };
1413 
1414     bool emitCallCheck = !generator.isBuiltinFunction();
1415     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1416         makeFunction();
1417         CallArguments callArguments(generator, m_args);
1418         generator.move(callArguments.thisRegister(), base.get());
1419         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1420         generator.move(dst, returnValue.get());
1421         return returnValue.get();
1422     }
1423 
1424     Ref&lt;Label&gt; realCall = generator.newLabel();
1425     Ref&lt;Label&gt; end = generator.newLabel();
1426 
1427     if (emitCallCheck) {
1428         makeFunction();
1429         generator.emitJumpIfNotFunctionCall(function.get(), realCall.get());
1430     }
1431     {
1432         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1433             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1434             ExpressionNode* subject = spread-&gt;expression();
1435             RefPtr&lt;RegisterID&gt; argumentsRegister;
1436             argumentsRegister = generator.emitNode(subject);
1437             generator.emitExpressionInfo(spread-&gt;divot(), spread-&gt;divotStart(), spread-&gt;divotEnd());
1438             RefPtr&lt;RegisterID&gt; thisRegister = generator.emitGetByVal(generator.newTemporary(), argumentsRegister.get(), generator.emitLoad(0, jsNumber(0)));
1439             generator.emitCallVarargsInTailPosition(returnValue.get(), base.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 1, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1440         } else if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1441             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1442             m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1443 
1444             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1445             CallArguments callArguments(generator, m_args);
1446             generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1447             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1448             m_args-&gt;m_listNode = oldList;
1449         } else {
1450             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1451             CallArguments callArguments(generator, m_args);
1452             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1453             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1454         }
1455     }
1456     if (emitCallCheck) {
1457         generator.emitJump(end.get());
1458         generator.emitLabel(realCall.get());
1459         {
1460             CallArguments callArguments(generator, m_args);
1461             generator.move(callArguments.thisRegister(), base.get());
1462             generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1463         }
1464         generator.emitLabel(end.get());
1465     }
1466     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1467     return returnValue.get();
1468 }
1469 
1470 static bool areTrivialApplyArguments(ArgumentsNode* args)
1471 {
1472     return !args-&gt;m_listNode || !args-&gt;m_listNode-&gt;m_expr || !args-&gt;m_listNode-&gt;m_next
1473         || (!args-&gt;m_listNode-&gt;m_next-&gt;m_next &amp;&amp; args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1474 }
1475 
1476 RegisterID* ApplyFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1477 {
1478     // A few simple cases can be trivially handled as ordinary function calls.
1479     // function.apply(), function.apply(arg) -&gt; identical to function.call
1480     // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
1481     bool mayBeCall = areTrivialApplyArguments(m_args);
1482 
1483     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
1484     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
1485 
1486     if (m_base-&gt;isOptionalChainBase())
1487         generator.emitOptionalCheck(base.get());
1488 
1489     RefPtr&lt;RegisterID&gt; function;
1490     auto makeFunction = [&amp;] {
1491         if (m_base-&gt;isSuperNode()) {
1492             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1493             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
1494         } else
1495             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
1496 
1497         if (isOptionalChainBase())
1498             generator.emitOptionalCheck(function.get());
1499     };
1500 
1501     bool emitCallCheck = !generator.isBuiltinFunction();
1502     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1503         makeFunction();
1504         CallArguments callArguments(generator, m_args);
1505         generator.move(callArguments.thisRegister(), base.get());
1506         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1507         generator.move(dst, returnValue.get());
1508         return returnValue.get();
1509     }
1510 
1511     Ref&lt;Label&gt; realCall = generator.newLabel();
1512     Ref&lt;Label&gt; end = generator.newLabel();
1513     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1514     if (emitCallCheck) {
1515         makeFunction();
1516         ASSERT(!m_base-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(m_base)-&gt;identifier() != &quot;Reflect&quot;);
1517         generator.emitJumpIfNotFunctionApply(function.get(), realCall.get());
1518     }
1519     if (mayBeCall) {
1520         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1521             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1522             if (m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1523                 SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1524                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.newTemporary(), base.get());
1525                 RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(0));
1526                 RefPtr&lt;RegisterID&gt; thisRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1527                 RefPtr&lt;RegisterID&gt; argumentsRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1528 
1529                 auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([&amp;thisRegister, &amp;argumentsRegister, &amp;index](BytecodeGenerator&amp; generator, RegisterID* value)
1530                 {
1531                     Ref&lt;Label&gt; haveThis = generator.newLabel();
1532                     Ref&lt;Label&gt; end = generator.newLabel();
1533                     RefPtr&lt;RegisterID&gt; compareResult = generator.newTemporary();
1534                     RefPtr&lt;RegisterID&gt; indexZeroCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(0)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1535                     generator.emitJumpIfFalse(indexZeroCompareResult.get(), haveThis.get());
1536                     generator.move(thisRegister.get(), value);
1537                     generator.emitLoad(index.get(), jsNumber(1));
1538                     generator.emitJump(end.get());
1539                     generator.emitLabel(haveThis.get());
1540                     RefPtr&lt;RegisterID&gt; indexOneCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(1)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1541                     generator.emitJumpIfFalse(indexOneCompareResult.get(), end.get());
1542                     generator.move(argumentsRegister.get(), value);
1543                     generator.emitLoad(index.get(), jsNumber(2));
1544                     generator.emitLabel(end.get());
1545                 });
1546                 generator.emitEnumeration(this, spread-&gt;expression(), extractor);
1547                 generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1548             } else if (m_args-&gt;m_listNode-&gt;m_next) {
1549                 ASSERT(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1550                 ASSERT(!m_args-&gt;m_listNode-&gt;m_next-&gt;m_next);
1551                 m_args-&gt;m_listNode = static_cast&lt;ArrayNode*&gt;(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr)-&gt;toArgumentList(generator.parserArena(), 0, 0);
1552                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1553                 CallArguments callArguments(generator, m_args);
1554                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1555                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1556             } else {
1557                 m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1558                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1559                 CallArguments callArguments(generator, m_args);
1560                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1561                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1562             }
1563             m_args-&gt;m_listNode = oldList;
1564         } else {
1565             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1566             CallArguments callArguments(generator, m_args);
1567             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1568             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1569         }
1570     } else {
1571         ASSERT(m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_next);
1572         RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1573         RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(m_args-&gt;m_listNode-&gt;m_expr);
1574         RefPtr&lt;RegisterID&gt; argsRegister;
1575         ArgumentListNode* args = m_args-&gt;m_listNode-&gt;m_next;
1576         argsRegister = generator.emitNode(args-&gt;m_expr);
1577 
1578         // Function.prototype.apply ignores extra arguments, but we still
1579         // need to evaluate them for side effects.
1580         while ((args = args-&gt;m_next))
1581             generator.emitNode(args-&gt;m_expr);
1582 
1583         generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1584     }
1585     if (emitCallCheck) {
1586         generator.emitJump(end.get());
1587         generator.emitLabel(realCall.get());
1588         CallArguments callArguments(generator, m_args);
1589         generator.move(callArguments.thisRegister(), base.get());
1590         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1591         generator.emitLabel(end.get());
1592     }
1593     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1594     return returnValue.get();
1595 }
1596 
1597 // ------------------------------ PostfixNode ----------------------------------
1598 
1599 static RegisterID* emitIncOrDec(BytecodeGenerator&amp; generator, RegisterID* srcDst, Operator oper)
1600 {
1601     return (oper == OpPlusPlus) ? generator.emitInc(srcDst) : generator.emitDec(srcDst);
1602 }
1603 
1604 static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
1605 {
1606     if (dst == srcDst)
1607         return generator.emitToNumber(generator.finalDestination(dst), srcDst);
1608     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumber(generator.tempDestination(dst), srcDst);
1609     emitIncOrDec(generator, srcDst, oper);
1610     return generator.move(dst, tmp.get());
1611 }
1612 
1613 RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1614 {
1615     if (dst == generator.ignoredResult())
1616         return PrefixNode::emitResolve(generator, dst);
1617 
1618     ASSERT(m_expr-&gt;isResolveNode());
1619     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1620     const Identifier&amp; ident = resolve-&gt;identifier();
1621 
1622     Variable var = generator.variable(ident);
1623     if (RegisterID* local = var.local()) {
1624         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1625         RefPtr&lt;RegisterID&gt; localReg = local;
1626         if (var.isReadOnly()) {
1627             generator.emitReadOnlyExceptionIfNeeded(var);
1628             localReg = generator.move(generator.tempDestination(dst), local);
1629         }
1630         RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), localReg.get(), m_operator);
1631         generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1632         return oldValue.get();
1633     }
1634 
1635     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1636     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
1637     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1638     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1639     if (var.isReadOnly()) {
1640         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1641         if (threwException)
1642             return value.get();
1643     }
1644     RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), value.get(), m_operator);
1645     if (!var.isReadOnly()) {
1646         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
1647         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
1648     }
1649 
1650     return oldValue.get();
1651 }
1652 
1653 RegisterID* PostfixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
1654 {
1655     if (dst == generator.ignoredResult())
1656         return PrefixNode::emitBracket(generator, dst);
1657 
1658     ASSERT(m_expr-&gt;isBracketAccessorNode());
1659     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
1660     ExpressionNode* baseNode = bracketAccessor-&gt;base();
1661     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
1662 
1663     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
1664     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
1665 
1666     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
1667     RefPtr&lt;RegisterID&gt; value;
1668     RefPtr&lt;RegisterID&gt; thisValue;
1669     if (baseNode-&gt;isSuperNode()) {
1670         thisValue = generator.ensureThis();
1671         value = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
1672     } else
1673         value = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
1674     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1675     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1676     if (baseNode-&gt;isSuperNode())
1677         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value.get());
1678     else
1679         generator.emitPutByVal(base.get(), property.get(), value.get());
1680     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1681     return generator.move(dst, oldValue);
1682 }
1683 
1684 RegisterID* PostfixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
1685 {
1686     if (dst == generator.ignoredResult())
1687         return PrefixNode::emitDot(generator, dst);
1688 
1689     ASSERT(m_expr-&gt;isDotAccessorNode());
1690     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
1691     ExpressionNode* baseNode = dotAccessor-&gt;base();
1692     bool baseIsSuper = baseNode-&gt;isSuperNode();
1693     const Identifier&amp; ident = dotAccessor-&gt;identifier();
1694 
1695     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
1696 
1697     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
1698     RefPtr&lt;RegisterID&gt; value;
1699     RefPtr&lt;RegisterID&gt; thisValue;
1700     if (baseIsSuper) {
1701         thisValue = generator.ensureThis();
1702         value = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), ident);
1703     } else
1704         value = generator.emitGetById(generator.newTemporary(), base.get(), ident);
1705     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1706     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1707     if (baseIsSuper)
1708         generator.emitPutById(base.get(), thisValue.get(), ident, value.get());
1709     else
1710         generator.emitPutById(base.get(), ident, value.get());
1711     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1712     return generator.move(dst, oldValue);
1713 }
1714 
1715 RegisterID* PostfixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1716 {
1717     if (m_expr-&gt;isResolveNode())
1718         return emitResolve(generator, dst);
1719 
1720     if (m_expr-&gt;isBracketAccessorNode())
1721         return emitBracket(generator, dst);
1722 
1723     if (m_expr-&gt;isDotAccessorNode())
1724         return emitDot(generator, dst);
1725 
1726     ASSERT(m_expr-&gt;isFunctionCall());
1727     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1728         ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
1729         : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
1730 }
1731 
1732 // ------------------------------ DeleteResolveNode -----------------------------------
1733 
1734 RegisterID* DeleteResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1735 {
1736     Variable var = generator.variable(m_ident);
1737     if (var.local()) {
1738         generator.emitTDZCheckIfNecessary(var, var.local(), nullptr);
1739         return generator.emitLoad(generator.finalDestination(dst), false);
1740     }
1741 
1742     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1743     RefPtr&lt;RegisterID&gt; base = generator.emitResolveScope(dst, var);
1744     generator.emitTDZCheckIfNecessary(var, nullptr, base.get());
1745     return generator.emitDeleteById(generator.finalDestination(dst, base.get()), base.get(), m_ident);
1746 }
1747 
1748 // ------------------------------ DeleteBracketNode -----------------------------------
1749 
1750 RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1751 {
1752     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
1753     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
1754 
1755     if (m_base-&gt;isOptionalChainBase())
1756         generator.emitOptionalCheck(r0.get());
1757 
1758     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);
1759     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1760     if (m_base-&gt;isSuperNode())
1761         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
1762     return generator.emitDeleteByVal(finalDest.get(), r0.get(), r1.get());
1763 }
1764 
1765 // ------------------------------ DeleteDotNode -----------------------------------
1766 
1767 RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1768 {
1769     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
1770     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
1771 
1772     if (m_base-&gt;isOptionalChainBase())
1773         generator.emitOptionalCheck(r0.get());
1774 
1775     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1776     if (m_base-&gt;isSuperNode())
1777         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
1778     return generator.emitDeleteById(finalDest.get(), r0.get(), m_ident);
1779 }
1780 
1781 // ------------------------------ DeleteValueNode -----------------------------------
1782 
1783 RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1784 {
1785     generator.emitNode(generator.ignoredResult(), m_expr);
1786 
1787     // delete on a non-location expression ignores the value and returns true
1788     return generator.emitLoad(generator.finalDestination(dst), true);
1789 }
1790 
1791 // ------------------------------ VoidNode -------------------------------------
1792 
1793 RegisterID* VoidNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1794 {
1795     if (dst == generator.ignoredResult()) {
1796         generator.emitNode(generator.ignoredResult(), m_expr);
1797         return 0;
1798     }
1799     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
1800     return generator.emitLoad(dst, jsUndefined());
1801 }
1802 
1803 // ------------------------------ TypeOfResolveNode -----------------------------------
1804 
1805 RegisterID* TypeOfResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1806 {
1807     Variable var = generator.variable(m_ident);
1808     if (RegisterID* local = var.local()) {
1809         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1810         if (dst == generator.ignoredResult())
1811             return 0;
1812         return generator.emitTypeOf(generator.finalDestination(dst), local);
1813     }
1814 
1815     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1816     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
1817     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1818     if (dst == generator.ignoredResult())
1819         return 0;
1820     return generator.emitTypeOf(generator.finalDestination(dst, scope.get()), value.get());
1821 }
1822 
1823 // ------------------------------ TypeOfValueNode -----------------------------------
1824 
1825 RegisterID* TypeOfValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1826 {
1827     if (dst == generator.ignoredResult()) {
1828         generator.emitNode(generator.ignoredResult(), m_expr);
1829         return 0;
1830     }
1831     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1832     return generator.emitTypeOf(generator.finalDestination(dst), src.get());
1833 }
1834 
1835 // ------------------------------ PrefixNode ----------------------------------
1836 
1837 RegisterID* PrefixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1838 {
1839     ASSERT(m_expr-&gt;isResolveNode());
1840     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1841     const Identifier&amp; ident = resolve-&gt;identifier();
1842 
1843     Variable var = generator.variable(ident);
1844     if (RegisterID* local = var.local()) {
1845         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1846         RefPtr&lt;RegisterID&gt; localReg = local;
1847         if (var.isReadOnly()) {
1848             generator.emitReadOnlyExceptionIfNeeded(var);
1849             localReg = generator.move(generator.tempDestination(dst), localReg.get());
1850         } else if (generator.shouldEmitTypeProfilerHooks()) {
1851             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
1852             generator.move(tempDst.get(), localReg.get());
1853             emitIncOrDec(generator, tempDst.get(), m_operator);
1854             generator.move(localReg.get(), tempDst.get());
1855             generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1856             return generator.move(dst, tempDst.get());
1857         }
1858         emitIncOrDec(generator, localReg.get(), m_operator);
1859         return generator.move(dst, localReg.get());
1860     }
1861 
1862     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1863     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
1864     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1865     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1866     if (var.isReadOnly()) {
1867         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1868         if (threwException)
1869             return value.get();
1870     }
1871 
1872     emitIncOrDec(generator, value.get(), m_operator);
1873     if (!var.isReadOnly()) {
1874         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
1875         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
1876     }
1877     return generator.move(dst, value.get());
1878 }
1879 
1880 RegisterID* PrefixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
1881 {
1882     ASSERT(m_expr-&gt;isBracketAccessorNode());
1883     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
1884     ExpressionNode* baseNode = bracketAccessor-&gt;base();
1885     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
1886 
1887     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
1888     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
1889     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
1890 
1891     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
1892     RegisterID* value;
1893     RefPtr&lt;RegisterID&gt; thisValue;
1894     if (baseNode-&gt;isSuperNode()) {
1895         thisValue = generator.ensureThis();
1896         value = generator.emitGetByVal(propDst.get(), base.get(), thisValue.get(), property.get());
1897     } else
1898         value = generator.emitGetByVal(propDst.get(), base.get(), property.get());
1899     emitIncOrDec(generator, value, m_operator);
1900     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1901     if (baseNode-&gt;isSuperNode())
1902         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
1903     else
1904         generator.emitPutByVal(base.get(), property.get(), value);
1905     generator.emitProfileType(value, divotStart(), divotEnd());
1906     return generator.move(dst, propDst.get());
1907 }
1908 
1909 RegisterID* PrefixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
1910 {
1911     ASSERT(m_expr-&gt;isDotAccessorNode());
1912     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
1913     ExpressionNode* baseNode = dotAccessor-&gt;base();
1914     const Identifier&amp; ident = dotAccessor-&gt;identifier();
1915 
1916     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
1917     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
1918 
1919     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
1920     RegisterID* value;
1921     RefPtr&lt;RegisterID&gt; thisValue;
1922     if (baseNode-&gt;isSuperNode()) {
1923         thisValue = generator.ensureThis();
1924         value = generator.emitGetById(propDst.get(), base.get(), thisValue.get(), ident);
1925     } else
1926         value = generator.emitGetById(propDst.get(), base.get(), ident);
1927     emitIncOrDec(generator, value, m_operator);
1928     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1929     if (baseNode-&gt;isSuperNode())
1930         generator.emitPutById(base.get(), thisValue.get(), ident, value);
1931     else
1932         generator.emitPutById(base.get(), ident, value);
1933     generator.emitProfileType(value, divotStart(), divotEnd());
1934     return generator.move(dst, propDst.get());
1935 }
1936 
1937 RegisterID* PrefixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1938 {
1939     if (m_expr-&gt;isResolveNode())
1940         return emitResolve(generator, dst);
1941 
1942     if (m_expr-&gt;isBracketAccessorNode())
1943         return emitBracket(generator, dst);
1944 
1945     if (m_expr-&gt;isDotAccessorNode())
1946         return emitDot(generator, dst);
1947 
1948     ASSERT(m_expr-&gt;isFunctionCall());
1949     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1950         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
1951         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
1952 }
1953 
1954 // ------------------------------ Unary Operation Nodes -----------------------------------
1955 
1956 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1957 {
1958     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
1959     generator.emitExpressionInfo(position(), position(), position());
1960     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));
1961 }
1962 
1963 // ------------------------------ UnaryPlusNode -----------------------------------
1964 
1965 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1966 {
1967     ASSERT(opcodeID() == op_to_number);
1968     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
1969     generator.emitExpressionInfo(position(), position(), position());
1970     return generator.emitToNumber(generator.finalDestination(dst), src.get());
1971 }
1972 
1973 // ------------------------------ LogicalNotNode -----------------------------------
1974 
1975 void LogicalNotNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
1976 {
1977     if (UNLIKELY(needsDebugHook()))
1978         generator.emitDebugHook(this);
1979 
1980     // Reverse the true and false targets.
1981     generator.emitNodeInConditionContext(expr(), falseTarget, trueTarget, invert(fallThroughMode));
1982 }
1983 
1984 
1985 // ------------------------------ Binary Operation Nodes -----------------------------------
1986 
1987 // BinaryOpNode::emitStrcat:
1988 //
1989 // This node generates an op_strcat operation.  This opcode can handle concatenation of three or
1990 // more values, where we can determine a set of separate op_add operations would be operating on
1991 // string values.
1992 //
1993 // This function expects to be operating on a graph of AST nodes looking something like this:
1994 //
1995 //     (a)...     (b)
1996 //          \   /
1997 //           (+)     (c)
1998 //              \   /
1999 //      [d]     ((+))
2000 //         \    /
2001 //          [+=]
2002 //
2003 // The assignment operation is optional, if it exists the register holding the value on the
2004 // lefthand side of the assignment should be passing as the optional &#39;lhs&#39; argument.
2005 //
2006 // The method should be called on the node at the root of the tree of regular binary add
2007 // operations (marked in the diagram with a double set of parentheses).  This node must
2008 // be performing a string concatenation (determined by statically detecting that at least
2009 // one child must be a string).
2010 //
2011 // Since the minimum number of values being concatenated together is expected to be 3, if
2012 // a lhs to a concatenating assignment is not provided then the  root add should have at
2013 // least one left child that is also an add that can be determined to be operating on strings.
2014 //
2015 RegisterID* BinaryOpNode::emitStrcat(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* lhs, ReadModifyResolveNode* emitExpressionInfoForMe)
2016 {
2017     ASSERT(isAdd());
2018     ASSERT(resultDescriptor().definitelyIsString());
2019 
2020     // Create a list of expressions for all the adds in the tree of nodes we can convert into
2021     // a string concatenation.  The rightmost node (c) is added first.  The rightmost node is
2022     // added first, and the leftmost child is never added, so the vector produced for the
2023     // example above will be [ c, b ].
2024     Vector&lt;ExpressionNode*, 16&gt; reverseExpressionList;
2025     reverseExpressionList.append(m_expr2);
2026 
2027     // Examine the left child of the add.  So long as this is a string add, add its right-child
2028     // to the list, and keep processing along the left fork.
2029     ExpressionNode* leftMostAddChild = m_expr1;
2030     while (leftMostAddChild-&gt;isAdd() &amp;&amp; leftMostAddChild-&gt;resultDescriptor().definitelyIsString()) {
2031         reverseExpressionList.append(static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr2);
2032         leftMostAddChild = static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr1;
2033     }
2034 
2035     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
2036 
2037     // If there is an assignment, allocate a temporary to hold the lhs after conversion.
2038     // We could possibly avoid this (the lhs is converted last anyway, we could let the
2039     // op_strcat node handle its conversion if required).
2040     if (lhs)
2041         temporaryRegisters.append(generator.newTemporary());
2042 
2043     // Emit code for the leftmost node ((a) in the example).
2044     temporaryRegisters.append(generator.newTemporary());
2045     RegisterID* leftMostAddChildTempRegister = temporaryRegisters.last().get();
2046     generator.emitNode(leftMostAddChildTempRegister, leftMostAddChild);
2047 
2048     // Note on ordering of conversions:
2049     //
2050     // We maintain the same ordering of conversions as we would see if the concatenations
2051     // was performed as a sequence of adds (otherwise this optimization could change
2052     // behaviour should an object have been provided a valueOf or toString method).
2053     //
2054     // Considering the above example, the sequnce of execution is:
2055     //     * evaluate operand (a)
2056     //     * evaluate operand (b)
2057     //     * convert (a) to primitive   &lt;-  (this would be triggered by the first add)
2058     //     * convert (b) to primitive   &lt;-  (ditto)
2059     //     * evaluate operand (c)
2060     //     * convert (c) to primitive   &lt;-  (this would be triggered by the second add)
2061     // And optionally, if there is an assignment:
2062     //     * convert (d) to primitive   &lt;-  (this would be triggered by the assigning addition)
2063     //
2064     // As such we do not plant an op to convert the leftmost child now.  Instead, use
2065     // &#39;leftMostAddChildTempRegister&#39; as a flag to trigger generation of the conversion
2066     // once the second node has been generated.  However, if the leftmost child is an
2067     // immediate we can trivially determine that no conversion will be required.
2068     // If this is the case
2069     if (leftMostAddChild-&gt;isString())
2070         leftMostAddChildTempRegister = 0;
2071 
2072     while (reverseExpressionList.size()) {
2073         ExpressionNode* node = reverseExpressionList.last();
2074         reverseExpressionList.removeLast();
2075 
2076         // Emit the code for the current node.
2077         temporaryRegisters.append(generator.newTemporary());
2078         generator.emitNode(temporaryRegisters.last().get(), node);
2079 
2080         // On the first iteration of this loop, when we first reach this point we have just
2081         // generated the second node, which means it is time to convert the leftmost operand.
2082         if (leftMostAddChildTempRegister) {
2083             generator.emitToPrimitive(leftMostAddChildTempRegister, leftMostAddChildTempRegister);
2084             leftMostAddChildTempRegister = 0; // Only do this once.
2085         }
2086         // Plant a conversion for this node, if necessary.
2087         if (!node-&gt;isString())
2088             generator.emitToPrimitive(temporaryRegisters.last().get(), temporaryRegisters.last().get());
2089     }
2090     ASSERT(temporaryRegisters.size() &gt;= 3);
2091 
2092     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2093     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2094     if (emitExpressionInfoForMe)
2095         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2096     // If there is an assignment convert the lhs now.  This will also copy lhs to
2097     // the temporary register we allocated for it.
2098     if (lhs)
2099         generator.emitToPrimitive(temporaryRegisters[0].get(), lhs);
2100 
2101     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
2102 }
2103 
2104 void BinaryOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2105 {
2106     TriState branchCondition;
2107     ExpressionNode* branchExpression;
2108     tryFoldToBranch(generator, branchCondition, branchExpression);
2109 
2110     if (UNLIKELY(needsDebugHook())) {
2111         if (branchCondition != MixedTriState)
2112             generator.emitDebugHook(this);
2113     }
2114 
2115     if (branchCondition == MixedTriState)
2116         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
2117     else if (branchCondition == TrueTriState)
2118         generator.emitNodeInConditionContext(branchExpression, trueTarget, falseTarget, fallThroughMode);
2119     else
2120         generator.emitNodeInConditionContext(branchExpression, falseTarget, trueTarget, invert(fallThroughMode));
2121 }
2122 
2123 static inline bool canFoldToBranch(OpcodeID opcodeID, ExpressionNode* branchExpression, JSValue constant)
2124 {
2125     ResultType expressionType = branchExpression-&gt;resultDescriptor();
2126 
2127     if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isBoolean())
2128         return true;
2129     else if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isInt32() &amp;&amp; (constant.asInt32() == 0 || constant.asInt32() == 1))
2130         return opcodeID == op_eq || opcodeID == op_neq; // Strict equality is false in the case of type mismatch.
2131     else if (expressionType.isInt32() &amp;&amp; constant.isInt32() &amp;&amp; constant.asInt32() == 0)
2132         return true;
2133 
2134     return false;
2135 }
2136 
2137 void BinaryOpNode::tryFoldToBranch(BytecodeGenerator&amp; generator, TriState&amp; branchCondition, ExpressionNode*&amp; branchExpression)
2138 {
2139     branchCondition = MixedTriState;
2140     branchExpression = 0;
2141 
2142     ConstantNode* constant = 0;
2143     if (m_expr1-&gt;isConstant()) {
2144         constant = static_cast&lt;ConstantNode*&gt;(m_expr1);
2145         branchExpression = m_expr2;
2146     } else if (m_expr2-&gt;isConstant()) {
2147         constant = static_cast&lt;ConstantNode*&gt;(m_expr2);
2148         branchExpression = m_expr1;
2149     }
2150 
2151     if (!constant)
2152         return;
2153     ASSERT(branchExpression);
2154 
2155     OpcodeID opcodeID = this-&gt;opcodeID();
2156     JSValue value = constant-&gt;jsValue(generator);
2157     bool canFoldToBranch = JSC::canFoldToBranch(opcodeID, branchExpression, value);
2158     if (!canFoldToBranch)
2159         return;
2160 
2161     if (opcodeID == op_eq || opcodeID == op_stricteq)
2162         branchCondition = triState(value.pureToBoolean());
2163     else if (opcodeID == op_neq || opcodeID == op_nstricteq)
2164         branchCondition = triState(!value.pureToBoolean());
2165 }
2166 
2167 RegisterID* BinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2168 {
2169     OpcodeID opcodeID = this-&gt;opcodeID();
2170 
2171     if (opcodeID == op_less || opcodeID == op_lesseq || opcodeID == op_greater || opcodeID == op_greatereq) {
2172         auto isUInt32 = [&amp;] (ExpressionNode* node) -&gt; Optional&lt;UInt32Result&gt; {
2173             if (node-&gt;isBinaryOpNode() &amp;&amp; static_cast&lt;BinaryOpNode*&gt;(node)-&gt;opcodeID() == op_urshift)
2174                 return UInt32Result::UInt32;
2175             if (node-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(node)-&gt;isIntegerNode()) {
2176                 auto value = jsNumber(static_cast&lt;NumberNode*&gt;(node)-&gt;value());
2177                 if (value.isInt32() &amp;&amp; value.asInt32() &gt;= 0)
2178                     return UInt32Result::Constant;
2179             }
2180             return WTF::nullopt;
2181         };
2182         auto leftResult = isUInt32(m_expr1);
2183         auto rightResult = isUInt32(m_expr2);
2184         if ((leftResult &amp;&amp; rightResult) &amp;&amp; (leftResult.value() == UInt32Result::UInt32 || rightResult.value() == UInt32Result::UInt32)) {
2185             auto* left = m_expr1;
2186             auto* right = m_expr2;
2187             if (left-&gt;isBinaryOpNode()) {
2188                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(left)-&gt;opcodeID() == op_urshift);
2189                 static_cast&lt;BinaryOpNode*&gt;(left)-&gt;m_shouldToUnsignedResult = false;
2190             }
2191             if (right-&gt;isBinaryOpNode()) {
2192                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(right)-&gt;opcodeID() == op_urshift);
2193                 static_cast&lt;BinaryOpNode*&gt;(right)-&gt;m_shouldToUnsignedResult = false;
2194             }
2195             RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2196             RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2197             generator.emitExpressionInfo(position(), position(), position());
2198 
2199             // Since the both sides only accept Int32, replacing operands is not observable to users.
2200             bool replaceOperands = false;
2201             OpcodeID resultOp = opcodeID;
2202             switch (opcodeID) {
2203             case op_less:
2204                 resultOp = op_below;
2205                 break;
2206             case op_lesseq:
2207                 resultOp = op_beloweq;
2208                 break;
2209             case op_greater:
2210                 resultOp = op_below;
2211                 replaceOperands = true;
2212                 break;
2213             case op_greatereq:
2214                 resultOp = op_beloweq;
2215                 replaceOperands = true;
2216                 break;
2217             default:
2218                 RELEASE_ASSERT_NOT_REACHED();
2219             }
2220             OperandTypes operandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor());
2221             if (replaceOperands) {
2222                 std::swap(src1, src2);
2223                 operandTypes = OperandTypes(right-&gt;resultDescriptor(), left-&gt;resultDescriptor());
2224             }
2225             return generator.emitBinaryOp(resultOp, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), operandTypes);
2226         }
2227     }
2228 
2229     if (opcodeID == op_add &amp;&amp; m_expr1-&gt;isAdd() &amp;&amp; m_expr1-&gt;resultDescriptor().definitelyIsString()) {
2230         generator.emitExpressionInfo(position(), position(), position());
2231         return emitStrcat(generator, dst);
2232     }
2233 
2234     if (opcodeID == op_neq) {
2235         if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2236             RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2237             generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2238             return generator.emitUnaryOp&lt;OpNeqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2239         }
2240     }
2241 
2242     ExpressionNode* left = m_expr1;
2243     ExpressionNode* right = m_expr2;
2244     if (opcodeID == op_neq || opcodeID == op_nstricteq) {
2245         if (left-&gt;isString())
2246             std::swap(left, right);
2247     }
2248 
2249     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2250     bool wasTypeof = generator.lastOpcodeID() == op_typeof;
2251     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2252     generator.emitExpressionInfo(position(), position(), position());
2253     if (wasTypeof &amp;&amp; (opcodeID == op_neq || opcodeID == op_nstricteq)) {
2254         RefPtr&lt;RegisterID&gt; tmp = generator.tempDestination(dst);
2255         if (opcodeID == op_neq)
2256             generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2257         else if (opcodeID == op_nstricteq)
2258             generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2259         else
2260             RELEASE_ASSERT_NOT_REACHED();
2261         return generator.emitUnaryOp&lt;OpNot&gt;(generator.finalDestination(dst, tmp.get()), tmp.get());
2262     }
2263     RegisterID* result = generator.emitBinaryOp(opcodeID, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor()));
2264     if (m_shouldToUnsignedResult) {
2265         if (opcodeID == op_urshift &amp;&amp; dst != generator.ignoredResult())
2266             return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2267     }
2268     return result;
2269 }
2270 
2271 RegisterID* EqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2272 {
2273     if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2274         RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2275         generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2276         return generator.emitUnaryOp&lt;OpEqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2277     }
2278 
2279     ExpressionNode* left = m_expr1;
2280     ExpressionNode* right = m_expr2;
2281     if (left-&gt;isString())
2282         std::swap(left, right);
2283 
2284     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2285     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2286     return generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2287 }
2288 
2289 RegisterID* StrictEqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2290 {
2291     ExpressionNode* left = m_expr1;
2292     ExpressionNode* right = m_expr2;
2293     if (left-&gt;isString())
2294         std::swap(left, right);
2295 
2296     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2297     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2298     return generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2299 }
2300 
2301 RegisterID* ThrowableBinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2302 {
2303     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2304     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(m_expr2);
2305     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2306     return generator.emitBinaryOp(opcodeID(), generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(m_expr1-&gt;resultDescriptor(), m_expr2-&gt;resultDescriptor()));
2307 }
2308 
2309 RegisterID* InstanceOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2310 {
2311     RefPtr&lt;RegisterID&gt; hasInstanceValue = generator.newTemporary();
2312     RefPtr&lt;RegisterID&gt; isObject = generator.newTemporary();
2313     RefPtr&lt;RegisterID&gt; isCustom = generator.newTemporary();
2314     RefPtr&lt;RegisterID&gt; prototype = generator.newTemporary();
2315     RefPtr&lt;RegisterID&gt; value = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2316     RefPtr&lt;RegisterID&gt; constructor = generator.emitNode(m_expr2);
2317     RefPtr&lt;RegisterID&gt; dstReg = generator.finalDestination(dst, value.get());
2318     Ref&lt;Label&gt; custom = generator.newLabel();
2319     Ref&lt;Label&gt; done = generator.newLabel();
2320     Ref&lt;Label&gt; typeError = generator.newLabel();
2321 
2322     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2323     generator.emitIsObject(isObject.get(), constructor.get());
2324     generator.emitJumpIfFalse(isObject.get(), typeError.get());
2325 
2326     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2327     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm().propertyNames-&gt;hasInstanceSymbol);
2328 
2329     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2330     generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
2331 
2332     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2333     generator.emitJumpIfTrue(isCustom.get(), custom.get());
2334 
2335     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2336     generator.emitGetById(prototype.get(), constructor.get(), generator.vm().propertyNames-&gt;prototype);
2337 
2338     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2339     generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
2340 
2341     generator.emitJump(done.get());
2342 
2343     generator.emitLabel(typeError.get());
2344     generator.emitThrowTypeError(&quot;Right hand side of instanceof is not an object&quot;);
2345 
2346     generator.emitLabel(custom.get());
2347 
2348     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2349     generator.emitInstanceOfCustom(dstReg.get(), value.get(), constructor.get(), hasInstanceValue.get());
2350 
2351     generator.emitLabel(done.get());
2352 
2353     return dstReg.get();
2354 }
2355 
2356 // ------------------------------ InNode ----------------------------
2357 
2358 RegisterID* InNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2359 {
2360     if (isNonIndexStringElement(*m_expr1)) {
2361         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2362         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2363         return generator.emitInById(generator.finalDestination(dst, base.get()), base.get(), static_cast&lt;StringNode*&gt;(m_expr1)-&gt;value());
2364     }
2365 
2366     RefPtr&lt;RegisterID&gt; key = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2367     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2368     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2369     return generator.emitInByVal(generator.finalDestination(dst, key.get()), key.get(), base.get());
2370 }
2371 
2372 
2373 // ------------------------------ LogicalOpNode ----------------------------
2374 
2375 RegisterID* LogicalOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2376 {
2377     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
2378     Ref&lt;Label&gt; target = generator.newLabel();
2379 
2380     generator.emitNode(temp.get(), m_expr1);
2381     if (m_operator == OpLogicalAnd)
2382         generator.emitJumpIfFalse(temp.get(), target.get());
2383     else
2384         generator.emitJumpIfTrue(temp.get(), target.get());
2385     generator.emitNodeInTailPosition(temp.get(), m_expr2);
2386     generator.emitLabel(target.get());
2387 
2388     return generator.move(dst, temp.get());
2389 }
2390 
2391 void LogicalOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2392 {
2393     if (UNLIKELY(needsDebugHook()))
2394         generator.emitDebugHook(this);
2395 
2396     Ref&lt;Label&gt; afterExpr1 = generator.newLabel();
2397     if (m_operator == OpLogicalAnd)
2398         generator.emitNodeInConditionContext(m_expr1, afterExpr1.get(), falseTarget, FallThroughMeansTrue);
2399     else
2400         generator.emitNodeInConditionContext(m_expr1, trueTarget, afterExpr1.get(), FallThroughMeansFalse);
2401     generator.emitLabel(afterExpr1.get());
2402 
2403     generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
2404 }
2405 
2406 // ------------------------------ CoalesceNode ----------------------------
2407 
2408 RegisterID* CoalesceNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2409 {
2410     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
2411     Ref&lt;Label&gt; endLabel = generator.newLabel();
2412 
2413     if (m_hasAbsorbedOptionalChain)
2414         generator.pushOptionalChainTarget();
2415     generator.emitNode(temp.get(), m_expr1);
2416     generator.emitJumpIfFalse(generator.emitIsUndefinedOrNull(generator.newTemporary(), temp.get()), endLabel.get());
2417 
2418     if (m_hasAbsorbedOptionalChain)
2419         generator.popOptionalChainTarget();
2420     generator.emitNodeInTailPosition(temp.get(), m_expr2);
2421 
2422     generator.emitLabel(endLabel.get());
2423     return generator.move(dst, temp.get());
2424 }
2425 
2426 // ------------------------------ OptionalChainNode ----------------------------
2427 
2428 RegisterID* OptionalChainNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2429 {
2430     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
2431 
2432     if (m_isOutermost)
2433         generator.pushOptionalChainTarget();
2434     generator.emitNodeInTailPosition(finalDest.get(), m_expr);
2435     if (m_isOutermost)
2436         generator.popOptionalChainTarget(finalDest.get(), m_expr-&gt;isDeleteNode());
2437 
2438     return finalDest.get();
2439 }
2440 
2441 // ------------------------------ ConditionalNode ------------------------------
2442 
2443 RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2444 {
2445     RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
2446     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2447     Ref&lt;Label&gt; afterElse = generator.newLabel();
2448 
2449     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2450     generator.emitNodeInConditionContext(m_logical, beforeThen.get(), beforeElse.get(), FallThroughMeansTrue);
2451     generator.emitLabel(beforeThen.get());
2452 
2453     generator.emitProfileControlFlow(m_expr1-&gt;startOffset());
2454     generator.emitNodeInTailPosition(newDst.get(), m_expr1);
2455     generator.emitJump(afterElse.get());
2456 
2457     generator.emitLabel(beforeElse.get());
2458     generator.emitProfileControlFlow(m_expr1-&gt;endOffset() + 1);
2459     generator.emitNodeInTailPosition(newDst.get(), m_expr2);
2460 
2461     generator.emitLabel(afterElse.get());
2462 
2463     generator.emitProfileControlFlow(m_expr2-&gt;endOffset() + 1);
2464 
2465     return newDst.get();
2466 }
2467 
2468 // ------------------------------ ReadModifyResolveNode -----------------------------------
2469 
2470 // FIXME: should this be moved to be a method on BytecodeGenerator?
2471 static ALWAYS_INLINE RegisterID* emitReadModifyAssignment(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* src1, ExpressionNode* m_right, Operator oper, OperandTypes types, ReadModifyResolveNode* emitExpressionInfoForMe = 0)
2472 {
2473     OpcodeID opcodeID;
2474     switch (oper) {
2475         case OpMultEq:
2476             opcodeID = op_mul;
2477             break;
2478         case OpDivEq:
2479             opcodeID = op_div;
2480             break;
2481         case OpPlusEq:
2482             if (m_right-&gt;isAdd() &amp;&amp; m_right-&gt;resultDescriptor().definitelyIsString())
2483                 return static_cast&lt;AddNode*&gt;(m_right)-&gt;emitStrcat(generator, dst, src1, emitExpressionInfoForMe);
2484             opcodeID = op_add;
2485             break;
2486         case OpMinusEq:
2487             opcodeID = op_sub;
2488             break;
2489         case OpLShift:
2490             opcodeID = op_lshift;
2491             break;
2492         case OpRShift:
2493             opcodeID = op_rshift;
2494             break;
2495         case OpURShift:
2496             opcodeID = op_urshift;
2497             break;
2498         case OpAndEq:
2499             opcodeID = op_bitand;
2500             break;
2501         case OpXOrEq:
2502             opcodeID = op_bitxor;
2503             break;
2504         case OpOrEq:
2505             opcodeID = op_bitor;
2506             break;
2507         case OpModEq:
2508             opcodeID = op_mod;
2509             break;
2510         case OpPowEq:
2511             opcodeID = op_pow;
2512             break;
2513         default:
2514             RELEASE_ASSERT_NOT_REACHED();
2515             return dst;
2516     }
2517 
2518     RegisterID* src2 = generator.emitNode(m_right);
2519 
2520     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2521     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2522     if (emitExpressionInfoForMe)
2523         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2524     RegisterID* result = generator.emitBinaryOp(opcodeID, dst, src1, src2, types);
2525     if (oper == OpURShift)
2526         return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2527     return result;
2528 }
2529 
2530 RegisterID* ReadModifyResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2531 {
2532     JSTextPosition newDivot = divotStart() + m_ident.length();
2533     Variable var = generator.variable(m_ident);
2534     if (RegisterID* local = var.local()) {
2535         generator.emitTDZCheckIfNecessary(var, local, nullptr);
2536         if (var.isReadOnly()) {
2537             generator.emitReadOnlyExceptionIfNeeded(var);
2538             RegisterID* result = emitReadModifyAssignment(generator, generator.finalDestination(dst), local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2539             generator.emitProfileType(result, divotStart(), divotEnd());
2540             return result;
2541         }
2542 
2543         if (generator.leftHandSideNeedsCopy(m_rightHasAssignments, m_right-&gt;isPure(generator))) {
2544             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
2545             generator.move(result.get(), local);
2546             emitReadModifyAssignment(generator, result.get(), result.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2547             generator.move(local, result.get());
2548             generator.emitProfileType(local, divotStart(), divotEnd());
2549             return generator.move(dst, result.get());
2550         }
2551 
2552         RegisterID* result = emitReadModifyAssignment(generator, local, local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2553         generator.emitProfileType(result, divotStart(), divotEnd());
2554         return generator.move(dst, result);
2555     }
2556 
2557     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
2558     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2559     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
2560     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
2561     if (var.isReadOnly()) {
2562         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2563         if (threwException)
2564             return value.get();
2565     }
2566     RefPtr&lt;RegisterID&gt; result = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()), this);
2567     RegisterID* returnResult = result.get();
2568     if (!var.isReadOnly()) {
2569         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
2570         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2571     }
2572     return returnResult;
2573 }
2574 
2575 static InitializationMode initializationModeForAssignmentContext(AssignmentContext assignmentContext)
2576 {
2577     switch (assignmentContext) {
2578     case AssignmentContext::DeclarationStatement:
2579         return InitializationMode::Initialization;
2580     case AssignmentContext::ConstDeclarationStatement:
2581         return InitializationMode::ConstInitialization;
2582     case AssignmentContext::AssignmentExpression:
2583         return InitializationMode::NotInitialization;
2584     }
2585 
2586     ASSERT_NOT_REACHED();
2587     return InitializationMode::NotInitialization;
2588 }
2589 
2590 // ------------------------------ AssignResolveNode -----------------------------------
2591 
2592 RegisterID* AssignResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2593 {
2594     Variable var = generator.variable(m_ident);
2595     bool isReadOnly = var.isReadOnly() &amp;&amp; m_assignmentContext != AssignmentContext::ConstDeclarationStatement;
2596     if (RegisterID* local = var.local()) {
2597         RegisterID* result = nullptr;
2598         if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2599             generator.emitTDZCheckIfNecessary(var, local, nullptr);
2600 
2601         if (isReadOnly) {
2602             result = generator.emitNode(dst, m_right); // Execute side effects first.
2603             generator.emitReadOnlyExceptionIfNeeded(var);
2604             generator.emitProfileType(result, var, divotStart(), divotEnd());
2605         } else if (var.isSpecial()) {
2606             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
2607             generator.emitNode(tempDst.get(), m_right);
2608             generator.move(local, tempDst.get());
2609             generator.emitProfileType(local, var, divotStart(), divotEnd());
2610             result = generator.move(dst, tempDst.get());
2611         } else {
2612             RegisterID* right = generator.emitNode(local, m_right);
2613             generator.emitProfileType(right, var, divotStart(), divotEnd());
2614             result = generator.move(dst, right);
2615         }
2616 
2617         if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2618             generator.liftTDZCheckIfPossible(var);
2619         return result;
2620     }
2621 
2622     if (generator.isStrictMode())
2623         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2624     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2625     if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2626         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
2627     if (dst == generator.ignoredResult())
2628         dst = 0;
2629     RefPtr&lt;RegisterID&gt; result = generator.emitNode(dst, m_right);
2630     if (isReadOnly) {
2631         RegisterID* result = generator.emitNode(dst, m_right); // Execute side effects first.
2632         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2633         if (threwException)
2634             return result;
2635     }
2636     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2637     RegisterID* returnResult = result.get();
2638     if (!isReadOnly) {
2639         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_assignmentContext));
2640         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2641     }
2642 
2643     if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2644         generator.liftTDZCheckIfPossible(var);
2645     return returnResult;
2646 }
2647 
2648 // ------------------------------ AssignDotNode -----------------------------------
2649 
2650 RegisterID* AssignDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2651 {
2652     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2653     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2654     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2655     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2656     RefPtr&lt;RegisterID&gt; forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2657     if (m_base-&gt;isSuperNode()) {
2658         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2659         generator.emitPutById(base.get(), thisValue.get(), m_ident, forwardResult.get());
2660     } else
2661         generator.emitPutById(base.get(), m_ident, forwardResult.get());
2662     generator.emitProfileType(forwardResult.get(), divotStart(), divotEnd());
2663     return generator.move(dst, forwardResult.get());
2664 }
2665 
2666 // ------------------------------ ReadModifyDotNode -----------------------------------
2667 
2668 RegisterID* ReadModifyDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2669 {
2670     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2671 
2672     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2673     RefPtr&lt;RegisterID&gt; value;
2674     RefPtr&lt;RegisterID&gt; thisValue;
2675     if (m_base-&gt;isSuperNode()) {
2676         thisValue = generator.ensureThis();
2677         value = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), m_ident);
2678     } else
2679         value = generator.emitGetById(generator.tempDestination(dst), base.get(), m_ident);
2680     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2681 
2682     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2683     RegisterID* ret;
2684     if (m_base-&gt;isSuperNode())
2685         ret = generator.emitPutById(base.get(), thisValue.get(), m_ident, updatedValue);
2686     else
2687         ret = generator.emitPutById(base.get(), m_ident, updatedValue);
2688     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
2689     return ret;
2690 }
2691 
2692 // ------------------------------ AssignErrorNode -----------------------------------
2693 
2694 RegisterID* AssignErrorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2695 {
2696     return emitThrowReferenceError(generator, &quot;Left side of assignment is not a reference.&quot;_s);
2697 }
2698 
2699 // ------------------------------ AssignBracketNode -----------------------------------
2700 
2701 RegisterID* AssignBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2702 {
2703     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2704     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2705     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2706     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2707 
2708     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2709     RegisterID* forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2710 
2711     if (isNonIndexStringElement(*m_subscript)) {
2712         if (m_base-&gt;isSuperNode()) {
2713             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2714             generator.emitPutById(base.get(), thisValue.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2715         } else
2716             generator.emitPutById(base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2717     } else {
2718         if (m_base-&gt;isSuperNode()) {
2719             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2720             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), forwardResult);
2721         } else
2722             generator.emitPutByVal(base.get(), property.get(), forwardResult);
2723     }
2724 
2725     generator.emitProfileType(forwardResult, divotStart(), divotEnd());
2726     return generator.move(dst, forwardResult);
2727 }
2728 
2729 // ------------------------------ ReadModifyBracketNode -----------------------------------
2730 
2731 RegisterID* ReadModifyBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2732 {
2733     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2734     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2735 
2736     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2737     RefPtr&lt;RegisterID&gt; value;
2738     RefPtr&lt;RegisterID&gt; thisValue;
2739     if (m_base-&gt;isSuperNode()) {
2740         thisValue = generator.ensureThis();
2741         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisValue.get(), property.get());
2742     } else
2743         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());
2744     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2745 
2746     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2747     if (m_base-&gt;isSuperNode())
2748         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), updatedValue);
2749     else
2750         generator.emitPutByVal(base.get(), property.get(), updatedValue);
2751     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
2752 
2753     return updatedValue;
2754 }
2755 
2756 // ------------------------------ CommaNode ------------------------------------
2757 
2758 RegisterID* CommaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2759 {
2760     CommaNode* node = this;
2761     for (; node &amp;&amp; node-&gt;next(); node = node-&gt;next())
2762         generator.emitNode(generator.ignoredResult(), node-&gt;m_expr);
2763     return generator.emitNodeInTailPosition(dst, node-&gt;m_expr);
2764 }
2765 
2766 // ------------------------------ SourceElements -------------------------------
2767 
2768 inline void SourceElements::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2769 {
2770     StatementNode* lastStatementWithCompletionValue = nullptr;
2771     if (generator.shouldBeConcernedWithCompletionValue()) {
2772         for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
2773             if (statement-&gt;hasCompletionValue())
2774                 lastStatementWithCompletionValue = statement;
2775         }
2776     }
2777 
2778     for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
2779         if (statement == lastStatementWithCompletionValue)
2780             generator.emitLoad(dst, jsUndefined());
2781         generator.emitNodeInTailPosition(dst, statement);
2782     }
2783 }
2784 
2785 // ------------------------------ BlockNode ------------------------------------
2786 
2787 void BlockNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2788 {
2789     if (!m_statements)
2790         return;
2791     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
2792     m_statements-&gt;emitBytecode(generator, dst);
2793     generator.popLexicalScope(this);
2794 }
2795 
2796 // ------------------------------ EmptyStatementNode ---------------------------
2797 
2798 void EmptyStatementNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
2799 {
2800     RELEASE_ASSERT(needsDebugHook());
2801 }
2802 
2803 // ------------------------------ DebuggerStatementNode ---------------------------
2804 
2805 void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2806 {
2807     generator.emitDebugHook(DidReachBreakpoint, position());
2808 }
2809 
2810 // ------------------------------ ExprStatementNode ----------------------------
2811 
2812 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2813 {
2814     ASSERT(m_expr);
2815     generator.emitNode(dst, m_expr);
2816 }
2817 
2818 // ------------------------------ DeclarationStatement ----------------------------
2819 
2820 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2821 {
2822     ASSERT(m_expr);
2823     generator.emitNode(m_expr);
2824 }
2825 
2826 // ------------------------------ EmptyVarExpression ----------------------------
2827 
2828 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2829 {
2830     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
2831     if (!generator.shouldEmitTypeProfilerHooks())
2832         return nullptr;
2833 
2834     Variable var = generator.variable(m_ident);
2835     if (RegisterID* local = var.local())
2836         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2837     else {
2838         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2839         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
2840         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2841     }
2842 
2843     return nullptr;
2844 }
2845 
2846 // ------------------------------ EmptyLetExpression ----------------------------
2847 
2848 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2849 {
2850     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
2851     // get TDZ errors for situations like this: `let x; x;`
2852     Variable var = generator.variable(m_ident);
2853     if (RegisterID* local = var.local()) {
2854         generator.emitLoad(local, jsUndefined());
2855         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2856     } else {
2857         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2858         RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
2859         generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
2860         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
2861     }
2862 
2863     generator.liftTDZCheckIfPossible(var);
2864 
2865     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
2866     return nullptr;
2867 }
2868 
2869 // ------------------------------ IfElseNode ---------------------------------------
2870 
2871 static inline StatementNode* singleStatement(StatementNode* statementNode)
2872 {
2873     if (statementNode-&gt;isBlock())
2874         return static_cast&lt;BlockNode*&gt;(statementNode)-&gt;singleStatement();
2875     return statementNode;
2876 }
2877 
2878 bool IfElseNode::tryFoldBreakAndContinue(BytecodeGenerator&amp; generator, StatementNode* ifBlock,
2879     Label*&amp; trueTarget, FallThroughMode&amp; fallThroughMode)
2880 {
2881     StatementNode* singleStatement = JSC::singleStatement(ifBlock);
2882     if (!singleStatement)
2883         return false;
2884 
2885     if (singleStatement-&gt;isBreak()) {
2886         BreakNode* breakNode = static_cast&lt;BreakNode*&gt;(singleStatement);
2887         Label* target = breakNode-&gt;trivialTarget(generator);
2888         if (!target)
2889             return false;
2890         trueTarget = target;
2891         fallThroughMode = FallThroughMeansFalse;
2892         return true;
2893     }
2894 
2895     if (singleStatement-&gt;isContinue()) {
2896         ContinueNode* continueNode = static_cast&lt;ContinueNode*&gt;(singleStatement);
2897         Label* target = continueNode-&gt;trivialTarget(generator);
2898         if (!target)
2899             return false;
2900         trueTarget = target;
2901         fallThroughMode = FallThroughMeansFalse;
2902         return true;
2903     }
2904 
2905     return false;
2906 }
2907 
2908 void IfElseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2909 {
2910     if (generator.shouldBeConcernedWithCompletionValue()) {
2911         if (m_ifBlock-&gt;hasEarlyBreakOrContinue() || (m_elseBlock &amp;&amp; m_elseBlock-&gt;hasEarlyBreakOrContinue()))
2912             generator.emitLoad(dst, jsUndefined());
2913     }
2914 
2915     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2916     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2917     Ref&lt;Label&gt; afterElse = generator.newLabel();
2918 
2919     Label* trueTarget = beforeThen.ptr();
2920     Label&amp; falseTarget = beforeElse.get();
2921     FallThroughMode fallThroughMode = FallThroughMeansTrue;
2922     bool didFoldIfBlock = tryFoldBreakAndContinue(generator, m_ifBlock, trueTarget, fallThroughMode);
2923 
2924     generator.emitNodeInConditionContext(m_condition, *trueTarget, falseTarget, fallThroughMode);
2925     generator.emitLabel(beforeThen.get());
2926     generator.emitProfileControlFlow(m_ifBlock-&gt;startOffset());
2927 
2928     if (!didFoldIfBlock) {
2929         generator.emitNodeInTailPosition(dst, m_ifBlock);
2930         if (m_elseBlock)
2931             generator.emitJump(afterElse.get());
2932     }
2933 
2934     generator.emitLabel(beforeElse.get());
2935 
2936     if (m_elseBlock) {
2937         generator.emitProfileControlFlow(m_ifBlock-&gt;endOffset() + (m_ifBlock-&gt;isBlock() ? 1 : 0));
2938         generator.emitNodeInTailPosition(dst, m_elseBlock);
2939     }
2940 
2941     generator.emitLabel(afterElse.get());
2942     StatementNode* endingBlock = m_elseBlock ? m_elseBlock : m_ifBlock;
2943     generator.emitProfileControlFlow(endingBlock-&gt;endOffset() + (endingBlock-&gt;isBlock() ? 1 : 0));
2944 }
2945 
2946 // ------------------------------ DoWhileNode ----------------------------------
2947 
2948 void DoWhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2949 {
2950     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2951         generator.emitLoad(dst, jsUndefined());
2952 
2953     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
2954 
2955     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
2956     generator.emitLabel(topOfLoop.get());
2957     generator.emitLoopHint();
2958 
2959     generator.emitNodeInTailPosition(dst, m_statement);
2960 
2961     generator.emitLabel(*scope-&gt;continueTarget());
2962     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
2963 
2964     generator.emitLabel(scope-&gt;breakTarget());
2965 }
2966 
2967 // ------------------------------ WhileNode ------------------------------------
2968 
2969 void WhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2970 {
2971     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2972         generator.emitLoad(dst, jsUndefined());
2973 
2974     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
2975     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
2976 
2977     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
2978 
2979     generator.emitLabel(topOfLoop.get());
2980     generator.emitLoopHint();
2981 
2982     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
2983     generator.emitNodeInTailPosition(dst, m_statement);
2984 
2985     generator.emitLabel(*scope-&gt;continueTarget());
2986 
2987     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
2988 
2989     generator.emitLabel(scope-&gt;breakTarget());
2990 
2991     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
2992 }
2993 
2994 // ------------------------------ ForNode --------------------------------------
2995 
2996 void ForNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2997 {
2998     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
2999         generator.emitLoad(dst, jsUndefined());
3000 
3001     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3002 
3003     RegisterID* forLoopSymbolTable = nullptr;
3004     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3005 
3006     if (m_expr1)
3007         generator.emitNode(generator.ignoredResult(), m_expr1);
3008 
3009     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
3010     if (m_expr2)
3011         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
3012 
3013     generator.emitLabel(topOfLoop.get());
3014     generator.emitLoopHint();
3015     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3016 
3017     generator.emitNodeInTailPosition(dst, m_statement);
3018 
3019     generator.emitLabel(*scope-&gt;continueTarget());
3020     generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3021     if (m_expr3)
3022         generator.emitNode(generator.ignoredResult(), m_expr3);
3023 
3024     if (m_expr2)
3025         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
3026     else
3027         generator.emitJump(topOfLoop.get());
3028 
3029     generator.emitLabel(scope-&gt;breakTarget());
3030     generator.popLexicalScope(this);
3031     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3032 }
3033 
3034 // ------------------------------ ForInNode ------------------------------------
3035 
3036 RegisterID* ForInNode::tryGetBoundLocal(BytecodeGenerator&amp; generator)
3037 {
3038     if (m_lexpr-&gt;isResolveNode()) {
3039         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3040         return generator.variable(ident).local();
3041     }
3042 
3043     if (m_lexpr-&gt;isDestructuringNode()) {
3044         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3045         auto binding = assignNode-&gt;bindings();
3046         if (!binding-&gt;isBindingNode())
3047             return nullptr;
3048 
3049         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
3050         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
3051         Variable var = generator.variable(ident);
3052         if (var.isSpecial())
3053             return nullptr;
3054         return var.local();
3055     }
3056 
3057     return nullptr;
3058 }
3059 
3060 void ForInNode::emitLoopHeader(BytecodeGenerator&amp; generator, RegisterID* propertyName)
3061 {
3062     auto lambdaEmitResolveVariable = [&amp;] (const Identifier&amp; ident) {
3063         Variable var = generator.variable(ident);
3064         if (RegisterID* local = var.local()) {
3065             if (var.isReadOnly())
3066                 generator.emitReadOnlyExceptionIfNeeded(var);
3067             generator.move(local, propertyName);
3068         } else {
3069             if (generator.isStrictMode())
3070                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3071             if (var.isReadOnly())
3072                 generator.emitReadOnlyExceptionIfNeeded(var);
3073             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3074             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3075             generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3076         }
3077         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));
3078     };
3079 
3080     if (m_lexpr-&gt;isResolveNode()) {
3081         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3082         lambdaEmitResolveVariable(ident);
3083         return;
3084     }
3085 
3086     if (m_lexpr-&gt;isAssignResolveNode()) {
3087         const Identifier&amp; ident = static_cast&lt;AssignResolveNode*&gt;(m_lexpr)-&gt;identifier();
3088         lambdaEmitResolveVariable(ident);
3089         return;
3090     }
3091 
3092     if (m_lexpr-&gt;isDotAccessorNode()) {
3093         DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3094         const Identifier&amp; ident = assignNode-&gt;identifier();
3095         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3096         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3097         if (assignNode-&gt;base()-&gt;isSuperNode()) {
3098             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3099             generator.emitPutById(base.get(), thisValue.get(), ident, propertyName);
3100         } else
3101             generator.emitPutById(base.get(), ident, propertyName);
3102         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3103         return;
3104     }
3105     if (m_lexpr-&gt;isBracketAccessorNode()) {
3106         BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3107         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3108         RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3109         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3110         if (assignNode-&gt;base()-&gt;isSuperNode()) {
3111             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3112             generator.emitPutByVal(base.get(), thisValue.get(), subscript.get(), propertyName);
3113         } else
3114             generator.emitPutByVal(base.get(), subscript.get(), propertyName);
3115         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3116         return;
3117     }
3118 
3119     if (m_lexpr-&gt;isDestructuringNode()) {
3120         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3121         auto binding = assignNode-&gt;bindings();
3122         if (!binding-&gt;isBindingNode()) {
3123             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3124             return;
3125         }
3126 
3127         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
3128         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
3129         Variable var = generator.variable(ident);
3130         if (!var.local() || var.isSpecial()) {
3131             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3132             return;
3133         }
3134         generator.move(var.local(), propertyName);
3135         generator.emitProfileType(propertyName, var, simpleBinding-&gt;divotStart(), simpleBinding-&gt;divotEnd());
3136         return;
3137     }
3138 
3139     RELEASE_ASSERT_NOT_REACHED();
3140 }
3141 
3142 void ForInNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3143 {
3144     if (!m_lexpr-&gt;isAssignResolveNode() &amp;&amp; !m_lexpr-&gt;isAssignmentLocation()) {
3145         emitThrowReferenceError(generator, &quot;Left side of for-in statement is not a reference.&quot;_s);
3146         return;
3147     }
3148 
3149     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3150         generator.emitLoad(dst, jsUndefined());
3151 
3152     Ref&lt;Label&gt; end = generator.newLabel();
3153 
3154     RegisterID* forLoopSymbolTable = nullptr;
3155     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3156 
3157     if (m_lexpr-&gt;isAssignResolveNode())
3158         generator.emitNode(generator.ignoredResult(), m_lexpr);
3159 
3160     RefPtr&lt;RegisterID&gt; base = generator.newTemporary();
3161     RefPtr&lt;RegisterID&gt; length;
3162     RefPtr&lt;RegisterID&gt; enumerator;
3163 
3164     generator.emitNode(base.get(), m_expr);
3165     RefPtr&lt;RegisterID&gt; local = this-&gt;tryGetBoundLocal(generator);
3166     RefPtr&lt;RegisterID&gt; enumeratorIndex;
3167 
3168     // Pause at the assignment expression for each for..in iteration.
3169     generator.emitDebugHook(m_lexpr);
3170 
3171     int profilerStartOffset = m_statement-&gt;startOffset();
3172     int profilerEndOffset = m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0);
3173 
3174     enumerator = generator.emitGetPropertyEnumerator(generator.newTemporary(), base.get());
3175 
3176     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
3177     generator.preserveTDZStack(preservedTDZStack);
3178 
3179     // Indexed property loop.
3180     {
3181         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3182         Ref&lt;Label&gt; loopStart = generator.newLabel();
3183         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3184 
3185         length = generator.emitGetEnumerableLength(generator.newTemporary(), enumerator.get());
3186         RefPtr&lt;RegisterID&gt; i = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3187         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3188 
3189         generator.emitLabel(loopStart.get());
3190         generator.emitLoopHint();
3191 
3192         RefPtr&lt;RegisterID&gt; result = generator.emitEqualityOp&lt;OpLess&gt;(generator.newTemporary(), i.get(), length.get());
3193         generator.emitJumpIfFalse(result.get(), loopEnd.get());
3194         generator.emitHasIndexedProperty(result.get(), base.get(), i.get());
3195         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3196 
3197         generator.emitToIndexString(propertyName.get(), i.get());
3198         this-&gt;emitLoopHeader(generator, propertyName.get());
3199 
3200         generator.emitProfileControlFlow(profilerStartOffset);
3201 
3202         generator.pushIndexedForInScope(local.get(), i.get());
3203         generator.emitNode(dst, m_statement);
3204         generator.popIndexedForInScope(local.get());
3205 
3206         generator.emitProfileControlFlow(profilerEndOffset);
3207 
3208         generator.emitLabel(*scope-&gt;continueTarget());
3209         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3210         generator.emitInc(i.get());
3211         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3212         generator.emitJump(loopStart.get());
3213 
3214         generator.emitLabel(scope-&gt;breakTarget());
3215         generator.emitJump(end.get());
3216         generator.emitLabel(loopEnd.get());
3217     }
3218     generator.restoreTDZStack(preservedTDZStack);
3219 
3220     // Structure property loop.
3221     {
3222         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3223         Ref&lt;Label&gt; loopStart = generator.newLabel();
3224         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3225 
3226         enumeratorIndex = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3227         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3228         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3229 
3230         generator.emitLabel(loopStart.get());
3231         generator.emitLoopHint();
3232 
3233         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3234         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3235         generator.emitHasStructureProperty(result.get(), base.get(), propertyName.get(), enumerator.get());
3236         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3237 
3238         this-&gt;emitLoopHeader(generator, propertyName.get());
3239 
3240         generator.emitProfileControlFlow(profilerStartOffset);
3241 
3242         generator.pushStructureForInScope(local.get(), enumeratorIndex.get(), propertyName.get(), enumerator.get());
3243         generator.emitNode(dst, m_statement);
3244         generator.popStructureForInScope(local.get());
3245 
3246         generator.emitProfileControlFlow(profilerEndOffset);
3247 
3248         generator.emitLabel(*scope-&gt;continueTarget());
3249         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3250         generator.emitInc(enumeratorIndex.get());
3251         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3252         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3253         generator.emitJump(loopStart.get());
3254 
3255         generator.emitLabel(scope-&gt;breakTarget());
3256         generator.emitJump(end.get());
3257         generator.emitLabel(loopEnd.get());
3258     }
3259     generator.restoreTDZStack(preservedTDZStack);
3260 
3261     // Generic property loop.
3262     {
3263         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3264         Ref&lt;Label&gt; loopStart = generator.newLabel();
3265         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3266 
3267         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3268 
3269         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3270 
3271         generator.emitLabel(loopStart.get());
3272         generator.emitLoopHint();
3273 
3274         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3275         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3276 
3277         generator.emitHasGenericProperty(result.get(), base.get(), propertyName.get());
3278         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3279 
3280         this-&gt;emitLoopHeader(generator, propertyName.get());
3281 
3282         generator.emitProfileControlFlow(profilerStartOffset);
3283 
3284         generator.emitNode(dst, m_statement);
3285 
3286         generator.emitLabel(*scope-&gt;continueTarget());
3287         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3288         generator.emitInc(enumeratorIndex.get());
3289         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3290         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3291         generator.emitJump(loopStart.get());
3292 
3293         generator.emitLabel(scope-&gt;breakTarget());
3294         generator.emitJump(end.get());
3295         generator.emitLabel(loopEnd.get());
3296     }
3297 
3298     generator.emitLabel(end.get());
3299     generator.popLexicalScope(this);
3300     generator.emitProfileControlFlow(profilerEndOffset);
3301 }
3302 
3303 // ------------------------------ ForOfNode ------------------------------------
3304 void ForOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3305 {
3306     if (!m_lexpr-&gt;isAssignmentLocation()) {
3307         emitThrowReferenceError(generator, &quot;Left side of for-of statement is not a reference.&quot;_s);
3308         return;
3309     }
3310 
3311     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3312         generator.emitLoad(dst, jsUndefined());
3313 
3314     RegisterID* forLoopSymbolTable = nullptr;
3315     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3316     auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([this, dst](BytecodeGenerator&amp; generator, RegisterID* value)
3317     {
3318         if (m_lexpr-&gt;isResolveNode()) {
3319             const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3320             Variable var = generator.variable(ident);
3321             if (RegisterID* local = var.local()) {
3322                 if (var.isReadOnly())
3323                     generator.emitReadOnlyExceptionIfNeeded(var);
3324                 generator.move(local, value);
3325             } else {
3326                 if (generator.isStrictMode())
3327                     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3328                 if (var.isReadOnly())
3329                     generator.emitReadOnlyExceptionIfNeeded(var);
3330                 RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3331                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3332                 generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3333             }
3334             generator.emitProfileType(value, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));
3335         } else if (m_lexpr-&gt;isDotAccessorNode()) {
3336             DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3337             const Identifier&amp; ident = assignNode-&gt;identifier();
3338             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3339 
3340             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3341             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3342                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3343                 generator.emitPutById(base.get(), thisValue.get(), ident, value);
3344             } else
3345                 generator.emitPutById(base.get(), ident, value);
3346             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3347         } else if (m_lexpr-&gt;isBracketAccessorNode()) {
3348             BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3349             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3350             RegisterID* subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3351 
3352             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3353             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3354                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3355                 generator.emitPutByVal(base.get(), thisValue.get(), subscript, value);
3356             } else
3357                 generator.emitPutByVal(base.get(), subscript, value);
3358             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3359         } else {
3360             ASSERT(m_lexpr-&gt;isDestructuringNode());
3361             DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3362             assignNode-&gt;bindings()-&gt;bindValue(generator, value);
3363         }
3364         generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3365         generator.emitNode(dst, m_statement);
3366     });
3367     generator.emitEnumeration(this, m_expr, extractor, this, forLoopSymbolTable);
3368     generator.popLexicalScope(this);
3369     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3370 }
3371 
3372 // ------------------------------ ContinueNode ---------------------------------
3373 
3374 Label* ContinueNode::trivialTarget(BytecodeGenerator&amp; generator)
3375 {
3376     if (generator.shouldEmitDebugHooks())
3377         return nullptr;
3378 
3379     LabelScope* scope = generator.continueTarget(m_ident);
3380     ASSERT(scope);
3381 
3382     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3383         return nullptr;
3384 
3385     return scope-&gt;continueTarget();
3386 }
3387 
3388 void ContinueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3389 {
3390     LabelScope* scope = generator.continueTarget(m_ident);
3391     ASSERT(scope);
3392 
3393     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), *scope-&gt;continueTarget());
3394     if (!hasFinally) {
3395         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3396         generator.restoreScopeRegister(lexicalScopeIndex);
3397         generator.emitJump(*scope-&gt;continueTarget());
3398     }
3399 
3400     generator.emitProfileControlFlow(endOffset());
3401 }
3402 
3403 // ------------------------------ BreakNode ------------------------------------
3404 
3405 Label* BreakNode::trivialTarget(BytecodeGenerator&amp; generator)
3406 {
3407     if (generator.shouldEmitDebugHooks())
3408         return nullptr;
3409 
3410     LabelScope* scope = generator.breakTarget(m_ident);
3411     ASSERT(scope);
3412 
3413     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3414         return nullptr;
3415 
3416     return &amp;scope-&gt;breakTarget();
3417 }
3418 
3419 void BreakNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3420 {
3421     LabelScope* scope = generator.breakTarget(m_ident);
3422     ASSERT(scope);
3423 
3424     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), scope-&gt;breakTarget());
3425     if (!hasFinally) {
3426         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3427         generator.restoreScopeRegister(lexicalScopeIndex);
3428         generator.emitJump(scope-&gt;breakTarget());
3429     }
3430 
3431     generator.emitProfileControlFlow(endOffset());
3432 }
3433 
3434 // ------------------------------ ReturnNode -----------------------------------
3435 
3436 void ReturnNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3437 {
3438     ASSERT(generator.codeType() == FunctionCode);
3439 
3440     if (dst == generator.ignoredResult())
3441         dst = 0;
3442 
3443     RefPtr&lt;RegisterID&gt; returnRegister = m_value ? generator.emitNodeInTailPosition(dst, m_value) : generator.emitLoad(dst, jsUndefined());
3444 
3445     generator.emitProfileType(returnRegister.get(), ProfileTypeBytecodeFunctionReturnStatement, divotStart(), divotEnd());
3446 
3447     bool hasFinally = generator.emitReturnViaFinallyIfNeeded(returnRegister.get());
3448     if (!hasFinally) {
3449         if (generator.parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
3450             returnRegister = generator.move(generator.newTemporary(), returnRegister.get());
3451             generator.emitAwait(returnRegister.get());
3452         }
3453 
3454         generator.emitWillLeaveCallFrameDebugHook();
3455         generator.emitReturn(returnRegister.get());
3456     }
3457 
3458     generator.emitProfileControlFlow(endOffset());
3459     // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
3460     // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
3461     if (generator.shouldEmitControlFlowProfilerHooks())
3462         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3463 }
3464 
3465 // ------------------------------ WithNode -------------------------------------
3466 
3467 void WithNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3468 {
3469     RefPtr&lt;RegisterID&gt; scope = generator.emitNode(m_expr);
3470     generator.emitExpressionInfo(m_divot, m_divot - m_expressionLength, m_divot);
3471     generator.emitPushWithScope(scope.get());
3472     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3473         generator.emitLoad(dst, jsUndefined());
3474     generator.emitNodeInTailPosition(dst, m_statement);
3475     generator.emitPopWithScope();
3476 }
3477 
3478 // ------------------------------ CaseClauseNode --------------------------------
3479 
3480 inline void CaseClauseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3481 {
3482     generator.emitProfileControlFlow(m_startOffset);
3483     if (!m_statements)
3484         return;
3485     m_statements-&gt;emitBytecode(generator, dst);
3486 }
3487 
3488 // ------------------------------ CaseBlockNode --------------------------------
3489 
3490 enum SwitchKind {
3491     SwitchUnset = 0,
3492     SwitchNumber = 1,
3493     SwitchString = 2,
3494     SwitchNeither = 3
3495 };
3496 
3497 static void processClauseList(ClauseListNode* list, Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, SwitchKind&amp; typeForTable, bool&amp; singleCharacterSwitch, int32_t&amp; min_num, int32_t&amp; max_num)
3498 {
3499     for (; list; list = list-&gt;getNext()) {
3500         ExpressionNode* clauseExpression = list-&gt;getClause()-&gt;expr();
3501         literalVector.append(clauseExpression);
3502         if (clauseExpression-&gt;isNumber()) {
3503             double value = static_cast&lt;NumberNode*&gt;(clauseExpression)-&gt;value();
3504             int32_t intVal = static_cast&lt;int32_t&gt;(value);
3505             if ((typeForTable &amp; ~SwitchNumber) || (intVal != value)) {
3506                 typeForTable = SwitchNeither;
3507                 break;
3508             }
3509             if (intVal &lt; min_num)
3510                 min_num = intVal;
3511             if (intVal &gt; max_num)
3512                 max_num = intVal;
3513             typeForTable = SwitchNumber;
3514             continue;
3515         }
3516         if (clauseExpression-&gt;isString()) {
3517             if (typeForTable &amp; ~SwitchString) {
3518                 typeForTable = SwitchNeither;
3519                 break;
3520             }
3521             const String&amp; value = static_cast&lt;StringNode*&gt;(clauseExpression)-&gt;value().string();
3522             if (singleCharacterSwitch &amp;= value.length() == 1) {
3523                 int32_t intVal = value[0];
3524                 if (intVal &lt; min_num)
3525                     min_num = intVal;
3526                 if (intVal &gt; max_num)
3527                     max_num = intVal;
3528             }
3529             typeForTable = SwitchString;
3530             continue;
3531         }
3532         typeForTable = SwitchNeither;
3533         break;
3534     }
3535 }
3536 
3537 static inline size_t length(ClauseListNode* list1, ClauseListNode* list2)
3538 {
3539     size_t length = 0;
3540     for (ClauseListNode* node = list1; node; node = node-&gt;getNext())
3541         ++length;
3542     for (ClauseListNode* node = list2; node; node = node-&gt;getNext())
3543         ++length;
3544     return length;
3545 }
3546 
3547 SwitchInfo::SwitchType CaseBlockNode::tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num)
3548 {
3549     if (length(m_list1, m_list2) &lt; s_tableSwitchMinimum)
3550         return SwitchInfo::SwitchNone;
3551 
3552     SwitchKind typeForTable = SwitchUnset;
3553     bool singleCharacterSwitch = true;
3554 
3555     processClauseList(m_list1, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3556     processClauseList(m_list2, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3557 
3558     if (typeForTable == SwitchUnset || typeForTable == SwitchNeither)
3559         return SwitchInfo::SwitchNone;
3560 
3561     if (typeForTable == SwitchNumber) {
3562         int32_t range = max_num - min_num;
3563         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3564             return SwitchInfo::SwitchImmediate;
3565         return SwitchInfo::SwitchNone;
3566     }
3567 
3568     ASSERT(typeForTable == SwitchString);
3569 
3570     if (singleCharacterSwitch) {
3571         int32_t range = max_num - min_num;
3572         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3573             return SwitchInfo::SwitchCharacter;
3574     }
3575 
3576     return SwitchInfo::SwitchString;
3577 }
3578 
3579 void CaseBlockNode::emitBytecodeForBlock(BytecodeGenerator&amp; generator, RegisterID* switchExpression, RegisterID* dst)
3580 {
3581     Vector&lt;Ref&lt;Label&gt;, 8&gt; labelVector;
3582     Vector&lt;ExpressionNode*, 8&gt; literalVector;
3583     int32_t min_num = std::numeric_limits&lt;int32_t&gt;::max();
3584     int32_t max_num = std::numeric_limits&lt;int32_t&gt;::min();
3585     SwitchInfo::SwitchType switchType = tryTableSwitch(literalVector, min_num, max_num);
3586 
3587     Ref&lt;Label&gt; defaultLabel = generator.newLabel();
3588     if (switchType != SwitchInfo::SwitchNone) {
3589         // Prepare the various labels
3590         for (uint32_t i = 0; i &lt; literalVector.size(); i++)
3591             labelVector.append(generator.newLabel());
3592         generator.beginSwitch(switchExpression, switchType);
3593     } else {
3594         // Setup jumps
3595         for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3596             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3597             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3598             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3599             labelVector.append(generator.newLabel());
3600             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3601         }
3602 
3603         for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3604             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3605             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3606             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3607             labelVector.append(generator.newLabel());
3608             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3609         }
3610         generator.emitJump(defaultLabel.get());
3611     }
3612 
3613     size_t i = 0;
3614     for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3615         generator.emitLabel(labelVector[i++].get());
3616         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3617     }
3618 
3619     if (m_defaultClause) {
3620         generator.emitLabel(defaultLabel.get());
3621         m_defaultClause-&gt;emitBytecode(generator, dst);
3622     }
3623 
3624     for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3625         generator.emitLabel(labelVector[i++].get());
3626         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3627     }
3628     if (!m_defaultClause)
3629         generator.emitLabel(defaultLabel.get());
3630 
3631     ASSERT(i == labelVector.size());
3632     if (switchType != SwitchInfo::SwitchNone) {
3633         ASSERT(labelVector.size() == literalVector.size());
3634         generator.endSwitch(labelVector.size(), labelVector, literalVector.data(), defaultLabel.get(), min_num, max_num);
3635     }
3636 }
3637 
3638 // ------------------------------ SwitchNode -----------------------------------
3639 
3640 void SwitchNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3641 {
3642     if (generator.shouldBeConcernedWithCompletionValue())
3643         generator.emitLoad(dst, jsUndefined());
3644 
3645     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Switch);
3646 
3647     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
3648 
3649     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::DoNotOptimize, BytecodeGenerator::NestedScopeType::IsNested);
3650     m_block-&gt;emitBytecodeForBlock(generator, r0.get(), dst);
3651     generator.popLexicalScope(this);
3652 
3653     generator.emitLabel(scope-&gt;breakTarget());
3654     generator.emitProfileControlFlow(endOffset());
3655 }
3656 
3657 // ------------------------------ LabelNode ------------------------------------
3658 
3659 void LabelNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3660 {
3661     ASSERT(!generator.breakTarget(m_name));
3662 
3663     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::NamedLabel, &amp;m_name);
3664     generator.emitNodeInTailPosition(dst, m_statement);
3665 
3666     generator.emitLabel(scope-&gt;breakTarget());
3667 }
3668 
3669 // ------------------------------ ThrowNode ------------------------------------
3670 
3671 void ThrowNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3672 {
3673     if (dst == generator.ignoredResult())
3674         dst = 0;
3675     RefPtr&lt;RegisterID&gt; expr = generator.emitNode(m_expr);
3676     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3677     generator.emitThrow(expr.get());
3678 
3679     generator.emitProfileControlFlow(endOffset());
3680 }
3681 
3682 // ------------------------------ TryNode --------------------------------------
3683 
3684 void TryNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3685 {
3686     // NOTE: The catch and finally blocks must be labeled explicitly, so the
3687     // optimizer knows they may be jumped to from anywhere.
3688 
3689     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
3690         generator.emitLoad(dst, jsUndefined());
3691 
3692     ASSERT(m_catchBlock || m_finallyBlock);
3693 
3694     RefPtr&lt;Label&gt; catchLabel;
3695     RefPtr&lt;Label&gt; catchEndLabel;
3696     RefPtr&lt;Label&gt; finallyLabel;
3697     RefPtr&lt;Label&gt; finallyEndLabel;
3698     Optional&lt;FinallyContext&gt; finallyContext;
3699 
3700     if (m_finallyBlock) {
3701         finallyLabel = generator.newLabel();
3702         finallyEndLabel = generator.newLabel();
3703 
3704         finallyContext.emplace(generator, *finallyLabel);
3705         generator.pushFinallyControlFlowScope(finallyContext.value());
3706     }
3707     if (m_catchBlock) {
3708         catchLabel = generator.newLabel();
3709         catchEndLabel = generator.newLabel();
3710     }
3711 
3712     Ref&lt;Label&gt; tryLabel = generator.newEmittedLabel();
3713     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyLabel;
3714     HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
3715     TryData* tryData = generator.pushTry(tryLabel.get(), tryHandlerLabel, tryHandlerType);
3716     TryData* finallyTryData = nullptr;
3717     if (!m_catchBlock &amp;&amp; m_finallyBlock)
3718         finallyTryData = tryData;
3719 
3720     generator.emitNode(dst, m_tryBlock);
3721 
3722     if (m_finallyBlock)
3723         generator.emitJump(*finallyLabel);
3724     else
3725         generator.emitJump(*catchEndLabel);
3726 
3727     Ref&lt;Label&gt; tryEndLabel = generator.newEmittedLabel();
3728     generator.popTry(tryData, tryEndLabel.get());
3729 
3730     if (m_catchBlock) {
3731         // Uncaught exception path: the catch block.
3732         generator.emitLabel(*catchLabel);
3733         RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
3734         RegisterID* completionTypeRegister = m_finallyBlock ? finallyContext-&gt;completionTypeRegister() : nullptr;
3735         generator.emitOutOfLineCatchHandler(thrownValueRegister.get(), completionTypeRegister, tryData);
3736         generator.restoreScopeRegister();
3737 
3738         if (m_finallyBlock) {
3739             // If the catch block throws an exception and we have a finally block, then the finally
3740             // block should &quot;catch&quot; that exception.
3741             finallyTryData = generator.pushTry(*catchLabel, *finallyLabel, HandlerType::Finally);
3742         }
3743 
3744         if (m_catchPattern) {
3745             generator.emitPushCatchScope(m_lexicalVariables);
3746             m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
3747         }
3748 
3749         generator.emitProfileControlFlow(m_tryBlock-&gt;endOffset() + 1);
3750         if (m_finallyBlock)
3751             generator.emitNode(dst, m_catchBlock);
3752         else
3753             generator.emitNodeInTailPosition(dst, m_catchBlock);
3754         generator.emitLoad(thrownValueRegister.get(), jsUndefined());
3755 
3756         if (m_catchPattern)
3757             generator.emitPopCatchScope(m_lexicalVariables);
3758 
3759         if (m_finallyBlock) {
3760             generator.emitLoad(finallyContext-&gt;completionTypeRegister(), CompletionType::Normal);
3761             generator.emitJump(*finallyLabel);
3762             generator.popTry(finallyTryData, *finallyLabel);
3763         }
3764 
3765         generator.emitLabel(*catchEndLabel);
3766         generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
3767     }
3768 
3769     if (m_finallyBlock) {
3770         generator.popFinallyControlFlowScope();
3771 
3772         // Entry to the finally block for CompletionType::Throw to be generated later.
3773         generator.emitOutOfLineFinallyHandler(finallyContext-&gt;completionValueRegister(), finallyContext-&gt;completionTypeRegister(), finallyTryData);
3774 
3775         // Entry to the finally block for CompletionTypes other than Throw.
3776         generator.emitLabel(*finallyLabel);
3777         generator.restoreScopeRegister();
3778 
3779         int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
3780         generator.emitProfileControlFlow(finallyStartOffset);
3781         generator.emitNodeInTailPosition(m_finallyBlock);
3782 
3783         generator.emitFinallyCompletion(finallyContext.value(), *finallyEndLabel);
3784         generator.emitLabel(*finallyEndLabel);
3785         generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
3786     }
3787 }
3788 
3789 // ------------------------------ ScopeNode -----------------------------
3790 
3791 inline void ScopeNode::emitStatementsBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3792 {
3793     if (!m_statements)
3794         return;
3795     m_statements-&gt;emitBytecode(generator, dst);
3796 }
3797 
3798 static void emitProgramNodeBytecode(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)
3799 {
3800     generator.emitDebugHook(WillExecuteProgram, scopeNode.startLine(), scopeNode.startStartOffset(), scopeNode.startLineStartOffset());
3801 
3802     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3803     generator.emitLoad(dstRegister.get(), jsUndefined());
3804     generator.emitProfileControlFlow(scopeNode.startStartOffset());
3805     scopeNode.emitStatementsBytecode(generator, dstRegister.get());
3806 
3807     generator.emitDebugHook(DidExecuteProgram, scopeNode.lastLine(), scopeNode.startOffset(), scopeNode.lineStartOffset());
3808     generator.emitEnd(dstRegister.get());
3809 }
3810 
3811 // ------------------------------ ProgramNode -----------------------------
3812 
3813 void ProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3814 {
3815     emitProgramNodeBytecode(generator, *this);
3816 }
3817 
3818 // ------------------------------ ModuleProgramNode --------------------
3819 
3820 void ModuleProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3821 {
3822     emitProgramNodeBytecode(generator, *this);
3823 }
3824 
3825 // ------------------------------ EvalNode -----------------------------
3826 
3827 void EvalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3828 {
3829     generator.emitDebugHook(WillExecuteProgram, startLine(), startStartOffset(), startLineStartOffset());
3830 
3831     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
3832     generator.emitLoad(dstRegister.get(), jsUndefined());
3833     emitStatementsBytecode(generator, dstRegister.get());
3834 
3835     generator.emitDebugHook(DidExecuteProgram, lastLine(), startOffset(), lineStartOffset());
3836     generator.emitEnd(dstRegister.get());
3837 }
3838 
3839 // ------------------------------ FunctionNode -----------------------------
3840 
3841 void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3842 {
3843     if (generator.shouldEmitTypeProfilerHooks()) {
3844         // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
3845         if (m_parameters-&gt;isSimpleParameterList()) {
3846             for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
3847                 BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
3848                 RegisterID reg(CallFrame::argumentOffset(i));
3849                 generator.emitProfileType(&amp;reg, ProfileTypeBytecodeFunctionArgument, bindingNode-&gt;divotStart(), bindingNode-&gt;divotEnd());
3850             }
3851         }
3852     }
3853 
3854     generator.emitProfileControlFlow(startStartOffset());
3855     generator.emitDebugHook(DidEnterCallFrame, startLine(), startStartOffset(), startLineStartOffset());
3856 
3857     switch (generator.parseMode()) {
3858     case SourceParseMode::GeneratorWrapperFunctionMode:
3859     case SourceParseMode::GeneratorWrapperMethodMode:
3860     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
3861     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
3862         StatementNode* singleStatement = this-&gt;singleStatement();
3863         ASSERT(singleStatement-&gt;isExprStatement());
3864         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
3865         ExpressionNode* expr = exprStatement-&gt;expr();
3866         ASSERT(expr-&gt;isFuncExprNode());
3867         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
3868 
3869         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
3870         generator.emitNode(next.get(), funcExpr);
3871 
3872         if (generator.superBinding() == SuperBinding::Needed) {
3873             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
3874             emitPutHomeObject(generator, next.get(), homeObject.get());
3875         }
3876 
3877         if (isGeneratorWrapperParseMode(generator.parseMode()))
3878             generator.emitPutGeneratorFields(next.get());
3879         else {
3880             ASSERT(isAsyncGeneratorWrapperParseMode(generator.parseMode()));
3881             generator.emitPutAsyncGeneratorFields(next.get());
3882         }
3883 
3884         ASSERT(startOffset() &gt;= lineStartOffset());
3885         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
3886         generator.emitReturn(generator.generatorRegister());
3887         break;
3888     }
3889 
3890     case SourceParseMode::AsyncFunctionMode:
3891     case SourceParseMode::AsyncMethodMode:
3892     case SourceParseMode::AsyncArrowFunctionMode: {
3893         StatementNode* singleStatement = this-&gt;singleStatement();
3894         ASSERT(singleStatement-&gt;isExprStatement());
3895         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
3896         ExpressionNode* expr = exprStatement-&gt;expr();
3897         ASSERT(expr-&gt;isFuncExprNode());
3898         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
3899 
3900         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
3901         generator.emitNode(next.get(), funcExpr);
3902 
3903         if (generator.superBinding() == SuperBinding::Needed || (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isSuperUsedInInnerArrowFunction())) {
3904             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
3905             emitPutHomeObject(generator, next.get(), homeObject.get());
3906         }
3907 
3908         if (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isThisUsedInInnerArrowFunction())
3909             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
3910 
3911         generator.emitPutGeneratorFields(next.get());
3912 
3913         ASSERT(startOffset() &gt;= lineStartOffset());
3914         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
3915 
3916         // load and call @asyncFunctionResume
3917         auto var = generator.variable(generator.propertyNames().builtinNames().asyncFunctionResumePrivateName());
3918         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
3919         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
3920         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
3921 
3922         CallArguments args(generator, nullptr, 4);
3923         unsigned argumentCount = 0;
3924         generator.emitLoad(args.thisRegister(), jsUndefined());
3925         generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
3926         generator.move(args.argumentRegister(argumentCount++), generator.promiseCapabilityRegister());
3927         generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
3928         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode)));
3929         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
3930         JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
3931 
3932         RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
3933         generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
3934         generator.emitReturn(result.get());
3935         break;
3936     }
3937 
3938     case SourceParseMode::AsyncGeneratorBodyMode:
3939     case SourceParseMode::AsyncArrowFunctionBodyMode:
3940     case SourceParseMode::AsyncFunctionBodyMode:
3941     case SourceParseMode::GeneratorBodyMode: {
3942         Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
3943         {
3944             RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
3945             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));
3946             generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
3947 
3948             Ref&lt;Label&gt; throwLabel = generator.newLabel();
3949             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));
3950             generator.emitJumpIfTrue(condition.get(), throwLabel.get());
3951 
3952             generator.emitReturn(generator.generatorValueRegister());
3953 
3954             generator.emitLabel(throwLabel.get());
3955             generator.emitThrow(generator.generatorValueRegister());
3956         }
3957 
3958         generator.emitLabel(generatorBodyLabel.get());
3959 
3960         emitStatementsBytecode(generator, generator.ignoredResult());
3961 
3962         Ref&lt;Label&gt; done = generator.newLabel();
3963         generator.emitLabel(done.get());
3964         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3965         break;
3966     }
3967 
3968     default: {
3969         emitStatementsBytecode(generator, generator.ignoredResult());
3970 
3971         StatementNode* singleStatement = this-&gt;singleStatement();
3972         ReturnNode* returnNode = 0;
3973 
3974         // Check for a return statement at the end of a function composed of a single block.
3975         if (singleStatement &amp;&amp; singleStatement-&gt;isBlock()) {
3976             StatementNode* lastStatementInBlock = static_cast&lt;BlockNode*&gt;(singleStatement)-&gt;lastStatement();
3977             if (lastStatementInBlock &amp;&amp; lastStatementInBlock-&gt;isReturnNode())
3978                 returnNode = static_cast&lt;ReturnNode*&gt;(lastStatementInBlock);
3979         }
3980 
3981         // If there is no return we must automatically insert one.
3982         if (!returnNode) {
3983             if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
3984                 generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
3985 
3986             RegisterID* r0 = generator.isConstructor() ? generator.thisRegister() : generator.emitLoad(0, jsUndefined());
3987             generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
3988             ASSERT(startOffset() &gt;= lineStartOffset());
3989             generator.emitWillLeaveCallFrameDebugHook();
3990             generator.emitReturn(r0);
3991             return;
3992         }
3993         break;
3994     }
3995     }
3996 }
3997 
3998 // ------------------------------ FuncDeclNode ---------------------------------
3999 
4000 void FuncDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4001 {
4002     generator.hoistSloppyModeFunctionIfNecessary(metadata()-&gt;ident());
4003 }
4004 
4005 // ------------------------------ FuncExprNode ---------------------------------
4006 
4007 RegisterID* FuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4008 {
4009     return generator.emitNewFunctionExpression(generator.finalDestination(dst), this);
4010 }
4011 
4012 // ------------------------------ ArrowFuncExprNode ---------------------------------
4013 
4014 RegisterID* ArrowFuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4015 {
4016     return generator.emitNewArrowFunctionExpression(generator.finalDestination(dst), this);
4017 }
4018 
4019 // ------------------------------ MethodDefinitionNode ---------------------------------
4020 
4021 RegisterID* MethodDefinitionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4022 {
4023     return generator.emitNewMethodDefinition(generator.finalDestination(dst), this);
4024 }
4025 
4026 // ------------------------------ YieldExprNode --------------------------------
4027 
4028 RegisterID* YieldExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4029 {
4030     if (!delegate()) {
4031         RefPtr&lt;RegisterID&gt; arg = nullptr;
4032         if (argument()) {
4033             arg = generator.newTemporary();
4034             generator.emitNode(arg.get(), argument());
4035         } else
4036             arg = generator.emitLoad(nullptr, jsUndefined());
4037         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
4038         if (dst == generator.ignoredResult())
4039             return nullptr;
4040         return generator.move(generator.finalDestination(dst), value.get());
4041     }
4042     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4043     generator.emitNode(arg.get(), argument());
4044     RefPtr&lt;RegisterID&gt; value = generator.emitDelegateYield(arg.get(), this);
4045     if (dst == generator.ignoredResult())
4046         return nullptr;
4047     return generator.move(generator.finalDestination(dst), value.get());
4048 }
4049 
4050 // ------------------------------ AwaitExprNode --------------------------------
4051 
4052 RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4053 {
4054     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4055     generator.emitNode(arg.get(), argument());
4056     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);
4057     if (dst == generator.ignoredResult())
4058         return nullptr;
4059     return generator.move(generator.finalDestination(dst), value.get());
4060 }
4061 
4062 // ------------------------------ ClassDeclNode ---------------------------------
4063 
4064 void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4065 {
4066     generator.emitNode(m_classDeclaration);
4067 }
4068 
4069 // ------------------------------ ClassExprNode ---------------------------------
4070 
4071 RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4072 {
4073     if (!m_name.isNull())
4074         generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
4075 
4076     RefPtr&lt;RegisterID&gt; superclass;
4077     if (m_classHeritage) {
4078         superclass = generator.newTemporary();
4079         generator.emitNode(superclass.get(), m_classHeritage);
4080     }
4081 
4082     RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
4083     bool needsHomeObject = false;
4084 
4085     if (m_constructorExpression) {
4086         ASSERT(m_constructorExpression-&gt;isFuncExprNode());
4087         FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
4088         metadata-&gt;setEcmaName(ecmaName());
4089         metadata-&gt;setClassSource(m_classSource);
4090         constructor = generator.emitNode(constructor.get(), m_constructorExpression);
4091         needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
4092     } else
4093         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource);
4094 
4095     const auto&amp; propertyNames = generator.propertyNames();
4096     RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
4097 
4098     if (superclass) {
4099         RefPtr&lt;RegisterID&gt; protoParent = generator.newTemporary();
4100         generator.emitLoad(protoParent.get(), jsNull());
4101 
4102         RefPtr&lt;RegisterID&gt; tempRegister = generator.newTemporary();
4103 
4104         // FIXME: Throw TypeError if it&#39;s a generator function.
4105         Ref&lt;Label&gt; superclassIsUndefinedLabel = generator.newLabel();
4106         generator.emitJumpIfTrue(generator.emitIsUndefined(tempRegister.get(), superclass.get()), superclassIsUndefinedLabel.get());
4107 
4108         Ref&lt;Label&gt; superclassIsNullLabel = generator.newLabel();
4109         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpEqNull&gt;(tempRegister.get(), superclass.get()), superclassIsNullLabel.get());
4110 
4111         Ref&lt;Label&gt; superclassIsObjectLabel = generator.newLabel();
4112         generator.emitJumpIfTrue(generator.emitIsObject(tempRegister.get(), superclass.get()), superclassIsObjectLabel.get());
4113         generator.emitLabel(superclassIsUndefinedLabel.get());
4114         generator.emitThrowTypeError(&quot;The superclass is not an object.&quot;_s);
4115         generator.emitLabel(superclassIsObjectLabel.get());
4116         generator.emitGetById(protoParent.get(), superclass.get(), generator.propertyNames().prototype);
4117 
4118         Ref&lt;Label&gt; protoParentIsObjectOrNullLabel = generator.newLabel();
4119         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsObjectOrNull&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4120         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsFunction&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4121         generator.emitThrowTypeError(&quot;The value of the superclass&#39;s prototype property is not an object.&quot;_s);
4122         generator.emitLabel(protoParentIsObjectOrNullLabel.get());
4123 
4124         generator.emitDirectPutById(constructor.get(), generator.propertyNames().underscoreProto, superclass.get(), PropertyNode::Unknown);
4125         generator.emitLabel(superclassIsNullLabel.get());
4126         generator.emitDirectPutById(prototype.get(), generator.propertyNames().underscoreProto, protoParent.get(), PropertyNode::Unknown);
4127     }
4128 
4129     if (needsHomeObject)
4130         emitPutHomeObject(generator, constructor.get(), prototype.get());
4131 
4132     RefPtr&lt;RegisterID&gt; constructorNameRegister = generator.emitLoad(nullptr, propertyNames.constructor);
4133     generator.emitCallDefineProperty(prototype.get(), constructorNameRegister.get(), constructor.get(), nullptr, nullptr,
4134         BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
4135 
4136     RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
4137     generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
4138 
4139     if (m_classElements)
4140         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get());
4141 
4142     if (!m_name.isNull()) {
4143         Variable classNameVar = generator.variable(m_name);
4144         RELEASE_ASSERT(classNameVar.isResolved());
4145         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);
4146         generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);
4147         generator.popLexicalScope(this);
4148     }
4149 
4150     return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
4151 }
4152 
4153 // ------------------------------ ImportDeclarationNode -----------------------
4154 
4155 void ImportDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4156 {
4157     // Do nothing at runtime.
4158 }
4159 
4160 // ------------------------------ ExportAllDeclarationNode --------------------
4161 
4162 void ExportAllDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4163 {
4164     // Do nothing at runtime.
4165 }
4166 
4167 // ------------------------------ ExportDefaultDeclarationNode ----------------
4168 
4169 void ExportDefaultDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4170 {
4171     ASSERT(m_declaration);
4172     generator.emitNode(dst, m_declaration);
4173 }
4174 
4175 // ------------------------------ ExportLocalDeclarationNode ------------------
4176 
4177 void ExportLocalDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4178 {
4179     ASSERT(m_declaration);
4180     generator.emitNode(dst, m_declaration);
4181 }
4182 
4183 // ------------------------------ ExportNamedDeclarationNode ------------------
4184 
4185 void ExportNamedDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4186 {
4187     // Do nothing at runtime.
4188 }
4189 
4190 // ------------------------------ DestructuringAssignmentNode -----------------
4191 RegisterID* DestructuringAssignmentNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4192 {
4193     if (RegisterID* result = m_bindings-&gt;emitDirectBinding(generator, dst, m_initializer))
4194         return result;
4195     RefPtr&lt;RegisterID&gt; initializer = generator.tempDestination(dst);
4196     generator.emitNode(initializer.get(), m_initializer);
4197     m_bindings-&gt;bindValue(generator, initializer.get());
4198     return generator.move(dst, initializer.get());
4199 }
4200 
4201 static void assignDefaultValueIfUndefined(BytecodeGenerator&amp; generator, RegisterID* maybeUndefined, ExpressionNode* defaultValue)
4202 {
4203     ASSERT(defaultValue);
4204     Ref&lt;Label&gt; isNotUndefined = generator.newLabel();
4205     generator.emitJumpIfFalse(generator.emitIsUndefined(generator.newTemporary(), maybeUndefined), isNotUndefined.get());
4206     generator.emitNode(maybeUndefined, defaultValue);
4207     generator.emitLabel(isNotUndefined.get());
4208 }
4209 
4210 void ArrayPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4211 {
4212     RefPtr&lt;RegisterID&gt; iterator = generator.newTemporary();
4213     {
4214         generator.emitGetById(iterator.get(), rhs, generator.propertyNames().iteratorSymbol);
4215         CallArguments args(generator, nullptr);
4216         generator.move(args.thisRegister(), rhs);
4217         generator.emitCall(iterator.get(), iterator.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4218     }
4219     RefPtr&lt;RegisterID&gt; nextMethod = generator.emitGetById(generator.newTemporary(), iterator.get(), generator.propertyNames().next);
4220 
4221     if (m_targetPatterns.isEmpty()) {
4222         generator.emitIteratorClose(iterator.get(), this);
4223         return;
4224     }
4225 
4226     RefPtr&lt;RegisterID&gt; done;
4227     for (auto&amp; target : m_targetPatterns) {
4228         switch (target.bindingType) {
4229         case BindingType::Elision:
4230         case BindingType::Element: {
4231             Ref&lt;Label&gt; iterationSkipped = generator.newLabel();
4232             if (!done)
4233                 done = generator.newTemporary();
4234             else
4235                 generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4236 
4237             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4238             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4239             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4240             generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4241             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4242 
4243             {
4244                 Ref&lt;Label&gt; valueIsSet = generator.newLabel();
4245                 generator.emitJump(valueIsSet.get());
4246                 generator.emitLabel(iterationSkipped.get());
4247                 generator.emitLoad(value.get(), jsUndefined());
4248                 generator.emitLabel(valueIsSet.get());
4249             }
4250 
4251             if (target.bindingType == BindingType::Element) {
4252                 if (target.defaultValue)
4253                     assignDefaultValueIfUndefined(generator, value.get(), target.defaultValue);
4254                 target.pattern-&gt;bindValue(generator, value.get());
4255             }
4256             break;
4257         }
4258 
4259         case BindingType::RestElement: {
4260             RefPtr&lt;RegisterID&gt; array = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4261 
4262             Ref&lt;Label&gt; iterationDone = generator.newLabel();
4263             if (!done)
4264                 done = generator.newTemporary();
4265             else
4266                 generator.emitJumpIfTrue(done.get(), iterationDone.get());
4267 
4268             RefPtr&lt;RegisterID&gt; index = generator.newTemporary();
4269             generator.emitLoad(index.get(), jsNumber(0));
4270             Ref&lt;Label&gt; loopStart = generator.newLabel();
4271             generator.emitLabel(loopStart.get());
4272 
4273             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4274             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4275             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4276             generator.emitJumpIfTrue(done.get(), iterationDone.get());
4277             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4278 
4279             generator.emitDirectPutByVal(array.get(), index.get(), value.get());
4280             generator.emitInc(index.get());
4281             generator.emitJump(loopStart.get());
4282 
4283             generator.emitLabel(iterationDone.get());
4284             target.pattern-&gt;bindValue(generator, array.get());
4285             break;
4286         }
4287         }
4288     }
4289 
4290     Ref&lt;Label&gt; iteratorClosed = generator.newLabel();
4291     generator.emitJumpIfTrue(done.get(), iteratorClosed.get());
4292     generator.emitIteratorClose(iterator.get(), this);
4293     generator.emitLabel(iteratorClosed.get());
4294 }
4295 
4296 RegisterID* ArrayPatternNode::emitDirectBinding(BytecodeGenerator&amp; generator, RegisterID* dst, ExpressionNode* rhs)
4297 {
4298     if (!rhs-&gt;isSimpleArray())
4299         return nullptr;
4300 
4301     ElementNode* elementNodes = static_cast&lt;ArrayNode*&gt;(rhs)-&gt;elements();
4302     Vector&lt;ExpressionNode*&gt; elements;
4303     for (; elementNodes; elementNodes = elementNodes-&gt;next()) {
4304         ExpressionNode* value = elementNodes-&gt;value();
4305         if (value-&gt;isSpreadExpression())
4306             return nullptr;
4307         elements.append(value);
4308     }
4309 
4310     RefPtr&lt;RegisterID&gt; resultRegister;
4311     if (dst != generator.ignoredResult())
4312         resultRegister = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4313     if (m_targetPatterns.size() != elements.size())
4314         return nullptr;
4315     Vector&lt;RefPtr&lt;RegisterID&gt;&gt; registers;
4316     registers.reserveCapacity(m_targetPatterns.size());
4317     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4318         registers.uncheckedAppend(generator.newTemporary());
4319         generator.emitNode(registers.last().get(), elements[i]);
4320         if (m_targetPatterns[i].defaultValue)
4321             assignDefaultValueIfUndefined(generator, registers.last().get(), m_targetPatterns[i].defaultValue);
4322         if (resultRegister) {
4323             RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(i));
4324             generator.emitDirectPutByVal(resultRegister.get(), index.get(), registers.last().get());
4325         }
4326     }
4327 
4328     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4329         if (m_targetPatterns[i].pattern)
4330             m_targetPatterns[i].pattern-&gt;bindValue(generator, registers[i].get());
4331     }
4332     if (resultRegister)
4333         return generator.move(generator.finalDestination(dst, resultRegister.get()), resultRegister.get());
4334     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
4335 }
4336 
4337 void ArrayPatternNode::toString(StringBuilder&amp; builder) const
4338 {
4339     builder.append(&#39;[&#39;);
4340     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4341         const auto&amp; target = m_targetPatterns[i];
4342 
4343         switch (target.bindingType) {
4344         case BindingType::Elision:
4345             builder.append(&#39;,&#39;);
4346             break;
4347 
4348         case BindingType::Element:
4349             target.pattern-&gt;toString(builder);
4350             if (i &lt; m_targetPatterns.size() - 1)
4351                 builder.append(&#39;,&#39;);
4352             break;
4353 
4354         case BindingType::RestElement:
4355             builder.appendLiteral(&quot;...&quot;);
4356             target.pattern-&gt;toString(builder);
4357             break;
4358         }
4359     }
4360     builder.append(&#39;]&#39;);
4361 }
4362 
4363 void ArrayPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4364 {
4365     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4366         if (DestructuringPatternNode* node = m_targetPatterns[i].pattern)
4367             node-&gt;collectBoundIdentifiers(identifiers);
4368     }
4369 }
4370 
4371 void ObjectPatternNode::toString(StringBuilder&amp; builder) const
4372 {
4373     builder.append(&#39;{&#39;);
4374     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4375         if (m_targetPatterns[i].wasString)
4376             builder.appendQuotedJSONString(m_targetPatterns[i].propertyName.string());
4377         else
4378             builder.append(m_targetPatterns[i].propertyName.string());
4379         builder.append(&#39;:&#39;);
4380         m_targetPatterns[i].pattern-&gt;toString(builder);
4381         if (i &lt; m_targetPatterns.size() - 1)
4382             builder.append(&#39;,&#39;);
4383     }
4384     builder.append(&#39;}&#39;);
4385 }
4386 
4387 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4388 {
4389     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4390 
4391     RefPtr&lt;RegisterID&gt; excludedList;
4392     IdentifierSet excludedSet;
4393     RefPtr&lt;RegisterID&gt; addMethod;
4394     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
4395         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());
4396 
4397         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4398         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4399         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4400 
4401         CallArguments args(generator, nullptr, 0);
4402         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4403 
4404         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4405     }
4406 
4407     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
4408     generator.preserveTDZStack(preservedTDZStack);
4409 
4410     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4411         const auto&amp; target = m_targetPatterns[i];
4412         if (target.bindingType == BindingType::Element) {
4413             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4414             RefPtr&lt;RegisterID&gt; propertyName;
4415             if (!target.propertyExpression) {
4416                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4417                 if (!optionalIndex)
4418                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4419                 else {
4420                     RefPtr&lt;RegisterID&gt; propertyIndex = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
4421                     generator.emitGetByVal(temp.get(), rhs, propertyIndex.get());
4422                 }
4423             } else {
4424                 propertyName = generator.emitNodeForProperty(target.propertyExpression);
4425                 generator.emitGetByVal(temp.get(), rhs, propertyName.get());
4426             }
4427 
4428             if (m_containsRestElement) {
4429                 if (m_containsComputedProperty) {
4430                     if (!target.propertyExpression)
4431                         propertyName = generator.emitLoad(nullptr, target.propertyName);
4432 
4433                     CallArguments args(generator, nullptr, 1);
4434                     generator.move(args.thisRegister(), excludedList.get());
4435                     generator.move(args.argumentRegister(0), propertyName.get());
4436                     generator.emitCall(generator.newTemporary(), addMethod.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4437                 } else
4438                     excludedSet.add(target.propertyName.impl());
4439             }
4440 
4441             if (target.defaultValue)
4442                 assignDefaultValueIfUndefined(generator, temp.get(), target.defaultValue);
4443             target.pattern-&gt;bindValue(generator, temp.get());
4444         } else {
4445             ASSERT(target.bindingType == BindingType::RestElement);
4446             ASSERT(i == m_targetPatterns.size() - 1);
4447             RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
4448 
4449             // load and call @copyDataProperties
4450             auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesPrivateName());
4451 
4452             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4453             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4454             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4455 
4456             CallArguments args(generator, nullptr, 3);
4457             generator.emitLoad(args.thisRegister(), jsUndefined());
4458             generator.move(args.argumentRegister(0), newObject.get());
4459             generator.move(args.argumentRegister(1), rhs);
4460             if (m_containsComputedProperty)
4461                 generator.move(args.argumentRegister(2), excludedList.get());
4462             else {
4463                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4464                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4465             }
4466 
4467             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4468             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4469             target.pattern-&gt;bindValue(generator, result.get());
4470         }
4471     }
4472 
4473     generator.restoreTDZStack(preservedTDZStack);
4474 }
4475 
4476 void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4477 {
4478     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
4479         m_targetPatterns[i].pattern-&gt;collectBoundIdentifiers(identifiers);
4480 }
4481 
4482 void BindingNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4483 {
4484     Variable var = generator.variable(m_boundProperty);
4485     bool isReadOnly = var.isReadOnly() &amp;&amp; m_bindingContext != AssignmentContext::ConstDeclarationStatement;
4486     if (RegisterID* local = var.local()) {
4487         if (m_bindingContext == AssignmentContext::AssignmentExpression)
4488             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4489         if (isReadOnly) {
4490             generator.emitReadOnlyExceptionIfNeeded(var);
4491             return;
4492         }
4493         generator.move(local, value);
4494         generator.emitProfileType(local, var, divotStart(), divotEnd());
4495         if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4496             generator.liftTDZCheckIfPossible(var);
4497         return;
4498     }
4499     if (generator.isStrictMode())
4500         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4501     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4502     generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4503     if (m_bindingContext == AssignmentContext::AssignmentExpression)
4504         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4505     if (isReadOnly) {
4506         generator.emitReadOnlyExceptionIfNeeded(var);
4507         return;
4508     }
4509     generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_bindingContext));
4510     generator.emitProfileType(value, var, divotStart(), divotEnd());
4511     if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4512         generator.liftTDZCheckIfPossible(var);
4513     return;
4514 }
4515 
4516 void BindingNode::toString(StringBuilder&amp; builder) const
4517 {
4518     builder.append(m_boundProperty.string());
4519 }
4520 
4521 void BindingNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4522 {
4523     identifiers.append(m_boundProperty);
4524 }
4525 
4526 void AssignmentElementNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const
4527 {
4528 }
4529 
4530 void AssignmentElementNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4531 {
4532     if (m_assignmentTarget-&gt;isResolveNode()) {
4533         ResolveNode* lhs = static_cast&lt;ResolveNode*&gt;(m_assignmentTarget);
4534         Variable var = generator.variable(lhs-&gt;identifier());
4535         bool isReadOnly = var.isReadOnly();
4536         if (RegisterID* local = var.local()) {
4537             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4538 
4539             if (isReadOnly)
4540                 generator.emitReadOnlyExceptionIfNeeded(var);
4541             else {
4542                 generator.move(local, value);
4543                 generator.emitProfileType(local, divotStart(), divotEnd());
4544             }
4545             return;
4546         }
4547         if (generator.isStrictMode())
4548             generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4549         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4550         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4551         if (isReadOnly) {
4552             bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
4553             if (threwException)
4554                 return;
4555         }
4556         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4557         if (!isReadOnly) {
4558             generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
4559             generator.emitProfileType(value, var, divotStart(), divotEnd());
4560         }
4561     } else if (m_assignmentTarget-&gt;isDotAccessorNode()) {
4562         DotAccessorNode* lhs = static_cast&lt;DotAccessorNode*&gt;(m_assignmentTarget);
4563         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4564         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4565         if (lhs-&gt;base()-&gt;isSuperNode()) {
4566             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4567             generator.emitPutById(base.get(), thisValue.get(), lhs-&gt;identifier(), value);
4568         } else
4569             generator.emitPutById(base.get(), lhs-&gt;identifier(), value);
4570         generator.emitProfileType(value, divotStart(), divotEnd());
4571     } else if (m_assignmentTarget-&gt;isBracketAccessorNode()) {
4572         BracketAccessorNode* lhs = static_cast&lt;BracketAccessorNode*&gt;(m_assignmentTarget);
4573         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4574         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(lhs-&gt;subscript(), true, false);
4575         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4576         if (lhs-&gt;base()-&gt;isSuperNode()) {
4577             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4578             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
4579         } else
4580             generator.emitPutByVal(base.get(), property.get(), value);
4581         generator.emitProfileType(value, divotStart(), divotEnd());
4582     }
4583 }
4584 
4585 void AssignmentElementNode::toString(StringBuilder&amp; builder) const
4586 {
4587     if (m_assignmentTarget-&gt;isResolveNode())
4588         builder.append(static_cast&lt;ResolveNode*&gt;(m_assignmentTarget)-&gt;identifier().string());
4589 }
4590 
4591 void RestParameterNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4592 {
4593     m_pattern-&gt;collectBoundIdentifiers(identifiers);
4594 }
4595 
4596 void RestParameterNode::toString(StringBuilder&amp; builder) const
4597 {
4598     builder.appendLiteral(&quot;...&quot;);
4599     m_pattern-&gt;toString(builder);
4600 }
4601 
4602 void RestParameterNode::bindValue(BytecodeGenerator&amp;, RegisterID*) const
4603 {
4604     RELEASE_ASSERT_NOT_REACHED();
4605 }
4606 
4607 void RestParameterNode::emit(BytecodeGenerator&amp; generator)
4608 {
4609     RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4610     generator.emitRestParameter(temp.get(), m_numParametersToSkip);
4611     m_pattern-&gt;bindValue(generator, temp.get());
4612 }
4613 
4614 
4615 RegisterID* SpreadExpressionNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4616 {
4617     RELEASE_ASSERT_NOT_REACHED();
4618     return 0;
4619 }
4620 
4621 RegisterID* ObjectSpreadExpressionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4622 {
4623     RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
4624     generator.emitNode(src.get(), m_expression);
4625 
4626     // load and call @copyDataPropertiesNoExclusions
4627     auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesNoExclusionsPrivateName());
4628 
4629     RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();
4630     generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));
4631     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
4632 
4633     CallArguments args(generator, nullptr, 2);
4634     generator.emitLoad(args.thisRegister(), jsUndefined());
4635     generator.move(args.argumentRegister(0), dst);
4636     generator.move(args.argumentRegister(1), src.get());
4637 
4638     generator.emitCall(generator.newTemporary(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4639 
4640     return dst;
4641 }
4642 
4643 } // namespace JSC
    </pre>
  </body>
</html>