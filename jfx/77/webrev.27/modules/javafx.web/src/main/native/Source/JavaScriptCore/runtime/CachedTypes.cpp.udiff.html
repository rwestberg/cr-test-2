<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ButterflyInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,30 +24,35 @@</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;CachedTypes.h&quot;
  
<span class="udiff-line-added">+ #include &quot;BytecodeCacheError.h&quot;</span>
  #include &quot;BytecodeCacheVersion.h&quot;
  #include &quot;BytecodeLivenessAnalysis.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;JSCast.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;JSCInlines.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;ScopedArgumentsTable.h&quot;
  #include &quot;SourceCodeKey.h&quot;
<span class="udiff-line-added">+ #include &quot;SourceProvider.h&quot;</span>
  #include &quot;UnlinkedEvalCodeBlock.h&quot;
  #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  #include &quot;UnlinkedProgramCodeBlock.h&quot;
  #include &lt;wtf/FastMalloc.h&gt;
<span class="udiff-line-removed">- #include &lt;wtf/Forward.h&gt;</span>
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/UUID.h&gt;
<span class="udiff-line-modified-removed">- #include &lt;wtf/text/AtomicStringImpl.h&gt;</span>
<span class="udiff-line-modified-added">+ #include &lt;wtf/text/AtomStringImpl.h&gt;</span>
  
  namespace JSC {
  
<span class="udiff-line-added">+ namespace Yarr {</span>
<span class="udiff-line-added">+ enum class Flags : uint8_t;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template &lt;typename T, typename = void&gt;
  struct SourceTypeImpl {
      using type = T;
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,23 +86,24 @@</span>
  
          uint8_t* m_buffer;
          ptrdiff_t m_offset;
      };
  
<span class="udiff-line-modified-removed">-     Encoder(VM&amp; vm)</span>
<span class="udiff-line-modified-added">+     Encoder(VM&amp; vm, FileSystem::PlatformFileHandle fd = FileSystem::invalidPlatformFileHandle)</span>
          : m_vm(vm)
<span class="udiff-line-added">+         , m_fd(fd)</span>
          , m_baseOffset(0)
          , m_currentPage(nullptr)
      {
          allocateNewPage();
      }
  
      VM&amp; vm() { return m_vm; }
  
      Allocation malloc(unsigned size)
      {
<span class="udiff-line-modified-removed">-         ASSERT(size);</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(size);</span>
          ptrdiff_t offset;
          if (m_currentPage-&gt;malloc(size, offset))
              return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
          allocateNewPage(size);
          return malloc(size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,32 +131,76 @@</span>
      void cachePtr(const void* ptr, ptrdiff_t offset)
      {
          m_ptrToOffsetMap.add(ptr, offset);
      }
  
<span class="udiff-line-modified-removed">-     WTF::Optional&lt;ptrdiff_t&gt; offsetForPtr(const void* ptr)</span>
<span class="udiff-line-modified-added">+     Optional&lt;ptrdiff_t&gt; cachedOffsetForPtr(const void* ptr)</span>
      {
          auto it = m_ptrToOffsetMap.find(ptr);
          if (it == m_ptrToOffsetMap.end())
              return WTF::nullopt;
          return { it-&gt;value };
      }
  
<span class="udiff-line-modified-removed">-     std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; release()</span>
<span class="udiff-line-modified-added">+     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         m_leafExecutables.add(executable, offset);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)</span>
      {
<span class="udiff-line-added">+         if (!m_currentPage)</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         m_currentPage-&gt;alignEnd();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (FileSystem::isHandleValid(m_fd)) {</span>
<span class="udiff-line-added">+             return releaseMapped(error);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          size_t size = m_baseOffset + m_currentPage-&gt;size();
          MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
          unsigned offset = 0;
          for (const auto&amp; page : m_pages) {
              memcpy(buffer.get() + offset, page.buffer(), page.size());
              offset += page.size();
          }
          RELEASE_ASSERT(offset == size);
<span class="udiff-line-modified-removed">-         return { WTFMove(buffer), size };</span>
<span class="udiff-line-modified-added">+         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));</span>
      }
  
  private:
<span class="udiff-line-added">+     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         size_t size = m_baseOffset + m_currentPage-&gt;size();</span>
<span class="udiff-line-added">+         if (!FileSystem::truncateFile(m_fd, size)) {</span>
<span class="udiff-line-added">+             error = BytecodeCacheError::StandardError(errno);</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (const auto&amp; page : m_pages) {</span>
<span class="udiff-line-added">+             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());</span>
<span class="udiff-line-added">+             if (bytesWritten == -1) {</span>
<span class="udiff-line-added">+                 error = BytecodeCacheError::StandardError(errno);</span>
<span class="udiff-line-added">+                 return nullptr;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {</span>
<span class="udiff-line-added">+                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());</span>
<span class="udiff-line-added">+                 return nullptr;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         bool success;</span>
<span class="udiff-line-added">+         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);</span>
<span class="udiff-line-added">+         if (!success) {</span>
<span class="udiff-line-added">+             error = BytecodeCacheError::StandardError(errno);</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      class Page {
      public:
          Page(size_t size)
              : m_offset(0)
              , m_capacity(size)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159,12 +209,12 @@</span>
          }
  
          bool malloc(size_t size, ptrdiff_t&amp; result)
          {
              size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<span class="udiff-line-modified-removed">-             ptrdiff_t offset = WTF::roundUpToMultipleOf(alignment, m_offset);</span>
<span class="udiff-line-modified-removed">-             size = WTF::roundUpToMultipleOf(alignment, size);</span>
<span class="udiff-line-modified-added">+             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);</span>
<span class="udiff-line-modified-added">+             size = roundUpToMultipleOf(alignment, size);</span>
              if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
                  return false;
  
              result = offset;
              m_offset = offset + size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -182,94 +232,126 @@</span>
                  return true;
              }
              return false;
          }
  
<span class="udiff-line-added">+         void alignEnd()</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);</span>
<span class="udiff-line-added">+             if (size == m_offset)</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);</span>
<span class="udiff-line-added">+             m_offset = size;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
      private:
          MallocPtr&lt;uint8_t&gt; m_buffer;
          ptrdiff_t m_offset;
          size_t m_capacity;
      };
  
      void allocateNewPage(size_t size = 0)
      {
<span class="udiff-line-modified-removed">-         static size_t minPageSize = WTF::pageSize();</span>
<span class="udiff-line-modified-removed">-         if (m_currentPage)</span>
<span class="udiff-line-modified-added">+         static size_t minPageSize = pageSize();</span>
<span class="udiff-line-modified-added">+         if (m_currentPage) {</span>
<span class="udiff-line-added">+             m_currentPage-&gt;alignEnd();</span>
              m_baseOffset += m_currentPage-&gt;size();
<span class="udiff-line-added">+         }</span>
          if (size &lt; minPageSize)
              size = minPageSize;
          else
<span class="udiff-line-modified-removed">-             size = WTF::roundUpToMultipleOf(minPageSize, size);</span>
<span class="udiff-line-modified-added">+             size = roundUpToMultipleOf(minPageSize, size);</span>
          m_pages.append(Page { size });
          m_currentPage = &amp;m_pages.last();
      }
  
      VM&amp; m_vm;
<span class="udiff-line-added">+     FileSystem::PlatformFileHandle m_fd;</span>
      ptrdiff_t m_baseOffset;
      Page* m_currentPage;
      Vector&lt;Page&gt; m_pages;
      HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
<span class="udiff-line-added">+     LeafExecutableMap m_leafExecutables;</span>
  };
  
<span class="udiff-line-modified-removed">- class Decoder {</span>
<span class="udiff-line-modified-removed">-     WTF_MAKE_NONCOPYABLE(Decoder);</span>
<span class="udiff-line-modified-removed">-     WTF_FORBID_HEAP_ALLOCATION;</span>
<span class="udiff-line-modified-added">+ Decoder::Decoder(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="udiff-line-modified-added">+     : m_vm(vm)</span>
<span class="udiff-line-modified-added">+     , m_cachedBytecode(WTFMove(cachedBytecode))</span>
<span class="udiff-line-added">+     , m_provider(provider)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- public:</span>
<span class="udiff-line-modified-removed">-     Decoder(VM&amp; vm, const void* baseAddress, size_t size)</span>
<span class="udiff-line-modified-removed">-         : m_vm(vm)</span>
<span class="udiff-line-modified-removed">-         , m_baseAddress(reinterpret_cast&lt;const uint8_t*&gt;(baseAddress))</span>
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-removed">-         , m_size(size)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         UNUSED_PARAM(size);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ Decoder::~Decoder()</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     for (auto&amp; finalizer : m_finalizers)</span>
<span class="udiff-line-modified-added">+         finalizer();</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     ~Decoder()</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         for (auto&amp; pair : m_finalizers)</span>
<span class="udiff-line-modified-removed">-             pair.value();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ Ref&lt;Decoder&gt; Decoder::create(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     return adoptRef(*new Decoder(vm, WTFMove(cachedBytecode), WTFMove(provider)));</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     VM&amp; vm() { return m_vm; }</span>
<span class="udiff-line-modified-added">+ size_t Decoder::size() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return m_cachedBytecode-&gt;size();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     ptrdiff_t offsetOf(const void* ptr)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="udiff-line-modified-removed">-         ASSERT(addr &gt;= m_baseAddress &amp;&amp; addr &lt; m_baseAddress + m_size);</span>
<span class="udiff-line-modified-removed">-         return addr - m_baseAddress;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ ptrdiff_t Decoder::offsetOf(const void* ptr)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="udiff-line-modified-added">+     ASSERT(addr &gt;= m_cachedBytecode-&gt;data() &amp;&amp; addr &lt; m_cachedBytecode-&gt;data() + m_cachedBytecode-&gt;size());</span>
<span class="udiff-line-modified-added">+     return addr - m_cachedBytecode-&gt;data();</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     void cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         m_offsetToPtrMap.add(offset, ptr);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ void Decoder::cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     m_offsetToPtrMap.add(offset, ptr);</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     WTF::Optional&lt;void*&gt; ptrForOffset(ptrdiff_t offset)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         auto it = m_offsetToPtrMap.find(offset);</span>
<span class="udiff-line-modified-removed">-         if (it == m_offsetToPtrMap.end())</span>
<span class="udiff-line-modified-removed">-             return WTF::nullopt;</span>
<span class="udiff-line-modified-removed">-         return { it-&gt;value };</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ WTF::Optional&lt;void*&gt; Decoder::cachedPtrForOffset(ptrdiff_t offset)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     auto it = m_offsetToPtrMap.find(offset);</span>
<span class="udiff-line-modified-added">+     if (it == m_offsetToPtrMap.end())</span>
<span class="udiff-line-modified-added">+         return WTF::nullopt;</span>
<span class="udiff-line-modified-added">+     return { it-&gt;value };</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     template&lt;typename Functor&gt;</span>
<span class="udiff-line-modified-removed">-     void addFinalizer(ptrdiff_t offset, const Functor&amp; fn)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         m_finalizers.add(offset, fn);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ const void* Decoder::ptrForOffsetFromBase(ptrdiff_t offset)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     ASSERT(offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(offset) &lt; m_cachedBytecode-&gt;size());</span>
<span class="udiff-line-modified-added">+     return m_cachedBytecode-&gt;data() + offset;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">- private:</span>
<span class="udiff-line-modified-removed">-     VM&amp; m_vm;</span>
<span class="udiff-line-modified-removed">-     const uint8_t* m_baseAddress;</span>
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-modified-removed">-     size_t m_size;</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-     HashMap&lt;ptrdiff_t, void*&gt; m_offsetToPtrMap;</span>
<span class="udiff-line-modified-removed">-     HashMap&lt;ptrdiff_t, std::function&lt;void()&gt;&gt; m_finalizers;</span>
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-added">+ CompactVariableMap::Handle Decoder::handleForEnvironment(CompactVariableEnvironment* environment) const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     auto it = m_environmentToHandleMap.find(environment);</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(it != m_environmentToHandleMap.end());</span>
<span class="udiff-line-modified-added">+     return it-&gt;value;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void Decoder::setHandleForEnvironment(CompactVariableEnvironment* environment, const CompactVariableMap::Handle&amp; handle)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-added">+     auto addResult = m_environmentToHandleMap.add(environment, handle);</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(addResult.isNewEntry);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Decoder::addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_cachedBytecode-&gt;leafExecutables().add(executable, offset);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template&lt;typename Functor&gt;</span>
<span class="udiff-line-added">+ void Decoder::addFinalizer(const Functor&amp; fn)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_finalizers.append(fn);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ RefPtr&lt;SourceProvider&gt; Decoder::provider() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return m_provider;</span>
<span class="udiff-line-added">+ }</span>
  
  template&lt;typename T&gt;
  static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
  {
      dst = src;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -313,35 +395,48 @@</span>
      using SourceType_ = Source;
  
      CachedObject() = default;
  
      inline void* operator new(size_t, void* where) { return where; }
<span class="udiff-line-added">+     void* operator new[](size_t, void* where) { return where; }</span>
  
      // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
<span class="udiff-line-removed">-     void* operator new[](size_t, void*) = delete;</span>
      void* operator new(size_t) = delete;
      void operator delete(void*) = delete;
      void* operator new[](size_t size) = delete;
      void operator delete[](void*) = delete;
      void* operator new(size_t, NotNullTag, void* location) = delete;
  };
  
  template&lt;typename Source&gt;
<span class="udiff-line-modified-removed">- class VariableLengthObject : public CachedObject&lt;Source&gt; {</span>
<span class="udiff-line-modified-added">+ class VariableLengthObject : public CachedObject&lt;Source&gt;, VariableLengthObjectBase {</span>
      template&lt;typename, typename&gt;
<span class="udiff-line-modified-removed">-     friend struct CachedPtr;</span>
<span class="udiff-line-modified-added">+     friend class CachedPtr;</span>
<span class="udiff-line-added">+     friend struct CachedPtrOffsets;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     VariableLengthObject()</span>
<span class="udiff-line-added">+         : VariableLengthObjectBase(s_invalidOffset)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     bool isEmpty() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return m_offset == s_invalidOffset;</span>
<span class="udiff-line-added">+     }</span>
  
  protected:
      const uint8_t* buffer() const
      {
<span class="udiff-line-modified-removed">-         ASSERT(m_offset != s_invalidOffset);</span>
<span class="udiff-line-modified-removed">-         return reinterpret_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
<span class="udiff-line-modified-added">+         ASSERT(!isEmpty());</span>
<span class="udiff-line-modified-added">+         return bitwise_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
      }
  
      template&lt;typename T&gt;
      const T* buffer() const
      {
<span class="udiff-line-added">+         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(buffer()) % alignof(T)));</span>
          return bitwise_cast&lt;const T*&gt;(buffer());
      }
  
      uint8_t* allocate(Encoder&amp; encoder, size_t size)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -350,74 +445,91 @@</span>
          m_offset = result.offset() - offsetOffset;
          return result.buffer();
      }
  
      template&lt;typename T&gt;
<span class="udiff-line-added">+ #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)</span>
<span class="udiff-line-added">+     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:</span>
<span class="udiff-line-added">+     // &lt;rdar://problem/49792205&gt;</span>
<span class="udiff-line-added">+     __attribute__((optnone))</span>
<span class="udiff-line-added">+ #endif</span>
      T* allocate(Encoder&amp; encoder, unsigned size = 1)
      {
          uint8_t* result = allocate(encoder, sizeof(T) * size);
<span class="udiff-line-modified-removed">-         return new (result) T();</span>
<span class="udiff-line-modified-added">+         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));</span>
<span class="udiff-line-added">+         return new (result) T[size];</span>
      }
  
  private:
      constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ptrdiff_t m_offset { s_invalidOffset };</span>
<span class="udiff-line-removed">- </span>
  };
  
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
      template&lt;typename, typename&gt;
<span class="udiff-line-modified-removed">-     friend struct CachedRefPtr;</span>
<span class="udiff-line-modified-added">+     friend class CachedRefPtr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     friend struct CachedPtrOffsets;</span>
  
  public:
      void encode(Encoder&amp; encoder, const Source* src)
      {
<span class="udiff-line-modified-removed">-         m_isEmpty = !src;</span>
<span class="udiff-line-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-modified-added">+         if (!src)</span>
              return;
  
<span class="udiff-line-modified-removed">-         if (WTF::Optional&lt;ptrdiff_t&gt; offset = encoder.offsetForPtr(src)) {</span>
<span class="udiff-line-modified-added">+         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {</span>
              this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
              return;
          }
  
          T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
          cachedObject-&gt;encode(encoder, *src);
          encoder.cachePtr(src, encoder.offsetOf(cachedObject));
      }
  
      template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">-     Source* decode(Decoder&amp; decoder, Args... args) const</span>
<span class="udiff-line-modified-added">+     Source* decode(Decoder&amp; decoder, bool&amp; isNewAllocation, Args&amp;&amp;... args) const</span>
      {
<span class="udiff-line-modified-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-modified-added">+         if (this-&gt;isEmpty()) {</span>
<span class="udiff-line-added">+             isNewAllocation = false;</span>
              return nullptr;
<span class="udiff-line-added">+         }</span>
  
          ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
<span class="udiff-line-modified-removed">-         if (WTF::Optional&lt;void*&gt; ptr = decoder.ptrForOffset(bufferOffset))</span>
<span class="udiff-line-modified-removed">-             return reinterpret_cast&lt;Source*&gt;(*ptr);</span>
<span class="udiff-line-modified-added">+         if (Optional&lt;void*&gt; ptr = decoder.cachedPtrForOffset(bufferOffset)) {</span>
<span class="udiff-line-modified-added">+             isNewAllocation = false;</span>
<span class="udiff-line-added">+             return static_cast&lt;Source*&gt;(*ptr);</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-         Source* ptr = get()-&gt;decode(decoder, args...);</span>
<span class="udiff-line-modified-added">+         isNewAllocation = true;</span>
<span class="udiff-line-added">+         Source* ptr = get()-&gt;decode(decoder, std::forward&lt;Args&gt;(args)...);</span>
          decoder.cacheOffset(bufferOffset, ptr);
          return ptr;
      }
  
<span class="udiff-line-added">+     template&lt;typename... Args&gt;</span>
<span class="udiff-line-added">+     Source* decode(Decoder&amp; decoder, Args&amp;&amp;... args) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         bool unusedIsNewAllocation;</span>
<span class="udiff-line-added">+         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      const T* operator-&gt;() const { return get(); }
  
  private:
      const T* get() const
      {
<span class="udiff-line-modified-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(!this-&gt;isEmpty());</span>
          return this-&gt;template buffer&lt;T&gt;();
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bool m_isEmpty;</span>
<span class="udiff-line-removed">- </span>
  };
  
<span class="udiff-line-added">+ ptrdiff_t CachedPtrOffsets::offsetOffset()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
  public:
      void encode(Encoder&amp; encoder, const Source* src)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -429,14 +541,19 @@</span>
          encode(encoder, src.get());
      }
  
      RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
      {
<span class="udiff-line-modified-removed">-         Source* decodedPtr = m_ptr.decode(decoder);</span>
<span class="udiff-line-modified-added">+         bool isNewAllocation;</span>
<span class="udiff-line-added">+         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);</span>
          if (!decodedPtr)
              return nullptr;
<span class="udiff-line-modified-removed">-         decoder.addFinalizer(decoder.offsetOf(m_ptr.buffer()), [=] { derefIfNotNull(decodedPtr); });</span>
<span class="udiff-line-modified-added">+         if (isNewAllocation) {</span>
<span class="udiff-line-added">+             decoder.addFinalizer([=] {</span>
<span class="udiff-line-added">+                 derefIfNotNull(decodedPtr);</span>
<span class="udiff-line-added">+             });</span>
<span class="udiff-line-added">+         }</span>
          refIfNotNull(decodedPtr);
          return adoptRef(decodedPtr);
      }
  
      void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,11 +565,15 @@</span>
      CachedPtr&lt;T, Source&gt; m_ptr;
  };
  
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
<span class="udiff-line-added">+     friend struct CachedWriteBarrierOffsets;</span>
<span class="udiff-line-added">+ </span>
  public:
<span class="udiff-line-added">+     bool isEmpty() const { return m_ptr.isEmpty(); }</span>
<span class="udiff-line-added">+ </span>
      void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
      {
          m_ptr.encode(encoder, src.get());
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -465,10 +586,15 @@</span>
  
  private:
      CachedPtr&lt;T, Source&gt; m_ptr;
  };
  
<span class="udiff-line-added">+ ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
  class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
  public:
      void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -540,15 +666,16 @@</span>
  
  private:
      CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
  };
  
<span class="udiff-line-modified-removed">- class CachedUniquedStringImpl : public VariableLengthObject&lt;UniquedStringImpl&gt; {</span>
<span class="udiff-line-modified-added">+ template&lt;typename T&gt;</span>
<span class="udiff-line-added">+ class CachedUniquedStringImplBase : public VariableLengthObject&lt;T&gt; {</span>
  public:
      void encode(Encoder&amp; encoder, const StringImpl&amp; string)
      {
<span class="udiff-line-modified-removed">-         m_isAtomic = string.isAtomic();</span>
<span class="udiff-line-modified-added">+         m_isAtomic = string.isAtom();</span>
          m_isSymbol = string.isSymbol();
          RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
  
          if (m_isSymbol) {
              SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -580,52 +707,39 @@</span>
  
      UniquedStringImpl* decode(Decoder&amp; decoder) const
      {
          auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
              if (!m_isSymbol)
<span class="udiff-line-modified-removed">-                 return AtomicStringImpl::add(buffer, m_length).leakRef();</span>
<span class="udiff-line-modified-added">+                 return AtomStringImpl::add(buffer, m_length).leakRef();</span>
  
<span class="udiff-line-modified-removed">-             Identifier ident = Identifier::fromString(&amp;decoder.vm(), buffer, m_length);</span>
<span class="udiff-line-modified-added">+             Identifier ident = Identifier::fromString(decoder.vm(), buffer, m_length);</span>
              String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
              StringImpl* impl = str.releaseImpl().get();
              ASSERT(impl-&gt;isSymbol());
              return static_cast&lt;UniquedStringImpl*&gt;(impl);
          };
  
          if (!m_length) {
              if (m_isSymbol)
                  return &amp;SymbolImpl::createNullSymbol().leakRef();
<span class="udiff-line-modified-removed">-             return AtomicStringImpl::add(&quot;&quot;).leakRef();</span>
<span class="udiff-line-modified-added">+             return AtomStringImpl::add(&quot;&quot;).leakRef();</span>
          }
  
          if (m_is8Bit)
<span class="udiff-line-modified-removed">-             return create(this-&gt;buffer&lt;LChar&gt;());</span>
<span class="udiff-line-modified-removed">-         return create(this-&gt;buffer&lt;UChar&gt;());</span>
<span class="udiff-line-modified-added">+             return create(this-&gt;template buffer&lt;LChar&gt;());</span>
<span class="udiff-line-modified-added">+         return create(this-&gt;template buffer&lt;UChar&gt;());</span>
      }
  
  private:
      bool m_is8Bit : 1;
      bool m_isSymbol : 1;
      bool m_isAtomic : 1;
      unsigned m_length;
  };
  
<span class="udiff-line-modified-removed">- class CachedStringImpl : public VariableLengthObject&lt;StringImpl&gt; {</span>
<span class="udiff-line-modified-removed">- public:</span>
<span class="udiff-line-removed">-     void encode(Encoder&amp; encoder, const StringImpl&amp; impl)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         m_uniquedStringImpl.encode(encoder, impl);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     StringImpl* decode(Decoder&amp; decoder) const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return m_uniquedStringImpl.decode(decoder);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-     CachedUniquedStringImpl m_uniquedStringImpl;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-modified-added">+ class CachedUniquedStringImpl : public CachedUniquedStringImplBase&lt;UniquedStringImpl&gt; { };</span>
<span class="udiff-line-modified-added">+ class CachedStringImpl : public CachedUniquedStringImplBase&lt;StringImpl&gt; { };</span>
  
  class CachedString : public VariableLengthObject&lt;String&gt; {
  public:
      void encode(Encoder&amp; encoder, const String&amp; string)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -657,11 +771,11 @@</span>
      {
          String str = m_string.decode(decoder);
          if (str.isNull())
              return Identifier();
  
<span class="udiff-line-modified-removed">-         return Identifier::fromUid(&amp;decoder.vm(), (UniquedStringImpl*)str.impl());</span>
<span class="udiff-line-modified-added">+         return Identifier::fromUid(decoder.vm(), (UniquedStringImpl*)str.impl());</span>
      }
  
      void decode(Decoder&amp; decoder, Identifier&amp; ident) const
      {
          ident = decode(decoder);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -670,31 +784,29 @@</span>
  private:
      CachedString m_string;
  };
  
  template&lt;typename T&gt;
<span class="udiff-line-modified-removed">- class CachedOptional : public VariableLengthObject&lt;WTF::Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
<span class="udiff-line-modified-added">+ class CachedOptional : public VariableLengthObject&lt;Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
  public:
<span class="udiff-line-modified-removed">-     void encode(Encoder&amp; encoder, const WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
<span class="udiff-line-modified-added">+     void encode(Encoder&amp; encoder, const Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
      {
<span class="udiff-line-modified-removed">-         m_isEmpty = !source;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-modified-added">+         if (!source)</span>
              return;
  
          this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
      }
  
<span class="udiff-line-modified-removed">-     WTF::Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
<span class="udiff-line-modified-added">+     Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
      {
<span class="udiff-line-modified-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-modified-added">+         if (this-&gt;isEmpty())</span>
              return WTF::nullopt;
  
          return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
      }
  
<span class="udiff-line-modified-removed">-     void decode(Decoder&amp; decoder, WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
<span class="udiff-line-modified-added">+     void decode(Decoder&amp; decoder, Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
      {
          dst = decode(decoder);
      }
  
      void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -702,21 +814,10 @@</span>
          if (!source)
              encode(encoder, WTF::nullopt);
          else
              encode(encoder, { *source });
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     SourceType&lt;T&gt;* decodeAsPtr(Decoder&amp; decoder) const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         if (m_isEmpty)</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-     bool m_isEmpty;</span>
  };
  
  class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
  public:
      void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -876,10 +977,75 @@</span>
  private:
      bool m_isEverythingCaptured;
      CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
  };
  
<span class="udiff-line-added">+ class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         m_variables.encode(encoder, env.m_variables);</span>
<span class="udiff-line-added">+         m_variableMetadata.encode(encoder, env.m_variableMetadata);</span>
<span class="udiff-line-added">+         m_hash = env.m_hash;</span>
<span class="udiff-line-added">+         m_isEverythingCaptured = env.m_isEverythingCaptured;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         m_variables.decode(decoder, env.m_variables);</span>
<span class="udiff-line-added">+         m_variableMetadata.decode(decoder, env.m_variableMetadata);</span>
<span class="udiff-line-added">+         env.m_hash = m_hash;</span>
<span class="udiff-line-added">+         env.m_isEverythingCaptured = m_isEverythingCaptured;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CompactVariableEnvironment* decode(Decoder&amp; decoder) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         CompactVariableEnvironment* env = new CompactVariableEnvironment;</span>
<span class="udiff-line-added">+         decode(decoder, *env);</span>
<span class="udiff-line-added">+         return env;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;</span>
<span class="udiff-line-added">+     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;</span>
<span class="udiff-line-added">+     unsigned m_hash;</span>
<span class="udiff-line-added">+     bool m_isEverythingCaptured;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         m_environment.encode(encoder, handle.m_environment);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CompactVariableMap::Handle decode(Decoder&amp; decoder) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         bool isNewAllocation;</span>
<span class="udiff-line-added">+         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);</span>
<span class="udiff-line-added">+         if (!environment) {</span>
<span class="udiff-line-added">+             ASSERT(!isNewAllocation);</span>
<span class="udiff-line-added">+             return CompactVariableMap::Handle();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (!isNewAllocation)</span>
<span class="udiff-line-added">+             return decoder.handleForEnvironment(environment);</span>
<span class="udiff-line-added">+         bool isNewEntry;</span>
<span class="udiff-line-added">+         CompactVariableMap::Handle handle = decoder.vm().m_compactVariableMap-&gt;get(environment, isNewEntry);</span>
<span class="udiff-line-added">+         if (!isNewEntry) {</span>
<span class="udiff-line-added">+             decoder.addFinalizer([=] {</span>
<span class="udiff-line-added">+                 delete environment;</span>
<span class="udiff-line-added">+             });</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         decoder.setHandleForEnvironment(environment, handle);</span>
<span class="udiff-line-added">+         return handle;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     CachedPtr&lt;CachedCompactVariableEnvironment&gt; m_environment;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
  class CachedArray : public VariableLengthObject&lt;Source*&gt; {
  public:
      void encode(Encoder&amp; encoder, const Source* array, unsigned size)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -904,17 +1070,17 @@</span>
  class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
  public:
      void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
      {
          m_length = scopedArgumentsTable.m_length;
<span class="udiff-line-modified-removed">-         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(), m_length);</span>
<span class="udiff-line-modified-added">+         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(m_length), m_length);</span>
      }
  
      ScopedArgumentsTable* decode(Decoder&amp; decoder) const
      {
          ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
<span class="udiff-line-modified-removed">-         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(), m_length);</span>
<span class="udiff-line-modified-added">+         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(m_length), m_length);</span>
          return scopedArgumentsTable;
      }
  
  private:
      uint32_t m_length;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1023,33 +1189,35 @@</span>
          return RegExp::create(decoder.vm(), pattern, m_flags);
      }
  
  private:
      CachedString m_patternString;
<span class="udiff-line-modified-removed">-     RegExpFlags m_flags;</span>
<span class="udiff-line-modified-added">+     OptionSet&lt;Yarr::Flags&gt; m_flags;</span>
  };
  
  class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
  public:
<span class="udiff-line-modified-removed">-     void encode(Encoder&amp; encoder, const TemplateObjectDescriptor&amp; templateObjectDescriptor)</span>
<span class="udiff-line-modified-added">+     void encode(Encoder&amp; encoder, const JSTemplateObjectDescriptor&amp; descriptor)</span>
      {
<span class="udiff-line-modified-removed">-         m_rawStrings.encode(encoder, templateObjectDescriptor.rawStrings());</span>
<span class="udiff-line-modified-removed">-         m_cookedStrings.encode(encoder, templateObjectDescriptor.cookedStrings());</span>
<span class="udiff-line-modified-added">+         m_rawStrings.encode(encoder, descriptor.descriptor().rawStrings());</span>
<span class="udiff-line-modified-added">+         m_cookedStrings.encode(encoder, descriptor.descriptor().cookedStrings());</span>
<span class="udiff-line-added">+         m_endOffset = descriptor.endOffset();</span>
      }
  
<span class="udiff-line-modified-removed">-     Ref&lt;TemplateObjectDescriptor&gt; decode(Decoder&amp; decoder) const</span>
<span class="udiff-line-modified-added">+     JSTemplateObjectDescriptor* decode(Decoder&amp; decoder) const</span>
      {
          TemplateObjectDescriptor::StringVector decodedRawStrings;
          TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
          m_rawStrings.decode(decoder, decodedRawStrings);
          m_cookedStrings.decode(decoder, decodedCookedStrings);
<span class="udiff-line-modified-removed">-         return TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings));</span>
<span class="udiff-line-modified-added">+         return JSTemplateObjectDescriptor::create(decoder.vm(), TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings)), m_endOffset);</span>
      }
  
  private:
      CachedVector&lt;CachedString, 4&gt; m_rawStrings;
      CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
<span class="udiff-line-added">+     int m_endOffset;</span>
  };
  
  class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
  public:
      void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1119,11 +1287,11 @@</span>
              return;
          }
  
          if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
              m_type = EncodedType::TemplateObjectDescriptor;
<span class="udiff-line-modified-removed">-             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, templateObjectDescriptor-&gt;descriptor());</span>
<span class="udiff-line-modified-added">+             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, *templateObjectDescriptor);</span>
              return;
          }
  
          if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
              m_type = EncodedType::BigInt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1144,21 +1312,21 @@</span>
          case EncodedType::SymbolTable:
              v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
              break;
          case EncodedType::String: {
              StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
<span class="udiff-line-modified-removed">-             v = jsString(&amp;decoder.vm(), adoptRef(*impl));</span>
<span class="udiff-line-modified-added">+             v = jsString(decoder.vm(), adoptRef(*impl));</span>
              break;
          }
          case EncodedType::ImmutableButterfly:
              v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
              break;
          case EncodedType::RegExp:
              v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
              break;
          case EncodedType::TemplateObjectDescriptor:
<span class="udiff-line-modified-removed">-             v = JSTemplateObjectDescriptor::create(decoder.vm(), this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder));</span>
<span class="udiff-line-modified-added">+             v = this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder);</span>
              break;
          case EncodedType::BigInt:
              v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
              break;
          default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1205,27 +1373,42 @@</span>
      {
          ASSERT(metadataTable.m_isFinalized);
          m_hasMetadata = metadataTable.m_hasMetadata;
          if (!m_hasMetadata)
              return;
<span class="udiff-line-modified-removed">-         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-modified-removed">-             m_metadata[i] = metadataTable.buffer()[i];</span>
<span class="udiff-line-modified-added">+         m_is32Bit = metadataTable.m_is32Bit;</span>
<span class="udiff-line-modified-added">+         if (m_is32Bit) {</span>
<span class="udiff-line-added">+             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-added">+                 m_metadata[i] = metadataTable.offsetTable32()[i];</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-added">+                 m_metadata[i] = metadataTable.offsetTable16()[i];</span>
<span class="udiff-line-added">+         }</span>
      }
  
      Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
      {
<span class="udiff-line-modified-removed">-         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create();</span>
<span class="udiff-line-modified-added">+         if (!m_hasMetadata)</span>
<span class="udiff-line-added">+             return UnlinkedMetadataTable::empty();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create(m_is32Bit);</span>
          metadataTable-&gt;m_isFinalized = true;
          metadataTable-&gt;m_isLinked = false;
          metadataTable-&gt;m_hasMetadata = m_hasMetadata;
<span class="udiff-line-modified-removed">-         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-modified-removed">-             metadataTable-&gt;buffer()[i] = m_metadata[i];</span>
<span class="udiff-line-modified-added">+         if (m_is32Bit) {</span>
<span class="udiff-line-modified-added">+             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-added">+                 metadataTable-&gt;offsetTable32()[i] = m_metadata[i];</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="udiff-line-added">+                 metadataTable-&gt;offsetTable16()[i] = m_metadata[i];</span>
<span class="udiff-line-added">+         }</span>
          return metadataTable;
      }
  
  private:
      bool m_hasMetadata;
<span class="udiff-line-added">+     bool m_is32Bit;</span>
      std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
  };
  
  class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
  public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1385,11 +1568,11 @@</span>
  template&lt;typename Source&gt;
  class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
  public:
      void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
      {
<span class="udiff-line-modified-removed">-         m_provider.encode(encoder, sourceCode.m_provider.get());</span>
<span class="udiff-line-modified-added">+         m_provider.encode(encoder, sourceCode.m_provider);</span>
          m_startOffset = sourceCode.startOffset();
          m_endOffset = sourceCode.endOffset();
      }
  
      void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1398,11 +1581,11 @@</span>
          sourceCode.m_startOffset = m_startOffset;
          sourceCode.m_endOffset = m_endOffset;
      }
  
  private:
<span class="udiff-line-modified-removed">-     CachedPtr&lt;CachedSourceProvider&gt; m_provider;</span>
<span class="udiff-line-modified-added">+     CachedRefPtr&lt;CachedSourceProvider&gt; m_provider;</span>
      int m_startOffset;
      int m_endOffset;
  };
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1429,29 +1612,64 @@</span>
  private:
      int m_firstLine;
      int m_startColumn;
  };
  
<span class="udiff-line-added">+ class CachedSourceCodeWithoutProvider : public CachedObject&lt;SourceCode&gt; {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+     void encode(Encoder&amp;, const SourceCode&amp; sourceCode)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         m_hasProvider = !!sourceCode.provider();</span>
<span class="udiff-line-added">+         m_startOffset = sourceCode.startOffset();</span>
<span class="udiff-line-added">+         m_endOffset = sourceCode.endOffset();</span>
<span class="udiff-line-added">+         m_firstLine = sourceCode.firstLine().zeroBasedInt();</span>
<span class="udiff-line-added">+         m_startColumn = sourceCode.startColumn().zeroBasedInt();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_hasProvider)</span>
<span class="udiff-line-added">+             sourceCode.m_provider = decoder.provider();</span>
<span class="udiff-line-added">+         sourceCode.m_startOffset = m_startOffset;</span>
<span class="udiff-line-added">+         sourceCode.m_endOffset = m_endOffset;</span>
<span class="udiff-line-added">+         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);</span>
<span class="udiff-line-added">+         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     bool m_hasProvider;</span>
<span class="udiff-line-added">+     int m_startOffset;</span>
<span class="udiff-line-added">+     int m_endOffset;</span>
<span class="udiff-line-added">+     int m_firstLine;</span>
<span class="udiff-line-added">+     int m_startColumn;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
  public:
      void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
      {
          m_classSource.encode(encoder, rareData.m_classSource);
<span class="udiff-line-added">+         m_parentScopeTDZVariables.encode(encoder, rareData.m_parentScopeTDZVariables);</span>
      }
  
      UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
      {
          UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
          m_classSource.decode(decoder, rareData-&gt;m_classSource);
<span class="udiff-line-added">+         auto parentScopeTDZVariables = m_parentScopeTDZVariables.decode(decoder);</span>
<span class="udiff-line-added">+         rareData-&gt;m_parentScopeTDZVariables = WTFMove(parentScopeTDZVariables);</span>
          return rareData;
      }
  
  private:
<span class="udiff-line-modified-removed">-     CachedSourceCode m_classSource;</span>
<span class="udiff-line-modified-added">+     CachedSourceCodeWithoutProvider m_classSource;</span>
<span class="udiff-line-added">+     CachedCompactVariableMapHandle m_parentScopeTDZVariables;</span>
  };
  
  class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
<span class="udiff-line-added">+     friend struct CachedFunctionExecutableOffsets;</span>
<span class="udiff-line-added">+ </span>
  public:
      void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
      UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
  
      unsigned firstLineOffset() const { return m_firstLineOffset; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1464,15 +1682,15 @@</span>
      unsigned parametersStartOffset() const { return m_parametersStartOffset; }
      unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
      unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
      unsigned parameterCount() const { return m_parameterCount; }
  
<span class="udiff-line-modified-removed">-     CodeFeatures features() const { return m_features; }</span>
<span class="udiff-line-modified-added">+     CodeFeatures features() const { return m_mutableMetadata.m_features; }</span>
      SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
  
      unsigned isInStrictContext() const { return m_isInStrictContext; }
<span class="udiff-line-modified-removed">-     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }</span>
<span class="udiff-line-modified-added">+     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }</span>
      unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
      unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
      unsigned constructAbility() const { return m_constructAbility; }
      unsigned constructorKind() const { return m_constructorKind; }
      unsigned functionMode() const { return m_functionMode; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1480,51 +1698,65 @@</span>
      unsigned superBinding() const { return m_superBinding; }
      unsigned derivedContextType() const { return m_derivedContextType; }
  
      Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
      Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
<span class="udiff-line-removed">-     Identifier inferredName(Decoder&amp; decoder) const { return m_inferredName.decode(decoder); }</span>
  
<span class="udiff-line-modified-removed">-     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>
<span class="udiff-line-modified-added">+     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }</span>
<span class="udiff-line-added">+     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }</span>
  
  private:
<span class="udiff-line-modified-removed">-     unsigned m_firstLineOffset;</span>
<span class="udiff-line-modified-removed">-     unsigned m_lineCount;</span>
<span class="udiff-line-modified-removed">-     unsigned m_unlinkedFunctionNameStart;</span>
<span class="udiff-line-removed">-     unsigned m_unlinkedBodyStartColumn;</span>
<span class="udiff-line-removed">-     unsigned m_unlinkedBodyEndColumn;</span>
<span class="udiff-line-removed">-     unsigned m_startOffset;</span>
<span class="udiff-line-removed">-     unsigned m_sourceLength;</span>
<span class="udiff-line-removed">-     unsigned m_parametersStartOffset;</span>
<span class="udiff-line-removed">-     unsigned m_typeProfilingStartOffset;</span>
<span class="udiff-line-removed">-     unsigned m_typeProfilingEndOffset;</span>
<span class="udiff-line-removed">-     unsigned m_parameterCount;</span>
<span class="udiff-line-removed">-     CodeFeatures m_features;</span>
<span class="udiff-line-removed">-     SourceParseMode m_sourceParseMode;</span>
<span class="udiff-line-modified-added">+     CachedFunctionExecutableMetadata m_mutableMetadata;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     unsigned m_firstLineOffset : 31;</span>
      unsigned m_isInStrictContext : 1;
<span class="udiff-line-modified-removed">-     unsigned m_hasCapturedVariables : 1;</span>
<span class="udiff-line-modified-added">+     unsigned m_lineCount : 31;</span>
      unsigned m_isBuiltinFunction : 1;
<span class="udiff-line-added">+     unsigned m_unlinkedFunctionNameStart : 31;</span>
      unsigned m_isBuiltinDefaultClassConstructor : 1;
<span class="udiff-line-added">+     unsigned m_unlinkedBodyStartColumn : 31;</span>
      unsigned m_constructAbility: 1;
<span class="udiff-line-modified-removed">-     unsigned m_constructorKind : 2;</span>
<span class="udiff-line-modified-removed">-     unsigned m_functionMode : 2; // FunctionMode</span>
<span class="udiff-line-modified-added">+     unsigned m_unlinkedBodyEndColumn : 31;</span>
<span class="udiff-line-modified-added">+     unsigned m_startOffset : 31;</span>
      unsigned m_scriptMode: 1; // JSParserScriptMode
<span class="udiff-line-added">+     unsigned m_sourceLength : 31;</span>
      unsigned m_superBinding : 1;
<span class="udiff-line-added">+     unsigned m_parametersStartOffset : 31;</span>
<span class="udiff-line-added">+     unsigned m_typeProfilingStartOffset;</span>
<span class="udiff-line-added">+     unsigned m_typeProfilingEndOffset;</span>
<span class="udiff-line-added">+     unsigned m_parameterCount;</span>
<span class="udiff-line-added">+     SourceParseMode m_sourceParseMode;</span>
<span class="udiff-line-added">+     unsigned m_constructorKind : 2;</span>
<span class="udiff-line-added">+     unsigned m_functionMode : 2; // FunctionMode</span>
      unsigned m_derivedContextType: 2;
  
<span class="udiff-line-modified-removed">-     CachedOptional&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
<span class="udiff-line-modified-added">+     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
  
      CachedIdentifier m_name;
      CachedIdentifier m_ecmaName;
<span class="udiff-line-removed">-     CachedIdentifier m_inferredName;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     CachedVariableEnvironment m_parentScopeTDZVariables;</span>
  
      CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
      CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
  };
  
<span class="udiff-line-added">+ ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename CodeBlockType&gt;
  class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
  public:
      void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
      void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1546,11 +1778,10 @@</span>
      unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
      unsigned superBinding() const { return m_superBinding; }
      unsigned scriptMode() const { return m_scriptMode; }
      unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
      unsigned isClassContext() const { return m_isClassContext; }
<span class="udiff-line-removed">-     unsigned wasCompiledWithDebuggingOpcodes() const { return m_wasCompiledWithDebuggingOpcodes; }</span>
      unsigned constructorKind() const { return m_constructorKind; }
      unsigned derivedContextType() const { return m_derivedContextType; }
      unsigned evalContextType() const { return m_evalContextType; }
      unsigned hasTailCalls() const { return m_hasTailCalls; }
      unsigned lineCount() const { return m_lineCount; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1560,13 +1791,14 @@</span>
      int numCalleeLocals() const { return m_numCalleeLocals; }
      int numParameters() const { return m_numParameters; }
  
      CodeFeatures features() const { return m_features; }
      SourceParseMode parseMode() const { return m_parseMode; }
<span class="udiff-line-added">+     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }</span>
      unsigned codeType() const { return m_codeType; }
  
<span class="udiff-line-modified-removed">-     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>
<span class="udiff-line-modified-added">+     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }</span>
  
  private:
      VirtualRegister m_thisRegister;
      VirtualRegister m_scopeRegister;
      std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1578,30 +1810,30 @@</span>
      unsigned m_isBuiltinFunction : 1;
      unsigned m_superBinding : 1;
      unsigned m_scriptMode: 1;
      unsigned m_isArrowFunctionContext : 1;
      unsigned m_isClassContext : 1;
<span class="udiff-line-removed">-     unsigned m_wasCompiledWithDebuggingOpcodes : 1;</span>
      unsigned m_constructorKind : 2;
      unsigned m_derivedContextType : 2;
      unsigned m_evalContextType : 2;
      unsigned m_hasTailCalls : 1;
      unsigned m_codeType : 2;
  
      CodeFeatures m_features;
      SourceParseMode m_parseMode;
<span class="udiff-line-added">+     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;</span>
  
      unsigned m_lineCount;
      unsigned m_endColumn;
  
      int m_numVars;
      int m_numCalleeLocals;
      int m_numParameters;
  
      CachedMetadataTable m_metadata;
  
<span class="udiff-line-modified-removed">-     CachedOptional&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
<span class="udiff-line-modified-added">+     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
  
      CachedString m_sourceURLDirective;
      CachedString m_sourceMappingURLDirective;
  
      CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1722,10 +1954,26 @@</span>
      CachedProgramCodeBlockTag,
      CachedModuleCodeBlockTag,
      CachedEvalCodeBlockTag,
  };
  
<span class="udiff-line-added">+ static CachedCodeBlockTag tagFromSourceCodeType(SourceCodeType type)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     switch (type) {</span>
<span class="udiff-line-added">+     case SourceCodeType::ProgramType:</span>
<span class="udiff-line-added">+         return CachedProgramCodeBlockTag;</span>
<span class="udiff-line-added">+     case SourceCodeType::EvalType:</span>
<span class="udiff-line-added">+         return CachedEvalCodeBlockTag;</span>
<span class="udiff-line-added">+     case SourceCodeType::ModuleType:</span>
<span class="udiff-line-added">+         return CachedModuleCodeBlockTag;</span>
<span class="udiff-line-added">+     case SourceCodeType::FunctionType:</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     return static_cast&lt;CachedCodeBlockTag&gt;(-1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;&gt;
  struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
      using type = CachedProgramCodeBlock;
      static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1758,19 +2006,22 @@</span>
      , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
      , m_superBinding(cachedCodeBlock.superBinding())
      , m_scriptMode(cachedCodeBlock.scriptMode())
      , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
      , m_isClassContext(cachedCodeBlock.isClassContext())
<span class="udiff-line-modified-removed">-     , m_wasCompiledWithDebuggingOpcodes(cachedCodeBlock.wasCompiledWithDebuggingOpcodes())</span>
<span class="udiff-line-modified-added">+     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
      , m_constructorKind(cachedCodeBlock.constructorKind())
      , m_derivedContextType(cachedCodeBlock.derivedContextType())
      , m_evalContextType(cachedCodeBlock.evalContextType())
<span class="udiff-line-removed">-     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
      , m_codeType(cachedCodeBlock.codeType())
  
<span class="udiff-line-added">+     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))</span>
<span class="udiff-line-added">+     , m_age(0)</span>
<span class="udiff-line-added">+ </span>
      , m_features(cachedCodeBlock.features())
      , m_parseMode(cachedCodeBlock.parseMode())
<span class="udiff-line-added">+     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())</span>
  
      , m_lineCount(cachedCodeBlock.lineCount())
      , m_endColumn(cachedCodeBlock.endColumn())
      , m_numVars(cachedCodeBlock.numVars())
      , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1818,10 +2069,13 @@</span>
  {
  }
  
  ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
  {
<span class="udiff-line-added">+     m_mutableMetadata.m_features = executable.m_features;</span>
<span class="udiff-line-added">+     m_mutableMetadata.m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
<span class="udiff-line-added">+ </span>
      m_firstLineOffset = executable.m_firstLineOffset;
      m_lineCount = executable.m_lineCount;
      m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
      m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
      m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1830,84 +2084,103 @@</span>
      m_parametersStartOffset = executable.m_parametersStartOffset;
      m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
      m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
      m_parameterCount = executable.m_parameterCount;
  
<span class="udiff-line-removed">-     m_features = executable.m_features;</span>
      m_sourceParseMode = executable.m_sourceParseMode;
  
      m_isInStrictContext = executable.m_isInStrictContext;
<span class="udiff-line-removed">-     m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
      m_isBuiltinFunction = executable.m_isBuiltinFunction;
      m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
      m_constructAbility = executable.m_constructAbility;
      m_constructorKind = executable.m_constructorKind;
      m_functionMode = executable.m_functionMode;
      m_scriptMode = executable.m_scriptMode;
      m_superBinding = executable.m_superBinding;
      m_derivedContextType = executable.m_derivedContextType;
  
<span class="udiff-line-modified-removed">-     m_rareData.encode(encoder, executable.m_rareData);</span>
<span class="udiff-line-modified-added">+     m_rareData.encode(encoder, executable.m_rareData.get());</span>
  
      m_name.encode(encoder, executable.name());
      m_ecmaName.encode(encoder, executable.ecmaName());
<span class="udiff-line-removed">-     m_inferredName.encode(encoder, executable.inferredName());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_parentScopeTDZVariables.encode(encoder, executable.parentScopeTDZVariables());</span>
  
      m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
      m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)</span>
<span class="udiff-line-added">+         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));</span>
  }
  
  ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
  {
<span class="udiff-line-modified-removed">-     VariableEnvironment env;</span>
<span class="udiff-line-removed">-     m_parentScopeTDZVariables.decode(decoder, env);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, env, *this);</span>
<span class="udiff-line-modified-added">+     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);</span>
      executable-&gt;finishCreation(decoder.vm());
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_unlinkedCodeBlockForCall.decode(decoder, executable-&gt;m_unlinkedCodeBlockForCall, executable);</span>
<span class="udiff-line-removed">-     m_unlinkedCodeBlockForConstruct.decode(decoder, executable-&gt;m_unlinkedCodeBlockForConstruct, executable);</span>
<span class="udiff-line-removed">- </span>
      return executable;
  }
  
<span class="udiff-line-modified-removed">- ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, VariableEnvironment&amp; parentScopeTDZVariables, const CachedFunctionExecutable&amp; cachedExecutable)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, const CachedFunctionExecutable&amp; cachedExecutable)</span>
      : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
      , m_firstLineOffset(cachedExecutable.firstLineOffset())
<span class="udiff-line-added">+     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
      , m_lineCount(cachedExecutable.lineCount())
<span class="udiff-line-added">+     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
      , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
<span class="udiff-line-added">+     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
      , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
<span class="udiff-line-added">+     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
      , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
<span class="udiff-line-added">+     , m_constructAbility(cachedExecutable.constructAbility())</span>
      , m_startOffset(cachedExecutable.startOffset())
<span class="udiff-line-added">+     , m_scriptMode(cachedExecutable.scriptMode())</span>
      , m_sourceLength(cachedExecutable.sourceLength())
<span class="udiff-line-added">+     , m_superBinding(cachedExecutable.superBinding())</span>
      , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
<span class="udiff-line-added">+     , m_isCached(false)</span>
      , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
      , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
      , m_parameterCount(cachedExecutable.parameterCount())
      , m_features(cachedExecutable.features())
      , m_sourceParseMode(cachedExecutable.sourceParseMode())
<span class="udiff-line-removed">-     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
<span class="udiff-line-removed">-     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
<span class="udiff-line-removed">-     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
<span class="udiff-line-removed">-     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
<span class="udiff-line-removed">-     , m_constructAbility(cachedExecutable.constructAbility())</span>
      , m_constructorKind(cachedExecutable.constructorKind())
      , m_functionMode(cachedExecutable.functionMode())
<span class="udiff-line-removed">-     , m_scriptMode(cachedExecutable.scriptMode())</span>
<span class="udiff-line-removed">-     , m_superBinding(cachedExecutable.superBinding())</span>
      , m_derivedContextType(cachedExecutable.derivedContextType())
<span class="udiff-line-added">+     , m_isGeneratedFromCache(true)</span>
<span class="udiff-line-added">+     , m_unlinkedCodeBlockForCall()</span>
<span class="udiff-line-added">+     , m_unlinkedCodeBlockForConstruct()</span>
  
      , m_name(cachedExecutable.name(decoder))
      , m_ecmaName(cachedExecutable.ecmaName(decoder))
<span class="udiff-line-removed">-     , m_inferredName(cachedExecutable.inferredName(decoder))</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     , m_parentScopeTDZVariables(decoder.vm().m_compactVariableMap-&gt;get(parentScopeTDZVariables))</span>
  
      , m_rareData(cachedExecutable.rareData(decoder))
  {
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint32_t leafExecutables = 2;</span>
<span class="udiff-line-added">+     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {</span>
<span class="udiff-line-added">+         if (!cachedPtr.isEmpty()) {</span>
<span class="udiff-line-added">+             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);</span>
<span class="udiff-line-added">+             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {</span>
<span class="udiff-line-added">+                 codeBlockOffset = offset;</span>
<span class="udiff-line-added">+                 m_isCached = true;</span>
<span class="udiff-line-added">+                 leafExecutables--;</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         codeBlockOffset = 0;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!cachedExecutable.unlinkedCodeBlockForCall().isEmpty() || !cachedExecutable.unlinkedCodeBlockForConstruct().isEmpty()) {</span>
<span class="udiff-line-added">+         checkBounds(m_cachedCodeBlockForCallOffset, cachedExecutable.unlinkedCodeBlockForCall());</span>
<span class="udiff-line-added">+         checkBounds(m_cachedCodeBlockForConstructOffset, cachedExecutable.unlinkedCodeBlockForConstruct());</span>
<span class="udiff-line-added">+         if (m_isCached)</span>
<span class="udiff-line-added">+             m_decoder = &amp;decoder;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             m_decoder = nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (leafExecutables)</span>
<span class="udiff-line-added">+         decoder.addLeafExecutable(this, decoder.offsetOf(&amp;cachedExecutable));</span>
  }
  
  template&lt;typename CodeBlockType&gt;
  ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1920,29 +2193,29 @@</span>
      m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
      m_superBinding = codeBlock.m_superBinding;
      m_scriptMode = codeBlock.m_scriptMode;
      m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
      m_isClassContext = codeBlock.m_isClassContext;
<span class="udiff-line-modified-removed">-     m_wasCompiledWithDebuggingOpcodes = codeBlock.m_wasCompiledWithDebuggingOpcodes;</span>
<span class="udiff-line-modified-added">+     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
      m_constructorKind = codeBlock.m_constructorKind;
      m_derivedContextType = codeBlock.m_derivedContextType;
      m_evalContextType = codeBlock.m_evalContextType;
<span class="udiff-line-removed">-     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
      m_lineCount = codeBlock.m_lineCount;
      m_endColumn = codeBlock.m_endColumn;
      m_numVars = codeBlock.m_numVars;
      m_numCalleeLocals = codeBlock.m_numCalleeLocals;
      m_numParameters = codeBlock.m_numParameters;
      m_features = codeBlock.m_features;
      m_parseMode = codeBlock.m_parseMode;
<span class="udiff-line-added">+     m_codeGenerationMode = codeBlock.m_codeGenerationMode;</span>
      m_codeType = codeBlock.m_codeType;
  
      for (unsigned i = LinkTimeConstantCount; i--;)
          m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
  
      m_metadata.encode(encoder, codeBlock.m_metadata.get());
<span class="udiff-line-modified-removed">-     m_rareData.encode(encoder, codeBlock.m_rareData);</span>
<span class="udiff-line-modified-added">+     m_rareData.encode(encoder, codeBlock.m_rareData.get());</span>
  
      m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
      m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
  
      m_instructions.encode(encoder, codeBlock.m_instructions.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1987,20 +2260,30 @@</span>
  };
  
  class GenericCacheEntry {
  public:
      bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
<span class="udiff-line-added">+     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;</span>
  
  protected:
      GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
          : m_tag(tag)
      {
          m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
      }
  
      CachedCodeBlockTag tag() const { return m_tag; }
  
<span class="udiff-line-added">+     bool isUpToDate(Decoder&amp; decoder) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  private:
      uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
      CachedString m_bootSessionUUID;
      CachedCodeBlockTag m_tag;
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2020,10 +2303,17 @@</span>
      }
  
  private:
      friend GenericCacheEntry;
  
<span class="udiff-line-added">+     bool isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         SourceCodeKey decodedKey;</span>
<span class="udiff-line-added">+         m_key.decode(decoder, decodedKey);</span>
<span class="udiff-line-added">+         return decodedKey == key;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
      {
          ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
          SourceCodeKey decodedKey;
          m_key.decode(decoder, decodedKey);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2035,20 +2325,18 @@</span>
      CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
  };
  
  bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
  {
<span class="udiff-line-modified-removed">-     if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">-     if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
<span class="udiff-line-modified-added">+     if (!isUpToDate(decoder))</span>
          return false;
  
      switch (m_tag) {
      case CachedProgramCodeBlockTag:
<span class="udiff-line-modified-removed">-         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
<span class="udiff-line-modified-added">+         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
      case CachedModuleCodeBlockTag:
<span class="udiff-line-modified-removed">-         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
<span class="udiff-line-modified-added">+         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
      case CachedEvalCodeBlockTag:
          // We do not cache eval code blocks
          RELEASE_ASSERT_NOT_REACHED();
      }
      RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2056,44 +2344,93 @@</span>
      // Without this, MSVC will complain that this path does not return a value.
      return false;
  #endif
  }
  
<span class="udiff-line-added">+ bool GenericCacheEntry::isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key, CachedCodeBlockTag tag) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!isUpToDate(decoder))</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     switch (tag) {</span>
<span class="udiff-line-added">+     case CachedProgramCodeBlockTag:</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="udiff-line-added">+     case CachedModuleCodeBlockTag:</span>
<span class="udiff-line-added">+         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);</span>
<span class="udiff-line-added">+     case CachedEvalCodeBlockTag:</span>
<span class="udiff-line-added">+         // We do not cache eval code blocks</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  template&lt;typename UnlinkedCodeBlockType&gt;
  void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
  {
      auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
<span class="udiff-line-modified-removed">-     entry-&gt;encode(encoder,  { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
<span class="udiff-line-modified-added">+     entry-&gt;encode(encoder, { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
  }
  
<span class="udiff-line-modified-removed">- std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)</span>
  {
      const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
  
<span class="udiff-line-modified-removed">-     Encoder encoder(vm);</span>
<span class="udiff-line-modified-added">+     Encoder encoder(vm, fd);</span>
      if (classInfo == UnlinkedProgramCodeBlock::info())
          encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
      else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
          encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
      else
          ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
  
<span class="udiff-line-modified-removed">-     return encoder.release();</span>
<span class="udiff-line-modified-added">+     return encoder.release(error);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     BytecodeCacheError error;</span>
<span class="udiff-line-added">+     return encodeCodeBlock(vm, key, codeBlock, FileSystem::invalidPlatformFileHandle, error);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ RefPtr&lt;CachedBytecode&gt; encodeFunctionCodeBlock(VM&amp; vm, const UnlinkedFunctionCodeBlock* codeBlock, BytecodeCacheError&amp; error)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     Encoder encoder(vm);</span>
<span class="udiff-line-added">+     encoder.malloc&lt;CachedFunctionCodeBlock&gt;()-&gt;encode(encoder, *codeBlock);</span>
<span class="udiff-line-added">+     return encoder.release(error);</span>
  }
  
<span class="udiff-line-modified-removed">- UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, const void* buffer, size_t size)</span>
<span class="udiff-line-modified-added">+ UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, Ref&lt;CachedBytecode&gt; cachedBytecode)</span>
  {
<span class="udiff-line-modified-removed">-     const auto* cachedEntry = reinterpret_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="udiff-line-modified-removed">-     Decoder decoder(vm, buffer, size);</span>
<span class="udiff-line-modified-added">+     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(cachedBytecode-&gt;data());</span>
<span class="udiff-line-modified-added">+     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode), &amp;key.source().provider());</span>
      std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
      {
          DeferGC deferGC(vm.heap);
<span class="udiff-line-modified-removed">-         if (!cachedEntry-&gt;decode(decoder, entry))</span>
<span class="udiff-line-modified-added">+         if (!cachedEntry-&gt;decode(decoder.get(), entry))</span>
              return nullptr;
      }
  
      if (entry.first != key)
          return nullptr;
      return entry.second;
  }
  
<span class="udiff-line-added">+ bool isCachedBytecodeStillValid(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, const SourceCodeKey&amp; key, SourceCodeType type)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     const void* buffer = cachedBytecode-&gt;data();</span>
<span class="udiff-line-added">+     size_t size = cachedBytecode-&gt;size();</span>
<span class="udiff-line-added">+     if (!size)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="udiff-line-added">+     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode));</span>
<span class="udiff-line-added">+     return cachedEntry-&gt;isStillValid(decoder.get(), key, tagFromSourceCodeType(type));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void decodeFunctionCodeBlock(Decoder&amp; decoder, int32_t cachedFunctionCodeBlockOffset, WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt;&amp; codeBlock, const JSCell* owner)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(decoder.vm().heap.isDeferred());</span>
<span class="udiff-line-added">+     auto* cachedCodeBlock = static_cast&lt;const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;*&gt;(decoder.ptrForOffsetFromBase(cachedFunctionCodeBlockOffset));</span>
<span class="udiff-line-added">+     cachedCodeBlock-&gt;decode(decoder, codeBlock, owner);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="ButterflyInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachedTypes.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>