<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeMediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5  * Copyright (C) 2015 Ericsson AB. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  *
  11  * 1. Redistributions of source code must retain the above copyright
  12  *    notice, this list of conditions and the following disclaimer.
  13  * 2. Redistributions in binary form must reproduce the above copyright
  14  *    notice, this list of conditions and the following disclaimer
  15  *    in the documentation and/or other materials provided with the
  16  *    distribution.
  17  * 3. Neither the name of Google Inc. nor the names of its contributors
  18  *    may be used to endorse or promote products derived from this
  19  *    software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 
  34 #include &quot;config.h&quot;
  35 
  36 #if ENABLE(MEDIA_STREAM)
  37 #include &quot;RealtimeMediaSource.h&quot;
  38 
  39 #include &quot;Logging.h&quot;
  40 #include &quot;MediaConstraints.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;RealtimeMediaSourceCapabilities.h&quot;
  43 #include &quot;RealtimeMediaSourceCenter.h&quot;
  44 #include &lt;wtf/CompletionHandler.h&gt;
  45 #include &lt;wtf/MainThread.h&gt;
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/StringHash.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 RealtimeMediaSource::RealtimeMediaSource(Type type, String&amp;&amp; name, String&amp;&amp; deviceID, String&amp;&amp; hashSalt)
  52     : m_idHashSalt(WTFMove(hashSalt))
  53     , m_persistentID(WTFMove(deviceID))
  54     , m_type(type)
  55     , m_name(WTFMove(name))
  56 {
  57     if (m_persistentID.isEmpty())
  58         m_persistentID = createCanonicalUUIDString();
  59 
  60     m_hashedID = RealtimeMediaSourceCenter::singleton().hashStringWithSalt(m_persistentID, m_idHashSalt);
  61 }
  62 
  63 void RealtimeMediaSource::addObserver(RealtimeMediaSource::Observer&amp; observer)
  64 {
  65     auto locker = holdLock(m_observersLock);
  66     m_observers.add(&amp;observer);
  67 }
  68 
  69 void RealtimeMediaSource::removeObserver(RealtimeMediaSource::Observer&amp; observer)
  70 {
  71     auto locker = holdLock(m_observersLock);
  72     m_observers.remove(&amp;observer);
  73     if (m_observers.isEmpty())
  74         stopBeingObserved();
  75 }
  76 
  77 void RealtimeMediaSource::setInterrupted(bool interrupted, bool pageMuted)
  78 {
  79     if (interrupted == m_interrupted)
  80         return;
  81 
  82     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, interrupted, &quot;, page muted : &quot;, pageMuted);
  83 
  84     m_interrupted = interrupted;
  85     if (!interrupted &amp;&amp; pageMuted)
  86         return;
  87 
  88     setMuted(interrupted);
  89 }
  90 
  91 void RealtimeMediaSource::setMuted(bool muted)
  92 {
  93     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);
  94 
  95     if (muted)
  96         stop();
  97     else {
  98         if (interrupted())
  99             return;
 100 
 101         start();
 102     }
 103 
 104     notifyMutedChange(muted);
 105 }
 106 
 107 void RealtimeMediaSource::notifyMutedChange(bool muted)
 108 {
 109     if (m_muted == muted)
 110         return;
 111 
 112     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);
 113     m_muted = muted;
 114 
 115     notifyMutedObservers();
 116 }
 117 
 118 void RealtimeMediaSource::setInterruptedForTesting(bool interrupted)
 119 {
 120     notifyMutedChange(interrupted);
 121 }
 122 
 123 void RealtimeMediaSource::forEachObserver(const WTF::Function&lt;void(Observer&amp;)&gt;&amp; apply) const
 124 {
 125     Vector&lt;Observer*&gt; observersCopy;
 126     {
 127         auto locker = holdLock(m_observersLock);
 128         observersCopy = copyToVector(m_observers);
 129     }
 130     for (auto* observer : observersCopy) {
 131         auto locker = holdLock(m_observersLock);
 132         // Make sure the observer has not been destroyed.
 133         if (!m_observers.contains(observer))
 134             continue;
 135         apply(*observer);
 136     }
 137 }
 138 
 139 void RealtimeMediaSource::notifyMutedObservers() const
 140 {
 141     forEachObserver([](auto&amp; observer) {
 142         observer.sourceMutedChanged();
 143     });
 144 }
 145 
 146 void RealtimeMediaSource::notifySettingsDidChangeObservers(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; flags)
 147 {
 148     ASSERT(isMainThread());
 149 
 150     settingsDidChange(flags);
 151 
 152     if (m_pendingSettingsDidChangeNotification)
 153         return;
 154     m_pendingSettingsDidChangeNotification = true;
 155 
 156     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, flags);
 157 
 158     scheduleDeferredTask([this] {
 159         m_pendingSettingsDidChangeNotification = false;
 160         forEachObserver([](auto&amp; observer) {
 161             observer.sourceSettingsChanged();
 162         });
 163     });
 164 }
 165 
 166 void RealtimeMediaSource::videoSampleAvailable(MediaSample&amp; mediaSample)
 167 {
 168 #if !RELEASE_LOG_DISABLED
 169     ++m_frameCount;
 170 
 171     auto timestamp = MonotonicTime::now();
 172     auto delta = timestamp - m_lastFrameLogTime;
 173     if (!m_lastFrameLogTime || delta &gt;= 1_s) {
 174         if (m_lastFrameLogTime) {
 175             INFO_LOG_IF(loggerPtr(), LOGIDENTIFIER, m_frameCount, &quot; frames sent in &quot;, delta.value(), &quot; seconds&quot;);
 176             m_frameCount = 0;
 177         }
 178         m_lastFrameLogTime = timestamp;
 179     }
 180 #endif
 181 
 182     forEachObserver([&amp;](auto&amp; observer) {
 183         observer.videoSampleAvailable(mediaSample);
 184     });
 185 }
 186 
 187 void RealtimeMediaSource::audioSamplesAvailable(const MediaTime&amp; time, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t numberOfFrames)
 188 {
 189     forEachObserver([&amp;](auto&amp; observer) {
 190         observer.audioSamplesAvailable(time, audioData, description, numberOfFrames);
 191     });
 192 }
 193 
 194 void RealtimeMediaSource::start()
 195 {
 196     if (m_isProducingData || m_isEnded)
 197         return;
 198 
 199     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 200 
 201     m_isProducingData = true;
 202     startProducingData();
 203 
 204     if (!m_isProducingData)
 205         return;
 206 
 207     forEachObserver([](auto&amp; observer) {
 208         observer.sourceStarted();
 209     });
 210 }
 211 
 212 void RealtimeMediaSource::stop()
 213 {
 214     if (!m_isProducingData)
 215         return;
 216 
 217     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 218 
 219     m_isProducingData = false;
 220     stopProducingData();
 221 }
 222 
 223 void RealtimeMediaSource::requestToEnd(Observer&amp; callingObserver)
 224 {
 225     if (!m_isProducingData)
 226         return;
 227 
 228     bool hasObserverPreventingStopping = false;
 229     forEachObserver([&amp;](auto&amp; observer) {
 230         if (observer.preventSourceFromStopping())
 231             hasObserverPreventingStopping = true;
 232     });
 233     if (hasObserverPreventingStopping)
 234         return;
 235 
 236     auto protectedThis = makeRef(*this);
 237 
 238     stop();
 239     m_isEnded = true;
 240     hasEnded();
 241 
 242     forEachObserver([callingObserver](auto&amp; observer) {
 243         if (&amp;observer != &amp;callingObserver)
 244             observer.sourceStopped();
 245     });
 246 }
 247 
 248 void RealtimeMediaSource::captureFailed()
 249 {
 250     ERROR_LOG_IF(m_logger, LOGIDENTIFIER);
 251 
 252     m_isProducingData = false;
 253     m_captureDidFailed = true;
 254 
 255     forEachObserver([](auto&amp; observer) {
 256         observer.sourceStopped();
 257     });
 258 }
 259 
 260 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;int&gt;, Optional&lt;int&gt;, Optional&lt;double&gt;)
 261 {
 262     // The size and frame rate are within the capability limits, so they are supported.
 263     return true;
 264 }
 265 
 266 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;IntConstraint&gt; widthConstraint, Optional&lt;IntConstraint&gt; heightConstraint, Optional&lt;DoubleConstraint&gt; frameRateConstraint, String&amp; badConstraint, double&amp; distance)
 267 {
 268     if (!widthConstraint &amp;&amp; !heightConstraint &amp;&amp; !frameRateConstraint)
 269         return true;
 270 
 271     auto&amp; capabilities = this-&gt;capabilities();
 272 
 273     distance = std::numeric_limits&lt;double&gt;::infinity();
 274 
 275     Optional&lt;int&gt; width;
 276     if (widthConstraint &amp;&amp; capabilities.supportsWidth()) {
 277         double constraintDistance = fitnessDistance(*widthConstraint);
 278         if (std::isinf(constraintDistance)) {
 279             badConstraint = widthConstraint-&gt;name();
 280             return false;
 281         }
 282 
 283         distance = std::min(distance, constraintDistance);
 284         if (widthConstraint-&gt;isMandatory()) {
 285             auto range = capabilities.width();
 286             width = widthConstraint-&gt;valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 287         }
 288     }
 289 
 290     Optional&lt;int&gt; height;
 291     if (heightConstraint &amp;&amp; capabilities.supportsHeight()) {
 292         double constraintDistance = fitnessDistance(*heightConstraint);
 293         if (std::isinf(constraintDistance)) {
 294             badConstraint = heightConstraint-&gt;name();
 295             return false;
 296         }
 297 
 298         distance = std::min(distance, constraintDistance);
 299         if (heightConstraint-&gt;isMandatory()) {
 300             auto range = capabilities.height();
 301             height = heightConstraint-&gt;valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 302         }
 303     }
 304 
 305     Optional&lt;double&gt; frameRate;
 306     if (frameRateConstraint &amp;&amp; capabilities.supportsFrameRate()) {
 307         double constraintDistance = fitnessDistance(*frameRateConstraint);
 308         if (std::isinf(constraintDistance)) {
 309             badConstraint = frameRateConstraint-&gt;name();
 310             return false;
 311         }
 312 
 313         distance = std::min(distance, constraintDistance);
 314         if (frameRateConstraint-&gt;isMandatory()) {
 315             auto range = capabilities.frameRate();
 316             frameRate = frameRateConstraint-&gt;valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 317         }
 318     }
 319 
 320     // Each of the non-null values is supported individually, see if they all can be applied at the same time.
 321     if (!supportsSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate))) {
 322         if (widthConstraint)
 323             badConstraint = widthConstraint-&gt;name();
 324         else if (heightConstraint)
 325             badConstraint = heightConstraint-&gt;name();
 326         else
 327             badConstraint = frameRateConstraint-&gt;name();
 328         return false;
 329     }
 330 
 331     return true;
 332 }
 333 
 334 double RealtimeMediaSource::fitnessDistance(const MediaConstraint&amp; constraint)
 335 {
 336     auto&amp; capabilities = this-&gt;capabilities();
 337 
 338     switch (constraint.constraintType()) {
 339     case MediaConstraintType::Width: {
 340         ASSERT(constraint.isInt());
 341         if (!capabilities.supportsWidth())
 342             return 0;
 343 
 344         auto range = capabilities.width();
 345         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 346         break;
 347     }
 348 
 349     case MediaConstraintType::Height: {
 350         ASSERT(constraint.isInt());
 351         if (!capabilities.supportsHeight())
 352             return 0;
 353 
 354         auto range = capabilities.height();
 355         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 356         break;
 357     }
 358 
 359     case MediaConstraintType::FrameRate: {
 360         ASSERT(constraint.isDouble());
 361         if (!capabilities.supportsFrameRate())
 362             return 0;
 363 
 364         auto range = capabilities.frameRate();
 365         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 366         break;
 367     }
 368 
 369     case MediaConstraintType::AspectRatio: {
 370         ASSERT(constraint.isDouble());
 371         if (!capabilities.supportsAspectRatio())
 372             return 0;
 373 
 374         auto range = capabilities.aspectRatio();
 375         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 376         break;
 377     }
 378 
 379     case MediaConstraintType::Volume: {
 380         ASSERT(constraint.isDouble());
 381         if (!capabilities.supportsVolume())
 382             return 0;
 383 
 384         auto range = capabilities.volume();
 385         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 386         break;
 387     }
 388 
 389     case MediaConstraintType::SampleRate: {
 390         ASSERT(constraint.isInt());
 391         if (!capabilities.supportsSampleRate())
 392             return 0;
 393 
 394         if (auto discreteRates = discreteSampleRates())
 395             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteRates);
 396 
 397         auto range = capabilities.sampleRate();
 398         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 399         break;
 400     }
 401 
 402     case MediaConstraintType::SampleSize: {
 403         ASSERT(constraint.isInt());
 404         if (!capabilities.supportsSampleSize())
 405             return 0;
 406 
 407         if (auto discreteSizes = discreteSampleSizes())
 408             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteSizes);
 409 
 410         auto range = capabilities.sampleSize();
 411         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 412         break;
 413     }
 414 
 415     case MediaConstraintType::FacingMode: {
 416         ASSERT(constraint.isString());
 417         if (!capabilities.supportsFacingMode())
 418             return 0;
 419 
 420         auto&amp; modes = capabilities.facingMode();
 421         Vector&lt;String&gt; supportedModes;
 422         supportedModes.reserveInitialCapacity(modes.size());
 423         for (auto&amp; mode : modes)
 424             supportedModes.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
 425         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(supportedModes);
 426         break;
 427     }
 428 
 429     case MediaConstraintType::EchoCancellation: {
 430         ASSERT(constraint.isBoolean());
 431         if (!capabilities.supportsEchoCancellation())
 432             return 0;
 433 
 434         bool echoCancellationReadWrite = capabilities.echoCancellation() == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite;
 435         return downcast&lt;BooleanConstraint&gt;(constraint).fitnessDistance(echoCancellationReadWrite);
 436         break;
 437     }
 438 
 439     case MediaConstraintType::DeviceId:
 440         ASSERT(!m_hashedID.isEmpty());
 441         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(m_hashedID);
 442         break;
 443 
 444     case MediaConstraintType::GroupId: {
 445         ASSERT(constraint.isString());
 446         if (!capabilities.supportsDeviceId())
 447             return 0;
 448 
 449         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(settings().groupId());
 450         break;
 451     }
 452 
 453     case MediaConstraintType::DisplaySurface:
 454     case MediaConstraintType::LogicalSurface:
 455         break;
 456 
 457     case MediaConstraintType::Unknown:
 458         // Unknown (or unsupported) constraints should be ignored.
 459         break;
 460     }
 461 
 462     return 0;
 463 }
 464 
 465 template &lt;typename ValueType&gt;
 466 static void applyNumericConstraint(const NumericConstraint&lt;ValueType&gt;&amp; constraint, ValueType current, Optional&lt;Vector&lt;ValueType&gt;&gt; discreteCapabilityValues, ValueType capabilityMin, ValueType capabilityMax, RealtimeMediaSource&amp; source, void (RealtimeMediaSource::*applier)(ValueType))
 467 {
 468     if (discreteCapabilityValues) {
 469         int value = constraint.valueForDiscreteCapabilityValues(current, *discreteCapabilityValues);
 470         if (value != current)
 471             (source.*applier)(value);
 472         return;
 473     }
 474 
 475     ValueType value = constraint.valueForCapabilityRange(current, capabilityMin, capabilityMax);
 476     if (value != current)
 477         (source.*applier)(value);
 478 }
 479 
 480 void RealtimeMediaSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; frameRate)
 481 {
 482     IntSize size;
 483     if (width)
 484         size.setWidth(width.value());
 485     if (height)
 486         size.setHeight(height.value());
 487     setSize(size);
 488     if (frameRate)
 489         setFrameRate(frameRate.value());
 490 }
 491 
 492 void RealtimeMediaSource::applyConstraint(const MediaConstraint&amp; constraint)
 493 {
 494     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, constraint.name());
 495 
 496     auto&amp; capabilities = this-&gt;capabilities();
 497     switch (constraint.constraintType()) {
 498     case MediaConstraintType::Width:
 499         ASSERT_NOT_REACHED();
 500         break;
 501 
 502     case MediaConstraintType::Height:
 503         ASSERT_NOT_REACHED();
 504         break;
 505 
 506     case MediaConstraintType::FrameRate:
 507         ASSERT_NOT_REACHED();
 508         break;
 509 
 510     case MediaConstraintType::AspectRatio: {
 511         ASSERT(constraint.isDouble());
 512         if (!capabilities.supportsAspectRatio())
 513             return;
 514 
 515         auto range = capabilities.aspectRatio();
 516         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), aspectRatio(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setAspectRatio);
 517         break;
 518     }
 519 
 520     case MediaConstraintType::Volume: {
 521         ASSERT(constraint.isDouble());
 522         if (!capabilities.supportsVolume())
 523             return;
 524 
 525         auto range = capabilities.volume();
 526         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), volume(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setVolume);
 527         break;
 528     }
 529 
 530     case MediaConstraintType::SampleRate: {
 531         ASSERT(constraint.isInt());
 532         if (!capabilities.supportsSampleRate())
 533             return;
 534 
 535         auto range = capabilities.sampleRate();
 536         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleRate(), discreteSampleRates(), range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleRate);
 537         break;
 538     }
 539 
 540     case MediaConstraintType::SampleSize: {
 541         ASSERT(constraint.isInt());
 542         if (!capabilities.supportsSampleSize())
 543             return;
 544 
 545         auto range = capabilities.sampleSize();
 546         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleSize(), { }, range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleSize);
 547         break;
 548     }
 549 
 550     case MediaConstraintType::EchoCancellation: {
 551         ASSERT(constraint.isBoolean());
 552         if (!capabilities.supportsEchoCancellation())
 553             return;
 554 
 555         bool setting;
 556         const BooleanConstraint&amp; boolConstraint = downcast&lt;BooleanConstraint&gt;(constraint);
 557         if (boolConstraint.getExact(setting) || boolConstraint.getIdeal(setting))
 558             setEchoCancellation(setting);
 559         break;
 560     }
 561 
 562     case MediaConstraintType::FacingMode: {
 563         ASSERT(constraint.isString());
 564         if (!capabilities.supportsFacingMode())
 565             return;
 566 
 567         auto&amp; supportedModes = capabilities.facingMode();
 568         auto filter = [supportedModes](const String&amp; modeString) {
 569             auto mode = RealtimeMediaSourceSettings::videoFacingModeEnum(modeString);
 570             for (auto&amp; supportedMode : supportedModes) {
 571                 if (mode == supportedMode)
 572                     return true;
 573             }
 574             return false;
 575         };
 576 
 577         auto modeString = downcast&lt;StringConstraint&gt;(constraint).find(WTFMove(filter));
 578         if (!modeString.isEmpty())
 579             setFacingMode(RealtimeMediaSourceSettings::videoFacingModeEnum(modeString));
 580         break;
 581     }
 582 
 583     case MediaConstraintType::DeviceId:
 584     case MediaConstraintType::GroupId:
 585         ASSERT(constraint.isString());
 586         // There is nothing to do here, neither can be changed.
 587         break;
 588 
 589     case MediaConstraintType::DisplaySurface:
 590     case MediaConstraintType::LogicalSurface:
 591         ASSERT(constraint.isBoolean());
 592         break;
 593 
 594     case MediaConstraintType::Unknown:
 595         break;
 596     }
 597 }
 598 
 599 bool RealtimeMediaSource::selectSettings(const MediaConstraints&amp; constraints, FlattenedConstraint&amp; candidates, String&amp; failedConstraint)
 600 {
 601     double minimumDistance = std::numeric_limits&lt;double&gt;::infinity();
 602 
 603     // https://w3c.github.io/mediacapture-main/#dfn-selectsettings
 604     //
 605     // 1. Each constraint specifies one or more values (or a range of values) for its property.
 606     //    A property may appear more than once in the list of &#39;advanced&#39; ConstraintSets. If an
 607     //    empty object or list has been given as the value for a constraint, it must be interpreted
 608     //    as if the constraint were not specified (in other words, an empty constraint == no constraint).
 609     //
 610     //    Note that unknown properties are discarded by WebIDL, which means that unknown/unsupported required
 611     //    constraints will silently disappear. To avoid this being a surprise, application authors are
 612     //    expected to first use the getSupportedConstraints() method as shown in the Examples below.
 613 
 614     // 2. Let object be the ConstrainablePattern object on which this algorithm is applied. Let copy be an
 615     //    unconstrained copy of object (i.e., copy should behave as if it were object with all ConstraintSets
 616     //    removed.)
 617 
 618     // 3. For every possible settings dictionary of copy compute its fitness distance, treating bare values of
 619     //    properties as ideal values. Let candidates be the set of settings dictionaries for which the fitness
 620     //    distance is finite.
 621 
 622     failedConstraint = emptyString();
 623 
 624     // Check width, height and frame rate jointly, because while they may be supported individually the combination may not be supported.
 625     double distance = std::numeric_limits&lt;double&gt;::infinity();
 626     if (!supportsSizeAndFrameRate(constraints.mandatoryConstraints.width(), constraints.mandatoryConstraints.height(), constraints.mandatoryConstraints.frameRate(), failedConstraint, minimumDistance))
 627         return false;
 628 
 629     constraints.mandatoryConstraints.filter([&amp;](const MediaConstraint&amp; constraint) {
 630         if (!supportsConstraint(constraint))
 631             return false;
 632 
 633         if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate) {
 634             candidates.set(constraint);
 635             return false;
 636         }
 637 
 638         double constraintDistance = fitnessDistance(constraint);
 639         if (std::isinf(constraintDistance)) {
 640             failedConstraint = constraint.name();
 641             return true;
 642         }
 643 
 644         distance = std::min(distance, constraintDistance);
 645         candidates.set(constraint);
 646         return false;
 647     });
 648 
 649     if (!failedConstraint.isEmpty())
 650         return false;
 651 
 652     minimumDistance = distance;
 653 
 654     // 4. If candidates is empty, return undefined as the result of the SelectSettings() algorithm.
 655     if (candidates.isEmpty())
 656         return true;
 657 
 658     // 5. Iterate over the &#39;advanced&#39; ConstraintSets in newConstraints in the order in which they were specified.
 659     //    For each ConstraintSet:
 660 
 661     // 5.1 compute the fitness distance between it and each settings dictionary in candidates, treating bare
 662     //     values of properties as exact.
 663     Vector&lt;std::pair&lt;double, MediaTrackConstraintSetMap&gt;&gt; supportedConstraints;
 664 
 665     for (const auto&amp; advancedConstraint : constraints.advancedConstraints) {
 666         double constraintDistance = 0;
 667         bool supported = false;
 668 
 669         if (advancedConstraint.width() || advancedConstraint.height() || advancedConstraint.frameRate()) {
 670             String dummy;
 671             if (!supportsSizeAndFrameRate(advancedConstraint.width(), advancedConstraint.height(), advancedConstraint.frameRate(), dummy, constraintDistance))
 672                 continue;
 673 
 674             supported = true;
 675         }
 676 
 677         advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 678 
 679             if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate)
 680                 return;
 681 
 682             distance = fitnessDistance(constraint);
 683             constraintDistance += distance;
 684             if (!std::isinf(distance))
 685                 supported = true;
 686         });
 687 
 688         minimumDistance = std::min(minimumDistance, constraintDistance);
 689 
 690         // 5.2 If the fitness distance is finite for one or more settings dictionaries in candidates, keep those
 691         //     settings dictionaries in candidates, discarding others.
 692         //     If the fitness distance is infinite for all settings dictionaries in candidates, ignore this ConstraintSet.
 693         if (supported)
 694             supportedConstraints.append({constraintDistance, advancedConstraint});
 695     }
 696 
 697     // 6. Select one settings dictionary from candidates, and return it as the result of the SelectSettings() algorithm.
 698     //    The UA should use the one with the smallest fitness distance, as calculated in step 3.
 699     if (!supportedConstraints.isEmpty()) {
 700         supportedConstraints.removeAllMatching([&amp;](const std::pair&lt;double, MediaTrackConstraintSetMap&gt;&amp; pair) -&gt; bool {
 701             return std::isinf(pair.first) || pair.first &gt; minimumDistance;
 702         });
 703 
 704         if (!supportedConstraints.isEmpty()) {
 705             auto&amp; advancedConstraint = supportedConstraints[0].second;
 706             advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 707                 candidates.merge(constraint);
 708             });
 709 
 710             minimumDistance = std::min(minimumDistance, supportedConstraints[0].first);
 711         }
 712     }
 713 
 714     return true;
 715 }
 716 
 717 bool RealtimeMediaSource::supportsConstraint(const MediaConstraint&amp; constraint)
 718 {
 719     auto&amp; capabilities = this-&gt;capabilities();
 720 
 721     switch (constraint.constraintType()) {
 722     case MediaConstraintType::Width:
 723         ASSERT(constraint.isInt());
 724         return capabilities.supportsWidth();
 725         break;
 726 
 727     case MediaConstraintType::Height:
 728         ASSERT(constraint.isInt());
 729         return capabilities.supportsHeight();
 730         break;
 731 
 732     case MediaConstraintType::FrameRate:
 733         ASSERT(constraint.isDouble());
 734         return capabilities.supportsFrameRate();
 735         break;
 736 
 737     case MediaConstraintType::AspectRatio:
 738         ASSERT(constraint.isDouble());
 739         return capabilities.supportsAspectRatio();
 740         break;
 741 
 742     case MediaConstraintType::Volume:
 743         ASSERT(constraint.isDouble());
 744         return capabilities.supportsVolume();
 745         break;
 746 
 747     case MediaConstraintType::SampleRate:
 748         ASSERT(constraint.isInt());
 749         return capabilities.supportsSampleRate();
 750         break;
 751 
 752     case MediaConstraintType::SampleSize:
 753         ASSERT(constraint.isInt());
 754         return capabilities.supportsSampleSize();
 755         break;
 756 
 757     case MediaConstraintType::FacingMode:
 758         ASSERT(constraint.isString());
 759         return capabilities.supportsFacingMode();
 760         break;
 761 
 762     case MediaConstraintType::EchoCancellation:
 763         ASSERT(constraint.isBoolean());
 764         return capabilities.supportsEchoCancellation();
 765         break;
 766 
 767     case MediaConstraintType::DeviceId:
 768         ASSERT(constraint.isString());
 769         return capabilities.supportsDeviceId();
 770         break;
 771 
 772     case MediaConstraintType::GroupId:
 773         ASSERT(constraint.isString());
 774         return capabilities.supportsDeviceId();
 775         break;
 776 
 777     case MediaConstraintType::DisplaySurface:
 778     case MediaConstraintType::LogicalSurface:
 779         // https://www.w3.org/TR/screen-capture/#new-constraints-for-captured-display-surfaces
 780         // 5.2.1 New Constraints for Captured Display Surfaces
 781         // Since the source of media cannot be changed after a MediaStreamTrack has been returned,
 782         // these constraints cannot be changed by an application.
 783         return false;
 784         break;
 785 
 786     case MediaConstraintType::Unknown:
 787         // Unknown (or unsupported) constraints should be ignored.
 788         break;
 789     }
 790 
 791     return false;
 792 }
 793 
 794 bool RealtimeMediaSource::supportsConstraints(const MediaConstraints&amp; constraints, String&amp; invalidConstraint)
 795 {
 796     ASSERT(constraints.isValid);
 797 
 798     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 799 
 800     FlattenedConstraint candidates;
 801     if (!selectSettings(constraints, candidates, invalidConstraint))
 802         return false;
 803 
 804     m_fitnessScore = 0;
 805     for (auto&amp; variant : candidates) {
 806         double distance = fitnessDistance(variant);
 807         switch (variant.constraintType()) {
 808         case MediaConstraintType::DeviceId:
 809         case MediaConstraintType::FacingMode:
 810             m_fitnessScore += distance ? 1 : 32;
 811             break;
 812 
 813         case MediaConstraintType::Width:
 814         case MediaConstraintType::Height:
 815         case MediaConstraintType::FrameRate:
 816         case MediaConstraintType::AspectRatio:
 817         case MediaConstraintType::Volume:
 818         case MediaConstraintType::SampleRate:
 819         case MediaConstraintType::SampleSize:
 820         case MediaConstraintType::EchoCancellation:
 821         case MediaConstraintType::GroupId:
 822         case MediaConstraintType::DisplaySurface:
 823         case MediaConstraintType::LogicalSurface:
 824         case MediaConstraintType::Unknown:
 825             m_fitnessScore += distance ? 1 : 2;
 826             break;
 827         }
 828     }
 829 
 830     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, &quot;fitness distance : &quot;, m_fitnessScore);
 831 
 832     return true;
 833 }
 834 
 835 void RealtimeMediaSource::applyConstraints(const FlattenedConstraint&amp; constraints)
 836 {
 837     if (constraints.isEmpty())
 838         return;
 839 
 840     beginConfiguration();
 841 
 842     auto&amp; capabilities = this-&gt;capabilities();
 843 
 844     Optional&lt;int&gt; width;
 845     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Width)) {
 846         ASSERT(constraint-&gt;isInt());
 847         if (capabilities.supportsWidth()) {
 848             auto range = capabilities.width();
 849             width = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 850         }
 851     }
 852 
 853     Optional&lt;int&gt; height;
 854     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Height)) {
 855         ASSERT(constraint-&gt;isInt());
 856         if (capabilities.supportsHeight()) {
 857             auto range = capabilities.height();
 858             height = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 859         }
 860     }
 861 
 862     Optional&lt;double&gt; frameRate;
 863     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::FrameRate)) {
 864         ASSERT(constraint-&gt;isDouble());
 865         if (capabilities.supportsFrameRate()) {
 866             auto range = capabilities.frameRate();
 867             frameRate = downcast&lt;DoubleConstraint&gt;(*constraint).valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 868         }
 869     }
 870 
 871     if (width || height || frameRate)
 872         setSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate));
 873 
 874     for (auto&amp; variant : constraints) {
 875         if (variant.constraintType() == MediaConstraintType::Width || variant.constraintType() == MediaConstraintType::Height || variant.constraintType() == MediaConstraintType::FrameRate)
 876             continue;
 877 
 878         applyConstraint(variant);
 879     }
 880 
 881     commitConfiguration();
 882 }
 883 
 884 Optional&lt;RealtimeMediaSource::ApplyConstraintsError&gt; RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints)
 885 {
 886     ASSERT(constraints.isValid);
 887 
 888     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 889 
 890     FlattenedConstraint candidates;
 891     String failedConstraint;
 892     if (!selectSettings(constraints, candidates, failedConstraint))
 893         return ApplyConstraintsError { failedConstraint, &quot;Constraint not supported&quot;_s };
 894 
 895     applyConstraints(candidates);
 896     return { };
 897 }
 898 
 899 void RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints, ApplyConstraintsHandler&amp;&amp; completionHandler)
 900 {
 901     completionHandler(applyConstraints(constraints));
 902 }
 903 
 904 void RealtimeMediaSource::setSize(const IntSize&amp; size)
 905 {
 906     if (size == m_size)
 907         return;
 908 
 909     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
 910 
 911     m_size = size;
 912     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 913 }
 914 
 915 const IntSize RealtimeMediaSource::size() const
 916 {
 917     auto size = m_size;
 918 
 919     if (size.isEmpty() &amp;&amp; !m_intrinsicSize.isEmpty()) {
 920         if (size.isZero())
 921             size = m_intrinsicSize;
 922         else if (size.width())
 923             size.setHeight(size.width() * (m_intrinsicSize.height() / static_cast&lt;double&gt;(m_intrinsicSize.width())));
 924         else if (size.height())
 925             size.setWidth(size.height() * (m_intrinsicSize.width() / static_cast&lt;double&gt;(m_intrinsicSize.height())));
 926     }
 927 
 928     return size;
 929 }
 930 
 931 void RealtimeMediaSource::setIntrinsicSize(const IntSize&amp; size)
 932 {
 933     if (m_intrinsicSize == size)
 934         return;
 935 
 936     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
 937 
 938     auto currentSize = this-&gt;size();
 939     m_intrinsicSize = size;
 940 
 941     if (currentSize != this-&gt;size())
 942         notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 943 }
 944 
 945 const IntSize RealtimeMediaSource::intrinsicSize() const
 946 {
 947     return m_intrinsicSize;
 948 }
 949 
 950 void RealtimeMediaSource::setFrameRate(double rate)
 951 {
 952     if (m_frameRate == rate)
 953         return;
 954 
 955     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);
 956 
 957     m_frameRate = rate;
 958     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FrameRate);
 959 }
 960 
 961 void RealtimeMediaSource::setAspectRatio(double ratio)
 962 {
 963     if (m_aspectRatio == ratio)
 964         return;
 965 
 966     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, ratio);
 967 
 968     m_aspectRatio = ratio;
 969     m_size.setHeight(m_size.width() / ratio);
 970     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::AspectRatio, RealtimeMediaSourceSettings::Flag::Height });
 971 }
 972 
 973 void RealtimeMediaSource::setFacingMode(RealtimeMediaSourceSettings::VideoFacingMode mode)
 974 {
 975     if (m_facingMode == mode)
 976         return;
 977 
 978     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, mode);
 979 
 980     m_facingMode = mode;
 981     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FacingMode);
 982 }
 983 
 984 void RealtimeMediaSource::setVolume(double volume)
 985 {
 986     if (m_volume == volume)
 987         return;
 988 
 989     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, volume);
 990 
 991     m_volume = volume;
 992     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::Volume);
 993 }
 994 
 995 void RealtimeMediaSource::setSampleRate(int rate)
 996 {
 997     if (m_sampleRate == rate)
 998         return;
 999 
1000     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);
1001 
1002     m_sampleRate = rate;
1003     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleRate);
1004 }
1005 
1006 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleRates() const
1007 {
1008     return WTF::nullopt;
1009 }
1010 
1011 void RealtimeMediaSource::setSampleSize(int size)
1012 {
1013     if (m_sampleSize == size)
1014         return;
1015 
1016     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
1017 
1018     m_sampleSize = size;
1019     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleSize);
1020 }
1021 
1022 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleSizes() const
1023 {
1024     return WTF::nullopt;
1025 }
1026 
1027 void RealtimeMediaSource::setEchoCancellation(bool echoCancellation)
1028 {
1029     if (m_echoCancellation == echoCancellation)
1030         return;
1031 
1032     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, echoCancellation);
1033     m_echoCancellation = echoCancellation;
1034     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::EchoCancellation);
1035 }
1036 
1037 void RealtimeMediaSource::scheduleDeferredTask(Function&lt;void()&gt;&amp;&amp; function)
1038 {
1039     ASSERT(function);
1040     callOnMainThread([protectedThis = makeRef(*this), function = WTFMove(function)] {
1041         function();
1042     });
1043 }
1044 
1045 const String&amp; RealtimeMediaSource::hashedId() const
1046 {
1047     ASSERT(!m_hashedID.isEmpty());
1048     return m_hashedID;
1049 }
1050 
1051 String RealtimeMediaSource::deviceIDHashSalt() const
1052 {
1053     return m_idHashSalt;
1054 }
1055 
1056 RealtimeMediaSource::Observer::~Observer()
1057 {
1058 }
1059 
1060 #if !RELEASE_LOG_DISABLED
1061 void RealtimeMediaSource::setLogger(const Logger&amp; newLogger, const void* newLogIdentifier)
1062 {
1063     m_logger = &amp;newLogger;
1064     m_logIdentifier = newLogIdentifier;
1065     ALWAYS_LOG(LOGIDENTIFIER, m_type, &quot;, &quot;, m_name, &quot;, &quot;, m_hashedID);
1066 }
1067 
1068 WTFLogChannel&amp; RealtimeMediaSource::logChannel() const
1069 {
1070     return LogWebRTC;
1071 }
1072 #endif
1073 
1074 String convertEnumerationToString(RealtimeMediaSource::Type enumerationValue)
1075 {
1076     static const NeverDestroyed&lt;String&gt; values[] = {
1077         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1078         MAKE_STATIC_STRING_IMPL(&quot;Audio&quot;),
1079         MAKE_STATIC_STRING_IMPL(&quot;Video&quot;),
1080     };
1081     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::None) == 0, &quot;RealtimeMediaSource::Type::None is not 0 as expected&quot;);
1082     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Audio) == 1, &quot;RealtimeMediaSource::Type::Audio is not 1 as expected&quot;);
1083     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Video) == 2, &quot;RealtimeMediaSource::Type::Video is not 2 as expected&quot;);
1084     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1085     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1086 }
1087 
1088 } // namespace WebCore
1089 
1090 #endif // ENABLE(MEDIA_STREAM)
    </pre>
  </body>
</html>