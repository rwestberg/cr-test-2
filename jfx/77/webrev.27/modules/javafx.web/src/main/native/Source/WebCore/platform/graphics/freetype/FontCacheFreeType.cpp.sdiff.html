<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontCacheFreeType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../filters/SourceGraphic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FontCustomPlatformDataFreeType.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/freetype/FontCacheFreeType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;FontCache.h&quot;
 24 
 25 #include &quot;CairoUniquePtr.h&quot;
 26 #include &quot;CairoUtilities.h&quot;

 27 #include &quot;FcUniquePtr.h&quot;
 28 #include &quot;FloatConversion.h&quot;
 29 #include &quot;Font.h&quot;
 30 #include &quot;FontDescription.h&quot;
 31 #include &quot;FontCacheFreeType.h&quot;
 32 #include &quot;RefPtrCairo.h&quot;
 33 #include &quot;RefPtrFontconfig.h&quot;
 34 #include &quot;UTF16UChar32Iterator.h&quot;
 35 #include &lt;cairo-ft.h&gt;
 36 #include &lt;cairo.h&gt;
 37 #include &lt;fontconfig/fcfreetype.h&gt;
 38 #include &lt;wtf/Assertions.h&gt;


 39 #include &lt;wtf/text/CString.h&gt;
 40 
 41 #if PLATFORM(GTK)
 42 #include &quot;GtkUtilities.h&quot;
 43 #endif
 44 
 45 #if ENABLE(VARIATION_FONTS)
 46 #include FT_MULTIPLE_MASTERS_H
 47 #endif
 48 
 49 namespace WebCore {
 50 
 51 void FontCache::platformInit()
 52 {
 53     // It&#39;s fine to call FcInit multiple times per the documentation.
 54     if (!FcInit())
 55         ASSERT_NOT_REACHED();
 56 }
 57 
 58 static int fontWeightToFontconfigWeight(FontSelectionValue weight)
</pre>
<hr />
<pre>
101         FcBool fontConfigEmbolden = FcFalse;
102         if (FcPatternGetBool(pattern, FC_EMBOLDEN, 0, &amp;fontConfigEmbolden) == FcResultMatch)
103             syntheticBold = fontConfigEmbolden;
104 
105         // Fallback fonts may not have FC_EMBOLDEN activated even though it&#39;s necessary.
106         int weight = 0;
107         if (!syntheticBold &amp;&amp; FcPatternGetInteger(pattern, FC_WEIGHT, 0, &amp;weight) == FcResultMatch)
108             syntheticBold = syntheticBold || weight &lt; FC_WEIGHT_DEMIBOLD;
109     }
110 
111     // We requested an italic font, but Fontconfig gave us one that was neither oblique nor italic.
112     syntheticOblique = false;
113     int actualFontSlant;
114     bool descriptionAllowsSyntheticOblique = fontDescription.fontSynthesis() &amp; FontSynthesisStyle;
115     if (descriptionAllowsSyntheticOblique &amp;&amp; fontDescription.italic()
116         &amp;&amp; FcPatternGetInteger(pattern, FC_SLANT, 0, &amp;actualFontSlant) == FcResultMatch) {
117         syntheticOblique = actualFontSlant == FC_SLANT_ROMAN;
118     }
119 }
120 
<span class="line-modified">121 RefPtr&lt;Font&gt; FontCache::systemFallbackForCharacters(const FontDescription&amp; description, const Font*, IsForPlatformFont, PreferColoredFont preferColoredFont, const UChar* characters, unsigned length)</span>
<span class="line-modified">122 {</span>
<span class="line-modified">123     FcUniquePtr&lt;FcCharSet&gt; fontConfigCharSet(FcCharSetCreate());</span>
<span class="line-modified">124     UTF16UChar32Iterator iterator(characters, length);</span>
<span class="line-modified">125     UChar32 character = iterator.next();</span>
<span class="line-modified">126     while (character != iterator.end()) {</span>
<span class="line-modified">127         FcCharSetAddChar(fontConfigCharSet.get(), character);</span>
<span class="line-modified">128         character = iterator.next();</span>













129     }
130 
<span class="line-modified">131     RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());</span>
<span class="line-modified">132     FcPatternAddCharSet(pattern.get(), FC_CHARSET, fontConfigCharSet.get());</span>




133 
<span class="line-modified">134     FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);</span>































































































135 #ifdef FC_COLOR
<span class="line-modified">136     if (preferColoredFont == PreferColoredFont::Yes)</span>
<span class="line-modified">137         FcPatternAddBool(pattern.get(), FC_COLOR, FcTrue);</span>
138 #endif


139 
<span class="line-modified">140     if (!configurePatternForFontDescription(pattern.get(), description))</span>
<span class="line-modified">141         return nullptr;</span>

142 
<span class="line-modified">143     FcConfigSubstitute(nullptr, pattern.get(), FcMatchPattern);</span>
<span class="line-modified">144     cairo_ft_font_options_substitute(getDefaultCairoFontOptions(), pattern.get());</span>
<span class="line-removed">145     FcDefaultSubstitute(pattern.get());</span>
146 
<span class="line-modified">147     FcResult fontConfigResult;</span>
<span class="line-modified">148     RefPtr&lt;FcPattern&gt; resultPattern = adoptRef(FcFontMatch(nullptr, pattern.get(), &amp;fontConfigResult));</span>


149     if (!resultPattern)
150         return nullptr;
151 
152     bool fixedWidth, syntheticBold, syntheticOblique;
153     getFontPropertiesFromPattern(resultPattern.get(), description, fixedWidth, syntheticBold, syntheticOblique);
154 
155     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
156     FontPlatformData alternateFontData(fontFace.get(), resultPattern.get(), description.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, description.orientation());
157     return fontForPlatformData(alternateFontData);
158 }
159 





160 static Vector&lt;String&gt; patternToFamilies(FcPattern&amp; pattern)
161 {
162     char* patternChars = reinterpret_cast&lt;char*&gt;(FcPatternFormat(&amp;pattern, reinterpret_cast&lt;const FcChar8*&gt;(&quot;%{family}&quot;)));
163     String patternString = String::fromUTF8(patternChars);
164     free(patternChars);
165 
166     return patternString.split(&#39;,&#39;);
167 }
168 
169 Vector&lt;String&gt; FontCache::systemFontFamilies()
170 {
171     RefPtr&lt;FcPattern&gt; scalablesOnlyPattern = adoptRef(FcPatternCreate());
172     FcPatternAddBool(scalablesOnlyPattern.get(), FC_SCALABLE, FcTrue);
173 
174     FcUniquePtr&lt;FcObjectSet&gt; familiesOnly(FcObjectSetBuild(FC_FAMILY, nullptr));
175     FcUniquePtr&lt;FcFontSet&gt; fontSet(FcFontList(nullptr, scalablesOnlyPattern.get(), familiesOnly.get()));
176 
177     Vector&lt;String&gt; fontFamilies;
178     for (int i = 0; i &lt; fontSet-&gt;nfont; i++) {
179         FcPattern* pattern = fontSet-&gt;fonts[i];
180         FcChar8* family = nullptr;
181         FcPatternGetString(pattern, FC_FAMILY, 0, &amp;family);
182         if (family)
183             fontFamilies.appendVector(patternToFamilies(*pattern));
184     }
185 
186     return fontFamilies;
187 }
188 





189 Ref&lt;Font&gt; FontCache::lastResortFallbackFont(const FontDescription&amp; fontDescription)
190 {
191     // We want to return a fallback font here, otherwise the logic preventing FontConfig
192     // matches for non-fallback fonts might return 0. See isFallbackFontAllowed.
<span class="line-modified">193     static AtomicString timesStr(&quot;serif&quot;);</span>
194     if (RefPtr&lt;Font&gt; font = fontForFamily(fontDescription, timesStr))
195         return *font;
196 
197     // This could be reached due to improperly-installed or misconfigured fontconfig.
198     RELEASE_ASSERT_NOT_REACHED();
199 }
200 
<span class="line-modified">201 Vector&lt;FontSelectionCapabilities&gt; FontCache::getFontSelectionCapabilitiesInFamily(const AtomicString&amp;, AllowUserInstalledFonts)</span>
202 {
203     return { };
204 }
205 
<span class="line-modified">206 static String getFamilyNameStringFromFamily(const AtomicString&amp; family)</span>
207 {
208     // If we&#39;re creating a fallback font (e.g. &quot;-webkit-monospace&quot;), convert the name into
209     // the fallback name (like &quot;monospace&quot;) that fontconfig understands.
210     if (family.length() &amp;&amp; !family.startsWith(&quot;-webkit-&quot;))
211         return family.string();
212 
213     if (family == standardFamily || family == serifFamily)
214         return &quot;serif&quot;;
215     if (family == sansSerifFamily)
216         return &quot;sans-serif&quot;;
217     if (family == monospaceFamily)
218         return &quot;monospace&quot;;
219     if (family == cursiveFamily)
220         return &quot;cursive&quot;;
221     if (family == fantasyFamily)
222         return &quot;fantasy&quot;;
223 
224 #if PLATFORM(GTK)
225     if (family == systemUiFamily || family == &quot;-webkit-system-font&quot;)
226         return defaultGtkSystemFont();
</pre>
<hr />
<pre>
354         if (family == familyB)
355             return true;
356     }
357     return false;
358 }
359 
360 static inline bool isCommonlyUsedGenericFamily(const String&amp; familyNameString)
361 {
362     return equalLettersIgnoringASCIICase(familyNameString, &quot;sans&quot;)
363         || equalLettersIgnoringASCIICase(familyNameString, &quot;sans-serif&quot;)
364         || equalLettersIgnoringASCIICase(familyNameString, &quot;serif&quot;)
365         || equalLettersIgnoringASCIICase(familyNameString, &quot;monospace&quot;)
366         || equalLettersIgnoringASCIICase(familyNameString, &quot;fantasy&quot;)
367 #if PLATFORM(GTK)
368         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-font&quot;)
369         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-ui&quot;)
370 #endif
371         || equalLettersIgnoringASCIICase(familyNameString, &quot;cursive&quot;);
372 }
373 
<span class="line-modified">374 std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformData(const FontDescription&amp; fontDescription, const AtomicString&amp; family, const FontFeatureSettings*, const FontVariantSettings*, FontSelectionSpecifiedCapabilities)</span>
375 {
376     // The CSS font matching algorithm (http://www.w3.org/TR/css3-fonts/#font-matching-algorithm)
377     // says that we must find an exact match for font family, slant (italic or oblique can be used)
378     // and font weight (we only match bold/non-bold here).
379     RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());
380     // Never choose unscalable fonts, as they pixelate when displayed at different sizes.
381     FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
382 #if ENABLE(VARIATION_FONTS)
383     FcPatternAddBool(pattern.get(), FC_VARIABLE, FcDontCare);
384 #endif
385     String familyNameString(getFamilyNameStringFromFamily(family));
386     if (!FcPatternAddString(pattern.get(), FC_FAMILY, reinterpret_cast&lt;const FcChar8*&gt;(familyNameString.utf8().data())))
387         return nullptr;
388 
389     if (!configurePatternForFontDescription(pattern.get(), fontDescription))
390         return nullptr;
391 
392     // The strategy is originally from Skia (src/ports/SkFontHost_fontconfig.cpp):
393     //
394     // We do not normally allow fontconfig to substitute one font family for another, since this
</pre>
<hr />
<pre>
433         return nullptr;
434 
435     bool fixedWidth, syntheticBold, syntheticOblique;
436     getFontPropertiesFromPattern(resultPattern.get(), fontDescription, fixedWidth, syntheticBold, syntheticOblique);
437 
438     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
439 #if ENABLE(VARIATION_FONTS)
440     // Cairo doesn&#39;t have API to get the FT_Face of an unscaled font, so we need to
441     // create a temporary scaled font to get the FT_Face.
442     CairoUniquePtr&lt;cairo_font_options_t&gt; options(cairo_font_options_copy(getDefaultCairoFontOptions()));
443     cairo_matrix_t matrix;
444     cairo_matrix_init_identity(&amp;matrix);
445     RefPtr&lt;cairo_scaled_font_t&gt; scaledFont = adoptRef(cairo_scaled_font_create(fontFace.get(), &amp;matrix, &amp;matrix, options.get()));
446     CairoFtFaceLocker cairoFtFaceLocker(scaledFont.get());
447     if (FT_Face freeTypeFace = cairoFtFaceLocker.ftFace()) {
448         auto variants = buildVariationSettings(freeTypeFace, fontDescription);
449         if (!variants.isEmpty())
450             FcPatternAddString(resultPattern.get(), FC_FONT_VARIATIONS, reinterpret_cast&lt;const FcChar8*&gt;(variants.utf8().data()));
451     }
452 #endif
<span class="line-modified">453     auto platformData = std::make_unique&lt;FontPlatformData&gt;(fontFace.get(), resultPattern.get(), fontDescription.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, fontDescription.orientation());</span>
454     // Verify that this font has an encoding compatible with Fontconfig. Fontconfig currently
455     // supports three encodings in FcFreeTypeCharIndex: Unicode, Symbol and AppleRoman.
456     // If this font doesn&#39;t have one of these three encodings, don&#39;t select it.
457     if (!platformData-&gt;hasCompatibleCharmap())
458         return nullptr;
459 
460     return platformData;
461 }
462 
<span class="line-modified">463 const AtomicString&amp; FontCache::platformAlternateFamilyName(const AtomicString&amp;)</span>
464 {
465     return nullAtom();
466 }
467 
468 #if ENABLE(VARIATION_FONTS)
469 struct VariationDefaults {
470     float defaultValue;
471     float minimumValue;
472     float maximumValue;
473 };
474 
475 typedef HashMap&lt;FontTag, VariationDefaults, FourCharacterTagHash, FourCharacterTagHashTraits&gt; VariationDefaultsMap;
476 typedef HashMap&lt;FontTag, float, FourCharacterTagHash, FourCharacterTagHashTraits&gt; VariationsMap;
477 
478 static VariationDefaultsMap defaultVariationValues(FT_Face face)
479 {
480     VariationDefaultsMap result;
481     FT_MM_Var* ftMMVar;
482     if (FT_Get_MM_Var(face, &amp;ftMMVar))
483         return result;
</pre>
<hr />
<pre>
505     auto applyVariation = [&amp;](const FontTag&amp; tag, float value) {
506         auto iterator = defaultValues.find(tag);
507         if (iterator == defaultValues.end())
508             return;
509         float valueToApply = clampTo(value, iterator-&gt;value.minimumValue, iterator-&gt;value.maximumValue);
510         variationsToBeApplied.set(tag, valueToApply);
511     };
512 
513     for (auto&amp; variation : variations)
514         applyVariation(variation.tag(), variation.value());
515 
516     StringBuilder builder;
517     for (auto&amp; variation : variationsToBeApplied) {
518         if (!builder.isEmpty())
519             builder.append(&#39;,&#39;);
520         builder.append(variation.key[0]);
521         builder.append(variation.key[1]);
522         builder.append(variation.key[2]);
523         builder.append(variation.key[3]);
524         builder.append(&#39;=&#39;);
<span class="line-modified">525         builder.appendNumber(variation.value);</span>
526     }
527     return builder.toString();
528 }
529 #endif // ENABLE(VARIATION_FONTS)
530 
531 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;FontCache.h&quot;
 24 
 25 #include &quot;CairoUniquePtr.h&quot;
 26 #include &quot;CairoUtilities.h&quot;
<span class="line-added"> 27 #include &quot;CharacterProperties.h&quot;</span>
 28 #include &quot;FcUniquePtr.h&quot;
 29 #include &quot;FloatConversion.h&quot;
 30 #include &quot;Font.h&quot;
 31 #include &quot;FontDescription.h&quot;
 32 #include &quot;FontCacheFreeType.h&quot;
 33 #include &quot;RefPtrCairo.h&quot;
 34 #include &quot;RefPtrFontconfig.h&quot;
 35 #include &quot;UTF16UChar32Iterator.h&quot;
 36 #include &lt;cairo-ft.h&gt;
 37 #include &lt;cairo.h&gt;
 38 #include &lt;fontconfig/fcfreetype.h&gt;
 39 #include &lt;wtf/Assertions.h&gt;
<span class="line-added"> 40 #include &lt;wtf/HashFunctions.h&gt;</span>
<span class="line-added"> 41 #include &lt;wtf/HashMap.h&gt;</span>
 42 #include &lt;wtf/text/CString.h&gt;
 43 
 44 #if PLATFORM(GTK)
 45 #include &quot;GtkUtilities.h&quot;
 46 #endif
 47 
 48 #if ENABLE(VARIATION_FONTS)
 49 #include FT_MULTIPLE_MASTERS_H
 50 #endif
 51 
 52 namespace WebCore {
 53 
 54 void FontCache::platformInit()
 55 {
 56     // It&#39;s fine to call FcInit multiple times per the documentation.
 57     if (!FcInit())
 58         ASSERT_NOT_REACHED();
 59 }
 60 
 61 static int fontWeightToFontconfigWeight(FontSelectionValue weight)
</pre>
<hr />
<pre>
104         FcBool fontConfigEmbolden = FcFalse;
105         if (FcPatternGetBool(pattern, FC_EMBOLDEN, 0, &amp;fontConfigEmbolden) == FcResultMatch)
106             syntheticBold = fontConfigEmbolden;
107 
108         // Fallback fonts may not have FC_EMBOLDEN activated even though it&#39;s necessary.
109         int weight = 0;
110         if (!syntheticBold &amp;&amp; FcPatternGetInteger(pattern, FC_WEIGHT, 0, &amp;weight) == FcResultMatch)
111             syntheticBold = syntheticBold || weight &lt; FC_WEIGHT_DEMIBOLD;
112     }
113 
114     // We requested an italic font, but Fontconfig gave us one that was neither oblique nor italic.
115     syntheticOblique = false;
116     int actualFontSlant;
117     bool descriptionAllowsSyntheticOblique = fontDescription.fontSynthesis() &amp; FontSynthesisStyle;
118     if (descriptionAllowsSyntheticOblique &amp;&amp; fontDescription.italic()
119         &amp;&amp; FcPatternGetInteger(pattern, FC_SLANT, 0, &amp;actualFontSlant) == FcResultMatch) {
120         syntheticOblique = actualFontSlant == FC_SLANT_ROMAN;
121     }
122 }
123 
<span class="line-modified">124 struct CachedPattern {</span>
<span class="line-modified">125     // The pattern is owned by the CachedFontSet.</span>
<span class="line-modified">126     FcPattern* pattern { nullptr };</span>
<span class="line-modified">127     FcCharSet* charSet { nullptr };</span>
<span class="line-modified">128 };</span>
<span class="line-modified">129 </span>
<span class="line-modified">130 class CachedFontSet {</span>
<span class="line-modified">131     WTF_MAKE_NONCOPYABLE(CachedFontSet); WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">132 public:</span>
<span class="line-added">133     explicit CachedFontSet(RefPtr&lt;FcPattern&gt;&amp;&amp; pattern)</span>
<span class="line-added">134         : m_pattern(WTFMove(pattern))</span>
<span class="line-added">135     {</span>
<span class="line-added">136         FcResult result;</span>
<span class="line-added">137         m_fontSet.reset(FcFontSort(nullptr, m_pattern.get(), FcTrue, nullptr, &amp;result));</span>
<span class="line-added">138         for (int i = 0; i &lt; m_fontSet-&gt;nfont; ++i) {</span>
<span class="line-added">139             FcPattern* pattern = m_fontSet-&gt;fonts[i];</span>
<span class="line-added">140             FcCharSet* charSet;</span>
<span class="line-added">141 </span>
<span class="line-added">142             if (FcPatternGetCharSet(pattern, FC_CHARSET, 0, &amp;charSet) == FcResultMatch)</span>
<span class="line-added">143                 m_patterns.append({ pattern, charSet });</span>
<span class="line-added">144         }</span>
145     }
146 
<span class="line-modified">147     RefPtr&lt;FcPattern&gt; bestForCharacters(const UChar* characters, unsigned length)</span>
<span class="line-modified">148     {</span>
<span class="line-added">149         if (m_patterns.isEmpty()) {</span>
<span class="line-added">150             FcResult result;</span>
<span class="line-added">151             return adoptRef(FcFontMatch(nullptr, m_pattern.get(), &amp;result));</span>
<span class="line-added">152         }</span>
153 
<span class="line-modified">154         FcUniquePtr&lt;FcCharSet&gt; fontConfigCharSet(FcCharSetCreate());</span>
<span class="line-added">155         UTF16UChar32Iterator iterator(characters, length);</span>
<span class="line-added">156         UChar32 character = iterator.next();</span>
<span class="line-added">157         bool hasNonIgnorableCharacters = false;</span>
<span class="line-added">158         while (character != iterator.end()) {</span>
<span class="line-added">159             if (!isDefaultIgnorableCodePoint(character)) {</span>
<span class="line-added">160                 FcCharSetAddChar(fontConfigCharSet.get(), character);</span>
<span class="line-added">161                 hasNonIgnorableCharacters = true;</span>
<span class="line-added">162             }</span>
<span class="line-added">163             character = iterator.next();</span>
<span class="line-added">164         }</span>
<span class="line-added">165 </span>
<span class="line-added">166         FcPattern* bestPattern = nullptr;</span>
<span class="line-added">167         int minScore = std::numeric_limits&lt;int&gt;::max();</span>
<span class="line-added">168         if (hasNonIgnorableCharacters) {</span>
<span class="line-added">169             for (const auto&amp; cachedPattern : m_patterns) {</span>
<span class="line-added">170                 if (!cachedPattern.charSet)</span>
<span class="line-added">171                     continue;</span>
<span class="line-added">172 </span>
<span class="line-added">173                 int score = FcCharSetSubtractCount(fontConfigCharSet.get(), cachedPattern.charSet);</span>
<span class="line-added">174                 if (!score)</span>
<span class="line-added">175                     return adoptRef(FcFontRenderPrepare(nullptr, m_pattern.get(), cachedPattern.pattern));</span>
<span class="line-added">176 </span>
<span class="line-added">177                 if (score &lt; minScore) {</span>
<span class="line-added">178                     bestPattern = cachedPattern.pattern;</span>
<span class="line-added">179                     minScore = score;</span>
<span class="line-added">180                 }</span>
<span class="line-added">181             }</span>
<span class="line-added">182         }</span>
<span class="line-added">183 </span>
<span class="line-added">184         if (bestPattern)</span>
<span class="line-added">185             return adoptRef(FcFontRenderPrepare(nullptr, m_pattern.get(), bestPattern));</span>
<span class="line-added">186 </span>
<span class="line-added">187         // If there aren&#39;t fonts with the given characters or all characters are ignorable, the first one is the best match.</span>
<span class="line-added">188         return adoptRef(FcFontRenderPrepare(nullptr, m_pattern.get(), m_patterns[0].pattern));</span>
<span class="line-added">189     }</span>
<span class="line-added">190 </span>
<span class="line-added">191 private:</span>
<span class="line-added">192     RefPtr&lt;FcPattern&gt; m_pattern;</span>
<span class="line-added">193     FcUniquePtr&lt;FcFontSet&gt; m_fontSet;</span>
<span class="line-added">194     Vector&lt;CachedPattern&gt; m_patterns;</span>
<span class="line-added">195 };</span>
<span class="line-added">196 </span>
<span class="line-added">197 struct FallbackFontDescriptionKey {</span>
<span class="line-added">198     FallbackFontDescriptionKey() = default;</span>
<span class="line-added">199 </span>
<span class="line-added">200     FallbackFontDescriptionKey(const FontDescription&amp; description, FontCache::PreferColoredFont preferColoredFont)</span>
<span class="line-added">201         : descriptionKey(description)</span>
<span class="line-added">202         , coloredFont(preferColoredFont == FontCache::PreferColoredFont::Yes)</span>
<span class="line-added">203     {</span>
<span class="line-added">204     }</span>
<span class="line-added">205 </span>
<span class="line-added">206     explicit FallbackFontDescriptionKey(WTF::HashTableDeletedValueType deletedValue)</span>
<span class="line-added">207         : descriptionKey(deletedValue)</span>
<span class="line-added">208     {</span>
<span class="line-added">209     }</span>
<span class="line-added">210 </span>
<span class="line-added">211     bool operator==(const FallbackFontDescriptionKey&amp; other) const</span>
<span class="line-added">212     {</span>
<span class="line-added">213         return descriptionKey == other.descriptionKey &amp;&amp; coloredFont == other.coloredFont;</span>
<span class="line-added">214     }</span>
<span class="line-added">215 </span>
<span class="line-added">216     bool operator!=(const FallbackFontDescriptionKey&amp; other) const</span>
<span class="line-added">217     {</span>
<span class="line-added">218         return !(*this == other);</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
<span class="line-added">221     bool isHashTableDeletedValue() const { return descriptionKey.isHashTableDeletedValue(); }</span>
<span class="line-added">222 </span>
<span class="line-added">223     unsigned computeHash() const</span>
<span class="line-added">224     {</span>
<span class="line-added">225         return WTF::pairIntHash(descriptionKey.computeHash(), WTF::DefaultHash&lt;bool&gt;::Hash::hash(coloredFont));</span>
<span class="line-added">226     }</span>
<span class="line-added">227 </span>
<span class="line-added">228     FontDescriptionKey descriptionKey;</span>
<span class="line-added">229     bool coloredFont { false };</span>
<span class="line-added">230 };</span>
<span class="line-added">231 </span>
<span class="line-added">232 struct FallbackFontDescriptionKeyHash {</span>
<span class="line-added">233     static unsigned hash(const FallbackFontDescriptionKey&amp; key) { return key.computeHash(); }</span>
<span class="line-added">234     static bool equal(const FallbackFontDescriptionKey&amp; a, const FallbackFontDescriptionKey&amp; b) { return a == b; }</span>
<span class="line-added">235     static const bool safeToCompareToEmptyOrDeleted = true;</span>
<span class="line-added">236 };</span>
<span class="line-added">237 </span>
<span class="line-added">238 using SystemFallbackCache = HashMap&lt;FallbackFontDescriptionKey, std::unique_ptr&lt;CachedFontSet&gt;, FallbackFontDescriptionKeyHash, SimpleClassHashTraits&lt;FallbackFontDescriptionKey&gt;&gt;;</span>
<span class="line-added">239 static SystemFallbackCache&amp; systemFallbackCache()</span>
<span class="line-added">240 {</span>
<span class="line-added">241     static NeverDestroyed&lt;SystemFallbackCache&gt; cache;</span>
<span class="line-added">242     return cache.get();</span>
<span class="line-added">243 }</span>
<span class="line-added">244 </span>
<span class="line-added">245 RefPtr&lt;Font&gt; FontCache::systemFallbackForCharacters(const FontDescription&amp; description, const Font*, IsForPlatformFont, PreferColoredFont preferColoredFont, const UChar* characters, unsigned length)</span>
<span class="line-added">246 {</span>
<span class="line-added">247     auto addResult = systemFallbackCache().ensure(FallbackFontDescriptionKey(description, preferColoredFont), [&amp;description, preferColoredFont]() -&gt; std::unique_ptr&lt;CachedFontSet&gt; {</span>
<span class="line-added">248         RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());</span>
<span class="line-added">249         FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);</span>
250 #ifdef FC_COLOR
<span class="line-modified">251         if (preferColoredFont == PreferColoredFont::Yes)</span>
<span class="line-modified">252             FcPatternAddBool(pattern.get(), FC_COLOR, FcTrue);</span>
253 #endif
<span class="line-added">254         if (!configurePatternForFontDescription(pattern.get(), description))</span>
<span class="line-added">255             return nullptr;</span>
256 
<span class="line-modified">257         FcConfigSubstitute(nullptr, pattern.get(), FcMatchPattern);</span>
<span class="line-modified">258         cairo_ft_font_options_substitute(getDefaultCairoFontOptions(), pattern.get());</span>
<span class="line-added">259         FcDefaultSubstitute(pattern.get());</span>
260 
<span class="line-modified">261         return makeUnique&lt;CachedFontSet&gt;(WTFMove(pattern));</span>
<span class="line-modified">262     });</span>

263 
<span class="line-modified">264     if (!addResult.iterator-&gt;value)</span>
<span class="line-modified">265         return nullptr;</span>
<span class="line-added">266 </span>
<span class="line-added">267     RefPtr&lt;FcPattern&gt; resultPattern = addResult.iterator-&gt;value-&gt;bestForCharacters(characters, length);</span>
268     if (!resultPattern)
269         return nullptr;
270 
271     bool fixedWidth, syntheticBold, syntheticOblique;
272     getFontPropertiesFromPattern(resultPattern.get(), description, fixedWidth, syntheticBold, syntheticOblique);
273 
274     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
275     FontPlatformData alternateFontData(fontFace.get(), resultPattern.get(), description.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, description.orientation());
276     return fontForPlatformData(alternateFontData);
277 }
278 
<span class="line-added">279 void FontCache::platformPurgeInactiveFontData()</span>
<span class="line-added">280 {</span>
<span class="line-added">281     systemFallbackCache().clear();</span>
<span class="line-added">282 }</span>
<span class="line-added">283 </span>
284 static Vector&lt;String&gt; patternToFamilies(FcPattern&amp; pattern)
285 {
286     char* patternChars = reinterpret_cast&lt;char*&gt;(FcPatternFormat(&amp;pattern, reinterpret_cast&lt;const FcChar8*&gt;(&quot;%{family}&quot;)));
287     String patternString = String::fromUTF8(patternChars);
288     free(patternChars);
289 
290     return patternString.split(&#39;,&#39;);
291 }
292 
293 Vector&lt;String&gt; FontCache::systemFontFamilies()
294 {
295     RefPtr&lt;FcPattern&gt; scalablesOnlyPattern = adoptRef(FcPatternCreate());
296     FcPatternAddBool(scalablesOnlyPattern.get(), FC_SCALABLE, FcTrue);
297 
298     FcUniquePtr&lt;FcObjectSet&gt; familiesOnly(FcObjectSetBuild(FC_FAMILY, nullptr));
299     FcUniquePtr&lt;FcFontSet&gt; fontSet(FcFontList(nullptr, scalablesOnlyPattern.get(), familiesOnly.get()));
300 
301     Vector&lt;String&gt; fontFamilies;
302     for (int i = 0; i &lt; fontSet-&gt;nfont; i++) {
303         FcPattern* pattern = fontSet-&gt;fonts[i];
304         FcChar8* family = nullptr;
305         FcPatternGetString(pattern, FC_FAMILY, 0, &amp;family);
306         if (family)
307             fontFamilies.appendVector(patternToFamilies(*pattern));
308     }
309 
310     return fontFamilies;
311 }
312 
<span class="line-added">313 bool FontCache::isSystemFontForbiddenForEditing(const String&amp;)</span>
<span class="line-added">314 {</span>
<span class="line-added">315     return false;</span>
<span class="line-added">316 }</span>
<span class="line-added">317 </span>
318 Ref&lt;Font&gt; FontCache::lastResortFallbackFont(const FontDescription&amp; fontDescription)
319 {
320     // We want to return a fallback font here, otherwise the logic preventing FontConfig
321     // matches for non-fallback fonts might return 0. See isFallbackFontAllowed.
<span class="line-modified">322     static AtomString timesStr(&quot;serif&quot;);</span>
323     if (RefPtr&lt;Font&gt; font = fontForFamily(fontDescription, timesStr))
324         return *font;
325 
326     // This could be reached due to improperly-installed or misconfigured fontconfig.
327     RELEASE_ASSERT_NOT_REACHED();
328 }
329 
<span class="line-modified">330 Vector&lt;FontSelectionCapabilities&gt; FontCache::getFontSelectionCapabilitiesInFamily(const AtomString&amp;, AllowUserInstalledFonts)</span>
331 {
332     return { };
333 }
334 
<span class="line-modified">335 static String getFamilyNameStringFromFamily(const AtomString&amp; family)</span>
336 {
337     // If we&#39;re creating a fallback font (e.g. &quot;-webkit-monospace&quot;), convert the name into
338     // the fallback name (like &quot;monospace&quot;) that fontconfig understands.
339     if (family.length() &amp;&amp; !family.startsWith(&quot;-webkit-&quot;))
340         return family.string();
341 
342     if (family == standardFamily || family == serifFamily)
343         return &quot;serif&quot;;
344     if (family == sansSerifFamily)
345         return &quot;sans-serif&quot;;
346     if (family == monospaceFamily)
347         return &quot;monospace&quot;;
348     if (family == cursiveFamily)
349         return &quot;cursive&quot;;
350     if (family == fantasyFamily)
351         return &quot;fantasy&quot;;
352 
353 #if PLATFORM(GTK)
354     if (family == systemUiFamily || family == &quot;-webkit-system-font&quot;)
355         return defaultGtkSystemFont();
</pre>
<hr />
<pre>
483         if (family == familyB)
484             return true;
485     }
486     return false;
487 }
488 
489 static inline bool isCommonlyUsedGenericFamily(const String&amp; familyNameString)
490 {
491     return equalLettersIgnoringASCIICase(familyNameString, &quot;sans&quot;)
492         || equalLettersIgnoringASCIICase(familyNameString, &quot;sans-serif&quot;)
493         || equalLettersIgnoringASCIICase(familyNameString, &quot;serif&quot;)
494         || equalLettersIgnoringASCIICase(familyNameString, &quot;monospace&quot;)
495         || equalLettersIgnoringASCIICase(familyNameString, &quot;fantasy&quot;)
496 #if PLATFORM(GTK)
497         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-font&quot;)
498         || equalLettersIgnoringASCIICase(familyNameString, &quot;-webkit-system-ui&quot;)
499 #endif
500         || equalLettersIgnoringASCIICase(familyNameString, &quot;cursive&quot;);
501 }
502 
<span class="line-modified">503 std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings*, const FontVariantSettings*, FontSelectionSpecifiedCapabilities)</span>
504 {
505     // The CSS font matching algorithm (http://www.w3.org/TR/css3-fonts/#font-matching-algorithm)
506     // says that we must find an exact match for font family, slant (italic or oblique can be used)
507     // and font weight (we only match bold/non-bold here).
508     RefPtr&lt;FcPattern&gt; pattern = adoptRef(FcPatternCreate());
509     // Never choose unscalable fonts, as they pixelate when displayed at different sizes.
510     FcPatternAddBool(pattern.get(), FC_SCALABLE, FcTrue);
511 #if ENABLE(VARIATION_FONTS)
512     FcPatternAddBool(pattern.get(), FC_VARIABLE, FcDontCare);
513 #endif
514     String familyNameString(getFamilyNameStringFromFamily(family));
515     if (!FcPatternAddString(pattern.get(), FC_FAMILY, reinterpret_cast&lt;const FcChar8*&gt;(familyNameString.utf8().data())))
516         return nullptr;
517 
518     if (!configurePatternForFontDescription(pattern.get(), fontDescription))
519         return nullptr;
520 
521     // The strategy is originally from Skia (src/ports/SkFontHost_fontconfig.cpp):
522     //
523     // We do not normally allow fontconfig to substitute one font family for another, since this
</pre>
<hr />
<pre>
562         return nullptr;
563 
564     bool fixedWidth, syntheticBold, syntheticOblique;
565     getFontPropertiesFromPattern(resultPattern.get(), fontDescription, fixedWidth, syntheticBold, syntheticOblique);
566 
567     RefPtr&lt;cairo_font_face_t&gt; fontFace = adoptRef(cairo_ft_font_face_create_for_pattern(resultPattern.get()));
568 #if ENABLE(VARIATION_FONTS)
569     // Cairo doesn&#39;t have API to get the FT_Face of an unscaled font, so we need to
570     // create a temporary scaled font to get the FT_Face.
571     CairoUniquePtr&lt;cairo_font_options_t&gt; options(cairo_font_options_copy(getDefaultCairoFontOptions()));
572     cairo_matrix_t matrix;
573     cairo_matrix_init_identity(&amp;matrix);
574     RefPtr&lt;cairo_scaled_font_t&gt; scaledFont = adoptRef(cairo_scaled_font_create(fontFace.get(), &amp;matrix, &amp;matrix, options.get()));
575     CairoFtFaceLocker cairoFtFaceLocker(scaledFont.get());
576     if (FT_Face freeTypeFace = cairoFtFaceLocker.ftFace()) {
577         auto variants = buildVariationSettings(freeTypeFace, fontDescription);
578         if (!variants.isEmpty())
579             FcPatternAddString(resultPattern.get(), FC_FONT_VARIATIONS, reinterpret_cast&lt;const FcChar8*&gt;(variants.utf8().data()));
580     }
581 #endif
<span class="line-modified">582     auto platformData = makeUnique&lt;FontPlatformData&gt;(fontFace.get(), resultPattern.get(), fontDescription.computedPixelSize(), fixedWidth, syntheticBold, syntheticOblique, fontDescription.orientation());</span>
583     // Verify that this font has an encoding compatible with Fontconfig. Fontconfig currently
584     // supports three encodings in FcFreeTypeCharIndex: Unicode, Symbol and AppleRoman.
585     // If this font doesn&#39;t have one of these three encodings, don&#39;t select it.
586     if (!platformData-&gt;hasCompatibleCharmap())
587         return nullptr;
588 
589     return platformData;
590 }
591 
<span class="line-modified">592 const AtomString&amp; FontCache::platformAlternateFamilyName(const AtomString&amp;)</span>
593 {
594     return nullAtom();
595 }
596 
597 #if ENABLE(VARIATION_FONTS)
598 struct VariationDefaults {
599     float defaultValue;
600     float minimumValue;
601     float maximumValue;
602 };
603 
604 typedef HashMap&lt;FontTag, VariationDefaults, FourCharacterTagHash, FourCharacterTagHashTraits&gt; VariationDefaultsMap;
605 typedef HashMap&lt;FontTag, float, FourCharacterTagHash, FourCharacterTagHashTraits&gt; VariationsMap;
606 
607 static VariationDefaultsMap defaultVariationValues(FT_Face face)
608 {
609     VariationDefaultsMap result;
610     FT_MM_Var* ftMMVar;
611     if (FT_Get_MM_Var(face, &amp;ftMMVar))
612         return result;
</pre>
<hr />
<pre>
634     auto applyVariation = [&amp;](const FontTag&amp; tag, float value) {
635         auto iterator = defaultValues.find(tag);
636         if (iterator == defaultValues.end())
637             return;
638         float valueToApply = clampTo(value, iterator-&gt;value.minimumValue, iterator-&gt;value.maximumValue);
639         variationsToBeApplied.set(tag, valueToApply);
640     };
641 
642     for (auto&amp; variation : variations)
643         applyVariation(variation.tag(), variation.value());
644 
645     StringBuilder builder;
646     for (auto&amp; variation : variationsToBeApplied) {
647         if (!builder.isEmpty())
648             builder.append(&#39;,&#39;);
649         builder.append(variation.key[0]);
650         builder.append(variation.key[1]);
651         builder.append(variation.key[2]);
652         builder.append(variation.key[3]);
653         builder.append(&#39;=&#39;);
<span class="line-modified">654         builder.appendFixedPrecisionNumber(variation.value);</span>
655     }
656     return builder.toString();
657 }
658 #endif // ENABLE(VARIATION_FONTS)
659 
660 }
</pre>
</td>
</tr>
</table>
<center><a href="../filters/SourceGraphic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FontCustomPlatformDataFreeType.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>