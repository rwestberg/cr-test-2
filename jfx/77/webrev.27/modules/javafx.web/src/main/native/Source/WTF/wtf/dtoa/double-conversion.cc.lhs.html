<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2010 the V8 project authors. All rights reserved.
  2 // Redistribution and use in source and binary forms, with or without
  3 // modification, are permitted provided that the following conditions are
  4 // met:
  5 //
  6 //     * Redistributions of source code must retain the above copyright
  7 //       notice, this list of conditions and the following disclaimer.
  8 //     * Redistributions in binary form must reproduce the above
  9 //       copyright notice, this list of conditions and the following
 10 //       disclaimer in the documentation and/or other materials provided
 11 //       with the distribution.
 12 //     * Neither the name of Google Inc. nor the names of its
 13 //       contributors may be used to endorse or promote products derived
 14 //       from this software without specific prior written permission.
 15 //
 16 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27 
 28 #include &quot;config.h&quot;
 29 
 30 #include &lt;climits&gt;
 31 #include &lt;locale&gt;
 32 #include &lt;cmath&gt;
 33 
 34 #include &lt;wtf/dtoa/double-conversion.h&gt;
 35 
 36 #include &lt;wtf/dtoa/bignum-dtoa.h&gt;
 37 #include &lt;wtf/dtoa/fast-dtoa.h&gt;
 38 #include &lt;wtf/dtoa/fixed-dtoa.h&gt;
 39 #include &lt;wtf/dtoa/ieee.h&gt;
 40 #include &lt;wtf/dtoa/strtod.h&gt;
 41 #include &lt;wtf/dtoa/utils.h&gt;
 42 
 43 #include &lt;wtf/ASCIICType.h&gt;
 44 
 45 namespace WTF {
 46 namespace double_conversion {
<a name="1" id="anc1"></a><span class="line-modified"> 47     </span>
 48 const DoubleToStringConverter&amp; DoubleToStringConverter::EcmaScriptConverter() {
<a name="2" id="anc2"></a><span class="line-modified"> 49         int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;</span>
<span class="line-modified"> 50         static DoubleToStringConverter converter(flags,</span>
<span class="line-modified"> 51                                                  &quot;Infinity&quot;,</span>
<span class="line-modified"> 52                                                  &quot;NaN&quot;,</span>
<span class="line-modified"> 53                                                  &#39;e&#39;,</span>
<span class="line-modified"> 54                                                  -6, 21,</span>
<span class="line-modified"> 55                                                  6, 0);</span>
<span class="line-modified"> 56         return converter;</span>
 57 }
<a name="3" id="anc3"></a><span class="line-modified"> 58     </span>
<span class="line-modified"> 59     </span>
 60 bool DoubleToStringConverter::HandleSpecialValues(
<a name="4" id="anc4"></a><span class="line-modified"> 61                                                       double value,</span>
<span class="line-modified"> 62                                                       StringBuilder* result_builder) const {</span>
<span class="line-modified"> 63         Double double_inspect(value);</span>
<span class="line-modified"> 64         if (double_inspect.IsInfinite()) {</span>
<span class="line-modified"> 65             if (infinity_symbol_ == NULL) return false;</span>
<span class="line-modified"> 66             if (value &lt; 0) {</span>
<span class="line-modified"> 67                 result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified"> 68             }</span>
<span class="line-modified"> 69             result_builder-&gt;AddString(infinity_symbol_);</span>
<span class="line-modified"> 70             return true;</span>
<span class="line-modified"> 71         }</span>
<span class="line-modified"> 72         if (double_inspect.IsNan()) {</span>
<span class="line-modified"> 73             if (nan_symbol_ == NULL) return false;</span>
<span class="line-modified"> 74             result_builder-&gt;AddString(nan_symbol_);</span>
<span class="line-modified"> 75             return true;</span>
<span class="line-modified"> 76         }</span>
<span class="line-modified"> 77         return false;</span>
 78 }
<a name="5" id="anc5"></a><span class="line-modified"> 79     </span>
<span class="line-modified"> 80     </span>
 81 void DoubleToStringConverter::CreateExponentialRepresentation(
<a name="6" id="anc6"></a><span class="line-modified"> 82                                                                   const char* decimal_digits,</span>
<span class="line-modified"> 83                                                                   int length,</span>
<span class="line-modified"> 84                                                                   int exponent,</span>
<span class="line-modified"> 85                                                                   StringBuilder* result_builder) const {</span>
<span class="line-modified"> 86         ASSERT(length != 0);</span>
<span class="line-modified"> 87         result_builder-&gt;AddCharacter(decimal_digits[0]);</span>
<span class="line-modified"> 88         if (length != 1) {</span>
<span class="line-modified"> 89             result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified"> 90             result_builder-&gt;AddSubstring(&amp;decimal_digits[1], length-1);</span>
<span class="line-modified"> 91         }</span>
<span class="line-modified"> 92         result_builder-&gt;AddCharacter(exponent_character_);</span>
<span class="line-modified"> 93         if (exponent &lt; 0) {</span>
<span class="line-modified"> 94             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified"> 95             exponent = -exponent;</span>
<span class="line-modified"> 96         } else {</span>
<span class="line-modified"> 97             if ((flags_ &amp; EMIT_POSITIVE_EXPONENT_SIGN) != 0) {</span>
<span class="line-modified"> 98                 result_builder-&gt;AddCharacter(&#39;+&#39;);</span>
<span class="line-modified"> 99             }</span>
<span class="line-modified">100         }</span>
<span class="line-modified">101         if (exponent == 0) {</span>
<span class="line-modified">102             result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">103             return;</span>
<span class="line-modified">104         }</span>
<span class="line-modified">105         ASSERT(exponent &lt; 1e4);</span>
<span class="line-modified">106         const int kMaxExponentLength = 5;</span>
<span class="line-modified">107         char buffer[kMaxExponentLength + 1];</span>
108   buffer[kMaxExponentLength] = &#39;\0&#39;;
<a name="7" id="anc7"></a><span class="line-modified">109         int first_char_pos = kMaxExponentLength;</span>
<span class="line-modified">110         while (exponent &gt; 0) {</span>
<span class="line-modified">111             buffer[--first_char_pos] = &#39;0&#39; + (exponent % 10);</span>
<span class="line-modified">112             exponent /= 10;</span>
<span class="line-modified">113         }</span>
<span class="line-modified">114         result_builder-&gt;AddSubstring(&amp;buffer[first_char_pos],</span>
<span class="line-modified">115                                      kMaxExponentLength - first_char_pos);</span>
116 }
<a name="8" id="anc8"></a><span class="line-modified">117     </span>
<span class="line-modified">118     </span>
119 void DoubleToStringConverter::CreateDecimalRepresentation(
<a name="9" id="anc9"></a><span class="line-modified">120                                                               const char* decimal_digits,</span>
<span class="line-modified">121                                                               int length,</span>
<span class="line-modified">122                                                               int decimal_point,</span>
<span class="line-modified">123                                                               int digits_after_point,</span>
<span class="line-modified">124                                                               StringBuilder* result_builder) const {</span>
<span class="line-modified">125         // Create a representation that is padded with zeros if needed.</span>
<span class="line-modified">126         if (decimal_point &lt;= 0) {</span>
127       // &quot;0.00000decimal_rep&quot; or &quot;0.000decimal_rep00&quot;.
<a name="10" id="anc10"></a><span class="line-modified">128             result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">129             if (digits_after_point &gt; 0) {</span>
<span class="line-modified">130                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">131                 result_builder-&gt;AddPadding(&#39;0&#39;, -decimal_point);</span>
<span class="line-modified">132                 ASSERT(length &lt;= digits_after_point - (-decimal_point));</span>
<span class="line-modified">133                 result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">134                 int remaining_digits = digits_after_point - (-decimal_point) - length;</span>
<span class="line-modified">135                 result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">136             }</span>
<span class="line-modified">137         } else if (decimal_point &gt;= length) {</span>
138     // &quot;decimal_rep0000.00000&quot; or &quot;decimal_rep.0000&quot;.
<a name="11" id="anc11"></a><span class="line-modified">139             result_builder-&gt;AddSubstring(decimal_digits, length);</span>
<span class="line-modified">140             result_builder-&gt;AddPadding(&#39;0&#39;, decimal_point - length);</span>
<span class="line-modified">141             if (digits_after_point &gt; 0) {</span>
<span class="line-modified">142                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">143                 result_builder-&gt;AddPadding(&#39;0&#39;, digits_after_point);</span>
<span class="line-modified">144             }</span>
<span class="line-modified">145         } else {</span>
146     // &quot;decima.l_rep000&quot;.
<a name="12" id="anc12"></a><span class="line-modified">147             ASSERT(digits_after_point &gt; 0);</span>
<span class="line-modified">148             result_builder-&gt;AddSubstring(decimal_digits, decimal_point);</span>
<span class="line-modified">149             result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">150             ASSERT(length - decimal_point &lt;= digits_after_point);</span>
<span class="line-modified">151             result_builder-&gt;AddSubstring(&amp;decimal_digits[decimal_point],</span>
<span class="line-modified">152                                          length - decimal_point);</span>
<span class="line-modified">153             int remaining_digits = digits_after_point - (length - decimal_point);</span>
<span class="line-modified">154             result_builder-&gt;AddPadding(&#39;0&#39;, remaining_digits);</span>
<span class="line-modified">155         }</span>
<span class="line-modified">156         if (digits_after_point == 0) {</span>
<span class="line-modified">157             if ((flags_ &amp; EMIT_TRAILING_DECIMAL_POINT) != 0) {</span>
<span class="line-modified">158                 result_builder-&gt;AddCharacter(&#39;.&#39;);</span>
<span class="line-modified">159             }</span>
<span class="line-modified">160             if ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {</span>
<span class="line-modified">161                 result_builder-&gt;AddCharacter(&#39;0&#39;);</span>
<span class="line-modified">162             }</span>
<span class="line-modified">163         }</span>
164 }
<a name="13" id="anc13"></a><span class="line-modified">165     </span>
<span class="line-modified">166     </span>
167 bool DoubleToStringConverter::ToShortestIeeeNumber(
168     double value,
169     StringBuilder* result_builder,
170     DoubleToStringConverter::DtoaMode mode) const {
171   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);
<a name="14" id="anc14"></a><span class="line-modified">172         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">173             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">174         }</span>
<span class="line-modified">175         </span>
<span class="line-modified">176         int decimal_point;</span>
<span class="line-modified">177         bool sign;</span>
<span class="line-modified">178         const int kDecimalRepCapacity = kBase10MaximalLength + 1;</span>
<span class="line-modified">179         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">180         int decimal_rep_length;</span>
<span class="line-modified">181         </span>
182   DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,
<a name="15" id="anc15"></a><span class="line-modified">183                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">184         </span>
<span class="line-modified">185         bool unique_zero = (flags_ &amp; UNIQUE_ZERO) != 0;</span>
<span class="line-modified">186         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">187             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">188         }</span>
<span class="line-modified">189         </span>
<span class="line-modified">190         int exponent = decimal_point - 1;</span>
<span class="line-modified">191         if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;</span>
<span class="line-modified">192             (exponent &lt; decimal_in_shortest_high_)) {</span>
<span class="line-modified">193             CreateDecimalRepresentation(decimal_rep, decimal_rep_length,</span>
<span class="line-modified">194                                         decimal_point,</span>
<span class="line-modified">195                                         Max(0, decimal_rep_length - decimal_point),</span>
<span class="line-modified">196                                         result_builder);</span>
<span class="line-modified">197         } else {</span>
<span class="line-modified">198             CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,</span>
<span class="line-modified">199                                             result_builder);</span>
<span class="line-modified">200         }</span>
<span class="line-modified">201         return true;</span>
202 }
<a name="16" id="anc16"></a><span class="line-modified">203     </span>
<span class="line-modified">204     </span>
205 bool DoubleToStringConverter::ToFixed(double value,
<a name="17" id="anc17"></a><span class="line-modified">206                                           int requested_digits,</span>
<span class="line-modified">207                                           StringBuilder* result_builder) const {</span>
<span class="line-modified">208         ASSERT(kMaxFixedDigitsBeforePoint == 60);</span>
<span class="line-modified">209         const double kFirstNonFixed = 1e60;</span>
<span class="line-modified">210         </span>
<span class="line-modified">211         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">212             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">213         }</span>
<span class="line-modified">214         </span>
<span class="line-modified">215         if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;</span>
<span class="line-modified">216         if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;</span>
<span class="line-modified">217         </span>
<span class="line-modified">218         // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">219         int decimal_point;</span>
<span class="line-modified">220         bool sign;</span>
<span class="line-modified">221         // Add space for the &#39;\0&#39; byte.</span>
<span class="line-modified">222         const int kDecimalRepCapacity =</span>
<span class="line-modified">223         kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;</span>
<span class="line-modified">224         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">225         int decimal_rep_length;</span>
<span class="line-modified">226         DoubleToAscii(value, FIXED, requested_digits,</span>
<span class="line-modified">227                       decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">228                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">229         </span>
<span class="line-modified">230         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">231         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">232             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">233         }</span>
<span class="line-modified">234         </span>
<span class="line-modified">235         CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">236                                     requested_digits, result_builder);</span>
<span class="line-modified">237         return true;</span>
238 }
<a name="18" id="anc18"></a><span class="line-modified">239     </span>
<span class="line-modified">240     </span>
241 bool DoubleToStringConverter::ToExponential(
<a name="19" id="anc19"></a><span class="line-modified">242                                                 double value,</span>
<span class="line-modified">243                                                 int requested_digits,</span>
<span class="line-modified">244                                                 StringBuilder* result_builder) const {</span>
<span class="line-modified">245         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">246             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">247         }</span>
<span class="line-modified">248         </span>
<span class="line-modified">249         if (requested_digits &lt; -1) return false;</span>
<span class="line-modified">250         if (requested_digits &gt; kMaxExponentialDigits) return false;</span>
<span class="line-modified">251         </span>
<span class="line-modified">252         int decimal_point;</span>
<span class="line-modified">253         bool sign;</span>
<span class="line-modified">254         // Add space for digit before the decimal point and the &#39;\0&#39; character.</span>
<span class="line-modified">255         const int kDecimalRepCapacity = kMaxExponentialDigits + 2;</span>
<span class="line-modified">256         ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);</span>
<span class="line-modified">257         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">258         int decimal_rep_length;</span>
<span class="line-modified">259         </span>
<span class="line-modified">260         if (requested_digits == -1) {</span>
<span class="line-modified">261             DoubleToAscii(value, SHORTEST, 0,</span>
<span class="line-modified">262                           decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">263                           &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">264         } else {</span>
<span class="line-modified">265             DoubleToAscii(value, PRECISION, requested_digits + 1,</span>
<span class="line-modified">266                           decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">267                           &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">268             ASSERT(decimal_rep_length &lt;= requested_digits + 1);</span>
<span class="line-modified">269             </span>
<span class="line-modified">270             for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {</span>
<span class="line-modified">271                 decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">272             }</span>
<span class="line-modified">273             decimal_rep_length = requested_digits + 1;</span>
<span class="line-modified">274         }</span>
<span class="line-modified">275         </span>
<span class="line-modified">276         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">277         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">278             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">279         }</span>
<span class="line-modified">280         </span>
<span class="line-modified">281         int exponent = decimal_point - 1;</span>
<span class="line-modified">282         CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">283                                         decimal_rep_length,</span>
<span class="line-modified">284                                         exponent,</span>
<span class="line-modified">285                                         result_builder);</span>
<span class="line-modified">286         return true;</span>
287 }
<a name="20" id="anc20"></a><span class="line-modified">288     </span>
<span class="line-modified">289     </span>
290 bool DoubleToStringConverter::ToPrecision(double value,
<a name="21" id="anc21"></a><span class="line-modified">291                                               int precision,</span>
<span class="line-modified">292                                               StringBuilder* result_builder) const {</span>
<span class="line-modified">293         if (Double(value).IsSpecial()) {</span>
<span class="line-modified">294             return HandleSpecialValues(value, result_builder);</span>
<span class="line-modified">295         }</span>
<span class="line-modified">296         </span>
<span class="line-modified">297         if (precision &lt; kMinPrecisionDigits || precision &gt; kMaxPrecisionDigits) {</span>
<span class="line-modified">298             return false;</span>
<span class="line-modified">299         }</span>
<span class="line-modified">300         </span>
<span class="line-modified">301         // Find a sufficiently precise decimal representation of n.</span>
<span class="line-modified">302         int decimal_point;</span>
<span class="line-modified">303         bool sign;</span>
<span class="line-modified">304         // Add one for the terminating null character.</span>
<span class="line-modified">305         const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;</span>
<span class="line-modified">306         char decimal_rep[kDecimalRepCapacity];</span>
<span class="line-modified">307         int decimal_rep_length;</span>
<span class="line-modified">308         </span>
<span class="line-modified">309         DoubleToAscii(value, PRECISION, precision,</span>
<span class="line-modified">310                       decimal_rep, kDecimalRepCapacity,</span>
<span class="line-modified">311                       &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);</span>
<span class="line-modified">312         ASSERT(decimal_rep_length &lt;= precision);</span>
<span class="line-modified">313         </span>
<span class="line-modified">314         bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);</span>
<span class="line-modified">315         if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {</span>
<span class="line-modified">316             result_builder-&gt;AddCharacter(&#39;-&#39;);</span>
<span class="line-modified">317         }</span>
<span class="line-modified">318         </span>
<span class="line-modified">319         // The exponent if we print the number as x.xxeyyy. That is with the</span>
<span class="line-modified">320         // decimal point after the first digit.</span>
<span class="line-modified">321         int exponent = decimal_point - 1;</span>
<span class="line-modified">322         </span>
<span class="line-modified">323         int extra_zero = ((flags_ &amp; EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;</span>
<span class="line-modified">324         if ((-decimal_point + 1 &gt; max_leading_padding_zeroes_in_precision_mode_) ||</span>
<span class="line-modified">325             (decimal_point - precision + extra_zero &gt;</span>
<span class="line-modified">326              max_trailing_padding_zeroes_in_precision_mode_)) {</span>
<span class="line-modified">327                 // Fill buffer to contain &#39;precision&#39; digits.</span>
<span class="line-modified">328                 // Usually the buffer is already at the correct length, but &#39;DoubleToAscii&#39;</span>
<span class="line-modified">329                 // is allowed to return less characters.</span>
<span class="line-modified">330                 for (int i = decimal_rep_length; i &lt; precision; ++i) {</span>
<span class="line-modified">331                     decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-modified">332                 }</span>
<span class="line-modified">333                 </span>
<span class="line-modified">334                 CreateExponentialRepresentation(decimal_rep,</span>
<span class="line-modified">335                                                 precision,</span>
<span class="line-modified">336                                                 exponent,</span>
<span class="line-modified">337                                                 result_builder);</span>
<span class="line-modified">338             } else {</span>
<span class="line-modified">339                 CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,</span>
<span class="line-modified">340                                             Max(0, precision - decimal_point),</span>
<span class="line-modified">341                                             result_builder);</span>
<span class="line-modified">342             }</span>
<span class="line-modified">343         return true;</span>
344 }
<a name="22" id="anc22"></a><span class="line-modified">345     </span>
<span class="line-modified">346     </span>
347 static BignumDtoaMode DtoaToBignumDtoaMode(
<a name="23" id="anc23"></a><span class="line-modified">348                                                DoubleToStringConverter::DtoaMode dtoa_mode) {</span>
<span class="line-modified">349         switch (dtoa_mode) {</span>
<span class="line-modified">350             case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;</span>
351     case DoubleToStringConverter::SHORTEST_SINGLE:
352         return BIGNUM_DTOA_SHORTEST_SINGLE;
<a name="24" id="anc24"></a><span class="line-modified">353             case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;</span>
<span class="line-modified">354             case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;</span>
<span class="line-modified">355             default:</span>
<span class="line-modified">356                 UNREACHABLE();</span>
<span class="line-modified">357     }</span>
358 }
<a name="25" id="anc25"></a><span class="line-modified">359     </span>
<span class="line-modified">360     </span>
361 void DoubleToStringConverter::DoubleToAscii(double v,
<a name="26" id="anc26"></a><span class="line-modified">362                                                 DtoaMode mode,</span>
<span class="line-modified">363                                                 int requested_digits,</span>
<span class="line-modified">364                                                 char* buffer,</span>
<span class="line-modified">365                                                 int buffer_length,</span>
<span class="line-modified">366                                                 bool* sign,</span>
<span class="line-modified">367                                                 int* length,</span>
<span class="line-modified">368                                                 int* point) {</span>
369   BufferReference&lt;char&gt; bufferReference(buffer, buffer_length);
<a name="27" id="anc27"></a><span class="line-modified">370         ASSERT(!Double(v).IsSpecial());</span>
371   ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits &gt;= 0);
<a name="28" id="anc28"></a><span class="line-modified">372         </span>
<span class="line-modified">373         if (Double(v).Sign() &lt; 0) {</span>
<span class="line-modified">374             *sign = true;</span>
<span class="line-modified">375             v = -v;</span>
<span class="line-modified">376         } else {</span>
<span class="line-modified">377             *sign = false;</span>
<span class="line-modified">378         }</span>
<span class="line-modified">379         </span>
<span class="line-modified">380         if (mode == PRECISION &amp;&amp; requested_digits == 0) {</span>
381     bufferReference[0] = &#39;\0&#39;;
<a name="29" id="anc29"></a><span class="line-modified">382             *length = 0;</span>
<span class="line-modified">383             return;</span>
<span class="line-modified">384         }</span>
<span class="line-modified">385         </span>
<span class="line-modified">386         if (v == 0) {</span>
387     bufferReference[0] = &#39;0&#39;;
388     bufferReference[1] = &#39;\0&#39;;
<a name="30" id="anc30"></a><span class="line-modified">389             *length = 1;</span>
<span class="line-modified">390             *point = 1;</span>
<span class="line-modified">391             return;</span>
<span class="line-modified">392         }</span>
<span class="line-modified">393         </span>
<span class="line-modified">394         bool fast_worked;</span>
<span class="line-modified">395         switch (mode) {</span>
<span class="line-modified">396             case SHORTEST:</span>
397       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, bufferReference, length, point);
398       break;
399     case SHORTEST_SINGLE:
400       fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,
401                              bufferReference, length, point);
<a name="31" id="anc31"></a><span class="line-modified">402                 break;</span>
<span class="line-modified">403             case FIXED:</span>
404       fast_worked = FastFixedDtoa(v, requested_digits, bufferReference, length, point);
<a name="32" id="anc32"></a><span class="line-modified">405                 break;</span>
<span class="line-modified">406             case PRECISION:</span>
<span class="line-modified">407                 fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,</span>
408                              bufferReference, length, point);
<a name="33" id="anc33"></a><span class="line-modified">409                 break;</span>
<span class="line-modified">410             default:</span>
<span class="line-modified">411                 fast_worked = false;</span>
412       UNREACHABLE();
<a name="34" id="anc34"></a><span class="line-modified">413         }</span>
<span class="line-modified">414         if (fast_worked) return;</span>
<span class="line-modified">415         </span>
<span class="line-modified">416         // If the fast dtoa didn&#39;t succeed use the slower bignum version.</span>
<span class="line-modified">417         BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);</span>
418   BignumDtoa(v, bignum_mode, requested_digits, bufferReference, length, point);
419   bufferReference[*length] = &#39;\0&#39;;
420 }
421 
422 // Maximum number of significant digits in decimal representation.
423 // The longest possible double in decimal representation is
424 // (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074
425 // (768 digits). If we parse a number whose first digits are equal to a
426 // mean of 2 adjacent doubles (that could have up to 769 digits) the result
427 // must be rounded to the bigger one unless the tail consists of zeros, so
428 // we don&#39;t need to preserve all the digits.
429 const int kMaxSignificantDigits = 772;
<a name="35" id="anc35"></a><span class="line-modified">430     </span>
<span class="line-modified">431     </span>
432 static double SignedZero(bool sign) {
<a name="36" id="anc36"></a><span class="line-modified">433         return sign ? -0.0 : 0.0;</span>
434 }
<a name="37" id="anc37"></a><span class="line-modified">435     </span>
<span class="line-modified">436     </span>
437 // Returns true, when the iterator is equal to end.
438 template&lt;class Iterator&gt;
439 static inline bool Advance(Iterator* it, Iterator&amp; end) {
440   ++(*it);
441   return *it == end;
442 }
443 
444 template &lt;typename FloatingPointType&gt;
445 inline FloatingPointType StringToFloatingPointType(BufferReference&lt;const char&gt; buffer, int exponent);
446 
447 template &lt;&gt;
448 inline double StringToFloatingPointType&lt;double&gt;(BufferReference&lt;const char&gt; buffer, int exponent) {
449   return Strtod(buffer, exponent);
450 }
451 
452 template &lt;&gt;
453 inline float StringToFloatingPointType&lt;float&gt;(BufferReference&lt;const char&gt; buffer, int exponent) {
454   return Strtof(buffer, exponent);
455 }
456 
457 template &lt;typename FloatingPointType, class Iterator&gt;
458 static FloatingPointType StringToIeee(
459     Iterator input,
<a name="38" id="anc38"></a><span class="line-modified">460                                                    size_t length,</span>
<span class="line-modified">461                                                    size_t* processed_characters_count) {</span>
462   static_assert(std::is_floating_point&lt;FloatingPointType&gt;::value, &quot;Only floating point types are allowed.&quot;);
463 
464   Iterator current = input;
465   Iterator end = input + length;
<a name="39" id="anc39"></a><span class="line-modified">466         </span>
<span class="line-modified">467         *processed_characters_count = 0;</span>
<span class="line-modified">468         </span>
<span class="line-modified">469         // To make sure that iterator dereferencing is valid the following</span>
<span class="line-modified">470         // convention is used:</span>
<span class="line-modified">471         // 1. Each &#39;++current&#39; statement is followed by check for equality to &#39;end&#39;.</span>
<span class="line-modified">472         // 3. If &#39;current&#39; becomes equal to &#39;end&#39; the function returns or goes to</span>
<span class="line-modified">473         // &#39;parsing_done&#39;.</span>
<span class="line-modified">474         // 4. &#39;current&#39; is not dereferenced after the &#39;parsing_done&#39; label.</span>
<span class="line-modified">475         // 5. Code before &#39;parsing_done&#39; may rely on &#39;current != end&#39;.</span>
<span class="line-modified">476 </span>
<span class="line-modified">477         if (current == end) return 0.0;</span>
<span class="line-modified">478         </span>
<span class="line-modified">479         // The longest form of simplified number is: &quot;-&lt;significant digits&gt;.1eXXX\0&quot;.</span>
480   const int kBufferSize = kMaxSignificantDigits + 10;
<a name="40" id="anc40"></a><span class="line-modified">481         char buffer[kBufferSize];  // NOLINT: size is known at compile time.</span>
482   int buffer_pos = 0;
<a name="41" id="anc41"></a><span class="line-modified">483         </span>
<span class="line-modified">484         // Exponent will be adjusted if insignificant digits of the integer part</span>
<span class="line-modified">485         // or insignificant leading zeros of the fractional part are dropped.</span>
<span class="line-modified">486         int exponent = 0;</span>
<span class="line-modified">487         int significant_digits = 0;</span>
<span class="line-modified">488         int insignificant_digits = 0;</span>
<span class="line-modified">489         bool nonzero_digit_dropped = false;</span>
<span class="line-modified">490 </span>
<span class="line-modified">491         bool sign = false;</span>
<span class="line-modified">492         </span>
<span class="line-modified">493         if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
<span class="line-modified">494             sign = (*current == &#39;-&#39;);</span>
<span class="line-modified">495             ++current;</span>
<span class="line-modified">496             if (current == end) return 0.0;</span>
<span class="line-modified">497         }</span>
<span class="line-modified">498         </span>
<span class="line-modified">499         bool leading_zero = false;</span>
<span class="line-modified">500         if (*current == &#39;0&#39;) {</span>
501     if (Advance(&amp;current, end)) {
502       *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<a name="42" id="anc42"></a><span class="line-modified">503                 return SignedZero(sign);</span>
<span class="line-modified">504             }</span>
<span class="line-modified">505             </span>
<span class="line-modified">506             leading_zero = true;</span>
<span class="line-modified">507             </span>
<span class="line-modified">508             // Ignore leading zeros in the integer part.</span>
<span class="line-modified">509             while (*current == &#39;0&#39;) {</span>
510       if (Advance(&amp;current, end)) {
511         *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<a name="43" id="anc43"></a><span class="line-modified">512                     return SignedZero(sign);</span>
<span class="line-modified">513                 }</span>
<span class="line-modified">514             }</span>
<span class="line-modified">515         }</span>
<span class="line-modified">516         </span>
<span class="line-modified">517         // Copy significant digits of the integer part (if any) to the buffer.</span>
<span class="line-modified">518         while (isASCIIDigit(*current)) {</span>
<span class="line-modified">519             if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">520                 ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">521                 buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">522                 significant_digits++;</span>
<span class="line-modified">523             } else {</span>
<span class="line-modified">524                 insignificant_digits++;  // Move the digit into the exponential part.</span>
<span class="line-modified">525                 nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">526             }</span>
527     if (Advance(&amp;current, end)) goto parsing_done;
<a name="44" id="anc44"></a><span class="line-modified">528         }</span>
<span class="line-modified">529         </span>
<span class="line-modified">530         if (*current == &#39;.&#39;) {</span>
531     if (Advance(&amp;current, end)) {
<a name="45" id="anc45"></a><span class="line-modified">532                 if (significant_digits == 0 &amp;&amp; !leading_zero) {</span>
<span class="line-modified">533                     return 0.0;</span>
<span class="line-modified">534                 } else {</span>
<span class="line-modified">535                     goto parsing_done;</span>
<span class="line-modified">536                 }</span>
<span class="line-modified">537             }</span>
<span class="line-modified">538             </span>
<span class="line-modified">539             if (significant_digits == 0) {</span>
<span class="line-modified">540                 // Integer part consists of 0 or is absent. Significant digits start after</span>
<span class="line-modified">541                 // leading zeros (if any).</span>
<span class="line-modified">542                 while (*current == &#39;0&#39;) {</span>
543         if (Advance(&amp;current, end)) {
544           *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<a name="46" id="anc46"></a><span class="line-modified">545                         return SignedZero(sign);</span>
<span class="line-modified">546                     }</span>
<span class="line-modified">547                     exponent--;  // Move this 0 into the exponent.</span>
<span class="line-modified">548                 }</span>
<span class="line-modified">549             }</span>
550 
<a name="47" id="anc47"></a><span class="line-modified">551             // There is a fractional part.</span>
552     // We don&#39;t emit a &#39;.&#39;, but adjust the exponent instead.
<a name="48" id="anc48"></a><span class="line-modified">553             while (isASCIIDigit(*current)) {</span>
<span class="line-modified">554                 if (significant_digits &lt; kMaxSignificantDigits) {</span>
<span class="line-modified">555                     ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">556                     buffer[buffer_pos++] = static_cast&lt;char&gt;(*current);</span>
<span class="line-modified">557                     significant_digits++;</span>
<span class="line-modified">558                     exponent--;</span>
<span class="line-modified">559                 } else {</span>
<span class="line-modified">560                     // Ignore insignificant digits in the fractional part.</span>
<span class="line-modified">561                     nonzero_digit_dropped = nonzero_digit_dropped || *current != &#39;0&#39;;</span>
<span class="line-modified">562                 }</span>
563       if (Advance(&amp;current, end)) goto parsing_done;
<a name="49" id="anc49"></a><span class="line-modified">564             }</span>
<span class="line-modified">565         }</span>
<span class="line-modified">566         </span>
<span class="line-modified">567         if (!leading_zero &amp;&amp; exponent == 0 &amp;&amp; significant_digits == 0) {</span>
<span class="line-modified">568             // If leading_zeros is true then the string contains zeros.</span>
<span class="line-modified">569             // If exponent &lt; 0 then string was [+-]\.0*...</span>
<span class="line-modified">570             // If significant_digits != 0 the string is not equal to 0.</span>
<span class="line-modified">571             // Otherwise there are no digits in the string.</span>
<span class="line-modified">572             return 0.0;</span>
<span class="line-modified">573         }</span>
<span class="line-modified">574         </span>
<span class="line-modified">575         // Parse exponential part.</span>
<span class="line-modified">576         if (*current == &#39;e&#39; || *current == &#39;E&#39;) {</span>
<span class="line-modified">577             ++current;</span>
<span class="line-modified">578             if (current == end) {</span>
<span class="line-modified">579                 --current;</span>
<span class="line-modified">580                 goto parsing_done;</span>
<span class="line-modified">581             }</span>
582     char exponen_sign = 0;
<a name="50" id="anc50"></a><span class="line-modified">583             if (*current == &#39;+&#39; || *current == &#39;-&#39;) {</span>
584       exponen_sign = static_cast&lt;char&gt;(*current);
<a name="51" id="anc51"></a><span class="line-modified">585                 ++current;</span>
<span class="line-modified">586                 if (current == end) {</span>
<span class="line-modified">587                     current -= 2;</span>
<span class="line-modified">588                     goto parsing_done;</span>
<span class="line-modified">589                 }</span>
<span class="line-modified">590             }</span>
<span class="line-modified">591             </span>
<span class="line-modified">592             if (*current &lt; &#39;0&#39; || *current &gt; &#39;9&#39;) {</span>
593       if (exponen_sign)
<a name="52" id="anc52"></a><span class="line-modified">594                     --current;</span>
<span class="line-modified">595                 --current;</span>
<span class="line-modified">596                 goto parsing_done;</span>
<span class="line-modified">597             }</span>
<span class="line-modified">598             </span>
<span class="line-modified">599             const int max_exponent = INT_MAX / 2;</span>
<span class="line-modified">600             ASSERT(-max_exponent / 2 &lt;= exponent &amp;&amp; exponent &lt;= max_exponent / 2);</span>
<span class="line-modified">601             int num = 0;</span>
<span class="line-modified">602             do {</span>
<span class="line-modified">603                 // Check overflow.</span>
<span class="line-modified">604                 int digit = *current - &#39;0&#39;;</span>
<span class="line-modified">605                 if (num &gt;= max_exponent / 10</span>
<span class="line-modified">606                     &amp;&amp; !(num == max_exponent / 10 &amp;&amp; digit &lt;= max_exponent % 10)) {</span>
<span class="line-modified">607                     num = max_exponent;</span>
<span class="line-modified">608                 } else {</span>
<span class="line-modified">609                     num = num * 10 + digit;</span>
<span class="line-modified">610                 }</span>
<span class="line-modified">611                 ++current;</span>
<span class="line-modified">612             } while (current != end &amp;&amp; isASCIIDigit(*current));</span>
<span class="line-modified">613             </span>
614     exponent += (exponen_sign == &#39;-&#39; ? -num : num);
<a name="53" id="anc53"></a><span class="line-modified">615         }</span>
<span class="line-modified">616         </span>
<span class="line-modified">617     parsing_done:</span>
<span class="line-modified">618         exponent += insignificant_digits;</span>
<span class="line-modified">619         </span>
<span class="line-modified">620         if (nonzero_digit_dropped) {</span>
<span class="line-modified">621             buffer[buffer_pos++] = &#39;1&#39;;</span>
<span class="line-modified">622             exponent--;</span>
<span class="line-modified">623         }</span>
<span class="line-modified">624         </span>
<span class="line-modified">625         ASSERT(buffer_pos &lt; kBufferSize);</span>
<span class="line-modified">626         buffer[buffer_pos] = &#39;\0&#39;;</span>
<span class="line-modified">627         </span>
628   auto converted = StringToFloatingPointType&lt;FloatingPointType&gt;(BufferReference&lt;const char&gt;(buffer, buffer_pos), exponent);
629   *processed_characters_count = static_cast&lt;size_t&gt;(current - input);
<a name="54" id="anc54"></a><span class="line-modified">630         return sign? -converted: converted;</span>
631 }
632 
633 double StringToDoubleConverter::StringToDouble(
634     const char* buffer,
635     size_t length,
636     size_t* processed_characters_count) {
637   return StringToIeee&lt;double&gt;(buffer, length, processed_characters_count);
638 }
<a name="55" id="anc55"></a><span class="line-modified">639     </span>
640 
641 double StringToDoubleConverter::StringToDouble(
642     const uc16* buffer,
643     size_t length,
644     size_t* processed_characters_count) {
645   return StringToIeee&lt;double&gt;(buffer, length, processed_characters_count);
646 }
647 
648 
649 float StringToDoubleConverter::StringToFloat(
650     const char* buffer,
651     size_t length,
652     size_t* processed_characters_count) {
653   return StringToIeee&lt;float&gt;(buffer, length, processed_characters_count);
654 }
655 
656 
657 float StringToDoubleConverter::StringToFloat(
658     const uc16* buffer,
659     size_t length,
660     size_t* processed_characters_count) {
661   return StringToIeee&lt;float&gt;(buffer, length, processed_characters_count);
662 }
663 
664 }  // namespace double_conversion
<a name="56" id="anc56"></a><span class="line-modified">665 } // namespace WTF</span>
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>