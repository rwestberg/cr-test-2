<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/win/PasteboardWin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006, 2007, 2013-2014 Apple Inc.  All rights reserved.
   3  * Copyright (C) 2013 Xueqing Huang &lt;huangxueqing@baidu.com&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Pasteboard.h&quot;
  29 
  30 #include &quot;BitmapInfo.h&quot;
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;ClipboardUtilitiesWin.h&quot;
  33 #include &quot;Color.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;Editor.h&quot;
  37 #include &quot;Element.h&quot;
  38 #include &quot;Frame.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;HTMLParserIdioms.h&quot;
  41 #include &quot;HWndDC.h&quot;
  42 #include &quot;HitTestResult.h&quot;
  43 #include &quot;Image.h&quot;
  44 #include &quot;NotImplemented.h&quot;
  45 #include &quot;Range.h&quot;
  46 #include &quot;RenderImage.h&quot;
  47 #include &quot;SharedBuffer.h&quot;
  48 #include &quot;TextEncoding.h&quot;
  49 #include &quot;WebCoreInstanceHandle.h&quot;
  50 #include &quot;markup.h&quot;
  51 #include &lt;wtf/URL.h&gt;
  52 #include &lt;wtf/WindowsExtras.h&gt;
  53 #include &lt;wtf/text/CString.h&gt;
  54 #include &lt;wtf/text/StringView.h&gt;
  55 #include &lt;wtf/text/win/WCharStringExtras.h&gt;
  56 #include &lt;wtf/win/GDIObject.h&gt;
  57 
  58 namespace WebCore {
  59 
  60 // We provide the IE clipboard types (URL and Text), and the clipboard types specified in the WHATWG Web Applications 1.0 draft
  61 // see http://www.whatwg.org/specs/web-apps/current-work/ Section 6.3.5.3
  62 
  63 static UINT HTMLClipboardFormat = 0;
  64 static UINT BookmarkClipboardFormat = 0;
  65 static UINT WebSmartPasteFormat = 0;
  66 
  67 static LRESULT CALLBACK PasteboardOwnerWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
  68 {
  69     LRESULT lresult = 0;
  70 
  71     switch (message) {
  72     case WM_RENDERFORMAT:
  73         // This message comes when SetClipboardData was sent a null data handle
  74         // and now it&#39;s come time to put the data on the clipboard.
  75         break;
  76     case WM_RENDERALLFORMATS:
  77         // This message comes when SetClipboardData was sent a null data handle
  78         // and now this application is about to quit, so it must put data on
  79         // the clipboard before it exits.
  80         break;
  81     case WM_DESTROY:
  82         break;
  83     case WM_DRAWCLIPBOARD:
  84         break;
  85     case WM_CHANGECBCHAIN:
  86         break;
  87     default:
  88         lresult = DefWindowProc(hWnd, message, wParam, lParam);
  89         break;
  90     }
  91     return lresult;
  92 }
  93 
  94 std::unique_ptr&lt;Pasteboard&gt; Pasteboard::createForCopyAndPaste()
  95 {
  96     auto pasteboard = makeUnique&lt;Pasteboard&gt;();
  97     COMPtr&lt;IDataObject&gt; clipboardData;
  98     if (!SUCCEEDED(OleGetClipboard(&amp;clipboardData)))
  99         clipboardData = 0;
 100     pasteboard-&gt;setExternalDataObject(clipboardData.get());
 101     return pasteboard;
 102 }
 103 
 104 #if ENABLE(DRAG_SUPPORT)
 105 std::unique_ptr&lt;Pasteboard&gt; Pasteboard::createForDragAndDrop()
 106 {
 107     COMPtr&lt;WCDataObject&gt; dataObject;
 108     WCDataObject::createInstance(&amp;dataObject);
 109     return makeUnique&lt;Pasteboard&gt;(dataObject.get());
 110 }
 111 
 112 // static
 113 std::unique_ptr&lt;Pasteboard&gt; Pasteboard::createForDragAndDrop(const DragData&amp; dragData)
 114 {
 115     if (dragData.platformData())
 116         return makeUnique&lt;Pasteboard&gt;(dragData.platformData());
 117     // FIXME: Should add a const overload of dragDataMap so we don&#39;t need a const_cast here.
 118     return makeUnique&lt;Pasteboard&gt;(const_cast&lt;DragData&amp;&gt;(dragData).dragDataMap());
 119 }
 120 #endif
 121 
 122 void Pasteboard::finishCreatingPasteboard()
 123 {
 124     WNDCLASS wc;
 125     memset(&amp;wc, 0, sizeof(WNDCLASS));
 126     wc.lpfnWndProc    = PasteboardOwnerWndProc;
 127     wc.hInstance      = WebCore::instanceHandle();
 128     wc.lpszClassName  = L&quot;PasteboardOwnerWindowClass&quot;;
 129     RegisterClass(&amp;wc);
 130 
 131     m_owner = ::CreateWindow(L&quot;PasteboardOwnerWindowClass&quot;, L&quot;PasteboardOwnerWindow&quot;, 0, 0, 0, 0, 0,
 132         HWND_MESSAGE, 0, 0, 0);
 133 
 134     HTMLClipboardFormat = ::RegisterClipboardFormat(L&quot;HTML Format&quot;);
 135     BookmarkClipboardFormat = ::RegisterClipboardFormat(L&quot;UniformResourceLocatorW&quot;);
 136     WebSmartPasteFormat = ::RegisterClipboardFormat(L&quot;WebKit Smart Paste Format&quot;);
 137 }
 138 
 139 Pasteboard::Pasteboard()
 140     : m_dataObject(0)
 141     , m_writableDataObject(0)
 142 {
 143     finishCreatingPasteboard();
 144 }
 145 
 146 Pasteboard::Pasteboard(IDataObject* dataObject)
 147     : m_dataObject(dataObject)
 148     , m_writableDataObject(0)
 149 {
 150     finishCreatingPasteboard();
 151 }
 152 
 153 Pasteboard::Pasteboard(WCDataObject* dataObject)
 154     : m_dataObject(dataObject)
 155     , m_writableDataObject(dataObject)
 156 {
 157     finishCreatingPasteboard();
 158 }
 159 
 160 Pasteboard::Pasteboard(const DragDataMap&amp; dataMap)
 161     : m_dataObject(0)
 162     , m_writableDataObject(0)
 163     , m_dragDataMap(dataMap)
 164 {
 165     finishCreatingPasteboard();
 166 }
 167 
 168 void Pasteboard::clear()
 169 {
 170     if (::OpenClipboard(m_owner)) {
 171         ::EmptyClipboard();
 172         ::CloseClipboard();
 173     }
 174 }
 175 
 176 enum ClipboardDataType { ClipboardDataTypeNone, ClipboardDataTypeURL, ClipboardDataTypeText, ClipboardDataTypeTextHTML };
 177 
 178 static ClipboardDataType clipboardTypeFromMIMEType(const String&amp; type)
 179 {
 180     // two special cases for IE compatibility
 181     if (equalLettersIgnoringASCIICase(type, &quot;text/plain&quot;))
 182         return ClipboardDataTypeText;
 183     if (equalLettersIgnoringASCIICase(type, &quot;text/uri-list&quot;))
 184         return ClipboardDataTypeURL;
 185     if (equalLettersIgnoringASCIICase(type, &quot;text/html&quot;))
 186         return ClipboardDataTypeTextHTML;
 187 
 188     return ClipboardDataTypeNone;
 189 }
 190 
 191 void Pasteboard::clear(const String&amp; type)
 192 {
 193     if (!m_writableDataObject)
 194         return;
 195 
 196     ClipboardDataType dataType = clipboardTypeFromMIMEType(type);
 197 
 198     if (dataType == ClipboardDataTypeURL) {
 199         m_writableDataObject-&gt;clearData(urlWFormat()-&gt;cfFormat);
 200         m_writableDataObject-&gt;clearData(urlFormat()-&gt;cfFormat);
 201     }
 202     if (dataType == ClipboardDataTypeText) {
 203         m_writableDataObject-&gt;clearData(plainTextFormat()-&gt;cfFormat);
 204         m_writableDataObject-&gt;clearData(plainTextWFormat()-&gt;cfFormat);
 205     }
 206 }
 207 
 208 bool Pasteboard::hasData()
 209 {
 210     if (!m_dataObject &amp;&amp; m_dragDataMap.isEmpty())
 211         return false;
 212 
 213     if (m_dataObject) {
 214         COMPtr&lt;IEnumFORMATETC&gt; itr;
 215         if (FAILED(m_dataObject-&gt;EnumFormatEtc(DATADIR_GET, &amp;itr)))
 216             return false;
 217 
 218         if (!itr)
 219             return false;
 220 
 221         FORMATETC data;
 222 
 223         // IEnumFORMATETC::Next returns S_FALSE if there are no more items.
 224         if (itr-&gt;Next(1, &amp;data, 0) == S_OK) {
 225             // There is at least one item in the IDataObject
 226             return true;
 227         }
 228 
 229         return false;
 230     }
 231     return !m_dragDataMap.isEmpty();
 232 }
 233 
 234 static void addMimeTypesForFormat(ListHashSet&lt;String&gt;&amp; results, const FORMATETC&amp; format)
 235 {
 236     if (format.cfFormat == urlFormat()-&gt;cfFormat || format.cfFormat == urlWFormat()-&gt;cfFormat)
 237         results.add(&quot;text/uri-list&quot;);
 238     if (format.cfFormat == plainTextWFormat()-&gt;cfFormat || format.cfFormat == plainTextFormat()-&gt;cfFormat)
 239         results.add(&quot;text/plain&quot;);
 240 }
 241 
 242 Vector&lt;String&gt; Pasteboard::typesSafeForBindings(const String&amp;)
 243 {
 244     notImplemented();
 245     return { };
 246 }
 247 
 248 Vector&lt;String&gt; Pasteboard::typesForLegacyUnsafeBindings()
 249 {
 250     ListHashSet&lt;String&gt; results;
 251 
 252     if (!m_dataObject &amp;&amp; m_dragDataMap.isEmpty())
 253         return Vector&lt;String&gt;();
 254 
 255     if (m_dataObject) {
 256         COMPtr&lt;IEnumFORMATETC&gt; itr;
 257 
 258         if (FAILED(m_dataObject-&gt;EnumFormatEtc(DATADIR_GET, &amp;itr)))
 259             return Vector&lt;String&gt;();
 260 
 261         if (!itr)
 262             return Vector&lt;String&gt;();
 263 
 264         FORMATETC data;
 265 
 266         // IEnumFORMATETC::Next returns S_FALSE if there are no more items.
 267         while (itr-&gt;Next(1, &amp;data, 0) == S_OK)
 268             addMimeTypesForFormat(results, data);
 269     } else {
 270         for (DragDataMap::const_iterator it = m_dragDataMap.begin(); it != m_dragDataMap.end(); ++it) {
 271             FORMATETC data;
 272             data.cfFormat = (*it).key;
 273             addMimeTypesForFormat(results, data);
 274         }
 275     }
 276 
 277     return copyToVector(results);
 278 }
 279 
 280 String Pasteboard::readOrigin()
 281 {
 282     notImplemented();
 283     return { };
 284 }
 285 
 286 String Pasteboard::readString(const String&amp; type)
 287 {
 288     if (!m_dataObject &amp;&amp; m_dragDataMap.isEmpty())
 289         return &quot;&quot;;
 290 
 291     ClipboardDataType dataType = clipboardTypeFromMIMEType(type);
 292     if (dataType == ClipboardDataTypeText)
 293         return m_dataObject ? getPlainText(m_dataObject.get()) : getPlainText(&amp;m_dragDataMap);
 294     if (dataType == ClipboardDataTypeURL)
 295         return m_dataObject ? getURL(m_dataObject.get(), DragData::DoNotConvertFilenames) : getURL(&amp;m_dragDataMap, DragData::DoNotConvertFilenames);
 296     if (dataType == ClipboardDataTypeTextHTML) {
 297         String data = m_dataObject ? getTextHTML(m_dataObject.get()) : getTextHTML(&amp;m_dragDataMap);
 298         if (!data.isEmpty())
 299             return data;
 300         return m_dataObject ? getCFHTML(m_dataObject.get()) : getCFHTML(&amp;m_dragDataMap);
 301     }
 302 
 303     return &quot;&quot;;
 304 }
 305 
 306 String Pasteboard::readStringInCustomData(const String&amp;)
 307 {
 308     notImplemented();
 309     return { };
 310 }
 311 
 312 struct PasteboardFileCounter final : PasteboardFileReader {
 313     void readFilename(const String&amp;) final { ++count; }
 314     void readBuffer(const String&amp;, const String&amp;, Ref&lt;SharedBuffer&gt;&amp;&amp;) final { ++count; }
 315 
 316     unsigned count { 0 };
 317 };
 318 
 319 Pasteboard::FileContentState Pasteboard::fileContentState()
 320 {
 321     // FIXME: This implementation can be slightly more efficient by avoiding calls to DragQueryFileW.
 322     PasteboardFileCounter reader;
 323     read(reader);
 324     return reader.count ? FileContentState::MayContainFilePaths : FileContentState::NoFileOrImageData;
 325 }
 326 
 327 void Pasteboard::read(PasteboardFileReader&amp; reader)
 328 {
 329 #if USE(CF)
 330     if (m_dataObject) {
 331         STGMEDIUM medium;
 332         if (FAILED(m_dataObject-&gt;GetData(cfHDropFormat(), &amp;medium)))
 333             return;
 334 
 335         HDROP hdrop = reinterpret_cast&lt;HDROP&gt;(GlobalLock(medium.hGlobal));
 336         if (!hdrop)
 337             return;
 338 
 339         WCHAR filename[MAX_PATH];
 340         UINT fileCount = DragQueryFileW(hdrop, 0xFFFFFFFF, 0, 0);
 341         for (UINT i = 0; i &lt; fileCount; i++) {
 342             if (!DragQueryFileW(hdrop, i, filename, WTF_ARRAY_LENGTH(filename)))
 343                 continue;
 344             reader.readFilename(filename);
 345         }
 346 
 347         GlobalUnlock(medium.hGlobal);
 348         ReleaseStgMedium(&amp;medium);
 349         return;
 350     }
 351     auto list = m_dragDataMap.find(cfHDropFormat()-&gt;cfFormat);
 352     if (list == m_dragDataMap.end())
 353         return;
 354 
 355     for (auto&amp; filename : list-&gt;value)
 356         reader.readFilename(filename);
 357 #else
 358     UNUSED_PARAM(reader);
 359     notImplemented();
 360     return;
 361 #endif
 362 }
 363 
 364 static bool writeURL(WCDataObject *data, const URL&amp; url, String title, bool withPlainText, bool withHTML)
 365 {
 366     ASSERT(data);
 367 
 368     if (url.isEmpty())
 369         return false;
 370 
 371     if (title.isEmpty()) {
 372         title = url.lastPathComponent();
 373         if (title.isEmpty())
 374             title = url.host().toString();
 375     }
 376 
 377     STGMEDIUM medium { };
 378     medium.tymed = TYMED_HGLOBAL;
 379 
 380     medium.hGlobal = createGlobalData(url, title);
 381     bool success = false;
 382     if (medium.hGlobal &amp;&amp; FAILED(data-&gt;SetData(urlWFormat(), &amp;medium, TRUE)))
 383         ::GlobalFree(medium.hGlobal);
 384     else
 385         success = true;
 386 
 387     if (withHTML) {
 388         Vector&lt;char&gt; cfhtmlData;
 389         markupToCFHTML(urlToMarkup(url, title), &quot;&quot;, cfhtmlData);
 390         medium.hGlobal = createGlobalData(cfhtmlData);
 391         if (medium.hGlobal &amp;&amp; FAILED(data-&gt;SetData(htmlFormat(), &amp;medium, TRUE)))
 392             ::GlobalFree(medium.hGlobal);
 393         else
 394             success = true;
 395     }
 396 
 397     if (withPlainText) {
 398         medium.hGlobal = createGlobalData(url.string());
 399         if (medium.hGlobal &amp;&amp; FAILED(data-&gt;SetData(plainTextWFormat(), &amp;medium, TRUE)))
 400             ::GlobalFree(medium.hGlobal);
 401         else
 402             success = true;
 403     }
 404 
 405     return success;
 406 }
 407 
 408 void Pasteboard::writeString(const String&amp; type, const String&amp; data)
 409 {
 410     if (!m_writableDataObject)
 411         return;
 412 
 413     ClipboardDataType winType = clipboardTypeFromMIMEType(type);
 414 
 415     if (winType == ClipboardDataTypeURL) {
 416         WebCore::writeURL(m_writableDataObject.get(), URL(URL(), data), String(), false, true);
 417         return;
 418     }
 419 
 420     if (winType == ClipboardDataTypeText) {
 421         STGMEDIUM medium { };
 422         medium.tymed = TYMED_HGLOBAL;
 423         medium.hGlobal = createGlobalData(data);
 424         if (!medium.hGlobal)
 425             return;
 426 
 427         if (FAILED(m_writableDataObject-&gt;SetData(plainTextWFormat(), &amp;medium, TRUE)))
 428             ::GlobalFree(medium.hGlobal);
 429     }
 430 }
 431 
 432 #if ENABLE(DRAG_SUPPORT)
 433 void Pasteboard::setDragImage(DragImage, const IntPoint&amp;)
 434 {
 435     // Do nothing in Windows.
 436 }
 437 #endif
 438 
 439 void Pasteboard::writeRangeToDataObject(Range&amp; selectedRange, Frame&amp; frame)
 440 {
 441     if (!m_writableDataObject)
 442         return;
 443 
 444     STGMEDIUM medium { };
 445     medium.tymed = TYMED_HGLOBAL;
 446 
 447     Vector&lt;char&gt; data;
 448     markupToCFHTML(serializePreservingVisualAppearance(selectedRange, nullptr, AnnotateForInterchange::Yes),
 449         selectedRange.startContainer().document().url().string(), data);
 450     medium.hGlobal = createGlobalData(data);
 451     if (medium.hGlobal &amp;&amp; FAILED(m_writableDataObject-&gt;SetData(htmlFormat(), &amp;medium, TRUE)))
 452         ::GlobalFree(medium.hGlobal);
 453 
 454     String str = frame.editor().selectedTextForDataTransfer();
 455     replaceNewlinesWithWindowsStyleNewlines(str);
 456     replaceNBSPWithSpace(str);
 457     medium.hGlobal = createGlobalData(str);
 458     if (medium.hGlobal &amp;&amp; FAILED(m_writableDataObject-&gt;SetData(plainTextWFormat(), &amp;medium, TRUE)))
 459         ::GlobalFree(medium.hGlobal);
 460 
 461     medium.hGlobal = 0;
 462     if (frame.editor().canSmartCopyOrDelete())
 463         m_writableDataObject-&gt;SetData(smartPasteFormat(), &amp;medium, TRUE);
 464 }
 465 
 466 void Pasteboard::writeSelection(Range&amp; selectedRange, bool canSmartCopyOrDelete, Frame&amp; frame, ShouldSerializeSelectedTextForDataTransfer shouldSerializeSelectedTextForDataTransfer)
 467 {
 468     clear();
 469 
 470     // Put CF_HTML format on the pasteboard
 471     if (::OpenClipboard(m_owner)) {
 472         Vector&lt;char&gt; data;
 473         // FIXME: Use ResolveURLs::YesExcludingLocalFileURLsForPrivacy.
 474         markupToCFHTML(serializePreservingVisualAppearance(frame.selection().selection()),
 475             selectedRange.startContainer().document().url().string(), data);
 476         HGLOBAL cbData = createGlobalData(data);
 477         if (!::SetClipboardData(HTMLClipboardFormat, cbData))
 478             ::GlobalFree(cbData);
 479         ::CloseClipboard();
 480     }
 481 
 482     // Put plain string on the pasteboard. CF_UNICODETEXT covers CF_TEXT as well
 483     String str = shouldSerializeSelectedTextForDataTransfer == IncludeImageAltTextForDataTransfer ? frame.editor().selectedTextForDataTransfer() : frame.editor().selectedText();
 484     replaceNewlinesWithWindowsStyleNewlines(str);
 485     replaceNBSPWithSpace(str);
 486     if (::OpenClipboard(m_owner)) {
 487         HGLOBAL cbData = createGlobalData(str);
 488         if (!::SetClipboardData(CF_UNICODETEXT, cbData))
 489             ::GlobalFree(cbData);
 490         ::CloseClipboard();
 491     }
 492 
 493     // enable smart-replacing later on by putting dummy data on the pasteboard
 494     if (canSmartCopyOrDelete) {
 495         if (::OpenClipboard(m_owner)) {
 496             ::SetClipboardData(WebSmartPasteFormat, 0);
 497             ::CloseClipboard();
 498         }
 499     }
 500 
 501     writeRangeToDataObject(selectedRange, frame);
 502 }
 503 
 504 void Pasteboard::writePlainTextToDataObject(const String&amp; text, SmartReplaceOption smartReplaceOption)
 505 {
 506     if (!m_writableDataObject)
 507         return;
 508 
 509     STGMEDIUM medium { };
 510     medium.tymed = TYMED_HGLOBAL;
 511 
 512     String str = text;
 513     replaceNewlinesWithWindowsStyleNewlines(str);
 514     replaceNBSPWithSpace(str);
 515     medium.hGlobal = createGlobalData(str);
 516     if (medium.hGlobal &amp;&amp; FAILED(m_writableDataObject-&gt;SetData(plainTextWFormat(), &amp;medium, TRUE)))
 517         ::GlobalFree(medium.hGlobal);
 518 }
 519 
 520 void Pasteboard::writePlainText(const String&amp; text, SmartReplaceOption smartReplaceOption)
 521 {
 522     clear();
 523 
 524     // Put plain string on the pasteboard. CF_UNICODETEXT covers CF_TEXT as well
 525     String str = text;
 526     replaceNewlinesWithWindowsStyleNewlines(str);
 527     if (::OpenClipboard(m_owner)) {
 528         HGLOBAL cbData = createGlobalData(str);
 529         if (!::SetClipboardData(CF_UNICODETEXT, cbData))
 530             ::GlobalFree(cbData);
 531         ::CloseClipboard();
 532     }
 533 
 534     // enable smart-replacing later on by putting dummy data on the pasteboard
 535     if (smartReplaceOption == CanSmartReplace) {
 536         if (::OpenClipboard(m_owner)) {
 537             ::SetClipboardData(WebSmartPasteFormat, 0);
 538             ::CloseClipboard();
 539         }
 540     }
 541 
 542     writePlainTextToDataObject(text, smartReplaceOption);
 543 }
 544 
 545 static inline void pathRemoveBadFSCharacters(PWSTR psz, size_t length)
 546 {
 547     size_t writeTo = 0;
 548     size_t readFrom = 0;
 549     while (readFrom &lt; length) {
 550         UINT type = PathGetCharType(psz[readFrom]);
 551         if (!psz[readFrom] || type &amp; (GCT_LFNCHAR | GCT_SHORTCHAR))
 552             psz[writeTo++] = psz[readFrom];
 553 
 554         readFrom++;
 555     }
 556     psz[writeTo] = 0;
 557 }
 558 
 559 static String filesystemPathFromUrlOrTitle(const String&amp; url, const String&amp; title, const String&amp; extension, bool isLink)
 560 {
 561     static const size_t fsPathMaxLengthExcludingNullTerminator = MAX_PATH - 1;
 562     bool usedURL = false;
 563     UChar fsPathBuffer[MAX_PATH];
 564     fsPathBuffer[0] = 0;
 565     int fsPathMaxLengthExcludingExtension = fsPathMaxLengthExcludingNullTerminator - extension.length();
 566 
 567     if (!title.isEmpty()) {
 568         size_t len = std::min&lt;size_t&gt;(title.length(), fsPathMaxLengthExcludingExtension);
 569         StringView(title).substring(0, len).getCharactersWithUpconvert(fsPathBuffer);
 570         fsPathBuffer[len] = 0;
 571         pathRemoveBadFSCharacters(wcharFrom(fsPathBuffer), len);
 572     }
 573 
 574     if (!wcslen(wcharFrom(fsPathBuffer))) {
 575         URL kurl(URL(), url);
 576         usedURL = true;
 577         // The filename for any content based drag or file url should be the last element of
 578         // the path. If we can&#39;t find it, or we&#39;re coming up with the name for a link
 579         // we just use the entire url.
 580         DWORD len = fsPathMaxLengthExcludingExtension;
 581         String lastComponent = kurl.lastPathComponent();
 582         if (kurl.isLocalFile() || (!isLink &amp;&amp; !lastComponent.isEmpty())) {
 583             len = std::min&lt;DWORD&gt;(fsPathMaxLengthExcludingExtension, lastComponent.length());
 584             StringView(lastComponent).substring(0, len).getCharactersWithUpconvert(fsPathBuffer);
 585         } else {
 586             len = std::min&lt;DWORD&gt;(fsPathMaxLengthExcludingExtension, url.length());
 587             StringView(url).substring(0, len).getCharactersWithUpconvert(fsPathBuffer);
 588         }
 589         fsPathBuffer[len] = 0;
 590         pathRemoveBadFSCharacters(wcharFrom(fsPathBuffer), len);
 591     }
 592 
 593     if (extension.isEmpty())
 594         return String(fsPathBuffer);
 595 
 596     if (!isLink &amp;&amp; usedURL) {
 597         PathRenameExtension(wcharFrom(fsPathBuffer), extension.wideCharacters().data());
 598         return String(fsPathBuffer);
 599     }
 600 
 601     return makeString(const_cast&lt;const UChar*&gt;(fsPathBuffer), extension);
 602 }
 603 
 604 // writeFileToDataObject takes ownership of fileDescriptor and fileContent
 605 static HRESULT writeFileToDataObject(IDataObject* dataObject, HGLOBAL fileDescriptor, HGLOBAL fileContent, HGLOBAL hDropContent)
 606 {
 607     HRESULT hr = S_OK;
 608     FORMATETC* fe;
 609     STGMEDIUM medium { };
 610     medium.tymed = TYMED_HGLOBAL;
 611 
 612     if (!fileDescriptor || !fileContent)
 613         goto exit;
 614 
 615     // Descriptor
 616     fe = fileDescriptorFormat();
 617 
 618     medium.hGlobal = fileDescriptor;
 619 
 620     if (FAILED(hr = dataObject-&gt;SetData(fe, &amp;medium, TRUE)))
 621         goto exit;
 622 
 623     // Contents
 624     fe = fileContentFormatZero();
 625     medium.hGlobal = fileContent;
 626     if (FAILED(hr = dataObject-&gt;SetData(fe, &amp;medium, TRUE)))
 627         goto exit;
 628 
 629 #if USE(CF)
 630     // HDROP
 631     if (hDropContent) {
 632         medium.hGlobal = hDropContent;
 633         hr = dataObject-&gt;SetData(cfHDropFormat(), &amp;medium, TRUE);
 634     }
 635 #endif
 636 
 637 exit:
 638     if (FAILED(hr)) {
 639         if (fileDescriptor)
 640             GlobalFree(fileDescriptor);
 641         if (fileContent)
 642             GlobalFree(fileContent);
 643         if (hDropContent)
 644             GlobalFree(hDropContent);
 645     }
 646     return hr;
 647 }
 648 
 649 void Pasteboard::writeURLToDataObject(const URL&amp; kurl, const String&amp; titleStr)
 650 {
 651     if (!m_writableDataObject)
 652         return;
 653     WebCore::writeURL(m_writableDataObject.get(), kurl, titleStr, true, true);
 654 
 655     String url = kurl.string();
 656     ASSERT(url.isAllASCII()); // URL::string() is URL encoded.
 657 
 658     String fsPath = filesystemPathFromUrlOrTitle(url, titleStr, &quot;.URL&quot;, true);
 659     String contentString(&quot;[InternetShortcut]\r\nURL=&quot; + url + &quot;\r\n&quot;);
 660     CString content = contentString.latin1();
 661 
 662     if (fsPath.length() &lt;= 0)
 663         return;
 664 
 665     HGLOBAL urlFileDescriptor = GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTOR));
 666     if (!urlFileDescriptor)
 667         return;
 668 
 669     HGLOBAL urlFileContent = GlobalAlloc(GPTR, content.length());
 670     if (!urlFileContent) {
 671         GlobalFree(urlFileDescriptor);
 672         return;
 673     }
 674 
 675     FILEGROUPDESCRIPTOR* fgd = static_cast&lt;FILEGROUPDESCRIPTOR*&gt;(GlobalLock(urlFileDescriptor));
 676     if (!fgd) {
 677         GlobalFree(urlFileDescriptor);
 678         return;
 679     }
 680 
 681     ZeroMemory(fgd, sizeof(FILEGROUPDESCRIPTOR));
 682     fgd-&gt;cItems = 1;
 683     fgd-&gt;fgd[0].dwFlags = FD_FILESIZE;
 684     fgd-&gt;fgd[0].nFileSizeLow = content.length();
 685 
 686     unsigned maxSize = std::min&lt;unsigned&gt;(fsPath.length(), WTF_ARRAY_LENGTH(fgd-&gt;fgd[0].cFileName));
 687     StringView(fsPath).substring(0, maxSize).getCharactersWithUpconvert(ucharFrom(fgd-&gt;fgd[0].cFileName));
 688     GlobalUnlock(urlFileDescriptor);
 689 
 690     char* fileContents = static_cast&lt;char*&gt;(GlobalLock(urlFileContent));
 691     if (!fileContents) {
 692         GlobalFree(urlFileDescriptor);
 693         return;
 694     }
 695 
 696     CopyMemory(fileContents, content.data(), content.length());
 697     GlobalUnlock(urlFileContent);
 698 
 699     writeFileToDataObject(m_writableDataObject.get(), urlFileDescriptor, urlFileContent, 0);
 700 }
 701 
 702 void Pasteboard::write(const PasteboardURL&amp; pasteboardURL)
 703 {
 704     ASSERT(!pasteboardURL.url.isEmpty());
 705 
 706     clear();
 707 
 708     String title(pasteboardURL.title);
 709     if (title.isEmpty()) {
 710         title = pasteboardURL.url.lastPathComponent();
 711         if (title.isEmpty())
 712             title = pasteboardURL.url.host().toString();
 713     }
 714 
 715     // write to clipboard in format com.apple.safari.bookmarkdata to be able to paste into the bookmarks view with appropriate title
 716     if (::OpenClipboard(m_owner)) {
 717         HGLOBAL cbData = createGlobalData(pasteboardURL.url, title);
 718         if (!::SetClipboardData(BookmarkClipboardFormat, cbData))
 719             ::GlobalFree(cbData);
 720         ::CloseClipboard();
 721     }
 722 
 723     // write to clipboard in format CF_HTML to be able to paste into contenteditable areas as a link
 724     if (::OpenClipboard(m_owner)) {
 725         Vector&lt;char&gt; data;
 726         markupToCFHTML(urlToMarkup(pasteboardURL.url, title), &quot;&quot;, data);
 727         HGLOBAL cbData = createGlobalData(data);
 728         if (!::SetClipboardData(HTMLClipboardFormat, cbData))
 729             ::GlobalFree(cbData);
 730         ::CloseClipboard();
 731     }
 732 
 733     // bare-bones CF_UNICODETEXT support
 734     if (::OpenClipboard(m_owner)) {
 735         HGLOBAL cbData = createGlobalData(pasteboardURL.url.string());
 736         if (!::SetClipboardData(CF_UNICODETEXT, cbData))
 737             ::GlobalFree(cbData);
 738         ::CloseClipboard();
 739     }
 740 
 741     writeURLToDataObject(pasteboardURL.url, pasteboardURL.title);
 742 }
 743 
 744 void Pasteboard::writeTrustworthyWebURLsPboardType(const PasteboardURL&amp;)
 745 {
 746     notImplemented();
 747 }
 748 
 749 void Pasteboard::writeImage(Element&amp; element, const URL&amp;, const String&amp;)
 750 {
 751     if (!is&lt;RenderImage&gt;(element.renderer()))
 752         return;
 753 
 754     auto&amp; renderer = downcast&lt;RenderImage&gt;(*element.renderer());
 755     CachedImage* cachedImage = renderer.cachedImage();
 756     if (!cachedImage || cachedImage-&gt;errorOccurred())
 757         return;
 758     Image* image = cachedImage-&gt;imageForRenderer(&amp;renderer);
 759     ASSERT(image);
 760 
 761     clear();
 762 
 763     HWndDC dc(0);
 764     auto compatibleDC = adoptGDIObject(::CreateCompatibleDC(0));
 765     auto sourceDC = adoptGDIObject(::CreateCompatibleDC(0));
 766     auto resultBitmap = adoptGDIObject(::CreateCompatibleBitmap(dc, image-&gt;width(), image-&gt;height()));
 767     HGDIOBJ oldBitmap = ::SelectObject(compatibleDC.get(), resultBitmap.get());
 768 
 769     BitmapInfo bmInfo = BitmapInfo::create(IntSize(image-&gt;size()));
 770 
 771     auto coreBitmap = adoptGDIObject(::CreateDIBSection(dc, &amp;bmInfo, DIB_RGB_COLORS, 0, 0, 0));
 772     HGDIOBJ oldSource = ::SelectObject(sourceDC.get(), coreBitmap.get());
 773     image-&gt;getHBITMAP(coreBitmap.get());
 774 
 775     ::BitBlt(compatibleDC.get(), 0, 0, image-&gt;width(), image-&gt;height(), sourceDC.get(), 0, 0, SRCCOPY);
 776 
 777     ::SelectObject(sourceDC.get(), oldSource);
 778     ::SelectObject(compatibleDC.get(), oldBitmap);
 779 
 780     if (::OpenClipboard(m_owner)) {
 781         ::SetClipboardData(CF_BITMAP, resultBitmap.leak());
 782         ::CloseClipboard();
 783     }
 784 }
 785 
 786 bool Pasteboard::canSmartReplace()
 787 {
 788     return ::IsClipboardFormatAvailable(WebSmartPasteFormat);
 789 }
 790 
 791 void Pasteboard::read(PasteboardPlainText&amp; text)
 792 {
 793     if (::IsClipboardFormatAvailable(CF_UNICODETEXT) &amp;&amp; ::OpenClipboard(m_owner)) {
 794         if (HANDLE cbData = ::GetClipboardData(CF_UNICODETEXT)) {
 795             text.text = static_cast&lt;UChar*&gt;(GlobalLock(cbData));
 796             GlobalUnlock(cbData);
 797             ::CloseClipboard();
 798             return;
 799         }
 800         ::CloseClipboard();
 801     }
 802 
 803     if (::IsClipboardFormatAvailable(CF_TEXT) &amp;&amp; ::OpenClipboard(m_owner)) {
 804         if (HANDLE cbData = ::GetClipboardData(CF_TEXT)) {
 805             // FIXME: This treats the characters as Latin-1, not UTF-8 or even Windows Latin-1. Is that the right encoding?
 806             text.text = static_cast&lt;char*&gt;(GlobalLock(cbData));
 807             GlobalUnlock(cbData);
 808             ::CloseClipboard();
 809             return;
 810         }
 811         ::CloseClipboard();
 812     }
 813 }
 814 
 815 RefPtr&lt;DocumentFragment&gt; Pasteboard::documentFragment(Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 816 {
 817     chosePlainText = false;
 818 
 819     if (::IsClipboardFormatAvailable(HTMLClipboardFormat) &amp;&amp; ::OpenClipboard(m_owner)) {
 820         // get data off of clipboard
 821         HANDLE cbData = ::GetClipboardData(HTMLClipboardFormat);
 822         if (cbData) {
 823             SIZE_T dataSize = ::GlobalSize(cbData);
 824             String cfhtml(UTF8Encoding().decode(static_cast&lt;char*&gt;(GlobalLock(cbData)), dataSize));
 825             GlobalUnlock(cbData);
 826             ::CloseClipboard();
 827 
 828             return fragmentFromCFHTML(frame.document(), cfhtml);
 829         } else
 830             ::CloseClipboard();
 831     }
 832 
 833     if (allowPlainText &amp;&amp; ::IsClipboardFormatAvailable(CF_UNICODETEXT)) {
 834         chosePlainText = true;
 835         if (::OpenClipboard(m_owner)) {
 836             HANDLE cbData = ::GetClipboardData(CF_UNICODETEXT);
 837             if (cbData) {
 838                 UChar* buffer = static_cast&lt;UChar*&gt;(GlobalLock(cbData));
 839                 String str(buffer);
 840                 GlobalUnlock(cbData);
 841                 ::CloseClipboard();
 842                 return createFragmentFromText(context, str);
 843             } else
 844                 ::CloseClipboard();
 845         }
 846     }
 847 
 848     if (allowPlainText &amp;&amp; ::IsClipboardFormatAvailable(CF_TEXT)) {
 849         chosePlainText = true;
 850         if (::OpenClipboard(m_owner)) {
 851             HANDLE cbData = ::GetClipboardData(CF_TEXT);
 852             if (cbData) {
 853                 char* buffer = static_cast&lt;char*&gt;(GlobalLock(cbData));
 854                 String str(buffer);
 855                 GlobalUnlock(cbData);
 856                 ::CloseClipboard();
 857                 return createFragmentFromText(context, str);
 858             } else
 859                 ::CloseClipboard();
 860         }
 861     }
 862 
 863     return nullptr;
 864 }
 865 
 866 void Pasteboard::setExternalDataObject(IDataObject *dataObject)
 867 {
 868     m_writableDataObject = 0;
 869     m_dataObject = dataObject;
 870 }
 871 
 872 static CachedImage* getCachedImage(Element&amp; element)
 873 {
 874     // Attempt to pull CachedImage from element
 875     RenderObject* renderer = element.renderer();
 876     if (!is&lt;RenderImage&gt;(renderer))
 877         return nullptr;
 878 
 879     auto* image = downcast&lt;RenderImage&gt;(renderer);
 880     if (image-&gt;cachedImage() &amp;&amp; !image-&gt;cachedImage()-&gt;errorOccurred())
 881         return image-&gt;cachedImage();
 882 
 883     return nullptr;
 884 }
 885 
 886 static HGLOBAL createGlobalImageFileDescriptor(const String&amp; url, const String&amp; title, CachedImage* image)
 887 {
 888     ASSERT_ARG(image, image);
 889     ASSERT(image-&gt;image()-&gt;data());
 890 
 891     String fsPath;
 892     HGLOBAL memObj = GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTOR));
 893     if (!memObj)
 894         return 0;
 895 
 896     FILEGROUPDESCRIPTOR* fgd = (FILEGROUPDESCRIPTOR*)GlobalLock(memObj);
 897     if (!fgd) {
 898         GlobalFree(memObj);
 899         return 0;
 900     }
 901 
 902     memset(fgd, 0, sizeof(FILEGROUPDESCRIPTOR));
 903     fgd-&gt;cItems = 1;
 904     fgd-&gt;fgd[0].dwFlags = FD_FILESIZE;
 905     fgd-&gt;fgd[0].nFileSizeLow = image-&gt;image()-&gt;data()-&gt;size();
 906 
 907     const String&amp; preferredTitle = title.isEmpty() ? image-&gt;response().suggestedFilename() : title;
 908     String extension = image-&gt;image()-&gt;filenameExtension();
 909     if (extension.isEmpty()) {
 910         // Do not continue processing in the rare and unusual case where a decoded image is not able
 911         // to provide a filename extension. Something tricky (like a bait-n-switch) is going on
 912         GlobalUnlock(memObj);
 913         GlobalFree(memObj);
 914         return 0;
 915     }
 916     extension.insert(&quot;.&quot;, 0);
 917     fsPath = filesystemPathFromUrlOrTitle(url, preferredTitle, extension, false);
 918 
 919     if (fsPath.length() &lt;= 0) {
 920         GlobalUnlock(memObj);
 921         GlobalFree(memObj);
 922         return 0;
 923     }
 924 
 925     int maxSize = std::min&lt;int&gt;(fsPath.length(), WTF_ARRAY_LENGTH(fgd-&gt;fgd[0].cFileName));
 926     StringView(fsPath).substring(0, maxSize).getCharactersWithUpconvert(ucharFrom(fgd-&gt;fgd[0].cFileName));
 927     GlobalUnlock(memObj);
 928 
 929     return memObj;
 930 }
 931 
 932 static HGLOBAL createGlobalImageFileContent(SharedBuffer* data)
 933 {
 934     HGLOBAL memObj = GlobalAlloc(GPTR, data-&gt;size());
 935     if (!memObj)
 936         return 0;
 937 
 938     char* fileContents = (PSTR)GlobalLock(memObj);
 939     if (!fileContents) {
 940         GlobalFree(memObj);
 941         return 0;
 942     }
 943 
 944     if (data-&gt;data())
 945         CopyMemory(fileContents, data-&gt;data(), data-&gt;size());
 946 
 947     GlobalUnlock(memObj);
 948 
 949     return memObj;
 950 }
 951 
 952 static HGLOBAL createGlobalHDropContent(const URL&amp; url, String&amp; fileName, SharedBuffer* data)
 953 {
 954     if (fileName.isEmpty() || !data)
 955         return 0;
 956 
 957     WCHAR filePath[MAX_PATH];
 958 
 959     if (url.isLocalFile()) {
 960         String localPath = decodeURLEscapeSequences(url.path());
 961         // windows does not enjoy a leading slash on paths
 962         if (localPath[0] == &#39;/&#39;)
 963             localPath = localPath.substring(1);
 964         LPCWSTR localPathStr = localPath.wideCharacters().data();
 965         if (localPathStr &amp;&amp; wcslen(localPathStr) + 1 &lt; MAX_PATH)
 966             wcscpy_s(filePath, MAX_PATH, localPathStr);
 967         else
 968             return 0;
 969     } else {
 970         WCHAR tempPath[MAX_PATH];
 971         WCHAR extension[MAX_PATH];
 972         if (!::GetTempPath(WTF_ARRAY_LENGTH(tempPath), tempPath))
 973             return 0;
 974         if (!::PathAppend(tempPath, fileName.wideCharacters().data()))
 975             return 0;
 976         LPCWSTR foundExtension = ::PathFindExtension(tempPath);
 977         if (foundExtension) {
 978             if (wcscpy_s(extension, MAX_PATH, foundExtension))
 979                 return 0;
 980         } else
 981             *extension = 0;
 982         ::PathRemoveExtension(tempPath);
 983         for (int i = 1; i &lt; 10000; i++) {
 984             if (swprintf_s(filePath, MAX_PATH, TEXT(&quot;%s-%d%s&quot;), tempPath, i, extension) == -1)
 985                 return 0;
 986             if (!::PathFileExists(filePath))
 987                 break;
 988         }
 989         HANDLE tempFileHandle = CreateFile(filePath, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
 990         if (tempFileHandle == INVALID_HANDLE_VALUE)
 991             return 0;
 992 
 993         // Write the data to this temp file.
 994         DWORD written;
 995         BOOL tempWriteSucceeded = FALSE;
 996         if (data-&gt;data())
 997             tempWriteSucceeded = WriteFile(tempFileHandle, data-&gt;data(), data-&gt;size(), &amp;written, 0);
 998         CloseHandle(tempFileHandle);
 999         if (!tempWriteSucceeded)
1000             return 0;
1001     }
1002 
1003     SIZE_T dropFilesSize = sizeof(DROPFILES) + (sizeof(WCHAR) * (wcslen(filePath) + 2));
1004     HGLOBAL memObj = GlobalAlloc(GHND | GMEM_SHARE, dropFilesSize);
1005     if (!memObj)
1006         return 0;
1007 
1008     DROPFILES* dropFiles = (DROPFILES*) GlobalLock(memObj);
1009     if (!dropFiles) {
1010         GlobalFree(memObj);
1011         return 0;
1012     }
1013 
1014     dropFiles-&gt;pFiles = sizeof(DROPFILES);
1015     dropFiles-&gt;fWide = TRUE;
1016     wcscpy(reinterpret_cast&lt;LPWSTR&gt;(dropFiles + 1), filePath);
1017     GlobalUnlock(memObj);
1018 
1019     return memObj;
1020 }
1021 
1022 void Pasteboard::writeImageToDataObject(Element&amp; element, const URL&amp; url)
1023 {
1024     // Shove image data into a DataObject for use as a file
1025     CachedImage* cachedImage = getCachedImage(element);
1026     if (!cachedImage || !cachedImage-&gt;imageForRenderer(element.renderer()) || !cachedImage-&gt;isLoaded())
1027         return;
1028 
1029     SharedBuffer* imageBuffer = cachedImage-&gt;imageForRenderer(element.renderer())-&gt;data();
1030     if (!imageBuffer || !imageBuffer-&gt;size())
1031         return;
1032 
1033     HGLOBAL imageFileDescriptor = createGlobalImageFileDescriptor(url.string(), element.attributeWithoutSynchronization(HTMLNames::altAttr), cachedImage);
1034     if (!imageFileDescriptor)
1035         return;
1036 
1037     HGLOBAL imageFileContent = createGlobalImageFileContent(imageBuffer);
1038     if (!imageFileContent) {
1039         GlobalFree(imageFileDescriptor);
1040         return;
1041     }
1042 
1043     String fileName = cachedImage-&gt;response().suggestedFilename();
1044     HGLOBAL hDropContent = createGlobalHDropContent(url, fileName, imageBuffer);
1045     if (!hDropContent) {
1046         GlobalFree(imageFileDescriptor);
1047         GlobalFree(imageFileContent);
1048         return;
1049     }
1050 
1051     writeFileToDataObject(m_writableDataObject.get(), imageFileDescriptor, imageFileContent, hDropContent);
1052 }
1053 
1054 void Pasteboard::writeURLToWritableDataObject(const URL&amp; url, const String&amp; title)
1055 {
1056     WebCore::writeURL(m_writableDataObject.get(), url, title, true, false);
1057 }
1058 
1059 void Pasteboard::writeMarkup(const String&amp; markup)
1060 {
1061     Vector&lt;char&gt; data;
1062     markupToCFHTML(markup, &quot;&quot;, data);
1063 
1064     STGMEDIUM medium { };
1065     medium.tymed = TYMED_HGLOBAL;
1066 
1067     medium.hGlobal = createGlobalData(data);
1068     if (medium.hGlobal &amp;&amp; FAILED(m_writableDataObject-&gt;SetData(htmlFormat(), &amp;medium, TRUE)))
1069         GlobalFree(medium.hGlobal);
1070 }
1071 
1072 void Pasteboard::write(const PasteboardWebContent&amp;)
1073 {
1074 }
1075 
1076 void Pasteboard::read(PasteboardWebContentReader&amp;, WebContentReadingPolicy)
1077 {
1078 }
1079 
1080 void Pasteboard::write(const PasteboardImage&amp;)
1081 {
1082 }
1083 
1084 void Pasteboard::writeCustomData(const PasteboardCustomData&amp;)
1085 {
1086 }
1087 
1088 void Pasteboard::write(const Color&amp;)
1089 {
1090 }
1091 
1092 } // namespace WebCore
    </pre>
  </body>
</html>