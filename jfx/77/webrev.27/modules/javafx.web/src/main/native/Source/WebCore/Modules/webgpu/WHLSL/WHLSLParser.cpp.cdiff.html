<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLNameResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLParser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,175 ***</span>
  
  #if ENABLE(WEBGPU)
  
  #include &quot;WHLSLAddressSpace.h&quot;
  #include &quot;WHLSLEntryPointType.h&quot;
  #include &lt;wtf/dtoa.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/StringConcatenate.h&gt;
  
  namespace WebCore {
  
  namespace WHLSL {
  
<span class="line-modified">! // FIXME: Return a better error code from this, and report it to JavaScript.</span>
<span class="line-modified">! auto Parser::parse(Program&amp; program, StringView stringView, Mode mode) -&gt; Optional&lt;Error&gt;</span>
  {
<span class="line-modified">!     m_lexer = Lexer(stringView);</span>
      m_mode = mode;
  
      while (!m_lexer.isFullyConsumed()) {
<span class="line-modified">!         if (tryType(Lexer::Token::Type::Semicolon)) {</span>
              m_lexer.consumeToken();
              continue;
          }
<span class="line-modified">! </span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto typeDefinition = backtrackingScope&lt;Expected&lt;AST::TypeDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!                 return parseTypeDefinition();</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!             if (typeDefinition) {</span>
<span class="line-modified">!                 auto success = program.append(WTFMove(*typeDefinition));</span>
<span class="line-modified">!                 if (!success)</span>
<span class="line-removed">-                     return WTF::nullopt;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto structureDefinition = backtrackingScope&lt;Expected&lt;AST::StructureDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!                 return parseStructureDefinition();</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!             if (structureDefinition) {</span>
<span class="line-modified">!                 auto success = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">!                 if (!success)</span>
<span class="line-removed">-                     return WTF::nullopt;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto enumerationDefinition = backtrackingScope&lt;Expected&lt;AST::EnumerationDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!                 return parseEnumerationDefinition();</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!             if (enumerationDefinition) {</span>
<span class="line-modified">!                 auto success = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">!                 if (!success)</span>
<span class="line-modified">!                     return WTF::nullopt;</span>
                  continue;
              }
          }
<span class="line-modified">! </span>
<span class="line-modified">!         Optional&lt;Error&gt; error;</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             auto functionDefinition = backtrackingScope&lt;Expected&lt;AST::FunctionDefinition, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!                 return parseFunctionDefinition();</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!             if (functionDefinition) {</span>
<span class="line-modified">!                 auto success = program.append(WTFMove(*functionDefinition));</span>
<span class="line-removed">-                 if (!success)</span>
<span class="line-removed">-                     return WTF::nullopt;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             error = functionDefinition.error();</span>
          }
<span class="line-removed">- </span>
<span class="line-removed">-         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-removed">-             auto nativeFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeFunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-                 return parseNativeFunctionDeclaration();</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-             if (nativeFunctionDeclaration) {</span>
<span class="line-removed">-                 auto success = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-removed">-                 if (!success)</span>
<span class="line-removed">-                     return WTF::nullopt;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
          }
  
<span class="line-modified">!         if (m_mode == Mode::StandardLibrary) {</span>
<span class="line-modified">!             auto nativeTypeDeclaration = backtrackingScope&lt;Expected&lt;AST::NativeTypeDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-                 return parseNativeTypeDeclaration();</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-             if (nativeTypeDeclaration) {</span>
<span class="line-removed">-                 auto success = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-removed">-                 if (!success)</span>
<span class="line-removed">-                     return WTF::nullopt;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return WTFMove(*error);</span>
      }
<span class="line-modified">!     return WTF::nullopt;</span>
  }
  
<span class="line-modified">! auto Parser::fail(const String&amp; message) -&gt; Unexpected&lt;Error&gt;</span>
  {
<span class="line-modified">!     if (auto nextToken = peek())</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(Error(m_lexer.errorString(*nextToken, message)));</span>
<span class="line-modified">!     return Unexpected&lt;Error&gt;(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>
  }
  
<span class="line-modified">! auto Parser::peek() -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
  {
<span class="line-modified">!     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified">!         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified">!         return *token;</span>
      }
<span class="line-modified">!     return fail(&quot;Cannot consume token&quot;_str);</span>
  }
  
<span class="line-modified">! Optional&lt;Lexer::Token&gt; Parser::tryType(Lexer::Token::Type type)</span>
  {
<span class="line-modified">!     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified">!         if (token-&gt;type == type)</span>
<span class="line-modified">!             return token;</span>
<span class="line-modified">!         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-modified">!     }</span>
      return WTF::nullopt;
  }
  
<span class="line-modified">! Optional&lt;Lexer::Token&gt; Parser::tryTypes(Vector&lt;Lexer::Token::Type&gt; types)</span>
  {
<span class="line-modified">!     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified">!         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified">!             return token;</span>
<span class="line-removed">-         m_lexer.unconsumeToken(Lexer::Token(*token));</span>
<span class="line-removed">-     }</span>
      return WTF::nullopt;
  }
  
<span class="line-modified">! auto Parser::consumeType(Lexer::Token::Type type) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
  {
<span class="line-modified">!     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified">!         if (token-&gt;type == type)</span>
<span class="line-modified">!             return *token;</span>
<span class="line-modified">!         return fail(makeString(&quot;Unexpected token (expected &quot;, Lexer::Token::typeName(type), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return fail(makeString(&quot;Cannot consume token (expected &quot;, Lexer::Token::typeName(type), &quot;)&quot;));</span>
  }
  
<span class="line-modified">! auto Parser::consumeTypes(Vector&lt;Lexer::Token::Type&gt; types) -&gt; Expected&lt;Lexer::Token, Error&gt;</span>
  {
      auto buildExpectedString = [&amp;]() -&gt; String {
          StringBuilder builder;
          builder.append(&quot;[&quot;);
<span class="line-modified">!         for (unsigned i = 0; i &lt; types.size(); ++i) {</span>
<span class="line-removed">-             if (i &gt; 0)</span>
<span class="line-removed">-                 builder.append(&quot;, &quot;);</span>
<span class="line-removed">-             builder.append(Lexer::Token::typeName(types[i]));</span>
<span class="line-removed">-         }</span>
          builder.append(&quot;]&quot;);
          return builder.toString();
      };
  
<span class="line-modified">!     if (auto token = m_lexer.consumeToken()) {</span>
<span class="line-modified">!         if (std::find(types.begin(), types.end(), token-&gt;type) != types.end())</span>
<span class="line-modified">!             return *token;</span>
<span class="line-modified">!         return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Lexer::Token::typeName(token-&gt;type), &quot;)&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return fail(makeString(&quot;Cannot consume token (expected &quot;, buildExpectedString(), &quot;)&quot;));</span>
  }
  
  static int digitValue(UChar character)
  {
      if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
<span class="line-new-header">--- 28,222 ---</span>
  
  #if ENABLE(WEBGPU)
  
  #include &quot;WHLSLAddressSpace.h&quot;
  #include &quot;WHLSLEntryPointType.h&quot;
<span class="line-added">+ #include &quot;WHLSLProgram.h&quot;</span>
  #include &lt;wtf/dtoa.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/StringConcatenate.h&gt;
  
  namespace WebCore {
  
  namespace WHLSL {
  
<span class="line-modified">! #define PARSE(name, element, ...) \</span>
<span class="line-modified">!     auto name = parse##element(__VA_ARGS__); \</span>
<span class="line-added">+     if (!name) \</span>
<span class="line-added">+         return makeUnexpected(name.error()); \</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define CONSUME_TYPE(name, type) \</span>
<span class="line-added">+     auto name = consumeType(Token::Type::type); \</span>
<span class="line-added">+     if (!name) \</span>
<span class="line-added">+         return makeUnexpected(name.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define PEEK(name) \</span>
<span class="line-added">+     auto name = peek(); \</span>
<span class="line-added">+     if (!name) \</span>
<span class="line-added">+         return makeUnexpected(name.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define PEEK_FURTHER(name) \</span>
<span class="line-added">+     auto name = peekFurther(); \</span>
<span class="line-added">+     if (!name) \</span>
<span class="line-added">+         return makeUnexpected(name.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+ auto Parser::parse(Program&amp; program, StringView stringView, ParsingMode mode, AST::NameSpace nameSpace) -&gt; Expected&lt;void, Error&gt;</span>
  {
<span class="line-modified">!     m_lexer = Lexer(stringView, nameSpace);</span>
      m_mode = mode;
  
      while (!m_lexer.isFullyConsumed()) {
<span class="line-modified">!         auto token = m_lexer.peek();</span>
<span class="line-added">+         switch (token.type) {</span>
<span class="line-added">+         case Token::Type::Invalid:</span>
<span class="line-added">+             return { };</span>
<span class="line-added">+         case Token::Type::Semicolon:</span>
              m_lexer.consumeToken();
              continue;
<span class="line-added">+         case Token::Type::Typedef: {</span>
<span class="line-added">+             auto typeDefinition = parseTypeDefinition();</span>
<span class="line-added">+             if (!typeDefinition)</span>
<span class="line-added">+                 return makeUnexpected(typeDefinition.error());</span>
<span class="line-added">+             auto appendResult = program.append(WTFMove(*typeDefinition));</span>
<span class="line-added">+             if (!appendResult)</span>
<span class="line-added">+                 return makeUnexpected(appendResult.error());</span>
<span class="line-added">+             continue;</span>
          }
<span class="line-modified">!         case Token::Type::Struct: {</span>
<span class="line-modified">!             auto structureDefinition = parseStructureDefinition();</span>
<span class="line-modified">!             if (!structureDefinition)</span>
<span class="line-modified">!                 return makeUnexpected(structureDefinition.error());</span>
<span class="line-modified">!             auto appendResult = program.append(WTFMove(*structureDefinition));</span>
<span class="line-modified">!             if (!appendResult)</span>
<span class="line-modified">!                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified">!             continue;</span>
          }
<span class="line-modified">!         case Token::Type::Enum: {</span>
<span class="line-modified">!             auto enumerationDefinition = parseEnumerationDefinition();</span>
<span class="line-modified">!             if (!enumerationDefinition)</span>
<span class="line-modified">!                 return makeUnexpected(enumerationDefinition.error());</span>
<span class="line-modified">!             auto appendResult = program.append(WTFMove(*enumerationDefinition));</span>
<span class="line-modified">!             if (!appendResult)</span>
<span class="line-modified">!                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified">!             continue;</span>
          }
<span class="line-modified">!         case Token::Type::Native: {</span>
<span class="line-modified">!             if (m_mode != ParsingMode::StandardLibrary)</span>
<span class="line-modified">!                 return fail(makeString(&quot;&#39;native&#39; can&#39;t exist outside of the standard library.&quot;));</span>
<span class="line-modified">!             auto furtherToken = peekFurther();</span>
<span class="line-modified">!             if (!furtherToken)</span>
<span class="line-modified">!                 return { };</span>
<span class="line-modified">!             if (furtherToken-&gt;type == Token::Type::Typedef) {</span>
<span class="line-modified">!                 auto nativeTypeDeclaration = parseNativeTypeDeclaration();</span>
<span class="line-modified">!                 if (!nativeTypeDeclaration)</span>
<span class="line-added">+                     return makeUnexpected(nativeTypeDeclaration.error());</span>
<span class="line-added">+                 auto appendResult = program.append(WTFMove(*nativeTypeDeclaration));</span>
<span class="line-added">+                 if (!appendResult)</span>
<span class="line-added">+                     return makeUnexpected(appendResult.error());</span>
                  continue;
              }
<span class="line-added">+             auto nativeFunctionDeclaration = parseNativeFunctionDeclaration();</span>
<span class="line-added">+             if (!nativeFunctionDeclaration)</span>
<span class="line-added">+                 return makeUnexpected(nativeFunctionDeclaration.error());</span>
<span class="line-added">+             auto appendResult = program.append(WTFMove(*nativeFunctionDeclaration));</span>
<span class="line-added">+             if (!appendResult)</span>
<span class="line-added">+                 return makeUnexpected(appendResult.error());</span>
<span class="line-added">+             continue;</span>
          }
<span class="line-modified">!         default: {</span>
<span class="line-modified">!             auto functionDefinition = parseFunctionDefinition();</span>
<span class="line-modified">!             if (!functionDefinition)</span>
<span class="line-modified">!                 return makeUnexpected(functionDefinition.error());</span>
<span class="line-modified">!             auto appendResult = program.append(WTFMove(*functionDefinition));</span>
<span class="line-modified">!             if (!appendResult)</span>
<span class="line-modified">!                 return makeUnexpected(appendResult.error());</span>
<span class="line-modified">!             continue;</span>
          }
          }
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return { };</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! auto Parser::fail(const String&amp; message, TryToPeek tryToPeek) -&gt; Unexpected&lt;Error&gt;</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (tryToPeek == TryToPeek::Yes) {</span>
<span class="line-added">+         if (auto nextToken = peek())</span>
<span class="line-added">+             return makeUnexpected(Error(m_lexer.errorString(*nextToken, message)));</span>
      }
<span class="line-modified">!     return makeUnexpected(Error(makeString(&quot;Cannot lex: &quot;, message)));</span>
  }
  
<span class="line-modified">! auto Parser::peek() -&gt; Expected&lt;Token, Error&gt;</span>
  {
<span class="line-modified">!     auto token = m_lexer.peek();</span>
<span class="line-modified">!     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified">!         return { token };</span>
<span class="line-added">+     return fail(&quot;Cannot consume token&quot;_str, TryToPeek::No);</span>
  }
  
<span class="line-modified">! auto Parser::peekFurther() -&gt; Expected&lt;Token, Error&gt;</span>
  {
<span class="line-modified">!     auto token = m_lexer.peekFurther();</span>
<span class="line-modified">!     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)</span>
<span class="line-modified">!         return { token };</span>
<span class="line-added">+     return fail(&quot;Cannot consume two tokens&quot;_str, TryToPeek::No);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;Token::Type t, Token::Type... ts&gt;</span>
<span class="line-added">+ struct Types {</span>
<span class="line-added">+     static bool includes(Token::Type type)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return t == type || Types&lt;ts...&gt;::includes(type);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         builder.append(Token::typeName(t), &quot;, &quot;);</span>
<span class="line-added">+         Types&lt;ts...&gt;::appendNameTo(builder);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ template &lt;Token::Type t&gt;</span>
<span class="line-added">+ struct Types&lt;t&gt; {</span>
<span class="line-added">+     static bool includes(Token::Type type)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return t == type;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static void appendNameTo(StringBuilder&amp; builder)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         builder.append(Token::typeName(t));</span>
      }
<span class="line-modified">! };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Parser::peekType(Token::Type type)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto token = m_lexer.peek();</span>
<span class="line-added">+     return token.type == type;</span>
  }
  
<span class="line-modified">! template &lt;Token::Type... types&gt;</span>
<span class="line-added">+ bool Parser::peekTypes()</span>
  {
<span class="line-modified">!     auto token = m_lexer.peek();</span>
<span class="line-modified">!     return Types&lt;types...&gt;::includes(token.type);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! Optional&lt;Token&gt; Parser::tryType(Token::Type type)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto token = m_lexer.peek();</span>
<span class="line-added">+     if (token.type == type)</span>
<span class="line-added">+         return { m_lexer.consumeToken() };</span>
      return WTF::nullopt;
  }
  
<span class="line-modified">! template &lt;Token::Type... types&gt;</span>
<span class="line-added">+ Optional&lt;Token&gt; Parser::tryTypes()</span>
  {
<span class="line-modified">!     auto token = m_lexer.peek();</span>
<span class="line-modified">!     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified">!         return { m_lexer.consumeToken() };</span>
      return WTF::nullopt;
  }
  
<span class="line-modified">! auto Parser::consumeType(Token::Type type) -&gt; Expected&lt;Token, Error&gt;</span>
  {
<span class="line-modified">!     auto token = m_lexer.consumeToken();</span>
<span class="line-modified">!     if (token.type == type)</span>
<span class="line-modified">!         return { token };</span>
<span class="line-modified">!     return fail(makeString(&quot;Unexpected token (expected &quot;, Token::typeName(type), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>
  }
  
<span class="line-modified">! template &lt;Token::Type... types&gt;</span>
<span class="line-added">+ auto Parser::consumeTypes() -&gt; Expected&lt;Token, Error&gt;</span>
  {
      auto buildExpectedString = [&amp;]() -&gt; String {
          StringBuilder builder;
          builder.append(&quot;[&quot;);
<span class="line-modified">!         Types&lt;types...&gt;::appendNameTo(builder);</span>
          builder.append(&quot;]&quot;);
          return builder.toString();
      };
  
<span class="line-modified">!     auto token = m_lexer.consumeToken();</span>
<span class="line-modified">!     if (Types&lt;types...&gt;::includes(token.type))</span>
<span class="line-modified">!         return { token };</span>
<span class="line-modified">!     return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));</span>
  }
  
  static int digitValue(UChar character)
  {
      if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,11 ***</span>
      if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
          return character - &#39;a&#39; + 10;
      return character - &#39;A&#39; + 10;
  }
  
<span class="line-modified">! static Expected&lt;int, Parser::Error&gt; intLiteralToInt(StringView text)</span>
  {
      bool negate = false;
      if (text.startsWith(&quot;-&quot;_str)) {
          negate = true;
          text = text.substring(1);
<span class="line-new-header">--- 251,11 ---</span>
      if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
          return character - &#39;a&#39; + 10;
      return character - &#39;A&#39; + 10;
  }
  
<span class="line-modified">! static Expected&lt;int, Error&gt; intLiteralToInt(StringView text)</span>
  {
      bool negate = false;
      if (text.startsWith(&quot;-&quot;_str)) {
          negate = true;
          text = text.substring(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,24 ***</span>
      for (auto codePoint : text.codePoints()) {
          unsigned digit = digitValue(codePoint);
          auto previous = result;
          result = result * base + digit;
          if (result &lt; previous)
<span class="line-modified">!             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      }
      if (negate) {
<span class="line-modified">!         static_assert(std::numeric_limits&lt;long long int&gt;::min() &lt; std::numeric_limits&lt;int&gt;::min(), &quot;long long needs to be bigger than an int&quot;);</span>
<span class="line-modified">!         if (static_cast&lt;long long&gt;(result) &gt; std::abs(static_cast&lt;long long&gt;(std::numeric_limits&lt;int&gt;::min())))</span>
<span class="line-modified">!             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-modified">!         return { static_cast&lt;int&gt;(static_cast&lt;long long&gt;(result) * 1) };</span>
      }
      if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<span class="line-modified">!         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      return { static_cast&lt;int&gt;(result) };
  }
  
<span class="line-modified">! static Expected&lt;unsigned, Parser::Error&gt; uintLiteralToUint(StringView text)</span>
  {
      unsigned base = 10;
      if (text.startsWith(&quot;0x&quot;_str)) {
          text = text.substring(2);
          base = 16;
<span class="line-new-header">--- 270,25 ---</span>
      for (auto codePoint : text.codePoints()) {
          unsigned digit = digitValue(codePoint);
          auto previous = result;
          result = result * base + digit;
          if (result &lt; previous)
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      }
      if (negate) {
<span class="line-modified">!         static_assert(sizeof(int64_t) &gt; sizeof(unsigned) &amp;&amp; sizeof(int64_t) &gt; sizeof(int), &quot;This code would be wrong otherwise&quot;);</span>
<span class="line-modified">!         int64_t intResult = -static_cast&lt;int64_t&gt;(result);</span>
<span class="line-modified">!         if (intResult &lt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int&gt;::min()))</span>
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
<span class="line-added">+         return { static_cast&lt;int&gt;(intResult) };</span>
      }
      if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
<span class="line-modified">!         return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      return { static_cast&lt;int&gt;(result) };
  }
  
<span class="line-modified">! static Expected&lt;unsigned, Error&gt; uintLiteralToUint(StringView text)</span>
  {
      unsigned base = 10;
      if (text.startsWith(&quot;0x&quot;_str)) {
          text = text.substring(2);
          base = 16;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,52 ***</span>
      for (auto codePoint : text.codePoints()) {
          unsigned digit = digitValue(codePoint);
          auto previous = result;
          result = result * base + digit;
          if (result &lt; previous)
<span class="line-modified">!             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      }
      return { result };
  }
  
<span class="line-modified">! static Expected&lt;float, Parser::Error&gt; floatLiteralToFloat(StringView text)</span>
  {
      size_t parsedLength;
      auto result = parseDouble(text, parsedLength);
      if (parsedLength != text.length())
<span class="line-modified">!         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
      return static_cast&lt;float&gt;(result);
  }
  
  auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
  {
<span class="line-modified">!     auto integralLiteralToken = consumeTypes({ Lexer::Token::Type::IntLiteral, Lexer::Token::Type::UintLiteral });</span>
      if (!integralLiteralToken)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(integralLiteralToken.error());</span>
  
      switch (integralLiteralToken-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView);</span>
          if (result)
              return {{ *result }};
<span class="line-modified">!         return Unexpected&lt;Error&gt;(result.error());</span>
      }
      default: {
<span class="line-modified">!         ASSERT(integralLiteralToken-&gt;type == Lexer::Token::Type::UintLiteral);</span>
<span class="line-modified">!         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView);</span>
          if (result)
              return {{ *result }};
<span class="line-modified">!         return Unexpected&lt;Error&gt;(result.error());</span>
      }
      }
  }
  
  auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
  {
      auto integralLiteral = consumeIntegralLiteral();
      if (!integralLiteral)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(integralLiteral.error());</span>
      auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
          if (x &lt; 0)
              return WTF::nullopt;
          return x;
      }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
<span class="line-new-header">--- 299,52 ---</span>
      for (auto codePoint : text.codePoints()) {
          unsigned digit = digitValue(codePoint);
          auto previous = result;
          result = result * base + digit;
          if (result &lt; previous)
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));</span>
      }
      return { result };
  }
  
<span class="line-modified">! static Expected&lt;float, Error&gt; floatLiteralToFloat(StringView text)</span>
  {
      size_t parsedLength;
      auto result = parseDouble(text, parsedLength);
      if (parsedLength != text.length())
<span class="line-modified">!         return makeUnexpected(Error(makeString(&quot;Cannot parse float &quot;, text)));</span>
      return static_cast&lt;float&gt;(result);
  }
  
  auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
  {
<span class="line-modified">!     auto integralLiteralToken = consumeTypes&lt;Token::Type::IntLiteral, Token::Type::UintLiteral&gt;();</span>
      if (!integralLiteralToken)
<span class="line-modified">!         return makeUnexpected(integralLiteralToken.error());</span>
  
      switch (integralLiteralToken-&gt;type) {
<span class="line-modified">!     case Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView(m_lexer));</span>
          if (result)
              return {{ *result }};
<span class="line-modified">!         return makeUnexpected(result.error());</span>
      }
      default: {
<span class="line-modified">!         ASSERT(integralLiteralToken-&gt;type == Token::Type::UintLiteral);</span>
<span class="line-modified">!         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView(m_lexer));</span>
          if (result)
              return {{ *result }};
<span class="line-modified">!         return makeUnexpected(result.error());</span>
      }
      }
  }
  
  auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
  {
      auto integralLiteral = consumeIntegralLiteral();
      if (!integralLiteral)
<span class="line-modified">!         return makeUnexpected(integralLiteral.error());</span>
      auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
          if (x &lt; 0)
              return WTF::nullopt;
          return x;
      }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,398 ***</span>
      if (result)
          return *result;
      return fail(&quot;int literal is negative&quot;_str);
  }
  
<span class="line-modified">! static Expected&lt;unsigned, Parser::Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
  {
      unsigned result = 0;
      if (stringView.length() &lt; 1)
<span class="line-modified">!         return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
      for (auto codePoint : stringView.codePoints()) {
          if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<span class="line-modified">!             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
          auto previous = result;
          result = result * 10 + (codePoint - &#39;0&#39;);
          if (result &lt; previous)
<span class="line-modified">!             return Unexpected&lt;Parser::Error&gt;(Parser::Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
      }
      return result;
  }
  
  auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
  {
<span class="line-modified">!     auto type = consumeTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::Null,</span>
<span class="line-modified">!         Lexer::Token::Type::True,</span>
<span class="line-modified">!         Lexer::Token::Type::False,</span>
<span class="line-modified">!         Lexer::Token::Type::Identifier,</span>
<span class="line-removed">-     });</span>
      if (!type)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(type.error());</span>
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto value = intLiteralToInt(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return {{ AST::IntegerLiteral(WTFMove(*type), *value) }};</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified">!         auto value = uintLiteralToUint(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return {{ AST::UnsignedIntegerLiteral(WTFMove(*type), *value) }};</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified">!         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return {{ AST::FloatLiteral(WTFMove(*type), *value) }};</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::Null:</span>
          return { AST::NullLiteral(WTFMove(*type)) };
<span class="line-modified">!     case Lexer::Token::Type::True:</span>
          return { AST::BooleanLiteral(WTFMove(*type), true) };
<span class="line-modified">!     case Lexer::Token::Type::False:</span>
          return { AST::BooleanLiteral(WTFMove(*type), false) };
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!         auto origin = consumeType(Lexer::Token::Type::FullStop);</span>
<span class="line-modified">!         if (!origin)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">-         auto next = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-         if (!next)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(next.error());</span>
<span class="line-removed">-         return { AST::EnumerationMemberLiteral(WTFMove(*origin), type-&gt;stringView.toString(), next-&gt;stringView.toString()) };</span>
      }
      }
  }
  
  auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
  {
<span class="line-modified">!     auto constantExpression = backtrackingScope&lt;Expected&lt;AST::ConstantExpression, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseConstantExpression();</span>
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (constantExpression)</span>
          return AST::TypeArgument(WTFMove(*constantExpression));
<span class="line-modified">!     auto result = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!result)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified">!     return AST::TypeArgument(makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*result), result-&gt;stringView.toString(), AST::TypeArguments()));</span>
  }
  
  auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
  {
<span class="line-modified">!     auto typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified">!         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified">!         if (!lessThanSign)</span>
<span class="line-removed">-             return WTF::nullopt;</span>
<span class="line-removed">-         AST::TypeArguments typeArguments;</span>
<span class="line-removed">-         auto typeArgument = parseTypeArgument();</span>
<span class="line-removed">-         if (!typeArgument)</span>
<span class="line-removed">-             return WTF::nullopt;</span>
<span class="line-removed">-         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed">-         while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed">-             auto typeArgument = parseTypeArgument();</span>
<span class="line-removed">-             if (!typeArgument)</span>
<span class="line-removed">-                 return WTF::nullopt;</span>
<span class="line-removed">-             typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-removed">-         if (!greaterThanSign)</span>
<span class="line-removed">-             return WTF::nullopt;</span>
          return typeArguments;
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (typeArguments)</span>
<span class="line-removed">-         return WTFMove(*typeArguments);</span>
  
<span class="line-modified">!     typeArguments = backtrackingScope&lt;Optional&lt;AST::TypeArguments&gt;&gt;([&amp;]() -&gt; Optional&lt;AST::TypeArguments&gt; {</span>
<span class="line-modified">!         auto lessThanSign = consumeType(Lexer::Token::Type::LessThanSign);</span>
<span class="line-modified">!         if (!lessThanSign)</span>
<span class="line-modified">!             return WTF::nullopt;</span>
<span class="line-modified">!         auto greaterThanSign = consumeType(Lexer::Token::Type::GreaterThanSign);</span>
<span class="line-modified">!         if (!greaterThanSign)</span>
<span class="line-modified">!             return WTF::nullopt;</span>
<span class="line-modified">!         return {{ }};</span>
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (typeArguments)</span>
<span class="line-modified">!         return WTFMove(*typeArguments);</span>
  
<span class="line-modified">!     return AST::TypeArguments();</span>
  }
  
  auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
  {
<span class="line-modified">!     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>
      if (!token)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified">!     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
          auto numElements = consumeNonNegativeIntegralLiteral();
          if (!numElements)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified">!         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified">!         if (!rightSquareBracket)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed">-         return {{ *token, *numElements }};</span>
      }
<span class="line-modified">!     return {{ *token, WTF::nullopt }};</span>
  }
  
  auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
  {
<span class="line-modified">!     auto token = consumeTypes({ Lexer::Token::Type::Star, Lexer::Token::Type::SquareBracketPair, Lexer::Token::Type::LeftSquareBracket });</span>
      if (!token)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(token.error());</span>
<span class="line-modified">!     if (token-&gt;type == Lexer::Token::Type::LeftSquareBracket) {</span>
          auto numElements = consumeNonNegativeIntegralLiteral();
          if (!numElements)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(numElements.error());</span>
<span class="line-modified">!         auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-modified">!         if (!rightSquareBracket)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-modified">!         return {{ *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>
      if (!addressSpaceToken)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
      AST::AddressSpace addressSpace;
      switch (addressSpaceToken-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::Constant:</span>
          addressSpace = AST::AddressSpace::Constant;
          break;
<span class="line-modified">!     case Lexer::Token::Type::Device:</span>
          addressSpace = AST::AddressSpace::Device;
          break;
<span class="line-modified">!     case Lexer::Token::Type::Threadgroup:</span>
          addressSpace = AST::AddressSpace::Threadgroup;
          break;
      default:
<span class="line-modified">!         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
          addressSpace = AST::AddressSpace::Thread;
          break;
      }
<span class="line-modified">!     return {{ *token, { addressSpace }, WTF::nullopt }};</span>
  }
  
<span class="line-modified">! auto Parser::parseAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
  {
<span class="line-modified">!     auto addressSpaceToken = consumeTypes({ Lexer::Token::Type::Constant, Lexer::Token::Type::Device, Lexer::Token::Type::Threadgroup, Lexer::Token::Type::Thread});</span>
<span class="line-modified">!     if (!addressSpaceToken)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(addressSpaceToken.error());</span>
<span class="line-modified">!     AST::AddressSpace addressSpace;</span>
<span class="line-modified">!     switch (addressSpaceToken-&gt;type) {</span>
<span class="line-removed">-     case Lexer::Token::Type::Constant:</span>
<span class="line-removed">-         addressSpace = AST::AddressSpace::Constant;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case Lexer::Token::Type::Device:</span>
<span class="line-removed">-         addressSpace = AST::AddressSpace::Device;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case Lexer::Token::Type::Threadgroup:</span>
<span class="line-removed">-         addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         ASSERT(addressSpaceToken-&gt;type == Lexer::Token::Type::Thread);</span>
<span class="line-removed">-         addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">-     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed">-     if (!typeArguments)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
<span class="line-removed">-         switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-removed">-         case Lexer::Token::Type::Star:</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed">-         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixAbbreviated.token), addressSpace, WTFMove(previous)) };</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             ASSERT(typeSuffixAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixAbbreviated.token), WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     auto firstTypeSuffixAbbreviated = parseTypeSuffixAbbreviated();</span>
<span class="line-modified">!     if (!firstTypeSuffixAbbreviated)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(firstTypeSuffixAbbreviated.error());</span>
<span class="line-modified">!     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*addressSpaceToken), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
<span class="line-modified">!     auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-modified">!     result = WTFMove(next);</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto typeSuffixAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-             return parseTypeSuffixAbbreviated();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (!typeSuffixAbbreviated)</span>
              break;
<span class="line-modified">!         // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-modified">!         next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
          result = WTFMove(next);
      }
  
<span class="line-modified">!     return WTFMove(result);</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- auto Parser::parseNonAddressSpaceType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">-     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed">-     if (!typeArguments)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; UniqueRef&lt;AST::UnnamedType&gt; {</span>
          switch (typeSuffixNonAbbreviated.token.type) {
<span class="line-modified">!         case Lexer::Token::Type::Star:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::PointerType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified">!         case Lexer::Token::Type::SquareBracketPair:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::ArrayReferenceType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
          default:
<span class="line-modified">!             ASSERT(typeSuffixNonAbbreviated.token.type == Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::ArrayType&gt;(Lexer::Token(typeSuffixNonAbbreviated.token), WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
          }
      };
<span class="line-modified">! </span>
<span class="line-removed">-     UniqueRef&lt;AST::UnnamedType&gt; result = makeUniqueRef&lt;AST::TypeReference&gt;(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
      while (true) {
<span class="line-modified">!         auto typeSuffixNonAbbreviated = backtrackingScope&lt;Expected&lt;TypeSuffixNonAbbreviated, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseTypeSuffixNonAbbreviated();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (!typeSuffixNonAbbreviated)</span>
              break;
          // FIXME: The nesting here might be in the wrong order.
          auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
          result = WTFMove(next);
      }
<span class="line-removed">- </span>
      return WTFMove(result);
  }
  
<span class="line-removed">- auto Parser::parseType() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseAddressSpaceType();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (type)</span>
<span class="line-removed">-         return type;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     type = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseNonAddressSpaceType();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (type)</span>
<span class="line-removed">-         return type;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">!     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!name)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">-     auto equals = consumeType(Lexer::Token::Type::EqualsSign);</span>
<span class="line-removed">-     if (!equals)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(equals.error());</span>
<span class="line-removed">-     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed">-     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-     if (!semicolon)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">-     return AST::TypeDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
  }
  
  auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::SVInstanceID,</span>
<span class="line-modified">!         Lexer::Token::Type::SVVertexID,</span>
<span class="line-modified">!         Lexer::Token::Type::PSize,</span>
<span class="line-modified">!         Lexer::Token::Type::SVPosition,</span>
<span class="line-modified">!         Lexer::Token::Type::SVIsFrontFace,</span>
<span class="line-modified">!         Lexer::Token::Type::SVSampleIndex,</span>
<span class="line-modified">!         Lexer::Token::Type::SVInnerCoverage,</span>
<span class="line-modified">!         Lexer::Token::Type::SVTarget,</span>
<span class="line-modified">!         Lexer::Token::Type::SVDepth,</span>
<span class="line-modified">!         Lexer::Token::Type::SVCoverage,</span>
<span class="line-modified">!         Lexer::Token::Type::SVDispatchThreadID,</span>
<span class="line-modified">!         Lexer::Token::Type::SVGroupID,</span>
<span class="line-modified">!         Lexer::Token::Type::SVGroupIndex,</span>
<span class="line-modified">!         Lexer::Token::Type::SVGroupThreadID});</span>
      if (!origin)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      switch (origin-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::SVInstanceID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVVertexID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified">!     case Lexer::Token::Type::PSize:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVPosition:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVIsFrontFace:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVSampleIndex:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVInnerCoverage:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVTarget: {</span>
<span class="line-modified">!         auto target = consumeNonNegativeIntegralLiteral();</span>
          if (!target)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(target.error());</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Lexer::Token::Type::SVDepth:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVCoverage:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVDispatchThreadID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVGroupID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified">!     case Lexer::Token::Type::SVGroupIndex:</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
      default:
<span class="line-modified">!         ASSERT(origin-&gt;type == Lexer::Token::Type::SVGroupThreadID);</span>
<span class="line-modified">!         return AST::BuiltInSemantic(WTFMove(*origin), AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
      }
  }
  
  auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Register);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">!     if (!leftParenthesis)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto info = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!info)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(info.error());</span>
<span class="line-removed">-     if (info-&gt;stringView.length() &lt; 2 || (info-&gt;stringView[0] != &#39;u&#39;</span>
<span class="line-removed">-         &amp;&amp; info-&gt;stringView[0] != &#39;t&#39;</span>
<span class="line-removed">-         &amp;&amp; info-&gt;stringView[0] != &#39;b&#39;</span>
<span class="line-removed">-         &amp;&amp; info-&gt;stringView[0] != &#39;s&#39;))</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(Error(makeString(info-&gt;stringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>
  
      AST::ResourceSemantic::Mode mode;
<span class="line-modified">!     switch (info-&gt;stringView[0]) {</span>
      case &#39;u&#39;:
          mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
          break;
      case &#39;t&#39;:
          mode = AST::ResourceSemantic::Mode::Texture;
<span class="line-new-header">--- 353,341 ---</span>
      if (result)
          return *result;
      return fail(&quot;int literal is negative&quot;_str);
  }
  
<span class="line-modified">! static Expected&lt;unsigned, Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)</span>
  {
      unsigned result = 0;
      if (stringView.length() &lt; 1)
<span class="line-modified">!         return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));</span>
      for (auto codePoint : stringView.codePoints()) {
          if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));</span>
          auto previous = result;
          result = result * 10 + (codePoint - &#39;0&#39;);
          if (result &lt; previous)
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));</span>
      }
      return result;
  }
  
  auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
  {
<span class="line-modified">!     auto type = consumeTypes&lt;</span>
<span class="line-modified">!         Token::Type::IntLiteral,</span>
<span class="line-modified">!         Token::Type::UintLiteral,</span>
<span class="line-modified">!         Token::Type::FloatLiteral,</span>
<span class="line-modified">!         Token::Type::Null,</span>
<span class="line-modified">!         Token::Type::True,</span>
<span class="line-modified">!         Token::Type::False,</span>
<span class="line-modified">!         Token::Type::Identifier&gt;();</span>
      if (!type)
<span class="line-modified">!         return makeUnexpected(type.error());</span>
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return {{ AST::IntegerLiteral({ *type }, *value) }};</span>
      }
<span class="line-modified">!     case Token::Type::UintLiteral: {</span>
<span class="line-modified">!         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};</span>
      }
<span class="line-modified">!     case Token::Type::FloatLiteral: {</span>
<span class="line-modified">!         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return {{ AST::FloatLiteral({ *type }, *value) }};</span>
      }
<span class="line-modified">!     case Token::Type::Null:</span>
          return { AST::NullLiteral(WTFMove(*type)) };
<span class="line-modified">!     case Token::Type::True:</span>
          return { AST::BooleanLiteral(WTFMove(*type), true) };
<span class="line-modified">!     case Token::Type::False:</span>
          return { AST::BooleanLiteral(WTFMove(*type), false) };
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Token::Type::Identifier);</span>
<span class="line-modified">!         CONSUME_TYPE(fullStop, FullStop);</span>
<span class="line-modified">!         CONSUME_TYPE(next, Identifier);</span>
<span class="line-modified">!         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };</span>
      }
      }
  }
  
  auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
  {
<span class="line-modified">!     PEEK(nextToken);</span>
<span class="line-modified">!     PEEK_FURTHER(furtherToken);</span>
<span class="line-modified">!     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {</span>
<span class="line-modified">!         PARSE(constantExpression, ConstantExpression);</span>
          return AST::TypeArgument(WTFMove(*constantExpression));
<span class="line-modified">!     }</span>
<span class="line-modified">!     CONSUME_TYPE(result, Identifier);</span>
<span class="line-modified">!     CodeLocation location(*result);</span>
<span class="line-modified">!     return AST::TypeArgument(AST::TypeReference::create(location, result-&gt;stringView(m_lexer).toString(), AST::TypeArguments()));</span>
  }
  
  auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
  {
<span class="line-modified">!     AST::TypeArguments typeArguments;</span>
<span class="line-modified">!     auto lessThanSign = tryType(Token::Type::LessThanSign);</span>
<span class="line-modified">!     if (!lessThanSign)</span>
          return typeArguments;
  
<span class="line-modified">!     auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified">!     if (greaterThanSign)</span>
<span class="line-modified">!         return typeArguments;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     PARSE(typeArgument, TypeArgument);</span>
<span class="line-modified">!     typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto greaterThanSign = tryType(Token::Type::GreaterThanSign);</span>
<span class="line-modified">!         if (greaterThanSign)</span>
<span class="line-modified">!             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         CONSUME_TYPE(comma, Comma);</span>
<span class="line-added">+         PARSE(typeArgument, TypeArgument);</span>
<span class="line-added">+         typeArguments.append(WTFMove(*typeArgument));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return typeArguments;</span>
  }
  
  auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
  {
<span class="line-modified">!     auto token = consumeTypes&lt;</span>
<span class="line-added">+         Token::Type::Star,</span>
<span class="line-added">+         Token::Type::SquareBracketPair,</span>
<span class="line-added">+         Token::Type::LeftSquareBracket&gt;();</span>
      if (!token)
<span class="line-modified">!         return makeUnexpected(token.error());</span>
<span class="line-modified">!     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
          auto numElements = consumeNonNegativeIntegralLiteral();
          if (!numElements)
<span class="line-modified">!             return makeUnexpected(numElements.error());</span>
<span class="line-modified">!         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified">!         return {{ { *token, *rightSquareBracket }, *token, *numElements }};</span>
      }
<span class="line-modified">!     return {{ { *token }, *token, WTF::nullopt }};</span>
  }
  
  auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
  {
<span class="line-modified">!     auto token = consumeTypes&lt;</span>
<span class="line-added">+         Token::Type::Star,</span>
<span class="line-added">+         Token::Type::SquareBracketPair,</span>
<span class="line-added">+         Token::Type::LeftSquareBracket&gt;();</span>
      if (!token)
<span class="line-modified">!         return makeUnexpected(token.error());</span>
<span class="line-modified">!     if (token-&gt;type == Token::Type::LeftSquareBracket) {</span>
          auto numElements = consumeNonNegativeIntegralLiteral();
          if (!numElements)
<span class="line-modified">!             return makeUnexpected(numElements.error());</span>
<span class="line-modified">!         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);</span>
<span class="line-modified">!         return {{ { *token, *rightSquareBracket }, *token, WTF::nullopt, *numElements }};</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     auto addressSpaceToken = consumeTypes&lt;</span>
<span class="line-modified">!         Token::Type::Constant,</span>
<span class="line-modified">!         Token::Type::Device,</span>
<span class="line-added">+         Token::Type::Threadgroup,</span>
<span class="line-added">+         Token::Type::Thread&gt;();</span>
      if (!addressSpaceToken)
<span class="line-modified">!         return makeUnexpected(addressSpaceToken.error());</span>
      AST::AddressSpace addressSpace;
      switch (addressSpaceToken-&gt;type) {
<span class="line-modified">!     case Token::Type::Constant:</span>
          addressSpace = AST::AddressSpace::Constant;
          break;
<span class="line-modified">!     case Token::Type::Device:</span>
          addressSpace = AST::AddressSpace::Device;
          break;
<span class="line-modified">!     case Token::Type::Threadgroup:</span>
          addressSpace = AST::AddressSpace::Threadgroup;
          break;
      default:
<span class="line-modified">!         ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
          addressSpace = AST::AddressSpace::Thread;
          break;
      }
<span class="line-modified">!     return {{ { *token }, *token, { addressSpace }, WTF::nullopt }};</span>
  }
  
<span class="line-modified">! auto Parser::parseType() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt;</span>
  {
<span class="line-modified">!     auto addressSpaceToken = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::Constant,</span>
<span class="line-modified">!         Token::Type::Device,</span>
<span class="line-modified">!         Token::Type::Threadgroup,</span>
<span class="line-modified">!         Token::Type::Thread&gt;();</span>
  
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (addressSpaceToken) {</span>
<span class="line-modified">!         AST::AddressSpace addressSpace;</span>
<span class="line-modified">!         switch (addressSpaceToken-&gt;type) {</span>
<span class="line-modified">!         case Token::Type::Constant:</span>
<span class="line-modified">!             addressSpace = AST::AddressSpace::Constant;</span>
              break;
<span class="line-modified">!         case Token::Type::Device:</span>
<span class="line-modified">!             addressSpace = AST::AddressSpace::Device;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case Token::Type::Threadgroup:</span>
<span class="line-added">+             addressSpace = AST::AddressSpace::Threadgroup;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);</span>
<span class="line-added">+             addressSpace = AST::AddressSpace::Thread;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-added">+             CodeLocation location(*addressSpaceToken, typeSuffixAbbreviated.location);</span>
<span class="line-added">+             switch (typeSuffixAbbreviated.token.type) {</span>
<span class="line-added">+             case Token::Type::Star:</span>
<span class="line-added">+                 return { AST::PointerType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added">+             case Token::Type::SquareBracketPair:</span>
<span class="line-added">+                 return { AST::ArrayReferenceType::create(location, addressSpace, WTFMove(previous)) };</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 ASSERT(typeSuffixAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-added">+                 return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixAbbreviated.numElements) };</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+         PARSE(firstTypeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added">+         Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(WTFMove(*addressSpaceToken), name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>
<span class="line-added">+         auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));</span>
          result = WTFMove(next);
<span class="line-added">+         while (true) {</span>
<span class="line-added">+             PEEK(nextToken);</span>
<span class="line-added">+             if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-added">+                 &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-added">+                 &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             PARSE(typeSuffixAbbreviated, TypeSuffixAbbreviated);</span>
<span class="line-added">+             // FIXME: The nesting here might be in the wrong order.</span>
<span class="line-added">+             next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));</span>
<span class="line-added">+             result = WTFMove(next);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return WTFMove(result);</span>
      }
  
<span class="line-modified">!     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {</span>
<span class="line-modified">!         CodeLocation location(*name, typeSuffixNonAbbreviated.location);</span>
          switch (typeSuffixNonAbbreviated.token.type) {
<span class="line-modified">!         case Token::Type::Star:</span>
<span class="line-modified">!             return { AST::PointerType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
<span class="line-modified">!         case Token::Type::SquareBracketPair:</span>
<span class="line-modified">!             return { AST::ArrayReferenceType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };</span>
          default:
<span class="line-modified">!             ASSERT(typeSuffixNonAbbreviated.token.type == Token::Type::LeftSquareBracket);</span>
<span class="line-modified">!             return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };</span>
          }
      };
<span class="line-modified">!     Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(*name, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>
      while (true) {
<span class="line-modified">!         PEEK(nextToken);</span>
<span class="line-modified">!         if (nextToken-&gt;type != Token::Type::Star</span>
<span class="line-modified">!             &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair</span>
<span class="line-modified">!             &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {</span>
              break;
<span class="line-added">+         }</span>
<span class="line-added">+         PARSE(typeSuffixNonAbbreviated, TypeSuffixNonAbbreviated);</span>
          // FIXME: The nesting here might be in the wrong order.
          auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
          result = WTFMove(next);
      }
      return WTFMove(result);
  }
  
  auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Typedef);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     CONSUME_TYPE(equals, EqualsSign);</span>
<span class="line-modified">!     PARSE(type, Type);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!     return AST::TypeDefinition({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>
  }
  
  auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeTypes&lt;</span>
<span class="line-modified">!         Token::Type::SVInstanceID,</span>
<span class="line-modified">!         Token::Type::SVVertexID,</span>
<span class="line-modified">!         Token::Type::PSize,</span>
<span class="line-modified">!         Token::Type::SVPosition,</span>
<span class="line-modified">!         Token::Type::SVIsFrontFace,</span>
<span class="line-modified">!         Token::Type::SVSampleIndex,</span>
<span class="line-modified">!         Token::Type::SVInnerCoverage,</span>
<span class="line-modified">!         Token::Type::SVTarget,</span>
<span class="line-modified">!         Token::Type::SVDepth,</span>
<span class="line-modified">!         Token::Type::SVCoverage,</span>
<span class="line-modified">!         Token::Type::SVDispatchThreadID,</span>
<span class="line-modified">!         Token::Type::SVGroupID,</span>
<span class="line-modified">!         Token::Type::SVGroupIndex,</span>
<span class="line-modified">!         Token::Type::SVGroupThreadID&gt;();</span>
      if (!origin)
<span class="line-modified">!         return makeUnexpected(origin.error());</span>
  
      switch (origin-&gt;type) {
<span class="line-modified">!     case Token::Type::SVInstanceID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInstanceID);</span>
<span class="line-modified">!     case Token::Type::SVVertexID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVVertexID);</span>
<span class="line-modified">!     case Token::Type::PSize:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::PSize);</span>
<span class="line-modified">!     case Token::Type::SVPosition:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVPosition);</span>
<span class="line-modified">!     case Token::Type::SVIsFrontFace:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVIsFrontFace);</span>
<span class="line-modified">!     case Token::Type::SVSampleIndex:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVSampleIndex);</span>
<span class="line-modified">!     case Token::Type::SVInnerCoverage:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInnerCoverage);</span>
<span class="line-modified">!     case Token::Type::SVTarget: {</span>
<span class="line-modified">!         auto target = consumeNonNegativeIntegralLiteral(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195807 Make this work with strings like &quot;SV_Target0&quot;.</span>
          if (!target)
<span class="line-modified">!             return makeUnexpected(target.error());</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVTarget, *target);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::SVDepth:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDepth);</span>
<span class="line-modified">!     case Token::Type::SVCoverage:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVCoverage);</span>
<span class="line-modified">!     case Token::Type::SVDispatchThreadID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDispatchThreadID);</span>
<span class="line-modified">!     case Token::Type::SVGroupID:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupID);</span>
<span class="line-modified">!     case Token::Type::SVGroupIndex:</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupIndex);</span>
      default:
<span class="line-modified">!         ASSERT(origin-&gt;type == Token::Type::SVGroupThreadID);</span>
<span class="line-modified">!         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupThreadID);</span>
      }
  }
  
  auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Register);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
  
<span class="line-modified">!     CONSUME_TYPE(info, Identifier);</span>
<span class="line-modified">!     auto infoStringView = info-&gt;stringView(m_lexer);</span>
<span class="line-modified">!     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;</span>
<span class="line-modified">!         &amp;&amp; infoStringView[0] != &#39;t&#39;</span>
<span class="line-modified">!         &amp;&amp; infoStringView[0] != &#39;b&#39;</span>
<span class="line-modified">!         &amp;&amp; infoStringView[0] != &#39;s&#39;))</span>
<span class="line-modified">!         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));</span>
  
      AST::ResourceSemantic::Mode mode;
<span class="line-modified">!     switch (infoStringView[0]) {</span>
      case &#39;u&#39;:
          mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
          break;
      case &#39;t&#39;:
          mode = AST::ResourceSemantic::Mode::Texture;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,1873 ***</span>
      case &#39;s&#39;:
          mode = AST::ResourceSemantic::Mode::Sampler;
          break;
      }
  
<span class="line-modified">!     auto index = recognizeSimpleUnsignedInteger(info-&gt;stringView.substring(1));</span>
      if (!index)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(index.error());</span>
  
      unsigned space = 0;
<span class="line-modified">!     if (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto spaceToken = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!         if (!spaceToken)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(spaceToken.error());</span>
<span class="line-modified">!         auto prefix = &quot;space&quot;_str;</span>
<span class="line-modified">!         if (!spaceToken-&gt;stringView.startsWith(StringView(prefix)))</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified">!         if (spaceToken-&gt;stringView.length() &lt;= prefix.length())</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceToken-&gt;stringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-removed">-         auto spaceValue = recognizeSimpleUnsignedInteger(spaceToken-&gt;stringView.substring(prefix.length()));</span>
          if (!spaceValue)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(spaceValue.error());</span>
          space = *spaceValue;
      }
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     return AST::ResourceSemantic(WTFMove(*origin), mode, *index, space);</span>
  }
  
  auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Specialized);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">-     return AST::SpecializationConstantSemantic(WTFMove(*origin));</span>
  }
  
  auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Attribute);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
  
      auto index = consumeNonNegativeIntegralLiteral();
      if (!index)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(index.error());</span>
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     return AST::StageInOutSemantic(WTFMove(*origin), *index);</span>
  }
  
<span class="line-modified">! auto Parser::parseSemantic() -&gt; Expected&lt;AST::Semantic, Error&gt;</span>
  {
<span class="line-modified">!     auto builtInSemantic = backtrackingScope&lt;Expected&lt;AST::BuiltInSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseBuiltInSemantic();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (builtInSemantic)</span>
<span class="line-removed">-         return AST::Semantic(WTFMove(*builtInSemantic));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto resourceSemantic = backtrackingScope&lt;Expected&lt;AST::ResourceSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseResourceSemantic();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (resourceSemantic)</span>
<span class="line-removed">-         return AST::Semantic(WTFMove(*resourceSemantic));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto specializationConstantSemantic = backtrackingScope&lt;Expected&lt;AST::SpecializationConstantSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseSpecializationConstantSemantic();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (specializationConstantSemantic)</span>
<span class="line-removed">-         return AST::Semantic(WTFMove(*specializationConstantSemantic));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto stageInOutSemantic = backtrackingScope&lt;Expected&lt;AST::StageInOutSemantic, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseStageInOutSemantic();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (stageInOutSemantic)</span>
<span class="line-removed">-         return AST::Semantic(WTFMove(*stageInOutSemantic));</span>
  
<span class="line-modified">!     return Unexpected&lt;Error&gt;(stageInOutSemantic.error());</span>
  }
  AST::Qualifiers Parser::parseQualifiers()
  {
      AST::Qualifiers qualifiers;
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         if (auto next = tryType(Lexer::Token::Type::Qualifier)) {</span>
<span class="line-modified">!             if (&quot;nointerpolation&quot; == next-&gt;stringView)</span>
<span class="line-modified">!                 qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified">!             else if (&quot;noperspective&quot; == next-&gt;stringView)</span>
<span class="line-modified">!                 qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified">!             else if (&quot;uniform&quot; == next-&gt;stringView)</span>
<span class="line-modified">!                 qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified">!             else if (&quot;centroid&quot; == next-&gt;stringView)</span>
<span class="line-modified">!                 qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 ASSERT(&quot;sample&quot; == next-&gt;stringView);</span>
<span class="line-modified">!                 qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             break;</span>
      }
      return qualifiers;
  }
  
  auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      AST::Qualifiers qualifiers = parseQualifiers();
  
<span class="line-modified">!     auto type = parseType();</span>
<span class="line-modified">!     if (!type)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">-         auto semantic = parseSemantic();</span>
<span class="line-removed">-         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-         if (!semicolon)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semicolon.error());</span>
  
<span class="line-modified">!         return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*semantic));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-     if (!semicolon)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::StructureElement(WTFMove(*origin), WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView.toString(), WTF::nullopt);</span>
  }
  
  auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Struct);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed">-     if (!leftCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
  
      AST::StructureElements structureElements;
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto structureElement = backtrackingScope&lt;Expected&lt;AST::StructureElement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseStructureElement();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (structureElement)</span>
<span class="line-removed">-             structureElements.append(WTFMove(*structureElement));</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             break;</span>
      }
  
<span class="line-modified">!     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">-     if (!rightCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
  
<span class="line-modified">!     return AST::StructureDefinition(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(structureElements));</span>
  }
  
  auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Enum);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
  
<span class="line-modified">!     auto type = ([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified">!         if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified">!             auto parsedType = parseType();</span>
<span class="line-removed">-             if (!parsedType)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(parsedType.error());</span>
              return WTFMove(*parsedType);
          }
<span class="line-modified">!         return { makeUniqueRef&lt;AST::TypeReference&gt;(Lexer::Token(*origin), &quot;int&quot;_str, AST::TypeArguments()) };</span>
      })();
      if (!type)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(type.error());</span>
  
<span class="line-modified">!     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-removed">-     if (!leftCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
  
<span class="line-modified">!     auto firstEnumerationMember = parseEnumerationMember();</span>
<span class="line-modified">!     if (!firstEnumerationMember)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(firstEnumerationMember.error());</span>
  
<span class="line-modified">!     AST::EnumerationDefinition result(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*type));</span>
      auto success = result.add(WTFMove(*firstEnumerationMember));
      if (!success)
          return fail(&quot;Cannot add enumeration member&quot;_str);
  
<span class="line-modified">!     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto member = parseEnumerationMember();</span>
<span class="line-modified">!         if (!member)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(member.error());</span>
          success = result.add(WTFMove(*member));
          if (!success)
              return fail(&quot;Cannot add enumeration member&quot;_str);
      }
  
<span class="line-modified">!     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-modified">!     if (!rightCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
  
      return WTFMove(result);
  }
  
<span class="line-modified">! auto Parser::parseEnumerationMember() -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
  {
<span class="line-modified">!     auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!identifier)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(identifier.error());</span>
<span class="line-modified">!     auto name = identifier-&gt;stringView.toString();</span>
  
<span class="line-modified">!     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified">!         auto constantExpression = parseConstantExpression();</span>
<span class="line-modified">!         if (!constantExpression)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(constantExpression.error());</span>
<span class="line-modified">!         return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name), WTFMove(*constantExpression));</span>
      }
<span class="line-modified">!     return AST::EnumerationMember(Lexer::Token(*identifier), WTFMove(name));</span>
  }
  
  auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto parsedTypedef = consumeType(Lexer::Token::Type::Typedef);</span>
<span class="line-removed">-     if (!parsedTypedef)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(parsedTypedef.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-removed">-     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
  
<span class="line-modified">!     auto typeArguments = parseTypeArguments();</span>
<span class="line-removed">-     if (!typeArguments)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(typeArguments.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-     if (!semicolon)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::NativeTypeDeclaration(WTFMove(*origin), name-&gt;stringView.toString(), WTFMove(*typeArguments));</span>
  }
  
  auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::NumThreads);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
  
      auto width = consumeNonNegativeIntegralLiteral();
      if (!width)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(width.error());</span>
  
<span class="line-modified">!     auto comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed">-     if (!comma)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(comma.error());</span>
  
      auto height = consumeNonNegativeIntegralLiteral();
      if (!height)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(height.error());</span>
  
<span class="line-modified">!     comma = consumeType(Lexer::Token::Type::Comma);</span>
<span class="line-removed">-     if (!comma)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(comma.error());</span>
  
      auto depth = consumeNonNegativeIntegralLiteral();
      if (!depth)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(depth.error());</span>
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     return AST::NumThreadsFunctionAttribute(WTFMove(*origin), *width, *height, *depth);</span>
  }
  
  auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
  {
<span class="line-modified">!     auto leftSquareBracket = consumeType(Lexer::Token::Type::LeftSquareBracket);</span>
<span class="line-removed">-     if (!leftSquareBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftSquareBracket.error());</span>
  
      AST::AttributeBlock result;
  
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto numThreadsFunctionAttribute = backtrackingScope&lt;Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseNumThreadsFunctionAttribute();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (numThreadsFunctionAttribute) {</span>
<span class="line-removed">-             result.append(WTFMove(*numThreadsFunctionAttribute));</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         break;</span>
      }
  
<span class="line-removed">-     auto rightSquareBracket = consumeType(Lexer::Token::Type::RightSquareBracket);</span>
<span class="line-removed">-     if (!rightSquareBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightSquareBracket.error());</span>
<span class="line-removed">- </span>
      return WTFMove(result);
  }
  
  auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      AST::Qualifiers qualifiers = parseQualifiers();
<span class="line-modified">! </span>
<span class="line-removed">-     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
  
      String name;
<span class="line-modified">!     if (auto token = tryType(Lexer::Token::Type::Identifier))</span>
<span class="line-modified">!         name = token-&gt;stringView.toString();</span>
  
<span class="line-modified">!     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-modified">!         auto semantic = parseSemantic();</span>
<span class="line-modified">!         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">-         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), Optional&lt;UniqueRef&lt;AST::UnnamedType&gt;&gt;(WTFMove(*type)), WTFMove(name), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTF::nullopt, WTF::nullopt);</span>
  }
  
  auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
  {
<span class="line-removed">-     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
      AST::VariableDeclarations parameters;
<span class="line-modified">!     if (tryType(Lexer::Token::Type::RightParenthesis))</span>
          return WTFMove(parameters);
  
<span class="line-modified">!     auto firstParameter = parseParameter();</span>
<span class="line-modified">!     if (!firstParameter)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(firstParameter.error());</span>
<span class="line-removed">-     parameters.append(WTFMove(*firstParameter));</span>
  
<span class="line-modified">!     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto parameter = parseParameter();</span>
<span class="line-modified">!         if (!parameter)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(parameter.error());</span>
<span class="line-removed">-         parameters.append(WTFMove(*parameter));</span>
      }
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
      return WTFMove(parameters);
  }
  
  auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
  {
<span class="line-modified">!     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-modified">!     if (!functionDeclaration)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto block = parseBlock();</span>
<span class="line-removed">-     if (!block)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(block.error());</span>
<span class="line-removed">- </span>
      return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
  }
  
<span class="line-modified">! auto Parser::parseEntryPointFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     AST::AttributeBlock attributeBlock;</span>
<span class="line-modified">!     AST::EntryPointType entryPointType;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto parsedAttributeBlock = backtrackingScope&lt;Expected&lt;AST::AttributeBlock, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseAttributeBlock();</span>
<span class="line-modified">!     });</span>
<span class="line-removed">-     if (parsedAttributeBlock) {</span>
<span class="line-removed">-         auto compute = consumeType(Lexer::Token::Type::Compute);</span>
<span class="line-removed">-         if (!compute)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(compute.error());</span>
<span class="line-removed">-         attributeBlock = WTFMove(*parsedAttributeBlock);</span>
<span class="line-removed">-         entryPointType = AST::EntryPointType::Compute;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         auto type = consumeTypes({ Lexer::Token::Type::Vertex, Lexer::Token::Type::Fragment });</span>
<span class="line-removed">-         if (!type)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(type.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (origin-&gt;type) {</span>
<span class="line-removed">-         case Lexer::Token::Type::Vertex:</span>
<span class="line-removed">-             entryPointType = AST::EntryPointType::Vertex;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             ASSERT(origin-&gt;type == Lexer::Token::Type::Fragment);</span>
<span class="line-removed">-             entryPointType = AST::EntryPointType::Fragment;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
  
<span class="line-modified">!     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!name)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(name.error());</span>
  
<span class="line-modified">!     auto parameters = parseParameters();</span>
<span class="line-modified">!     if (!parameters)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parameters.error());</span>
  
<span class="line-modified">!     bool isOperator = false;</span>
  
<span class="line-modified">!     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">-         auto semantic = parseSemantic();</span>
<span class="line-removed">-         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">-         return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return AST::FunctionDeclaration(WTFMove(*origin), WTFMove(attributeBlock), entryPointType, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>
  }
  
  auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
  
<span class="line-modified">!     auto name = consumeTypes({ Lexer::Token::Type::Identifier, Lexer::Token::Type::OperatorName });</span>
      if (!name)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-modified">!     auto isOperator = name-&gt;type == Lexer::Token::Type::OperatorName;</span>
  
<span class="line-modified">!     auto parameters = parseParameters();</span>
<span class="line-modified">!     if (!parameters)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(parameters.error());</span>
  
<span class="line-modified">!     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">-         auto semantic = parseSemantic();</span>
<span class="line-removed">-         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">-         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView.toString(), WTFMove(*parameters), WTF::nullopt, isOperator);</span>
  }
  
  auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Operator);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
  
<span class="line-modified">!     auto parameters = parseParameters();</span>
<span class="line-removed">-     if (!parameters)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(parameters.error());</span>
  
      bool isOperator = true;
<span class="line-modified">! </span>
<span class="line-removed">-     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">-         auto semantic = parseSemantic();</span>
<span class="line-removed">-         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">-         return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::FunctionDeclaration(WTFMove(*origin), { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTF::nullopt, isOperator);</span>
  }
  
  auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     auto entryPointFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseEntryPointFunctionDeclaration();</span>
<span class="line-modified">!     });</span>
<span class="line-removed">-     if (entryPointFunctionDeclaration)</span>
<span class="line-removed">-         return WTFMove(*entryPointFunctionDeclaration);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto regularFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseRegularFunctionDeclaration();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (regularFunctionDeclaration)</span>
<span class="line-removed">-         return WTFMove(*regularFunctionDeclaration);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto operatorFunctionDeclaration = backtrackingScope&lt;Expected&lt;AST::FunctionDeclaration, Error&gt;&gt;([&amp;]() {</span>
          return parseOperatorFunctionDeclaration();
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (operatorFunctionDeclaration)</span>
<span class="line-modified">!         return WTFMove(*operatorFunctionDeclaration);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return Unexpected&lt;Error&gt;(operatorFunctionDeclaration.error());</span>
  }
  
  auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     Optional&lt;Lexer::Token&gt; origin;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto native = consumeType(Lexer::Token::Type::Native);</span>
<span class="line-removed">-     if (!native)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(native.error());</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         origin = *native;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto functionDeclaration = parseFunctionDeclaration();</span>
<span class="line-removed">-     if (!functionDeclaration)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(functionDeclaration.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-     if (!semicolon)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(semicolon.error());</span>
  
      return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
  }
  
  auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto result = parseBlockBody(WTFMove(*origin));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">-     if (!rightCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return WTFMove(result);</span>
  }
  
<span class="line-modified">! AST::Block Parser::parseBlockBody(Lexer::Token&amp;&amp; origin)</span>
  {
      AST::Statements statements;
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         auto statement = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseStatement();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (statement)</span>
<span class="line-removed">-             statements.append(WTFMove(*statement));</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             break;</span>
      }
<span class="line-modified">!     return AST::Block(WTFMove(origin), WTFMove(statements));</span>
  }
  
  auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::If);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto conditional = parseExpression();</span>
<span class="line-removed">-     if (!conditional)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto body = parseStatement();</span>
<span class="line-removed">-     if (!body)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(body.error());</span>
  
<span class="line-modified">!     Optional&lt;UniqueRef&lt;AST::Statement&gt;&gt; elseBody;</span>
<span class="line-modified">!     if (tryType(Lexer::Token::Type::Else)) {</span>
<span class="line-modified">!         auto parsedElseBody = parseStatement();</span>
<span class="line-modified">!         if (!parsedElseBody)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(parsedElseBody.error());</span>
<span class="line-removed">-         elseBody = WTFMove(*parsedElseBody);</span>
      }
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
      castArguments.append(WTFMove(*conditional));
<span class="line-modified">!     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!     return AST::IfStatement(WTFMove(*origin), WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
  }
  
  auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Switch);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">!     if (!leftParenthesis)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
  
<span class="line-modified">!     auto value = parseExpression();</span>
<span class="line-removed">-     if (!value)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(value.error());</span>
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">!     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     auto leftCurlyBracket = consumeType(Lexer::Token::Type::LeftCurlyBracket);</span>
<span class="line-modified">!     if (!leftCurlyBracket)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(leftCurlyBracket.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-removed">-     while (true) {</span>
<span class="line-removed">-         auto switchCase = backtrackingScope&lt;Expected&lt;AST::SwitchCase, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-             return parseSwitchCase();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (switchCase)</span>
<span class="line-removed">-             switchCases.append(WTFMove(*switchCase));</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto rightCurlyBracket = consumeType(Lexer::Token::Type::RightCurlyBracket);</span>
<span class="line-removed">-     if (!rightCurlyBracket)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightCurlyBracket.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::SwitchStatement(WTFMove(*origin), WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto origin = consumeTypes({ Lexer::Token::Type::Case, Lexer::Token::Type::Default });</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      switch (origin-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::Case: {</span>
<span class="line-modified">!         auto value = parseConstantExpression();</span>
<span class="line-modified">!         if (!value)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(value.error());</span>
  
<span class="line-modified">!         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">-         if (!origin)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!         auto block = parseBlockBody(Lexer::Token(*origin));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return AST::SwitchCase(WTFMove(*origin), WTFMove(*value), WTFMove(block));</span>
      }
      default: {
<span class="line-modified">!         ASSERT(origin-&gt;type == Lexer::Token::Type::Default);</span>
<span class="line-modified">!         auto origin = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">-         if (!origin)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!         auto block = parseBlockBody(Lexer::Token(*origin));</span>
  
<span class="line-modified">!         return AST::SwitchCase(WTFMove(*origin), WTF::nullopt, WTFMove(block));</span>
      }
      }
  }
  
  auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::For);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     auto parseRemainder = [&amp;](Variant&lt;AST::VariableDeclarationsStatement, UniqueRef&lt;AST::Expression&gt;&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">!         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-         if (!semicolon)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semicolon.error());</span>
  
<span class="line-modified">!         auto condition = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>
              if (auto expression = parseExpression())
<span class="line-modified">!                 return { WTFMove(*expression) };</span>
<span class="line-modified">!             return WTF::nullopt;</span>
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-         if (!semicolon)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semicolon.error());</span>
  
<span class="line-modified">!         auto increment = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>
              if (auto expression = parseExpression())
<span class="line-modified">!                 return { WTFMove(*expression) };</span>
<span class="line-modified">!             return WTF::nullopt;</span>
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-         if (!rightParenthesis)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto body = parseStatement();</span>
<span class="line-removed">-         if (!body)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(body.error());</span>
  
<span class="line-modified">!         return AST::ForLoop(WTFMove(*origin), WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>
      };
  
<span class="line-removed">-     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
      auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
          return parseVariableDeclarations();
      });
<span class="line-modified">!     if (variableDeclarations)</span>
<span class="line-modified">!         return parseRemainder(WTFMove(*variableDeclarations));</span>
  
<span class="line-modified">!     auto effectfulExpression = parseEffectfulExpression();</span>
<span class="line-removed">-     if (!effectfulExpression)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
  
      return parseRemainder(WTFMove(*effectfulExpression));
  }
  
  auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::While);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto conditional = parseExpression();</span>
<span class="line-removed">-     if (!conditional)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     auto body = parseStatement();</span>
<span class="line-modified">!     if (!body)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::WhileLoop(WTFMove(*origin), WTFMove(*conditional), WTFMove(*body));</span>
  }
  
  auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
  {
<span class="line-modified">!     auto origin = consumeType(Lexer::Token::Type::Do);</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto body = parseStatement();</span>
<span class="line-modified">!     if (!body)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(body.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto whileKeyword = consumeType(Lexer::Token::Type::While);</span>
<span class="line-removed">-     if (!whileKeyword)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(whileKeyword.error());</span>
  
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto conditional = parseExpression();</span>
<span class="line-removed">-     if (!conditional)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(conditional.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return AST::DoWhileLoop(WTFMove(*origin), WTFMove(*body), WTFMove(*conditional));</span>
  }
  
<span class="line-modified">! auto Parser::parseVariableDeclaration(UniqueRef&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      auto qualifiers = parseQualifiers();
  
<span class="line-modified">!     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (tryType(Lexer::Token::Type::Colon)) {</span>
<span class="line-removed">-         auto semantic = parseSemantic();</span>
<span class="line-removed">-         if (!semantic)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semantic.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-removed">-             auto initializer = parseExpression();</span>
<span class="line-removed">-             if (!initializer)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">-             return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTFMove(*initializer));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTFMove(*semantic), WTF::nullopt);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (tryType(Lexer::Token::Type::EqualsSign)) {</span>
<span class="line-modified">!         auto initializer = parseExpression();</span>
<span class="line-modified">!         if (!initializer)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(initializer.error());</span>
<span class="line-removed">-         return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTFMove(*initializer));</span>
      }
  
<span class="line-modified">!     return AST::VariableDeclaration(WTFMove(*origin), WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView.toString(), WTF::nullopt, WTF::nullopt);</span>
  }
  
  auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
  
<span class="line-modified">!     auto type = parseType();</span>
<span class="line-removed">-     if (!type)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(type.error());</span>
  
<span class="line-modified">!     auto firstVariableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
      if (!firstVariableDeclaration)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(firstVariableDeclaration.error());</span>
  
<span class="line-modified">!     Vector&lt;AST::VariableDeclaration&gt; result;</span>
<span class="line-modified">!     result.append(WTFMove(*firstVariableDeclaration));</span>
  
<span class="line-modified">!     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto variableDeclaration = parseVariableDeclaration((*type)-&gt;clone());</span>
          if (!variableDeclaration)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(variableDeclaration.error());</span>
<span class="line-modified">!         result.append(WTFMove(*variableDeclaration));</span>
      }
  
<span class="line-modified">!     return AST::VariableDeclarationsStatement(WTFMove(*origin), WTFMove(result));</span>
  }
  
  auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
  {
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto block = backtrackingScope&lt;Expected&lt;AST::Block, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseBlock();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (block)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto ifStatement = backtrackingScope&lt;Expected&lt;AST::IfStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseIfStatement();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (ifStatement)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto switchStatement = backtrackingScope&lt;Expected&lt;AST::SwitchStatement, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseSwitchStatement();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (switchStatement)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto forLoop = backtrackingScope&lt;Expected&lt;AST::ForLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseForLoop();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (forLoop)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto whileLoop = backtrackingScope&lt;Expected&lt;AST::WhileLoop, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!             return parseWhileLoop();</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (whileLoop)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto doWhileLoop = backtrackingScope&lt;Expected&lt;AST::DoWhileLoop, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt; {</span>
<span class="line-modified">!             auto result = parseDoWhileLoop();</span>
<span class="line-modified">!             if (!result)</span>
<span class="line-modified">!                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">!             if (!semicolon)</span>
<span class="line-modified">!                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             return result;</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (doWhileLoop)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto breakObject = backtrackingScope&lt;Expected&lt;AST::Break, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Break, Error&gt; {</span>
<span class="line-modified">!             auto origin = consumeType(Lexer::Token::Type::Break);</span>
<span class="line-modified">!             if (!origin)</span>
<span class="line-modified">!                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-modified">!             if (!semicolon)</span>
<span class="line-modified">!                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             return AST::Break(WTFMove(*origin));</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         if (breakObject)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(*breakObject)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto continueObject = backtrackingScope&lt;Expected&lt;AST::Continue, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Continue, Error&gt; {</span>
<span class="line-modified">!             auto origin = consumeType(Lexer::Token::Type::Continue);</span>
<span class="line-modified">!             if (!origin)</span>
<span class="line-modified">!                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-removed">-             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-             if (!semicolon)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return AST::Continue(WTFMove(*origin));</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (continueObject)</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(*continueObject)) };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         auto fallthroughObject = backtrackingScope&lt;Expected&lt;AST::Fallthrough, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Fallthrough, Error&gt; {</span>
<span class="line-removed">-             auto origin = consumeType(Lexer::Token::Type::Fallthrough);</span>
<span class="line-removed">-             if (!origin)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-             if (!semicolon)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return AST::Fallthrough(WTFMove(*origin));</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (fallthroughObject)</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(*fallthroughObject)) };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         auto trapObject = backtrackingScope&lt;Expected&lt;AST::Trap, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Trap, Error&gt; {</span>
<span class="line-removed">-             auto origin = consumeType(Lexer::Token::Type::Trap);</span>
<span class="line-removed">-             if (!origin)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-             if (!semicolon)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return AST::Trap(WTFMove(*origin));</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (trapObject)</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::Trap&gt;(WTFMove(*trapObject)) };</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         auto returnObject = backtrackingScope&lt;Expected&lt;AST::Return, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::Return, Error&gt; {</span>
<span class="line-removed">-             auto origin = consumeType(Lexer::Token::Type::Return);</span>
<span class="line-removed">-             if (!origin)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (auto semicolon = tryType(Lexer::Token::Type::Semicolon))</span>
<span class="line-removed">-                 return AST::Return(WTFMove(*origin), WTF::nullopt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto expression = parseExpression();</span>
<span class="line-removed">-             if (!expression)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-             if (!semicolon)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return AST::Return(WTFMove(*origin), { WTFMove(*expression) });</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         if (returnObject)</span>
<span class="line-removed">-             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(*returnObject)) };</span>
      }
  
      {
<span class="line-modified">!         auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt; {</span>
<span class="line-modified">!             auto result = parseVariableDeclarations();</span>
<span class="line-modified">!             if (!result)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-             if (!semicolon)</span>
<span class="line-removed">-                 return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
              return result;
          });
<span class="line-modified">!         if (variableDeclarations)</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
      }
  
<span class="line-modified">!     auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">!         auto result = parseEffectfulExpression();</span>
<span class="line-modified">!         if (!result)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(result.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto semicolon = consumeType(Lexer::Token::Type::Semicolon);</span>
<span class="line-removed">-         if (!semicolon)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(semicolon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (effectfulExpression)</span>
<span class="line-removed">-         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(*effectfulExpression)) };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return Unexpected&lt;Error&gt;(effectfulExpression.error());</span>
  }
  
<span class="line-modified">! auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
  
<span class="line-modified">!     auto first = backtrackingScope&lt;Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt;&gt;([&amp;]() -&gt; Optional&lt;UniqueRef&lt;AST::Expression&gt;&gt; {</span>
<span class="line-modified">!         auto effectfulExpression = parseEffectfulAssignment();</span>
<span class="line-removed">-         if (!effectfulExpression)</span>
<span class="line-removed">-             return WTF::nullopt;</span>
<span class="line-removed">-         return { WTFMove(*effectfulExpression) };</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (!first)</span>
<span class="line-removed">-         return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     expressions.append(WTFMove(*first));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-removed">-         auto expression = parseEffectfulAssignment();</span>
<span class="line-removed">-         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
          expressions.append(WTFMove(*expression));
      }
  
      if (expressions.size() == 1)
<span class="line-modified">!         return WTFMove(expressions[0]);</span>
<span class="line-modified">!     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>
  }
  
  auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseAssignment();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (assignment)</span>
<span class="line-removed">-         return assignment;</span>
  
<span class="line-modified">!     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseEffectfulPrefix();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (assignment)</span>
<span class="line-removed">-         return assignment;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     assignment = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseCallExpression();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (assignment)</span>
<span class="line-removed">-         return assignment;</span>
  
<span class="line-modified">!     return Unexpected&lt;Error&gt;(assignment.error());</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! auto Parser::parseEffectfulPrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto prefix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-modified">!     if (!prefix)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(prefix.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto previous = parsePossiblePrefix();</span>
<span class="line-modified">!     if (!previous)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     switch (prefix-&gt;type) {</span>
<span class="line-removed">-     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">-         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">-         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">-         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">-         return { WTFMove(result) };</span>
      }
<span class="line-removed">-     default: {</span>
<span class="line-removed">-         ASSERT(prefix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">-         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*previous));</span>
<span class="line-removed">-         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-         callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">-         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">-         result-&gt;setResultExpression(result-&gt;newVariableReference());</span>
<span class="line-removed">-         return { WTFMove(result) };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! auto Parser::parseEffectfulSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">-         auto previous = parsePossibleSuffix();</span>
<span class="line-removed">-         if (!previous)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(previous.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto suffix = consumeTypes({ Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
<span class="line-removed">-         if (!suffix)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(suffix.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (suffix-&gt;type) {</span>
<span class="line-removed">-         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-removed">-             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">-             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">-             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">-             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">-             return { WTFMove(result) };</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         default: {</span>
<span class="line-removed">-             ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-removed">-             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(*previous));</span>
<span class="line-removed">-             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(result-&gt;oldVariableReference());</span>
<span class="line-removed">-             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
<span class="line-removed">-             result-&gt;setResultExpression(result-&gt;oldVariableReference());</span>
<span class="line-removed">-             return { WTFMove(result) };</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (effectfulSuffix)</span>
<span class="line-removed">-         return effectfulSuffix;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseCallExpression();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (effectfulSuffix)</span>
<span class="line-removed">-         return effectfulSuffix;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     effectfulSuffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-removed">-         auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-         if (!leftParenthesis)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto expression = parseExpression();</span>
<span class="line-removed">-         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-         if (!rightParenthesis)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return { WTFMove(*expression) };</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (effectfulSuffix)</span>
<span class="line-removed">-         return effectfulSuffix;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return Unexpected&lt;Error&gt;(effectfulSuffix.error());</span>
  }
  
  auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
  {
<span class="line-modified">!     auto type = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket });</span>
      if (!type)
          return SuffixExpression(WTFMove(previous), false);
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">!         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*type), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">!         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*type), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*type), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>
      }
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Lexer::Token::Type::LeftSquareBracket);</span>
          auto expression = parseExpression();
          if (!expression)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">!             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*type), WTFMove(previous), WTFMove(*expression)), true);</span>
      }
      }
  }
  
  auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
  {
<span class="line-modified">!     auto suffix = consumeTypes({ Lexer::Token::Type::FullStop, Lexer::Token::Type::Arrow, Lexer::Token::Type::LeftSquareBracket, Lexer::Token::Type::PlusPlus, Lexer::Token::Type::MinusMinus });</span>
      if (!suffix)
          return SuffixExpression(WTFMove(previous), false);
  
      switch (suffix-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::FullStop: {</span>
<span class="line-modified">!         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(WTFMove(*suffix), WTFMove(previous), identifier-&gt;stringView.toString()), true);</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::Arrow: {</span>
<span class="line-modified">!         auto identifier = consumeType(Lexer::Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(Lexer::Token(*suffix), makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView.toString()), true);</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::LeftSquareBracket: {</span>
          auto expression = parseExpression();
          if (!expression)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         if (!consumeType(Lexer::Token::Type::RightSquareBracket))</span>
<span class="line-modified">!             return SuffixExpression(WTFMove(previous), false);</span>
<span class="line-modified">!         return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(WTFMove(*suffix), WTFMove(previous), WTFMove(*expression)), true);</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">!         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
          callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
          result-&gt;setResultExpression(result-&gt;oldVariableReference());
          return SuffixExpression(WTFMove(result), true);
      }
      default: {
<span class="line-modified">!         ASSERT(suffix-&gt;type == Lexer::Token::Type::MinusMinus);</span>
<span class="line-modified">!         auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*suffix), WTFMove(previous));</span>
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
          callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*suffix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
          result-&gt;setResultExpression(result-&gt;oldVariableReference());
          return SuffixExpression(WTFMove(result), true);
      }
      }
  }
  
  auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-removed">-     if (!origin)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto first = parsePossibleTernaryConditional();</span>
<span class="line-removed">-     if (!first)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(first.error());</span>
<span class="line-removed">- </span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
      expressions.append(WTFMove(*first));
  
<span class="line-modified">!     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto expression = parsePossibleTernaryConditional();</span>
<span class="line-removed">-         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
          expressions.append(WTFMove(*expression));
      }
  
      if (expressions.size() == 1)
          return WTFMove(expressions[0]);
<span class="line-modified">!     return { makeUniqueRef&lt;AST::CommaExpression&gt;(WTFMove(*origin), WTFMove(expressions)) };</span>
  }
  
<span class="line-modified">! auto Parser::parseTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     auto predicate = parsePossibleLogicalBinaryOperation();</span>
<span class="line-removed">-     if (!predicate)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(predicate.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto questionMark = consumeType(Lexer::Token::Type::QuestionMark);</span>
<span class="line-removed">-     if (!questionMark)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(questionMark.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto bodyExpression = parseExpression();</span>
<span class="line-removed">-     if (!bodyExpression)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(bodyExpression.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto colon = consumeType(Lexer::Token::Type::Colon);</span>
<span class="line-removed">-     if (!colon)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(colon.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto elseExpression = parsePossibleTernaryConditional();</span>
<span class="line-removed">-     if (!elseExpression)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(elseExpression.error());</span>
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<span class="line-modified">!     castArguments.append(WTFMove(*predicate));</span>
<span class="line-modified">!     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(WTFMove(*origin), WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! auto Parser::parseAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto origin = peek();</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(origin.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto left = parsePossiblePrefix();</span>
<span class="line-modified">!     if (!left)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(left.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto assignmentOperator = consumeTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::EqualsSign,</span>
<span class="line-modified">!         Lexer::Token::Type::PlusEquals,</span>
<span class="line-modified">!         Lexer::Token::Type::MinusEquals,</span>
<span class="line-modified">!         Lexer::Token::Type::TimesEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::DivideEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::ModEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::XorEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::AndEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::OrEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::RightShiftEquals,</span>
<span class="line-removed">-         Lexer::Token::Type::LeftShiftEquals</span>
<span class="line-removed">-     });</span>
      if (!assignmentOperator)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(assignmentOperator.error());</span>
  
<span class="line-modified">!     auto right = parsePossibleTernaryConditional();</span>
<span class="line-modified">!     if (!right)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(right.error());</span>
  
<span class="line-modified">!     if (assignmentOperator-&gt;type == Lexer::Token::Type::EqualsSign)</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(WTFMove(*origin), WTFMove(*left), WTFMove(*right))};</span>
  
      String name;
      switch (assignmentOperator-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::PlusEquals:</span>
          name = &quot;operator+&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::MinusEquals:</span>
          name = &quot;operator-&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::TimesEquals:</span>
          name = &quot;operator*&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::DivideEquals:</span>
          name = &quot;operator/&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::ModEquals:</span>
          name = &quot;operator%&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::XorEquals:</span>
          name = &quot;operator^&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::AndEquals:</span>
          name = &quot;operator&amp;&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::OrEquals:</span>
          name = &quot;operator|&quot;_str;
          break;
<span class="line-modified">!     case Lexer::Token::Type::RightShiftEquals:</span>
          name = &quot;operator&gt;&gt;&quot;_str;
          break;
      default:
<span class="line-modified">!         ASSERT(assignmentOperator-&gt;type == Lexer::Token::Type::LeftShiftEquals);</span>
          name = &quot;operator&lt;&lt;&quot;_str;
          break;
      }
  
<span class="line-modified">!     auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*origin), WTFMove(*left));</span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
      callArguments.append(result-&gt;oldVariableReference());
      callArguments.append(WTFMove(*right));
<span class="line-modified">!     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*origin), WTFMove(name), WTFMove(callArguments)));</span>
      result-&gt;setResultExpression(result-&gt;newVariableReference());
      return { WTFMove(result) };
  }
  
  auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto ternaryExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-removed">-         return parseTernaryConditional();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">-     if (ternaryExpression)</span>
<span class="line-removed">-         return ternaryExpression;</span>
  
<span class="line-modified">!     auto assignmentExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parseAssignment();</span>
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (assignmentExpression)</span>
<span class="line-modified">!         return assignmentExpression;</span>
  
<span class="line-modified">!     auto binaryOperation = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() {</span>
<span class="line-modified">!         return parsePossibleLogicalBinaryOperation();</span>
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (binaryOperation)</span>
<span class="line-modified">!         return binaryOperation;</span>
  
<span class="line-modified">!     return Unexpected&lt;Error&gt;(binaryOperation.error());</span>
  }
  
  auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto parsedPrevious = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">!     if (!parsedPrevious)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">!     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (auto logicalBinaryOperation = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::OrOr,</span>
<span class="line-modified">!         Lexer::Token::Type::AndAnd,</span>
<span class="line-modified">!         Lexer::Token::Type::Or,</span>
<span class="line-modified">!         Lexer::Token::Type::Xor,</span>
<span class="line-modified">!         Lexer::Token::Type::And</span>
<span class="line-modified">!         })) {</span>
<span class="line-modified">!         auto next = parsePossibleRelationalBinaryOperation();</span>
<span class="line-modified">!         if (!next)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (logicalBinaryOperation-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::OrOr:</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
              break;
<span class="line-modified">!         case Lexer::Token::Type::AndAnd:</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(WTFMove(*logicalBinaryOperation), AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
              break;
<span class="line-modified">!         case Lexer::Token::Type::Or: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator|&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::Xor: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator^&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(logicalBinaryOperation-&gt;type == Lexer::Token::Type::And);</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*logicalBinaryOperation), &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return { WTFMove(previous) };
  }
  
  auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto parsedPrevious = parsePossibleShift();</span>
<span class="line-modified">!     if (!parsedPrevious)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">!     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (auto relationalBinaryOperation = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::LessThanSign,</span>
<span class="line-modified">!         Lexer::Token::Type::GreaterThanSign,</span>
<span class="line-modified">!         Lexer::Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">!         Lexer::Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">!         Lexer::Token::Type::EqualComparison,</span>
<span class="line-modified">!         Lexer::Token::Type::NotEqual</span>
<span class="line-modified">!         })) {</span>
<span class="line-modified">!         auto next = parsePossibleShift();</span>
<span class="line-modified">!         if (!next)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (relationalBinaryOperation-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::LessThanSign: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::GreaterThanSign: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::EqualComparison: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(relationalBinaryOperation-&gt;type == Lexer::Token::Type::NotEqual);</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">!             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*relationalBinaryOperation), &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(WTFMove(*relationalBinaryOperation), WTFMove(previous));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto parsedPrevious = parsePossibleAdd();</span>
<span class="line-modified">!     if (!parsedPrevious)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-modified">!     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
  
<span class="line-modified">!     while (auto shift = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::LeftShift,</span>
<span class="line-modified">!         Lexer::Token::Type::RightShift</span>
<span class="line-removed">-         })) {</span>
<span class="line-removed">-         auto next = parsePossibleAdd();</span>
<span class="line-removed">-         if (!next)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (shift-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::LeftShift: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(shift-&gt;type == Lexer::Token::Type::RightShift);</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*shift), &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto parsedPrevious = parsePossibleMultiply();</span>
<span class="line-modified">!     if (!parsedPrevious)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">-     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
  
<span class="line-modified">!     while (auto add = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::Plus,</span>
<span class="line-modified">!         Lexer::Token::Type::Minus</span>
<span class="line-modified">!         })) {</span>
<span class="line-modified">!         auto next = parsePossibleMultiply();</span>
<span class="line-modified">!         if (!next)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (add-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::Plus: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator+&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(add-&gt;type == Lexer::Token::Type::Minus);</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*add), &quot;operator-&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto parsedPrevious = parsePossiblePrefix();</span>
<span class="line-modified">!     if (!parsedPrevious)</span>
<span class="line-modified">!         return Unexpected&lt;Error&gt;(parsedPrevious.error());</span>
<span class="line-removed">-     UniqueRef&lt;AST::Expression&gt; previous = WTFMove(*parsedPrevious);</span>
  
<span class="line-modified">!     while (auto multiply = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::Star,</span>
<span class="line-modified">!         Lexer::Token::Type::Divide,</span>
<span class="line-modified">!         Lexer::Token::Type::Mod</span>
<span class="line-modified">!         })) {</span>
<span class="line-modified">!         auto next = parsePossiblePrefix();</span>
<span class="line-modified">!         if (!next)</span>
<span class="line-modified">!             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (multiply-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::Star: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator*&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Lexer::Token::Type::Divide: {</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator/&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(multiply-&gt;type == Lexer::Token::Type::Mod);</span>
<span class="line-modified">!             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-removed">-             callArguments.append(WTFMove(previous));</span>
<span class="line-removed">-             callArguments.append(WTFMove(*next));</span>
<span class="line-removed">-             previous = makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*multiply), &quot;operator%&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
<span class="line-modified">! auto Parser::parsePossiblePrefix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     if (auto prefix = tryTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::PlusPlus,</span>
<span class="line-modified">!         Lexer::Token::Type::MinusMinus,</span>
<span class="line-modified">!         Lexer::Token::Type::Plus,</span>
<span class="line-modified">!         Lexer::Token::Type::Minus,</span>
<span class="line-modified">!         Lexer::Token::Type::Tilde,</span>
<span class="line-modified">!         Lexer::Token::Type::ExclamationPoint,</span>
<span class="line-modified">!         Lexer::Token::Type::And,</span>
<span class="line-modified">!         Lexer::Token::Type::At,</span>
<span class="line-modified">!         Lexer::Token::Type::Star</span>
<span class="line-modified">!     })) {</span>
<span class="line-modified">!         auto next = parsePossiblePrefix();</span>
<span class="line-modified">!         if (!next)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(next.error());</span>
  
          switch (prefix-&gt;type) {
<span class="line-modified">!         case Lexer::Token::Type::PlusPlus: {</span>
<span class="line-modified">!             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
              result-&gt;setResultExpression(result-&gt;newVariableReference());
              return { WTFMove(result) };
          }
<span class="line-modified">!         case Lexer::Token::Type::MinusMinus: {</span>
<span class="line-modified">!             auto result = AST::ReadModifyWriteExpression::create(Lexer::Token(*prefix), WTFMove(*next));</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
              result-&gt;setResultExpression(result-&gt;newVariableReference());
              return { WTFMove(result) };
          }
<span class="line-modified">!         case Lexer::Token::Type::Plus: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Lexer::Token::Type::Minus: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Lexer::Token::Type::Tilde: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Lexer::Token::Type::ExclamationPoint: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
              castArguments.append(WTFMove(*next));
<span class="line-modified">!             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Lexer::Token(*prefix), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(Lexer::Token(*prefix), WTFMove(boolCast)) };</span>
          }
<span class="line-modified">!         case Lexer::Token::Type::And:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
<span class="line-modified">!         case Lexer::Token::Type::At:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
          default:
<span class="line-modified">!             ASSERT(prefix-&gt;type == Lexer::Token::Type::Star);</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(Lexer::Token(*prefix), WTFMove(*next)) };</span>
          }
      }
  
<span class="line-modified">!     return parsePossibleSuffix();</span>
  }
  
<span class="line-modified">! auto Parser::parsePossibleSuffix() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     auto suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">!         auto expression = parseCallExpression();</span>
<span class="line-removed">-         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
  
          while (true) {
<span class="line-modified">!             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">!                 return parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-             expression = WTFMove(result.result);</span>
<span class="line-removed">-             if (!result)</span>
                  break;
          }
          return expression;
<span class="line-modified">!     });</span>
<span class="line-removed">-     if (suffix)</span>
<span class="line-removed">-         return suffix;</span>
  
<span class="line-modified">!     suffix = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt; {</span>
<span class="line-modified">!         auto expression = parseTerm();</span>
<span class="line-removed">-         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
  
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             auto result = backtrackingScope&lt;SuffixExpression&gt;([&amp;]() -&gt; SuffixExpression {</span>
<span class="line-modified">!                 return parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">!             });</span>
<span class="line-modified">!             expression = WTFMove(result.result);</span>
<span class="line-modified">!             if (!result)</span>
<span class="line-modified">!                 break;</span>
          }
<span class="line-modified">!         return expression;</span>
<span class="line-modified">!     });</span>
<span class="line-modified">!     if (suffix)</span>
<span class="line-modified">!         return suffix;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return Unexpected&lt;Error&gt;(suffix.error());</span>
  }
  
  auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto name = consumeType(Lexer::Token::Type::Identifier);</span>
<span class="line-modified">!     if (!name)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(name.error());</span>
<span class="line-removed">-     auto callName = name-&gt;stringView.toString();</span>
  
<span class="line-modified">!     auto leftParenthesis = consumeType(Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-removed">-     if (!leftParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(leftParenthesis.error());</span>
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<span class="line-modified">!     if (tryType(Lexer::Token::Type::RightParenthesis))</span>
          return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
  
<span class="line-modified">!     auto firstArgument = parsePossibleTernaryConditional();</span>
<span class="line-removed">-     if (!firstArgument)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(firstArgument.error());</span>
      arguments.append(WTFMove(*firstArgument));
<span class="line-modified">!     while (tryType(Lexer::Token::Type::Comma)) {</span>
<span class="line-modified">!         auto argument = parsePossibleTernaryConditional();</span>
<span class="line-removed">-         if (!argument)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(argument.error());</span>
          arguments.append(WTFMove(*argument));
      }
  
<span class="line-modified">!     auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-modified">!     if (!rightParenthesis)</span>
<span class="line-removed">-         return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
<span class="line-modified">!     return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };</span>
  }
  
  auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto type = consumeTypes({</span>
<span class="line-modified">!         Lexer::Token::Type::IntLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::UintLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::FloatLiteral,</span>
<span class="line-modified">!         Lexer::Token::Type::Null,</span>
<span class="line-modified">!         Lexer::Token::Type::True,</span>
<span class="line-modified">!         Lexer::Token::Type::False,</span>
<span class="line-modified">!         Lexer::Token::Type::Identifier,</span>
<span class="line-modified">!         Lexer::Token::Type::LeftParenthesis</span>
<span class="line-removed">-     });</span>
      if (!type)
<span class="line-modified">!         return Unexpected&lt;Error&gt;(type.error());</span>
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Lexer::Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto value = intLiteralToInt(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(WTFMove(*type), *value) };</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::UintLiteral: {</span>
<span class="line-modified">!         auto value = uintLiteralToUint(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(WTFMove(*type), *value) };</span>
      }
<span class="line-modified">!     case Lexer::Token::Type::FloatLiteral: {</span>
<span class="line-modified">!         auto value = floatLiteralToFloat(type-&gt;stringView);</span>
          if (!value)
<span class="line-modified">!             return Unexpected&lt;Error&gt;(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(WTFMove(*type), *value) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Lexer::Token::Type::Null:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::NullLiteral&gt;(WTFMove(*type)) };</span>
<span class="line-modified">!     case Lexer::Token::Type::True:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), true) };</span>
<span class="line-modified">!     case Lexer::Token::Type::False:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(WTFMove(*type), false) };</span>
<span class="line-modified">!     case Lexer::Token::Type::Identifier: {</span>
<span class="line-modified">!         auto name = type-&gt;stringView.toString();</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::VariableReference&gt;(WTFMove(*type), WTFMove(name)) };</span>
      }
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Lexer::Token::Type::LeftParenthesis);</span>
<span class="line-modified">!         auto expression = parseExpression();</span>
<span class="line-modified">!         if (!expression)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(expression.error());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto rightParenthesis = consumeType(Lexer::Token::Type::RightParenthesis);</span>
<span class="line-removed">-         if (!rightParenthesis)</span>
<span class="line-removed">-             return Unexpected&lt;Error&gt;(rightParenthesis.error());</span>
  
          return { WTFMove(*expression) };
      }
      }
  }
<span class="line-new-header">--- 698,1386 ---</span>
      case &#39;s&#39;:
          mode = AST::ResourceSemantic::Mode::Sampler;
          break;
      }
  
<span class="line-modified">!     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));</span>
      if (!index)
<span class="line-modified">!         return makeUnexpected(index.error());</span>
  
      unsigned space = 0;
<span class="line-modified">!     if (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         CONSUME_TYPE(spaceToken, Identifier);</span>
<span class="line-modified">!         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);</span>
<span class="line-modified">!         StringView prefix { &quot;space&quot; };</span>
<span class="line-modified">!         if (!spaceTokenStringView.startsWith(prefix))</span>
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified">!         if (spaceTokenStringView.length() &lt;= prefix.length())</span>
<span class="line-modified">!             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));</span>
<span class="line-modified">!         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));</span>
          if (!spaceValue)
<span class="line-modified">!             return makeUnexpected(spaceValue.error());</span>
          space = *spaceValue;
      }
  
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
  
<span class="line-modified">!     return AST::ResourceSemantic({ *origin, *rightParenthesis }, mode, *index, space);</span>
  }
  
  auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Specialized);</span>
<span class="line-modified">!     return AST::SpecializationConstantSemantic(*origin);</span>
  }
  
  auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Attribute);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
  
      auto index = consumeNonNegativeIntegralLiteral();
      if (!index)
<span class="line-modified">!         return makeUnexpected(index.error());</span>
  
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
  
<span class="line-modified">!     return AST::StageInOutSemantic({ *origin, *rightParenthesis }, *index);</span>
  }
  
<span class="line-modified">! auto Parser::parseSemantic() -&gt; Expected&lt;std::unique_ptr&lt;AST::Semantic&gt;, Error&gt;</span>
  {
<span class="line-modified">!     if (!tryType(Token::Type::Colon))</span>
<span class="line-modified">!         return { nullptr };</span>
  
<span class="line-modified">!     PEEK(token);</span>
<span class="line-added">+     switch (token-&gt;type) {</span>
<span class="line-added">+     case Token::Type::Attribute: {</span>
<span class="line-added">+         PARSE(result, StageInOutSemantic);</span>
<span class="line-added">+         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case Token::Type::Specialized:  {</span>
<span class="line-added">+         PARSE(result, SpecializationConstantSemantic);</span>
<span class="line-added">+         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case Token::Type::Register:  {</span>
<span class="line-added">+         PARSE(result, ResourceSemantic);</span>
<span class="line-added">+         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:  {</span>
<span class="line-added">+         PARSE(result, BuiltInSemantic);</span>
<span class="line-added">+         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
  }
  AST::Qualifiers Parser::parseQualifiers()
  {
      AST::Qualifiers qualifiers;
<span class="line-modified">!     while (auto next = tryType(Token::Type::Qualifier)) {</span>
<span class="line-modified">!         auto nextStringView = next-&gt;stringView(m_lexer);</span>
<span class="line-modified">!         if (&quot;nointerpolation&quot; == nextStringView)</span>
<span class="line-modified">!             qualifiers.append(AST::Qualifier::Nointerpolation);</span>
<span class="line-modified">!         else if (&quot;noperspective&quot; == nextStringView)</span>
<span class="line-modified">!             qualifiers.append(AST::Qualifier::Noperspective);</span>
<span class="line-modified">!         else if (&quot;uniform&quot; == nextStringView)</span>
<span class="line-modified">!             qualifiers.append(AST::Qualifier::Uniform);</span>
<span class="line-modified">!         else if (&quot;centroid&quot; == nextStringView)</span>
<span class="line-modified">!             qualifiers.append(AST::Qualifier::Centroid);</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             ASSERT(&quot;sample&quot; == nextStringView);</span>
<span class="line-modified">!             qualifiers.append(AST::Qualifier::Sample);</span>
<span class="line-modified">!         }</span>
      }
      return qualifiers;
  }
  
  auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
  {
<span class="line-modified">!     PEEK(origin);</span>
  
      AST::Qualifiers qualifiers = parseQualifiers();
  
<span class="line-modified">!     PARSE(type, Type);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
  
<span class="line-modified">!     return AST::StructureElement({ *origin, *semicolon }, WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic));</span>
  }
  
  auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Struct);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>
  
      AST::StructureElements structureElements;
<span class="line-modified">!     while (!peekType(Token::Type::RightCurlyBracket)) {</span>
<span class="line-modified">!         PARSE(structureElement, StructureElement);</span>
<span class="line-modified">!         structureElements.append(WTFMove(*structureElement));</span>
      }
  
<span class="line-modified">!     auto rightCurlyBracket = m_lexer.consumeToken();</span>
  
<span class="line-modified">!     return AST::StructureDefinition({ *origin, rightCurlyBracket }, name-&gt;stringView(m_lexer).toString(), WTFMove(structureElements));</span>
  }
  
  auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Enum);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
  
<span class="line-modified">!     auto type = ([&amp;]() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt; {</span>
<span class="line-modified">!         if (tryType(Token::Type::Colon)) {</span>
<span class="line-modified">!             PARSE(parsedType, Type);</span>
              return WTFMove(*parsedType);
          }
<span class="line-modified">!         return { AST::TypeReference::create(*origin, &quot;int&quot;_str, AST::TypeArguments()) };</span>
      })();
      if (!type)
<span class="line-modified">!         return makeUnexpected(type.error());</span>
  
<span class="line-modified">!     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>
  
<span class="line-modified">!     int64_t nextValue = 0;</span>
<span class="line-modified">!     PARSE(firstEnumerationMember, EnumerationMember, nextValue);</span>
<span class="line-modified">!     nextValue = firstEnumerationMember-&gt;value() + 1;</span>
  
<span class="line-modified">!     AST::EnumerationDefinition result({ }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));</span>
      auto success = result.add(WTFMove(*firstEnumerationMember));
      if (!success)
          return fail(&quot;Cannot add enumeration member&quot;_str);
  
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         PARSE(member, EnumerationMember, nextValue);</span>
<span class="line-modified">!         nextValue = member-&gt;value() + 1;</span>
          success = result.add(WTFMove(*member));
          if (!success)
              return fail(&quot;Cannot add enumeration member&quot;_str);
      }
  
<span class="line-modified">!     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified">!     result.updateCodeLocation({ *origin, *rightCurlyBracket});</span>
  
      return WTFMove(result);
  }
  
<span class="line-modified">! auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;</span>
  {
<span class="line-modified">!     CONSUME_TYPE(identifier, Identifier);</span>
<span class="line-modified">!     auto name = identifier-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-added">+         PARSE(constantExpression, ConstantExpression);</span>
  
<span class="line-modified">!         Optional&lt;int64_t&gt; value;</span>
<span class="line-modified">!         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-modified">!             value = integerLiteral.value();</span>
<span class="line-modified">!         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-modified">!             value = unsignedIntegerLiteral.value();</span>
<span class="line-added">+         }, [&amp;](AST::FloatLiteral&amp;) {</span>
<span class="line-added">+         }, [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added">+         }, [&amp;](AST::BooleanLiteral&amp;) {</span>
<span class="line-added">+         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {</span>
<span class="line-added">+         }));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!value)</span>
<span class="line-added">+             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));</span>
<span class="line-added">+         return AST::EnumerationMember(*identifier, WTFMove(name), *value);</span>
      }
<span class="line-modified">!     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);</span>
  }
  
  auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Native);</span>
<span class="line-modified">!     CONSUME_TYPE(parsedTypedef, Typedef);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     PARSE(typeArguments, TypeArguments);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
  
<span class="line-modified">!     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));</span>
  }
  
  auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, NumThreads);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
  
      auto width = consumeNonNegativeIntegralLiteral();
      if (!width)
<span class="line-modified">!         return makeUnexpected(width.error());</span>
  
<span class="line-modified">!     CONSUME_TYPE(comma, Comma);</span>
  
      auto height = consumeNonNegativeIntegralLiteral();
      if (!height)
<span class="line-modified">!         return makeUnexpected(height.error());</span>
  
<span class="line-modified">!     CONSUME_TYPE(secondComma, Comma);</span>
  
      auto depth = consumeNonNegativeIntegralLiteral();
      if (!depth)
<span class="line-modified">!         return makeUnexpected(depth.error());</span>
  
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
  
<span class="line-modified">!     return AST::NumThreadsFunctionAttribute({ *origin, *rightParenthesis }, *width, *height, *depth);</span>
  }
  
  auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(leftSquareBracket, LeftSquareBracket);</span>
  
      AST::AttributeBlock result;
  
<span class="line-modified">!     while (!tryType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">!         PARSE(numThreadsFunctionAttribute, NumThreadsFunctionAttribute);</span>
<span class="line-modified">!         result.append(WTFMove(*numThreadsFunctionAttribute));</span>
      }
  
      return WTFMove(result);
  }
  
  auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
  {
<span class="line-modified">!     auto startOffset = m_lexer.peek().startOffset();</span>
  
      AST::Qualifiers qualifiers = parseQualifiers();
<span class="line-modified">!     PARSE(type, Type);</span>
  
      String name;
<span class="line-modified">!     if (auto token = tryType(Token::Type::Identifier))</span>
<span class="line-modified">!         name = token-&gt;stringView(m_lexer).toString();</span>
  
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
  
<span class="line-modified">!     return AST::VariableDeclaration({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTFMove(*semantic), nullptr);</span>
  }
  
  auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
  {
      AST::VariableDeclarations parameters;
<span class="line-modified">! </span>
<span class="line-added">+     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (tryType(Token::Type::RightParenthesis))</span>
          return WTFMove(parameters);
  
<span class="line-modified">!     PARSE(firstParameter, Parameter);</span>
<span class="line-modified">!     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstParameter)));</span>
  
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         PARSE(parameter, Parameter);</span>
<span class="line-modified">!         parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*parameter)));</span>
      }
  
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
  
      return WTFMove(parameters);
  }
  
  auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
  {
<span class="line-modified">!     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified">!     PARSE(block, Block);</span>
      return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
  }
  
<span class="line-modified">! auto Parser::parseComputeFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
  {
<span class="line-modified">!     PEEK(origin);</span>
  
<span class="line-modified">!     PARSE(attributeBlock, AttributeBlock);</span>
<span class="line-modified">!     CONSUME_TYPE(compute, Compute);</span>
<span class="line-modified">!     PARSE(type, Type);</span>
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     PARSE(parameters, Parameters);</span>
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
  
<span class="line-modified">!     bool isOperator = false;</span>
<span class="line-modified">!     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(*attributeBlock), AST::EntryPointType::Compute, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! auto Parser::parseVertexOrFragmentFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto entryPoint = consumeTypes&lt;Token::Type::Vertex, Token::Type::Fragment&gt;();</span>
<span class="line-added">+     if (!entryPoint)</span>
<span class="line-added">+         return makeUnexpected(entryPoint.error());</span>
<span class="line-added">+     auto entryPointType = (entryPoint-&gt;type == Token::Type::Vertex) ? AST::EntryPointType::Vertex : AST::EntryPointType::Fragment;</span>
  
<span class="line-modified">!     PARSE(type, Type);</span>
<span class="line-added">+     CONSUME_TYPE(name, Identifier);</span>
<span class="line-added">+     PARSE(parameters, Parameters);</span>
<span class="line-added">+     PARSE(semantic, Semantic);</span>
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
  
<span class="line-modified">!     bool isOperator = false;</span>
<span class="line-added">+     return AST::FunctionDeclaration({ entryPoint-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, entryPointType, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
  }
  
  auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     PEEK(origin);</span>
  
<span class="line-modified">!     PARSE(type, Type);</span>
  
<span class="line-modified">!     auto name = consumeTypes&lt;Token::Type::Identifier, Token::Type::OperatorName&gt;();</span>
      if (!name)
<span class="line-modified">!         return makeUnexpected(name.error());</span>
<span class="line-modified">!     auto isOperator = name-&gt;type == Token::Type::OperatorName;</span>
  
<span class="line-modified">!     PARSE(parameters, Parameters);</span>
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
  
<span class="line-modified">!     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
  }
  
  auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Operator);</span>
<span class="line-modified">!     PARSE(type, Type);</span>
<span class="line-modified">!     PARSE(parameters, Parameters);</span>
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
  
      bool isOperator = true;
<span class="line-modified">!     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);</span>
  }
  
  auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     PEEK(token);</span>
<span class="line-modified">!     switch (token-&gt;type) {</span>
<span class="line-modified">!     case Token::Type::Operator:</span>
          return parseOperatorFunctionDeclaration();
<span class="line-modified">!     case Token::Type::Vertex:</span>
<span class="line-modified">!     case Token::Type::Fragment:</span>
<span class="line-modified">!         return parseVertexOrFragmentFunctionDeclaration();</span>
<span class="line-modified">!     case Token::Type::LeftSquareBracket:</span>
<span class="line-modified">!         return parseComputeFunctionDeclaration();</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return parseRegularFunctionDeclaration();</span>
<span class="line-added">+     }</span>
  }
  
  auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(native, Native);</span>
<span class="line-modified">!     PARSE(functionDeclaration, FunctionDeclaration);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
  
      return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
  }
  
  auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, LeftCurlyBracket);</span>
<span class="line-modified">!     PARSE(result, BlockBody);</span>
<span class="line-modified">!     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);</span>
<span class="line-modified">!     result-&gt;updateCodeLocation({ *origin, *rightCurlyBracket });</span>
<span class="line-modified">!     return WTFMove(*result);</span>
  }
  
<span class="line-modified">! auto Parser::parseBlockBody() -&gt; Expected&lt;AST::Block, Error&gt;</span>
  {
<span class="line-added">+     auto startOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+ </span>
      AST::Statements statements;
<span class="line-modified">!     while (!peekTypes&lt;Token::Type::RightCurlyBracket, Token::Type::Case, Token::Type::Default&gt;()) {</span>
<span class="line-modified">!         PARSE(statement, Statement);</span>
<span class="line-modified">!         statements.append(WTFMove(*statement));</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return AST::Block({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(statements));</span>
  }
  
  auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, If);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">!     PARSE(conditional, Expression);</span>
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">!     PARSE(body, Statement);</span>
  
<span class="line-modified">!     std::unique_ptr&lt;AST::Statement&gt; elseBody(nullptr);</span>
<span class="line-modified">!     if (tryType(Token::Type::Else)) {</span>
<span class="line-modified">!         PARSE(parsedElseBody, Statement);</span>
<span class="line-modified">!         elseBody = (*parsedElseBody).moveToUniquePtr();</span>
      }
  
<span class="line-added">+     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+ </span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
      castArguments.append(WTFMove(*conditional));
<span class="line-modified">!     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!     return AST::IfStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));</span>
  }
  
  auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Switch);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">!     PARSE(value, Expression);</span>
<span class="line-added">+     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-added">+     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);</span>
  
<span class="line-modified">!     Vector&lt;AST::SwitchCase&gt; switchCases;</span>
<span class="line-modified">!     PEEK(nextToken);</span>
<span class="line-modified">!     while (nextToken-&gt;type != Token::Type::RightCurlyBracket) {</span>
<span class="line-added">+         PARSE(switchCase, SwitchCase);</span>
<span class="line-added">+         switchCases.append(WTFMove(*switchCase));</span>
<span class="line-added">+         PEEK(nextTokenInLoop);</span>
<span class="line-added">+         nextToken = nextTokenInLoop;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto endToken = m_lexer.consumeToken();</span>
  
<span class="line-modified">!     return AST::SwitchStatement({ *origin, endToken }, WTFMove(*value), WTFMove(switchCases));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto origin = consumeTypes&lt;Token::Type::Case, Token::Type::Default&gt;();</span>
<span class="line-modified">!     if (!origin)</span>
<span class="line-modified">!         return makeUnexpected(origin.error());</span>
  
      switch (origin-&gt;type) {
<span class="line-modified">!     case Token::Type::Case: {</span>
<span class="line-modified">!         PARSE(value, ConstantExpression);</span>
<span class="line-modified">!         CONSUME_TYPE(colon, Colon);</span>
  
<span class="line-modified">!         PARSE(block, BlockBody);</span>
  
<span class="line-modified">!         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTFMove(*value), WTFMove(*block));</span>
      }
      default: {
<span class="line-modified">!         ASSERT(origin-&gt;type == Token::Type::Default);</span>
<span class="line-modified">!         CONSUME_TYPE(colon, Colon);</span>
  
<span class="line-modified">!         PARSE(block, BlockBody);</span>
  
<span class="line-modified">!         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTF::nullopt, WTFMove(*block));</span>
      }
      }
  }
  
  auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, For);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
  
<span class="line-modified">!     auto parseRemainder = [&amp;](UniqueRef&lt;AST::Statement&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {</span>
<span class="line-modified">!         CONSUME_TYPE(semicolon, Semicolon);</span>
  
<span class="line-modified">!         std::unique_ptr&lt;AST::Expression&gt; condition(nullptr);</span>
<span class="line-added">+         if (!tryType(Token::Type::Semicolon)) {</span>
              if (auto expression = parseExpression())
<span class="line-modified">!                 condition = (*expression).moveToUniquePtr();</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 return makeUnexpected(expression.error());</span>
<span class="line-modified">!             CONSUME_TYPE(secondSemicolon, Semicolon);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         std::unique_ptr&lt;AST::Expression&gt; increment(nullptr);</span>
<span class="line-added">+         if (!tryType(Token::Type::RightParenthesis)) {</span>
              if (auto expression = parseExpression())
<span class="line-modified">!                 increment = (*expression).moveToUniquePtr();</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 return makeUnexpected(expression.error());</span>
<span class="line-modified">!             CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         PARSE(body, Statement);</span>
<span class="line-added">+         CodeLocation location(origin-&gt;codeLocation, (*body)-&gt;codeLocation());</span>
<span class="line-added">+         return AST::ForLoop(location, WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));</span>
      };
  
      auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
          return parseVariableDeclarations();
      });
<span class="line-modified">!     if (variableDeclarations) {</span>
<span class="line-modified">!         UniqueRef&lt;AST::Statement&gt; declarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations));</span>
<span class="line-added">+         return parseRemainder(WTFMove(declarationStatement));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     PARSE(effectfulExpression, EffectfulExpression);</span>
  
      return parseRemainder(WTFMove(*effectfulExpression));
  }
  
  auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, While);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">!     PARSE(conditional, Expression);</span>
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">!     PARSE(body, Statement);</span>
  
<span class="line-modified">!     CodeLocation location(origin-&gt;codeLocation,  (*body)-&gt;codeLocation());</span>
<span class="line-modified">!     return AST::WhileLoop(location, WTFMove(*conditional), WTFMove(*body));</span>
  }
  
  auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(origin, Do);</span>
<span class="line-modified">!     PARSE(body, Statement);</span>
<span class="line-modified">!     CONSUME_TYPE(whileKeyword, While);</span>
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
<span class="line-modified">!     PARSE(conditional, Expression);</span>
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
  
<span class="line-modified">!     return AST::DoWhileLoop({ *origin, *semicolon}, WTFMove(*body), WTFMove(*conditional));</span>
  }
  
<span class="line-modified">! auto Parser::parseVariableDeclaration(Ref&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;</span>
  {
<span class="line-modified">!     PEEK(origin);</span>
  
      auto qualifiers = parseQualifiers();
  
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     PARSE(semantic, Semantic);</span>
  
<span class="line-modified">!     std::unique_ptr&lt;AST::Expression&gt; initializer = nullptr;</span>
<span class="line-modified">!     if (tryType(Token::Type::EqualsSign)) {</span>
<span class="line-modified">!         PARSE(initializingExpression, PossibleTernaryConditional);</span>
<span class="line-modified">!         initializer = initializingExpression.value().moveToUniquePtr();</span>
      }
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+     return AST::VariableDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic), WTFMove(initializer));</span>
  }
  
  auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
  {
<span class="line-modified">!     PEEK(origin);</span>
  
<span class="line-modified">!     PARSE(type, Type);</span>
  
<span class="line-modified">!     auto firstVariableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
      if (!firstVariableDeclaration)
<span class="line-modified">!         return makeUnexpected(firstVariableDeclaration.error());</span>
  
<span class="line-modified">!     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; result;</span>
<span class="line-modified">!     result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstVariableDeclaration)));</span>
  
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         auto variableDeclaration = parseVariableDeclaration(type-&gt;copyRef());</span>
          if (!variableDeclaration)
<span class="line-modified">!             return makeUnexpected(variableDeclaration.error());</span>
<span class="line-modified">!         result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*variableDeclaration)));</span>
      }
  
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+     return AST::VariableDeclarationsStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(result));</span>
  }
  
  auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
  {
<span class="line-modified">!     PEEK(token);</span>
<span class="line-modified">!     switch (token-&gt;type) {</span>
<span class="line-modified">!     case Token::Type::LeftCurlyBracket: {</span>
<span class="line-modified">!         PARSE(block, Block);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::If: {</span>
<span class="line-modified">!         PARSE(ifStatement, IfStatement);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Switch: {</span>
<span class="line-modified">!         PARSE(switchStatement, SwitchStatement);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::For: {</span>
<span class="line-modified">!         PARSE(forLoop, ForLoop);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::While: {</span>
<span class="line-modified">!         PARSE(whileLoop, WhileLoop);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Do: {</span>
<span class="line-modified">!         PARSE(doWhileLoop, DoWhileLoop);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Break: {</span>
<span class="line-modified">!         auto breakToken = m_lexer.consumeToken();</span>
<span class="line-modified">!         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!         auto breakObject = AST::Break(WTFMove(breakToken));</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(breakObject)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Continue: {</span>
<span class="line-modified">!         auto continueToken = m_lexer.consumeToken();</span>
<span class="line-modified">!         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!         auto continueObject = AST::Continue(WTFMove(continueToken));</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(continueObject)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Fallthrough: {</span>
<span class="line-modified">!         auto fallthroughToken = m_lexer.consumeToken();</span>
<span class="line-modified">!         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!         auto fallthroughObject = AST::Fallthrough(WTFMove(fallthroughToken));</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(fallthroughObject)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Return: {</span>
<span class="line-modified">!         auto returnToken = m_lexer.consumeToken();</span>
<span class="line-modified">!         if (auto semicolon = tryType(Token::Type::Semicolon)) {</span>
<span class="line-modified">!             auto returnObject = AST::Return(WTFMove(returnToken), nullptr);</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         PARSE(expression, Expression);</span>
<span class="line-modified">!         CONSUME_TYPE(finalSemicolon, Semicolon);</span>
<span class="line-modified">!         auto returnObject = AST::Return(WTFMove(returnToken), (*expression).moveToUniquePtr());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Constant:</span>
<span class="line-modified">!     case Token::Type::Device:</span>
<span class="line-modified">!     case Token::Type::Threadgroup:</span>
<span class="line-modified">!     case Token::Type::Thread: {</span>
<span class="line-modified">!         PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">!         CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Identifier: {</span>
<span class="line-modified">!         PEEK_FURTHER(nextToken);</span>
<span class="line-modified">!         switch (nextToken-&gt;type) {</span>
<span class="line-modified">!         case Token::Type::Identifier:</span>
<span class="line-modified">!         case Token::Type::LessThanSign:</span>
<span class="line-modified">!         case Token::Type::Star:</span>
<span class="line-modified">!         case Token::Type::Qualifier: {</span>
<span class="line-modified">!             PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">!             CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         break;</span>
      }
<span class="line-modified">!     default:</span>
<span class="line-modified">!         break;</span>
      }
  
      {
<span class="line-modified">!         auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt; {</span>
<span class="line-modified">!             PARSE(result, EffectfulExpression);</span>
<span class="line-modified">!             CONSUME_TYPE(semicolon, Semicolon);</span>
              return result;
          });
<span class="line-modified">!         if (effectfulExpression)</span>
<span class="line-modified">!             return WTFMove(*effectfulExpression);</span>
      }
  
<span class="line-modified">!     PARSE(variableDeclarations, VariableDeclarations);</span>
<span class="line-modified">!     CONSUME_TYPE(semicolon, Semicolon);</span>
<span class="line-modified">!     return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };</span>
  }
  
<span class="line-modified">! auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;</span>
  {
<span class="line-modified">!     PEEK(origin);</span>
<span class="line-modified">!     if (origin-&gt;type == Token::Type::Semicolon)</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::Block&gt;(*origin, Vector&lt;UniqueRef&lt;AST::Statement&gt;&gt;()) };</span>
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<span class="line-added">+     PARSE(effectfulExpression, EffectfulAssignment);</span>
<span class="line-added">+     expressions.append(WTFMove(*effectfulExpression));</span>
  
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         PARSE(expression, EffectfulAssignment);</span>
          expressions.append(WTFMove(*expression));
      }
  
      if (expressions.size() == 1)
<span class="line-modified">!         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(expressions[0])) };</span>
<span class="line-modified">!     unsigned endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+     CodeLocation location(origin-&gt;startOffset(), endOffset, m_lexer.nameSpace());</span>
<span class="line-added">+     auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));</span>
<span class="line-added">+     return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(commaExpression)) };</span>
  }
  
  auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PEEK(origin);</span>
  
<span class="line-modified">!     bool isEffectful = false;</span>
<span class="line-modified">!     PARSE(expression, PossiblePrefix, &amp;isEffectful);</span>
  
<span class="line-modified">!     if (!isEffectful || peekTypes&lt;</span>
<span class="line-modified">!         Token::Type::EqualsSign,</span>
<span class="line-modified">!         Token::Type::PlusEquals,</span>
<span class="line-modified">!         Token::Type::MinusEquals,</span>
<span class="line-modified">!         Token::Type::TimesEquals,</span>
<span class="line-modified">!         Token::Type::DivideEquals,</span>
<span class="line-modified">!         Token::Type::ModEquals,</span>
<span class="line-modified">!         Token::Type::XorEquals,</span>
<span class="line-modified">!         Token::Type::AndEquals,</span>
<span class="line-modified">!         Token::Type::OrEquals,</span>
<span class="line-modified">!         Token::Type::RightShiftEquals,</span>
<span class="line-modified">!         Token::Type::LeftShiftEquals</span>
<span class="line-modified">!     &gt;()) {</span>
<span class="line-modified">!         return completeAssignment(WTFMove(*expression));</span>
      }
  
<span class="line-modified">!     return expression;</span>
  }
  
  auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
  {
<span class="line-modified">!     auto type = consumeTypes&lt;</span>
<span class="line-added">+         Token::Type::FullStop,</span>
<span class="line-added">+         Token::Type::Arrow,</span>
<span class="line-added">+         Token::Type::LeftSquareBracket&gt;();</span>
      if (!type)
          return SuffixExpression(WTFMove(previous), false);
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Token::Type::FullStop: {</span>
<span class="line-modified">!         auto identifier = consumeType(Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">+         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
      }
<span class="line-modified">!     case Token::Type::Arrow: {</span>
<span class="line-modified">!         auto identifier = consumeType(Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">+         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
      }
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Token::Type::LeftSquareBracket);</span>
          auto expression = parseExpression();
          if (!expression)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">!             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">!             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return SuffixExpression(WTFMove(previous), false);</span>
      }
      }
  }
  
  auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
  {
<span class="line-modified">!     auto suffix = consumeTypes&lt;</span>
<span class="line-added">+         Token::Type::FullStop,</span>
<span class="line-added">+         Token::Type::Arrow,</span>
<span class="line-added">+         Token::Type::LeftSquareBracket,</span>
<span class="line-added">+         Token::Type::PlusPlus,</span>
<span class="line-added">+         Token::Type::MinusMinus&gt;();</span>
      if (!suffix)
          return SuffixExpression(WTFMove(previous), false);
  
      switch (suffix-&gt;type) {
<span class="line-modified">!     case Token::Type::FullStop: {</span>
<span class="line-modified">!         auto identifier = consumeType(Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">+         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);</span>
      }
<span class="line-modified">!     case Token::Type::Arrow: {</span>
<span class="line-modified">!         auto identifier = consumeType(Token::Type::Identifier);</span>
          if (!identifier)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *identifier);</span>
<span class="line-added">+         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);</span>
      }
<span class="line-modified">!     case Token::Type::LeftSquareBracket: {</span>
          auto expression = parseExpression();
          if (!expression)
              return SuffixExpression(WTFMove(previous), false);
<span class="line-modified">!         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {</span>
<span class="line-modified">!             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);</span>
<span class="line-modified">!             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return SuffixExpression(WTFMove(previous), false);</span>
      }
<span class="line-modified">!     case Token::Type::PlusPlus: {</span>
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">+         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
          callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
          result-&gt;setResultExpression(result-&gt;oldVariableReference());
          return SuffixExpression(WTFMove(result), true);
      }
      default: {
<span class="line-modified">!         ASSERT(suffix-&gt;type == Token::Type::MinusMinus);</span>
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), *suffix);</span>
<span class="line-added">+         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));</span>
          Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
          callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
          result-&gt;setResultExpression(result-&gt;oldVariableReference());
          return SuffixExpression(WTFMove(result), true);
      }
      }
  }
  
  auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(first, PossibleTernaryConditional);</span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
<span class="line-added">+     unsigned startOffset = (*first)-&gt;codeLocation().startOffset();</span>
      expressions.append(WTFMove(*first));
  
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         PARSE(expression, PossibleTernaryConditional);</span>
          expressions.append(WTFMove(*expression));
      }
  
      if (expressions.size() == 1)
          return WTFMove(expressions[0]);
<span class="line-modified">!     auto endOffset = m_lexer.peek().startOffset();</span>
<span class="line-added">+     CodeLocation location(startOffset, endOffset, m_lexer.nameSpace());</span>
<span class="line-added">+     return { makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions)) };</span>
  }
  
<span class="line-modified">! auto Parser::completeTernaryConditional(UniqueRef&lt;AST::Expression&gt;&amp;&amp; predicate) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     CONSUME_TYPE(questionMark, QuestionMark);</span>
<span class="line-modified">!     PARSE(bodyExpression, Expression);</span>
<span class="line-modified">!     CONSUME_TYPE(colon, Colon);</span>
<span class="line-modified">!     PARSE(elseExpression, PossibleTernaryConditional);</span>
  
<span class="line-added">+     CodeLocation predicateLocation = predicate-&gt;codeLocation();</span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
<span class="line-modified">!     castArguments.append(WTFMove(predicate));</span>
<span class="line-modified">!     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(predicateLocation, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!     CodeLocation location(predicateLocation, (*elseExpression)-&gt;codeLocation());</span>
<span class="line-modified">!     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(location, WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! auto Parser::completeAssignment(UniqueRef&lt;AST::Expression&gt;&amp;&amp; left) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto assignmentOperator = consumeTypes&lt;</span>
<span class="line-modified">!         Token::Type::EqualsSign,</span>
<span class="line-modified">!         Token::Type::PlusEquals,</span>
<span class="line-modified">!         Token::Type::MinusEquals,</span>
<span class="line-modified">!         Token::Type::TimesEquals,</span>
<span class="line-modified">!         Token::Type::DivideEquals,</span>
<span class="line-modified">!         Token::Type::ModEquals,</span>
<span class="line-modified">!         Token::Type::XorEquals,</span>
<span class="line-modified">!         Token::Type::AndEquals,</span>
<span class="line-modified">!         Token::Type::OrEquals,</span>
<span class="line-modified">!         Token::Type::RightShiftEquals,</span>
<span class="line-modified">!         Token::Type::LeftShiftEquals&gt;();</span>
      if (!assignmentOperator)
<span class="line-modified">!         return makeUnexpected(assignmentOperator.error());</span>
  
<span class="line-modified">!     PARSE(right, PossibleTernaryConditional);</span>
<span class="line-modified">!     CodeLocation location = { left-&gt;codeLocation(), (*right)-&gt;codeLocation() };</span>
  
<span class="line-modified">!     if (assignmentOperator-&gt;type == Token::Type::EqualsSign)</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(left), WTFMove(*right))};</span>
  
      String name;
      switch (assignmentOperator-&gt;type) {
<span class="line-modified">!     case Token::Type::PlusEquals:</span>
          name = &quot;operator+&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::MinusEquals:</span>
          name = &quot;operator-&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::TimesEquals:</span>
          name = &quot;operator*&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::DivideEquals:</span>
          name = &quot;operator/&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::ModEquals:</span>
          name = &quot;operator%&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::XorEquals:</span>
          name = &quot;operator^&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::AndEquals:</span>
          name = &quot;operator&amp;&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::OrEquals:</span>
          name = &quot;operator|&quot;_str;
          break;
<span class="line-modified">!     case Token::Type::RightShiftEquals:</span>
          name = &quot;operator&gt;&gt;&quot;_str;
          break;
      default:
<span class="line-modified">!         ASSERT(assignmentOperator-&gt;type == Token::Type::LeftShiftEquals);</span>
          name = &quot;operator&lt;&lt;&quot;_str;
          break;
      }
  
<span class="line-modified">!     auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(left));</span>
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
      callArguments.append(result-&gt;oldVariableReference());
      callArguments.append(WTFMove(*right));
<span class="line-modified">!     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(name), WTFMove(callArguments)));</span>
      result-&gt;setResultExpression(result-&gt;newVariableReference());
      return { WTFMove(result) };
  }
  
  auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(expression, PossiblePrefix);</span>
  
<span class="line-modified">!     if (peekTypes&lt;Token::Type::EqualsSign,</span>
<span class="line-modified">!         Token::Type::PlusEquals,</span>
<span class="line-modified">!         Token::Type::MinusEquals,</span>
<span class="line-modified">!         Token::Type::TimesEquals,</span>
<span class="line-modified">!         Token::Type::DivideEquals,</span>
<span class="line-added">+         Token::Type::ModEquals,</span>
<span class="line-added">+         Token::Type::XorEquals,</span>
<span class="line-added">+         Token::Type::AndEquals,</span>
<span class="line-added">+         Token::Type::OrEquals,</span>
<span class="line-added">+         Token::Type::RightShiftEquals,</span>
<span class="line-added">+         Token::Type::LeftShiftEquals&gt;()) {</span>
<span class="line-added">+         return completeAssignment(WTFMove(*expression));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     expression = completePossibleShift(WTFMove(*expression));</span>
<span class="line-modified">!     if (!expression)</span>
<span class="line-modified">!         return makeUnexpected(expression.error());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     expression = completePossibleMultiply(WTFMove(*expression));</span>
<span class="line-added">+     if (!expression)</span>
<span class="line-added">+         return makeUnexpected(expression.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+     expression = completePossibleAdd(WTFMove(*expression));</span>
<span class="line-added">+     if (!expression)</span>
<span class="line-added">+         return makeUnexpected(expression.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+     expression = completePossibleRelationalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">+     if (!expression)</span>
<span class="line-added">+         return makeUnexpected(expression.error());</span>
  
<span class="line-modified">!     expression = completePossibleLogicalBinaryOperation(WTFMove(*expression));</span>
<span class="line-added">+     if (!expression)</span>
<span class="line-added">+         return makeUnexpected(expression.error());</span>
<span class="line-added">+ </span>
<span class="line-added">+     PEEK(nextToken);</span>
<span class="line-added">+     if (nextToken-&gt;type == Token::Type::QuestionMark)</span>
<span class="line-added">+         return completeTernaryConditional(WTFMove(*expression));</span>
<span class="line-added">+     return expression;</span>
  }
  
  auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(parsedPrevious, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">!     return completePossibleLogicalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! auto Parser::completePossibleLogicalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     while (auto logicalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::OrOr,</span>
<span class="line-modified">!         Token::Type::AndAnd,</span>
<span class="line-modified">!         Token::Type::Or,</span>
<span class="line-modified">!         Token::Type::Xor,</span>
<span class="line-modified">!         Token::Type::And</span>
<span class="line-modified">!         &gt;()) {</span>
<span class="line-modified">!         PARSE(next, PossibleRelationalBinaryOperation);</span>
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
  
          switch (logicalBinaryOperation-&gt;type) {
<span class="line-modified">!         case Token::Type::OrOr:</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));</span>
              break;
<span class="line-modified">!         case Token::Type::AndAnd:</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));</span>
              break;
<span class="line-modified">!         case Token::Type::Or: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator|&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::Xor: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator^&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(logicalBinaryOperation-&gt;type == Token::Type::And);</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(previous));
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&amp;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return { WTFMove(previous) };
  }
  
  auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(parsedPrevious, PossibleShift);</span>
<span class="line-modified">!     return completePossibleRelationalBinaryOperation(WTFMove(*parsedPrevious));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! auto Parser::completePossibleRelationalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     while (auto relationalBinaryOperation = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::LessThanSign,</span>
<span class="line-modified">!         Token::Type::GreaterThanSign,</span>
<span class="line-modified">!         Token::Type::LessThanOrEqualTo,</span>
<span class="line-modified">!         Token::Type::GreaterThanOrEqualTo,</span>
<span class="line-modified">!         Token::Type::EqualComparison,</span>
<span class="line-modified">!         Token::Type::NotEqual</span>
<span class="line-modified">!         &gt;()) {</span>
<span class="line-modified">!         PARSE(next, PossibleShift);</span>
<span class="line-modified">!         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">+         callArguments.append(WTFMove(previous));</span>
<span class="line-added">+         callArguments.append(WTFMove(*next));</span>
  
          switch (relationalBinaryOperation-&gt;type) {
<span class="line-modified">!         case Token::Type::LessThanSign: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::GreaterThanSign: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::LessThanOrEqualTo: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;=&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::GreaterThanOrEqualTo: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;=&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::EqualComparison: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(relationalBinaryOperation-&gt;type == Token::Type::NotEqual);</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(previous));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(parsedPrevious, PossibleAdd);</span>
<span class="line-modified">!     return completePossibleShift(WTFMove(*parsedPrevious));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ auto Parser::completePossibleShift(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-added">+ {</span>
<span class="line-added">+     while (auto shift = tryTypes&lt;</span>
<span class="line-added">+         Token::Type::LeftShift,</span>
<span class="line-added">+         Token::Type::RightShift</span>
<span class="line-added">+         &gt;()) {</span>
<span class="line-added">+         PARSE(next, PossibleAdd);</span>
<span class="line-added">+         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
  
<span class="line-modified">!         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-modified">!         callArguments.append(WTFMove(previous));</span>
<span class="line-modified">!         callArguments.append(WTFMove(*next));</span>
  
          switch (shift-&gt;type) {
<span class="line-modified">!         case Token::Type::LeftShift: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(shift-&gt;type == Token::Type::RightShift);</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(parsedPrevious, PossibleMultiply);</span>
<span class="line-modified">!     return completePossibleAdd(WTFMove(*parsedPrevious));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! auto Parser::completePossibleAdd(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     while (auto add = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::Plus,</span>
<span class="line-modified">!         Token::Type::Minus</span>
<span class="line-modified">!         &gt;()) {</span>
<span class="line-modified">!         PARSE(next, PossibleMultiply);</span>
<span class="line-added">+         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">+         callArguments.append(WTFMove(previous));</span>
<span class="line-added">+         callArguments.append(WTFMove(*next));</span>
  
          switch (add-&gt;type) {
<span class="line-modified">!         case Token::Type::Plus: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(add-&gt;type == Token::Type::Minus);</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
  auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     PARSE(parsedPrevious, PossiblePrefix);</span>
<span class="line-modified">!     return completePossibleMultiply(WTFMove(*parsedPrevious));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! auto Parser::completePossibleMultiply(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     while (auto multiply = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::Star,</span>
<span class="line-modified">!         Token::Type::Divide,</span>
<span class="line-modified">!         Token::Type::Mod</span>
<span class="line-modified">!         &gt;()) {</span>
<span class="line-modified">!         PARSE(next, PossiblePrefix);</span>
<span class="line-added">+         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());</span>
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;</span>
<span class="line-added">+         callArguments.append(WTFMove(previous));</span>
<span class="line-added">+         callArguments.append(WTFMove(*next));</span>
  
          switch (multiply-&gt;type) {
<span class="line-modified">!         case Token::Type::Star: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator*&quot;_str, WTFMove(callArguments));</span>
              break;
          }
<span class="line-modified">!         case Token::Type::Divide: {</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator/&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          default: {
<span class="line-modified">!             ASSERT(multiply-&gt;type == Token::Type::Mod);</span>
<span class="line-modified">!             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator%&quot;_str, WTFMove(callArguments));</span>
              break;
          }
          }
      }
  
      return WTFMove(previous);
  }
  
<span class="line-modified">! auto Parser::parsePossiblePrefix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     if (auto prefix = tryTypes&lt;</span>
<span class="line-modified">!         Token::Type::PlusPlus,</span>
<span class="line-modified">!         Token::Type::MinusMinus,</span>
<span class="line-modified">!         Token::Type::Plus,</span>
<span class="line-modified">!         Token::Type::Minus,</span>
<span class="line-modified">!         Token::Type::Tilde,</span>
<span class="line-modified">!         Token::Type::ExclamationPoint,</span>
<span class="line-modified">!         Token::Type::And,</span>
<span class="line-modified">!         Token::Type::At,</span>
<span class="line-modified">!         Token::Type::Star</span>
<span class="line-modified">!     &gt;()) {</span>
<span class="line-modified">!         PARSE(next, PossiblePrefix);</span>
<span class="line-modified">!         CodeLocation location(*prefix, (*next)-&gt;codeLocation());</span>
  
          switch (prefix-&gt;type) {
<span class="line-modified">!         case Token::Type::PlusPlus: {</span>
<span class="line-modified">!             if (isEffectful)</span>
<span class="line-added">+                 *isEffectful = true;</span>
<span class="line-added">+             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));</span>
              result-&gt;setResultExpression(result-&gt;newVariableReference());
              return { WTFMove(result) };
          }
<span class="line-modified">!         case Token::Type::MinusMinus: {</span>
<span class="line-modified">!             if (isEffectful)</span>
<span class="line-added">+                 *isEffectful = true;</span>
<span class="line-added">+             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(result-&gt;oldVariableReference());
<span class="line-modified">!             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));</span>
              result-&gt;setResultExpression(result-&gt;newVariableReference());
              return { WTFMove(result) };
          }
<span class="line-modified">!         case Token::Type::Plus: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Token::Type::Minus: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Token::Type::Tilde: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
              callArguments.append(WTFMove(*next));
<span class="line-modified">!             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator~&quot;_str, WTFMove(callArguments)) };</span>
          }
<span class="line-modified">!         case Token::Type::ExclamationPoint: {</span>
              Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
              castArguments.append(WTFMove(*next));
<span class="line-modified">!             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;bool&quot;_str, WTFMove(castArguments));</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(boolCast)) };</span>
          }
<span class="line-modified">!         case Token::Type::And:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
<span class="line-modified">!         case Token::Type::At:</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };</span>
          default:
<span class="line-modified">!             ASSERT(prefix-&gt;type == Token::Type::Star);</span>
<span class="line-modified">!             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(*next)) };</span>
          }
      }
  
<span class="line-modified">!     return parsePossibleSuffix(isEffectful);</span>
  }
  
<span class="line-modified">! auto Parser::parsePossibleSuffix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;</span>
  {
<span class="line-modified">!     PEEK(token);</span>
<span class="line-modified">!     PEEK_FURTHER(nextToken);</span>
  
<span class="line-added">+     if (token-&gt;type == Token::Type::Identifier &amp;&amp; nextToken-&gt;type == Token::Type::LeftParenthesis) {</span>
<span class="line-added">+         PARSE(expression, CallExpression);</span>
<span class="line-added">+         if (isEffectful)</span>
<span class="line-added">+             *isEffectful = true;</span>
          while (true) {
<span class="line-modified">!             PEEK(suffixToken);</span>
<span class="line-modified">!             if (suffixToken-&gt;type != Token::Type::FullStop &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket)</span>
                  break;
<span class="line-added">+             auto result = parseLimitedSuffixOperator(WTFMove(*expression));</span>
<span class="line-added">+             expression = WTFMove(result.result);</span>
          }
          return expression;
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (token-&gt;type == Token::Type::LeftParenthesis &amp;&amp; isEffectful)</span>
<span class="line-modified">!         *isEffectful = true;</span>
  
<span class="line-modified">!     PARSE(expression, Term);</span>
<span class="line-modified">!     bool isLastSuffixTokenEffectful = false;</span>
<span class="line-modified">!     while (true) {</span>
<span class="line-modified">!         PEEK(suffixToken);</span>
<span class="line-modified">!         if (suffixToken-&gt;type != Token::Type::FullStop</span>
<span class="line-modified">!             &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow</span>
<span class="line-modified">!             &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket</span>
<span class="line-added">+             &amp;&amp; suffixToken-&gt;type != Token::Type::PlusPlus</span>
<span class="line-added">+             &amp;&amp; suffixToken-&gt;type != Token::Type::MinusMinus) {</span>
<span class="line-added">+             break;</span>
          }
<span class="line-modified">!         isLastSuffixTokenEffectful = suffixToken-&gt;type == Token::Type::PlusPlus || suffixToken-&gt;type == Token::Type::MinusMinus;</span>
<span class="line-modified">!         auto result = parseSuffixOperator(WTFMove(*expression));</span>
<span class="line-modified">!         expression = WTFMove(result.result);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (isLastSuffixTokenEffectful &amp;&amp; isEffectful)</span>
<span class="line-modified">!         *isEffectful = true;</span>
<span class="line-added">+     return expression;</span>
  }
  
  auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     CONSUME_TYPE(name, Identifier);</span>
<span class="line-modified">!     auto callName = name-&gt;stringView(m_lexer).toString();</span>
  
<span class="line-modified">!     CONSUME_TYPE(leftParenthesis, LeftParenthesis);</span>
  
      Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
<span class="line-modified">!     if (tryType(Token::Type::RightParenthesis))</span>
          return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
  
<span class="line-modified">!     PARSE(firstArgument, PossibleTernaryConditional);</span>
      arguments.append(WTFMove(*firstArgument));
<span class="line-modified">!     while (tryType(Token::Type::Comma)) {</span>
<span class="line-modified">!         PARSE(argument, PossibleTernaryConditional);</span>
          arguments.append(WTFMove(*argument));
      }
  
<span class="line-modified">!     CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
<span class="line-modified">!     CodeLocation location(*name, *rightParenthesis);</span>
  
<span class="line-modified">!     return { makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(callName), WTFMove(arguments)) };</span>
  }
  
  auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
  {
<span class="line-modified">!     auto type = consumeTypes&lt;</span>
<span class="line-modified">!         Token::Type::IntLiteral,</span>
<span class="line-modified">!         Token::Type::UintLiteral,</span>
<span class="line-modified">!         Token::Type::FloatLiteral,</span>
<span class="line-modified">!         Token::Type::Null,</span>
<span class="line-modified">!         Token::Type::True,</span>
<span class="line-modified">!         Token::Type::False,</span>
<span class="line-modified">!         Token::Type::Identifier,</span>
<span class="line-modified">!         Token::Type::LeftParenthesis&gt;();</span>
      if (!type)
<span class="line-modified">!         return makeUnexpected(type.error());</span>
  
      switch (type-&gt;type) {
<span class="line-modified">!     case Token::Type::IntLiteral: {</span>
<span class="line-modified">!         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };</span>
      }
<span class="line-modified">!     case Token::Type::UintLiteral: {</span>
<span class="line-modified">!         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };</span>
      }
<span class="line-modified">!     case Token::Type::FloatLiteral: {</span>
<span class="line-modified">!         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));</span>
          if (!value)
<span class="line-modified">!             return makeUnexpected(value.error());</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case Token::Type::Null:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::NullLiteral&gt;(*type) };</span>
<span class="line-modified">!     case Token::Type::True:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };</span>
<span class="line-modified">!     case Token::Type::False:</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };</span>
<span class="line-modified">!     case Token::Type::Identifier: {</span>
<span class="line-modified">!         auto name = type-&gt;stringView(m_lexer).toString();</span>
<span class="line-modified">!         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };</span>
      }
      default: {
<span class="line-modified">!         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);</span>
<span class="line-modified">!         PARSE(expression, Expression);</span>
<span class="line-modified">!         CONSUME_TYPE(rightParenthesis, RightParenthesis);</span>
  
          return { WTFMove(*expression) };
      }
      }
  }
</pre>
<center><a href="WHLSLNameResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLParser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>