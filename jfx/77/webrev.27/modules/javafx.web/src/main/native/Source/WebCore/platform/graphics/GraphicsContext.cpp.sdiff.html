<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GradientImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36 #include &quot;RoundedRect.h&quot;
  37 #include &quot;TextRun.h&quot;
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 class TextRunIterator {
  43 public:
  44     TextRunIterator()
  45         : m_textRun(0)
  46         , m_offset(0)
  47     {
  48     }
  49 
  50     TextRunIterator(const TextRun* textRun, unsigned offset)
  51         : m_textRun(textRun)
  52         , m_offset(offset)
  53     {
  54     }
  55 
<span class="line-removed">  56     TextRunIterator(const TextRunIterator&amp; other)</span>
<span class="line-removed">  57         : m_textRun(other.m_textRun)</span>
<span class="line-removed">  58         , m_offset(other.m_offset)</span>
<span class="line-removed">  59     {</span>
<span class="line-removed">  60     }</span>
<span class="line-removed">  61 </span>
  62     unsigned offset() const { return m_offset; }
  63     void increment() { m_offset++; }
  64     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  65     UChar current() const { return (*m_textRun)[m_offset]; }
  66     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  67 
  68     bool operator==(const TextRunIterator&amp; other)
  69     {
  70         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  71     }
  72 
  73     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  74 
  75 private:
  76     const TextRun* m_textRun;
  77     unsigned m_offset;
  78 };
  79 
  80 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
  81     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \
</pre>
<hr />
<pre>
  98 
  99     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
 100     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
 101     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
 102     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
 103     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
 104     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
 105     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 106 
 107     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 108         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))
 109         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);
 110 
 111     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 112     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 113     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 114     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 115     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 116     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 117 




 118     return changeFlags;
 119 }
 120 
 121 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 122 {
 123     // FIXME: This code should move to GraphicsContextState.
 124     if (flags &amp; GraphicsContextState::StrokeGradientChange)
 125         m_state.strokeGradient = state.strokeGradient;
 126 
 127     if (flags &amp; GraphicsContextState::StrokePatternChange)
 128         m_state.strokePattern = state.strokePattern;
 129 
 130     if (flags &amp; GraphicsContextState::FillGradientChange)
 131         m_state.fillGradient = state.fillGradient;
 132 
 133     if (flags &amp; GraphicsContextState::FillPatternChange)
 134         m_state.fillPattern = state.fillPattern;
 135 
 136     if (flags &amp; GraphicsContextState::ShadowChange) {
 137         // FIXME: Deal with state.shadowsUseLegacyRadius.
</pre>
<hr />
<pre>
 167     }
 168 
 169     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)
 170         m_state.shouldAntialias = state.shouldAntialias;
 171 
 172     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 173         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 174 
 175     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 176         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 177 
 178     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 179         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 180 
 181     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 182         m_state.drawLuminanceMask = state.drawLuminanceMask;
 183 
 184     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 185         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 186 





 187     m_changeFlags |= flags;
 188 }
 189 
 190 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 191 {
 192     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 193         context.setStrokeGradient(*m_state.strokeGradient);
 194 
 195     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 196         context.setStrokePattern(*m_state.strokePattern);
 197 
 198     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 199         context.setFillGradient(*m_state.fillGradient);
 200 
 201     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 202         context.setFillPattern(*m_state.fillPattern);
 203 
 204     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 205 #if USE(CG)
 206         if (m_state.shadowsUseLegacyRadius)
</pre>
<hr />
<pre>
 234     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 235         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 236 
 237     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 238         context.setShouldAntialias(m_state.shouldAntialias);
 239 
 240     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 241         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 242 
 243     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 244         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 245 
 246     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 247         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 248 
 249     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 250         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 251 
 252     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 253         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);





 254 }
 255 
 256 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 257 {
 258     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);
 259 
 260     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 261         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 262 
 263     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 264         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 265 
 266     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 267         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 268 
 269     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 270         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 271 
 272     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 273         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
</pre>
<hr />
<pre>
 301     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)
 302         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 303 
 304     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)
 305         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 306 
 307     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 308         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 309 
 310     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 311         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 312 
 313     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 314         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 315 
 316     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 317         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 318 
 319     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 320         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);





 321 }
 322 
 323 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 324 {
 325     stateChange.dump(ts);
 326     return ts;
 327 }
 328 
 329 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 330     : m_paintInvalidationReasons(paintInvalidationReasons)
 331 {
 332 }
 333 
 334 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 335 {
 336     platformInit(platformGraphicsContext);
 337 }
 338 
 339 GraphicsContext::GraphicsContext(const GraphicsContextImplFactory&amp; factoryFunction)
 340     : m_impl(factoryFunction(*this))
</pre>
<hr />
<pre>
 636     if (paintingDisabled())
 637         return 0;
 638 
 639     // Display list recording for text content is done at glyphs level. See GraphicsContext::drawGlyphs.
 640     return font.drawText(*this, run, point, from, to);
 641 }
 642 
 643 void GraphicsContext::drawGlyphs(const Font&amp; font, const GlyphBuffer&amp; buffer, unsigned from, unsigned numGlyphs, const FloatPoint&amp; point, FontSmoothingMode fontSmoothingMode)
 644 {
 645     if (paintingDisabled())
 646         return;
 647 
 648     if (m_impl) {
 649         m_impl-&gt;drawGlyphs(font, buffer, from, numGlyphs, point, fontSmoothingMode);
 650         return;
 651     }
 652 
 653     FontCascade::drawGlyphs(*this, font, buffer, from, numGlyphs, point, fontSmoothingMode);
 654 }
 655 
<span class="line-modified"> 656 void GraphicsContext::drawEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; run, const AtomicString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)</span>
 657 {
 658     if (paintingDisabled())
 659         return;
 660 
 661     font.drawEmphasisMarks(*this, run, mark, point, from, to);
 662 }
 663 
 664 void GraphicsContext::drawBidiText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
 665 {
 666     if (paintingDisabled())
 667         return;
 668 
 669     BidiResolver&lt;TextRunIterator, BidiCharacterRun&gt; bidiResolver;
 670     bidiResolver.setStatus(BidiStatus(run.direction(), run.directionalOverride()));
 671     bidiResolver.setPositionIgnoringNestedIsolates(TextRunIterator(&amp;run, 0));
 672 
 673     // FIXME: This ownership should be reversed. We should pass BidiRunList
 674     // to BidiResolver in createBidiRunsForLine.
 675     BidiRunList&lt;BidiCharacterRun&gt;&amp; bidiRuns = bidiResolver.runs();
 676     bidiResolver.createBidiRunsForLine(TextRunIterator(&amp;run, run.length()));
</pre>
<hr />
<pre>
 685         bool isRTL = bidiRun-&gt;level() % 2;
 686         subrun.setDirection(isRTL ? TextDirection::RTL : TextDirection::LTR);
 687         subrun.setDirectionalOverride(bidiRun-&gt;dirOverride(false));
 688 
 689         float width = font.drawText(*this, subrun, currPoint, 0, WTF::nullopt, customFontNotReadyAction);
 690         currPoint.move(width, 0);
 691 
 692         bidiRun = bidiRun-&gt;next();
 693     }
 694 
 695     bidiRuns.clear();
 696 }
 697 
 698 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 699 {
 700     return drawImage(image, FloatRect(destination, image.size()), FloatRect(FloatPoint(), image.size()), imagePaintingOptions);
 701 }
 702 
 703 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 704 {
<span class="line-removed"> 705 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 706     FloatRect srcRect(FloatPoint(), image.originalSize());</span>
<span class="line-removed"> 707 #else</span>
 708     FloatRect srcRect(FloatPoint(), image.size());
<span class="line-removed"> 709 #endif</span>
<span class="line-removed"> 710 </span>
 711     return drawImage(image, destination, srcRect, imagePaintingOptions);
 712 }
 713 
<span class="line-modified"> 714 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 715 {
 716     if (paintingDisabled())
 717         return ImageDrawResult::DidNothing;
 718 
 719     if (m_impl)
<span class="line-modified"> 720         return m_impl-&gt;drawImage(image, destination, source, imagePaintingOptions);</span>
 721 
<span class="line-modified"> 722     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 723     return image.draw(*this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode, imagePaintingOptions.m_decodingMode, imagePaintingOptions.m_orientationDescription);</span>
 724 }
 725 
<span class="line-modified"> 726 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 727 {
 728     if (paintingDisabled())
 729         return ImageDrawResult::DidNothing;
 730 
 731     if (m_impl)
<span class="line-modified"> 732         return m_impl-&gt;drawTiledImage(image, destination, source, tileSize, spacing, imagePaintingOptions);</span>
 733 
<span class="line-modified"> 734     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 735     return image.drawTiled(*this, destination, source, tileSize, spacing, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode, imagePaintingOptions.m_decodingMode);</span>
 736 }
 737 
 738 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,
<span class="line-modified"> 739     Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 740 {
 741     if (paintingDisabled())
 742         return ImageDrawResult::DidNothing;
 743 
 744     if (m_impl)
<span class="line-modified"> 745         return m_impl-&gt;drawTiledImage(image, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions);</span>
 746 
 747     if (hRule == Image::StretchTile &amp;&amp; vRule == Image::StretchTile) {
 748         // Just do a scale.
<span class="line-modified"> 749         return drawImage(image, destination, source, imagePaintingOptions);</span>
 750     }
 751 
<span class="line-modified"> 752     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 753     return image.drawTiled(*this, destination, source, tileScaleFactor, hRule, vRule, imagePaintingOptions.m_compositeOperator);</span>
 754 }
 755 
 756 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 757 {
 758     drawImageBuffer(image, FloatRect(destination, image.logicalSize()), FloatRect(FloatPoint(), image.logicalSize()), imagePaintingOptions);
 759 }
 760 
 761 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 762 {
 763     drawImageBuffer(image, destination, FloatRect(FloatPoint(), FloatSize(image.logicalSize())), imagePaintingOptions);
 764 }
 765 
<span class="line-modified"> 766 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 767 {
 768     if (paintingDisabled())
 769         return;
 770 
<span class="line-modified"> 771     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 772     image.draw(*this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode);</span>
 773 }
 774 
 775 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 776 {
 777     if (!image)
 778         return;
 779     IntSize imageLogicalSize = image-&gt;logicalSize();
 780     drawConsumingImageBuffer(WTFMove(image), FloatRect(destination, imageLogicalSize), FloatRect(FloatPoint(), imageLogicalSize), imagePaintingOptions);
 781 }
 782 
 783 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 784 {
 785     if (!image)
 786         return;
 787     IntSize imageLogicalSize = image-&gt;logicalSize();
 788     drawConsumingImageBuffer(WTFMove(image), destination, FloatRect(FloatPoint(), FloatSize(imageLogicalSize)), imagePaintingOptions);
 789 }
 790 
<span class="line-modified"> 791 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)</span>
 792 {
 793     if (paintingDisabled() || !image)
 794         return;
 795 
<span class="line-modified"> 796     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, imagePaintingOptions.m_interpolationQuality);</span>
<span class="line-modified"> 797     ImageBuffer::drawConsuming(WTFMove(image), *this, destination, source, imagePaintingOptions.m_compositeOperator, imagePaintingOptions.m_blendMode);</span>
 798 }
 799 
 800 void GraphicsContext::clipRoundedRect(const FloatRoundedRect&amp; rect)
 801 {
 802     if (paintingDisabled())
 803         return;
 804 
 805     Path path;
 806     path.addRoundedRect(rect);
 807     clipPath(path);
 808 }
 809 
 810 void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect&amp; rect)
 811 {
 812     if (paintingDisabled())
 813         return;
 814 
 815     if (!rect.isRounded()) {
 816         clipOut(rect.rect());
 817         return;
</pre>
<hr />
<pre>
 930 }
 931 
 932 void GraphicsContext::setCompositeOperation(CompositeOperator compositeOperation, BlendMode blendMode)
 933 {
 934     m_state.compositeOperator = compositeOperation;
 935     m_state.blendMode = blendMode;
 936     if (m_impl) {
 937         m_impl-&gt;updateState(m_state, GraphicsContextState::CompositeOperationChange);
 938         return;
 939     }
 940     setPlatformCompositeOperation(compositeOperation, blendMode);
 941 }
 942 
 943 void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
 944 {
 945     m_state.drawLuminanceMask = drawLuminanceMask;
 946     if (m_impl)
 947         m_impl-&gt;updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 948 }
 949 









 950 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 951 // Implement this if you want to go push the drawing mode into your native context immediately.
 952 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 953 {
 954 }
 955 #endif
 956 
 957 #if !USE(CAIRO) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 958 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 959 {
 960 }
 961 #endif
 962 
 963 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
 964 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 965 {
 966 }
 967 #endif
 968 
 969 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO)
</pre>
</td>
<td>
<hr />
<pre>
  36 #include &quot;RoundedRect.h&quot;
  37 #include &quot;TextRun.h&quot;
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 class TextRunIterator {
  43 public:
  44     TextRunIterator()
  45         : m_textRun(0)
  46         , m_offset(0)
  47     {
  48     }
  49 
  50     TextRunIterator(const TextRun* textRun, unsigned offset)
  51         : m_textRun(textRun)
  52         , m_offset(offset)
  53     {
  54     }
  55 






  56     unsigned offset() const { return m_offset; }
  57     void increment() { m_offset++; }
  58     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  59     UChar current() const { return (*m_textRun)[m_offset]; }
  60     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  61 
  62     bool operator==(const TextRunIterator&amp; other)
  63     {
  64         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  65     }
  66 
  67     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  68 
  69 private:
  70     const TextRun* m_textRun;
  71     unsigned m_offset;
  72 };
  73 
  74 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
  75     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \
</pre>
<hr />
<pre>
  92 
  93     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
  94     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
  95     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
  96     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
  97     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
  98     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
  99     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 100 
 101     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 102         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))
 103         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);
 104 
 105     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 106     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 107     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 108     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 109     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 110     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 111 
<span class="line-added"> 112 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 113     CHECK_FOR_CHANGED_PROPERTY(UseDarkAppearanceChange, useDarkAppearance);</span>
<span class="line-added"> 114 #endif</span>
<span class="line-added"> 115 </span>
 116     return changeFlags;
 117 }
 118 
 119 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 120 {
 121     // FIXME: This code should move to GraphicsContextState.
 122     if (flags &amp; GraphicsContextState::StrokeGradientChange)
 123         m_state.strokeGradient = state.strokeGradient;
 124 
 125     if (flags &amp; GraphicsContextState::StrokePatternChange)
 126         m_state.strokePattern = state.strokePattern;
 127 
 128     if (flags &amp; GraphicsContextState::FillGradientChange)
 129         m_state.fillGradient = state.fillGradient;
 130 
 131     if (flags &amp; GraphicsContextState::FillPatternChange)
 132         m_state.fillPattern = state.fillPattern;
 133 
 134     if (flags &amp; GraphicsContextState::ShadowChange) {
 135         // FIXME: Deal with state.shadowsUseLegacyRadius.
</pre>
<hr />
<pre>
 165     }
 166 
 167     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)
 168         m_state.shouldAntialias = state.shouldAntialias;
 169 
 170     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 171         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 172 
 173     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 174         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 175 
 176     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 177         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 178 
 179     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 180         m_state.drawLuminanceMask = state.drawLuminanceMask;
 181 
 182     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 183         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 184 
<span class="line-added"> 185 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 186     if (flags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 187         m_state.useDarkAppearance = state.useDarkAppearance;</span>
<span class="line-added"> 188 #endif</span>
<span class="line-added"> 189 </span>
 190     m_changeFlags |= flags;
 191 }
 192 
 193 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 194 {
 195     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 196         context.setStrokeGradient(*m_state.strokeGradient);
 197 
 198     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 199         context.setStrokePattern(*m_state.strokePattern);
 200 
 201     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 202         context.setFillGradient(*m_state.fillGradient);
 203 
 204     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 205         context.setFillPattern(*m_state.fillPattern);
 206 
 207     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 208 #if USE(CG)
 209         if (m_state.shadowsUseLegacyRadius)
</pre>
<hr />
<pre>
 237     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 238         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 239 
 240     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 241         context.setShouldAntialias(m_state.shouldAntialias);
 242 
 243     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 244         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 245 
 246     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 247         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 248 
 249     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 250         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 251 
 252     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 253         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 254 
 255     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 256         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
<span class="line-added"> 257 </span>
<span class="line-added"> 258 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 259     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 260         context.setUseDarkAppearance(m_state.useDarkAppearance);</span>
<span class="line-added"> 261 #endif</span>
 262 }
 263 
 264 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 265 {
 266     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);
 267 
 268     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 269         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 270 
 271     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 272         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 273 
 274     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 275         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 276 
 277     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 278         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 279 
 280     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 281         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
</pre>
<hr />
<pre>
 309     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)
 310         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 311 
 312     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)
 313         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 314 
 315     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 316         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 317 
 318     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 319         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 320 
 321     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 322         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 323 
 324     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 325         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 326 
 327     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 328         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
<span class="line-added"> 329 </span>
<span class="line-added"> 330 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 331     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 332         ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);</span>
<span class="line-added"> 333 #endif</span>
 334 }
 335 
 336 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 337 {
 338     stateChange.dump(ts);
 339     return ts;
 340 }
 341 
 342 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 343     : m_paintInvalidationReasons(paintInvalidationReasons)
 344 {
 345 }
 346 
 347 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 348 {
 349     platformInit(platformGraphicsContext);
 350 }
 351 
 352 GraphicsContext::GraphicsContext(const GraphicsContextImplFactory&amp; factoryFunction)
 353     : m_impl(factoryFunction(*this))
</pre>
<hr />
<pre>
 649     if (paintingDisabled())
 650         return 0;
 651 
 652     // Display list recording for text content is done at glyphs level. See GraphicsContext::drawGlyphs.
 653     return font.drawText(*this, run, point, from, to);
 654 }
 655 
 656 void GraphicsContext::drawGlyphs(const Font&amp; font, const GlyphBuffer&amp; buffer, unsigned from, unsigned numGlyphs, const FloatPoint&amp; point, FontSmoothingMode fontSmoothingMode)
 657 {
 658     if (paintingDisabled())
 659         return;
 660 
 661     if (m_impl) {
 662         m_impl-&gt;drawGlyphs(font, buffer, from, numGlyphs, point, fontSmoothingMode);
 663         return;
 664     }
 665 
 666     FontCascade::drawGlyphs(*this, font, buffer, from, numGlyphs, point, fontSmoothingMode);
 667 }
 668 
<span class="line-modified"> 669 void GraphicsContext::drawEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)</span>
 670 {
 671     if (paintingDisabled())
 672         return;
 673 
 674     font.drawEmphasisMarks(*this, run, mark, point, from, to);
 675 }
 676 
 677 void GraphicsContext::drawBidiText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
 678 {
 679     if (paintingDisabled())
 680         return;
 681 
 682     BidiResolver&lt;TextRunIterator, BidiCharacterRun&gt; bidiResolver;
 683     bidiResolver.setStatus(BidiStatus(run.direction(), run.directionalOverride()));
 684     bidiResolver.setPositionIgnoringNestedIsolates(TextRunIterator(&amp;run, 0));
 685 
 686     // FIXME: This ownership should be reversed. We should pass BidiRunList
 687     // to BidiResolver in createBidiRunsForLine.
 688     BidiRunList&lt;BidiCharacterRun&gt;&amp; bidiRuns = bidiResolver.runs();
 689     bidiResolver.createBidiRunsForLine(TextRunIterator(&amp;run, run.length()));
</pre>
<hr />
<pre>
 698         bool isRTL = bidiRun-&gt;level() % 2;
 699         subrun.setDirection(isRTL ? TextDirection::RTL : TextDirection::LTR);
 700         subrun.setDirectionalOverride(bidiRun-&gt;dirOverride(false));
 701 
 702         float width = font.drawText(*this, subrun, currPoint, 0, WTF::nullopt, customFontNotReadyAction);
 703         currPoint.move(width, 0);
 704 
 705         bidiRun = bidiRun-&gt;next();
 706     }
 707 
 708     bidiRuns.clear();
 709 }
 710 
 711 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 712 {
 713     return drawImage(image, FloatRect(destination, image.size()), FloatRect(FloatPoint(), image.size()), imagePaintingOptions);
 714 }
 715 
 716 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 717 {



 718     FloatRect srcRect(FloatPoint(), image.size());


 719     return drawImage(image, destination, srcRect, imagePaintingOptions);
 720 }
 721 
<span class="line-modified"> 722 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 723 {
 724     if (paintingDisabled())
 725         return ImageDrawResult::DidNothing;
 726 
 727     if (m_impl)
<span class="line-modified"> 728         return m_impl-&gt;drawImage(image, destination, source, options);</span>
 729 
<span class="line-modified"> 730     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 731     return image.draw(*this, destination, source, options);</span>
 732 }
 733 
<span class="line-modified"> 734 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)</span>
 735 {
 736     if (paintingDisabled())
 737         return ImageDrawResult::DidNothing;
 738 
 739     if (m_impl)
<span class="line-modified"> 740         return m_impl-&gt;drawTiledImage(image, destination, source, tileSize, spacing, options);</span>
 741 
<span class="line-modified"> 742     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 743     return image.drawTiled(*this, destination, source, tileSize, spacing, options);</span>
 744 }
 745 
 746 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,
<span class="line-modified"> 747     Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; options)</span>
 748 {
 749     if (paintingDisabled())
 750         return ImageDrawResult::DidNothing;
 751 
 752     if (m_impl)
<span class="line-modified"> 753         return m_impl-&gt;drawTiledImage(image, destination, source, tileScaleFactor, hRule, vRule, options);</span>
 754 
 755     if (hRule == Image::StretchTile &amp;&amp; vRule == Image::StretchTile) {
 756         // Just do a scale.
<span class="line-modified"> 757         return drawImage(image, destination, source, options);</span>
 758     }
 759 
<span class="line-modified"> 760     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 761     return image.drawTiled(*this, destination, source, tileScaleFactor, hRule, vRule, options.compositeOperator());</span>
 762 }
 763 
 764 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 765 {
 766     drawImageBuffer(image, FloatRect(destination, image.logicalSize()), FloatRect(FloatPoint(), image.logicalSize()), imagePaintingOptions);
 767 }
 768 
 769 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 770 {
 771     drawImageBuffer(image, destination, FloatRect(FloatPoint(), FloatSize(image.logicalSize())), imagePaintingOptions);
 772 }
 773 
<span class="line-modified"> 774 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 775 {
 776     if (paintingDisabled())
 777         return;
 778 
<span class="line-modified"> 779     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 780     image.draw(*this, destination, source, options);</span>
 781 }
 782 
 783 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 784 {
 785     if (!image)
 786         return;
 787     IntSize imageLogicalSize = image-&gt;logicalSize();
 788     drawConsumingImageBuffer(WTFMove(image), FloatRect(destination, imageLogicalSize), FloatRect(FloatPoint(), imageLogicalSize), imagePaintingOptions);
 789 }
 790 
 791 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 792 {
 793     if (!image)
 794         return;
 795     IntSize imageLogicalSize = image-&gt;logicalSize();
 796     drawConsumingImageBuffer(WTFMove(image), destination, FloatRect(FloatPoint(), FloatSize(imageLogicalSize)), imagePaintingOptions);
 797 }
 798 
<span class="line-modified"> 799 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 800 {
 801     if (paintingDisabled() || !image)
 802         return;
 803 
<span class="line-modified"> 804     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 805     ImageBuffer::drawConsuming(WTFMove(image), *this, destination, source, options);</span>
 806 }
 807 
 808 void GraphicsContext::clipRoundedRect(const FloatRoundedRect&amp; rect)
 809 {
 810     if (paintingDisabled())
 811         return;
 812 
 813     Path path;
 814     path.addRoundedRect(rect);
 815     clipPath(path);
 816 }
 817 
 818 void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect&amp; rect)
 819 {
 820     if (paintingDisabled())
 821         return;
 822 
 823     if (!rect.isRounded()) {
 824         clipOut(rect.rect());
 825         return;
</pre>
<hr />
<pre>
 938 }
 939 
 940 void GraphicsContext::setCompositeOperation(CompositeOperator compositeOperation, BlendMode blendMode)
 941 {
 942     m_state.compositeOperator = compositeOperation;
 943     m_state.blendMode = blendMode;
 944     if (m_impl) {
 945         m_impl-&gt;updateState(m_state, GraphicsContextState::CompositeOperationChange);
 946         return;
 947     }
 948     setPlatformCompositeOperation(compositeOperation, blendMode);
 949 }
 950 
 951 void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
 952 {
 953     m_state.drawLuminanceMask = drawLuminanceMask;
 954     if (m_impl)
 955         m_impl-&gt;updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 956 }
 957 
<span class="line-added"> 958 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 959 void GraphicsContext::setUseDarkAppearance(bool useDarkAppearance)</span>
<span class="line-added"> 960 {</span>
<span class="line-added"> 961     m_state.useDarkAppearance = useDarkAppearance;</span>
<span class="line-added"> 962     if (m_impl)</span>
<span class="line-added"> 963         m_impl-&gt;updateState(m_state, GraphicsContextState::UseDarkAppearanceChange);</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 #endif</span>
<span class="line-added"> 966 </span>
 967 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 968 // Implement this if you want to go push the drawing mode into your native context immediately.
 969 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 970 {
 971 }
 972 #endif
 973 
 974 #if !USE(CAIRO) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 975 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 976 {
 977 }
 978 #endif
 979 
 980 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
 981 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 982 {
 983 }
 984 #endif
 985 
 986 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO)
</pre>
</td>
</tr>
</table>
<center><a href="GradientImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>