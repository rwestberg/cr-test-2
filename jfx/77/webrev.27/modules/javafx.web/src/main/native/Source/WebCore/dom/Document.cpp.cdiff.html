<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeviceOrientationEvent.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,11 ***</span>
  /*
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   *           (C) 2001 Dirk Mueller (mueller@kde.org)
   *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">!  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
   *
<span class="line-new-header">--- 1,11 ---</span>
  /*
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   *           (C) 2001 Dirk Mueller (mueller@kde.org)
   *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">!  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,15 ***</span>
  #include &quot;ContentSecurityPolicy.h&quot;
  #include &quot;CookieJar.h&quot;
  #include &quot;CustomElementReactionQueue.h&quot;
  #include &quot;CustomElementRegistry.h&quot;
  #include &quot;CustomEvent.h&quot;
  #include &quot;DOMImplementation.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;DateComponents.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
<span class="line-removed">- #include &quot;DocumentAnimationScheduler.h&quot;</span>
  #include &quot;DocumentLoader.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DocumentSharedObjectPool.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;DocumentType.h&quot;
<span class="line-new-header">--- 51,15 ---</span>
  #include &quot;ContentSecurityPolicy.h&quot;
  #include &quot;CookieJar.h&quot;
  #include &quot;CustomElementReactionQueue.h&quot;
  #include &quot;CustomElementRegistry.h&quot;
  #include &quot;CustomEvent.h&quot;
<span class="line-added">+ #include &quot;CustomHeaderFields.h&quot;</span>
  #include &quot;DOMImplementation.h&quot;
  #include &quot;DOMWindow.h&quot;
  #include &quot;DateComponents.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
  #include &quot;DocumentLoader.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
  #include &quot;DocumentSharedObjectPool.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;DocumentType.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 74,11 ---</span>
  #include &quot;FormController.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;FrameView.h&quot;
<span class="line-added">+ #include &quot;FullscreenManager.h&quot;</span>
  #include &quot;GenericCachedHTMLCollection.h&quot;
  #include &quot;HTMLAllCollection.h&quot;
  #include &quot;HTMLAnchorElement.h&quot;
  #include &quot;HTMLAttachmentElement.h&quot;
  #include &quot;HTMLBaseElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,11 ***</span>
  #include &quot;ImageBitmapRenderingContext.h&quot;
  #include &quot;ImageLoader.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;IntersectionObserver.h&quot;
  #include &quot;JSCustomElementInterface.h&quot;
<span class="line-removed">- #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;JSLazyEventListener.h&quot;
  #include &quot;KeyboardEvent.h&quot;
  #include &quot;KeyframeEffect.h&quot;
  #include &quot;LayoutDisallowedScope.h&quot;
  #include &quot;LibWebRTCProvider.h&quot;
<span class="line-new-header">--- 111,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,10 ***</span>
<span class="line-new-header">--- 122,11 ---</span>
  #include &quot;Logging.h&quot;
  #include &quot;MediaCanStartListener.h&quot;
  #include &quot;MediaProducer.h&quot;
  #include &quot;MediaQueryList.h&quot;
  #include &quot;MediaQueryMatcher.h&quot;
<span class="line-added">+ #include &quot;MediaStream.h&quot;</span>
  #include &quot;MessageEvent.h&quot;
  #include &quot;Microtasks.h&quot;
  #include &quot;MouseEventWithHitTestResults.h&quot;
  #include &quot;MutationEvent.h&quot;
  #include &quot;NameNodeList.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
  #include &quot;NavigationScheduler.h&quot;
  #include &quot;NestingLevelIncrementer.h&quot;
  #include &quot;NodeIterator.h&quot;
  #include &quot;NodeRareData.h&quot;
  #include &quot;NodeWithIndex.h&quot;
<span class="line-removed">- #include &quot;OriginAccessEntry.h&quot;</span>
  #include &quot;OverflowEvent.h&quot;
  #include &quot;PageConsoleClient.h&quot;
  #include &quot;PageGroup.h&quot;
  #include &quot;PageTransitionEvent.h&quot;
  #include &quot;PaintWorkletGlobalScope.h&quot;
<span class="line-new-header">--- 134,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,10 ***</span>
<span class="line-new-header">--- 160,11 ---</span>
  #include &quot;RenderLineBreak.h&quot;
  #include &quot;RenderTreeUpdater.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RenderWidget.h&quot;
  #include &quot;RequestAnimationFrameCallback.h&quot;
<span class="line-added">+ #include &quot;ResizeObserver.h&quot;</span>
  #include &quot;ResourceLoadObserver.h&quot;
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;SVGDocumentExtensions.h&quot;
  #include &quot;SVGElement.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,10 ***</span>
<span class="line-new-header">--- 249,11 ---</span>
  #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
  #endif
  
  #if ENABLE(DEVICE_ORIENTATION)
  #include &quot;DeviceMotionEvent.h&quot;
<span class="line-added">+ #include &quot;DeviceOrientationAndMotionAccessController.h&quot;</span>
  #include &quot;DeviceOrientationEvent.h&quot;
  #endif
  
  #if ENABLE(FULLSCREEN_API)
  #include &quot;RenderFullScreen.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,20 ***</span>
  #include &quot;IDBConnectionProxy.h&quot;
  #include &quot;IDBOpenDBRequest.h&quot;
  #endif
  
  #if PLATFORM(IOS_FAMILY)
  #include &quot;CSSFontSelector.h&quot;
  #include &quot;DeviceMotionClientIOS.h&quot;
  #include &quot;DeviceMotionController.h&quot;
  #include &quot;DeviceOrientationClientIOS.h&quot;
  #include &quot;DeviceOrientationController.h&quot;
  #include &quot;Geolocation.h&quot;
  #include &quot;Navigator.h&quot;
  #include &quot;NavigatorGeolocation.h&quot;
<span class="line-removed">- #include &quot;WKContentObservation.h&quot;</span>
<span class="line-removed">- #include &quot;WKContentObservationInternal.h&quot;</span>
  #endif
  
  #if ENABLE(IOS_GESTURE_EVENTS)
  #include &quot;GestureEvent.h&quot;
  #endif
<span class="line-new-header">--- 263,20 ---</span>
  #include &quot;IDBConnectionProxy.h&quot;
  #include &quot;IDBOpenDBRequest.h&quot;
  #endif
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-added">+ #include &quot;ContentChangeObserver.h&quot;</span>
  #include &quot;CSSFontSelector.h&quot;
<span class="line-added">+ #include &quot;DOMTimerHoldingTank.h&quot;</span>
  #include &quot;DeviceMotionClientIOS.h&quot;
  #include &quot;DeviceMotionController.h&quot;
  #include &quot;DeviceOrientationClientIOS.h&quot;
  #include &quot;DeviceOrientationController.h&quot;
  #include &quot;Geolocation.h&quot;
  #include &quot;Navigator.h&quot;
  #include &quot;NavigatorGeolocation.h&quot;
  #endif
  
  #if ENABLE(IOS_GESTURE_EVENTS)
  #include &quot;GestureEvent.h&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,26 ***</span>
  
  #if ENABLE(XSLT)
  #include &quot;XSLTProcessor.h&quot;
  #endif
  
<span class="line-removed">- #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed">- #include &quot;MediaStream.h&quot;</span>
<span class="line-removed">- #include &quot;MediaStreamRegistry.h&quot;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(WEBGL)
  #include &quot;WebGLRenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGL2)
  #include &quot;WebGL2RenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">! #include &quot;WebGPURenderingContext.h&quot;</span>
  #endif
<span class="line-modified">! #if ENABLE(WEBMETAL)</span>
<span class="line-modified">! #include &quot;WebMetalRenderingContext.h&quot;</span>
  #endif
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
<span class="line-new-header">--- 309,22 ---</span>
  
  #if ENABLE(XSLT)
  #include &quot;XSLTProcessor.h&quot;
  #endif
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLRenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGL2)
  #include &quot;WebGL2RenderingContext.h&quot;
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">! #include &quot;GPUCanvasContext.h&quot;</span>
  #endif
<span class="line-modified">! </span>
<span class="line-modified">! #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+ #include &quot;PointerCaptureController.h&quot;</span>
  #endif
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,12 ***</span>
  using namespace PAL;
  using namespace WTF::Unicode;
  
  static const unsigned cMaxWriteRecursionDepth = 21;
  bool Document::hasEverCreatedAnAXObjectCache = false;
<span class="line-modified">! </span>
<span class="line-removed">- unsigned ScriptDisallowedScope::LayoutAssertionDisableScope::s_layoutAssertionDisableCount = 0;</span>
  
  struct FrameFlatteningLayoutDisallower {
      FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
          : m_frameView(frameView)
          , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
<span class="line-new-header">--- 333,11 ---</span>
  using namespace PAL;
  using namespace WTF::Unicode;
  
  static const unsigned cMaxWriteRecursionDepth = 21;
  bool Document::hasEverCreatedAnAXObjectCache = false;
<span class="line-modified">! static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };</span>
  
  struct FrameFlatteningLayoutDisallower {
      FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
          : m_frameView(frameView)
          , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,10 ***</span>
<span class="line-new-header">--- 355,14 ---</span>
  private:
      FrameView&amp; m_frameView;
      bool m_disallowLayout { false };
  };
  
<span class="line-added">+ #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-added">+ static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  // DOM Level 2 says (letters added):
  //
  // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
  // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
  // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,45 ***</span>
      UNUSED_PARAM(frame);
  #endif
      return 0;
  }
  
<span class="line-modified">! Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
      : ContainerNode(*this, CreateDocument)
      , TreeScope(*this)
      , FrameDestructionObserver(frame)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
  #endif
      , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
      , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
      , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
      , m_domTreeVersion(++s_globalTreeVersion)
<span class="line-modified">!     , m_styleScope(std::make_unique&lt;Style::Scope&gt;(*this))</span>
<span class="line-modified">!     , m_extensionStyleSheets(std::make_unique&lt;ExtensionStyleSheets&gt;(*this))</span>
<span class="line-modified">!     , m_visitedLinkState(std::make_unique&lt;VisitedLinkState&gt;(*this))</span>
<span class="line-modified">!     , m_markers(std::make_unique&lt;DocumentMarkerController&gt;(*this))</span>
      , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
      , m_documentCreationTime(MonotonicTime::now())
<span class="line-modified">!     , m_scriptRunner(std::make_unique&lt;ScriptRunner&gt;(*this))</span>
<span class="line-modified">!     , m_moduleLoader(std::make_unique&lt;ScriptModuleLoader&gt;(*this))</span>
  #if ENABLE(XSLT)
      , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
  #endif
      , m_xmlVersion(&quot;1.0&quot;_s)
<span class="line-modified">!     , m_constantPropertyMap(std::make_unique&lt;ConstantPropertyMap&gt;(*this))</span>
      , m_documentClasses(documentClasses)
      , m_eventQueue(*this)
  #if ENABLE(INTERSECTION_OBSERVER)
      , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
  #endif
      , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">!     , m_deviceMotionClient(std::make_unique&lt;DeviceMotionClientIOS&gt;())</span>
<span class="line-modified">!     , m_deviceMotionController(std::make_unique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))</span>
<span class="line-modified">!     , m_deviceOrientationClient(std::make_unique&lt;DeviceOrientationClientIOS&gt;())</span>
<span class="line-modified">!     , m_deviceOrientationController(std::make_unique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))</span>
  #endif
      , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
      , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
      , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
      , m_fontSelector(CSSFontSelector::create(*this))
<span class="line-new-header">--- 524,49 ---</span>
      UNUSED_PARAM(frame);
  #endif
      return 0;
  }
  
<span class="line-modified">! Document::Document(PAL::SessionID sessionID, Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
      : ContainerNode(*this, CreateDocument)
      , TreeScope(*this)
      , FrameDestructionObserver(frame)
  #if ENABLE(IOS_TOUCH_EVENTS)
      , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
  #endif
      , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
      , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
      , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
      , m_domTreeVersion(++s_globalTreeVersion)
<span class="line-modified">!     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))</span>
<span class="line-modified">!     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))</span>
<span class="line-modified">!     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))</span>
<span class="line-modified">!     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))</span>
      , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
      , m_documentCreationTime(MonotonicTime::now())
<span class="line-modified">!     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))</span>
<span class="line-modified">!     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))</span>
  #if ENABLE(XSLT)
      , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
  #endif
      , m_xmlVersion(&quot;1.0&quot;_s)
<span class="line-modified">!     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))</span>
      , m_documentClasses(documentClasses)
      , m_eventQueue(*this)
<span class="line-added">+ #if ENABLE(FULLSCREEN_API)</span>
<span class="line-added">+     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }</span>
<span class="line-added">+ #endif</span>
  #if ENABLE(INTERSECTION_OBSERVER)
      , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
<span class="line-added">+     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)</span>
  #endif
      , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified">!     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;())</span>
<span class="line-modified">!     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))</span>
<span class="line-modified">!     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;())</span>
<span class="line-modified">!     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))</span>
  #endif
      , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
      , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
      , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
      , m_fontSelector(CSSFontSelector::create(*this))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,13 ***</span>
<span class="line-new-header">--- 574,16 ---</span>
      , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
      , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
      , m_isSynthesized(constructionFlags &amp; Synthesized)
      , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
      , m_orientationNotifier(currentOrientation(frame))
<span class="line-added">+     , m_sessionID(sessionID)</span>
      , m_identifier(DocumentIdentifier::generate())
      , m_undoManager(UndoManager::create(*this))
  {
<span class="line-added">+     ASSERT(!frame || frame-&gt;sessionID() == m_sessionID);</span>
<span class="line-added">+ </span>
      auto addResult = allDocumentsMap().add(m_identifier, this);
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
  
      // We depend on the url getting immediately set in subframes, but we
      // also depend on the url NOT getting immediately set in opened windows.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,33 ***</span>
          nodeListAndCollectionCount = 0;
  
      InspectorInstrumentation::addEventListenersToNode(*this);
  }
  
<span class="line-removed">- #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool isAttributeOnAllOwners(const WebCore::QualifiedName&amp; attribute, const WebCore::QualifiedName&amp; prefixedAttribute, const HTMLFrameOwnerElement* owner)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!owner)</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     do {</span>
<span class="line-removed">-         if (!(owner-&gt;hasAttribute(attribute) || owner-&gt;hasAttribute(prefixedAttribute)))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-     } while ((owner = owner-&gt;document().ownerElement()));</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
  {
<span class="line-modified">!     auto document = adoptRef(*new Document(nullptr, URL()));</span>
      document-&gt;setContextDocument(contextDocument);
      document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
      return document;
  }
  
  Document::~Document()
  {
      if (m_logger)
          m_logger-&gt;removeObserver(*this);
  
<span class="line-new-header">--- 608,23 ---</span>
          nodeListAndCollectionCount = 0;
  
      InspectorInstrumentation::addEventListenersToNode(*this);
  }
  
  Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
  {
<span class="line-modified">!     auto document = adoptRef(*new Document(contextDocument.sessionID(), nullptr, URL()));</span>
      document-&gt;setContextDocument(contextDocument);
      document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
      return document;
  }
  
<span class="line-added">+ Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return adoptRef(*new Document(frame.sessionID(), &amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Document::~Document()
  {
      if (m_logger)
          m_logger-&gt;removeObserver(*this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,10 ***</span>
<span class="line-new-header">--- 704,14 ---</span>
  
  void Document::removedLastRef()
  {
      ASSERT(!m_deletionHasBegun);
      if (m_referencingNodeCount) {
<span class="line-added">+         // Node::removedLastRef doesn&#39;t set refCount() to zero because it&#39;s not observable.</span>
<span class="line-added">+         // But we need to remember that our refCount reached zero in subsequent calls to decrementReferencingNodeCount().</span>
<span class="line-added">+         m_refCountAndParentBit = 0;</span>
<span class="line-added">+ </span>
          // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
          // until after removeDetachedChildren returns, so we protect ourselves.
          incrementReferencingNodeCount();
  
          RELEASE_ASSERT(!hasLivingRenderTree());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 721,12 ***</span>
          m_titleElement = nullptr;
          m_documentElement = nullptr;
          m_focusNavigationStartingNode = nullptr;
          m_userActionElements.clear();
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!         m_fullScreenElement = nullptr;</span>
<span class="line-removed">-         m_fullScreenElementStack.clear();</span>
  #endif
          m_associatedFormControls.clear();
  
          m_fontSelector-&gt;clearDocument();
          m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
<span class="line-new-header">--- 723,11 ---</span>
          m_titleElement = nullptr;
          m_documentElement = nullptr;
          m_focusNavigationStartingNode = nullptr;
          m_userActionElements.clear();
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!         m_fullscreenManager-&gt;clear();</span>
  #endif
          m_associatedFormControls.clear();
  
          m_fontSelector-&gt;clearDocument();
          m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,11 ***</span>
      } else {
  #ifndef NDEBUG
          m_inRemovedLastRefFunction = false;
          m_deletionHasBegun = true;
  #endif
<span class="line-removed">-         m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
          delete this;
      }
  }
  
  void Document::commonTeardown()
<span class="line-new-header">--- 756,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 779,21 ***</span>
      return m_accessKeyCache-&gt;get(key);
  }
  
  void Document::buildAccessKeyCache()
  {
<span class="line-modified">!     m_accessKeyCache = std::make_unique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {</span>
          HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
          for (auto&amp; node : composedTreeDescendants(*this)) {
              if (!is&lt;Element&gt;(node))
                  continue;
              auto&amp; element = downcast&lt;Element&gt;(node);
              auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
              if (key.isEmpty())
                  continue;
              map.add(key, &amp;element);
<span class="line-modified">!     }</span>
          return map;
      }());
  }
  
  void Document::invalidateAccessKeyCacheSlowCase()
<span class="line-new-header">--- 779,21 ---</span>
      return m_accessKeyCache-&gt;get(key);
  }
  
  void Document::buildAccessKeyCache()
  {
<span class="line-modified">!     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {</span>
          HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
          for (auto&amp; node : composedTreeDescendants(*this)) {
              if (!is&lt;Element&gt;(node))
                  continue;
              auto&amp; element = downcast&lt;Element&gt;(node);
              auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
              if (key.isEmpty())
                  continue;
              map.add(key, &amp;element);
<span class="line-modified">!         }</span>
          return map;
      }());
  }
  
  void Document::invalidateAccessKeyCacheSlowCase()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 804,11 ***</span>
  ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
  {
      if (selectorString.isEmpty())
          return Exception { SyntaxError };
      if (!m_selectorQueryCache)
<span class="line-modified">!         m_selectorQueryCache = std::make_unique&lt;SelectorQueryCache&gt;();</span>
      return m_selectorQueryCache-&gt;add(selectorString, *this);
  }
  
  void Document::clearSelectorQueryCache()
  {
<span class="line-new-header">--- 804,11 ---</span>
  ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
  {
      if (selectorString.isEmpty())
          return Exception { SyntaxError };
      if (!m_selectorQueryCache)
<span class="line-modified">!         m_selectorQueryCache = makeUnique&lt;SelectorQueryCache&gt;();</span>
      return m_selectorQueryCache-&gt;add(selectorString, *this);
  }
  
  void Document::clearSelectorQueryCache()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 869,11 ***</span>
  }
  
  DOMImplementation&amp; Document::implementation()
  {
      if (!m_implementation)
<span class="line-modified">!         m_implementation = std::make_unique&lt;DOMImplementation&gt;(*this);</span>
      return *m_implementation;
  }
  
  bool Document::hasManifest() const
  {
<span class="line-new-header">--- 869,11 ---</span>
  }
  
  DOMImplementation&amp; Document::implementation()
  {
      if (!m_implementation)
<span class="line-modified">!         m_implementation = makeUnique&lt;DOMImplementation&gt;(*this);</span>
      return *m_implementation;
  }
  
  bool Document::hasManifest() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,16 ***</span>
      auto element = HTMLElement::create(name, document);
      element-&gt;setIsCustomElementUpgradeCandidate();
      return element;
  }
  
<span class="line-modified">! static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomicString&amp; localName)</span>
  {
      return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
  }
  
<span class="line-modified">! static inline bool isValidHTMLElementName(const AtomicString&amp; localName)</span>
  {
      return Document::isValidName(localName);
  }
  
  static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
<span class="line-new-header">--- 916,16 ---</span>
      auto element = HTMLElement::create(name, document);
      element-&gt;setIsCustomElementUpgradeCandidate();
      return element;
  }
  
<span class="line-modified">! static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomString&amp; localName)</span>
  {
      return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
  }
  
<span class="line-modified">! static inline bool isValidHTMLElementName(const AtomString&amp; localName)</span>
  {
      return Document::isValidName(localName);
  }
  
  static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,11 ***</span>
          return Exception { InvalidCharacterError };
  
      return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomicString&amp; name)</span>
  {
      if (isHTMLDocument())
          return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
  
      if (isXHTMLDocument())
<span class="line-new-header">--- 952,11 ---</span>
          return Exception { InvalidCharacterError };
  
      return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomString&amp; name)</span>
  {
      if (isHTMLDocument())
          return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
  
      if (isXHTMLDocument())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,14 ***</span>
      case CDATA_SECTION_NODE:
      case PROCESSING_INSTRUCTION_NODE:
      case COMMENT_NODE:
          return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
  
<span class="line-modified">!     case ATTRIBUTE_NODE:</span>
<span class="line-modified">!         // FIXME: This will &quot;Attr::normalize&quot; child nodes of Attr.</span>
<span class="line-modified">!         return Ref&lt;Node&gt; { Attr::create(*this, QualifiedName(nullAtom(), downcast&lt;Attr&gt;(nodeToImport).name(), nullAtom()), downcast&lt;Attr&gt;(nodeToImport).value()) };</span>
<span class="line-modified">! </span>
      case DOCUMENT_NODE: // Can&#39;t import a document into another document.
      case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
          break;
      }
  
<span class="line-new-header">--- 1024,14 ---</span>
      case CDATA_SECTION_NODE:
      case PROCESSING_INSTRUCTION_NODE:
      case COMMENT_NODE:
          return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
  
<span class="line-modified">!     case ATTRIBUTE_NODE: {</span>
<span class="line-modified">!         auto&amp; attribute = downcast&lt;Attr&gt;(nodeToImport);</span>
<span class="line-modified">!         return Ref&lt;Node&gt; { Attr::create(*this, attribute.qualifiedName(), attribute.value()) };</span>
<span class="line-modified">!     }</span>
      case DOCUMENT_NODE: // Can&#39;t import a document into another document.
      case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,11 ***</span>
  
      ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
      return std::binary_search(std::begin(ranges), std::end(ranges), character);
  }
  
<span class="line-modified">! CustomElementNameValidationStatus Document::validateCustomElementName(const AtomicString&amp; localName)</span>
  {
      if (!isASCIILower(localName[0]))
          return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
  
      bool containsHyphen = false;
<span class="line-new-header">--- 1197,11 ---</span>
  
      ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
      return std::binary_search(std::begin(ranges), std::end(ranges), character);
  }
  
<span class="line-modified">! CustomElementNameValidationStatus Document::validateCustomElementName(const AtomString&amp; localName)</span>
  {
      if (!isASCIILower(localName[0]))
          return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
  
      bool containsHyphen = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1218,11 ***</span>
          return CustomElementNameValidationStatus::ContainsNoHyphen;
  
  #if ENABLE(MATHML)
      const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
  #else
<span class="line-modified">!     static NeverDestroyed&lt;const AtomicString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomicString::ConstructFromLiteral);</span>
  #endif
  
      if (localName == SVGNames::color_profileTag-&gt;localName()
          || localName == SVGNames::font_faceTag-&gt;localName()
          || localName == SVGNames::font_face_formatTag-&gt;localName()
<span class="line-new-header">--- 1218,11 ---</span>
          return CustomElementNameValidationStatus::ContainsNoHyphen;
  
  #if ENABLE(MATHML)
      const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
  #else
<span class="line-modified">!     static NeverDestroyed&lt;const AtomString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomString::ConstructFromLiteral);</span>
  #endif
  
      if (localName == SVGNames::color_profileTag-&gt;localName()
          || localName == SVGNames::font_faceTag-&gt;localName()
          || localName == SVGNames::font_face_formatTag-&gt;localName()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1234,11 ***</span>
          return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
  
      return CustomElementNameValidationStatus::Valid;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)</span>
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedName { parseResult.releaseReturnValue() };
<span class="line-new-header">--- 1234,11 ---</span>
          return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
  
      return CustomElementNameValidationStatus::Valid;
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)</span>
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedName { parseResult.releaseReturnValue() };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1363,11 ***</span>
          setVisualUpdatesAllowed(true);
  }
  
  String Document::characterSetWithUTF8Fallback() const
  {
<span class="line-modified">!     AtomicString name = encoding();</span>
      if (!name.isNull())
          return name;
      return UTF8Encoding().domName();
  }
  
<span class="line-new-header">--- 1363,11 ---</span>
          setVisualUpdatesAllowed(true);
  }
  
  String Document::characterSetWithUTF8Fallback() const
  {
<span class="line-modified">!     AtomString name = encoding();</span>
      if (!name.isNull())
          return name;
      return UTF8Encoding().domName();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1540,64 ***</span>
      }
  
      return body();
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt; static inline String canonicalizedTitle(Document&amp; document, const String&amp; title)</span>
  {
<span class="line-modified">!     // FIXME: Compiling a separate copy of this for LChar and UChar is likely unnecessary.</span>
<span class="line-modified">!     // FIXME: Missing an optimized case for when title is fine as-is. This unnecessarily allocates</span>
<span class="line-modified">!     // and keeps around a new copy, and it&#39;s even the less optimal type of StringImpl with a separate buffer.</span>
<span class="line-removed">-     // Could probably just use StringBuilder instead.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* characters = title.characters&lt;CharacterType&gt;();</span>
<span class="line-removed">-     unsigned length = title.length();</span>
  
<span class="line-modified">!     StringBuffer&lt;CharacterType&gt; buffer { length };</span>
<span class="line-removed">-     unsigned bufferLength = 0;</span>
  
      auto* decoder = document.decoder();
      auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
  
<span class="line-removed">-     // Collapse runs of HTML spaces into single space characters.</span>
<span class="line-removed">-     // Strip leading and trailing spaces.</span>
<span class="line-removed">-     // Replace backslashes with currency symbols.</span>
      bool previousCharacterWasHTMLSpace = false;
<span class="line-modified">!     for (unsigned i = 0; i &lt; length; ++i) {</span>
<span class="line-removed">-         auto character = characters[i];</span>
          if (isHTMLSpace(character))
              previousCharacterWasHTMLSpace = true;
          else {
              if (character == &#39;\\&#39;)
                  character = backslashAsCurrencySymbol;
<span class="line-modified">!             if (previousCharacterWasHTMLSpace &amp;&amp; bufferLength)</span>
<span class="line-modified">!                 buffer[bufferLength++] = &#39; &#39;;</span>
<span class="line-modified">!             buffer[bufferLength++] = character;</span>
              previousCharacterWasHTMLSpace = false;
          }
      }
<span class="line-removed">-     if (!bufferLength)</span>
<span class="line-removed">-         return { };</span>
  
<span class="line-modified">!     buffer.shrink(bufferLength);</span>
<span class="line-removed">-     return String::adopt(WTFMove(buffer));</span>
  }
  
  void Document::updateTitle(const StringWithDirection&amp; title)
  {
      if (m_rawTitle == title)
          return;
  
      m_rawTitle = title;
<span class="line-removed">-     m_title = title;</span>
  
<span class="line-modified">!     if (!m_title.string.isEmpty()) {</span>
<span class="line-modified">!         if (m_title.string.is8Bit())</span>
<span class="line-removed">-             m_title.string = canonicalizedTitle&lt;LChar&gt;(*this, m_title.string);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             m_title.string = canonicalizedTitle&lt;UChar&gt;(*this, m_title.string);</span>
<span class="line-removed">-     }</span>
  
      if (auto* loader = this-&gt;loader())
          loader-&gt;setTitle(m_title);
  }
  
<span class="line-new-header">--- 1540,47 ---</span>
      }
  
      return body();
  }
  
<span class="line-modified">! static String canonicalizedTitle(Document&amp; document, const String&amp; title)</span>
  {
<span class="line-modified">!     // Collapse runs of HTML spaces into single space characters.</span>
<span class="line-modified">!     // Strip leading and trailing spaces.</span>
<span class="line-modified">!     // Replace backslashes with currency symbols.</span>
  
<span class="line-modified">!     StringBuilder builder;</span>
  
      auto* decoder = document.decoder();
      auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
  
      bool previousCharacterWasHTMLSpace = false;
<span class="line-modified">!     for (auto character : StringView { title }.codeUnits()) {</span>
          if (isHTMLSpace(character))
              previousCharacterWasHTMLSpace = true;
          else {
              if (character == &#39;\\&#39;)
                  character = backslashAsCurrencySymbol;
<span class="line-modified">!             if (previousCharacterWasHTMLSpace &amp;&amp; !builder.isEmpty())</span>
<span class="line-modified">!                 builder.append(&#39; &#39;);</span>
<span class="line-modified">!             builder.append(character);</span>
              previousCharacterWasHTMLSpace = false;
          }
      }
  
<span class="line-modified">!     return builder == title ? title : builder.toString();</span>
  }
  
  void Document::updateTitle(const StringWithDirection&amp; title)
  {
      if (m_rawTitle == title)
          return;
  
      m_rawTitle = title;
  
<span class="line-modified">!     m_title.string = canonicalizedTitle(*this, title.string);</span>
<span class="line-modified">!     m_title.direction = title.direction;</span>
  
      if (auto* loader = this-&gt;loader())
          loader-&gt;setTitle(m_title);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1760,11 ***</span>
  }
  
  void Document::stopAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-modified">!         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(this);</span>
  }
  
  void Document::suspendAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-new-header">--- 1743,11 ---</span>
  }
  
  void Document::stopAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-modified">!         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);</span>
  }
  
  void Document::suspendAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,10 ***</span>
<span class="line-new-header">--- 1757,22 ---</span>
  void Document::resumeAllMediaPlayback()
  {
      if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
          platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
  }
<span class="line-added">+ </span>
<span class="line-added">+ void Document::suspendAllMediaBuffering()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())</span>
<span class="line-added">+         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::resumeAllMediaBuffering()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())</span>
<span class="line-added">+         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);</span>
<span class="line-added">+ }</span>
  #endif
  
  String Document::nodeName() const
  {
      return &quot;#document&quot;_s;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1789,11 ***</span>
  }
  
  FormController&amp; Document::formController()
  {
      if (!m_formController)
<span class="line-modified">!         m_formController = std::make_unique&lt;FormController&gt;();</span>
      return *m_formController;
  }
  
  Vector&lt;String&gt; Document::formElementsState() const
  {
<span class="line-new-header">--- 1784,11 ---</span>
  }
  
  FormController&amp; Document::formController()
  {
      if (!m_formController)
<span class="line-modified">!         m_formController = makeUnique&lt;FormController&gt;();</span>
      return *m_formController;
  }
  
  Vector&lt;String&gt; Document::formElementsState() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1846,18 ***</span>
  
      if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)
          return;
  
      ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     if (WKIsObservingStyleRecalcScheduling()) {</span>
<span class="line-removed">-         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: register this style recalc schedule and observe when it fires.&quot;);</span>
<span class="line-removed">-         WKSetObservedContentChange(WKContentIndeterminateChange);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      auto shouldThrottleStyleRecalc = [&amp;] {
          if (!view() || !view()-&gt;isVisuallyNonEmpty())
              return false;
          if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
              return false;
<span class="line-new-header">--- 1841,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1918,16 ***</span>
          // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
          for (auto&amp; element : elements)
              element-&gt;updateShadowTree();
      }
  
<span class="line-modified">!     // FIXME: We should update style on our ancestor chain before proceeding (especially for seamless),</span>
<span class="line-modified">!     // however doing so currently causes several tests to crash, as Frame::setDocument calls Document::attach</span>
<span class="line-removed">-     // before setting the DOMWindow on the Frame, or the SecurityOrigin on the document. The attach, in turn</span>
<span class="line-removed">-     // resolves style (here) and then when we resolve style on the parent chain, we may end up</span>
<span class="line-removed">-     // re-attaching our containing iframe, which when asked HTMLFrameElementBase::isURLAllowed</span>
<span class="line-removed">-     // hits a null-dereference due to security code always assuming the document has a SecurityOrigin.</span>
  
      {
          ScriptDisallowedScope::InMainThread scriptDisallowedScope;
          styleScope().flushPendingUpdate();
          frameView.willRecalcStyle();
<span class="line-new-header">--- 1905,12 ---</span>
          // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
          for (auto&amp; element : elements)
              element-&gt;updateShadowTree();
      }
  
<span class="line-modified">!     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at</span>
<span class="line-modified">!     // the time this comment was originally written caused several tests to crash.</span>
  
      {
          ScriptDisallowedScope::InMainThread scriptDisallowedScope;
          styleScope().flushPendingUpdate();
          frameView.willRecalcStyle();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1990,15 ***</span>
  
          if (m_renderView-&gt;needsLayout())
              frameView.layoutContext().scheduleLayout();
  
          // Usually this is handled by post-layout.
<span class="line-modified">!         if (!frameView.needsLayout()) {</span>
              frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
<span class="line-removed">-             if (m_needsForcedIntersectionObservationUpdate)</span>
<span class="line-removed">-                 page()-&gt;scheduleForcedIntersectionObservationUpdate(*this);</span>
<span class="line-removed">-         }</span>
  
          // As a result of the style recalculation, the currently hovered element might have been
          // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
          // to check if any other elements ended up under the mouse pointer due to re-layout.
          if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
<span class="line-new-header">--- 1973,12 ---</span>
  
          if (m_renderView-&gt;needsLayout())
              frameView.layoutContext().scheduleLayout();
  
          // Usually this is handled by post-layout.
<span class="line-modified">!         if (!frameView.needsLayout())</span>
              frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
  
          // As a result of the style recalculation, the currently hovered element might have been
          // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
          // to check if any other elements ended up under the mouse pointer due to re-layout.
          if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2029,11 ***</span>
  void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
  {
      ASSERT(!m_inRenderTreeUpdate);
      SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
  
<span class="line-modified">!     auto textUpdate = std::make_unique&lt;Style::Update&gt;(*this);</span>
      textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
  
      RenderTreeUpdater renderTreeUpdater(*this);
      renderTreeUpdater.commit(WTFMove(textUpdate));
  }
<span class="line-new-header">--- 2009,11 ---</span>
  void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
  {
      ASSERT(!m_inRenderTreeUpdate);
      SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
  
<span class="line-modified">!     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);</span>
      textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
  
      RenderTreeUpdater renderTreeUpdater(*this);
      renderTreeUpdater.commit(WTFMove(textUpdate));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2062,12 ***</span>
  static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
  {
      bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
      auto* frameView = document.view();
      bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
<span class="line-modified">!     bool isAssertionDisabled = ScriptDisallowedScope::LayoutAssertionDisableScope::shouldDisable();</span>
<span class="line-removed">-     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess() || isAssertionDisabled;</span>
  }
  
  bool Document::updateStyleIfNeeded()
  {
      RefPtr&lt;FrameView&gt; frameView = view();
<span class="line-new-header">--- 2042,11 ---</span>
  static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
  {
      bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
      auto* frameView = document.view();
      bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
<span class="line-modified">!     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();</span>
  }
  
  bool Document::updateStyleIfNeeded()
  {
      RefPtr&lt;FrameView&gt; frameView = view();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2084,37 ***</span>
          if (!needsStyleRecalc())
              return false;
      }
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     auto observingContentChange = WKShouldObserveNextStyleRecalc();</span>
<span class="line-removed">-     if (observingContentChange) {</span>
<span class="line-removed">-         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: start observing content change.&quot;);</span>
<span class="line-removed">-         WKSetShouldObserveNextStyleRecalc(false);</span>
<span class="line-removed">-         WKStartObservingContentChanges();</span>
<span class="line-removed">-     }</span>
  #endif
      // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
<span class="line-removed">- </span>
      resolveStyle();
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     if (observingContentChange) {</span>
<span class="line-removed">-         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: stop observing content change.&quot;);</span>
<span class="line-removed">-         WKStopObservingContentChanges();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto inDeterminedState = WKObservedContentChange() == WKContentVisibilityChange || !WebThreadCountOfObservedDOMTimers();</span>
<span class="line-removed">-         if (inDeterminedState) {</span>
<span class="line-removed">-             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: notify the pending synthetic click handler.&quot;);</span>
<span class="line-removed">-             if (auto* page = this-&gt;page())</span>
<span class="line-removed">-                 page-&gt;chrome().client().observedContentChange(*frame());</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: can&#39;t decided it yet.&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
      return true;
  }
  
  void Document::updateLayout()
  {
<span class="line-new-header">--- 2063,15 ---</span>
          if (!needsStyleRecalc())
              return false;
      }
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     ContentChangeObserver::StyleRecalcScope observingScope(*this);</span>
  #endif
      // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
      RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
      resolveStyle();
      return true;
  }
  
  void Document::updateLayout()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2334,11 ***</span>
  }
  
  StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
  {
      if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">!         m_userAgentShadowTreeStyleResolver = std::make_unique&lt;StyleResolver&gt;(*this);</span>
      return *m_userAgentShadowTreeStyleResolver;
  }
  
  void Document::fontsNeedUpdate(FontSelector&amp;)
  {
<span class="line-new-header">--- 2291,11 ---</span>
  }
  
  StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
  {
      if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">!         m_userAgentShadowTreeStyleResolver = makeUnique&lt;StyleResolver&gt;(*this);</span>
      return *m_userAgentShadowTreeStyleResolver;
  }
  
  void Document::fontsNeedUpdate(FontSelector&amp;)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2438,11 ***</span>
  }
  
  void Document::willDetachPage()
  {
      FrameDestructionObserver::willDetachPage();
<span class="line-modified">! </span>
      if (domWindow() &amp;&amp; frame())
          InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
  }
  
  void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
<span class="line-new-header">--- 2395,13 ---</span>
  }
  
  void Document::willDetachPage()
  {
      FrameDestructionObserver::willDetachPage();
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     contentChangeObserver().willDetachPage();</span>
<span class="line-added">+ #endif</span>
      if (domWindow() &amp;&amp; frame())
          InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
  }
  
  void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2534,11 ***</span>
      clearTouchEventHandlersAndListeners();
  #endif
  
      m_undoManager-&gt;removeAllItems();
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
      if (this != &amp;topDocument()) {
          // Let the ax cache know that this subframe goes out of scope.
          if (auto* cache = existingAXObjectCache())
              cache-&gt;prepareForDocumentDestruction(*this);
      }
<span class="line-new-header">--- 2493,11 ---</span>
      clearTouchEventHandlersAndListeners();
  #endif
  
      m_undoManager-&gt;removeAllItems();
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
      if (this != &amp;topDocument()) {
          // Let the ax cache know that this subframe goes out of scope.
          if (auto* cache = existingAXObjectCache())
              cache-&gt;prepareForDocumentDestruction(*this);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2546,10 ***</span>
<span class="line-new-header">--- 2505,11 ---</span>
  
      {
          NavigationDisabler navigationDisabler(m_frame);
          disconnectDescendantFrames();
      }
<span class="line-added">+     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());</span>
  
      if (m_domWindow &amp;&amp; m_frame)
          m_domWindow-&gt;willDetachDocumentFromFrame();
  
      styleScope().clearResolver();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2573,12 ***</span>
      InspectorInstrumentation::documentDetached(*this);
  
      stopActiveDOMObjects();
      m_eventQueue.close();
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     m_fullScreenChangeEventTargetQueue.clear();</span>
<span class="line-removed">-     m_fullScreenErrorEventTargetQueue.clear();</span>
  #endif
  
      commonTeardown();
  
  #if ENABLE(TOUCH_EVENTS)
<span class="line-new-header">--- 2533,11 ---</span>
      InspectorInstrumentation::documentDetached(*this);
  
      stopActiveDOMObjects();
      m_eventQueue.close();
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     m_fullscreenManager-&gt;emptyEventQueue();</span>
  #endif
  
      commonTeardown();
  
  #if ENABLE(TOUCH_EVENTS)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2611,17 ***</span>
      if (m_timeline) {
          m_timeline-&gt;detachFromDocument();
          m_timeline = nullptr;
      }
  
<span class="line-removed">- #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">-     if (m_animationScheduler) {</span>
<span class="line-removed">-         m_animationScheduler-&gt;detachFromDocument();</span>
<span class="line-removed">-         m_animationScheduler = nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if ENABLE(CSS_PAINTING_API)
      for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
          scope-&gt;prepareForDestruction();
      m_paintWorkletGlobalScopes.clear();
  #endif
<span class="line-new-header">--- 2570,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2687,17 ***</span>
  }
  
  void Document::platformSuspendOrStopActiveDOMObjects()
  {
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     if (WebThreadCountOfObservedDOMTimers() &gt; 0) {</span>
<span class="line-removed">-         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document::platformSuspendOrStopActiveDOMObjects: remove registered timers.&quot;);</span>
<span class="line-removed">-         if (auto* frame = this-&gt;frame()) {</span>
<span class="line-removed">-             if (auto* page = frame-&gt;page())</span>
<span class="line-removed">-                 page-&gt;chrome().client().clearContentChangeObservers(*frame);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  #endif
  }
  
  void Document::suspendActiveDOMObjects(ReasonForSuspension why)
  {
<span class="line-new-header">--- 2639,11 ---</span>
  }
  
  void Document::platformSuspendOrStopActiveDOMObjects()
  {
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     contentChangeObserver().didSuspendActiveDOMObjects();</span>
  #endif
  }
  
  void Document::suspendActiveDOMObjects(ReasonForSuspension why)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2748,11 ***</span>
      if (!topDocument.hasLivingRenderTree())
          return nullptr;
  
      ASSERT(&amp;topDocument == this || !m_axObjectCache);
      if (!topDocument.m_axObjectCache) {
<span class="line-modified">!         topDocument.m_axObjectCache = std::make_unique&lt;AXObjectCache&gt;(topDocument);</span>
          hasEverCreatedAnAXObjectCache = true;
      }
      return topDocument.m_axObjectCache.get();
  }
  
<span class="line-new-header">--- 2694,11 ---</span>
      if (!topDocument.hasLivingRenderTree())
          return nullptr;
  
      ASSERT(&amp;topDocument == this || !m_axObjectCache);
      if (!topDocument.m_axObjectCache) {
<span class="line-modified">!         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);</span>
          hasEverCreatedAnAXObjectCache = true;
      }
      return topDocument.m_axObjectCache.get();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2772,11 ***</span>
  ScriptableDocumentParser* Document::scriptableDocumentParser() const
  {
      return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
  }
  
<span class="line-modified">! ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomicString&amp; name, const String&amp; features)</span>
  {
      if (!m_domWindow)
          return Exception { InvalidAccessError };
  
      return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
<span class="line-new-header">--- 2718,11 ---</span>
  ScriptableDocumentParser* Document::scriptableDocumentParser() const
  {
      return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
  }
  
<span class="line-modified">! ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)</span>
  {
      if (!m_domWindow)
          return Exception { InvalidAccessError };
  
      return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2814,11 ***</span>
              }
          }
  
          if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
              m_frame-&gt;loader().policyChecker().stopCheck();
<span class="line-modified">!         if (m_frame-&gt;loader().state() == FrameStateProvisional)</span>
              m_frame-&gt;loader().stopAllLoaders();
      }
  
      removeAllEventListeners();
  
<span class="line-new-header">--- 2760,11 ---</span>
              }
          }
  
          if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
              m_frame-&gt;loader().policyChecker().stopCheck();
<span class="line-modified">!         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)</span>
              m_frame-&gt;loader().stopAllLoaders();
      }
  
      removeAllEventListeners();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3082,10 ***</span>
<span class="line-new-header">--- 3028,13 ---</span>
              view()-&gt;layoutContext().layout();
      }
  
      m_processingLoadEvent = false;
  
<span class="line-added">+     if (auto* fontFaceSet = fontSelector().optionalFontFaceSet())</span>
<span class="line-added">+         fontFaceSet-&gt;didFirstLayout();</span>
<span class="line-added">+ </span>
  #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
      if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
          // The AX cache may have been cleared at this point, but we need to make sure it contains an
          // AX object to send the notification to. getOrCreate will make sure that an valid AX object
          // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3112,11 ***</span>
  void Document::setParsing(bool b)
  {
      m_bParsing = b;
  
      if (m_bParsing &amp;&amp; !m_sharedObjectPool)
<span class="line-modified">!         m_sharedObjectPool = std::make_unique&lt;DocumentSharedObjectPool&gt;();</span>
  
      if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
          view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
  }
  
<span class="line-new-header">--- 3061,11 ---</span>
  void Document::setParsing(bool b)
  {
      m_bParsing = b;
  
      if (m_bParsing &amp;&amp; !m_sharedObjectPool)
<span class="line-modified">!         m_sharedObjectPool = makeUnique&lt;DocumentSharedObjectPool&gt;();</span>
  
      if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
          view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3284,17 ***</span>
  
      clearSelectorQueryCache();
  
      if (!m_baseURL.isValid())
          m_baseURL = URL();
<span class="line-removed">- </span>
<span class="line-removed">-     if (!equalIgnoringFragmentIdentifier(oldBaseURL, m_baseURL)) {</span>
<span class="line-removed">-         // Base URL change changes any relative visited links.</span>
<span class="line-removed">-         // FIXME: There are other URLs in the tree that would need to be re-evaluated on dynamic base URL change. Style should be invalidated too.</span>
<span class="line-removed">-         for (auto&amp; anchor : descendantsOfType&lt;HTMLAnchorElement&gt;(*this))</span>
<span class="line-removed">-             anchor.invalidateCachedVisitedLinkHash();</span>
<span class="line-removed">-     }</span>
  }
  
  void Document::setBaseURLOverride(const URL&amp; url)
  {
      m_baseURLOverride = url;
<span class="line-new-header">--- 3233,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3302,24 ***</span>
  }
  
  void Document::processBaseElement()
  {
      // Find the first href attribute in a base element and the first target attribute in a base element.
<span class="line-modified">!     const AtomicString* href = nullptr;</span>
<span class="line-modified">!     const AtomicString* target = nullptr;</span>
      auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
      for (auto&amp; base : baseDescendants) {
          if (!href) {
<span class="line-modified">!             const AtomicString&amp; value = base.attributeWithoutSynchronization(hrefAttr);</span>
              if (!value.isNull()) {
                  href = &amp;value;
                  if (target)
                      break;
              }
          }
          if (!target) {
<span class="line-modified">!             const AtomicString&amp; value = base.attributeWithoutSynchronization(targetAttr);</span>
              if (!value.isNull()) {
                  target = &amp;value;
                  if (href)
                      break;
              }
<span class="line-new-header">--- 3244,24 ---</span>
  }
  
  void Document::processBaseElement()
  {
      // Find the first href attribute in a base element and the first target attribute in a base element.
<span class="line-modified">!     const AtomString* href = nullptr;</span>
<span class="line-modified">!     const AtomString* target = nullptr;</span>
      auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
      for (auto&amp; base : baseDescendants) {
          if (!href) {
<span class="line-modified">!             const AtomString&amp; value = base.attributeWithoutSynchronization(hrefAttr);</span>
              if (!value.isNull()) {
                  href = &amp;value;
                  if (target)
                      break;
              }
          }
          if (!target) {
<span class="line-modified">!             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);</span>
              if (!value.isNull()) {
                  target = &amp;value;
                  if (href)
                      break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3508,11 ***</span>
      if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
          return false;
  
      // Only prevent cross-site navigations.
      auto* targetDocument = targetFrame.document();
<span class="line-modified">!     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || registrableDomainsAreEqual(targetDocument-&gt;url(), destinationURL)))</span>
          return false;
  
      return true;
  }
  
<span class="line-new-header">--- 3450,11 ---</span>
      if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
          return false;
  
      // Only prevent cross-site navigations.
      auto* targetDocument = targetFrame.document();
<span class="line-modified">!     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))</span>
          return false;
  
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3662,19 ***</span>
          return;
  
      page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
  }
  
<span class="line-removed">- void Document::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (viewportArguments == m_overrideViewportArguments)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_overrideViewportArguments = viewportArguments;</span>
<span class="line-removed">-     updateViewportArguments();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
  {
      ASSERT(!features.isNull());
  
      LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
<span class="line-new-header">--- 3604,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3691,78 ***</span>
      });
  
      updateViewportArguments();
  }
  
  void Document::updateViewportArguments()
  {
      if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
  #ifndef NDEBUG
          m_didDispatchViewportPropertiesChanged = true;
  #endif
<span class="line-modified">!         page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_overrideViewportArguments ? m_overrideViewportArguments.value() : m_viewportArguments);</span>
          page()-&gt;chrome().didReceiveDocType(*frame());
      }
  }
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">! static bool isColorSchemeSeparator(UChar character)</span>
  {
<span class="line-modified">!     return isASCIISpace(character) || character == &#39;,&#39;;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void processColorSchemes(StringView colorSchemes, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     unsigned length = colorSchemes.length();</span>
      for (unsigned i = 0; i &lt; length; ) {
          // Skip to first non-separator.
<span class="line-modified">!         while (i &lt; length &amp;&amp; isColorSchemeSeparator(colorSchemes[i]))</span>
              ++i;
          unsigned keyBegin = i;
  
          // Skip to first separator.
<span class="line-modified">!         while (i &lt; length &amp;&amp; !isColorSchemeSeparator(colorSchemes[i]))</span>
              ++i;
          unsigned keyEnd = i;
  
          if (keyBegin == keyEnd)
              continue;
  
<span class="line-modified">!         callback(colorSchemes.substring(keyBegin, keyEnd - keyBegin));</span>
      }
  }
  
<span class="line-modified">! void Document::processSupportedColorSchemes(const String&amp; colorSchemes)</span>
  {
<span class="line-modified">!     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;</span>
      bool allowsTransformations = true;
      bool autoEncountered = false;
  
<span class="line-modified">!     processColorSchemes(colorSchemes, [&amp;](StringView key) {</span>
          if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
<span class="line-modified">!             supportedColorSchemes = { };</span>
              allowsTransformations = true;
              autoEncountered = true;
              return;
          }
  
          if (autoEncountered)
              return;
  
          if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
<span class="line-modified">!             supportedColorSchemes.add(ColorSchemes::Light);</span>
          else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
<span class="line-modified">!             supportedColorSchemes.add(ColorSchemes::Dark);</span>
          else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
              allowsTransformations = false;
      });
  
      // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified">!     if (supportedColorSchemes.isEmpty() &amp;&amp; !allowsTransformations)</span>
<span class="line-modified">!         supportedColorSchemes.add(ColorSchemes::Light);</span>
  
<span class="line-modified">!     m_supportedColorSchemes = supportedColorSchemes;</span>
      m_allowsColorSchemeTransformations = allowsTransformations;
  
      if (auto* frameView = view())
          frameView-&gt;recalculateBaseBackgroundColor();
  
<span class="line-new-header">--- 3624,81 ---</span>
      });
  
      updateViewportArguments();
  }
  
<span class="line-added">+ ViewportArguments Document::viewportArguments() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* page = this-&gt;page();</span>
<span class="line-added">+     if (!page)</span>
<span class="line-added">+         return m_viewportArguments;</span>
<span class="line-added">+     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::updateViewportArguments()
  {
      if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
  #ifndef NDEBUG
          m_didDispatchViewportPropertiesChanged = true;
  #endif
<span class="line-modified">!         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());</span>
          page()-&gt;chrome().didReceiveDocType(*frame());
      }
  }
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">! static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)</span>
  {
<span class="line-modified">!     unsigned length = colorScheme.length();</span>
      for (unsigned i = 0; i &lt; length; ) {
          // Skip to first non-separator.
<span class="line-modified">!         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))</span>
              ++i;
          unsigned keyBegin = i;
  
          // Skip to first separator.
<span class="line-modified">!         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))</span>
              ++i;
          unsigned keyEnd = i;
  
          if (keyBegin == keyEnd)
              continue;
  
<span class="line-modified">!         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));</span>
      }
  }
  
<span class="line-modified">! void Document::processColorScheme(const String&amp; colorSchemeString)</span>
  {
<span class="line-modified">!     OptionSet&lt;ColorScheme&gt; colorScheme;</span>
      bool allowsTransformations = true;
      bool autoEncountered = false;
  
<span class="line-modified">!     processColorSchemeString(colorSchemeString, [&amp;](StringView key) {</span>
          if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
<span class="line-modified">!             colorScheme = { };</span>
              allowsTransformations = true;
              autoEncountered = true;
              return;
          }
  
          if (autoEncountered)
              return;
  
          if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
<span class="line-modified">!             colorScheme.add(ColorScheme::Light);</span>
          else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
<span class="line-modified">!             colorScheme.add(ColorScheme::Dark);</span>
          else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
              allowsTransformations = false;
      });
  
      // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified">!     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)</span>
<span class="line-modified">!         colorScheme.add(ColorScheme::Light);</span>
  
<span class="line-modified">!     m_colorScheme = colorScheme;</span>
      m_allowsColorSchemeTransformations = allowsTransformations;
  
      if (auto* frameView = view())
          frameView-&gt;recalculateBaseBackgroundColor();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3819,12 ***</span>
          return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
  
      HitTestResult result(documentPoint);
      hitTest(request, result);
  
<span class="line-modified">!     if (!request.readOnly())</span>
<span class="line-modified">!         updateHoverActiveState(request, result.targetElement());</span>
  
      return MouseEventWithHitTestResults(event, result);
  }
  
  // DOM Section 1.1.1
<span class="line-new-header">--- 3755,33 ---</span>
          return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
  
      HitTestResult result(documentPoint);
      hitTest(request, result);
  
<span class="line-modified">!     auto captureElementChanged = CaptureChange::No;</span>
<span class="line-modified">!     if (!request.readOnly()) {</span>
<span class="line-added">+         auto targetElement = makeRefPtr(result.targetElement());</span>
<span class="line-added">+ #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">+         if (auto* page = this-&gt;page()) {</span>
<span class="line-added">+             // Before we dispatch a new mouse event, we must run the Process Pending Capture Element steps as defined</span>
<span class="line-added">+             // in https://w3c.github.io/pointerevents/#process-pending-pointer-capture.</span>
<span class="line-added">+             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();</span>
<span class="line-added">+             auto* previousCaptureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());</span>
<span class="line-added">+             pointerCaptureController.processPendingPointerCapture(event.pointerId());</span>
<span class="line-added">+             auto* captureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());</span>
<span class="line-added">+             // If the capture element has changed while running the Process Pending Capture Element steps then</span>
<span class="line-added">+             // we need to indicate that when calling updateHoverActiveState to be sure that the :active and :hover</span>
<span class="line-added">+             // element chains are updated.</span>
<span class="line-added">+             if (previousCaptureElement != captureElement)</span>
<span class="line-added">+                 captureElementChanged = CaptureChange::Yes;</span>
<span class="line-added">+             // If we have a capture element, we must target it instead of what would normally hit-test for this event.</span>
<span class="line-added">+             if (captureElement)</span>
<span class="line-added">+                 targetElement = captureElement;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         updateHoverActiveState(request, targetElement.get(), captureElementChanged);</span>
<span class="line-added">+     }</span>
  
      return MouseEventWithHitTestResults(event, result);
  }
  
  // DOM Section 1.1.1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3930,21 ***</span>
          break;
      case CloningOperation::Everything:
          cloneChildNodes(clone);
          break;
      }
<span class="line-modified">!     return WTFMove(clone);</span>
  }
  
  Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
  {
      if (isXMLDocument()) {
          if (isXHTMLDocument())
<span class="line-modified">!             return XMLDocument::createXHTML(nullptr, url());</span>
<span class="line-modified">!         return XMLDocument::create(nullptr, url());</span>
      }
<span class="line-modified">!     return create(url());</span>
  }
  
  void Document::cloneDataFromDocument(const Document&amp; other)
  {
      ASSERT(m_url == other.url());
<span class="line-new-header">--- 3887,21 ---</span>
          break;
      case CloningOperation::Everything:
          cloneChildNodes(clone);
          break;
      }
<span class="line-modified">!     return clone;</span>
  }
  
  Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
  {
      if (isXMLDocument()) {
          if (isXHTMLDocument())
<span class="line-modified">!             return XMLDocument::createXHTML(sessionID(), nullptr, url());</span>
<span class="line-modified">!         return XMLDocument::create(sessionID(), nullptr, url());</span>
      }
<span class="line-modified">!     return create(sessionID(), url());</span>
  }
  
  void Document::cloneDataFromDocument(const Document&amp; other)
  {
      ASSERT(m_url == other.url());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4014,17 ***</span>
      }
  }
  
  void Document::addAudioProducer(MediaProducer&amp; audioProducer)
  {
<span class="line-modified">!     m_audioProducers.add(&amp;audioProducer);</span>
      updateIsPlayingMedia();
  }
  
  void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
  {
<span class="line-modified">!     m_audioProducers.remove(&amp;audioProducer);</span>
      updateIsPlayingMedia();
  }
  
  void Document::noteUserInteractionWithMediaElement()
  {
<span class="line-new-header">--- 3971,18 ---</span>
      }
  }
  
  void Document::addAudioProducer(MediaProducer&amp; audioProducer)
  {
<span class="line-modified">!     m_audioProducers.add(audioProducer);</span>
      updateIsPlayingMedia();
  }
  
  void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
  {
<span class="line-modified">!     RELEASE_ASSERT(isMainThread());</span>
<span class="line-added">+     m_audioProducers.remove(audioProducer);</span>
      updateIsPlayingMedia();
  }
  
  void Document::noteUserInteractionWithMediaElement()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4038,13 ***</span>
      updateIsPlayingMedia();
  }
  
  void Document::updateIsPlayingMedia(uint64_t sourceElementID)
  {
      MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">!     for (auto* audioProducer : m_audioProducers)</span>
<span class="line-modified">!         state |= audioProducer-&gt;mediaState();</span>
  
  #if ENABLE(MEDIA_SESSION)
      if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
          if (sourceElement-&gt;isPlaying())
              state |= MediaProducer::IsSourceElementPlaying;
<span class="line-new-header">--- 3996,18 ---</span>
      updateIsPlayingMedia();
  }
  
  void Document::updateIsPlayingMedia(uint64_t sourceElementID)
  {
<span class="line-added">+     ASSERT(!m_audioProducers.hasNullReferences());</span>
      MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">!     for (auto&amp; audioProducer : m_audioProducers)</span>
<span class="line-modified">!         state |= audioProducer.mediaState();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     state |= MediaStreamTrack::captureState();</span>
<span class="line-added">+ #endif</span>
  
  #if ENABLE(MEDIA_SESSION)
      if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
          if (sourceElement-&gt;isPlaying())
              state |= MediaProducer::IsSourceElementPlaying;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4081,12 ***</span>
  #endif
  }
  
  void Document::pageMutedStateDidChange()
  {
<span class="line-modified">!     for (auto* audioProducer : m_audioProducers)</span>
<span class="line-modified">!         audioProducer-&gt;pageMutedStateDidChange();</span>
  }
  
  static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
  {
      if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
<span class="line-new-header">--- 4044,16 ---</span>
  #endif
  }
  
  void Document::pageMutedStateDidChange()
  {
<span class="line-modified">!     for (auto&amp; audioProducer : m_audioProducers)</span>
<span class="line-modified">!         audioProducer.pageMutedStateDidChange();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">+     MediaStreamTrack::muteCapture();</span>
<span class="line-added">+ #endif</span>
  }
  
  static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
  {
      if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4137,82 ***</span>
      m_activeElement = element.parentElement();
      while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
          m_activeElement = m_activeElement-&gt;parentElement();
  }
  
<span class="line-modified">! #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">- const Vector&lt;AnnotatedRegionValue&gt;&amp; Document::annotatedRegions() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_annotatedRegions;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::setAnnotatedRegions(const Vector&lt;AnnotatedRegionValue&gt;&amp; regions)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_annotatedRegions = regions;</span>
<span class="line-removed">-     setAnnotatedRegionsDirty(false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::updateAnnotatedRegions()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!hasAnnotatedRegions())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Vector&lt;AnnotatedRegionValue&gt; newRegions;</span>
<span class="line-removed">-     renderBox()-&gt;collectAnnotatedRegions(newRegions); // FIXME.</span>
<span class="line-removed">-     if (newRegions == annotatedRegions())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     setAnnotatedRegions(newRegions);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (Page* page = this-&gt;page())</span>
<span class="line-removed">-         page-&gt;chrome().client().annotatedRegionsChanged();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::invalidateRenderingDependentRegions(AnnotationsAction annotationsAction)</span>
  {
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     // FIXME: we don&#39;t have a good invalidation/update policy for Dashboard regions. They get eagerly updated</span>
<span class="line-removed">-     // on forced layouts, and don&#39;t need to be.</span>
<span class="line-removed">-     if (annotationsAction == AnnotationsAction::Update)</span>
<span class="line-removed">-         updateAnnotatedRegions();</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         setAnnotatedRegionsDirty();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(annotationsAction);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
      setTouchEventRegionsNeedUpdate();
  #endif
  
<span class="line-modified">! #if ENABLE(POINTER_EVENTS)</span>
      if (auto* page = this-&gt;page()) {
          if (auto* frameView = view()) {
              if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
                  scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
          }
      }
  #endif
  }
  
<span class="line-removed">- void Document::invalidateScrollbarDependentRegions()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     if (hasAnnotatedRegions())</span>
<span class="line-removed">-         setAnnotatedRegionsDirty();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::updateZOrderDependentRegions()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">-     if (annotatedRegionsDirty())</span>
<span class="line-removed">-         updateAnnotatedRegions();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
  {
      RefPtr&lt;Element&gt; newFocusedElement = element;
      // Make sure newFocusedElement is actually in this document
      if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
<span class="line-new-header">--- 4104,26 ---</span>
      m_activeElement = element.parentElement();
      while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
          m_activeElement = m_activeElement-&gt;parentElement();
  }
  
<span class="line-modified">! void Document::invalidateRenderingDependentRegions()</span>
  {
  #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
      setTouchEventRegionsNeedUpdate();
  #endif
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
      if (auto* page = this-&gt;page()) {
          if (auto* frameView = view()) {
              if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
                  scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
          }
      }
  #endif
  }
  
  bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
  {
      RefPtr&lt;Element&gt; newFocusedElement = element;
      // Make sure newFocusedElement is actually in this document
      if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4524,11 ***</span>
  
      adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
      adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     adjustFullScreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);</span>
  #endif
  
      for (auto* range : m_ranges)
          range-&gt;nodeChildrenWillBeRemoved(container);
  
<span class="line-new-header">--- 4435,11 ---</span>
  
      adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
      adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);</span>
  #endif
  
      for (auto* range : m_ranges)
          range-&gt;nodeChildrenWillBeRemoved(container);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4557,11 ***</span>
  
      adjustFocusedNodeOnNodeRemoval(node);
      adjustFocusNavigationNodeOnNodeRemoval(node);
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     adjustFullScreenElementOnNodeRemoval(node);</span>
  #endif
  
      for (auto* it : m_nodeIterators)
          it-&gt;nodeWillBeRemoved(node);
  
<span class="line-new-header">--- 4468,11 ---</span>
  
      adjustFocusedNodeOnNodeRemoval(node);
      adjustFocusNavigationNodeOnNodeRemoval(node);
  
  #if ENABLE(FULLSCREEN_API)
<span class="line-modified">!     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(node, NodeRemoval::Node);</span>
  #endif
  
      for (auto* it : m_nodeIterators)
          it-&gt;nodeWillBeRemoved(node);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4574,15 ***</span>
          frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
      }
  
      if (is&lt;Text&gt;(node))
          m_markers-&gt;removeMarkers(node);
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">-     if (m_touchActionElements &amp;&amp; is&lt;Element&gt;(node))</span>
<span class="line-removed">-         m_touchActionElements-&gt;remove(&amp;downcast&lt;Element&gt;(node));</span>
<span class="line-removed">- #endif</span>
  }
  
  static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
  {
      return node.previousSibling() ? node.previousSibling() : node.parentNode();
<span class="line-new-header">--- 4485,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4607,10 ***</span>
<span class="line-new-header">--- 4513,15 ---</span>
              range-&gt;textInserted(text, offset, length);
      }
  
      // Update the markers for spelling and grammar checking.
      m_markers-&gt;shiftMarkers(text, offset, length);
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)</span>
<span class="line-added">+     // Freshly inserted text is expected to not inherit PlatformTextChecking markers.</span>
<span class="line-added">+     m_markers-&gt;removeMarkers(text, offset, length, DocumentMarker::PlatformTextChecking);</span>
<span class="line-added">+ #endif</span>
  }
  
  void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
  {
      if (!m_ranges.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4682,30 ***</span>
      if (m_contextDocument)
          return *m_contextDocument.get();
      return const_cast&lt;Document&amp;&gt;(*this);
  }
  
<span class="line-modified">! void Document::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
  }
  
<span class="line-modified">! void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return;
      m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
  }
  
<span class="line-modified">! void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return;
      setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
  }
  
<span class="line-modified">! EventListener* Document::getWindowAttributeEventListener(const AtomicString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return nullptr;
      return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
  }
<span class="line-new-header">--- 4593,30 ---</span>
      if (m_contextDocument)
          return *m_contextDocument.get();
      return const_cast&lt;Document&amp;&gt;(*this);
  }
  
<span class="line-modified">! void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
  }
  
<span class="line-modified">! void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return;
      m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
  }
  
<span class="line-modified">! void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return;
      setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
  }
  
<span class="line-modified">! EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)</span>
  {
      if (!m_domWindow)
          return nullptr;
      return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4840,11 ***</span>
      default:
          return false;
      }
  }
  
<span class="line-modified">! void Document::addListenerTypeIfNeeded(const AtomicString&amp; eventType)</span>
  {
      if (eventType == eventNames().DOMSubtreeModifiedEvent)
          addListenerType(DOMSUBTREEMODIFIED_LISTENER);
      else if (eventType == eventNames().DOMNodeInsertedEvent)
          addListenerType(DOMNODEINSERTED_LISTENER);
<span class="line-new-header">--- 4751,11 ---</span>
      default:
          return false;
      }
  }
  
<span class="line-modified">! void Document::addListenerTypeIfNeeded(const AtomString&amp; eventType)</span>
  {
      if (eventType == eventNames().DOMSubtreeModifiedEvent)
          addListenerType(DOMSUBTREEMODIFIED_LISTENER);
      else if (eventType == eventNames().DOMNodeInsertedEvent)
          addListenerType(DOMNODEINSERTED_LISTENER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4949,10 ***</span>
<span class="line-new-header">--- 4860,14 ---</span>
      return { };
  }
  
  String Document::referrer() const
  {
<span class="line-added">+ #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-added">+     if (!m_referrerOverride.isEmpty())</span>
<span class="line-added">+         return m_referrerOverride;</span>
<span class="line-added">+ #endif</span>
      if (frame())
          return frame()-&gt;loader().referrer();
      return String();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4964,53 ***</span>
  String Document::domain() const
  {
      return securityOrigin().domain();
  }
  
<span class="line-removed">- bool Document::domainIsRegisterable(const String&amp; newDomain) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (newDomain.isEmpty())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const String&amp; effectiveDomain = domain();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If the new domain is the same as the old domain, return true so that</span>
<span class="line-removed">-     // we still call securityOrigin().setDomainForDOM. This will change the</span>
<span class="line-removed">-     // security check behavior. For example, if a page loaded on port 8000</span>
<span class="line-removed">-     // assigns its current domain using document.domain, the page will</span>
<span class="line-removed">-     // allow other pages loaded on different ports in the same domain that</span>
<span class="line-removed">-     // have also assigned to access this page.</span>
<span class="line-removed">-     if (equalIgnoringASCIICase(effectiveDomain, newDomain))</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // e.g. newDomain = webkit.org (10) and domain() = www.webkit.org (14)</span>
<span class="line-removed">-     unsigned oldLength = effectiveDomain.length();</span>
<span class="line-removed">-     unsigned newLength = newDomain.length();</span>
<span class="line-removed">-     if (newLength &gt;= oldLength)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto ipAddressSetting = settings().treatIPAddressAsDomain() ? OriginAccessEntry::TreatIPAddressAsDomain : OriginAccessEntry::TreatIPAddressAsIPAddress;</span>
<span class="line-removed">-     OriginAccessEntry accessEntry { securityOrigin().protocol(), newDomain, OriginAccessEntry::AllowSubdomains, ipAddressSetting };</span>
<span class="line-removed">-     if (!accessEntry.matchesOrigin(securityOrigin()))</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (effectiveDomain[oldLength - newLength - 1] != &#39;.&#39;)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     if (StringView { effectiveDomain }.substring(oldLength - newLength) != newDomain)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto potentialPublicSuffix = newDomain;</span>
<span class="line-removed">-     if (potentialPublicSuffix.startsWith(&#39;.&#39;))</span>
<span class="line-removed">-         potentialPublicSuffix.remove(0, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
<span class="line-removed">-     return !isPublicSuffix(potentialPublicSuffix);</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
  {
      if (!frame())
          return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
  
<span class="line-new-header">--- 4879,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5024,11 ***</span>
  
      const String&amp; effectiveDomain = domain();
      if (effectiveDomain.isEmpty())
          return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
  
<span class="line-modified">!     if (!domainIsRegisterable(newDomain))</span>
          return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
  
      securityOrigin().setDomainFromDOM(newDomain);
      return { };
  }
<span class="line-new-header">--- 4896,11 ---</span>
  
      const String&amp; effectiveDomain = domain();
      if (effectiveDomain.isEmpty())
          return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
  
<span class="line-modified">!     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))</span>
          return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
  
      securityOrigin().setDomainFromDOM(newDomain);
      return { };
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5086,16 ***</span>
  static bool isValidNameNonASCII(const UChar* characters, unsigned length)
  {
      unsigned i = 0;
  
      UChar32 c;
<span class="line-modified">!     U16_NEXT(characters, i, length, c)</span>
      if (!isValidNameStart(c))
          return false;
  
      while (i &lt; length) {
<span class="line-modified">!         U16_NEXT(characters, i, length, c)</span>
          if (!isValidNamePart(c))
              return false;
      }
  
      return true;
<span class="line-new-header">--- 4958,16 ---</span>
  static bool isValidNameNonASCII(const UChar* characters, unsigned length)
  {
      unsigned i = 0;
  
      UChar32 c;
<span class="line-modified">!     U16_NEXT(characters, i, length, c);</span>
      if (!isValidNameStart(c))
          return false;
  
      while (i &lt; length) {
<span class="line-modified">!         U16_NEXT(characters, i, length, c);</span>
          if (!isValidNamePart(c))
              return false;
      }
  
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5138,11 ***</span>
          return true;
  
      return isValidNameNonASCII(characters, length);
  }
  
<span class="line-modified">! ExceptionOr&lt;std::pair&lt;AtomicString, AtomicString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)</span>
  {
      unsigned length = qualifiedName.length();
  
      if (!length)
          return Exception { InvalidCharacterError };
<span class="line-new-header">--- 5010,11 ---</span>
          return true;
  
      return isValidNameNonASCII(characters, length);
  }
  
<span class="line-modified">! ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)</span>
  {
      unsigned length = qualifiedName.length();
  
      if (!length)
          return Exception { InvalidCharacterError };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5151,11 ***</span>
      bool sawColon = false;
      unsigned colonPosition = 0;
  
      for (unsigned i = 0; i &lt; length; ) {
          UChar32 c;
<span class="line-modified">!         U16_NEXT(qualifiedName, i, length, c)</span>
          if (c == &#39;:&#39;) {
              if (sawColon)
                  return Exception { InvalidCharacterError };
              nameStart = true;
              sawColon = true;
<span class="line-new-header">--- 5023,11 ---</span>
      bool sawColon = false;
      unsigned colonPosition = 0;
  
      for (unsigned i = 0; i &lt; length; ) {
          UChar32 c;
<span class="line-modified">!         U16_NEXT(qualifiedName, i, length, c);</span>
          if (c == &#39;:&#39;) {
              if (sawColon)
                  return Exception { InvalidCharacterError };
              nameStart = true;
              sawColon = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5169,19 ***</span>
                  return Exception { InvalidCharacterError };
          }
      }
  
      if (!sawColon)
<span class="line-modified">!         return std::pair&lt;AtomicString, AtomicString&gt; { { }, { qualifiedName } };</span>
  
      if (!colonPosition || length - colonPosition &lt;= 1)
          return Exception { InvalidCharacterError };
  
<span class="line-modified">!     return std::pair&lt;AtomicString, AtomicString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomicString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomicString() };</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)</span>
  {
      auto parseResult = parseQualifiedName(qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      auto parsedPieces = parseResult.releaseReturnValue();
<span class="line-new-header">--- 5041,19 ---</span>
                  return Exception { InvalidCharacterError };
          }
      }
  
      if (!sawColon)
<span class="line-modified">!         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };</span>
  
      if (!colonPosition || length - colonPosition &lt;= 1)
          return Exception { InvalidCharacterError };
  
<span class="line-modified">!     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)</span>
  {
      auto parseResult = parseQualifiedName(qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      auto parsedPieces = parseResult.releaseReturnValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5211,16 ***</span>
      return completeURL(url, m_baseURL);
  }
  
  PAL::SessionID Document::sessionID() const
  {
<span class="line-removed">-     if (m_sessionID.isValid())</span>
<span class="line-removed">-         return m_sessionID;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto* page = this-&gt;page())</span>
<span class="line-removed">-         m_sessionID = page-&gt;sessionID();</span>
<span class="line-removed">- </span>
      return m_sessionID;
  }
  
  void Document::setPageCacheState(PageCacheState state)
  {
<span class="line-new-header">--- 5083,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5415,23 ***</span>
  void Document::storageBlockingStateDidChange()
  {
      securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
  }
  
<span class="line-modified">! void Document::privateBrowsingStateDidChange()</span>
  {
<span class="line-modified">!     m_sessionID = SessionID::emptySessionID();</span>
      if (m_logger)
<span class="line-modified">!         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());</span>
  
      for (auto* element : m_privateBrowsingStateChangedElements)
<span class="line-modified">!         element-&gt;privateBrowsingStateDidChange();</span>
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     ASSERT(sessionID().isValid());</span>
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection &amp;&amp; sessionID().isValid())</span>
<span class="line-removed">-         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID()));</span>
  #endif
  }
  
  void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
  {
<span class="line-new-header">--- 5281,22 ---</span>
  void Document::storageBlockingStateDidChange()
  {
      securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
  }
  
<span class="line-modified">! void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)</span>
  {
<span class="line-modified">!     m_sessionID = sessionID;</span>
      if (m_logger)
<span class="line-modified">!         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());</span>
  
      for (auto* element : m_privateBrowsingStateChangedElements)
<span class="line-modified">!         element-&gt;privateBrowsingStateDidChange(sessionID);</span>
  
  #if ENABLE(SERVICE_WORKER)
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection)</span>
<span class="line-modified">!         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID));</span>
  #endif
  }
  
  void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5514,16 ***</span>
  
  // Support for Javascript execCommand, and related methods
  
  static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
  {
<span class="line-modified">!     RefPtr&lt;Frame&gt; frame = document-&gt;frame();</span>
<span class="line-removed">-     if (!frame || frame-&gt;document() != document)</span>
<span class="line-removed">-         return Editor::Command();</span>
  
      document-&gt;updateStyleIfNeeded();
  
      return frame-&gt;editor().command(commandName,
          userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
  }
  
  bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
<span class="line-new-header">--- 5379,19 ---</span>
  
  // Support for Javascript execCommand, and related methods
  
  static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
  {
<span class="line-modified">!     auto protectedDocument = makeRef(*document);</span>
  
      document-&gt;updateStyleIfNeeded();
  
<span class="line-added">+     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!frame || frame-&gt;document() != document)</span>
<span class="line-added">+         return Editor::Command();</span>
<span class="line-added">+ </span>
      return frame-&gt;editor().command(commandName,
          userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
  }
  
  bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5697,11 ***</span>
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
  {
      return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)</span>
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedName { parseResult.releaseReturnValue() };
<span class="line-new-header">--- 5565,11 ---</span>
  ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
  {
      return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)</span>
  {
      auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
      if (parseResult.hasException())
          return parseResult.releaseException();
      QualifiedName parsedName { parseResult.releaseReturnValue() };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5716,11 ***</span>
  }
  
  SVGDocumentExtensions&amp; Document::accessSVGExtensions()
  {
      if (!m_svgExtensions)
<span class="line-modified">!         m_svgExtensions = std::make_unique&lt;SVGDocumentExtensions&gt;(*this);</span>
      return *m_svgExtensions;
  }
  
  void Document::addSVGUseElement(SVGUseElement&amp; element)
  {
<span class="line-new-header">--- 5584,11 ---</span>
  }
  
  SVGDocumentExtensions&amp; Document::accessSVGExtensions()
  {
      if (!m_svgExtensions)
<span class="line-modified">!         m_svgExtensions = makeUnique&lt;SVGDocumentExtensions&gt;(*this);</span>
      return *m_svgExtensions;
  }
  
  void Document::addSVGUseElement(SVGUseElement&amp; element)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5789,21 ***</span>
  Ref&lt;HTMLCollection&gt; Document::all()
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomicString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomicString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomicString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
  }
  
  void Document::finishedParsing()
<span class="line-new-header">--- 5657,21 ---</span>
  Ref&lt;HTMLCollection&gt; Document::all()
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
  }
  
<span class="line-modified">! Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)</span>
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
  }
  
  void Document::finishedParsing()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5817,12 ***</span>
      scriptRunner().documentFinishedParsing();
  
      if (!m_documentTiming.domContentLoadedEventStart)
          m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
  
<span class="line-modified">!     // FIXME: Schdule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-modified">!     MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
  
      dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
  
      if (!m_documentTiming.domContentLoadedEventEnd)
          m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
<span class="line-new-header">--- 5685,14 ---</span>
      scriptRunner().documentFinishedParsing();
  
      if (!m_documentTiming.domContentLoadedEventStart)
          m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
  
<span class="line-modified">!     if (!page() || !page()-&gt;isForSanitizingWebContent()) {</span>
<span class="line-modified">!         // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-added">+         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
<span class="line-added">+     }</span>
  
      dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
  
      if (!m_documentTiming.domContentLoadedEventEnd)
          m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5876,11 ***</span>
      return m_isTelephoneNumberParsingAllowed;
  }
  
  #endif
  
<span class="line-modified">! String Document::originIdentifierForPasteboard()</span>
  {
      auto origin = securityOrigin().toString();
      if (origin != &quot;null&quot;)
          return origin;
      if (!m_uniqueIdentifier)
<span class="line-new-header">--- 5746,11 ---</span>
      return m_isTelephoneNumberParsingAllowed;
  }
  
  #endif
  
<span class="line-modified">! String Document::originIdentifierForPasteboard() const</span>
  {
      auto origin = securityOrigin().toString();
      if (origin != &quot;null&quot;)
          return origin;
      if (!m_uniqueIdentifier)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5919,11 ***</span>
      if (!m_frame) {
          // No source for a security context.
          // This can occur via document.implementation.createDocument().
          setCookieURL(URL({ }, emptyString()));
          setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
<span class="line-modified">!         setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));</span>
          return;
      }
  
      // In the common case, create the security context from the currently
      // loading URL with a fresh content security policy.
<span class="line-new-header">--- 5789,11 ---</span>
      if (!m_frame) {
          // No source for a security context.
          // This can occur via document.implementation.createDocument().
          setCookieURL(URL({ }, emptyString()));
          setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
<span class="line-modified">!         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));</span>
          return;
      }
  
      // In the common case, create the security context from the currently
      // loading URL with a fresh content security policy.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5938,26 ***</span>
      bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
      if (!isSecurityOriginUnique)
          isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
  
      setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
<span class="line-modified">!     setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {</span>
<span class="line-removed">-         // If this document was loaded with substituteData, then the document can</span>
<span class="line-removed">-         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756</span>
<span class="line-removed">-         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further</span>
<span class="line-removed">-         // discussion.</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead</span>
<span class="line-removed">-         // of &quot;loader()&quot; as the latter returns NULL while the document is being</span>
<span class="line-removed">-         // constructed</span>
<span class="line-removed">-         // DocumentLoader* documentLoader = loader();</span>
<span class="line-removed">-         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();</span>
<span class="line-removed">-         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())</span>
<span class="line-removed">-             securityOrigin().grantLoadLocalResources();</span>
<span class="line-removed">-     }</span>
  
      String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
      if (!overrideContentSecurityPolicy.isNull())
          contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
  
<span class="line-new-header">--- 5808,11 ---</span>
      bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
      if (!isSecurityOriginUnique)
          isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
  
      setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
<span class="line-modified">!     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>
  
      String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
      if (!overrideContentSecurityPolicy.isNull())
          contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6070,13 ***</span>
          return;
      ContentSecurityPolicy* ownerPolicy = nullptr;
      if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
          ownerPolicy = previousPolicy;
      if (!ownerPolicy) {
<span class="line-modified">!     Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">!     if (!ownerFrame)</span>
<span class="line-modified">!         ownerFrame = m_frame-&gt;loader().opener();</span>
          if (ownerFrame)
              ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
      }
      if (!ownerPolicy)
          return;
<span class="line-new-header">--- 5925,13 ---</span>
          return;
      ContentSecurityPolicy* ownerPolicy = nullptr;
      if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
          ownerPolicy = previousPolicy;
      if (!ownerPolicy) {
<span class="line-modified">!         Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">!         if (!ownerFrame)</span>
<span class="line-modified">!             ownerFrame = m_frame-&gt;loader().opener();</span>
          if (ownerFrame)
              ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
      }
      if (!ownerPolicy)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6096,10 ***</span>
<span class="line-new-header">--- 5951,12 ---</span>
  
  bool Document::isSecureContext() const
  {
      if (!m_frame)
          return true;
<span class="line-added">+     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())</span>
<span class="line-added">+         return true;</span>
      if (!securityOrigin().isPotentiallyTrustworthy())
          return false;
      for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
          if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6163,16 ***</span>
  #if ENABLE(WEBGL2)
      if (is&lt;WebGL2RenderingContext&gt;(*context))
          return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">!     if (is&lt;WebGPURenderingContext&gt;(*context))</span>
<span class="line-modified">!         return RenderingContext { RefPtr&lt;WebGPURenderingContext&gt; { &amp;downcast&lt;WebGPURenderingContext&gt;(*context) } };</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- #if ENABLE(WEBMETAL)</span>
<span class="line-removed">-     if (is&lt;WebMetalRenderingContext&gt;(*context))</span>
<span class="line-removed">-         return RenderingContext { RefPtr&lt;WebMetalRenderingContext&gt; { &amp;downcast&lt;WebMetalRenderingContext&gt;(*context) } };</span>
  #endif
  
      return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
  }
  
<span class="line-new-header">--- 6020,12 ---</span>
  #if ENABLE(WEBGL2)
      if (is&lt;WebGL2RenderingContext&gt;(*context))
          return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
  #endif
  #if ENABLE(WEBGPU)
<span class="line-modified">!     if (is&lt;GPUCanvasContext&gt;(*context))</span>
<span class="line-modified">!         return RenderingContext { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*context) } };</span>
  #endif
  
      return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6195,11 ***</span>
  
  #if ENABLE(TEXT_AUTOSIZING)
  TextAutoSizing&amp; Document::textAutoSizing()
  {
      if (!m_textAutoSizing)
<span class="line-modified">!         m_textAutoSizing = std::make_unique&lt;TextAutoSizing&gt;();</span>
      return *m_textAutoSizing;
  }
  #endif // ENABLE(TEXT_AUTOSIZING)
  
  void Document::initDNSPrefetch()
<span class="line-new-header">--- 6048,11 ---</span>
  
  #if ENABLE(TEXT_AUTOSIZING)
  TextAutoSizing&amp; Document::textAutoSizing()
  {
      if (!m_textAutoSizing)
<span class="line-modified">!         m_textAutoSizing = makeUnique&lt;TextAutoSizing&gt;();</span>
      return *m_textAutoSizing;
  }
  #endif // ENABLE(TEXT_AUTOSIZING)
  
  void Document::initDNSPrefetch()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6226,10 ***</span>
<span class="line-new-header">--- 6079,30 ---</span>
  
      m_isDNSPrefetchEnabled = false;
      m_haveExplicitlyDisabledDNSPrefetch = true;
  }
  
<span class="line-added">+ void Document::getParserLocation(String&amp; completedURL, unsigned&amp; line, unsigned&amp; column) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // We definitely cannot associate the message with a location being parsed if we are not even parsing.</span>
<span class="line-added">+     if (!parsing())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ScriptableDocumentParser* parser = scriptableDocumentParser();</span>
<span class="line-added">+     if (!parser)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // When the parser waits for scripts, any messages must be coming from some other source, and are not related to the location of the script element that made the parser wait.</span>
<span class="line-added">+     if (!parser-&gt;shouldAssociateConsoleMessagesWithTextPosition())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     completedURL = url().string();</span>
<span class="line-added">+     TextPosition position = parser-&gt;textPosition();</span>
<span class="line-added">+     line = position.m_line.oneBasedInt();</span>
<span class="line-added">+     column = position.m_column.oneBasedInt();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
  {
      if (!isContextThread()) {
          postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6264,14 ***</span>
          page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
  }
  
  void Document::postTask(Task&amp;&amp; task)
  {
<span class="line-modified">!     callOnMainThread([documentReference = makeWeakPtr(*this), task = WTFMove(task)]() mutable {</span>
          ASSERT(isMainThread());
  
<span class="line-modified">!         Document* document = documentReference.get();</span>
          if (!document)
              return;
  
          Page* page = document-&gt;page();
          if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
<span class="line-new-header">--- 6137,14 ---</span>
          page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
  }
  
  void Document::postTask(Task&amp;&amp; task)
  {
<span class="line-modified">!     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {</span>
          ASSERT(isMainThread());
  
<span class="line-modified">!         auto* document = allDocumentsMap().get(documentID);</span>
          if (!document)
              return;
  
          Page* page = document-&gt;page();
          if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6351,17 ***</span>
  {
      if (m_scriptedAnimationController)
          m_scriptedAnimationController-&gt;resume();
  }
  
<span class="line-modified">! void Document::windowScreenDidChange(PlatformDisplayID displayID)</span>
  {
<span class="line-modified">! #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">!     if (m_animationScheduler)</span>
<span class="line-modified">!         m_animationScheduler-&gt;windowScreenDidChange(displayID);</span>
<span class="line-modified">! #endif</span>
  
      if (RenderView* view = renderView()) {
          if (view-&gt;usesCompositing())
              view-&gt;compositor().windowScreenDidChange(displayID);
      }
  }
<span class="line-new-header">--- 6224,24 ---</span>
  {
      if (m_scriptedAnimationController)
          m_scriptedAnimationController-&gt;resume();
  }
  
<span class="line-modified">! void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)</span>
  {
<span class="line-modified">!     if (m_timeline)</span>
<span class="line-modified">!         m_timeline-&gt;updateAnimationsAndSendEvents(timestamp);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_scriptedAnimationController)</span>
<span class="line-added">+         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ void Document::windowScreenDidChange(PlatformDisplayID displayID)</span>
<span class="line-added">+ {</span>
      if (RenderView* view = renderView()) {
          if (view-&gt;usesCompositing())
              view-&gt;compositor().windowScreenDidChange(displayID);
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6429,573 ***</span>
      deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
  }
  
  #endif
  
<span class="line-modified">! #if ENABLE(FULLSCREEN_API)</span>
  
<span class="line-modified">! bool Document::fullScreenIsAllowedForElement(Element&amp; element) const</span>
  {
<span class="line-modified">!     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, element.document().ownerElement());</span>
  }
  
<span class="line-modified">! void Document::requestFullScreenForElement(Element* element, FullScreenCheckType checkType)</span>
  {
<span class="line-modified">!     if (!element)</span>
<span class="line-modified">!         element = documentElement();</span>
  
<span class="line-modified">!     auto failedPreflights = [this](auto element) mutable {</span>
<span class="line-modified">!         m_fullScreenErrorEventTargetQueue.append(WTFMove(element));</span>
<span class="line-modified">!         m_fullScreenTaskQueue.enqueueTask([this] {</span>
<span class="line-removed">-             dispatchFullScreenChangeEvents();</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire</span>
<span class="line-modified">!     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s</span>
<span class="line-modified">!     // node document:</span>
  
<span class="line-modified">!     // This algorithm is not allowed to show a pop-up:</span>
<span class="line-modified">!     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:</span>
<span class="line-modified">!     //   - an activation behavior is currently being processed whose click event was trusted, or</span>
<span class="line-modified">!     //   - the event listener for a trusted click event is being handled.</span>
<span class="line-modified">!     if (!UserGestureIndicator::processingUserGesture()) {</span>
<span class="line-removed">-         failedPreflights(WTFMove(element));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // We do not allow pressing the Escape key as a user gesture to enter fullscreen since this is the key</span>
<span class="line-modified">!     // to exit fullscreen.</span>
<span class="line-modified">!     if (UserGestureIndicator::currentUserGesture()-&gt;gestureType() == UserGestureType::EscapeKey) {</span>
<span class="line-modified">!         addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Escape key may not be used as a user gesture to enter fullscreen&quot;_s);</span>
<span class="line-modified">!         failedPreflights(WTFMove(element));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // There is a previously-established user preference, security risk, or platform limitation.</span>
<span class="line-modified">!     if (!page() || !page()-&gt;settings().fullScreenEnabled()) {</span>
<span class="line-removed">-         failedPreflights(WTFMove(element));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     bool hasKeyboardAccess = true;</span>
<span class="line-modified">!     if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {</span>
<span class="line-modified">!         // The new full screen API does not accept a &quot;flags&quot; parameter, so fall back to disallowing</span>
<span class="line-modified">!         // keyboard input if the chrome client refuses to allow keyboard input.</span>
<span class="line-removed">-         hasKeyboardAccess = false;</span>
  
<span class="line-modified">!         if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {</span>
<span class="line-modified">!             failedPreflights(WTFMove(element));</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenTaskQueue.enqueueTask([this, element = makeRefPtr(element), checkType, hasKeyboardAccess, failedPreflights] () mutable {</span>
<span class="line-removed">-         // Don&#39;t allow fullscreen if document is hidden.</span>
<span class="line-removed">-         if (hidden()) {</span>
<span class="line-removed">-             failedPreflights(WTFMove(element));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // The context object is not in a document.</span>
<span class="line-removed">-         if (!element-&gt;isConnected()) {</span>
<span class="line-removed">-             failedPreflights(WTFMove(element));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have</span>
<span class="line-removed">-         // the fullscreen enabled flag set.</span>
<span class="line-removed">-         if (checkType == EnforceIFrameAllowFullScreenRequirement &amp;&amp; !fullScreenIsAllowedForElement(*element)) {</span>
<span class="line-removed">-             failedPreflights(WTFMove(element));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // The context object&#39;s node document fullscreen element stack is not empty and its top element</span>
<span class="line-removed">-         // is not an ancestor of the context object.</span>
<span class="line-removed">-         if (!m_fullScreenElementStack.isEmpty() &amp;&amp; !m_fullScreenElementStack.last()-&gt;contains(element.get())) {</span>
<span class="line-removed">-             failedPreflights(WTFMove(element));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.</span>
<span class="line-removed">-         bool descendentHasNonEmptyStack = false;</span>
<span class="line-removed">-         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {</span>
<span class="line-removed">-             if (descendant-&gt;document()-&gt;webkitFullscreenElement()) {</span>
<span class="line-removed">-                 descendentHasNonEmptyStack = true;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (descendentHasNonEmptyStack) {</span>
<span class="line-removed">-             failedPreflights(WTFMove(element));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 2. Let doc be element&#39;s node document. (i.e. &quot;this&quot;)</span>
<span class="line-removed">-         Document* currentDoc = this;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 3. Let docs be all doc&#39;s ancestor browsing context&#39;s documents (if any) and doc.</span>
<span class="line-removed">-         Deque&lt;Document*&gt; docs;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         do {</span>
<span class="line-removed">-             docs.prepend(currentDoc);</span>
<span class="line-removed">-             currentDoc = currentDoc-&gt;ownerElement() ? &amp;currentDoc-&gt;ownerElement()-&gt;document() : nullptr;</span>
<span class="line-removed">-         } while (currentDoc);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 4. For each document in docs, run these substeps:</span>
<span class="line-removed">-         Deque&lt;Document*&gt;::iterator current = docs.begin(), following = docs.begin();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         do {</span>
<span class="line-removed">-             ++following;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 1. Let following document be the document after document in docs, or null if there is no</span>
<span class="line-removed">-             // such document.</span>
<span class="line-removed">-             Document* currentDoc = *current;</span>
<span class="line-removed">-             Document* followingDoc = following != docs.end() ? *following : nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 2. If following document is null, push context object on document&#39;s fullscreen element</span>
<span class="line-removed">-             // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute</span>
<span class="line-removed">-             // set to true on the document.</span>
<span class="line-removed">-             if (!followingDoc) {</span>
<span class="line-removed">-                 currentDoc-&gt;pushFullscreenElementStack(*element);</span>
<span class="line-removed">-                 addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 3. Otherwise, if document&#39;s fullscreen element stack is either empty or its top element</span>
<span class="line-removed">-             // is not following document&#39;s browsing context container,</span>
<span class="line-removed">-             Element* topElement = currentDoc-&gt;webkitFullscreenElement();</span>
<span class="line-removed">-             if (!topElement || topElement != followingDoc-&gt;ownerElement()) {</span>
<span class="line-removed">-                 // ...push following document&#39;s browsing context container on document&#39;s fullscreen element</span>
<span class="line-removed">-                 // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute</span>
<span class="line-removed">-                 // set to true on document.</span>
<span class="line-removed">-                 currentDoc-&gt;pushFullscreenElementStack(*followingDoc-&gt;ownerElement());</span>
<span class="line-removed">-                 addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // 4. Otherwise, do nothing for this document. It stays the same.</span>
<span class="line-removed">-         } while (++current != docs.end());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 5. Return, and run the remaining steps asynchronously.</span>
<span class="line-removed">-         // 6. Optionally, perform some animation.</span>
<span class="line-removed">-         m_areKeysEnabledInFullScreen = hasKeyboardAccess;</span>
<span class="line-removed">-         m_fullScreenTaskQueue.enqueueTask([this, element = WTFMove(element)] {</span>
<span class="line-removed">-             if (auto page = this-&gt;page())</span>
<span class="line-removed">-                 page-&gt;chrome().client().enterFullScreenForElement(*element.get());</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 7. Optionally, display a message indicating how the user can exit displaying the context object fullscreen.</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitCancelFullScreen()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // The Mozilla &quot;cancelFullScreen()&quot; API behaves like the W3C &quot;fully exit fullscreen&quot; behavior, which</span>
<span class="line-removed">-     // is defined as:</span>
<span class="line-removed">-     // &quot;To fully exit fullscreen act as if the exitFullscreen() method was invoked on the top-level browsing</span>
<span class="line-removed">-     // context&#39;s document and subsequently empty that document&#39;s fullscreen element stack.&quot;</span>
<span class="line-removed">-     Document&amp; topDocument = this-&gt;topDocument();</span>
<span class="line-removed">-     if (!topDocument.webkitFullscreenElement())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // To achieve that aim, remove all the elements from the top document&#39;s stack except for the first before</span>
<span class="line-removed">-     // calling webkitExitFullscreen():</span>
<span class="line-removed">-     Vector&lt;RefPtr&lt;Element&gt;&gt; replacementFullscreenElementStack;</span>
<span class="line-removed">-     replacementFullscreenElementStack.append(topDocument.webkitFullscreenElement());</span>
<span class="line-removed">-     topDocument.m_fullScreenElementStack.swap(replacementFullscreenElementStack);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     topDocument.webkitExitFullscreen();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitExitFullscreen()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // The exitFullscreen() method must run these steps:</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 1. Let doc be the context object. (i.e. &quot;this&quot;)</span>
<span class="line-removed">-     Document* currentDoc = this;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 2. If doc&#39;s fullscreen element stack is empty, terminate these steps.</span>
<span class="line-removed">-     if (m_fullScreenElementStack.isEmpty())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 3. Let descendants be all the doc&#39;s descendant browsing context&#39;s documents with a non-empty fullscreen</span>
<span class="line-removed">-     // element stack (if any), ordered so that the child of the doc is last and the document furthest</span>
<span class="line-removed">-     // away from the doc is first.</span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;Document&gt;&gt; descendants;</span>
<span class="line-removed">-     for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {</span>
<span class="line-removed">-         if (descendant-&gt;document()-&gt;webkitFullscreenElement())</span>
<span class="line-removed">-             descendants.prepend(descendant-&gt;document());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 4. For each descendant in descendants, empty descendant&#39;s fullscreen element stack, and queue a</span>
<span class="line-removed">-     // task to fire an event named fullscreenchange with its bubbles attribute set to true on descendant.</span>
<span class="line-removed">-     for (auto&amp; document : descendants) {</span>
<span class="line-removed">-         document-&gt;clearFullscreenElementStack();</span>
<span class="line-removed">-         addDocumentToFullScreenChangeEventQueue(*document);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 5. While doc is not null, run these substeps:</span>
<span class="line-removed">-     Element* newTop = nullptr;</span>
<span class="line-removed">-     while (currentDoc) {</span>
<span class="line-removed">-         // 1. Pop the top element of doc&#39;s fullscreen element stack.</span>
<span class="line-removed">-         currentDoc-&gt;popFullscreenElementStack();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         //    If doc&#39;s fullscreen element stack is non-empty and the element now at the top is either</span>
<span class="line-removed">-         //    not in a document or its node document is not doc, repeat this substep.</span>
<span class="line-removed">-         newTop = currentDoc-&gt;webkitFullscreenElement();</span>
<span class="line-removed">-         if (newTop &amp;&amp; (!newTop-&gt;isConnected() || &amp;newTop-&gt;document() != currentDoc))</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 2. Queue a task to fire an event named fullscreenchange with its bubbles attribute set to true</span>
<span class="line-removed">-         // on doc.</span>
<span class="line-removed">-         addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 3. If doc&#39;s fullscreen element stack is empty and doc&#39;s browsing context has a browsing context</span>
<span class="line-removed">-         // container, set doc to that browsing context container&#39;s node document.</span>
<span class="line-removed">-         if (!newTop &amp;&amp; currentDoc-&gt;ownerElement()) {</span>
<span class="line-removed">-             currentDoc = &amp;currentDoc-&gt;ownerElement()-&gt;document();</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // 4. Otherwise, set doc to null.</span>
<span class="line-removed">-         currentDoc = nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 6. Return, and run the remaining steps asynchronously.</span>
<span class="line-removed">-     // 7. Optionally, perform some animation.</span>
<span class="line-removed">-     m_fullScreenTaskQueue.enqueueTask([this, newTop = makeRefPtr(newTop), fullScreenElement = m_fullScreenElement] {</span>
<span class="line-removed">-         auto* page = this-&gt;page();</span>
<span class="line-removed">-         if (!page)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Only exit out of full screen window mode if there are no remaining elements in the</span>
<span class="line-removed">-         // full screen stack.</span>
<span class="line-removed">-         if (!newTop) {</span>
<span class="line-removed">-             page-&gt;chrome().client().exitFullScreenForElement(fullScreenElement.get());</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Otherwise, notify the chrome of the new full screen element.</span>
<span class="line-removed">-         page-&gt;chrome().client().enterFullScreenForElement(*newTop);</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Document::webkitFullscreenEnabled() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor</span>
<span class="line-removed">-     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Top-level browsing contexts are implied to have their allowFullScreen attribute set.</span>
<span class="line-removed">-     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, ownerElement());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void unwrapFullScreenRenderer(RenderFullScreen* fullScreenRenderer, Element* fullScreenElement)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!fullScreenRenderer)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     bool requiresRenderTreeRebuild;</span>
<span class="line-removed">-     fullScreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (requiresRenderTreeRebuild &amp;&amp; fullScreenElement &amp;&amp; fullScreenElement-&gt;parentElement())</span>
<span class="line-removed">-         fullScreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitWillEnterFullScreen(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Protect against being called after the document has been removed from the page.</span>
<span class="line-removed">-     if (!page())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(page()-&gt;settings().fullScreenEnabled());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     element.willBecomeFullscreenElement();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement = &amp;element;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(NATIVE_FULLSCREEN_VIDEO)</span>
<span class="line-removed">-     if (element.isMediaElement())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Create a placeholder block for a the full-screen element, to keep the page from reflowing</span>
<span class="line-removed">-     // when the element is removed from the normal flow.  Only do this for a RenderBox, as only</span>
<span class="line-removed">-     // a box will have a frameRect.  The placeholder will be created in setFullScreenRenderer()</span>
<span class="line-removed">-     // during layout.</span>
<span class="line-removed">-     auto renderer = m_fullScreenElement-&gt;renderer();</span>
<span class="line-removed">-     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);</span>
<span class="line-removed">-     if (shouldCreatePlaceholder) {</span>
<span class="line-removed">-         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();</span>
<span class="line-removed">-         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_fullScreenElement != documentElement() &amp;&amp; renderer)</span>
<span class="line-removed">-         RenderFullScreen::wrapExistingRenderer(*renderer, *this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     resolveStyle(ResolveStyleType::Rebuild);</span>
<span class="line-removed">-     dispatchFullScreenChangeEvents();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitDidEnterFullScreen()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_fullScreenElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement-&gt;didBecomeFullscreenElement();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitWillExitFullScreen()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_fullScreenElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement-&gt;willStopBeingFullscreenElement();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::webkitDidExitFullScreen()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_fullScreenElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_areKeysEnabledInFullScreen = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElement = nullptr;</span>
<span class="line-removed">-     scheduleFullStyleRebuild();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // When webkitCancelFullScreen is called, we call webkitExitFullScreen on the topDocument(). That</span>
<span class="line-removed">-     // means that the events will be queued there. So if we have no events here, start the timer on</span>
<span class="line-removed">-     // the exiting document.</span>
<span class="line-removed">-     bool eventTargetQueuesEmpty = m_fullScreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullScreenErrorEventTargetQueue.isEmpty();</span>
<span class="line-removed">-     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : *this;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     exitingDocument.dispatchFullScreenChangeEvents();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::setFullScreenRenderer(RenderTreeBuilder&amp; builder, RenderFullScreen&amp; renderer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (&amp;renderer == m_fullScreenRenderer)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_savedPlaceholderRenderStyle)</span>
<span class="line-removed">-         builder.createPlaceholderForFullScreen(renderer, WTFMove(m_savedPlaceholderRenderStyle), m_savedPlaceholderFrameRect);</span>
<span class="line-removed">-     else if (m_fullScreenRenderer &amp;&amp; m_fullScreenRenderer-&gt;placeholder()) {</span>
<span class="line-removed">-         auto* placeholder = m_fullScreenRenderer-&gt;placeholder();</span>
<span class="line-removed">-         builder.createPlaceholderForFullScreen(renderer, RenderStyle::clonePtr(placeholder-&gt;style()), placeholder-&gt;frameRect());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_fullScreenRenderer)</span>
<span class="line-removed">-         builder.destroy(*m_fullScreenRenderer);</span>
<span class="line-removed">-     ASSERT(!m_fullScreenRenderer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenRenderer = makeWeakPtr(renderer);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::dispatchFullScreenChangeEvents()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Since we dispatch events in this function, it&#39;s possible that the</span>
<span class="line-removed">-     // document will be detached and GC&#39;d. We protect it here to make sure we</span>
<span class="line-removed">-     // can finish the function successfully.</span>
<span class="line-removed">-     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;Node&gt;&gt; changeQueue;</span>
<span class="line-removed">-     m_fullScreenChangeEventTargetQueue.swap(changeQueue);</span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;Node&gt;&gt; errorQueue;</span>
<span class="line-removed">-     m_fullScreenErrorEventTargetQueue.swap(errorQueue);</span>
<span class="line-removed">-     dispatchFullScreenChangeOrErrorEvent(changeQueue, eventNames().webkitfullscreenchangeEvent, /* shouldNotifyMediaElement */ true);</span>
<span class="line-removed">-     dispatchFullScreenChangeOrErrorEvent(errorQueue, eventNames().webkitfullscreenerrorEvent, /* shouldNotifyMediaElement */ false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::dispatchFullScreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp; queue, const AtomicString&amp; eventName, bool shouldNotifyMediaElement)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     while (!queue.isEmpty()) {</span>
<span class="line-removed">-         RefPtr&lt;Node&gt; node = queue.takeFirst();</span>
<span class="line-removed">-         if (!node)</span>
<span class="line-removed">-             node = documentElement();</span>
<span class="line-removed">-         // The dispatchEvent below may have blown away our documentElement.</span>
<span class="line-removed">-         if (!node)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // If the element was removed from our tree, also message the documentElement. Since we may</span>
<span class="line-removed">-         // have a document hierarchy, check that node isn&#39;t in another document.</span>
<span class="line-removed">-         if (!node-&gt;isConnected())</span>
<span class="line-removed">-             queue.append(documentElement());</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(VIDEO)</span>
<span class="line-removed">-         if (shouldNotifyMediaElement &amp;&amp; is&lt;HTMLMediaElement&gt;(*node))</span>
<span class="line-removed">-             downcast&lt;HTMLMediaElement&gt;(*node).enteredOrExitedFullscreen();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-         UNUSED_PARAM(shouldNotifyMediaElement);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-         node-&gt;dispatchEvent(Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::No));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::fullScreenElementRemoved()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);</span>
<span class="line-removed">-     webkitCancelFullScreen();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::adjustFullScreenElementOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_fullScreenElement)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool elementInSubtree = false;</span>
<span class="line-removed">-     if (nodeRemoval == NodeRemoval::ChildrenOfNode)</span>
<span class="line-removed">-         elementInSubtree = m_fullScreenElement-&gt;isDescendantOf(node);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         elementInSubtree = (m_fullScreenElement == &amp;node) || m_fullScreenElement-&gt;isDescendantOf(node);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (elementInSubtree)</span>
<span class="line-removed">-         fullScreenElementRemoved();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Document::isAnimatingFullScreen() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_isAnimatingFullScreen;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::setAnimatingFullScreen(bool flag)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_isAnimatingFullScreen == flag)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     m_isAnimatingFullScreen = flag;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {</span>
<span class="line-removed">-         m_fullScreenElement-&gt;invalidateStyleForSubtree();</span>
<span class="line-removed">-         scheduleFullStyleRebuild();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Document::areFullscreenControlsHidden() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_areFullscreenControlsHidden;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::setFullscreenControlsHidden(bool flag)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_areFullscreenControlsHidden == flag)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     m_areFullscreenControlsHidden = flag;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {</span>
<span class="line-removed">-         m_fullScreenElement-&gt;invalidateStyleForSubtree();</span>
<span class="line-removed">-         scheduleFullStyleRebuild();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::clearFullscreenElementStack()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_fullScreenElementStack.clear();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::popFullscreenElementStack()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_fullScreenElementStack.isEmpty())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_fullScreenElementStack.removeLast();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::pushFullscreenElementStack(Element&amp; element)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_fullScreenElementStack.append(&amp;element);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::addDocumentToFullScreenChangeEventQueue(Document&amp; document)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Node* target = document.webkitFullscreenElement();</span>
<span class="line-removed">-     if (!target)</span>
<span class="line-removed">-         target = document.webkitCurrentFullScreenElement();</span>
<span class="line-removed">-     if (!target)</span>
<span class="line-removed">-         target = &amp;document;</span>
<span class="line-removed">-     m_fullScreenChangeEventTargetQueue.append(target);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(POINTER_LOCK)</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::exitPointerLock()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Page* page = this-&gt;page();</span>
<span class="line-removed">-     if (!page)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     if (auto* target = page-&gt;pointerLockController().element()) {</span>
<span class="line-removed">-         if (&amp;target-&gt;document() != this)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     page-&gt;pointerLockController().requestPointerUnlock();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::decrementLoadEventDelayCount()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_loadEventDelayCount);</span>
<span class="line-removed">-     --m_loadEventDelayCount;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())</span>
<span class="line-removed">-         m_loadEventDelayTimer.startOneShot(0_s);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::loadEventDelayTimerFired()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?</span>
<span class="line-removed">-     // FIXME: Should this also call DocumentLoader::checkLoadComplete?</span>
<span class="line-removed">-     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is</span>
<span class="line-removed">-     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.</span>
<span class="line-removed">-     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-removed">-     checkCompleted();</span>
<span class="line-removed">-     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">-         frame-&gt;loader().checkLoadComplete();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::checkCompleted()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">-         frame-&gt;loader().checkCompleted();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- double Document::monotonicTimestamp() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* loader = this-&gt;loader();</span>
<span class="line-removed">-     if (!loader)</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_scriptedAnimationController) {</span>
<span class="line-removed">-         m_scriptedAnimationController = ScriptedAnimationController::create(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // It&#39;s possible that the Page may have suspended scripted animations before</span>
<span class="line-removed">-         // we were created. We need to make sure that we don&#39;t start up the animation</span>
<span class="line-removed">-         // controller on a background tab, for example.</span>
<span class="line-removed">-         if (!page() || page()-&gt;scriptedAnimationsSuspended())</span>
<span class="line-removed">-             m_scriptedAnimationController-&gt;suspend();</span>
  
          if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
              m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
  
          if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
<span class="line-new-header">--- 6309,72 ---</span>
      deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
  }
  
  #endif
  
<span class="line-modified">! #if ENABLE(POINTER_LOCK)</span>
  
<span class="line-modified">! void Document::exitPointerLock()</span>
  {
<span class="line-modified">!     Page* page = this-&gt;page();</span>
<span class="line-added">+     if (!page)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     if (auto* target = page-&gt;pointerLockController().element()) {</span>
<span class="line-added">+         if (&amp;target-&gt;document() != this)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     page-&gt;pointerLockController().requestPointerUnlock();</span>
  }
  
<span class="line-modified">! #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::decrementLoadEventDelayCount()</span>
  {
<span class="line-modified">!     ASSERT(m_loadEventDelayCount);</span>
<span class="line-modified">!     --m_loadEventDelayCount;</span>
  
<span class="line-modified">!     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())</span>
<span class="line-modified">!         m_loadEventDelayTimer.startOneShot(0_s);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void Document::loadEventDelayTimerFired()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?</span>
<span class="line-added">+     // FIXME: Should this also call DocumentLoader::checkLoadComplete?</span>
<span class="line-added">+     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is</span>
<span class="line-added">+     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.</span>
<span class="line-added">+     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-added">+     checkCompleted();</span>
<span class="line-added">+     if (auto* frame = this-&gt;frame())</span>
<span class="line-added">+         frame-&gt;loader().checkLoadComplete();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void Document::checkCompleted()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (auto* frame = this-&gt;frame())</span>
<span class="line-modified">!         frame-&gt;loader().checkCompleted();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! double Document::monotonicTimestamp() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto* loader = this-&gt;loader();</span>
<span class="line-modified">!     if (!loader)</span>
<span class="line-modified">!         return 0;</span>
  
<span class="line-modified">!     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!m_scriptedAnimationController) {</span>
<span class="line-modified">!         m_scriptedAnimationController = ScriptedAnimationController::create(*this);</span>
  
<span class="line-modified">!         // It&#39;s possible that the Page may have suspended scripted animations before</span>
<span class="line-modified">!         // we were created. We need to make sure that we don&#39;t start up the animation</span>
<span class="line-modified">!         // controller on a background tab, for example.</span>
<span class="line-modified">!         if (!page() || page()-&gt;scriptedAnimationsSuspended())</span>
<span class="line-modified">!             m_scriptedAnimationController-&gt;suspend();</span>
  
          if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
              m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
  
          if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7036,11 ***</span>
  }
  
  void Document::didAddWheelEventHandler(Node&amp; node)
  {
      if (!m_wheelEventTargets)
<span class="line-modified">!         m_wheelEventTargets = std::make_unique&lt;EventTargetSet&gt;();</span>
  
      m_wheelEventTargets-&gt;add(&amp;node);
  
      wheelEventHandlersChanged();
  
<span class="line-new-header">--- 6415,11 ---</span>
  }
  
  void Document::didAddWheelEventHandler(Node&amp; node)
  {
      if (!m_wheelEventTargets)
<span class="line-modified">!         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();</span>
  
      m_wheelEventTargets-&gt;add(&amp;node);
  
      wheelEventHandlersChanged();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7096,11 ***</span>
  
  void Document::didAddTouchEventHandler(Node&amp; handler)
  {
  #if ENABLE(TOUCH_EVENTS)
      if (!m_touchEventTargets)
<span class="line-modified">!         m_touchEventTargets = std::make_unique&lt;EventTargetSet&gt;();</span>
  
      m_touchEventTargets-&gt;add(&amp;handler);
  
      if (Document* parent = parentDocument()) {
          parent-&gt;didAddTouchEventHandler(*this);
<span class="line-new-header">--- 6475,11 ---</span>
  
  void Document::didAddTouchEventHandler(Node&amp; handler)
  {
  #if ENABLE(TOUCH_EVENTS)
      if (!m_touchEventTargets)
<span class="line-modified">!         m_touchEventTargets = makeUnique&lt;EventTargetSet&gt;();</span>
  
      m_touchEventTargets-&gt;add(&amp;handler);
  
      if (Document* parent = parentDocument()) {
          parent-&gt;didAddTouchEventHandler(*this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7237,10 ***</span>
<span class="line-new-header">--- 6616,13 ---</span>
  bool Document::processingUserGestureForMedia() const
  {
      if (UserGestureIndicator::processingUserGestureForMedia())
          return true;
  
<span class="line-added">+     if (m_userActivatedMediaFinishedPlayingTimestamp + maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying &gt;= MonotonicTime::now())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
      if (settings().mediaUserGestureInheritsFromDocument())
          return topDocument().hasHadUserInteraction();
  
      auto* loader = this-&gt;loader();
      if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7402,11 ***</span>
              return element;
      }
      return nullptr;
  }
  
<span class="line-modified">! void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement)</span>
  {
      ASSERT(!request.readOnly());
  
      Element* innerElementInDocument = innerElement;
      while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
<span class="line-new-header">--- 6784,11 ---</span>
              return element;
      }
      return nullptr;
  }
  
<span class="line-modified">! void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement, CaptureChange captureElementChanged)</span>
  {
      ASSERT(!request.readOnly());
  
      Element* innerElementInDocument = innerElement;
      while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7441,12 ***</span>
      // nodes should remain :active until the mouse is released.
      bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
  
      // If the mouse is down and if this is a mouse move event, we want to restrict changes in
      // :hover/:active to only apply to elements that are in the :active chain that we froze
<span class="line-modified">!     // at the time the mouse went down.</span>
<span class="line-modified">!     bool mustBeInActiveChain = request.active() &amp;&amp; request.move();</span>
  
      RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
  
      // A touch release does not set a new hover target; clearing the element we&#39;re working with
      // will clear the chain of hovered elements all the way to the top of the tree.
<span class="line-new-header">--- 6823,12 ---</span>
      // nodes should remain :active until the mouse is released.
      bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
  
      // If the mouse is down and if this is a mouse move event, we want to restrict changes in
      // :hover/:active to only apply to elements that are in the :active chain that we froze
<span class="line-modified">!     // at the time the mouse went down, unless the capture element changed.</span>
<span class="line-modified">!     bool mustBeInActiveChain = request.active() &amp;&amp; request.move() &amp;&amp; captureElementChanged == CaptureChange::No;</span>
  
      RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
  
      // A touch release does not set a new hover target; clearing the element we&#39;re working with
      // will clear the chain of hovered elements all the way to the top of the tree.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7504,13 ***</span>
  bool Document::haveStylesheetsLoaded() const
  {
      return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
  }
  
<span class="line-modified">! Locale&amp; Document::getCachedLocale(const AtomicString&amp; locale)</span>
  {
<span class="line-modified">!     AtomicString localeKey = locale;</span>
      if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
          localeKey = defaultLanguage();
      LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
      if (result.isNewEntry)
          result.iterator-&gt;value = Locale::create(localeKey);
<span class="line-new-header">--- 6886,13 ---</span>
  bool Document::haveStylesheetsLoaded() const
  {
      return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
  }
  
<span class="line-modified">! Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)</span>
  {
<span class="line-modified">!     AtomString localeKey = locale;</span>
      if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
          localeKey = defaultLanguage();
      LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
      if (result.isNewEntry)
          result.iterator-&gt;value = Locale::create(localeKey);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7521,13 ***</span>
  {
      if (const Document* document = templateDocument())
          return const_cast&lt;Document&amp;&gt;(*document);
  
      if (isHTMLDocument())
<span class="line-modified">!         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());</span>
      else
<span class="line-modified">!         m_templateDocument = create(WTF::blankURL());</span>
  
      m_templateDocument-&gt;setContextDocument(contextDocument());
      m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
  
      return *m_templateDocument;
<span class="line-new-header">--- 6903,13 ---</span>
  {
      if (const Document* document = templateDocument())
          return const_cast&lt;Document&amp;&gt;(*document);
  
      if (isHTMLDocument())
<span class="line-modified">!         m_templateDocument = HTMLDocument::create(sessionID(), nullptr, WTF::blankURL());</span>
      else
<span class="line-modified">!         m_templateDocument = create(sessionID(), WTF::blankURL());</span>
  
      m_templateDocument-&gt;setContextDocument(contextDocument());
      m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
  
      return *m_templateDocument;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7537,41 ***</span>
  {
      updateStyleIfNeeded();
      return fontSelector().fontFaceSet();
  }
  
  float Document::deviceScaleFactor() const
  {
      float deviceScaleFactor = 1.0;
      if (Page* documentPage = page())
          deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
      return deviceScaleFactor;
  }
  
  bool Document::useSystemAppearance() const
  {
<span class="line-modified">!     bool useSystemAppearance = false;</span>
<span class="line-modified">!     if (Page* documentPage = page())</span>
<span class="line-modified">!         useSystemAppearance = documentPage-&gt;useSystemAppearance();</span>
<span class="line-removed">-     return useSystemAppearance;</span>
  }
  
  bool Document::useDarkAppearance(const RenderStyle* style) const
  {
<span class="line-removed">- #if HAVE(OS_DARK_MODE_SUPPORT)</span>
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;</span>
  
      // Use the style&#39;s supported color schemes, if supplied.
      if (style)
<span class="line-modified">!         supportedColorSchemes = style-&gt;supportedColorSchemes().colorSchemes();</span>
  
      // Fallback to the document&#39;s supported color schemes if style was empty (auto).
<span class="line-modified">!     if (supportedColorSchemes.isEmpty())</span>
<span class="line-modified">!         supportedColorSchemes = m_supportedColorSchemes;</span>
  
<span class="line-modified">!     if (supportedColorSchemes.contains(ColorSchemes::Dark) &amp;&amp; !supportedColorSchemes.contains(ColorSchemes::Light))</span>
          return true;
  #else
      UNUSED_PARAM(style);
  #endif
  
<span class="line-new-header">--- 6919,44 ---</span>
  {
      updateStyleIfNeeded();
      return fontSelector().fontFaceSet();
  }
  
<span class="line-added">+ EditingBehavior Document::editingBehavior() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return EditingBehavior { settings().editingBehaviorType() };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  float Document::deviceScaleFactor() const
  {
      float deviceScaleFactor = 1.0;
      if (Page* documentPage = page())
          deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
      return deviceScaleFactor;
  }
  
  bool Document::useSystemAppearance() const
  {
<span class="line-modified">!     if (auto* documentPage = page())</span>
<span class="line-modified">!         return documentPage-&gt;useSystemAppearance();</span>
<span class="line-modified">!     return false;</span>
  }
  
  bool Document::useDarkAppearance(const RenderStyle* style) const
  {
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     OptionSet&lt;ColorScheme&gt; colorScheme;</span>
  
      // Use the style&#39;s supported color schemes, if supplied.
      if (style)
<span class="line-modified">!         colorScheme = style-&gt;colorScheme().colorScheme();</span>
  
      // Fallback to the document&#39;s supported color schemes if style was empty (auto).
<span class="line-modified">!     if (colorScheme.isEmpty())</span>
<span class="line-modified">!         colorScheme = m_colorScheme;</span>
  
<span class="line-modified">!     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))</span>
          return true;
  #else
      UNUSED_PARAM(style);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7581,30 ***</span>
  
      if (useSystemAppearance())
          return pageUsesDarkAppearance;
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (supportedColorSchemes.contains(ColorSchemes::Dark))</span>
          return pageUsesDarkAppearance;
  #endif
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(style);</span>
<span class="line-removed">- #endif</span>
  
      return false;
  }
  
  OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
  {
      OptionSet&lt;StyleColor::Options&gt; options;
      if (useSystemAppearance())
          options.add(StyleColor::Options::UseSystemAppearance);
      if (useDarkAppearance(style))
          options.add(StyleColor::Options::UseDarkAppearance);
      return options;
  }
  
  void Document::didAssociateFormControl(Element&amp; element)
  {
      auto* page = this-&gt;page();
      if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
          return;
<span class="line-new-header">--- 6966,50 ---</span>
  
      if (useSystemAppearance())
          return pageUsesDarkAppearance;
  
  #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">!     if (colorScheme.contains(ColorScheme::Dark))</span>
          return pageUsesDarkAppearance;
  #endif
  
      return false;
  }
  
<span class="line-added">+ bool Document::useElevatedUserInterfaceLevel() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto* documentPage = page())</span>
<span class="line-added">+         return documentPage-&gt;useElevatedUserInterfaceLevel();</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
  {
      OptionSet&lt;StyleColor::Options&gt; options;
      if (useSystemAppearance())
          options.add(StyleColor::Options::UseSystemAppearance);
      if (useDarkAppearance(style))
          options.add(StyleColor::Options::UseDarkAppearance);
<span class="line-added">+     if (useElevatedUserInterfaceLevel())</span>
<span class="line-added">+         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);</span>
      return options;
  }
  
<span class="line-added">+ CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))</span>
<span class="line-added">+         return CompositeSourceOver;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* frameView = view();</span>
<span class="line-added">+     if (!frameView)</span>
<span class="line-added">+         return CompositeSourceOver;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to</span>
<span class="line-added">+     // use different composite modes to get the right results in this case.</span>
<span class="line-added">+     return frameView-&gt;isTransparent() ? CompositeDestinationOut : CompositeDestinationIn;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::didAssociateFormControl(Element&amp; element)
  {
      auto* page = this-&gt;page();
      if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7615,12 ***</span>
  
  void Document::didAssociateFormControlsTimerFired()
  {
      auto vector = copyToVector(m_associatedFormControls);
      m_associatedFormControls.clear();
<span class="line-modified">!     if (auto* page = this-&gt;page())</span>
<span class="line-modified">!         page-&gt;chrome().client().didAssociateFormControls(vector);</span>
  }
  
  void Document::setCachedDOMCookies(const String&amp; cookies)
  {
      ASSERT(!isDOMCookieCacheValid());
<span class="line-new-header">--- 7020,14 ---</span>
  
  void Document::didAssociateFormControlsTimerFired()
  {
      auto vector = copyToVector(m_associatedFormControls);
      m_associatedFormControls.clear();
<span class="line-modified">!     if (auto* page = this-&gt;page()) {</span>
<span class="line-modified">!         ASSERT(m_frame);</span>
<span class="line-added">+         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);</span>
<span class="line-added">+     }</span>
  }
  
  void Document::setCachedDOMCookies(const String&amp; cookies)
  {
      ASSERT(!isDOMCookieCacheValid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7645,16 ***</span>
  void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
  {
      if (m_hasInjectedPlugInsScript)
          return;
  
      // Use the JS file provided by the Chrome client, or fallback to the default one.
      String jsString = page()-&gt;chrome().client().plugInExtraScript();
<span class="line-modified">!     if (!jsString)</span>
          jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
  
<span class="line-modified">!     frame()-&gt;script().evaluateInWorld(ScriptSourceCode(jsString), world);</span>
  
      m_hasInjectedPlugInsScript = true;
  }
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-new-header">--- 7052,19 ---</span>
  void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
  {
      if (m_hasInjectedPlugInsScript)
          return;
  
<span class="line-added">+     auto&amp; scriptController = frame()-&gt;script();</span>
<span class="line-added">+ </span>
      // Use the JS file provided by the Chrome client, or fallback to the default one.
      String jsString = page()-&gt;chrome().client().plugInExtraScript();
<span class="line-modified">!     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))</span>
          jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
  
<span class="line-modified">!     setHasEvaluatedUserAgentScripts();</span>
<span class="line-added">+     scriptController.evaluateInWorld(ScriptSourceCode(jsString), world);</span>
  
      m_hasInjectedPlugInsScript = true;
  }
  
  #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7827,14 ***</span>
      return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
  }
  
  void Document::applyQuickLookSandbox()
  {
<span class="line-modified">!     const URL&amp; responseURL = m_frame-&gt;loader().activeDocumentLoader()-&gt;responseURL();</span>
      ASSERT(responseURL.protocolIs(QLPreviewProtocol));
  
<span class="line-modified">!     auto securityOrigin = SecurityOrigin::create(responseURL);</span>
      securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
      setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
  
      static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
      RELEASE_ASSERT(contentSecurityPolicy());
<span class="line-new-header">--- 7237,17 ---</span>
      return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
  }
  
  void Document::applyQuickLookSandbox()
  {
<span class="line-modified">!     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();</span>
<span class="line-added">+     auto documentURL = documentLoader.documentURL();</span>
<span class="line-added">+     auto&amp; responseURL = documentLoader.responseURL();</span>
<span class="line-added">+     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));</span>
      ASSERT(responseURL.protocolIs(QLPreviewProtocol));
  
<span class="line-modified">!     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());</span>
      securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
      setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
  
      static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
      RELEASE_ASSERT(contentSecurityPolicy());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7889,10 ***</span>
<span class="line-new-header">--- 7302,19 ---</span>
  void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)
  {
      m_appearanceDependentPictures.remove(&amp;picture);
  }
  
<span class="line-added">+ void Document::scheduleTimedRenderingUpdate()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-added">+     m_intersectionObserversInitialUpdateTimer.stop();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     if (auto page = this-&gt;page())</span>
<span class="line-added">+         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if ENABLE(INTERSECTION_OBSERVER)
  void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
  {
      ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
      m_intersectionObservers.append(makeWeakPtr(&amp;observer));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7978,13 ***</span>
          expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
  
      LayoutRect localTargetBounds;
      if (is&lt;RenderBox&gt;(*targetRenderer))
          localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
<span class="line-modified">!     else if (is&lt;RenderInline&gt;(targetRenderer))</span>
<span class="line-modified">!         localTargetBounds = downcast&lt;RenderInline&gt;(targetRenderer)-&gt;linesBoundingBox();</span>
<span class="line-modified">!     else if (is&lt;RenderLineBreak&gt;(targetRenderer))</span>
          localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
  
      Optional&lt;LayoutRect&gt; rootLocalTargetRect;
      if (observer.root()) {
          OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
<span class="line-new-header">--- 7400,17 ---</span>
          expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
  
      LayoutRect localTargetBounds;
      if (is&lt;RenderBox&gt;(*targetRenderer))
          localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
<span class="line-modified">!     else if (is&lt;RenderInline&gt;(targetRenderer)) {</span>
<span class="line-modified">!         auto pair = target.boundingAbsoluteRectWithoutLayout();</span>
<span class="line-modified">!         if (pair) {</span>
<span class="line-added">+             FloatRect absoluteTargetBounds = pair-&gt;second;</span>
<span class="line-added">+             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))</span>
          localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
  
      Optional&lt;LayoutRect&gt; rootLocalTargetRect;
      if (observer.root()) {
          OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8016,16 ***</span>
  {
      auto* frameView = view();
      if (!frameView)
          return;
  
      bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
      if (needsLayout || hasPendingStyleRecalc())
          return;
  
<span class="line-removed">-     m_needsForcedIntersectionObservationUpdate = false;</span>
<span class="line-removed">- </span>
      for (const auto&amp; observer : m_intersectionObservers) {
          bool needNotify = false;
          DOMHighResTimeStamp timestamp;
          if (!observer-&gt;createTimestamp(timestamp))
              continue;
<span class="line-new-header">--- 7442,16 ---</span>
  {
      auto* frameView = view();
      if (!frameView)
          return;
  
<span class="line-added">+     m_intersectionObserversInitialUpdateTimer.stop();</span>
<span class="line-added">+ </span>
      bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
      if (needsLayout || hasPendingStyleRecalc())
          return;
  
      for (const auto&amp; observer : m_intersectionObservers) {
          bool needNotify = false;
          DOMHighResTimeStamp timestamp;
          if (!observer-&gt;createTimestamp(timestamp))
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8098,40 ***</span>
  
      if (m_intersectionObserversWithPendingNotifications.size())
          m_intersectionObserversNotifyTimer.startOneShot(0_s);
  }
  
<span class="line-removed">- void Document::scheduleForcedIntersectionObservationUpdate()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!m_intersectionObservers.isEmpty());</span>
<span class="line-removed">-     if (m_needsForcedIntersectionObservationUpdate)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_needsForcedIntersectionObservationUpdate = true;</span>
<span class="line-removed">-     if (auto* page = this-&gt;page())</span>
<span class="line-removed">-         page-&gt;scheduleForcedIntersectionObservationUpdate(*this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Document::notifyIntersectionObserversTimerFired()
  {
      for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
          if (observer)
              observer-&gt;notify();
      }
      m_intersectionObserversWithPendingNotifications.clear();
  }
  #endif
  
<span class="line-modified">! const AtomicString&amp; Document::dir() const</span>
  {
      auto* documentElement = this-&gt;documentElement();
      if (!is&lt;HTMLHtmlElement&gt;(documentElement))
          return nullAtom();
      return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
  }
  
<span class="line-modified">! void Document::setDir(const AtomicString&amp; value)</span>
  {
      auto* documentElement = this-&gt;documentElement();
      if (is&lt;HTMLHtmlElement&gt;(documentElement))
          downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
  }
<span class="line-new-header">--- 7524,119 ---</span>
  
      if (m_intersectionObserversWithPendingNotifications.size())
          m_intersectionObserversNotifyTimer.startOneShot(0_s);
  }
  
  void Document::notifyIntersectionObserversTimerFired()
  {
      for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
          if (observer)
              observer-&gt;notify();
      }
      m_intersectionObserversWithPendingNotifications.clear();
  }
<span class="line-added">+ </span>
<span class="line-added">+ void Document::scheduleInitialIntersectionObservationUpdate()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_readyState == Complete)</span>
<span class="line-added">+         scheduleTimedRenderingUpdate();</span>
<span class="line-added">+     else if (!m_intersectionObserversInitialUpdateTimer.isActive())</span>
<span class="line-added">+         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);</span>
<span class="line-added">+ }</span>
  #endif
  
<span class="line-modified">! #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">+ void Document::addResizeObserver(ResizeObserver&amp; observer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_resizeObservers.contains(&amp;observer))</span>
<span class="line-added">+         m_resizeObservers.append(makeWeakPtr(&amp;observer));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::removeResizeObserver(ResizeObserver&amp; observer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_resizeObservers.removeFirst(&amp;observer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Document::hasResizeObservers()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return !m_resizeObservers.isEmpty();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ size_t Document::gatherResizeObservations(size_t deeperThan)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t minDepth = ResizeObserver::maxElementDepth();</span>
<span class="line-added">+     for (const auto&amp; observer : m_resizeObservers) {</span>
<span class="line-added">+         if (!observer-&gt;hasObservations())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         auto depth = observer-&gt;gatherObservations(deeperThan);</span>
<span class="line-added">+         minDepth = std::min(minDepth, depth);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return minDepth;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::deliverResizeObservations()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto observersToNotify = m_resizeObservers;</span>
<span class="line-added">+     for (const auto&amp; observer : observersToNotify) {</span>
<span class="line-added">+         if (!observer || !observer-&gt;hasActiveObservations())</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         observer-&gt;deliverObservations();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Document::hasSkippedResizeObservations() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (const auto&amp; observer : m_resizeObservers) {</span>
<span class="line-added">+         if (observer-&gt;hasSkippedObservations())</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setHasSkippedResizeObservations(bool skipped)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (const auto&amp; observer : m_resizeObservers)</span>
<span class="line-added">+         observer-&gt;setHasSkippedObservations(skipped);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::updateResizeObservations(Page&amp; page)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!hasResizeObservers())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // We need layout the whole frame tree here. Because ResizeObserver could observe element in other frame,</span>
<span class="line-added">+     // and it could change other frame in deliverResizeObservations().</span>
<span class="line-added">+     page.layoutIfNeeded();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Start check resize obervers;</span>
<span class="line-added">+     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {</span>
<span class="line-added">+         deliverResizeObservations();</span>
<span class="line-added">+         page.layoutIfNeeded();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (hasSkippedResizeObservations()) {</span>
<span class="line-added">+         setHasSkippedResizeObservations(false);</span>
<span class="line-added">+         String url;</span>
<span class="line-added">+         unsigned line = 0;</span>
<span class="line-added">+         unsigned column = 0;</span>
<span class="line-added">+         getParserLocation(url, line, column);</span>
<span class="line-added">+         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);</span>
<span class="line-added">+         // Starting a new schedule the next round of notify.</span>
<span class="line-added">+         scheduleTimedRenderingUpdate();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ const AtomString&amp; Document::dir() const</span>
  {
      auto* documentElement = this-&gt;documentElement();
      if (!is&lt;HTMLHtmlElement&gt;(documentElement))
          return nullAtom();
      return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
  }
  
<span class="line-modified">! void Document::setDir(const AtomString&amp; value)</span>
  {
      auto* documentElement = this-&gt;documentElement();
      if (is&lt;HTMLHtmlElement&gt;(documentElement))
          downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8165,21 ***</span>
  {
  #if ENABLE(MEDIA_STREAM)
      if (!page())
          return;
  
<span class="line-modified">!     RealtimeMediaSourceCenter::singleton().setVideoCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
  #endif
  }
  
  #if ENABLE(MEDIA_STREAM)
  void Document::stopMediaCapture()
  {
<span class="line-modified">!     MediaStreamRegistry::shared().forEach([this](MediaStream&amp; stream) {</span>
<span class="line-removed">-         if (stream.document() == this)</span>
<span class="line-removed">-             stream.endCaptureTracks();</span>
<span class="line-removed">-     });</span>
  }
  
  void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
  {
      m_mediaStreamStateChangeElements.add(&amp;element);
<span class="line-new-header">--- 7670,18 ---</span>
  {
  #if ENABLE(MEDIA_STREAM)
      if (!page())
          return;
  
<span class="line-modified">!     RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
  #endif
  }
  
  #if ENABLE(MEDIA_STREAM)
  void Document::stopMediaCapture()
  {
<span class="line-modified">!     MediaStreamTrack::endCapture(*this);</span>
  }
  
  void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
  {
      m_mediaStreamStateChangeElements.add(&amp;element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8221,11 ***</span>
  {
      for (auto* listener : m_applicationStateChangeListeners)
          functor(*listener);
  }
  
<span class="line-modified">! const AtomicString&amp; Document::bgColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
<span class="line-new-header">--- 7723,11 ---</span>
  {
      for (auto* listener : m_applicationStateChangeListeners)
          functor(*listener);
  }
  
<span class="line-modified">! const AtomString&amp; Document::bgColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8235,11 ***</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
  }
  
<span class="line-modified">! const AtomicString&amp; Document::fgColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
<span class="line-new-header">--- 7737,11 ---</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
  }
  
<span class="line-modified">! const AtomString&amp; Document::fgColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8249,11 ***</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
  }
  
<span class="line-modified">! const AtomicString&amp; Document::alinkColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
<span class="line-new-header">--- 7751,11 ---</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
  }
  
<span class="line-modified">! const AtomString&amp; Document::alinkColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8263,11 ***</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
  }
  
<span class="line-modified">! const AtomicString&amp; Document::linkColorForBindings() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
<span class="line-new-header">--- 7765,11 ---</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
  }
  
<span class="line-modified">! const AtomString&amp; Document::linkColorForBindings() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8277,11 ***</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
  }
  
<span class="line-modified">! const AtomicString&amp; Document::vlinkColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
<span class="line-new-header">--- 7779,11 ---</span>
  {
      if (auto* bodyElement = body())
          bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
  }
  
<span class="line-modified">! const AtomString&amp; Document::vlinkColor() const</span>
  {
      auto* bodyElement = body();
      if (!bodyElement)
          return emptyAtom();
      return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8302,156 ***</span>
      }
  
      return *m_logger;
  }
  
<span class="line-modified">! Optional&lt;uint64_t&gt; Document::pageID() const</span>
  {
      return m_frame-&gt;loader().client().pageID();
  }
  
<span class="line-removed">- void Document::hasStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(settings().storageAccessAPIEnabled());</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-removed">-     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {</span>
<span class="line-removed">-         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_frame || securityOrigin().isUnique()) {</span>
<span class="line-removed">-         promise-&gt;resolve&lt;IDLBoolean&gt;(false);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_frame-&gt;isMainFrame()) {</span>
<span class="line-removed">-         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto&amp; securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-removed">-     auto&amp; topSecurityOrigin = topDocument().securityOrigin();</span>
<span class="line-removed">-     if (securityOrigin.equal(&amp;topSecurityOrigin)) {</span>
<span class="line-removed">-         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto frameID = m_frame-&gt;loader().client().frameID();</span>
<span class="line-removed">-     auto pageID = m_frame-&gt;loader().client().pageID();</span>
<span class="line-removed">-     if (!frameID || !pageID) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (Page* page = this-&gt;page()) {</span>
<span class="line-removed">-         auto iframeHost = securityOrigin.host();</span>
<span class="line-removed">-         auto topHost = topSecurityOrigin.host();</span>
<span class="line-removed">-         page-&gt;chrome().client().hasStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool hasAccess) {</span>
<span class="line-removed">-             Document* document = documentReference.get();</span>
<span class="line-removed">-             if (!document)</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             promise-&gt;resolve&lt;IDLBoolean&gt;(hasAccess);</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     promise-&gt;reject();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::requestStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(settings().storageAccessAPIEnabled());</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-removed">-     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {</span>
<span class="line-removed">-         promise-&gt;resolve();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_frame || securityOrigin().isUnique()) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_frame-&gt;isMainFrame()) {</span>
<span class="line-removed">-         promise-&gt;resolve();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto&amp; topDocument = this-&gt;topDocument();</span>
<span class="line-removed">-     auto&amp; topSecurityOrigin = topDocument.securityOrigin();</span>
<span class="line-removed">-     auto&amp; securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-removed">-     if (securityOrigin.equal(&amp;topSecurityOrigin)) {</span>
<span class="line-removed">-         promise-&gt;resolve();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If there is a sandbox, it has to allow the storage access API to be called.</span>
<span class="line-removed">-     if (sandboxFlags() != SandboxNone &amp;&amp; isSandboxed(SandboxStorageAccessByUserActivation)) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The iframe has to be a direct child of the top document.</span>
<span class="line-removed">-     if (&amp;topDocument != parentDocument()) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!UserGestureIndicator::processingUserGesture()) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto iframeHost = securityOrigin.host();</span>
<span class="line-removed">-     auto topHost = topSecurityOrigin.host();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Page* page = this-&gt;page();</span>
<span class="line-removed">-     auto frameID = m_frame-&gt;loader().client().frameID();</span>
<span class="line-removed">-     auto pageID = m_frame-&gt;loader().client().pageID();</span>
<span class="line-removed">-     if (!page || !frameID || !pageID) {</span>
<span class="line-removed">-         promise-&gt;reject();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     page-&gt;chrome().client().requestStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool wasGranted) mutable {</span>
<span class="line-removed">-         Document* document = documentReference.get();</span>
<span class="line-removed">-         if (!document)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (wasGranted) {</span>
<span class="line-removed">-             document-&gt;setHasFrameSpecificStorageAccess(true);</span>
<span class="line-removed">-             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = makeWeakPtr(*document)] () {</span>
<span class="line-removed">-                 if (auto* document = documentReference.get())</span>
<span class="line-removed">-                     document-&gt;enableTemporaryTimeUserGesture();</span>
<span class="line-removed">-             }));</span>
<span class="line-removed">-             promise-&gt;resolve();</span>
<span class="line-removed">-             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = WTFMove(documentReference)] () {</span>
<span class="line-removed">-                 if (auto* document = documentReference.get())</span>
<span class="line-removed">-                     document-&gt;consumeTemporaryTimeUserGesture();</span>
<span class="line-removed">-             }));</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             promise-&gt;reject();</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     promise-&gt;reject();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::enableTemporaryTimeUserGesture()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_temporaryUserGesture = std::make_unique&lt;UserGestureIndicator&gt;(ProcessingUserGesture, this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Document::consumeTemporaryTimeUserGesture()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_temporaryUserGesture = nullptr;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Document::registerArticleElement(Element&amp; article)
  {
      m_articleElements.add(&amp;article);
  }
  
<span class="line-new-header">--- 7804,15 ---</span>
      }
  
      return *m_logger;
  }
  
<span class="line-modified">! Optional&lt;PageIdentifier&gt; Document::pageID() const</span>
  {
      return m_frame-&gt;loader().client().pageID();
  }
  
  void Document::registerArticleElement(Element&amp; article)
  {
      m_articleElements.add(&amp;article);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8515,47 ***</span>
  
      m_mainArticleElement = tallestArticle;
  }
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">! bool Document::hasFrameSpecificStorageAccess() const</span>
  {
<span class="line-modified">!     return m_frame &amp;&amp; m_frame-&gt;loader().client().hasFrameSpecificStorageAccess();</span>
  }
  
<span class="line-modified">! void Document::setHasFrameSpecificStorageAccess(bool value)</span>
  {
<span class="line-modified">!     if (m_frame)</span>
<span class="line-removed">-     m_frame-&gt;loader().client().setHasFrameSpecificStorageAccess(value);</span>
  }
  
<span class="line-modified">! bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)</span>
  {
<span class="line-modified">!     return m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction == primaryDomain;</span>
  }
  
<span class="line-modified">! void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)</span>
  {
<span class="line-modified">!     m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction = primaryDomain;</span>
  }
  #endif
  
  void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
  {
      m_consoleMessageListener = listener;
  }
  
<span class="line-removed">- #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">- DocumentAnimationScheduler&amp; Document::animationScheduler()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_animationScheduler)</span>
<span class="line-removed">-         m_animationScheduler = DocumentAnimationScheduler::create(*this, page() ? page()-&gt;chrome().displayID() : 0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return *m_animationScheduler;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  DocumentTimeline&amp; Document::timeline()
  {
      if (!m_timeline)
          m_timeline = DocumentTimeline::create(*this);
  
<span class="line-new-header">--- 7876,57 ---</span>
  
      m_mainArticleElement = tallestArticle;
  }
  
  #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">! bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)</span>
  {
<span class="line-modified">!     return m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction == domain;</span>
  }
  
<span class="line-modified">! void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)</span>
  {
<span class="line-modified">!     m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction = domain;</span>
  }
  
<span class="line-modified">! void Document::wasLoadedWithDataTransferFromPrevalentResource()</span>
  {
<span class="line-modified">!     downgradeReferrerToRegistrableDomain();</span>
  }
  
<span class="line-modified">! void Document::downgradeReferrerToRegistrableDomain()</span>
  {
<span class="line-modified">!     auto referrerStr = referrer();</span>
<span class="line-added">+     if (referrerStr.isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     URL referrerURL { URL(), referrerStr };</span>
<span class="line-added">+     auto referrerPort = referrerURL.port();</span>
<span class="line-added">+     RegistrableDomain referrerRegistrableDomain { referrerURL };</span>
<span class="line-added">+     auto referrerRegistrableDomainStr = referrerRegistrableDomain.string();</span>
<span class="line-added">+     if (referrerRegistrableDomainStr.isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     StringBuilder builder;</span>
<span class="line-added">+     builder.append(referrerURL.protocol());</span>
<span class="line-added">+     builder.appendLiteral(&quot;://&quot;);</span>
<span class="line-added">+     builder.append(referrerRegistrableDomainStr);</span>
<span class="line-added">+     if (referrerPort) {</span>
<span class="line-added">+         builder.append(&#39;:&#39;);</span>
<span class="line-added">+         builder.appendNumber(*referrerPort);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     builder.append(&#39;/&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_referrerOverride = builder.toString();</span>
  }
  #endif
  
  void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
  {
      m_consoleMessageListener = listener;
  }
  
  DocumentTimeline&amp; Document::timeline()
  {
      if (!m_timeline)
          m_timeline = DocumentTimeline::create(*this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8622,45 ***</span>
  
  static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
  {
      static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
      static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
  
      if (equalIgnoringASCIICase(mediaChannel, channel.name))
          return MessageSource::Media;
  
      if (equalIgnoringASCIICase(webrtcChannel, channel.name))
          return MessageSource::WebRTC;
  
      return MessageSource::Other;
  }
  
  static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
  {
      switch (level) {
<span class="line-modified">!     case WTFLogLevelAlways:</span>
          return MessageLevel::Log;
<span class="line-modified">!     case WTFLogLevelError:</span>
          return MessageLevel::Error;
          break;
<span class="line-modified">!     case WTFLogLevelWarning:</span>
          return MessageLevel::Warning;
          break;
<span class="line-modified">!     case WTFLogLevelInfo:</span>
          return MessageLevel::Info;
          break;
<span class="line-modified">!     case WTFLogLevelDebug:</span>
          return MessageLevel::Debug;
          break;
      }
  
      ASSERT_NOT_REACHED();
      return MessageLevel::Log;
  }
  
  void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
  {
      if (!page())
          return;
  
      ASSERT(sessionID().isAlwaysOnLoggingAllowed());
  
<span class="line-new-header">--- 7993,63 ---</span>
  
  static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
  {
      static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
      static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
<span class="line-added">+     static const NeverDestroyed&lt;String&gt; mediaSourceChannel = MAKE_STATIC_STRING_IMPL(&quot;mediasource&quot;);</span>
  
      if (equalIgnoringASCIICase(mediaChannel, channel.name))
          return MessageSource::Media;
  
      if (equalIgnoringASCIICase(webrtcChannel, channel.name))
          return MessageSource::WebRTC;
  
<span class="line-added">+     if (equalIgnoringASCIICase(mediaSourceChannel, channel.name))</span>
<span class="line-added">+         return MessageSource::MediaSource;</span>
<span class="line-added">+ </span>
      return MessageSource::Other;
  }
  
  static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
  {
      switch (level) {
<span class="line-modified">!     case WTFLogLevel::Always:</span>
          return MessageLevel::Log;
<span class="line-modified">!     case WTFLogLevel::Error:</span>
          return MessageLevel::Error;
          break;
<span class="line-modified">!     case WTFLogLevel::Warning:</span>
          return MessageLevel::Warning;
          break;
<span class="line-modified">!     case WTFLogLevel::Info:</span>
          return MessageLevel::Info;
          break;
<span class="line-modified">!     case WTFLogLevel::Debug:</span>
          return MessageLevel::Debug;
          break;
      }
  
      ASSERT_NOT_REACHED();
      return MessageLevel::Log;
  }
  
<span class="line-added">+ static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto values = WTFMove(source);</span>
<span class="line-added">+     for (auto&amp; value : values)</span>
<span class="line-added">+         value.value = crossThreadCopy(WTFMove(value.value));</span>
<span class="line-added">+     return values;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
  {
<span class="line-added">+     if (!isMainThread()) {</span>
<span class="line-added">+         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {</span>
<span class="line-added">+             didLogMessage(channel, level, WTFMove(logMessages));</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      if (!page())
          return;
  
      ASSERT(sessionID().isAlwaysOnLoggingAllowed());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8671,11 ***</span>
      m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
          if (!page())
              return;
  
          auto messageLevel = messageLevelFromWTFLogLevel(level);
<span class="line-modified">!         auto message = std::make_unique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));</span>
  
          addConsoleMessage(WTFMove(message));
      });
  }
  
<span class="line-new-header">--- 8060,11 ---</span>
      m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
          if (!page())
              return;
  
          auto messageLevel = messageLevelFromWTFLogLevel(level);
<span class="line-modified">!         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));</span>
  
          addConsoleMessage(WTFMove(message));
      });
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8706,15 ***</span>
      return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
  }
  
  bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
  {
<span class="line-modified">!     return m_CSSRegisteredPropertySet.add(prop.name, std::make_unique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;</span>
  }
  
  void Document::detachFromFrame()
  {
      observeFrame(nullptr);
  }
  
  void Document::frameWasDisconnectedFromOwner()
  {
<span class="line-new-header">--- 8095,19 ---</span>
      return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
  }
  
  bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
  {
<span class="line-modified">!     return m_CSSRegisteredPropertySet.add(prop.name, makeUnique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;</span>
  }
  
  void Document::detachFromFrame()
  {
<span class="line-added">+     // Assertion to help pinpint rdar://problem/49877867. If this hits, the crash trace should tell us</span>
<span class="line-added">+     // which piece of code is detaching the document from its frame while constructing the CachedFrames.</span>
<span class="line-added">+     RELEASE_ASSERT(m_mayBeDetachedFromFrame);</span>
<span class="line-added">+ </span>
      observeFrame(nullptr);
  }
  
  void Document::frameWasDisconnectedFromOwner()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8764,10 ***</span>
<span class="line-new-header">--- 8157,48 ---</span>
          }
      }
      return resultLayer;
  }
  
<span class="line-added">+ ElementIdentifier Document::identifierForElement(Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(&amp;element.document() == this);</span>
<span class="line-added">+     auto result = m_identifiedElementsMap.ensure(&amp;element, [&amp;] {</span>
<span class="line-added">+         return element.createElementIdentifier();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return result.iterator-&gt;value;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Element* Document::searchForElementByIdentifier(const ElementIdentifier&amp; identifier)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto it = m_identifiedElementsMap.begin(); it != m_identifiedElementsMap.end(); ++it) {</span>
<span class="line-added">+         if (it-&gt;value == identifier)</span>
<span class="line-added">+             return it-&gt;key;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::identifiedElementWasRemovedFromDocument(Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_identifiedElementsMap.remove(&amp;element);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">+ </span>
<span class="line-added">+ DeviceOrientationAndMotionAccessController&amp; Document::deviceOrientationAndMotionAccessController()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (&amp;topDocument() != this)</span>
<span class="line-added">+         return topDocument().deviceOrientationAndMotionAccessController();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_deviceOrientationAndMotionAccessController)</span>
<span class="line-added">+         m_deviceOrientationAndMotionAccessController = makeUnique&lt;DeviceOrientationAndMotionAccessController&gt;(*this);</span>
<span class="line-added">+     return *m_deviceOrientationAndMotionAccessController;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #if ENABLE(CSS_PAINTING_API)
  Worklet&amp; Document::ensurePaintWorklet()
  {
      if (!m_paintWorklet)
          m_paintWorklet = Worklet::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8784,34 ***</span>
      auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
      ASSERT_UNUSED(addResult, addResult);
  }
  #endif
  
<span class="line-modified">! #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">! void Document::updateTouchActionElements(Element&amp; element, const RenderStyle&amp; style)</span>
  {
<span class="line-modified">!     bool changed = false;</span>
  
<span class="line-modified">!     if (style.touchActions() != TouchAction::Auto) {</span>
<span class="line-modified">!         if (!m_touchActionElements)</span>
<span class="line-modified">!             m_touchActionElements = std::make_unique&lt;HashSet&lt;RefPtr&lt;Element&gt;&gt;&gt;();</span>
<span class="line-modified">!         changed |= m_touchActionElements-&gt;add(&amp;element).isNewEntry;</span>
<span class="line-modified">!     } else if (m_touchActionElements)</span>
<span class="line-modified">!         changed |= m_touchActionElements-&gt;remove(&amp;element);</span>
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">-     if (!changed)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     Page* page = this-&gt;page();</span>
<span class="line-modified">!     if (!page)</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     if (FrameView* frameView = view()) {</span>
<span class="line-modified">!         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())</span>
<span class="line-modified">!             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! #endif</span>
  }
  #endif
  
  } // namespace WebCore
<span class="line-new-header">--- 8215,74 ---</span>
      auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
      ASSERT_UNUSED(addResult, addResult);
  }
  #endif
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">! </span>
<span class="line-added">+ ContentChangeObserver&amp; Document::contentChangeObserver()</span>
  {
<span class="line-modified">!     if (!m_contentChangeObserver)</span>
<span class="line-added">+         m_contentChangeObserver = makeUnique&lt;ContentChangeObserver&gt;(*this);</span>
<span class="line-added">+     return *m_contentChangeObserver;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! DOMTimerHoldingTank&amp; Document::domTimerHoldingTank()</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (m_domTimerHoldingTank)</span>
<span class="line-modified">!         return *m_domTimerHoldingTank;</span>
<span class="line-modified">!     m_domTimerHoldingTank = makeUnique&lt;DOMTimerHoldingTank&gt;();</span>
<span class="line-modified">!     return *m_domTimerHoldingTank;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! #endif</span>
  
<span class="line-modified">! bool Document::hasEvaluatedUserAgentScripts() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto&amp; top = topDocument();</span>
<span class="line-added">+     return this == &amp;top ? m_hasEvaluatedUserAgentScripts : top.hasEvaluatedUserAgentScripts();</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! bool Document::isRunningUserScripts() const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto&amp; top = topDocument();</span>
<span class="line-modified">!     return this == &amp;top ? m_isRunningUserScripts : top.isRunningUserScripts();</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setAsRunningUserScripts()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; top = topDocument();</span>
<span class="line-added">+     if (this == &amp;top)</span>
<span class="line-added">+         m_isRunningUserScripts = true;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         top.setAsRunningUserScripts();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setHasEvaluatedUserAgentScripts()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; top = topDocument();</span>
<span class="line-added">+     if (this == &amp;top)</span>
<span class="line-added">+         m_hasEvaluatedUserAgentScripts = true;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         top.setHasEvaluatedUserAgentScripts();</span>
  }
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(APPLE_PAY)</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Document::isApplePayActive() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; top = topDocument();</span>
<span class="line-added">+     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Document::setApplePayIsActive()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; top = topDocument();</span>
<span class="line-added">+     if (this == &amp;top)</span>
<span class="line-added">+         m_hasStartedApplePaySession = true;</span>
<span class="line-added">+     else</span>
<span class="line-added">+         top.setApplePayIsActive();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #endif
  
  } // namespace WebCore
</pre>
<center><a href="DeviceOrientationEvent.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>