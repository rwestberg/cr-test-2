<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeMediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RealtimeIncomingVideoSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RealtimeMediaSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeMediaSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5  * Copyright (C) 2015 Ericsson AB. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  *
  11  * 1. Redistributions of source code must retain the above copyright
  12  *    notice, this list of conditions and the following disclaimer.
  13  * 2. Redistributions in binary form must reproduce the above copyright
  14  *    notice, this list of conditions and the following disclaimer
  15  *    in the documentation and/or other materials provided with the
  16  *    distribution.
  17  * 3. Neither the name of Google Inc. nor the names of its contributors
  18  *    may be used to endorse or promote products derived from this
  19  *    software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</pre>
<hr />
<pre>
  39 #include &quot;Logging.h&quot;
  40 #include &quot;MediaConstraints.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;RealtimeMediaSourceCapabilities.h&quot;
  43 #include &quot;RealtimeMediaSourceCenter.h&quot;
  44 #include &lt;wtf/CompletionHandler.h&gt;
  45 #include &lt;wtf/MainThread.h&gt;
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/StringHash.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 RealtimeMediaSource::RealtimeMediaSource(Type type, String&amp;&amp; name, String&amp;&amp; deviceID, String&amp;&amp; hashSalt)
  52     : m_idHashSalt(WTFMove(hashSalt))
  53     , m_persistentID(WTFMove(deviceID))
  54     , m_type(type)
  55     , m_name(WTFMove(name))
  56 {
  57     if (m_persistentID.isEmpty())
  58         m_persistentID = createCanonicalUUIDString();
<span class="line-modified">  59     else</span>
<span class="line-modified">  60         m_hashedID = RealtimeMediaSourceCenter::singleton().hashStringWithSalt(m_persistentID, m_idHashSalt);</span>
  61 }
  62 
  63 void RealtimeMediaSource::addObserver(RealtimeMediaSource::Observer&amp; observer)
  64 {
  65     auto locker = holdLock(m_observersLock);
  66     m_observers.add(&amp;observer);
  67 }
  68 
  69 void RealtimeMediaSource::removeObserver(RealtimeMediaSource::Observer&amp; observer)
  70 {
  71     auto locker = holdLock(m_observersLock);
<span class="line-removed">  72 </span>
  73     m_observers.remove(&amp;observer);
  74     if (m_observers.isEmpty())
<span class="line-modified">  75         stop();</span>
  76 }
  77 
  78 void RealtimeMediaSource::setInterrupted(bool interrupted, bool pageMuted)
  79 {
  80     if (interrupted == m_interrupted)
  81         return;
  82 


  83     m_interrupted = interrupted;
  84     if (!interrupted &amp;&amp; pageMuted)
  85         return;
  86 
  87     setMuted(interrupted);
  88 }
  89 
  90 void RealtimeMediaSource::setMuted(bool muted)
  91 {


  92     if (muted)
  93         stop();
  94     else {
  95         if (interrupted())
  96             return;
  97 
  98         start();
  99     }
 100 
 101     notifyMutedChange(muted);
 102 }
 103 
 104 void RealtimeMediaSource::notifyMutedChange(bool muted)
 105 {
 106     if (m_muted == muted)
 107         return;
 108 

 109     m_muted = muted;
 110 
 111     notifyMutedObservers();
 112 }
 113 
 114 void RealtimeMediaSource::setInterruptedForTesting(bool interrupted)
 115 {
 116     notifyMutedChange(interrupted);
 117 }
 118 
 119 void RealtimeMediaSource::forEachObserver(const WTF::Function&lt;void(Observer&amp;)&gt;&amp; apply) const
 120 {
 121     Vector&lt;Observer*&gt; observersCopy;
 122     {
 123         auto locker = holdLock(m_observersLock);
 124         observersCopy = copyToVector(m_observers);
 125     }
 126     for (auto* observer : observersCopy) {
 127         auto locker = holdLock(m_observersLock);
 128         // Make sure the observer has not been destroyed.
</pre>
<hr />
<pre>
 132     }
 133 }
 134 
 135 void RealtimeMediaSource::notifyMutedObservers() const
 136 {
 137     forEachObserver([](auto&amp; observer) {
 138         observer.sourceMutedChanged();
 139     });
 140 }
 141 
 142 void RealtimeMediaSource::notifySettingsDidChangeObservers(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; flags)
 143 {
 144     ASSERT(isMainThread());
 145 
 146     settingsDidChange(flags);
 147 
 148     if (m_pendingSettingsDidChangeNotification)
 149         return;
 150     m_pendingSettingsDidChangeNotification = true;
 151 


 152     scheduleDeferredTask([this] {
 153         m_pendingSettingsDidChangeNotification = false;
 154         forEachObserver([](auto&amp; observer) {
 155             observer.sourceSettingsChanged();
 156         });
 157     });
 158 }
 159 
 160 void RealtimeMediaSource::videoSampleAvailable(MediaSample&amp; mediaSample)
 161 {














 162     forEachObserver([&amp;](auto&amp; observer) {
 163         observer.videoSampleAvailable(mediaSample);
 164     });
 165 }
 166 
 167 void RealtimeMediaSource::audioSamplesAvailable(const MediaTime&amp; time, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t numberOfFrames)
 168 {
 169     forEachObserver([&amp;](auto&amp; observer) {
 170         observer.audioSamplesAvailable(time, audioData, description, numberOfFrames);
 171     });
 172 }
 173 
 174 void RealtimeMediaSource::start()
 175 {
 176     if (m_isProducingData || m_isEnded)
 177         return;
 178 


 179     m_isProducingData = true;
 180     startProducingData();
 181 
 182     if (!m_isProducingData)
 183         return;
 184 
 185     forEachObserver([](auto&amp; observer) {
 186         observer.sourceStarted();
 187     });
 188 }
 189 
 190 void RealtimeMediaSource::stop()
 191 {
 192     if (!m_isProducingData)
 193         return;
 194 


 195     m_isProducingData = false;
 196     stopProducingData();
 197 }
 198 
 199 void RealtimeMediaSource::requestToEnd(Observer&amp; callingObserver)
 200 {
 201     if (!m_isProducingData)
 202         return;
 203 
 204     bool hasObserverPreventingStopping = false;
 205     forEachObserver([&amp;](auto&amp; observer) {
 206         if (observer.preventSourceFromStopping())
 207             hasObserverPreventingStopping = true;
 208     });
 209     if (hasObserverPreventingStopping)
 210         return;
 211 
 212     auto protectedThis = makeRef(*this);
 213 
 214     stop();
 215     m_isEnded = true;
 216     hasEnded();
 217 
 218     forEachObserver([callingObserver](auto&amp; observer) {
 219         if (&amp;observer != &amp;callingObserver)
 220             observer.sourceStopped();
 221     });
 222 }
 223 
 224 void RealtimeMediaSource::captureFailed()
 225 {
<span class="line-modified"> 226     RELEASE_LOG_ERROR(MediaStream, &quot;RealtimeMediaSource::captureFailed&quot;);</span>
 227 
 228     m_isProducingData = false;
 229     m_captureDidFailed = true;
 230 
 231     forEachObserver([](auto&amp; observer) {
 232         observer.sourceStopped();
 233     });
 234 }
 235 
 236 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;int&gt;, Optional&lt;int&gt;, Optional&lt;double&gt;)
 237 {
 238     // The size and frame rate are within the capability limits, so they are supported.
 239     return true;
 240 }
 241 
 242 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;IntConstraint&gt; widthConstraint, Optional&lt;IntConstraint&gt; heightConstraint, Optional&lt;DoubleConstraint&gt; frameRateConstraint, String&amp; badConstraint, double&amp; distance)
 243 {
 244     if (!widthConstraint &amp;&amp; !heightConstraint &amp;&amp; !frameRateConstraint)
 245         return true;
 246 
</pre>
<hr />
<pre>
 396         auto&amp; modes = capabilities.facingMode();
 397         Vector&lt;String&gt; supportedModes;
 398         supportedModes.reserveInitialCapacity(modes.size());
 399         for (auto&amp; mode : modes)
 400             supportedModes.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
 401         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(supportedModes);
 402         break;
 403     }
 404 
 405     case MediaConstraintType::EchoCancellation: {
 406         ASSERT(constraint.isBoolean());
 407         if (!capabilities.supportsEchoCancellation())
 408             return 0;
 409 
 410         bool echoCancellationReadWrite = capabilities.echoCancellation() == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite;
 411         return downcast&lt;BooleanConstraint&gt;(constraint).fitnessDistance(echoCancellationReadWrite);
 412         break;
 413     }
 414 
 415     case MediaConstraintType::DeviceId:
<span class="line-modified"> 416         ASSERT_NOT_REACHED();</span>

 417         break;
 418 
 419     case MediaConstraintType::GroupId: {
 420         ASSERT(constraint.isString());
 421         if (!capabilities.supportsDeviceId())
 422             return 0;
 423 
 424         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(settings().groupId());
 425         break;
 426     }
 427 
 428     case MediaConstraintType::DisplaySurface:
 429     case MediaConstraintType::LogicalSurface:
 430         break;
 431 
 432     case MediaConstraintType::Unknown:
 433         // Unknown (or unsupported) constraints should be ignored.
 434         break;
 435     }
 436 
</pre>
<hr />
<pre>
 449 
 450     ValueType value = constraint.valueForCapabilityRange(current, capabilityMin, capabilityMax);
 451     if (value != current)
 452         (source.*applier)(value);
 453 }
 454 
 455 void RealtimeMediaSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; frameRate)
 456 {
 457     IntSize size;
 458     if (width)
 459         size.setWidth(width.value());
 460     if (height)
 461         size.setHeight(height.value());
 462     setSize(size);
 463     if (frameRate)
 464         setFrameRate(frameRate.value());
 465 }
 466 
 467 void RealtimeMediaSource::applyConstraint(const MediaConstraint&amp; constraint)
 468 {


 469     auto&amp; capabilities = this-&gt;capabilities();
 470     switch (constraint.constraintType()) {
 471     case MediaConstraintType::Width:
 472         ASSERT_NOT_REACHED();
 473         break;
 474 
 475     case MediaConstraintType::Height:
 476         ASSERT_NOT_REACHED();
 477         break;
 478 
 479     case MediaConstraintType::FrameRate:
 480         ASSERT_NOT_REACHED();
 481         break;
 482 
 483     case MediaConstraintType::AspectRatio: {
 484         ASSERT(constraint.isDouble());
 485         if (!capabilities.supportsAspectRatio())
 486             return;
 487 
 488         auto range = capabilities.aspectRatio();
</pre>
<hr />
<pre>
 552             setFacingMode(RealtimeMediaSourceSettings::videoFacingModeEnum(modeString));
 553         break;
 554     }
 555 
 556     case MediaConstraintType::DeviceId:
 557     case MediaConstraintType::GroupId:
 558         ASSERT(constraint.isString());
 559         // There is nothing to do here, neither can be changed.
 560         break;
 561 
 562     case MediaConstraintType::DisplaySurface:
 563     case MediaConstraintType::LogicalSurface:
 564         ASSERT(constraint.isBoolean());
 565         break;
 566 
 567     case MediaConstraintType::Unknown:
 568         break;
 569     }
 570 }
 571 
<span class="line-modified"> 572 bool RealtimeMediaSource::selectSettings(const MediaConstraints&amp; constraints, FlattenedConstraint&amp; candidates, String&amp; failedConstraint, SelectType type)</span>
 573 {
<span class="line-modified"> 574     m_fitnessScore = std::numeric_limits&lt;double&gt;::infinity();</span>
 575 
 576     // https://w3c.github.io/mediacapture-main/#dfn-selectsettings
 577     //
 578     // 1. Each constraint specifies one or more values (or a range of values) for its property.
 579     //    A property may appear more than once in the list of &#39;advanced&#39; ConstraintSets. If an
 580     //    empty object or list has been given as the value for a constraint, it must be interpreted
 581     //    as if the constraint were not specified (in other words, an empty constraint == no constraint).
 582     //
 583     //    Note that unknown properties are discarded by WebIDL, which means that unknown/unsupported required
 584     //    constraints will silently disappear. To avoid this being a surprise, application authors are
 585     //    expected to first use the getSupportedConstraints() method as shown in the Examples below.
 586 
 587     // 2. Let object be the ConstrainablePattern object on which this algorithm is applied. Let copy be an
 588     //    unconstrained copy of object (i.e., copy should behave as if it were object with all ConstraintSets
 589     //    removed.)
 590 
 591     // 3. For every possible settings dictionary of copy compute its fitness distance, treating bare values of
 592     //    properties as ideal values. Let candidates be the set of settings dictionaries for which the fitness
 593     //    distance is finite.
 594 
 595     failedConstraint = emptyString();
 596 
 597     // Check width, height and frame rate jointly, because while they may be supported individually the combination may not be supported.
 598     double distance = std::numeric_limits&lt;double&gt;::infinity();
<span class="line-modified"> 599     if (!supportsSizeAndFrameRate(constraints.mandatoryConstraints.width(), constraints.mandatoryConstraints.height(), constraints.mandatoryConstraints.frameRate(), failedConstraint, m_fitnessScore))</span>
 600         return false;
 601 
 602     constraints.mandatoryConstraints.filter([&amp;](const MediaConstraint&amp; constraint) {
 603         if (!supportsConstraint(constraint))
 604             return false;
 605 
 606         if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate) {
 607             candidates.set(constraint);
 608             return false;
 609         }
 610 
<span class="line-removed"> 611         // The deviceId can&#39;t be changed, and the constraint value is the hashed device ID, so verify that the</span>
<span class="line-removed"> 612         // device&#39;s unique ID hashes to the constraint value but don&#39;t include the constraint in the flattened</span>
<span class="line-removed"> 613         // constraint set.</span>
<span class="line-removed"> 614         if (constraint.constraintType() == MediaConstraintType::DeviceId) {</span>
<span class="line-removed"> 615             if (type == SelectType::ForApplyConstraints)</span>
<span class="line-removed"> 616                 return false;</span>
<span class="line-removed"> 617 </span>
<span class="line-removed"> 618             ASSERT(constraint.isString());</span>
<span class="line-removed"> 619             ASSERT(!m_hashedID.isEmpty());</span>
<span class="line-removed"> 620 </span>
<span class="line-removed"> 621             double constraintDistance = downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(m_hashedID);</span>
<span class="line-removed"> 622             if (std::isinf(constraintDistance)) {</span>
<span class="line-removed"> 623                 failedConstraint = constraint.name();</span>
<span class="line-removed"> 624                 return true;</span>
<span class="line-removed"> 625             }</span>
<span class="line-removed"> 626 </span>
<span class="line-removed"> 627             return false;</span>
<span class="line-removed"> 628         }</span>
<span class="line-removed"> 629 </span>
 630         double constraintDistance = fitnessDistance(constraint);
 631         if (std::isinf(constraintDistance)) {
 632             failedConstraint = constraint.name();
 633             return true;
 634         }
 635 
 636         distance = std::min(distance, constraintDistance);
 637         candidates.set(constraint);
 638         return false;
 639     });
 640 
 641     if (!failedConstraint.isEmpty())
 642         return false;
 643 
<span class="line-modified"> 644     m_fitnessScore = distance;</span>
 645 
 646     // 4. If candidates is empty, return undefined as the result of the SelectSettings() algorithm.
 647     if (candidates.isEmpty())
 648         return true;
 649 
 650     // 5. Iterate over the &#39;advanced&#39; ConstraintSets in newConstraints in the order in which they were specified.
 651     //    For each ConstraintSet:
 652 
 653     // 5.1 compute the fitness distance between it and each settings dictionary in candidates, treating bare
 654     //     values of properties as exact.
 655     Vector&lt;std::pair&lt;double, MediaTrackConstraintSetMap&gt;&gt; supportedConstraints;
 656 
 657     for (const auto&amp; advancedConstraint : constraints.advancedConstraints) {
 658         double constraintDistance = 0;
 659         bool supported = false;
 660 
 661         if (advancedConstraint.width() || advancedConstraint.height() || advancedConstraint.frameRate()) {
 662             String dummy;
 663             if (!supportsSizeAndFrameRate(advancedConstraint.width(), advancedConstraint.height(), advancedConstraint.frameRate(), dummy, constraintDistance))
 664                 continue;
 665 
 666             supported = true;
 667         }
 668 
 669         advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 670 
 671             if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate)
 672                 return;
 673 
 674             distance = fitnessDistance(constraint);
 675             constraintDistance += distance;
 676             if (!std::isinf(distance))
 677                 supported = true;
 678         });
 679 
<span class="line-modified"> 680         m_fitnessScore = std::min(m_fitnessScore, constraintDistance);</span>
 681 
 682         // 5.2 If the fitness distance is finite for one or more settings dictionaries in candidates, keep those
 683         //     settings dictionaries in candidates, discarding others.
 684         //     If the fitness distance is infinite for all settings dictionaries in candidates, ignore this ConstraintSet.
 685         if (supported)
 686             supportedConstraints.append({constraintDistance, advancedConstraint});
 687     }
 688 
 689     // 6. Select one settings dictionary from candidates, and return it as the result of the SelectSettings() algorithm.
 690     //    The UA should use the one with the smallest fitness distance, as calculated in step 3.
 691     if (!supportedConstraints.isEmpty()) {
 692         supportedConstraints.removeAllMatching([&amp;](const std::pair&lt;double, MediaTrackConstraintSetMap&gt;&amp; pair) -&gt; bool {
<span class="line-modified"> 693             return std::isinf(pair.first) || pair.first &gt; m_fitnessScore;</span>
 694         });
 695 
 696         if (!supportedConstraints.isEmpty()) {
 697             auto&amp; advancedConstraint = supportedConstraints[0].second;
 698             advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 699                 candidates.merge(constraint);
 700             });
 701 
<span class="line-modified"> 702             m_fitnessScore = std::min(m_fitnessScore, supportedConstraints[0].first);</span>
 703         }
 704     }
 705 
 706     return true;
 707 }
 708 
 709 bool RealtimeMediaSource::supportsConstraint(const MediaConstraint&amp; constraint)
 710 {
 711     auto&amp; capabilities = this-&gt;capabilities();
 712 
 713     switch (constraint.constraintType()) {
 714     case MediaConstraintType::Width:
 715         ASSERT(constraint.isInt());
 716         return capabilities.supportsWidth();
 717         break;
 718 
 719     case MediaConstraintType::Height:
 720         ASSERT(constraint.isInt());
 721         return capabilities.supportsHeight();
 722         break;
</pre>
<hr />
<pre>
 770     case MediaConstraintType::LogicalSurface:
 771         // https://www.w3.org/TR/screen-capture/#new-constraints-for-captured-display-surfaces
 772         // 5.2.1 New Constraints for Captured Display Surfaces
 773         // Since the source of media cannot be changed after a MediaStreamTrack has been returned,
 774         // these constraints cannot be changed by an application.
 775         return false;
 776         break;
 777 
 778     case MediaConstraintType::Unknown:
 779         // Unknown (or unsupported) constraints should be ignored.
 780         break;
 781     }
 782 
 783     return false;
 784 }
 785 
 786 bool RealtimeMediaSource::supportsConstraints(const MediaConstraints&amp; constraints, String&amp; invalidConstraint)
 787 {
 788     ASSERT(constraints.isValid);
 789 


 790     FlattenedConstraint candidates;
<span class="line-modified"> 791     if (!selectSettings(constraints, candidates, invalidConstraint, SelectType::ForSupportsConstraints))</span>
 792         return false;
 793 




























 794     return true;
 795 }
 796 
 797 void RealtimeMediaSource::applyConstraints(const FlattenedConstraint&amp; constraints)
 798 {
 799     if (constraints.isEmpty())
 800         return;
 801 
 802     beginConfiguration();
 803 
 804     auto&amp; capabilities = this-&gt;capabilities();
 805 
 806     Optional&lt;int&gt; width;
 807     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Width)) {
 808         ASSERT(constraint-&gt;isInt());
 809         if (capabilities.supportsWidth()) {
 810             auto range = capabilities.width();
 811             width = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 812         }
 813     }
</pre>
<hr />
<pre>
 830         }
 831     }
 832 
 833     if (width || height || frameRate)
 834         setSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate));
 835 
 836     for (auto&amp; variant : constraints) {
 837         if (variant.constraintType() == MediaConstraintType::Width || variant.constraintType() == MediaConstraintType::Height || variant.constraintType() == MediaConstraintType::FrameRate)
 838             continue;
 839 
 840         applyConstraint(variant);
 841     }
 842 
 843     commitConfiguration();
 844 }
 845 
 846 Optional&lt;RealtimeMediaSource::ApplyConstraintsError&gt; RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints)
 847 {
 848     ASSERT(constraints.isValid);
 849 


 850     FlattenedConstraint candidates;
 851     String failedConstraint;
<span class="line-modified"> 852     if (!selectSettings(constraints, candidates, failedConstraint, SelectType::ForApplyConstraints))</span>
 853         return ApplyConstraintsError { failedConstraint, &quot;Constraint not supported&quot;_s };
 854 
 855     applyConstraints(candidates);
 856     return { };
 857 }
 858 
 859 void RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints, ApplyConstraintsHandler&amp;&amp; completionHandler)
 860 {
 861     completionHandler(applyConstraints(constraints));
 862 }
 863 
 864 void RealtimeMediaSource::setSize(const IntSize&amp; size)
 865 {
 866     if (size == m_size)
 867         return;
 868 


 869     m_size = size;
 870     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 871 }
 872 
 873 const IntSize RealtimeMediaSource::size() const
 874 {
 875     auto size = m_size;
 876 
 877     if (size.isEmpty() &amp;&amp; !m_intrinsicSize.isEmpty()) {
 878         if (size.isZero())
 879             size = m_intrinsicSize;
 880         else if (size.width())
 881             size.setHeight(size.width() * (m_intrinsicSize.height() / static_cast&lt;double&gt;(m_intrinsicSize.width())));
 882         else if (size.height())
 883             size.setWidth(size.height() * (m_intrinsicSize.width() / static_cast&lt;double&gt;(m_intrinsicSize.height())));
 884     }
 885 
 886     return size;
 887 }
 888 
 889 void RealtimeMediaSource::setIntrinsicSize(const IntSize&amp; size)
 890 {
 891     if (m_intrinsicSize == size)
 892         return;
 893 


 894     auto currentSize = this-&gt;size();
 895     m_intrinsicSize = size;
 896 
 897     if (currentSize != this-&gt;size())
 898         notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 899 }
 900 
 901 const IntSize RealtimeMediaSource::intrinsicSize() const
 902 {
 903     return m_intrinsicSize;
 904 }
 905 
 906 void RealtimeMediaSource::setFrameRate(double rate)
 907 {
 908     if (m_frameRate == rate)
 909         return;
 910 


 911     m_frameRate = rate;
 912     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FrameRate);
 913 }
 914 
 915 void RealtimeMediaSource::setAspectRatio(double ratio)
 916 {
 917     if (m_aspectRatio == ratio)
 918         return;
 919 


 920     m_aspectRatio = ratio;
 921     m_size.setHeight(m_size.width() / ratio);
 922     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::AspectRatio, RealtimeMediaSourceSettings::Flag::Height });
 923 }
 924 
 925 void RealtimeMediaSource::setFacingMode(RealtimeMediaSourceSettings::VideoFacingMode mode)
 926 {
 927     if (m_facingMode == mode)
 928         return;
 929 


 930     m_facingMode = mode;
 931     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FacingMode);
 932 }
 933 
 934 void RealtimeMediaSource::setVolume(double volume)
 935 {
 936     if (m_volume == volume)
 937         return;
 938 


 939     m_volume = volume;
 940     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::Volume);
 941 }
 942 
 943 void RealtimeMediaSource::setSampleRate(int rate)
 944 {
 945     if (m_sampleRate == rate)
 946         return;
 947 


 948     m_sampleRate = rate;
 949     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleRate);
 950 }
 951 
 952 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleRates() const
 953 {
 954     return WTF::nullopt;
 955 }
 956 
 957 void RealtimeMediaSource::setSampleSize(int size)
 958 {
 959     if (m_sampleSize == size)
 960         return;
 961 


 962     m_sampleSize = size;
 963     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleSize);
 964 }
 965 
 966 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleSizes() const
 967 {
 968     return WTF::nullopt;
 969 }
 970 
 971 void RealtimeMediaSource::setEchoCancellation(bool echoCancellation)
 972 {
 973     if (m_echoCancellation == echoCancellation)
 974         return;
 975 

 976     m_echoCancellation = echoCancellation;
 977     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::EchoCancellation);
 978 }
 979 
<span class="line-modified"> 980 void RealtimeMediaSource::scheduleDeferredTask(WTF::Function&lt;void()&gt;&amp;&amp; function)</span>
 981 {
 982     ASSERT(function);
<span class="line-modified"> 983     callOnMainThread([weakThis = makeWeakPtr(*this), function = WTFMove(function)] {</span>
<span class="line-removed"> 984         if (!weakThis)</span>
<span class="line-removed"> 985             return;</span>
<span class="line-removed"> 986 </span>
 987         function();
 988     });
 989 }
 990 
 991 const String&amp; RealtimeMediaSource::hashedId() const
 992 {
 993     ASSERT(!m_hashedID.isEmpty());
 994     return m_hashedID;
 995 }
 996 
 997 String RealtimeMediaSource::deviceIDHashSalt() const
 998 {
 999     return m_idHashSalt;
1000 }
1001 
1002 RealtimeMediaSource::Observer::~Observer()
1003 {
1004 }
1005 




























1006 } // namespace WebCore
1007 
1008 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5  * Copyright (C) 2015 Ericsson AB. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  *
  11  * 1. Redistributions of source code must retain the above copyright
  12  *    notice, this list of conditions and the following disclaimer.
  13  * 2. Redistributions in binary form must reproduce the above copyright
  14  *    notice, this list of conditions and the following disclaimer
  15  *    in the documentation and/or other materials provided with the
  16  *    distribution.
  17  * 3. Neither the name of Google Inc. nor the names of its contributors
  18  *    may be used to endorse or promote products derived from this
  19  *    software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
</pre>
<hr />
<pre>
  39 #include &quot;Logging.h&quot;
  40 #include &quot;MediaConstraints.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;RealtimeMediaSourceCapabilities.h&quot;
  43 #include &quot;RealtimeMediaSourceCenter.h&quot;
  44 #include &lt;wtf/CompletionHandler.h&gt;
  45 #include &lt;wtf/MainThread.h&gt;
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/StringHash.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 RealtimeMediaSource::RealtimeMediaSource(Type type, String&amp;&amp; name, String&amp;&amp; deviceID, String&amp;&amp; hashSalt)
  52     : m_idHashSalt(WTFMove(hashSalt))
  53     , m_persistentID(WTFMove(deviceID))
  54     , m_type(type)
  55     , m_name(WTFMove(name))
  56 {
  57     if (m_persistentID.isEmpty())
  58         m_persistentID = createCanonicalUUIDString();
<span class="line-modified">  59 </span>
<span class="line-modified">  60     m_hashedID = RealtimeMediaSourceCenter::singleton().hashStringWithSalt(m_persistentID, m_idHashSalt);</span>
  61 }
  62 
  63 void RealtimeMediaSource::addObserver(RealtimeMediaSource::Observer&amp; observer)
  64 {
  65     auto locker = holdLock(m_observersLock);
  66     m_observers.add(&amp;observer);
  67 }
  68 
  69 void RealtimeMediaSource::removeObserver(RealtimeMediaSource::Observer&amp; observer)
  70 {
  71     auto locker = holdLock(m_observersLock);

  72     m_observers.remove(&amp;observer);
  73     if (m_observers.isEmpty())
<span class="line-modified">  74         stopBeingObserved();</span>
  75 }
  76 
  77 void RealtimeMediaSource::setInterrupted(bool interrupted, bool pageMuted)
  78 {
  79     if (interrupted == m_interrupted)
  80         return;
  81 
<span class="line-added">  82     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, interrupted, &quot;, page muted : &quot;, pageMuted);</span>
<span class="line-added">  83 </span>
  84     m_interrupted = interrupted;
  85     if (!interrupted &amp;&amp; pageMuted)
  86         return;
  87 
  88     setMuted(interrupted);
  89 }
  90 
  91 void RealtimeMediaSource::setMuted(bool muted)
  92 {
<span class="line-added">  93     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);</span>
<span class="line-added">  94 </span>
  95     if (muted)
  96         stop();
  97     else {
  98         if (interrupted())
  99             return;
 100 
 101         start();
 102     }
 103 
 104     notifyMutedChange(muted);
 105 }
 106 
 107 void RealtimeMediaSource::notifyMutedChange(bool muted)
 108 {
 109     if (m_muted == muted)
 110         return;
 111 
<span class="line-added"> 112     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);</span>
 113     m_muted = muted;
 114 
 115     notifyMutedObservers();
 116 }
 117 
 118 void RealtimeMediaSource::setInterruptedForTesting(bool interrupted)
 119 {
 120     notifyMutedChange(interrupted);
 121 }
 122 
 123 void RealtimeMediaSource::forEachObserver(const WTF::Function&lt;void(Observer&amp;)&gt;&amp; apply) const
 124 {
 125     Vector&lt;Observer*&gt; observersCopy;
 126     {
 127         auto locker = holdLock(m_observersLock);
 128         observersCopy = copyToVector(m_observers);
 129     }
 130     for (auto* observer : observersCopy) {
 131         auto locker = holdLock(m_observersLock);
 132         // Make sure the observer has not been destroyed.
</pre>
<hr />
<pre>
 136     }
 137 }
 138 
 139 void RealtimeMediaSource::notifyMutedObservers() const
 140 {
 141     forEachObserver([](auto&amp; observer) {
 142         observer.sourceMutedChanged();
 143     });
 144 }
 145 
 146 void RealtimeMediaSource::notifySettingsDidChangeObservers(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; flags)
 147 {
 148     ASSERT(isMainThread());
 149 
 150     settingsDidChange(flags);
 151 
 152     if (m_pendingSettingsDidChangeNotification)
 153         return;
 154     m_pendingSettingsDidChangeNotification = true;
 155 
<span class="line-added"> 156     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, flags);</span>
<span class="line-added"> 157 </span>
 158     scheduleDeferredTask([this] {
 159         m_pendingSettingsDidChangeNotification = false;
 160         forEachObserver([](auto&amp; observer) {
 161             observer.sourceSettingsChanged();
 162         });
 163     });
 164 }
 165 
 166 void RealtimeMediaSource::videoSampleAvailable(MediaSample&amp; mediaSample)
 167 {
<span class="line-added"> 168 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added"> 169     ++m_frameCount;</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     auto timestamp = MonotonicTime::now();</span>
<span class="line-added"> 172     auto delta = timestamp - m_lastFrameLogTime;</span>
<span class="line-added"> 173     if (!m_lastFrameLogTime || delta &gt;= 1_s) {</span>
<span class="line-added"> 174         if (m_lastFrameLogTime) {</span>
<span class="line-added"> 175             INFO_LOG_IF(loggerPtr(), LOGIDENTIFIER, m_frameCount, &quot; frames sent in &quot;, delta.value(), &quot; seconds&quot;);</span>
<span class="line-added"> 176             m_frameCount = 0;</span>
<span class="line-added"> 177         }</span>
<span class="line-added"> 178         m_lastFrameLogTime = timestamp;</span>
<span class="line-added"> 179     }</span>
<span class="line-added"> 180 #endif</span>
<span class="line-added"> 181 </span>
 182     forEachObserver([&amp;](auto&amp; observer) {
 183         observer.videoSampleAvailable(mediaSample);
 184     });
 185 }
 186 
 187 void RealtimeMediaSource::audioSamplesAvailable(const MediaTime&amp; time, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t numberOfFrames)
 188 {
 189     forEachObserver([&amp;](auto&amp; observer) {
 190         observer.audioSamplesAvailable(time, audioData, description, numberOfFrames);
 191     });
 192 }
 193 
 194 void RealtimeMediaSource::start()
 195 {
 196     if (m_isProducingData || m_isEnded)
 197         return;
 198 
<span class="line-added"> 199     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);</span>
<span class="line-added"> 200 </span>
 201     m_isProducingData = true;
 202     startProducingData();
 203 
 204     if (!m_isProducingData)
 205         return;
 206 
 207     forEachObserver([](auto&amp; observer) {
 208         observer.sourceStarted();
 209     });
 210 }
 211 
 212 void RealtimeMediaSource::stop()
 213 {
 214     if (!m_isProducingData)
 215         return;
 216 
<span class="line-added"> 217     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);</span>
<span class="line-added"> 218 </span>
 219     m_isProducingData = false;
 220     stopProducingData();
 221 }
 222 
 223 void RealtimeMediaSource::requestToEnd(Observer&amp; callingObserver)
 224 {
 225     if (!m_isProducingData)
 226         return;
 227 
 228     bool hasObserverPreventingStopping = false;
 229     forEachObserver([&amp;](auto&amp; observer) {
 230         if (observer.preventSourceFromStopping())
 231             hasObserverPreventingStopping = true;
 232     });
 233     if (hasObserverPreventingStopping)
 234         return;
 235 
 236     auto protectedThis = makeRef(*this);
 237 
 238     stop();
 239     m_isEnded = true;
 240     hasEnded();
 241 
 242     forEachObserver([callingObserver](auto&amp; observer) {
 243         if (&amp;observer != &amp;callingObserver)
 244             observer.sourceStopped();
 245     });
 246 }
 247 
 248 void RealtimeMediaSource::captureFailed()
 249 {
<span class="line-modified"> 250     ERROR_LOG_IF(m_logger, LOGIDENTIFIER);</span>
 251 
 252     m_isProducingData = false;
 253     m_captureDidFailed = true;
 254 
 255     forEachObserver([](auto&amp; observer) {
 256         observer.sourceStopped();
 257     });
 258 }
 259 
 260 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;int&gt;, Optional&lt;int&gt;, Optional&lt;double&gt;)
 261 {
 262     // The size and frame rate are within the capability limits, so they are supported.
 263     return true;
 264 }
 265 
 266 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;IntConstraint&gt; widthConstraint, Optional&lt;IntConstraint&gt; heightConstraint, Optional&lt;DoubleConstraint&gt; frameRateConstraint, String&amp; badConstraint, double&amp; distance)
 267 {
 268     if (!widthConstraint &amp;&amp; !heightConstraint &amp;&amp; !frameRateConstraint)
 269         return true;
 270 
</pre>
<hr />
<pre>
 420         auto&amp; modes = capabilities.facingMode();
 421         Vector&lt;String&gt; supportedModes;
 422         supportedModes.reserveInitialCapacity(modes.size());
 423         for (auto&amp; mode : modes)
 424             supportedModes.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
 425         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(supportedModes);
 426         break;
 427     }
 428 
 429     case MediaConstraintType::EchoCancellation: {
 430         ASSERT(constraint.isBoolean());
 431         if (!capabilities.supportsEchoCancellation())
 432             return 0;
 433 
 434         bool echoCancellationReadWrite = capabilities.echoCancellation() == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite;
 435         return downcast&lt;BooleanConstraint&gt;(constraint).fitnessDistance(echoCancellationReadWrite);
 436         break;
 437     }
 438 
 439     case MediaConstraintType::DeviceId:
<span class="line-modified"> 440         ASSERT(!m_hashedID.isEmpty());</span>
<span class="line-added"> 441         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(m_hashedID);</span>
 442         break;
 443 
 444     case MediaConstraintType::GroupId: {
 445         ASSERT(constraint.isString());
 446         if (!capabilities.supportsDeviceId())
 447             return 0;
 448 
 449         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(settings().groupId());
 450         break;
 451     }
 452 
 453     case MediaConstraintType::DisplaySurface:
 454     case MediaConstraintType::LogicalSurface:
 455         break;
 456 
 457     case MediaConstraintType::Unknown:
 458         // Unknown (or unsupported) constraints should be ignored.
 459         break;
 460     }
 461 
</pre>
<hr />
<pre>
 474 
 475     ValueType value = constraint.valueForCapabilityRange(current, capabilityMin, capabilityMax);
 476     if (value != current)
 477         (source.*applier)(value);
 478 }
 479 
 480 void RealtimeMediaSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; frameRate)
 481 {
 482     IntSize size;
 483     if (width)
 484         size.setWidth(width.value());
 485     if (height)
 486         size.setHeight(height.value());
 487     setSize(size);
 488     if (frameRate)
 489         setFrameRate(frameRate.value());
 490 }
 491 
 492 void RealtimeMediaSource::applyConstraint(const MediaConstraint&amp; constraint)
 493 {
<span class="line-added"> 494     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, constraint.name());</span>
<span class="line-added"> 495 </span>
 496     auto&amp; capabilities = this-&gt;capabilities();
 497     switch (constraint.constraintType()) {
 498     case MediaConstraintType::Width:
 499         ASSERT_NOT_REACHED();
 500         break;
 501 
 502     case MediaConstraintType::Height:
 503         ASSERT_NOT_REACHED();
 504         break;
 505 
 506     case MediaConstraintType::FrameRate:
 507         ASSERT_NOT_REACHED();
 508         break;
 509 
 510     case MediaConstraintType::AspectRatio: {
 511         ASSERT(constraint.isDouble());
 512         if (!capabilities.supportsAspectRatio())
 513             return;
 514 
 515         auto range = capabilities.aspectRatio();
</pre>
<hr />
<pre>
 579             setFacingMode(RealtimeMediaSourceSettings::videoFacingModeEnum(modeString));
 580         break;
 581     }
 582 
 583     case MediaConstraintType::DeviceId:
 584     case MediaConstraintType::GroupId:
 585         ASSERT(constraint.isString());
 586         // There is nothing to do here, neither can be changed.
 587         break;
 588 
 589     case MediaConstraintType::DisplaySurface:
 590     case MediaConstraintType::LogicalSurface:
 591         ASSERT(constraint.isBoolean());
 592         break;
 593 
 594     case MediaConstraintType::Unknown:
 595         break;
 596     }
 597 }
 598 
<span class="line-modified"> 599 bool RealtimeMediaSource::selectSettings(const MediaConstraints&amp; constraints, FlattenedConstraint&amp; candidates, String&amp; failedConstraint)</span>
 600 {
<span class="line-modified"> 601     double minimumDistance = std::numeric_limits&lt;double&gt;::infinity();</span>
 602 
 603     // https://w3c.github.io/mediacapture-main/#dfn-selectsettings
 604     //
 605     // 1. Each constraint specifies one or more values (or a range of values) for its property.
 606     //    A property may appear more than once in the list of &#39;advanced&#39; ConstraintSets. If an
 607     //    empty object or list has been given as the value for a constraint, it must be interpreted
 608     //    as if the constraint were not specified (in other words, an empty constraint == no constraint).
 609     //
 610     //    Note that unknown properties are discarded by WebIDL, which means that unknown/unsupported required
 611     //    constraints will silently disappear. To avoid this being a surprise, application authors are
 612     //    expected to first use the getSupportedConstraints() method as shown in the Examples below.
 613 
 614     // 2. Let object be the ConstrainablePattern object on which this algorithm is applied. Let copy be an
 615     //    unconstrained copy of object (i.e., copy should behave as if it were object with all ConstraintSets
 616     //    removed.)
 617 
 618     // 3. For every possible settings dictionary of copy compute its fitness distance, treating bare values of
 619     //    properties as ideal values. Let candidates be the set of settings dictionaries for which the fitness
 620     //    distance is finite.
 621 
 622     failedConstraint = emptyString();
 623 
 624     // Check width, height and frame rate jointly, because while they may be supported individually the combination may not be supported.
 625     double distance = std::numeric_limits&lt;double&gt;::infinity();
<span class="line-modified"> 626     if (!supportsSizeAndFrameRate(constraints.mandatoryConstraints.width(), constraints.mandatoryConstraints.height(), constraints.mandatoryConstraints.frameRate(), failedConstraint, minimumDistance))</span>
 627         return false;
 628 
 629     constraints.mandatoryConstraints.filter([&amp;](const MediaConstraint&amp; constraint) {
 630         if (!supportsConstraint(constraint))
 631             return false;
 632 
 633         if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate) {
 634             candidates.set(constraint);
 635             return false;
 636         }
 637 



















 638         double constraintDistance = fitnessDistance(constraint);
 639         if (std::isinf(constraintDistance)) {
 640             failedConstraint = constraint.name();
 641             return true;
 642         }
 643 
 644         distance = std::min(distance, constraintDistance);
 645         candidates.set(constraint);
 646         return false;
 647     });
 648 
 649     if (!failedConstraint.isEmpty())
 650         return false;
 651 
<span class="line-modified"> 652     minimumDistance = distance;</span>
 653 
 654     // 4. If candidates is empty, return undefined as the result of the SelectSettings() algorithm.
 655     if (candidates.isEmpty())
 656         return true;
 657 
 658     // 5. Iterate over the &#39;advanced&#39; ConstraintSets in newConstraints in the order in which they were specified.
 659     //    For each ConstraintSet:
 660 
 661     // 5.1 compute the fitness distance between it and each settings dictionary in candidates, treating bare
 662     //     values of properties as exact.
 663     Vector&lt;std::pair&lt;double, MediaTrackConstraintSetMap&gt;&gt; supportedConstraints;
 664 
 665     for (const auto&amp; advancedConstraint : constraints.advancedConstraints) {
 666         double constraintDistance = 0;
 667         bool supported = false;
 668 
 669         if (advancedConstraint.width() || advancedConstraint.height() || advancedConstraint.frameRate()) {
 670             String dummy;
 671             if (!supportsSizeAndFrameRate(advancedConstraint.width(), advancedConstraint.height(), advancedConstraint.frameRate(), dummy, constraintDistance))
 672                 continue;
 673 
 674             supported = true;
 675         }
 676 
 677         advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 678 
 679             if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate)
 680                 return;
 681 
 682             distance = fitnessDistance(constraint);
 683             constraintDistance += distance;
 684             if (!std::isinf(distance))
 685                 supported = true;
 686         });
 687 
<span class="line-modified"> 688         minimumDistance = std::min(minimumDistance, constraintDistance);</span>
 689 
 690         // 5.2 If the fitness distance is finite for one or more settings dictionaries in candidates, keep those
 691         //     settings dictionaries in candidates, discarding others.
 692         //     If the fitness distance is infinite for all settings dictionaries in candidates, ignore this ConstraintSet.
 693         if (supported)
 694             supportedConstraints.append({constraintDistance, advancedConstraint});
 695     }
 696 
 697     // 6. Select one settings dictionary from candidates, and return it as the result of the SelectSettings() algorithm.
 698     //    The UA should use the one with the smallest fitness distance, as calculated in step 3.
 699     if (!supportedConstraints.isEmpty()) {
 700         supportedConstraints.removeAllMatching([&amp;](const std::pair&lt;double, MediaTrackConstraintSetMap&gt;&amp; pair) -&gt; bool {
<span class="line-modified"> 701             return std::isinf(pair.first) || pair.first &gt; minimumDistance;</span>
 702         });
 703 
 704         if (!supportedConstraints.isEmpty()) {
 705             auto&amp; advancedConstraint = supportedConstraints[0].second;
 706             advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 707                 candidates.merge(constraint);
 708             });
 709 
<span class="line-modified"> 710             minimumDistance = std::min(minimumDistance, supportedConstraints[0].first);</span>
 711         }
 712     }
 713 
 714     return true;
 715 }
 716 
 717 bool RealtimeMediaSource::supportsConstraint(const MediaConstraint&amp; constraint)
 718 {
 719     auto&amp; capabilities = this-&gt;capabilities();
 720 
 721     switch (constraint.constraintType()) {
 722     case MediaConstraintType::Width:
 723         ASSERT(constraint.isInt());
 724         return capabilities.supportsWidth();
 725         break;
 726 
 727     case MediaConstraintType::Height:
 728         ASSERT(constraint.isInt());
 729         return capabilities.supportsHeight();
 730         break;
</pre>
<hr />
<pre>
 778     case MediaConstraintType::LogicalSurface:
 779         // https://www.w3.org/TR/screen-capture/#new-constraints-for-captured-display-surfaces
 780         // 5.2.1 New Constraints for Captured Display Surfaces
 781         // Since the source of media cannot be changed after a MediaStreamTrack has been returned,
 782         // these constraints cannot be changed by an application.
 783         return false;
 784         break;
 785 
 786     case MediaConstraintType::Unknown:
 787         // Unknown (or unsupported) constraints should be ignored.
 788         break;
 789     }
 790 
 791     return false;
 792 }
 793 
 794 bool RealtimeMediaSource::supportsConstraints(const MediaConstraints&amp; constraints, String&amp; invalidConstraint)
 795 {
 796     ASSERT(constraints.isValid);
 797 
<span class="line-added"> 798     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);</span>
<span class="line-added"> 799 </span>
 800     FlattenedConstraint candidates;
<span class="line-modified"> 801     if (!selectSettings(constraints, candidates, invalidConstraint))</span>
 802         return false;
 803 
<span class="line-added"> 804     m_fitnessScore = 0;</span>
<span class="line-added"> 805     for (auto&amp; variant : candidates) {</span>
<span class="line-added"> 806         double distance = fitnessDistance(variant);</span>
<span class="line-added"> 807         switch (variant.constraintType()) {</span>
<span class="line-added"> 808         case MediaConstraintType::DeviceId:</span>
<span class="line-added"> 809         case MediaConstraintType::FacingMode:</span>
<span class="line-added"> 810             m_fitnessScore += distance ? 1 : 32;</span>
<span class="line-added"> 811             break;</span>
<span class="line-added"> 812 </span>
<span class="line-added"> 813         case MediaConstraintType::Width:</span>
<span class="line-added"> 814         case MediaConstraintType::Height:</span>
<span class="line-added"> 815         case MediaConstraintType::FrameRate:</span>
<span class="line-added"> 816         case MediaConstraintType::AspectRatio:</span>
<span class="line-added"> 817         case MediaConstraintType::Volume:</span>
<span class="line-added"> 818         case MediaConstraintType::SampleRate:</span>
<span class="line-added"> 819         case MediaConstraintType::SampleSize:</span>
<span class="line-added"> 820         case MediaConstraintType::EchoCancellation:</span>
<span class="line-added"> 821         case MediaConstraintType::GroupId:</span>
<span class="line-added"> 822         case MediaConstraintType::DisplaySurface:</span>
<span class="line-added"> 823         case MediaConstraintType::LogicalSurface:</span>
<span class="line-added"> 824         case MediaConstraintType::Unknown:</span>
<span class="line-added"> 825             m_fitnessScore += distance ? 1 : 2;</span>
<span class="line-added"> 826             break;</span>
<span class="line-added"> 827         }</span>
<span class="line-added"> 828     }</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, &quot;fitness distance : &quot;, m_fitnessScore);</span>
<span class="line-added"> 831 </span>
 832     return true;
 833 }
 834 
 835 void RealtimeMediaSource::applyConstraints(const FlattenedConstraint&amp; constraints)
 836 {
 837     if (constraints.isEmpty())
 838         return;
 839 
 840     beginConfiguration();
 841 
 842     auto&amp; capabilities = this-&gt;capabilities();
 843 
 844     Optional&lt;int&gt; width;
 845     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Width)) {
 846         ASSERT(constraint-&gt;isInt());
 847         if (capabilities.supportsWidth()) {
 848             auto range = capabilities.width();
 849             width = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 850         }
 851     }
</pre>
<hr />
<pre>
 868         }
 869     }
 870 
 871     if (width || height || frameRate)
 872         setSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate));
 873 
 874     for (auto&amp; variant : constraints) {
 875         if (variant.constraintType() == MediaConstraintType::Width || variant.constraintType() == MediaConstraintType::Height || variant.constraintType() == MediaConstraintType::FrameRate)
 876             continue;
 877 
 878         applyConstraint(variant);
 879     }
 880 
 881     commitConfiguration();
 882 }
 883 
 884 Optional&lt;RealtimeMediaSource::ApplyConstraintsError&gt; RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints)
 885 {
 886     ASSERT(constraints.isValid);
 887 
<span class="line-added"> 888     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);</span>
<span class="line-added"> 889 </span>
 890     FlattenedConstraint candidates;
 891     String failedConstraint;
<span class="line-modified"> 892     if (!selectSettings(constraints, candidates, failedConstraint))</span>
 893         return ApplyConstraintsError { failedConstraint, &quot;Constraint not supported&quot;_s };
 894 
 895     applyConstraints(candidates);
 896     return { };
 897 }
 898 
 899 void RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints, ApplyConstraintsHandler&amp;&amp; completionHandler)
 900 {
 901     completionHandler(applyConstraints(constraints));
 902 }
 903 
 904 void RealtimeMediaSource::setSize(const IntSize&amp; size)
 905 {
 906     if (size == m_size)
 907         return;
 908 
<span class="line-added"> 909     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);</span>
<span class="line-added"> 910 </span>
 911     m_size = size;
 912     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 913 }
 914 
 915 const IntSize RealtimeMediaSource::size() const
 916 {
 917     auto size = m_size;
 918 
 919     if (size.isEmpty() &amp;&amp; !m_intrinsicSize.isEmpty()) {
 920         if (size.isZero())
 921             size = m_intrinsicSize;
 922         else if (size.width())
 923             size.setHeight(size.width() * (m_intrinsicSize.height() / static_cast&lt;double&gt;(m_intrinsicSize.width())));
 924         else if (size.height())
 925             size.setWidth(size.height() * (m_intrinsicSize.width() / static_cast&lt;double&gt;(m_intrinsicSize.height())));
 926     }
 927 
 928     return size;
 929 }
 930 
 931 void RealtimeMediaSource::setIntrinsicSize(const IntSize&amp; size)
 932 {
 933     if (m_intrinsicSize == size)
 934         return;
 935 
<span class="line-added"> 936     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);</span>
<span class="line-added"> 937 </span>
 938     auto currentSize = this-&gt;size();
 939     m_intrinsicSize = size;
 940 
 941     if (currentSize != this-&gt;size())
 942         notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 943 }
 944 
 945 const IntSize RealtimeMediaSource::intrinsicSize() const
 946 {
 947     return m_intrinsicSize;
 948 }
 949 
 950 void RealtimeMediaSource::setFrameRate(double rate)
 951 {
 952     if (m_frameRate == rate)
 953         return;
 954 
<span class="line-added"> 955     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);</span>
<span class="line-added"> 956 </span>
 957     m_frameRate = rate;
 958     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FrameRate);
 959 }
 960 
 961 void RealtimeMediaSource::setAspectRatio(double ratio)
 962 {
 963     if (m_aspectRatio == ratio)
 964         return;
 965 
<span class="line-added"> 966     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, ratio);</span>
<span class="line-added"> 967 </span>
 968     m_aspectRatio = ratio;
 969     m_size.setHeight(m_size.width() / ratio);
 970     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::AspectRatio, RealtimeMediaSourceSettings::Flag::Height });
 971 }
 972 
 973 void RealtimeMediaSource::setFacingMode(RealtimeMediaSourceSettings::VideoFacingMode mode)
 974 {
 975     if (m_facingMode == mode)
 976         return;
 977 
<span class="line-added"> 978     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, mode);</span>
<span class="line-added"> 979 </span>
 980     m_facingMode = mode;
 981     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FacingMode);
 982 }
 983 
 984 void RealtimeMediaSource::setVolume(double volume)
 985 {
 986     if (m_volume == volume)
 987         return;
 988 
<span class="line-added"> 989     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, volume);</span>
<span class="line-added"> 990 </span>
 991     m_volume = volume;
 992     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::Volume);
 993 }
 994 
 995 void RealtimeMediaSource::setSampleRate(int rate)
 996 {
 997     if (m_sampleRate == rate)
 998         return;
 999 
<span class="line-added">1000     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);</span>
<span class="line-added">1001 </span>
1002     m_sampleRate = rate;
1003     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleRate);
1004 }
1005 
1006 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleRates() const
1007 {
1008     return WTF::nullopt;
1009 }
1010 
1011 void RealtimeMediaSource::setSampleSize(int size)
1012 {
1013     if (m_sampleSize == size)
1014         return;
1015 
<span class="line-added">1016     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);</span>
<span class="line-added">1017 </span>
1018     m_sampleSize = size;
1019     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleSize);
1020 }
1021 
1022 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleSizes() const
1023 {
1024     return WTF::nullopt;
1025 }
1026 
1027 void RealtimeMediaSource::setEchoCancellation(bool echoCancellation)
1028 {
1029     if (m_echoCancellation == echoCancellation)
1030         return;
1031 
<span class="line-added">1032     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, echoCancellation);</span>
1033     m_echoCancellation = echoCancellation;
1034     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::EchoCancellation);
1035 }
1036 
<span class="line-modified">1037 void RealtimeMediaSource::scheduleDeferredTask(Function&lt;void()&gt;&amp;&amp; function)</span>
1038 {
1039     ASSERT(function);
<span class="line-modified">1040     callOnMainThread([protectedThis = makeRef(*this), function = WTFMove(function)] {</span>



1041         function();
1042     });
1043 }
1044 
1045 const String&amp; RealtimeMediaSource::hashedId() const
1046 {
1047     ASSERT(!m_hashedID.isEmpty());
1048     return m_hashedID;
1049 }
1050 
1051 String RealtimeMediaSource::deviceIDHashSalt() const
1052 {
1053     return m_idHashSalt;
1054 }
1055 
1056 RealtimeMediaSource::Observer::~Observer()
1057 {
1058 }
1059 
<span class="line-added">1060 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">1061 void RealtimeMediaSource::setLogger(const Logger&amp; newLogger, const void* newLogIdentifier)</span>
<span class="line-added">1062 {</span>
<span class="line-added">1063     m_logger = &amp;newLogger;</span>
<span class="line-added">1064     m_logIdentifier = newLogIdentifier;</span>
<span class="line-added">1065     ALWAYS_LOG(LOGIDENTIFIER, m_type, &quot;, &quot;, m_name, &quot;, &quot;, m_hashedID);</span>
<span class="line-added">1066 }</span>
<span class="line-added">1067 </span>
<span class="line-added">1068 WTFLogChannel&amp; RealtimeMediaSource::logChannel() const</span>
<span class="line-added">1069 {</span>
<span class="line-added">1070     return LogWebRTC;</span>
<span class="line-added">1071 }</span>
<span class="line-added">1072 #endif</span>
<span class="line-added">1073 </span>
<span class="line-added">1074 String convertEnumerationToString(RealtimeMediaSource::Type enumerationValue)</span>
<span class="line-added">1075 {</span>
<span class="line-added">1076     static const NeverDestroyed&lt;String&gt; values[] = {</span>
<span class="line-added">1077         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),</span>
<span class="line-added">1078         MAKE_STATIC_STRING_IMPL(&quot;Audio&quot;),</span>
<span class="line-added">1079         MAKE_STATIC_STRING_IMPL(&quot;Video&quot;),</span>
<span class="line-added">1080     };</span>
<span class="line-added">1081     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::None) == 0, &quot;RealtimeMediaSource::Type::None is not 0 as expected&quot;);</span>
<span class="line-added">1082     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Audio) == 1, &quot;RealtimeMediaSource::Type::Audio is not 1 as expected&quot;);</span>
<span class="line-added">1083     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Video) == 2, &quot;RealtimeMediaSource::Type::Video is not 2 as expected&quot;);</span>
<span class="line-added">1084     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));</span>
<span class="line-added">1085     return values[static_cast&lt;size_t&gt;(enumerationValue)];</span>
<span class="line-added">1086 }</span>
<span class="line-added">1087 </span>
1088 } // namespace WebCore
1089 
1090 #endif // ENABLE(MEDIA_STREAM)
</pre>
</td>
</tr>
</table>
<center><a href="RealtimeIncomingVideoSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RealtimeMediaSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>