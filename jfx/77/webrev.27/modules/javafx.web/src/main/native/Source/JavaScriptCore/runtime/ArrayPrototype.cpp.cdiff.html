<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
<span class="line-new-header">--- 1,8 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  
  ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  {
      ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
      prototype-&gt;finishCreation(vm, globalObject);
<span class="line-removed">-     vm.heap.addFinalizer(prototype, destroy);</span>
      return prototype;
  }
  
  // ECMA 15.4.4
  ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
<span class="line-new-header">--- 66,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,75 ***</span>
  
  void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
<span class="line-removed">-     didBecomePrototype();</span>
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;arrayProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPublicName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toLocaleString, arrayProtoFuncToLocaleString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;concat&quot;, arrayPrototypeConcatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;fill&quot;, arrayPrototypeFillCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;join, arrayProtoFuncJoin, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;pop&quot;, arrayProtoFuncPop, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayPopIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;sort&quot;, arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;every&quot;, arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;forEach&quot;, arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;some&quot;, arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;filter&quot;, arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flat&quot;, arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flatMap&quot;, arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduce&quot;, arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduceRight&quot;, arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;map&quot;, arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;find&quot;, arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;findIndex&quot;, arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;copyWithin&quot;, arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  
      JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());
<span class="line-modified">!     const char* unscopableNames[] = {</span>
<span class="line-modified">!         &quot;copyWithin&quot;,</span>
<span class="line-modified">!         &quot;entries&quot;,</span>
<span class="line-modified">!         &quot;fill&quot;,</span>
<span class="line-modified">!         &quot;find&quot;,</span>
<span class="line-modified">!         &quot;findIndex&quot;,</span>
<span class="line-modified">!         &quot;includes&quot;,</span>
<span class="line-modified">!         &quot;keys&quot;,</span>
<span class="line-modified">!         &quot;values&quot;</span>
      };
<span class="line-modified">!     for (const char* unscopableName : unscopableNames)</span>
<span class="line-modified">!         unscopables-&gt;putDirect(vm, Identifier::fromString(&amp;vm, unscopableName), jsBoolean(true));</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
  }
  
<span class="line-removed">- void ArrayPrototype::destroy(JSC::JSCell* cell)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ArrayPrototype* thisObject = static_cast&lt;ArrayPrototype*&gt;(cell);</span>
<span class="line-removed">-     thisObject-&gt;ArrayPrototype::~ArrayPrototype();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // ------------------------------ Array Functions ----------------------------
  
  static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-new-header">--- 79,71 ---</span>
  
  void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;arrayProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPublicName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toLocaleString, arrayProtoFuncToLocaleString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().concatPublicName(), arrayPrototypeConcatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().fillPublicName(), arrayPrototypeFillCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;join, arrayProtoFuncJoin, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;pop&quot;, arrayProtoFuncPop, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayPopIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().sortPublicName(), arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().everyPublicName(), arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().forEachPublicName(), arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().somePublicName(), arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().filterPublicName(), arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  
      JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());
<span class="line-modified">!     unscopables-&gt;convertToDictionary(vm);</span>
<span class="line-modified">!     const Identifier* const unscopableNames[] = {</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().findPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().findIndexPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().flatPublicName(),</span>
<span class="line-modified">!         &amp;vm.propertyNames-&gt;builtinNames().flatMapPublicName(),</span>
<span class="line-added">+         &amp;vm.propertyNames-&gt;builtinNames().includesPublicName(),</span>
<span class="line-added">+         &amp;vm.propertyNames-&gt;builtinNames().keysPublicName(),</span>
<span class="line-added">+         &amp;vm.propertyNames-&gt;builtinNames().valuesPublicName()</span>
      };
<span class="line-modified">!     for (const auto* unscopableName : unscopableNames)</span>
<span class="line-modified">!         unscopables-&gt;putDirect(vm, *unscopableName, jsBoolean(true));</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
  }
  
  // ------------------------------ Array Functions ----------------------------
  
  static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)
  {
      VM&amp; vm = exec-&gt;vm();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,33 ***</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (UNLIKELY(!success))
          throwTypeError(exec, scope, ReadonlyPropertyWriteError);
  }
  
  ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)
  {
      VM&amp; vm = exec-&gt;vm();
      JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
      ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
  
<span class="line-modified">!     if (globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == ClearWatchpoint) {</span>
<span class="line-modified">!         arrayPrototype-&gt;tryInitializeSpeciesWatchpoint(exec);</span>
<span class="line-modified">!         ASSERT(globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() != ClearWatchpoint);</span>
      }
  
      return !thisObject-&gt;hasCustomProperties(vm)
          &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<span class="line-modified">!         &amp;&amp; globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == IsWatched;</span>
  }
  
  enum class SpeciesConstructResult {
      FastPath,
      Exception,
      CreatedObject
  };
  
<span class="line-modified">! static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, unsigned length)</span>
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto exceptionResult = [] () {
<span class="line-new-header">--- 184,38 ---</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (UNLIKELY(!success))
          throwTypeError(exec, scope, ReadonlyPropertyWriteError);
  }
  
<span class="line-added">+ namespace ArrayPrototypeInternal {</span>
<span class="line-added">+ static bool verbose = false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)
  {
      VM&amp; vm = exec-&gt;vm();
      JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
      ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
  
<span class="line-modified">!     if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {</span>
<span class="line-modified">!         dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));</span>
<span class="line-modified">!         globalObject-&gt;tryInstallArraySpeciesWatchpoint(exec);</span>
<span class="line-added">+         ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);</span>
      }
  
      return !thisObject-&gt;hasCustomProperties(vm)
          &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<span class="line-modified">!         &amp;&amp; globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == IsWatched;</span>
  }
  
  enum class SpeciesConstructResult {
      FastPath,
      Exception,
      CreatedObject
  };
  
<span class="line-modified">! static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, uint64_t length)</span>
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto exceptionResult = [] () {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,18 ***</span>
  
          constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);
          RETURN_IF_EXCEPTION(scope, exceptionResult());
          if (constructor.isConstructor(vm)) {
              JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified">!             if (exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm))</span>
<span class="line-modified">!                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>
          }
          if (constructor.isObject()) {
              constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);
              RETURN_IF_EXCEPTION(scope, exceptionResult());
              if (constructor.isNull())
<span class="line-modified">!                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>
          }
      } else {
          // If isArray is false, return ? ArrayCreate(length).
          return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
      }
<span class="line-new-header">--- 236,20 ---</span>
  
          constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);
          RETURN_IF_EXCEPTION(scope, exceptionResult());
          if (constructor.isConstructor(vm)) {
              JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified">!             bool isArrayConstructorFromAnotherRealm = exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm)</span>
<span class="line-modified">!                 &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);</span>
<span class="line-added">+             if (isArrayConstructorFromAnotherRealm)</span>
<span class="line-added">+                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);</span>
          }
          if (constructor.isObject()) {
              constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);
              RETURN_IF_EXCEPTION(scope, exceptionResult());
              if (constructor.isNull())
<span class="line-modified">!                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);</span>
          }
      } else {
          // If isArray is false, return ? ArrayCreate(length).
          return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,10 ***</span>
<span class="line-new-header">--- 263,32 ---</span>
      JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);
      RETURN_IF_EXCEPTION(scope, exceptionResult());
      return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
  }
  
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(ExecState* exec)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     JSObject* object = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-added">+     uint64_t length = static_cast&lt;uint64_t&gt;(exec-&gt;uncheckedArgument(1).asNumber());</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, object, length);</span>
<span class="line-added">+     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));</span>
<span class="line-added">+     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     if (speciesResult.first == SpeciesConstructResult::CreatedObject)</span>
<span class="line-added">+         return JSValue::encode(speciesResult.second);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {</span>
<span class="line-added">+         throwRangeError(exec, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)
  {
      JSValue value = exec-&gt;argument(argument);
      if (value.isUndefined())
          return undefinedValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,17 ***</span>
      case ALL_UNDECIDED_INDEXING_TYPES: {
          if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
              goto generalCase;
          switch (separator.length()) {
          case 0:
<span class="line-modified">!             RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
          case 1: {
              if (length &lt;= 1)
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
              if (separator.is8Bit())
                  RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));
              RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));
          }
          }
      }
      }
  
<span class="line-new-header">--- 531,36 ---</span>
      case ALL_UNDECIDED_INDEXING_TYPES: {
          if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
              goto generalCase;
          switch (separator.length()) {
          case 0:
<span class="line-modified">!             RELEASE_AND_RETURN(scope, jsEmptyString(vm));</span>
          case 1: {
              if (length &lt;= 1)
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, jsEmptyString(vm));</span>
              if (separator.is8Bit())
                  RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));
              RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));
<span class="line-added">+         default:</span>
<span class="line-added">+             JSString* result = jsEmptyString(vm);</span>
<span class="line-added">+             if (length &lt;= 1)</span>
<span class="line-added">+                 return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+             JSString* operand = jsString(vm, separator.toString());</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+             unsigned count = length - 1;</span>
<span class="line-added">+             for (;;) {</span>
<span class="line-added">+                 if (count &amp; 1) {</span>
<span class="line-added">+                     result = jsString(&amp;state, result, operand);</span>
<span class="line-added">+                     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 count &gt;&gt;= 1;</span>
<span class="line-added">+                 if (!count)</span>
<span class="line-added">+                     return result;</span>
<span class="line-added">+                 operand = jsString(&amp;state, operand, operand);</span>
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+             }</span>
          }
          }
      }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,39 ***</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      RELEASE_AND_RETURN(scope, joiner.join(state));
  }
  
  EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
  
      // 1. Let array be the result of calling ToObject on the this value.
      JSObject* thisObject = thisValue.toObject(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.</span>
<span class="line-modified">!     JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
  
<span class="line-modified">!     // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).</span>
<span class="line-modified">!     bool customJoinCase = false;</span>
<span class="line-modified">!     if (!function.isCell())</span>
<span class="line-modified">!         customJoinCase = true;</span>
<span class="line-modified">!     CallData callData;</span>
<span class="line-modified">!     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified">!     if (callType == CallType::None)</span>
<span class="line-modified">!         customJoinCase = true;</span>
  
<span class="line-modified">!     if (UNLIKELY(customJoinCase))</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
  
<span class="line-modified">!     // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.</span>
<span class="line-modified">!     if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>
  
      ASSERT(isJSArray(thisValue));
      JSArray* thisArray = asArray(thisValue);
  
      unsigned length = thisArray-&gt;length();
<span class="line-new-header">--- 574,56 ---</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      RELEASE_AND_RETURN(scope, joiner.join(state));
  }
  
<span class="line-added">+ inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     JSGlobalObject* globalObject = thisObject-&gt;globalObject();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (globalObject-&gt;arrayJoinWatchpointSet().stateOnJSThread() != IsWatched)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Structure* structure = thisObject-&gt;structure(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This is the fast case. Many arrays will be an original array.</span>
<span class="line-added">+     // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,</span>
<span class="line-added">+     // it would be possible that just looking into &quot;join&quot; function will show the same performance.</span>
<span class="line-added">+     return globalObject-&gt;isOriginalArrayStructure(structure);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
  
      // 1. Let array be the result of calling ToObject on the this value.
      JSObject* thisObject = thisValue.toObject(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {</span>
<span class="line-modified">!         // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.</span>
<span class="line-modified">!         JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
  
<span class="line-modified">!         // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).</span>
<span class="line-modified">!         bool customJoinCase = false;</span>
<span class="line-modified">!         if (!function.isCell())</span>
<span class="line-modified">!             customJoinCase = true;</span>
<span class="line-modified">!         CallData callData;</span>
<span class="line-modified">!         CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified">!         if (callType == CallType::None)</span>
<span class="line-modified">!             customJoinCase = true;</span>
  
<span class="line-modified">!         if (UNLIKELY(customJoinCase))</span>
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
  
<span class="line-modified">!         // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.</span>
<span class="line-modified">!         if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)</span>
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>
<span class="line-added">+     }</span>
  
      ASSERT(isJSArray(thisValue));
      JSArray* thisArray = asArray(thisValue);
  
      unsigned length = thisArray-&gt;length();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 637,11 ***</span>
  #endif
      for (unsigned i = 0; i &lt; length; ++i) {
          JSValue element = thisObject-&gt;getIndex(exec, i);
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (element.isUndefinedOrNull())
<span class="line-modified">!             element = jsEmptyString(exec);</span>
          else {
              JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              CallData callData;
              CallType callType = getCallData(vm, conversionFunction, callData);
<span class="line-new-header">--- 697,11 ---</span>
  #endif
      for (unsigned i = 0; i &lt; length; ++i) {
          JSValue element = thisObject-&gt;getIndex(exec, i);
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (element.isUndefinedOrNull())
<span class="line-modified">!             element = jsEmptyString(vm);</span>
          else {
              JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              CallData callData;
              CallType callType = getCallData(vm, conversionFunction, callData);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,38 ***</span>
      VM&amp; vm = exec.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 5. If len is zero, return the empty String.
      if (!length)
<span class="line-modified">!         return jsEmptyString(&amp;exec);</span>
  
      // 6. Let element0 be Get(O, &quot;0&quot;).
      JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
      JSString* r = nullptr;
      if (element0.isUndefinedOrNull())
<span class="line-modified">!         r = jsEmptyString(&amp;exec);</span>
      else
          r = element0.toString(&amp;exec);
      RETURN_IF_EXCEPTION(scope, { });
  
      // 8. Let k be 1.
      // 9. Repeat, while k &lt; len
      // 9.e Increase k by 1..
      for (uint64_t k = 1; k &lt; length; ++k) {
          // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified">!         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(&amp;exec, AtomicString::number(k)));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
          JSString* next = nullptr;
          if (element.isUndefinedOrNull()) {
              if (!separator-&gt;length())
                  continue;
<span class="line-modified">!             next = jsEmptyString(&amp;exec);</span>
          } else
              next = element.toString(&amp;exec);
          RETURN_IF_EXCEPTION(scope, { });
  
          // a. Let S be the String value produced by concatenating R and sep.
<span class="line-new-header">--- 726,38 ---</span>
      VM&amp; vm = exec.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 5. If len is zero, return the empty String.
      if (!length)
<span class="line-modified">!         return jsEmptyString(vm);</span>
  
      // 6. Let element0 be Get(O, &quot;0&quot;).
      JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
      JSString* r = nullptr;
      if (element0.isUndefinedOrNull())
<span class="line-modified">!         r = jsEmptyString(vm);</span>
      else
          r = element0.toString(&amp;exec);
      RETURN_IF_EXCEPTION(scope, { });
  
      // 8. Let k be 1.
      // 9. Repeat, while k &lt; len
      // 9.e Increase k by 1..
      for (uint64_t k = 1; k &lt; length; ++k) {
          // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified">!         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(vm, AtomString::number(k)));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
          JSString* next = nullptr;
          if (element.isUndefinedOrNull()) {
              if (!separator-&gt;length())
                  continue;
<span class="line-modified">!             next = jsEmptyString(vm);</span>
          } else
              next = element.toString(&amp;exec);
          RETURN_IF_EXCEPTION(scope, { });
  
          // a. Let S be the String value produced by concatenating R and sep.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,11 ***</span>
          const LChar comma = &#39;,&#39;;
  
          if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
              uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
              ASSERT(static_cast&lt;double&gt;(length64) == length);
<span class="line-modified">!             JSString* jsSeparator = jsSingleCharacterString(exec, comma);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
              RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
          }
  
<span class="line-new-header">--- 795,11 ---</span>
          const LChar comma = &#39;,&#39;;
  
          if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
              uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
              ASSERT(static_cast&lt;double&gt;(length64) == length);
<span class="line-modified">!             JSString* jsSeparator = jsSingleCharacterString(vm, comma);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
              RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
          // Check for integer overflow; where safe we can do a fast put by index.
          if (length + n &gt;= length)
              thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);
          else {
              PutPropertySlot slot(thisObj);
<span class="line-modified">!             Identifier propertyName = Identifier::fromString(exec, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
              thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-new-header">--- 886,11 ---</span>
          // Check for integer overflow; where safe we can do a fast put by index.
          if (length + n &gt;= length)
              thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);
          else {
              PutPropertySlot slot(thisObj);
<span class="line-modified">!             Identifier propertyName = Identifier::fromString(vm, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
              thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1533,127 ***</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
      JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));
      JSValue startValue = exec-&gt;uncheckedArgument(2);
<span class="line-modified">!     ASSERT(startValue.isAnyInt() &amp;&amp; startValue.asAnyInt() &gt;= 0 &amp;&amp; startValue.asAnyInt() &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified">!     unsigned startIndex = static_cast&lt;unsigned&gt;(startValue.asAnyInt());</span>
      bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (success)
          return JSValue::encode(jsUndefined());
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
      moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- // -------------------- ArrayPrototype.constructor Watchpoint ------------------</span>
<span class="line-removed">- </span>
<span class="line-removed">- namespace ArrayPrototypeInternal {</span>
<span class="line-removed">- static bool verbose = false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ArrayPrototypeAdaptiveInferredPropertyWatchpoint : public AdaptiveInferredPropertyValueWatchpointBase {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     typedef AdaptiveInferredPropertyValueWatchpointBase Base;</span>
<span class="line-removed">-     ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp;, ArrayPrototype*);</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     void handleFire(VM&amp;, const FireDetail&amp;) override;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ArrayPrototype* m_arrayPrototype;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ArrayPrototype::tryInitializeSpeciesWatchpoint(ExecState* exec)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RELEASE_ASSERT(!m_constructorWatchpoint);</span>
<span class="line-removed">-     RELEASE_ASSERT(!m_constructorSpeciesWatchpoint);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">-         dataLog(&quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(this), &quot; with structure: &quot;, pointerDump(this-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()-&gt;structure(vm)), &quot;\n&quot;);</span>
<span class="line-removed">-     // First we need to make sure that the Array.prototype.constructor property points to Array</span>
<span class="line-removed">-     // and that Array[Symbol.species] is the primordial GetterSetter.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We only initialize once so flattening the structures does not have any real cost.</span>
<span class="line-removed">-     Structure* prototypeStructure = this-&gt;structure(vm);</span>
<span class="line-removed">-     if (prototypeStructure-&gt;isDictionary())</span>
<span class="line-removed">-         prototypeStructure = prototypeStructure-&gt;flattenDictionaryStructure(vm, this);</span>
<span class="line-removed">-     RELEASE_ASSERT(!prototypeStructure-&gt;isDictionary());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
<span class="line-removed">-     ArrayConstructor* arrayConstructor = globalObject-&gt;arrayConstructor();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto invalidateWatchpoint = [&amp;] {</span>
<span class="line-removed">-         globalObject-&gt;arraySpeciesWatchpoint().invalidate(vm, StringFireDetail(&quot;Was not able to set up array species watchpoint.&quot;));</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PropertySlot constructorSlot(this, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">-     this-&gt;getOwnPropertySlot(this, exec, vm.propertyNames-&gt;constructor, constructorSlot);</span>
<span class="line-removed">-     scope.assertNoException();</span>
<span class="line-removed">-     if (constructorSlot.slotBase() != this</span>
<span class="line-removed">-         || !constructorSlot.isCacheableValue()</span>
<span class="line-removed">-         || constructorSlot.getValue(exec, vm.propertyNames-&gt;constructor) != arrayConstructor) {</span>
<span class="line-removed">-         invalidateWatchpoint();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Structure* constructorStructure = arrayConstructor-&gt;structure(vm);</span>
<span class="line-removed">-     if (constructorStructure-&gt;isDictionary())</span>
<span class="line-removed">-         constructorStructure = constructorStructure-&gt;flattenDictionaryStructure(vm, arrayConstructor);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PropertySlot speciesSlot(arrayConstructor, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">-     arrayConstructor-&gt;getOwnPropertySlot(arrayConstructor, exec, vm.propertyNames-&gt;speciesSymbol, speciesSlot);</span>
<span class="line-removed">-     scope.assertNoException();</span>
<span class="line-removed">-     if (speciesSlot.slotBase() != arrayConstructor</span>
<span class="line-removed">-         || !speciesSlot.isCacheableGetter()</span>
<span class="line-removed">-         || speciesSlot.getterSetter() != globalObject-&gt;speciesGetterSetter()) {</span>
<span class="line-removed">-         invalidateWatchpoint();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Now we need to setup the watchpoints to make sure these conditions remain valid.</span>
<span class="line-removed">-     prototypeStructure-&gt;startWatchingPropertyForReplacements(vm, constructorSlot.cachedOffset());</span>
<span class="line-removed">-     constructorStructure-&gt;startWatchingPropertyForReplacements(vm, speciesSlot.cachedOffset());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ObjectPropertyCondition constructorCondition = ObjectPropertyCondition::equivalence(vm, this, this, vm.propertyNames-&gt;constructor.impl(), arrayConstructor);</span>
<span class="line-removed">-     ObjectPropertyCondition speciesCondition = ObjectPropertyCondition::equivalence(vm, this, arrayConstructor, vm.propertyNames-&gt;speciesSymbol.impl(), globalObject-&gt;speciesGetterSetter());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!constructorCondition.isWatchable() || !speciesCondition.isWatchable()) {</span>
<span class="line-removed">-         invalidateWatchpoint();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_constructorWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(constructorCondition, this);</span>
<span class="line-removed">-     m_constructorWatchpoint-&gt;install(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_constructorSpeciesWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(speciesCondition, this);</span>
<span class="line-removed">-     m_constructorSpeciesWatchpoint-&gt;install(vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // We only watch this from the DFG, and the DFG makes sure to only start watching if the watchpoint is in the IsWatched state.</span>
<span class="line-removed">-     RELEASE_ASSERT(!globalObject-&gt;arraySpeciesWatchpoint().isBeingWatched());</span>
<span class="line-removed">-     globalObject-&gt;arraySpeciesWatchpoint().touch(vm, &quot;Set up array species watchpoint.&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- ArrayPrototypeAdaptiveInferredPropertyWatchpoint::ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp; key, ArrayPrototype* prototype)</span>
<span class="line-removed">-     : Base(key)</span>
<span class="line-removed">-     , m_arrayPrototype(prototype)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ArrayPrototypeAdaptiveInferredPropertyWatchpoint::handleFire(VM&amp; vm, const FireDetail&amp; detail)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto lazyDetail = createLazyFireDetail(&quot;ArrayPrototype adaption of &quot;, key(), &quot; failed: &quot;, detail);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">-         WTF::dataLog(lazyDetail, &quot;\n&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSGlobalObject* globalObject = m_arrayPrototype-&gt;globalObject(vm);</span>
<span class="line-removed">-     globalObject-&gt;arraySpeciesWatchpoint().fireAll(vm, lazyDetail);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  } // namespace JSC
<span class="line-new-header">--- 1593,18 ---</span>
      VM&amp; vm = exec-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
      JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));
      JSValue startValue = exec-&gt;uncheckedArgument(2);
<span class="line-modified">!     ASSERT(startValue.isUInt32AsAnyInt());</span>
<span class="line-modified">!     unsigned startIndex = startValue.asUInt32AsAnyInt();</span>
      bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (success)
          return JSValue::encode(jsUndefined());
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
      moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());
      return JSValue::encode(jsUndefined());
  }
  
  } // namespace JSC
</pre>
<center><a href="ArrayIteratorPrototype.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>