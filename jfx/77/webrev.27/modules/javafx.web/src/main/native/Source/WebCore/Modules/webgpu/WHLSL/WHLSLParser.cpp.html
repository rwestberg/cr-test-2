<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLParser.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLAddressSpace.h&quot;
  32 #include &quot;WHLSLEntryPointType.h&quot;
  33 #include &quot;WHLSLProgram.h&quot;
  34 #include &lt;wtf/dtoa.h&gt;
  35 #include &lt;wtf/text/StringBuilder.h&gt;
  36 #include &lt;wtf/text/StringConcatenate.h&gt;
  37 
  38 namespace WebCore {
  39 
  40 namespace WHLSL {
  41 
  42 #define PARSE(name, element, ...) \
  43     auto name = parse##element(__VA_ARGS__); \
  44     if (!name) \
  45         return makeUnexpected(name.error()); \
  46 
  47 #define CONSUME_TYPE(name, type) \
  48     auto name = consumeType(Token::Type::type); \
  49     if (!name) \
  50         return makeUnexpected(name.error());
  51 
  52 #define PEEK(name) \
  53     auto name = peek(); \
  54     if (!name) \
  55         return makeUnexpected(name.error());
  56 
  57 #define PEEK_FURTHER(name) \
  58     auto name = peekFurther(); \
  59     if (!name) \
  60         return makeUnexpected(name.error());
  61 
  62 auto Parser::parse(Program&amp; program, StringView stringView, ParsingMode mode, AST::NameSpace nameSpace) -&gt; Expected&lt;void, Error&gt;
  63 {
  64     m_lexer = Lexer(stringView, nameSpace);
  65     m_mode = mode;
  66 
  67     while (!m_lexer.isFullyConsumed()) {
  68         auto token = m_lexer.peek();
  69         switch (token.type) {
  70         case Token::Type::Invalid:
  71             return { };
  72         case Token::Type::Semicolon:
  73             m_lexer.consumeToken();
  74             continue;
  75         case Token::Type::Typedef: {
  76             auto typeDefinition = parseTypeDefinition();
  77             if (!typeDefinition)
  78                 return makeUnexpected(typeDefinition.error());
  79             auto appendResult = program.append(WTFMove(*typeDefinition));
  80             if (!appendResult)
  81                 return makeUnexpected(appendResult.error());
  82             continue;
  83         }
  84         case Token::Type::Struct: {
  85             auto structureDefinition = parseStructureDefinition();
  86             if (!structureDefinition)
  87                 return makeUnexpected(structureDefinition.error());
  88             auto appendResult = program.append(WTFMove(*structureDefinition));
  89             if (!appendResult)
  90                 return makeUnexpected(appendResult.error());
  91             continue;
  92         }
  93         case Token::Type::Enum: {
  94             auto enumerationDefinition = parseEnumerationDefinition();
  95             if (!enumerationDefinition)
  96                 return makeUnexpected(enumerationDefinition.error());
  97             auto appendResult = program.append(WTFMove(*enumerationDefinition));
  98             if (!appendResult)
  99                 return makeUnexpected(appendResult.error());
 100             continue;
 101         }
 102         case Token::Type::Native: {
 103             if (m_mode != ParsingMode::StandardLibrary)
 104                 return fail(makeString(&quot;&#39;native&#39; can&#39;t exist outside of the standard library.&quot;));
 105             auto furtherToken = peekFurther();
 106             if (!furtherToken)
 107                 return { };
 108             if (furtherToken-&gt;type == Token::Type::Typedef) {
 109                 auto nativeTypeDeclaration = parseNativeTypeDeclaration();
 110                 if (!nativeTypeDeclaration)
 111                     return makeUnexpected(nativeTypeDeclaration.error());
 112                 auto appendResult = program.append(WTFMove(*nativeTypeDeclaration));
 113                 if (!appendResult)
 114                     return makeUnexpected(appendResult.error());
 115                 continue;
 116             }
 117             auto nativeFunctionDeclaration = parseNativeFunctionDeclaration();
 118             if (!nativeFunctionDeclaration)
 119                 return makeUnexpected(nativeFunctionDeclaration.error());
 120             auto appendResult = program.append(WTFMove(*nativeFunctionDeclaration));
 121             if (!appendResult)
 122                 return makeUnexpected(appendResult.error());
 123             continue;
 124         }
 125         default: {
 126             auto functionDefinition = parseFunctionDefinition();
 127             if (!functionDefinition)
 128                 return makeUnexpected(functionDefinition.error());
 129             auto appendResult = program.append(WTFMove(*functionDefinition));
 130             if (!appendResult)
 131                 return makeUnexpected(appendResult.error());
 132             continue;
 133         }
 134         }
 135     }
 136 
 137     return { };
 138 }
 139 
 140 auto Parser::fail(const String&amp; message, TryToPeek tryToPeek) -&gt; Unexpected&lt;Error&gt;
 141 {
 142     if (tryToPeek == TryToPeek::Yes) {
 143         if (auto nextToken = peek())
 144             return makeUnexpected(Error(m_lexer.errorString(*nextToken, message)));
 145     }
 146     return makeUnexpected(Error(makeString(&quot;Cannot lex: &quot;, message)));
 147 }
 148 
 149 auto Parser::peek() -&gt; Expected&lt;Token, Error&gt;
 150 {
 151     auto token = m_lexer.peek();
 152     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)
 153         return { token };
 154     return fail(&quot;Cannot consume token&quot;_str, TryToPeek::No);
 155 }
 156 
 157 auto Parser::peekFurther() -&gt; Expected&lt;Token, Error&gt;
 158 {
 159     auto token = m_lexer.peekFurther();
 160     if (token.type != Token::Type::Invalid &amp;&amp; token.type != Token::Type::EndOfFile)
 161         return { token };
 162     return fail(&quot;Cannot consume two tokens&quot;_str, TryToPeek::No);
 163 }
 164 
 165 template &lt;Token::Type t, Token::Type... ts&gt;
 166 struct Types {
 167     static bool includes(Token::Type type)
 168     {
 169         return t == type || Types&lt;ts...&gt;::includes(type);
 170     }
 171 
 172     static void appendNameTo(StringBuilder&amp; builder)
 173     {
 174         builder.append(Token::typeName(t), &quot;, &quot;);
 175         Types&lt;ts...&gt;::appendNameTo(builder);
 176     }
 177 };
 178 template &lt;Token::Type t&gt;
 179 struct Types&lt;t&gt; {
 180     static bool includes(Token::Type type)
 181     {
 182         return t == type;
 183     }
 184 
 185     static void appendNameTo(StringBuilder&amp; builder)
 186     {
 187         builder.append(Token::typeName(t));
 188     }
 189 };
 190 
 191 
 192 bool Parser::peekType(Token::Type type)
 193 {
 194     auto token = m_lexer.peek();
 195     return token.type == type;
 196 }
 197 
 198 template &lt;Token::Type... types&gt;
 199 bool Parser::peekTypes()
 200 {
 201     auto token = m_lexer.peek();
 202     return Types&lt;types...&gt;::includes(token.type);
 203 }
 204 
 205 Optional&lt;Token&gt; Parser::tryType(Token::Type type)
 206 {
 207     auto token = m_lexer.peek();
 208     if (token.type == type)
 209         return { m_lexer.consumeToken() };
 210     return WTF::nullopt;
 211 }
 212 
 213 template &lt;Token::Type... types&gt;
 214 Optional&lt;Token&gt; Parser::tryTypes()
 215 {
 216     auto token = m_lexer.peek();
 217     if (Types&lt;types...&gt;::includes(token.type))
 218         return { m_lexer.consumeToken() };
 219     return WTF::nullopt;
 220 }
 221 
 222 auto Parser::consumeType(Token::Type type) -&gt; Expected&lt;Token, Error&gt;
 223 {
 224     auto token = m_lexer.consumeToken();
 225     if (token.type == type)
 226         return { token };
 227     return fail(makeString(&quot;Unexpected token (expected &quot;, Token::typeName(type), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));
 228 }
 229 
 230 template &lt;Token::Type... types&gt;
 231 auto Parser::consumeTypes() -&gt; Expected&lt;Token, Error&gt;
 232 {
 233     auto buildExpectedString = [&amp;]() -&gt; String {
 234         StringBuilder builder;
 235         builder.append(&quot;[&quot;);
 236         Types&lt;types...&gt;::appendNameTo(builder);
 237         builder.append(&quot;]&quot;);
 238         return builder.toString();
 239     };
 240 
 241     auto token = m_lexer.consumeToken();
 242     if (Types&lt;types...&gt;::includes(token.type))
 243         return { token };
 244     return fail(makeString(&quot;Unexpected token (expected one of &quot;, buildExpectedString(), &quot; got &quot;, Token::typeName(token.type), &quot;)&quot;));
 245 }
 246 
 247 static int digitValue(UChar character)
 248 {
 249     if (character &gt;= &#39;0&#39; &amp;&amp; character &lt;= &#39;9&#39;)
 250         return character - &#39;0&#39;;
 251     if (character &gt;= &#39;a&#39; &amp;&amp; character &lt;= &#39;f&#39;)
 252         return character - &#39;a&#39; + 10;
 253     return character - &#39;A&#39; + 10;
 254 }
 255 
 256 static Expected&lt;int, Error&gt; intLiteralToInt(StringView text)
 257 {
 258     bool negate = false;
 259     if (text.startsWith(&quot;-&quot;_str)) {
 260         negate = true;
 261         text = text.substring(1);
 262     }
 263     int base = 10;
 264     if (text.startsWith(&quot;0x&quot;_str)) {
 265         text = text.substring(2);
 266         base = 16;
 267     }
 268 
 269     unsigned result = 0;
 270     for (auto codePoint : text.codePoints()) {
 271         unsigned digit = digitValue(codePoint);
 272         auto previous = result;
 273         result = result * base + digit;
 274         if (result &lt; previous)
 275             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 276     }
 277     if (negate) {
 278         static_assert(sizeof(int64_t) &gt; sizeof(unsigned) &amp;&amp; sizeof(int64_t) &gt; sizeof(int), &quot;This code would be wrong otherwise&quot;);
 279         int64_t intResult = -static_cast&lt;int64_t&gt;(result);
 280         if (intResult &lt; static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int&gt;::min()))
 281             return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 282         return { static_cast&lt;int&gt;(intResult) };
 283     }
 284     if (result &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()))
 285         return makeUnexpected(Error(makeString(&quot;int literal &quot;, text, &quot; is out of bounds&quot;)));
 286     return { static_cast&lt;int&gt;(result) };
 287 }
 288 
 289 static Expected&lt;unsigned, Error&gt; uintLiteralToUint(StringView text)
 290 {
 291     unsigned base = 10;
 292     if (text.startsWith(&quot;0x&quot;_str)) {
 293         text = text.substring(2);
 294         base = 16;
 295     }
 296     ASSERT(text.endsWith(&quot;u&quot;));
 297     text = text.substring(0, text.length() - 1);
 298     unsigned result = 0;
 299     for (auto codePoint : text.codePoints()) {
 300         unsigned digit = digitValue(codePoint);
 301         auto previous = result;
 302         result = result * base + digit;
 303         if (result &lt; previous)
 304             return makeUnexpected(Error(makeString(&quot;uint literal &quot;, text, &quot; is out of bounds&quot;)));
 305     }
 306     return { result };
 307 }
 308 
 309 static Expected&lt;float, Error&gt; floatLiteralToFloat(StringView text)
 310 {
 311     size_t parsedLength;
 312     auto result = parseDouble(text, parsedLength);
 313     if (parsedLength != text.length())
 314         return makeUnexpected(Error(makeString(&quot;Cannot parse float &quot;, text)));
 315     return static_cast&lt;float&gt;(result);
 316 }
 317 
 318 auto Parser::consumeIntegralLiteral() -&gt; Expected&lt;Variant&lt;int, unsigned&gt;, Error&gt;
 319 {
 320     auto integralLiteralToken = consumeTypes&lt;Token::Type::IntLiteral, Token::Type::UintLiteral&gt;();
 321     if (!integralLiteralToken)
 322         return makeUnexpected(integralLiteralToken.error());
 323 
 324     switch (integralLiteralToken-&gt;type) {
 325     case Token::Type::IntLiteral: {
 326         auto result = intLiteralToInt(integralLiteralToken-&gt;stringView(m_lexer));
 327         if (result)
 328             return {{ *result }};
 329         return makeUnexpected(result.error());
 330     }
 331     default: {
 332         ASSERT(integralLiteralToken-&gt;type == Token::Type::UintLiteral);
 333         auto result = uintLiteralToUint(integralLiteralToken-&gt;stringView(m_lexer));
 334         if (result)
 335             return {{ *result }};
 336         return makeUnexpected(result.error());
 337     }
 338     }
 339 }
 340 
 341 auto Parser::consumeNonNegativeIntegralLiteral() -&gt; Expected&lt;unsigned, Error&gt;
 342 {
 343     auto integralLiteral = consumeIntegralLiteral();
 344     if (!integralLiteral)
 345         return makeUnexpected(integralLiteral.error());
 346     auto result = WTF::visit(WTF::makeVisitor([](int x) -&gt; Optional&lt;unsigned&gt; {
 347         if (x &lt; 0)
 348             return WTF::nullopt;
 349         return x;
 350     }, [](unsigned x) -&gt; Optional&lt;unsigned&gt; {
 351         return x;
 352     }), *integralLiteral);
 353     if (result)
 354         return *result;
 355     return fail(&quot;int literal is negative&quot;_str);
 356 }
 357 
 358 static Expected&lt;unsigned, Error&gt; recognizeSimpleUnsignedInteger(StringView stringView)
 359 {
 360     unsigned result = 0;
 361     if (stringView.length() &lt; 1)
 362         return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is too short&quot;)));
 363     for (auto codePoint : stringView.codePoints()) {
 364         if (codePoint &lt; &#39;0&#39; || codePoint &gt; &#39;9&#39;)
 365             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; isn&#39;t of the form [0-9]+&quot;)));
 366         auto previous = result;
 367         result = result * 10 + (codePoint - &#39;0&#39;);
 368         if (result &lt; previous)
 369             return makeUnexpected(Error(makeString(&quot;Simple unsigned literal &quot;, stringView, &quot; is out of bounds&quot;)));
 370     }
 371     return result;
 372 }
 373 
 374 auto Parser::parseConstantExpression() -&gt; Expected&lt;AST::ConstantExpression, Error&gt;
 375 {
 376     auto type = consumeTypes&lt;
 377         Token::Type::IntLiteral,
 378         Token::Type::UintLiteral,
 379         Token::Type::FloatLiteral,
 380         Token::Type::Null,
 381         Token::Type::True,
 382         Token::Type::False,
 383         Token::Type::Identifier&gt;();
 384     if (!type)
 385         return makeUnexpected(type.error());
 386 
 387     switch (type-&gt;type) {
 388     case Token::Type::IntLiteral: {
 389         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
 390         if (!value)
 391             return makeUnexpected(value.error());
 392         return {{ AST::IntegerLiteral({ *type }, *value) }};
 393     }
 394     case Token::Type::UintLiteral: {
 395         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
 396         if (!value)
 397             return makeUnexpected(value.error());
 398         return {{ AST::UnsignedIntegerLiteral({ *type }, *value) }};
 399     }
 400     case Token::Type::FloatLiteral: {
 401         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
 402         if (!value)
 403             return makeUnexpected(value.error());
 404         return {{ AST::FloatLiteral({ *type }, *value) }};
 405     }
 406     case Token::Type::Null:
 407         return { AST::NullLiteral(WTFMove(*type)) };
 408     case Token::Type::True:
 409         return { AST::BooleanLiteral(WTFMove(*type), true) };
 410     case Token::Type::False:
 411         return { AST::BooleanLiteral(WTFMove(*type), false) };
 412     default: {
 413         ASSERT(type-&gt;type == Token::Type::Identifier);
 414         CONSUME_TYPE(fullStop, FullStop);
 415         CONSUME_TYPE(next, Identifier);
 416         return { AST::EnumerationMemberLiteral({ *type, *next }, type-&gt;stringView(m_lexer).toString(), next-&gt;stringView(m_lexer).toString()) };
 417     }
 418     }
 419 }
 420 
 421 auto Parser::parseTypeArgument() -&gt; Expected&lt;AST::TypeArgument, Error&gt;
 422 {
 423     PEEK(nextToken);
 424     PEEK_FURTHER(furtherToken);
 425     if (nextToken-&gt;type != Token::Type::Identifier || furtherToken-&gt;type == Token::Type::FullStop) {
 426         PARSE(constantExpression, ConstantExpression);
 427         return AST::TypeArgument(WTFMove(*constantExpression));
 428     }
 429     CONSUME_TYPE(result, Identifier);
 430     CodeLocation location(*result);
 431     return AST::TypeArgument(AST::TypeReference::create(location, result-&gt;stringView(m_lexer).toString(), AST::TypeArguments()));
 432 }
 433 
 434 auto Parser::parseTypeArguments() -&gt; Expected&lt;AST::TypeArguments, Error&gt;
 435 {
 436     AST::TypeArguments typeArguments;
 437     auto lessThanSign = tryType(Token::Type::LessThanSign);
 438     if (!lessThanSign)
 439         return typeArguments;
 440 
 441     auto greaterThanSign = tryType(Token::Type::GreaterThanSign);
 442     if (greaterThanSign)
 443         return typeArguments;
 444 
 445     PARSE(typeArgument, TypeArgument);
 446     typeArguments.append(WTFMove(*typeArgument));
 447 
 448     while (true) {
 449         auto greaterThanSign = tryType(Token::Type::GreaterThanSign);
 450         if (greaterThanSign)
 451             break;
 452 
 453         CONSUME_TYPE(comma, Comma);
 454         PARSE(typeArgument, TypeArgument);
 455         typeArguments.append(WTFMove(*typeArgument));
 456     }
 457 
 458     return typeArguments;
 459 }
 460 
 461 auto Parser::parseTypeSuffixAbbreviated() -&gt; Expected&lt;TypeSuffixAbbreviated, Error&gt;
 462 {
 463     auto token = consumeTypes&lt;
 464         Token::Type::Star,
 465         Token::Type::SquareBracketPair,
 466         Token::Type::LeftSquareBracket&gt;();
 467     if (!token)
 468         return makeUnexpected(token.error());
 469     if (token-&gt;type == Token::Type::LeftSquareBracket) {
 470         auto numElements = consumeNonNegativeIntegralLiteral();
 471         if (!numElements)
 472             return makeUnexpected(numElements.error());
 473         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);
 474         return {{ { *token, *rightSquareBracket }, *token, *numElements }};
 475     }
 476     return {{ { *token }, *token, WTF::nullopt }};
 477 }
 478 
 479 auto Parser::parseTypeSuffixNonAbbreviated() -&gt; Expected&lt;TypeSuffixNonAbbreviated, Error&gt;
 480 {
 481     auto token = consumeTypes&lt;
 482         Token::Type::Star,
 483         Token::Type::SquareBracketPair,
 484         Token::Type::LeftSquareBracket&gt;();
 485     if (!token)
 486         return makeUnexpected(token.error());
 487     if (token-&gt;type == Token::Type::LeftSquareBracket) {
 488         auto numElements = consumeNonNegativeIntegralLiteral();
 489         if (!numElements)
 490             return makeUnexpected(numElements.error());
 491         CONSUME_TYPE(rightSquareBracket, RightSquareBracket);
 492         return {{ { *token, *rightSquareBracket }, *token, WTF::nullopt, *numElements }};
 493     }
 494     auto addressSpaceToken = consumeTypes&lt;
 495         Token::Type::Constant,
 496         Token::Type::Device,
 497         Token::Type::Threadgroup,
 498         Token::Type::Thread&gt;();
 499     if (!addressSpaceToken)
 500         return makeUnexpected(addressSpaceToken.error());
 501     AST::AddressSpace addressSpace;
 502     switch (addressSpaceToken-&gt;type) {
 503     case Token::Type::Constant:
 504         addressSpace = AST::AddressSpace::Constant;
 505         break;
 506     case Token::Type::Device:
 507         addressSpace = AST::AddressSpace::Device;
 508         break;
 509     case Token::Type::Threadgroup:
 510         addressSpace = AST::AddressSpace::Threadgroup;
 511         break;
 512     default:
 513         ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);
 514         addressSpace = AST::AddressSpace::Thread;
 515         break;
 516     }
 517     return {{ { *token }, *token, { addressSpace }, WTF::nullopt }};
 518 }
 519 
 520 auto Parser::parseType() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt;
 521 {
 522     auto addressSpaceToken = tryTypes&lt;
 523         Token::Type::Constant,
 524         Token::Type::Device,
 525         Token::Type::Threadgroup,
 526         Token::Type::Thread&gt;();
 527 
 528     CONSUME_TYPE(name, Identifier);
 529     PARSE(typeArguments, TypeArguments);
 530 
 531     if (addressSpaceToken) {
 532         AST::AddressSpace addressSpace;
 533         switch (addressSpaceToken-&gt;type) {
 534         case Token::Type::Constant:
 535             addressSpace = AST::AddressSpace::Constant;
 536             break;
 537         case Token::Type::Device:
 538             addressSpace = AST::AddressSpace::Device;
 539             break;
 540         case Token::Type::Threadgroup:
 541             addressSpace = AST::AddressSpace::Threadgroup;
 542             break;
 543         default:
 544             ASSERT(addressSpaceToken-&gt;type == Token::Type::Thread);
 545             addressSpace = AST::AddressSpace::Thread;
 546             break;
 547         }
 548         auto constructTypeFromSuffixAbbreviated = [&amp;](const TypeSuffixAbbreviated&amp; typeSuffixAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {
 549             CodeLocation location(*addressSpaceToken, typeSuffixAbbreviated.location);
 550             switch (typeSuffixAbbreviated.token.type) {
 551             case Token::Type::Star:
 552                 return { AST::PointerType::create(location, addressSpace, WTFMove(previous)) };
 553             case Token::Type::SquareBracketPair:
 554                 return { AST::ArrayReferenceType::create(location, addressSpace, WTFMove(previous)) };
 555             default:
 556                 ASSERT(typeSuffixAbbreviated.token.type == Token::Type::LeftSquareBracket);
 557                 return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixAbbreviated.numElements) };
 558             }
 559         };
 560         PARSE(firstTypeSuffixAbbreviated, TypeSuffixAbbreviated);
 561         Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(WTFMove(*addressSpaceToken), name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 562         auto next = constructTypeFromSuffixAbbreviated(*firstTypeSuffixAbbreviated, WTFMove(result));
 563         result = WTFMove(next);
 564         while (true) {
 565             PEEK(nextToken);
 566             if (nextToken-&gt;type != Token::Type::Star
 567                 &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair
 568                 &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {
 569                 break;
 570             }
 571             PARSE(typeSuffixAbbreviated, TypeSuffixAbbreviated);
 572             // FIXME: The nesting here might be in the wrong order.
 573             next = constructTypeFromSuffixAbbreviated(*typeSuffixAbbreviated, WTFMove(result));
 574             result = WTFMove(next);
 575         }
 576         return WTFMove(result);
 577     }
 578 
 579     auto constructTypeFromSuffixNonAbbreviated = [&amp;](const TypeSuffixNonAbbreviated&amp; typeSuffixNonAbbreviated, Ref&lt;AST::UnnamedType&gt;&amp;&amp; previous) -&gt; Ref&lt;AST::UnnamedType&gt; {
 580         CodeLocation location(*name, typeSuffixNonAbbreviated.location);
 581         switch (typeSuffixNonAbbreviated.token.type) {
 582         case Token::Type::Star:
 583             return { AST::PointerType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 584         case Token::Type::SquareBracketPair:
 585             return { AST::ArrayReferenceType::create(location, *typeSuffixNonAbbreviated.addressSpace, WTFMove(previous)) };
 586         default:
 587             ASSERT(typeSuffixNonAbbreviated.token.type == Token::Type::LeftSquareBracket);
 588             return { AST::ArrayType::create(location, WTFMove(previous), *typeSuffixNonAbbreviated.numElements) };
 589         }
 590     };
 591     Ref&lt;AST::UnnamedType&gt; result = AST::TypeReference::create(*name, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 592     while (true) {
 593         PEEK(nextToken);
 594         if (nextToken-&gt;type != Token::Type::Star
 595             &amp;&amp; nextToken-&gt;type != Token::Type::SquareBracketPair
 596             &amp;&amp; nextToken-&gt;type != Token::Type::LeftSquareBracket) {
 597             break;
 598         }
 599         PARSE(typeSuffixNonAbbreviated, TypeSuffixNonAbbreviated);
 600         // FIXME: The nesting here might be in the wrong order.
 601         auto next = constructTypeFromSuffixNonAbbreviated(*typeSuffixNonAbbreviated, WTFMove(result));
 602         result = WTFMove(next);
 603     }
 604     return WTFMove(result);
 605 }
 606 
 607 auto Parser::parseTypeDefinition() -&gt; Expected&lt;AST::TypeDefinition, Error&gt;
 608 {
 609     CONSUME_TYPE(origin, Typedef);
 610     CONSUME_TYPE(name, Identifier);
 611     CONSUME_TYPE(equals, EqualsSign);
 612     PARSE(type, Type);
 613     CONSUME_TYPE(semicolon, Semicolon);
 614     return AST::TypeDefinition({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));
 615 }
 616 
 617 auto Parser::parseBuiltInSemantic() -&gt; Expected&lt;AST::BuiltInSemantic, Error&gt;
 618 {
 619     auto origin = consumeTypes&lt;
 620         Token::Type::SVInstanceID,
 621         Token::Type::SVVertexID,
 622         Token::Type::PSize,
 623         Token::Type::SVPosition,
 624         Token::Type::SVIsFrontFace,
 625         Token::Type::SVSampleIndex,
 626         Token::Type::SVInnerCoverage,
 627         Token::Type::SVTarget,
 628         Token::Type::SVDepth,
 629         Token::Type::SVCoverage,
 630         Token::Type::SVDispatchThreadID,
 631         Token::Type::SVGroupID,
 632         Token::Type::SVGroupIndex,
 633         Token::Type::SVGroupThreadID&gt;();
 634     if (!origin)
 635         return makeUnexpected(origin.error());
 636 
 637     switch (origin-&gt;type) {
 638     case Token::Type::SVInstanceID:
 639         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInstanceID);
 640     case Token::Type::SVVertexID:
 641         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVVertexID);
 642     case Token::Type::PSize:
 643         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::PSize);
 644     case Token::Type::SVPosition:
 645         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVPosition);
 646     case Token::Type::SVIsFrontFace:
 647         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVIsFrontFace);
 648     case Token::Type::SVSampleIndex:
 649         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVSampleIndex);
 650     case Token::Type::SVInnerCoverage:
 651         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVInnerCoverage);
 652     case Token::Type::SVTarget: {
 653         auto target = consumeNonNegativeIntegralLiteral(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195807 Make this work with strings like &quot;SV_Target0&quot;.
 654         if (!target)
 655             return makeUnexpected(target.error());
 656         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVTarget, *target);
 657     }
 658     case Token::Type::SVDepth:
 659         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDepth);
 660     case Token::Type::SVCoverage:
 661         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVCoverage);
 662     case Token::Type::SVDispatchThreadID:
 663         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVDispatchThreadID);
 664     case Token::Type::SVGroupID:
 665         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupID);
 666     case Token::Type::SVGroupIndex:
 667         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupIndex);
 668     default:
 669         ASSERT(origin-&gt;type == Token::Type::SVGroupThreadID);
 670         return AST::BuiltInSemantic({ *origin }, AST::BuiltInSemantic::Variable::SVGroupThreadID);
 671     }
 672 }
 673 
 674 auto Parser::parseResourceSemantic() -&gt; Expected&lt;AST::ResourceSemantic, Error&gt;
 675 {
 676     CONSUME_TYPE(origin, Register);
 677     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 678 
 679     CONSUME_TYPE(info, Identifier);
 680     auto infoStringView = info-&gt;stringView(m_lexer);
 681     if (infoStringView.length() &lt; 2 || (infoStringView[0] != &#39;u&#39;
 682         &amp;&amp; infoStringView[0] != &#39;t&#39;
 683         &amp;&amp; infoStringView[0] != &#39;b&#39;
 684         &amp;&amp; infoStringView[0] != &#39;s&#39;))
 685         return makeUnexpected(Error(makeString(infoStringView.substring(0, 1), &quot; is not a known resource type (&#39;u&#39;, &#39;t&#39;, &#39;b&#39;, or &#39;s&#39;)&quot;)));
 686 
 687     AST::ResourceSemantic::Mode mode;
 688     switch (infoStringView[0]) {
 689     case &#39;u&#39;:
 690         mode = AST::ResourceSemantic::Mode::UnorderedAccessView;
 691         break;
 692     case &#39;t&#39;:
 693         mode = AST::ResourceSemantic::Mode::Texture;
 694         break;
 695     case &#39;b&#39;:
 696         mode = AST::ResourceSemantic::Mode::Buffer;
 697         break;
 698     case &#39;s&#39;:
 699         mode = AST::ResourceSemantic::Mode::Sampler;
 700         break;
 701     }
 702 
 703     auto index = recognizeSimpleUnsignedInteger(infoStringView.substring(1));
 704     if (!index)
 705         return makeUnexpected(index.error());
 706 
 707     unsigned space = 0;
 708     if (tryType(Token::Type::Comma)) {
 709         CONSUME_TYPE(spaceToken, Identifier);
 710         auto spaceTokenStringView = spaceToken-&gt;stringView(m_lexer);
 711         StringView prefix { &quot;space&quot; };
 712         if (!spaceTokenStringView.startsWith(prefix))
 713             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 714         if (spaceTokenStringView.length() &lt;= prefix.length())
 715             return makeUnexpected(Error(makeString(&quot;Second argument to resource semantic &quot;, spaceTokenStringView, &quot; needs be of the form &#39;space0&#39;&quot;)));
 716         auto spaceValue = recognizeSimpleUnsignedInteger(spaceTokenStringView.substring(prefix.length()));
 717         if (!spaceValue)
 718             return makeUnexpected(spaceValue.error());
 719         space = *spaceValue;
 720     }
 721 
 722     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 723 
 724     return AST::ResourceSemantic({ *origin, *rightParenthesis }, mode, *index, space);
 725 }
 726 
 727 auto Parser::parseSpecializationConstantSemantic() -&gt; Expected&lt;AST::SpecializationConstantSemantic, Error&gt;
 728 {
 729     CONSUME_TYPE(origin, Specialized);
 730     return AST::SpecializationConstantSemantic(*origin);
 731 }
 732 
 733 auto Parser::parseStageInOutSemantic() -&gt; Expected&lt;AST::StageInOutSemantic, Error&gt;
 734 {
 735     CONSUME_TYPE(origin, Attribute);
 736     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 737 
 738     auto index = consumeNonNegativeIntegralLiteral();
 739     if (!index)
 740         return makeUnexpected(index.error());
 741 
 742     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 743 
 744     return AST::StageInOutSemantic({ *origin, *rightParenthesis }, *index);
 745 }
 746 
 747 auto Parser::parseSemantic() -&gt; Expected&lt;std::unique_ptr&lt;AST::Semantic&gt;, Error&gt;
 748 {
 749     if (!tryType(Token::Type::Colon))
 750         return { nullptr };
 751 
 752     PEEK(token);
 753     switch (token-&gt;type) {
 754     case Token::Type::Attribute: {
 755         PARSE(result, StageInOutSemantic);
 756         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 757     }
 758     case Token::Type::Specialized:  {
 759         PARSE(result, SpecializationConstantSemantic);
 760         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 761     }
 762     case Token::Type::Register:  {
 763         PARSE(result, ResourceSemantic);
 764         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 765     }
 766     default:  {
 767         PARSE(result, BuiltInSemantic);
 768         return { makeUnique&lt;AST::Semantic&gt;(WTFMove(*result)) };
 769     }
 770     }
 771 }
 772 AST::Qualifiers Parser::parseQualifiers()
 773 {
 774     AST::Qualifiers qualifiers;
 775     while (auto next = tryType(Token::Type::Qualifier)) {
 776         auto nextStringView = next-&gt;stringView(m_lexer);
 777         if (&quot;nointerpolation&quot; == nextStringView)
 778             qualifiers.append(AST::Qualifier::Nointerpolation);
 779         else if (&quot;noperspective&quot; == nextStringView)
 780             qualifiers.append(AST::Qualifier::Noperspective);
 781         else if (&quot;uniform&quot; == nextStringView)
 782             qualifiers.append(AST::Qualifier::Uniform);
 783         else if (&quot;centroid&quot; == nextStringView)
 784             qualifiers.append(AST::Qualifier::Centroid);
 785         else {
 786             ASSERT(&quot;sample&quot; == nextStringView);
 787             qualifiers.append(AST::Qualifier::Sample);
 788         }
 789     }
 790     return qualifiers;
 791 }
 792 
 793 auto Parser::parseStructureElement() -&gt; Expected&lt;AST::StructureElement, Error&gt;
 794 {
 795     PEEK(origin);
 796 
 797     AST::Qualifiers qualifiers = parseQualifiers();
 798 
 799     PARSE(type, Type);
 800     CONSUME_TYPE(name, Identifier);
 801     PARSE(semantic, Semantic);
 802     CONSUME_TYPE(semicolon, Semicolon);
 803 
 804     return AST::StructureElement({ *origin, *semicolon }, WTFMove(qualifiers), WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic));
 805 }
 806 
 807 auto Parser::parseStructureDefinition() -&gt; Expected&lt;AST::StructureDefinition, Error&gt;
 808 {
 809     CONSUME_TYPE(origin, Struct);
 810     CONSUME_TYPE(name, Identifier);
 811     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
 812 
 813     AST::StructureElements structureElements;
 814     while (!peekType(Token::Type::RightCurlyBracket)) {
 815         PARSE(structureElement, StructureElement);
 816         structureElements.append(WTFMove(*structureElement));
 817     }
 818 
 819     auto rightCurlyBracket = m_lexer.consumeToken();
 820 
 821     return AST::StructureDefinition({ *origin, rightCurlyBracket }, name-&gt;stringView(m_lexer).toString(), WTFMove(structureElements));
 822 }
 823 
 824 auto Parser::parseEnumerationDefinition() -&gt; Expected&lt;AST::EnumerationDefinition, Error&gt;
 825 {
 826     CONSUME_TYPE(origin, Enum);
 827     CONSUME_TYPE(name, Identifier);
 828 
 829     auto type = ([&amp;]() -&gt; Expected&lt;Ref&lt;AST::UnnamedType&gt;, Error&gt; {
 830         if (tryType(Token::Type::Colon)) {
 831             PARSE(parsedType, Type);
 832             return WTFMove(*parsedType);
 833         }
 834         return { AST::TypeReference::create(*origin, &quot;int&quot;_str, AST::TypeArguments()) };
 835     })();
 836     if (!type)
 837         return makeUnexpected(type.error());
 838 
 839     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
 840 
 841     int64_t nextValue = 0;
 842     PARSE(firstEnumerationMember, EnumerationMember, nextValue);
 843     nextValue = firstEnumerationMember-&gt;value() + 1;
 844 
 845     AST::EnumerationDefinition result({ }, name-&gt;stringView(m_lexer).toString(), WTFMove(*type));
 846     auto success = result.add(WTFMove(*firstEnumerationMember));
 847     if (!success)
 848         return fail(&quot;Cannot add enumeration member&quot;_str);
 849 
 850     while (tryType(Token::Type::Comma)) {
 851         PARSE(member, EnumerationMember, nextValue);
 852         nextValue = member-&gt;value() + 1;
 853         success = result.add(WTFMove(*member));
 854         if (!success)
 855             return fail(&quot;Cannot add enumeration member&quot;_str);
 856     }
 857 
 858     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
 859     result.updateCodeLocation({ *origin, *rightCurlyBracket});
 860 
 861     return WTFMove(result);
 862 }
 863 
 864 auto Parser::parseEnumerationMember(int64_t defaultValue) -&gt; Expected&lt;AST::EnumerationMember, Error&gt;
 865 {
 866     CONSUME_TYPE(identifier, Identifier);
 867     auto name = identifier-&gt;stringView(m_lexer).toString();
 868 
 869     if (tryType(Token::Type::EqualsSign)) {
 870         PARSE(constantExpression, ConstantExpression);
 871 
 872         Optional&lt;int64_t&gt; value;
 873         constantExpression-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
 874             value = integerLiteral.value();
 875         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
 876             value = unsignedIntegerLiteral.value();
 877         }, [&amp;](AST::FloatLiteral&amp;) {
 878         }, [&amp;](AST::NullLiteral&amp;) {
 879         }, [&amp;](AST::BooleanLiteral&amp;) {
 880         }, [&amp;](AST::EnumerationMemberLiteral&amp;) {
 881         }));
 882 
 883         if (!value)
 884             return makeUnexpected(Error(&quot;enum initialization values can only be an int or uint constant.&quot;));
 885         return AST::EnumerationMember(*identifier, WTFMove(name), *value);
 886     }
 887     return AST::EnumerationMember(*identifier, WTFMove(name), defaultValue);
 888 }
 889 
 890 auto Parser::parseNativeTypeDeclaration() -&gt; Expected&lt;AST::NativeTypeDeclaration, Error&gt;
 891 {
 892     CONSUME_TYPE(origin, Native);
 893     CONSUME_TYPE(parsedTypedef, Typedef);
 894     CONSUME_TYPE(name, Identifier);
 895     PARSE(typeArguments, TypeArguments);
 896     CONSUME_TYPE(semicolon, Semicolon);
 897 
 898     return AST::NativeTypeDeclaration({ *origin, *semicolon }, name-&gt;stringView(m_lexer).toString(), WTFMove(*typeArguments));
 899 }
 900 
 901 auto Parser::parseNumThreadsFunctionAttribute() -&gt; Expected&lt;AST::NumThreadsFunctionAttribute, Error&gt;
 902 {
 903     CONSUME_TYPE(origin, NumThreads);
 904     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 905 
 906     auto width = consumeNonNegativeIntegralLiteral();
 907     if (!width)
 908         return makeUnexpected(width.error());
 909 
 910     CONSUME_TYPE(comma, Comma);
 911 
 912     auto height = consumeNonNegativeIntegralLiteral();
 913     if (!height)
 914         return makeUnexpected(height.error());
 915 
 916     CONSUME_TYPE(secondComma, Comma);
 917 
 918     auto depth = consumeNonNegativeIntegralLiteral();
 919     if (!depth)
 920         return makeUnexpected(depth.error());
 921 
 922     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 923 
 924     return AST::NumThreadsFunctionAttribute({ *origin, *rightParenthesis }, *width, *height, *depth);
 925 }
 926 
 927 auto Parser::parseAttributeBlock() -&gt; Expected&lt;AST::AttributeBlock, Error&gt;
 928 {
 929     CONSUME_TYPE(leftSquareBracket, LeftSquareBracket);
 930 
 931     AST::AttributeBlock result;
 932 
 933     while (!tryType(Token::Type::RightSquareBracket)) {
 934         PARSE(numThreadsFunctionAttribute, NumThreadsFunctionAttribute);
 935         result.append(WTFMove(*numThreadsFunctionAttribute));
 936     }
 937 
 938     return WTFMove(result);
 939 }
 940 
 941 auto Parser::parseParameter() -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
 942 {
 943     auto startOffset = m_lexer.peek().startOffset();
 944 
 945     AST::Qualifiers qualifiers = parseQualifiers();
 946     PARSE(type, Type);
 947 
 948     String name;
 949     if (auto token = tryType(Token::Type::Identifier))
 950         name = token-&gt;stringView(m_lexer).toString();
 951 
 952     PARSE(semantic, Semantic);
 953 
 954     auto endOffset = m_lexer.peek().startOffset();
 955 
 956     return AST::VariableDeclaration({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(*type) }, WTFMove(name), WTFMove(*semantic), nullptr);
 957 }
 958 
 959 auto Parser::parseParameters() -&gt; Expected&lt;AST::VariableDeclarations, Error&gt;
 960 {
 961     AST::VariableDeclarations parameters;
 962 
 963     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
 964 
 965     if (tryType(Token::Type::RightParenthesis))
 966         return WTFMove(parameters);
 967 
 968     PARSE(firstParameter, Parameter);
 969     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstParameter)));
 970 
 971     while (tryType(Token::Type::Comma)) {
 972         PARSE(parameter, Parameter);
 973         parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*parameter)));
 974     }
 975 
 976     CONSUME_TYPE(rightParenthesis, RightParenthesis);
 977 
 978     return WTFMove(parameters);
 979 }
 980 
 981 auto Parser::parseFunctionDefinition() -&gt; Expected&lt;AST::FunctionDefinition, Error&gt;
 982 {
 983     PARSE(functionDeclaration, FunctionDeclaration);
 984     PARSE(block, Block);
 985     return AST::FunctionDefinition(WTFMove(*functionDeclaration), WTFMove(*block));
 986 }
 987 
 988 auto Parser::parseComputeFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
 989 {
 990     PEEK(origin);
 991 
 992     PARSE(attributeBlock, AttributeBlock);
 993     CONSUME_TYPE(compute, Compute);
 994     PARSE(type, Type);
 995     CONSUME_TYPE(name, Identifier);
 996     PARSE(parameters, Parameters);
 997     PARSE(semantic, Semantic);
 998 
 999     auto endOffset = m_lexer.peek().startOffset();
1000 
1001     bool isOperator = false;
1002     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(*attributeBlock), AST::EntryPointType::Compute, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1003 }
1004 
1005 auto Parser::parseVertexOrFragmentFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1006 {
1007     auto entryPoint = consumeTypes&lt;Token::Type::Vertex, Token::Type::Fragment&gt;();
1008     if (!entryPoint)
1009         return makeUnexpected(entryPoint.error());
1010     auto entryPointType = (entryPoint-&gt;type == Token::Type::Vertex) ? AST::EntryPointType::Vertex : AST::EntryPointType::Fragment;
1011 
1012     PARSE(type, Type);
1013     CONSUME_TYPE(name, Identifier);
1014     PARSE(parameters, Parameters);
1015     PARSE(semantic, Semantic);
1016 
1017     auto endOffset = m_lexer.peek().startOffset();
1018 
1019     bool isOperator = false;
1020     return AST::FunctionDeclaration({ entryPoint-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, entryPointType, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1021 }
1022 
1023 auto Parser::parseRegularFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1024 {
1025     PEEK(origin);
1026 
1027     PARSE(type, Type);
1028 
1029     auto name = consumeTypes&lt;Token::Type::Identifier, Token::Type::OperatorName&gt;();
1030     if (!name)
1031         return makeUnexpected(name.error());
1032     auto isOperator = name-&gt;type == Token::Type::OperatorName;
1033 
1034     PARSE(parameters, Parameters);
1035     PARSE(semantic, Semantic);
1036 
1037     auto endOffset = m_lexer.peek().startOffset();
1038 
1039     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), name-&gt;stringView(m_lexer).toString(), WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1040 }
1041 
1042 auto Parser::parseOperatorFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1043 {
1044     CONSUME_TYPE(origin, Operator);
1045     PARSE(type, Type);
1046     PARSE(parameters, Parameters);
1047     PARSE(semantic, Semantic);
1048 
1049     auto endOffset = m_lexer.peek().startOffset();
1050 
1051     bool isOperator = true;
1052     return AST::FunctionDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, { }, WTF::nullopt, WTFMove(*type), &quot;operator cast&quot;_str, WTFMove(*parameters), WTFMove(*semantic), isOperator, m_mode);
1053 }
1054 
1055 auto Parser::parseFunctionDeclaration() -&gt; Expected&lt;AST::FunctionDeclaration, Error&gt;
1056 {
1057     PEEK(token);
1058     switch (token-&gt;type) {
1059     case Token::Type::Operator:
1060         return parseOperatorFunctionDeclaration();
1061     case Token::Type::Vertex:
1062     case Token::Type::Fragment:
1063         return parseVertexOrFragmentFunctionDeclaration();
1064     case Token::Type::LeftSquareBracket:
1065         return parseComputeFunctionDeclaration();
1066     default:
1067         return parseRegularFunctionDeclaration();
1068     }
1069 }
1070 
1071 auto Parser::parseNativeFunctionDeclaration() -&gt; Expected&lt;AST::NativeFunctionDeclaration, Error&gt;
1072 {
1073     CONSUME_TYPE(native, Native);
1074     PARSE(functionDeclaration, FunctionDeclaration);
1075     CONSUME_TYPE(semicolon, Semicolon);
1076 
1077     return AST::NativeFunctionDeclaration(WTFMove(*functionDeclaration));
1078 }
1079 
1080 auto Parser::parseBlock() -&gt; Expected&lt;AST::Block, Error&gt;
1081 {
1082     CONSUME_TYPE(origin, LeftCurlyBracket);
1083     PARSE(result, BlockBody);
1084     CONSUME_TYPE(rightCurlyBracket, RightCurlyBracket);
1085     result-&gt;updateCodeLocation({ *origin, *rightCurlyBracket });
1086     return WTFMove(*result);
1087 }
1088 
1089 auto Parser::parseBlockBody() -&gt; Expected&lt;AST::Block, Error&gt;
1090 {
1091     auto startOffset = m_lexer.peek().startOffset();
1092 
1093     AST::Statements statements;
1094     while (!peekTypes&lt;Token::Type::RightCurlyBracket, Token::Type::Case, Token::Type::Default&gt;()) {
1095         PARSE(statement, Statement);
1096         statements.append(WTFMove(*statement));
1097     }
1098 
1099     auto endOffset = m_lexer.peek().startOffset();
1100 
1101     return AST::Block({ startOffset, endOffset, m_lexer.nameSpace() }, WTFMove(statements));
1102 }
1103 
1104 auto Parser::parseIfStatement() -&gt; Expected&lt;AST::IfStatement, Error&gt;
1105 {
1106     CONSUME_TYPE(origin, If);
1107     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1108     PARSE(conditional, Expression);
1109     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1110     PARSE(body, Statement);
1111 
1112     std::unique_ptr&lt;AST::Statement&gt; elseBody(nullptr);
1113     if (tryType(Token::Type::Else)) {
1114         PARSE(parsedElseBody, Statement);
1115         elseBody = (*parsedElseBody).moveToUniquePtr();
1116     }
1117 
1118     auto endOffset = m_lexer.peek().startOffset();
1119 
1120     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1121     castArguments.append(WTFMove(*conditional));
1122     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(Token(*origin), &quot;bool&quot;_str, WTFMove(castArguments));
1123     return AST::IfStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(boolCast), WTFMove(*body), WTFMove(elseBody));
1124 }
1125 
1126 auto Parser::parseSwitchStatement() -&gt; Expected&lt;AST::SwitchStatement, Error&gt;
1127 {
1128     CONSUME_TYPE(origin, Switch);
1129     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1130     PARSE(value, Expression);
1131     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1132     CONSUME_TYPE(leftCurlyBracket, LeftCurlyBracket);
1133 
1134     Vector&lt;AST::SwitchCase&gt; switchCases;
1135     PEEK(nextToken);
1136     while (nextToken-&gt;type != Token::Type::RightCurlyBracket) {
1137         PARSE(switchCase, SwitchCase);
1138         switchCases.append(WTFMove(*switchCase));
1139         PEEK(nextTokenInLoop);
1140         nextToken = nextTokenInLoop;
1141     }
1142 
1143     auto endToken = m_lexer.consumeToken();
1144 
1145     return AST::SwitchStatement({ *origin, endToken }, WTFMove(*value), WTFMove(switchCases));
1146 }
1147 
1148 auto Parser::parseSwitchCase() -&gt; Expected&lt;AST::SwitchCase, Error&gt;
1149 {
1150     auto origin = consumeTypes&lt;Token::Type::Case, Token::Type::Default&gt;();
1151     if (!origin)
1152         return makeUnexpected(origin.error());
1153 
1154     switch (origin-&gt;type) {
1155     case Token::Type::Case: {
1156         PARSE(value, ConstantExpression);
1157         CONSUME_TYPE(colon, Colon);
1158 
1159         PARSE(block, BlockBody);
1160 
1161         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTFMove(*value), WTFMove(*block));
1162     }
1163     default: {
1164         ASSERT(origin-&gt;type == Token::Type::Default);
1165         CONSUME_TYPE(colon, Colon);
1166 
1167         PARSE(block, BlockBody);
1168 
1169         return AST::SwitchCase({ origin-&gt;codeLocation,  block-&gt;codeLocation()}, WTF::nullopt, WTFMove(*block));
1170     }
1171     }
1172 }
1173 
1174 auto Parser::parseForLoop() -&gt; Expected&lt;AST::ForLoop, Error&gt;
1175 {
1176     CONSUME_TYPE(origin, For);
1177     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1178 
1179     auto parseRemainder = [&amp;](UniqueRef&lt;AST::Statement&gt;&amp;&amp; initialization) -&gt; Expected&lt;AST::ForLoop, Error&gt; {
1180         CONSUME_TYPE(semicolon, Semicolon);
1181 
1182         std::unique_ptr&lt;AST::Expression&gt; condition(nullptr);
1183         if (!tryType(Token::Type::Semicolon)) {
1184             if (auto expression = parseExpression())
1185                 condition = (*expression).moveToUniquePtr();
1186             else
1187                 return makeUnexpected(expression.error());
1188             CONSUME_TYPE(secondSemicolon, Semicolon);
1189         }
1190 
1191         std::unique_ptr&lt;AST::Expression&gt; increment(nullptr);
1192         if (!tryType(Token::Type::RightParenthesis)) {
1193             if (auto expression = parseExpression())
1194                 increment = (*expression).moveToUniquePtr();
1195             else
1196                 return makeUnexpected(expression.error());
1197             CONSUME_TYPE(rightParenthesis, RightParenthesis);
1198         }
1199 
1200         PARSE(body, Statement);
1201         CodeLocation location(origin-&gt;codeLocation, (*body)-&gt;codeLocation());
1202         return AST::ForLoop(location, WTFMove(initialization), WTFMove(condition), WTFMove(increment), WTFMove(*body));
1203     };
1204 
1205     auto variableDeclarations = backtrackingScope&lt;Expected&lt;AST::VariableDeclarationsStatement, Error&gt;&gt;([&amp;]() {
1206         return parseVariableDeclarations();
1207     });
1208     if (variableDeclarations) {
1209         UniqueRef&lt;AST::Statement&gt; declarationStatement = makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations));
1210         return parseRemainder(WTFMove(declarationStatement));
1211     }
1212 
1213     PARSE(effectfulExpression, EffectfulExpression);
1214 
1215     return parseRemainder(WTFMove(*effectfulExpression));
1216 }
1217 
1218 auto Parser::parseWhileLoop() -&gt; Expected&lt;AST::WhileLoop, Error&gt;
1219 {
1220     CONSUME_TYPE(origin, While);
1221     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1222     PARSE(conditional, Expression);
1223     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1224     PARSE(body, Statement);
1225 
1226     CodeLocation location(origin-&gt;codeLocation,  (*body)-&gt;codeLocation());
1227     return AST::WhileLoop(location, WTFMove(*conditional), WTFMove(*body));
1228 }
1229 
1230 auto Parser::parseDoWhileLoop() -&gt; Expected&lt;AST::DoWhileLoop, Error&gt;
1231 {
1232     CONSUME_TYPE(origin, Do);
1233     PARSE(body, Statement);
1234     CONSUME_TYPE(whileKeyword, While);
1235     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
1236     PARSE(conditional, Expression);
1237     CONSUME_TYPE(rightParenthesis, RightParenthesis);
1238     CONSUME_TYPE(semicolon, Semicolon);
1239 
1240     return AST::DoWhileLoop({ *origin, *semicolon}, WTFMove(*body), WTFMove(*conditional));
1241 }
1242 
1243 auto Parser::parseVariableDeclaration(Ref&lt;AST::UnnamedType&gt;&amp;&amp; type) -&gt; Expected&lt;AST::VariableDeclaration, Error&gt;
1244 {
1245     PEEK(origin);
1246 
1247     auto qualifiers = parseQualifiers();
1248 
1249     CONSUME_TYPE(name, Identifier);
1250     PARSE(semantic, Semantic);
1251 
1252     std::unique_ptr&lt;AST::Expression&gt; initializer = nullptr;
1253     if (tryType(Token::Type::EqualsSign)) {
1254         PARSE(initializingExpression, PossibleTernaryConditional);
1255         initializer = initializingExpression.value().moveToUniquePtr();
1256     }
1257 
1258     auto endOffset = m_lexer.peek().startOffset();
1259     return AST::VariableDeclaration({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(qualifiers), { WTFMove(type) }, name-&gt;stringView(m_lexer).toString(), WTFMove(*semantic), WTFMove(initializer));
1260 }
1261 
1262 auto Parser::parseVariableDeclarations() -&gt; Expected&lt;AST::VariableDeclarationsStatement, Error&gt;
1263 {
1264     PEEK(origin);
1265 
1266     PARSE(type, Type);
1267 
1268     auto firstVariableDeclaration = parseVariableDeclaration(type-&gt;copyRef());
1269     if (!firstVariableDeclaration)
1270         return makeUnexpected(firstVariableDeclaration.error());
1271 
1272     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; result;
1273     result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*firstVariableDeclaration)));
1274 
1275     while (tryType(Token::Type::Comma)) {
1276         auto variableDeclaration = parseVariableDeclaration(type-&gt;copyRef());
1277         if (!variableDeclaration)
1278             return makeUnexpected(variableDeclaration.error());
1279         result.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(WTFMove(*variableDeclaration)));
1280     }
1281 
1282     auto endOffset = m_lexer.peek().startOffset();
1283     return AST::VariableDeclarationsStatement({ origin-&gt;startOffset(), endOffset, m_lexer.nameSpace() }, WTFMove(result));
1284 }
1285 
1286 auto Parser::parseStatement() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1287 {
1288     PEEK(token);
1289     switch (token-&gt;type) {
1290     case Token::Type::LeftCurlyBracket: {
1291         PARSE(block, Block);
1292         return { makeUniqueRef&lt;AST::Block&gt;(WTFMove(*block)) };
1293     }
1294     case Token::Type::If: {
1295         PARSE(ifStatement, IfStatement);
1296         return { makeUniqueRef&lt;AST::IfStatement&gt;(WTFMove(*ifStatement)) };
1297     }
1298     case Token::Type::Switch: {
1299         PARSE(switchStatement, SwitchStatement);
1300         return { makeUniqueRef&lt;AST::SwitchStatement&gt;(WTFMove(*switchStatement)) };
1301     }
1302     case Token::Type::For: {
1303         PARSE(forLoop, ForLoop);
1304         return { makeUniqueRef&lt;AST::ForLoop&gt;(WTFMove(*forLoop)) };
1305     }
1306     case Token::Type::While: {
1307         PARSE(whileLoop, WhileLoop);
1308         return { makeUniqueRef&lt;AST::WhileLoop&gt;(WTFMove(*whileLoop)) };
1309     }
1310     case Token::Type::Do: {
1311         PARSE(doWhileLoop, DoWhileLoop);
1312         return { makeUniqueRef&lt;AST::DoWhileLoop&gt;(WTFMove(*doWhileLoop)) };
1313     }
1314     case Token::Type::Break: {
1315         auto breakToken = m_lexer.consumeToken();
1316         CONSUME_TYPE(semicolon, Semicolon);
1317         auto breakObject = AST::Break(WTFMove(breakToken));
1318         return { makeUniqueRef&lt;AST::Break&gt;(WTFMove(breakObject)) };
1319     }
1320     case Token::Type::Continue: {
1321         auto continueToken = m_lexer.consumeToken();
1322         CONSUME_TYPE(semicolon, Semicolon);
1323         auto continueObject = AST::Continue(WTFMove(continueToken));
1324         return { makeUniqueRef&lt;AST::Continue&gt;(WTFMove(continueObject)) };
1325     }
1326     case Token::Type::Fallthrough: {
1327         auto fallthroughToken = m_lexer.consumeToken();
1328         CONSUME_TYPE(semicolon, Semicolon);
1329         auto fallthroughObject = AST::Fallthrough(WTFMove(fallthroughToken));
1330         return { makeUniqueRef&lt;AST::Fallthrough&gt;(WTFMove(fallthroughObject)) };
1331     }
1332     case Token::Type::Return: {
1333         auto returnToken = m_lexer.consumeToken();
1334         if (auto semicolon = tryType(Token::Type::Semicolon)) {
1335             auto returnObject = AST::Return(WTFMove(returnToken), nullptr);
1336             return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };
1337         }
1338         PARSE(expression, Expression);
1339         CONSUME_TYPE(finalSemicolon, Semicolon);
1340         auto returnObject = AST::Return(WTFMove(returnToken), (*expression).moveToUniquePtr());
1341         return { makeUniqueRef&lt;AST::Return&gt;(WTFMove(returnObject)) };
1342     }
1343     case Token::Type::Constant:
1344     case Token::Type::Device:
1345     case Token::Type::Threadgroup:
1346     case Token::Type::Thread: {
1347         PARSE(variableDeclarations, VariableDeclarations);
1348         CONSUME_TYPE(semicolon, Semicolon);
1349         return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1350     }
1351     case Token::Type::Identifier: {
1352         PEEK_FURTHER(nextToken);
1353         switch (nextToken-&gt;type) {
1354         case Token::Type::Identifier:
1355         case Token::Type::LessThanSign:
1356         case Token::Type::Star:
1357         case Token::Type::Qualifier: {
1358             PARSE(variableDeclarations, VariableDeclarations);
1359             CONSUME_TYPE(semicolon, Semicolon);
1360             return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1361         }
1362         default:
1363             break;
1364         }
1365         break;
1366     }
1367     default:
1368         break;
1369     }
1370 
1371     {
1372         auto effectfulExpression = backtrackingScope&lt;Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;&gt;([&amp;]() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt; {
1373             PARSE(result, EffectfulExpression);
1374             CONSUME_TYPE(semicolon, Semicolon);
1375             return result;
1376         });
1377         if (effectfulExpression)
1378             return WTFMove(*effectfulExpression);
1379     }
1380 
1381     PARSE(variableDeclarations, VariableDeclarations);
1382     CONSUME_TYPE(semicolon, Semicolon);
1383     return { makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(WTFMove(*variableDeclarations)) };
1384 }
1385 
1386 auto Parser::parseEffectfulExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Statement&gt;, Error&gt;
1387 {
1388     PEEK(origin);
1389     if (origin-&gt;type == Token::Type::Semicolon)
1390         return { makeUniqueRef&lt;AST::Block&gt;(*origin, Vector&lt;UniqueRef&lt;AST::Statement&gt;&gt;()) };
1391 
1392     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1393     PARSE(effectfulExpression, EffectfulAssignment);
1394     expressions.append(WTFMove(*effectfulExpression));
1395 
1396     while (tryType(Token::Type::Comma)) {
1397         PARSE(expression, EffectfulAssignment);
1398         expressions.append(WTFMove(*expression));
1399     }
1400 
1401     if (expressions.size() == 1)
1402         return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(expressions[0])) };
1403     unsigned endOffset = m_lexer.peek().startOffset();
1404     CodeLocation location(origin-&gt;startOffset(), endOffset, m_lexer.nameSpace());
1405     auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));
1406     return { makeUniqueRef&lt;AST::EffectfulExpressionStatement&gt;(WTFMove(commaExpression)) };
1407 }
1408 
1409 auto Parser::parseEffectfulAssignment() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1410 {
1411     PEEK(origin);
1412 
1413     bool isEffectful = false;
1414     PARSE(expression, PossiblePrefix, &amp;isEffectful);
1415 
1416     if (!isEffectful || peekTypes&lt;
1417         Token::Type::EqualsSign,
1418         Token::Type::PlusEquals,
1419         Token::Type::MinusEquals,
1420         Token::Type::TimesEquals,
1421         Token::Type::DivideEquals,
1422         Token::Type::ModEquals,
1423         Token::Type::XorEquals,
1424         Token::Type::AndEquals,
1425         Token::Type::OrEquals,
1426         Token::Type::RightShiftEquals,
1427         Token::Type::LeftShiftEquals
1428     &gt;()) {
1429         return completeAssignment(WTFMove(*expression));
1430     }
1431 
1432     return expression;
1433 }
1434 
1435 auto Parser::parseLimitedSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1436 {
1437     auto type = consumeTypes&lt;
1438         Token::Type::FullStop,
1439         Token::Type::Arrow,
1440         Token::Type::LeftSquareBracket&gt;();
1441     if (!type)
1442         return SuffixExpression(WTFMove(previous), false);
1443 
1444     switch (type-&gt;type) {
1445     case Token::Type::FullStop: {
1446         auto identifier = consumeType(Token::Type::Identifier);
1447         if (!identifier)
1448             return SuffixExpression(WTFMove(previous), false);
1449         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1450         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);
1451     }
1452     case Token::Type::Arrow: {
1453         auto identifier = consumeType(Token::Type::Identifier);
1454         if (!identifier)
1455             return SuffixExpression(WTFMove(previous), false);
1456         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1457         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);
1458     }
1459     default: {
1460         ASSERT(type-&gt;type == Token::Type::LeftSquareBracket);
1461         auto expression = parseExpression();
1462         if (!expression)
1463             return SuffixExpression(WTFMove(previous), false);
1464         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {
1465             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);
1466             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);
1467         }
1468         return SuffixExpression(WTFMove(previous), false);
1469     }
1470     }
1471 }
1472 
1473 auto Parser::parseSuffixOperator(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; SuffixExpression
1474 {
1475     auto suffix = consumeTypes&lt;
1476         Token::Type::FullStop,
1477         Token::Type::Arrow,
1478         Token::Type::LeftSquareBracket,
1479         Token::Type::PlusPlus,
1480         Token::Type::MinusMinus&gt;();
1481     if (!suffix)
1482         return SuffixExpression(WTFMove(previous), false);
1483 
1484     switch (suffix-&gt;type) {
1485     case Token::Type::FullStop: {
1486         auto identifier = consumeType(Token::Type::Identifier);
1487         if (!identifier)
1488             return SuffixExpression(WTFMove(previous), false);
1489         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1490         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, WTFMove(previous), identifier-&gt;stringView(m_lexer).toString()), true);
1491     }
1492     case Token::Type::Arrow: {
1493         auto identifier = consumeType(Token::Type::Identifier);
1494         if (!identifier)
1495             return SuffixExpression(WTFMove(previous), false);
1496         CodeLocation location(previous-&gt;codeLocation(), *identifier);
1497         return SuffixExpression(makeUniqueRef&lt;AST::DotExpression&gt;(location, makeUniqueRef&lt;AST::DereferenceExpression&gt;(WTFMove(*suffix), WTFMove(previous)), identifier-&gt;stringView(m_lexer).toString()), true);
1498     }
1499     case Token::Type::LeftSquareBracket: {
1500         auto expression = parseExpression();
1501         if (!expression)
1502             return SuffixExpression(WTFMove(previous), false);
1503         if (auto rightSquareBracket = consumeType(Token::Type::RightSquareBracket)) {
1504             CodeLocation location(previous-&gt;codeLocation(), *rightSquareBracket);
1505             return SuffixExpression(makeUniqueRef&lt;AST::IndexExpression&gt;(location, WTFMove(previous), WTFMove(*expression)), true);
1506         }
1507         return SuffixExpression(WTFMove(previous), false);
1508     }
1509     case Token::Type::PlusPlus: {
1510         CodeLocation location(previous-&gt;codeLocation(), *suffix);
1511         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));
1512         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1513         callArguments.append(result-&gt;oldVariableReference());
1514         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));
1515         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1516         return SuffixExpression(WTFMove(result), true);
1517     }
1518     default: {
1519         ASSERT(suffix-&gt;type == Token::Type::MinusMinus);
1520         CodeLocation location(previous-&gt;codeLocation(), *suffix);
1521         auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(previous));
1522         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1523         callArguments.append(result-&gt;oldVariableReference());
1524         result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));
1525         result-&gt;setResultExpression(result-&gt;oldVariableReference());
1526         return SuffixExpression(WTFMove(result), true);
1527     }
1528     }
1529 }
1530 
1531 auto Parser::parseExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1532 {
1533     PARSE(first, PossibleTernaryConditional);
1534     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
1535     unsigned startOffset = (*first)-&gt;codeLocation().startOffset();
1536     expressions.append(WTFMove(*first));
1537 
1538     while (tryType(Token::Type::Comma)) {
1539         PARSE(expression, PossibleTernaryConditional);
1540         expressions.append(WTFMove(*expression));
1541     }
1542 
1543     if (expressions.size() == 1)
1544         return WTFMove(expressions[0]);
1545     auto endOffset = m_lexer.peek().startOffset();
1546     CodeLocation location(startOffset, endOffset, m_lexer.nameSpace());
1547     return { makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions)) };
1548 }
1549 
1550 auto Parser::completeTernaryConditional(UniqueRef&lt;AST::Expression&gt;&amp;&amp; predicate) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1551 {
1552     CONSUME_TYPE(questionMark, QuestionMark);
1553     PARSE(bodyExpression, Expression);
1554     CONSUME_TYPE(colon, Colon);
1555     PARSE(elseExpression, PossibleTernaryConditional);
1556 
1557     CodeLocation predicateLocation = predicate-&gt;codeLocation();
1558     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1559     castArguments.append(WTFMove(predicate));
1560     auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(predicateLocation, &quot;bool&quot;_str, WTFMove(castArguments));
1561     CodeLocation location(predicateLocation, (*elseExpression)-&gt;codeLocation());
1562     return { makeUniqueRef&lt;AST::TernaryExpression&gt;(location, WTFMove(boolCast), WTFMove(*bodyExpression), WTFMove(*elseExpression)) };
1563 }
1564 
1565 auto Parser::completeAssignment(UniqueRef&lt;AST::Expression&gt;&amp;&amp; left) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1566 {
1567     auto assignmentOperator = consumeTypes&lt;
1568         Token::Type::EqualsSign,
1569         Token::Type::PlusEquals,
1570         Token::Type::MinusEquals,
1571         Token::Type::TimesEquals,
1572         Token::Type::DivideEquals,
1573         Token::Type::ModEquals,
1574         Token::Type::XorEquals,
1575         Token::Type::AndEquals,
1576         Token::Type::OrEquals,
1577         Token::Type::RightShiftEquals,
1578         Token::Type::LeftShiftEquals&gt;();
1579     if (!assignmentOperator)
1580         return makeUnexpected(assignmentOperator.error());
1581 
1582     PARSE(right, PossibleTernaryConditional);
1583     CodeLocation location = { left-&gt;codeLocation(), (*right)-&gt;codeLocation() };
1584 
1585     if (assignmentOperator-&gt;type == Token::Type::EqualsSign)
1586         return { makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(left), WTFMove(*right))};
1587 
1588     String name;
1589     switch (assignmentOperator-&gt;type) {
1590     case Token::Type::PlusEquals:
1591         name = &quot;operator+&quot;_str;
1592         break;
1593     case Token::Type::MinusEquals:
1594         name = &quot;operator-&quot;_str;
1595         break;
1596     case Token::Type::TimesEquals:
1597         name = &quot;operator*&quot;_str;
1598         break;
1599     case Token::Type::DivideEquals:
1600         name = &quot;operator/&quot;_str;
1601         break;
1602     case Token::Type::ModEquals:
1603         name = &quot;operator%&quot;_str;
1604         break;
1605     case Token::Type::XorEquals:
1606         name = &quot;operator^&quot;_str;
1607         break;
1608     case Token::Type::AndEquals:
1609         name = &quot;operator&amp;&quot;_str;
1610         break;
1611     case Token::Type::OrEquals:
1612         name = &quot;operator|&quot;_str;
1613         break;
1614     case Token::Type::RightShiftEquals:
1615         name = &quot;operator&gt;&gt;&quot;_str;
1616         break;
1617     default:
1618         ASSERT(assignmentOperator-&gt;type == Token::Type::LeftShiftEquals);
1619         name = &quot;operator&lt;&lt;&quot;_str;
1620         break;
1621     }
1622 
1623     auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(left));
1624     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1625     callArguments.append(result-&gt;oldVariableReference());
1626     callArguments.append(WTFMove(*right));
1627     result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(name), WTFMove(callArguments)));
1628     result-&gt;setResultExpression(result-&gt;newVariableReference());
1629     return { WTFMove(result) };
1630 }
1631 
1632 auto Parser::parsePossibleTernaryConditional() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1633 {
1634     PARSE(expression, PossiblePrefix);
1635 
1636     if (peekTypes&lt;Token::Type::EqualsSign,
1637         Token::Type::PlusEquals,
1638         Token::Type::MinusEquals,
1639         Token::Type::TimesEquals,
1640         Token::Type::DivideEquals,
1641         Token::Type::ModEquals,
1642         Token::Type::XorEquals,
1643         Token::Type::AndEquals,
1644         Token::Type::OrEquals,
1645         Token::Type::RightShiftEquals,
1646         Token::Type::LeftShiftEquals&gt;()) {
1647         return completeAssignment(WTFMove(*expression));
1648     }
1649 
1650     expression = completePossibleShift(WTFMove(*expression));
1651     if (!expression)
1652         return makeUnexpected(expression.error());
1653 
1654     expression = completePossibleMultiply(WTFMove(*expression));
1655     if (!expression)
1656         return makeUnexpected(expression.error());
1657 
1658     expression = completePossibleAdd(WTFMove(*expression));
1659     if (!expression)
1660         return makeUnexpected(expression.error());
1661 
1662     expression = completePossibleRelationalBinaryOperation(WTFMove(*expression));
1663     if (!expression)
1664         return makeUnexpected(expression.error());
1665 
1666     expression = completePossibleLogicalBinaryOperation(WTFMove(*expression));
1667     if (!expression)
1668         return makeUnexpected(expression.error());
1669 
1670     PEEK(nextToken);
1671     if (nextToken-&gt;type == Token::Type::QuestionMark)
1672         return completeTernaryConditional(WTFMove(*expression));
1673     return expression;
1674 }
1675 
1676 auto Parser::parsePossibleLogicalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1677 {
1678     PARSE(parsedPrevious, PossibleRelationalBinaryOperation);
1679     return completePossibleLogicalBinaryOperation(WTFMove(*parsedPrevious));
1680 }
1681 
1682 auto Parser::completePossibleLogicalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1683 {
1684     while (auto logicalBinaryOperation = tryTypes&lt;
1685         Token::Type::OrOr,
1686         Token::Type::AndAnd,
1687         Token::Type::Or,
1688         Token::Type::Xor,
1689         Token::Type::And
1690         &gt;()) {
1691         PARSE(next, PossibleRelationalBinaryOperation);
1692         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1693 
1694         switch (logicalBinaryOperation-&gt;type) {
1695         case Token::Type::OrOr:
1696             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::Or, WTFMove(previous), WTFMove(*next));
1697             break;
1698         case Token::Type::AndAnd:
1699             previous = makeUniqueRef&lt;AST::LogicalExpression&gt;(location, AST::LogicalExpression::Type::And, WTFMove(previous), WTFMove(*next));
1700             break;
1701         case Token::Type::Or: {
1702             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1703             callArguments.append(WTFMove(previous));
1704             callArguments.append(WTFMove(*next));
1705             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator|&quot;_str, WTFMove(callArguments));
1706             break;
1707         }
1708         case Token::Type::Xor: {
1709             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1710             callArguments.append(WTFMove(previous));
1711             callArguments.append(WTFMove(*next));
1712             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator^&quot;_str, WTFMove(callArguments));
1713             break;
1714         }
1715         default: {
1716             ASSERT(logicalBinaryOperation-&gt;type == Token::Type::And);
1717             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1718             callArguments.append(WTFMove(previous));
1719             callArguments.append(WTFMove(*next));
1720             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&amp;&quot;_str, WTFMove(callArguments));
1721             break;
1722         }
1723         }
1724     }
1725 
1726     return { WTFMove(previous) };
1727 }
1728 
1729 auto Parser::parsePossibleRelationalBinaryOperation() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1730 {
1731     PARSE(parsedPrevious, PossibleShift);
1732     return completePossibleRelationalBinaryOperation(WTFMove(*parsedPrevious));
1733 }
1734 
1735 auto Parser::completePossibleRelationalBinaryOperation(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1736 {
1737     while (auto relationalBinaryOperation = tryTypes&lt;
1738         Token::Type::LessThanSign,
1739         Token::Type::GreaterThanSign,
1740         Token::Type::LessThanOrEqualTo,
1741         Token::Type::GreaterThanOrEqualTo,
1742         Token::Type::EqualComparison,
1743         Token::Type::NotEqual
1744         &gt;()) {
1745         PARSE(next, PossibleShift);
1746         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1747 
1748         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1749         callArguments.append(WTFMove(previous));
1750         callArguments.append(WTFMove(*next));
1751 
1752         switch (relationalBinaryOperation-&gt;type) {
1753         case Token::Type::LessThanSign: {
1754             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&quot;_str, WTFMove(callArguments));
1755             break;
1756         }
1757         case Token::Type::GreaterThanSign: {
1758             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&quot;_str, WTFMove(callArguments));
1759             break;
1760         }
1761         case Token::Type::LessThanOrEqualTo: {
1762             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;=&quot;_str, WTFMove(callArguments));
1763             break;
1764         }
1765         case Token::Type::GreaterThanOrEqualTo: {
1766             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;=&quot;_str, WTFMove(callArguments));
1767             break;
1768         }
1769         case Token::Type::EqualComparison: {
1770             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));
1771             break;
1772         }
1773         default: {
1774             ASSERT(relationalBinaryOperation-&gt;type == Token::Type::NotEqual);
1775             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator==&quot;_str, WTFMove(callArguments));
1776             previous = makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(previous));
1777             break;
1778         }
1779         }
1780     }
1781 
1782     return WTFMove(previous);
1783 }
1784 
1785 auto Parser::parsePossibleShift() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1786 {
1787     PARSE(parsedPrevious, PossibleAdd);
1788     return completePossibleShift(WTFMove(*parsedPrevious));
1789 }
1790 
1791 auto Parser::completePossibleShift(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1792 {
1793     while (auto shift = tryTypes&lt;
1794         Token::Type::LeftShift,
1795         Token::Type::RightShift
1796         &gt;()) {
1797         PARSE(next, PossibleAdd);
1798         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1799 
1800         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1801         callArguments.append(WTFMove(previous));
1802         callArguments.append(WTFMove(*next));
1803 
1804         switch (shift-&gt;type) {
1805         case Token::Type::LeftShift: {
1806             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&lt;&lt;&quot;_str, WTFMove(callArguments));
1807             break;
1808         }
1809         default: {
1810             ASSERT(shift-&gt;type == Token::Type::RightShift);
1811             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator&gt;&gt;&quot;_str, WTFMove(callArguments));
1812             break;
1813         }
1814         }
1815     }
1816 
1817     return WTFMove(previous);
1818 }
1819 
1820 auto Parser::parsePossibleAdd() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1821 {
1822     PARSE(parsedPrevious, PossibleMultiply);
1823     return completePossibleAdd(WTFMove(*parsedPrevious));
1824 }
1825 
1826 auto Parser::completePossibleAdd(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1827 {
1828     while (auto add = tryTypes&lt;
1829         Token::Type::Plus,
1830         Token::Type::Minus
1831         &gt;()) {
1832         PARSE(next, PossibleMultiply);
1833         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1834 
1835         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1836         callArguments.append(WTFMove(previous));
1837         callArguments.append(WTFMove(*next));
1838 
1839         switch (add-&gt;type) {
1840         case Token::Type::Plus: {
1841             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments));
1842             break;
1843         }
1844         default: {
1845             ASSERT(add-&gt;type == Token::Type::Minus);
1846             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments));
1847             break;
1848         }
1849         }
1850     }
1851 
1852     return WTFMove(previous);
1853 }
1854 
1855 auto Parser::parsePossibleMultiply() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1856 {
1857     PARSE(parsedPrevious, PossiblePrefix);
1858     return completePossibleMultiply(WTFMove(*parsedPrevious));
1859 }
1860 
1861 auto Parser::completePossibleMultiply(UniqueRef&lt;AST::Expression&gt;&amp;&amp; previous) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1862 {
1863     while (auto multiply = tryTypes&lt;
1864         Token::Type::Star,
1865         Token::Type::Divide,
1866         Token::Type::Mod
1867         &gt;()) {
1868         PARSE(next, PossiblePrefix);
1869         CodeLocation location(previous-&gt;codeLocation(), (*next)-&gt;codeLocation());
1870 
1871         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1872         callArguments.append(WTFMove(previous));
1873         callArguments.append(WTFMove(*next));
1874 
1875         switch (multiply-&gt;type) {
1876         case Token::Type::Star: {
1877             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator*&quot;_str, WTFMove(callArguments));
1878             break;
1879         }
1880         case Token::Type::Divide: {
1881             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator/&quot;_str, WTFMove(callArguments));
1882             break;
1883         }
1884         default: {
1885             ASSERT(multiply-&gt;type == Token::Type::Mod);
1886             previous = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator%&quot;_str, WTFMove(callArguments));
1887             break;
1888         }
1889         }
1890     }
1891 
1892     return WTFMove(previous);
1893 }
1894 
1895 auto Parser::parsePossiblePrefix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1896 {
1897     if (auto prefix = tryTypes&lt;
1898         Token::Type::PlusPlus,
1899         Token::Type::MinusMinus,
1900         Token::Type::Plus,
1901         Token::Type::Minus,
1902         Token::Type::Tilde,
1903         Token::Type::ExclamationPoint,
1904         Token::Type::And,
1905         Token::Type::At,
1906         Token::Type::Star
1907     &gt;()) {
1908         PARSE(next, PossiblePrefix);
1909         CodeLocation location(*prefix, (*next)-&gt;codeLocation());
1910 
1911         switch (prefix-&gt;type) {
1912         case Token::Type::PlusPlus: {
1913             if (isEffectful)
1914                 *isEffectful = true;
1915             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));
1916             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1917             callArguments.append(result-&gt;oldVariableReference());
1918             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator++&quot;_str, WTFMove(callArguments)));
1919             result-&gt;setResultExpression(result-&gt;newVariableReference());
1920             return { WTFMove(result) };
1921         }
1922         case Token::Type::MinusMinus: {
1923             if (isEffectful)
1924                 *isEffectful = true;
1925             auto result = makeUniqueRef&lt;AST::ReadModifyWriteExpression&gt;(location, WTFMove(*next));
1926             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1927             callArguments.append(result-&gt;oldVariableReference());
1928             result-&gt;setNewValueExpression(makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator--&quot;_str, WTFMove(callArguments)));
1929             result-&gt;setResultExpression(result-&gt;newVariableReference());
1930             return { WTFMove(result) };
1931         }
1932         case Token::Type::Plus: {
1933             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1934             callArguments.append(WTFMove(*next));
1935             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator+&quot;_str, WTFMove(callArguments)) };
1936         }
1937         case Token::Type::Minus: {
1938             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1939             callArguments.append(WTFMove(*next));
1940             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator-&quot;_str, WTFMove(callArguments)) };
1941         }
1942         case Token::Type::Tilde: {
1943             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; callArguments;
1944             callArguments.append(WTFMove(*next));
1945             return { makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;operator~&quot;_str, WTFMove(callArguments)) };
1946         }
1947         case Token::Type::ExclamationPoint: {
1948             Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; castArguments;
1949             castArguments.append(WTFMove(*next));
1950             auto boolCast = makeUniqueRef&lt;AST::CallExpression&gt;(location, &quot;bool&quot;_str, WTFMove(castArguments));
1951             return { makeUniqueRef&lt;AST::LogicalNotExpression&gt;(location, WTFMove(boolCast)) };
1952         }
1953         case Token::Type::And:
1954             return { makeUniqueRef&lt;AST::MakePointerExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };
1955         case Token::Type::At:
1956             return { makeUniqueRef&lt;AST::MakeArrayReferenceExpression&gt;(location, WTFMove(*next), AST::AddressEscapeMode::Escapes) };
1957         default:
1958             ASSERT(prefix-&gt;type == Token::Type::Star);
1959             return { makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(*next)) };
1960         }
1961     }
1962 
1963     return parsePossibleSuffix(isEffectful);
1964 }
1965 
1966 auto Parser::parsePossibleSuffix(bool *isEffectful) -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
1967 {
1968     PEEK(token);
1969     PEEK_FURTHER(nextToken);
1970 
1971     if (token-&gt;type == Token::Type::Identifier &amp;&amp; nextToken-&gt;type == Token::Type::LeftParenthesis) {
1972         PARSE(expression, CallExpression);
1973         if (isEffectful)
1974             *isEffectful = true;
1975         while (true) {
1976             PEEK(suffixToken);
1977             if (suffixToken-&gt;type != Token::Type::FullStop &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket)
1978                 break;
1979             auto result = parseLimitedSuffixOperator(WTFMove(*expression));
1980             expression = WTFMove(result.result);
1981         }
1982         return expression;
1983     }
1984 
1985     if (token-&gt;type == Token::Type::LeftParenthesis &amp;&amp; isEffectful)
1986         *isEffectful = true;
1987 
1988     PARSE(expression, Term);
1989     bool isLastSuffixTokenEffectful = false;
1990     while (true) {
1991         PEEK(suffixToken);
1992         if (suffixToken-&gt;type != Token::Type::FullStop
1993             &amp;&amp; suffixToken-&gt;type != Token::Type::Arrow
1994             &amp;&amp; suffixToken-&gt;type != Token::Type::LeftSquareBracket
1995             &amp;&amp; suffixToken-&gt;type != Token::Type::PlusPlus
1996             &amp;&amp; suffixToken-&gt;type != Token::Type::MinusMinus) {
1997             break;
1998         }
1999         isLastSuffixTokenEffectful = suffixToken-&gt;type == Token::Type::PlusPlus || suffixToken-&gt;type == Token::Type::MinusMinus;
2000         auto result = parseSuffixOperator(WTFMove(*expression));
2001         expression = WTFMove(result.result);
2002     }
2003     if (isLastSuffixTokenEffectful &amp;&amp; isEffectful)
2004         *isEffectful = true;
2005     return expression;
2006 }
2007 
2008 auto Parser::parseCallExpression() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2009 {
2010     CONSUME_TYPE(name, Identifier);
2011     auto callName = name-&gt;stringView(m_lexer).toString();
2012 
2013     CONSUME_TYPE(leftParenthesis, LeftParenthesis);
2014 
2015     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
2016     if (tryType(Token::Type::RightParenthesis))
2017         return { makeUniqueRef&lt;AST::CallExpression&gt;(WTFMove(*name), WTFMove(callName), WTFMove(arguments)) };
2018 
2019     PARSE(firstArgument, PossibleTernaryConditional);
2020     arguments.append(WTFMove(*firstArgument));
2021     while (tryType(Token::Type::Comma)) {
2022         PARSE(argument, PossibleTernaryConditional);
2023         arguments.append(WTFMove(*argument));
2024     }
2025 
2026     CONSUME_TYPE(rightParenthesis, RightParenthesis);
2027     CodeLocation location(*name, *rightParenthesis);
2028 
2029     return { makeUniqueRef&lt;AST::CallExpression&gt;(location, WTFMove(callName), WTFMove(arguments)) };
2030 }
2031 
2032 auto Parser::parseTerm() -&gt; Expected&lt;UniqueRef&lt;AST::Expression&gt;, Error&gt;
2033 {
2034     auto type = consumeTypes&lt;
2035         Token::Type::IntLiteral,
2036         Token::Type::UintLiteral,
2037         Token::Type::FloatLiteral,
2038         Token::Type::Null,
2039         Token::Type::True,
2040         Token::Type::False,
2041         Token::Type::Identifier,
2042         Token::Type::LeftParenthesis&gt;();
2043     if (!type)
2044         return makeUnexpected(type.error());
2045 
2046     switch (type-&gt;type) {
2047     case Token::Type::IntLiteral: {
2048         auto value = intLiteralToInt(type-&gt;stringView(m_lexer));
2049         if (!value)
2050             return makeUnexpected(value.error());
2051         return { makeUniqueRef&lt;AST::IntegerLiteral&gt;(*type, *value) };
2052     }
2053     case Token::Type::UintLiteral: {
2054         auto value = uintLiteralToUint(type-&gt;stringView(m_lexer));
2055         if (!value)
2056             return makeUnexpected(value.error());
2057         return { makeUniqueRef&lt;AST::UnsignedIntegerLiteral&gt;(*type, *value) };
2058     }
2059     case Token::Type::FloatLiteral: {
2060         auto value = floatLiteralToFloat(type-&gt;stringView(m_lexer));
2061         if (!value)
2062             return makeUnexpected(value.error());
2063         return { makeUniqueRef&lt;AST::FloatLiteral&gt;(*type, *value) };
2064     }
2065     case Token::Type::Null:
2066         return { makeUniqueRef&lt;AST::NullLiteral&gt;(*type) };
2067     case Token::Type::True:
2068         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, true) };
2069     case Token::Type::False:
2070         return { makeUniqueRef&lt;AST::BooleanLiteral&gt;(*type, false) };
2071     case Token::Type::Identifier: {
2072         auto name = type-&gt;stringView(m_lexer).toString();
2073         return { makeUniqueRef&lt;AST::VariableReference&gt;(*type, WTFMove(name)) };
2074     }
2075     default: {
2076         ASSERT(type-&gt;type == Token::Type::LeftParenthesis);
2077         PARSE(expression, Expression);
2078         CONSUME_TYPE(rightParenthesis, RightParenthesis);
2079 
2080         return { WTFMove(*expression) };
2081     }
2082     }
2083 }
2084 
2085 } // namespace WHLSL
2086 
2087 } // namespace WebCore
2088 
2089 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>