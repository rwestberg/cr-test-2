<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Copyright 2014 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016-2018 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSParserFastPaths.h&quot;
  32 
  33 #include &quot;CSSFunctionValue.h&quot;
<a name="1" id="anc1"></a>
  34 #include &quot;CSSParserIdioms.h&quot;
  35 #include &quot;CSSPrimitiveValue.h&quot;
  36 #include &quot;CSSPropertyParser.h&quot;
  37 #include &quot;CSSValueList.h&quot;
  38 #include &quot;CSSValuePool.h&quot;
  39 #include &quot;HTMLParserIdioms.h&quot;
  40 #include &quot;RuntimeEnabledFeatures.h&quot;
  41 #include &quot;StyleColor.h&quot;
  42 #include &quot;StylePropertyShorthand.h&quot;
  43 
  44 namespace WebCore {
  45 
  46 static inline bool isSimpleLengthPropertyID(CSSPropertyID propertyId, bool&amp; acceptsNegativeNumbers)
  47 {
  48     switch (propertyId) {
  49     case CSSPropertyFontSize:
  50     case CSSPropertyHeight:
  51     case CSSPropertyWidth:
  52     case CSSPropertyMinHeight:
  53     case CSSPropertyMinWidth:
  54     case CSSPropertyPaddingBottom:
  55     case CSSPropertyPaddingLeft:
  56     case CSSPropertyPaddingRight:
  57     case CSSPropertyPaddingTop:
  58     case CSSPropertyInlineSize:
  59     case CSSPropertyBlockSize:
  60     case CSSPropertyMinInlineSize:
  61     case CSSPropertyMinBlockSize:
  62     case CSSPropertyPaddingBlockEnd:
  63     case CSSPropertyPaddingBlockStart:
  64     case CSSPropertyPaddingInlineEnd:
  65     case CSSPropertyPaddingInlineStart:
  66     case CSSPropertyShapeMargin:
  67         acceptsNegativeNumbers = false;
  68         return true;
  69     case CSSPropertyBottom:
  70     case CSSPropertyCx:
  71     case CSSPropertyCy:
  72     case CSSPropertyLeft:
  73     case CSSPropertyInsetBlockEnd:
  74     case CSSPropertyInsetBlockStart:
  75     case CSSPropertyInsetInlineEnd:
  76     case CSSPropertyInsetInlineStart:
  77     case CSSPropertyMarginBottom:
  78     case CSSPropertyMarginLeft:
  79     case CSSPropertyMarginRight:
  80     case CSSPropertyMarginTop:
  81     case CSSPropertyRight:
  82     case CSSPropertyTop:
  83     case CSSPropertyMarginBlockEnd:
  84     case CSSPropertyMarginBlockStart:
  85     case CSSPropertyMarginInlineEnd:
  86     case CSSPropertyMarginInlineStart:
  87     case CSSPropertyX:
  88     case CSSPropertyY:
  89     case CSSPropertyR:
  90     case CSSPropertyRx:
  91     case CSSPropertyRy:
  92         acceptsNegativeNumbers = true;
  93         return true;
  94     default:
  95         return false;
  96     }
  97 }
  98 
  99 template &lt;typename CharacterType&gt;
 100 static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)
 101 {
 102     if (length &gt; 2 &amp;&amp; (characters[length - 2] | 0x20) == &#39;p&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;x&#39;) {
 103         length -= 2;
 104         unit = CSSPrimitiveValue::UnitType::CSS_PX;
 105     } else if (length &gt; 1 &amp;&amp; characters[length - 1] == &#39;%&#39;) {
 106         length -= 1;
 107         unit = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;
 108     }
 109 
 110     // We rely on charactersToDouble for validation as well. The function
 111     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 112     // not represent a double.
 113     bool ok;
 114     number = charactersToDouble(characters, length, &amp;ok);
 115     if (!ok)
 116         return false;
 117     return true;
 118 }
 119 
 120 template &lt;typename CharacterType&gt;
 121 static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)
 122 {
 123     // Just support deg and rad for now.
 124     if (length &lt; 4)
 125         return false;
 126 
 127     if ((characters[length - 3] | 0x20) == &#39;d&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;e&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;g&#39;) {
 128         length -= 3;
 129         unit = CSSPrimitiveValue::UnitType::CSS_DEG;
 130     } else if ((characters[length - 3] | 0x20) == &#39;r&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;a&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;d&#39;) {
 131         length -= 3;
 132         unit = CSSPrimitiveValue::UnitType::CSS_RAD;
 133     } else
 134         return false;
 135 
 136     // We rely on charactersToDouble for validation as well. The function
 137     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 138     // not represent a double.
 139     bool ok;
 140     number = charactersToDouble(characters, length, &amp;ok);
 141     if (!ok)
 142         return false;
 143     return true;
 144 }
 145 
 146 static RefPtr&lt;CSSValue&gt; parseSimpleLengthValue(CSSPropertyID propertyId, const String&amp; string, CSSParserMode cssParserMode)
 147 {
 148     ASSERT(!string.isEmpty());
 149     bool acceptsNegativeNumbers = false;
 150 
 151     // In @viewport, width and height are shorthands, not simple length values.
 152     if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
 153         return nullptr;
 154 
 155     unsigned length = string.length();
 156     double number;
 157     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
 158 
 159     if (string.is8Bit()) {
 160         if (!parseSimpleLength(string.characters8(), length, unit, number))
 161             return nullptr;
 162     } else {
 163         if (!parseSimpleLength(string.characters16(), length, unit, number))
 164             return nullptr;
 165     }
 166 
 167     if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER) {
 168         if (number &amp;&amp; cssParserMode != SVGAttributeMode)
 169             return nullptr;
 170         unit = CSSPrimitiveValue::UnitType::CSS_PX;
 171     }
 172 
 173     if (number &lt; 0 &amp;&amp; !acceptsNegativeNumbers)
 174         return nullptr;
 175     if (std::isinf(number))
 176         return nullptr;
 177 
 178     return CSSPrimitiveValue::create(number, unit);
 179 }
 180 
 181 static inline bool isColorPropertyID(CSSPropertyID propertyId)
 182 {
 183     switch (propertyId) {
 184     case CSSPropertyColor:
 185     case CSSPropertyBackgroundColor:
 186     case CSSPropertyBorderBottomColor:
 187     case CSSPropertyBorderLeftColor:
 188     case CSSPropertyBorderRightColor:
 189     case CSSPropertyBorderTopColor:
 190     case CSSPropertyFill:
 191     case CSSPropertyFloodColor:
 192     case CSSPropertyLightingColor:
 193     case CSSPropertyOutlineColor:
 194     case CSSPropertyStopColor:
 195     case CSSPropertyStroke:
 196     case CSSPropertyStrokeColor:
 197     case CSSPropertyBorderBlockEndColor:
 198     case CSSPropertyBorderBlockStartColor:
 199     case CSSPropertyBorderInlineEndColor:
 200     case CSSPropertyBorderInlineStartColor:
 201     case CSSPropertyColumnRuleColor:
 202     case CSSPropertyWebkitTextEmphasisColor:
 203     case CSSPropertyWebkitTextFillColor:
 204     case CSSPropertyWebkitTextStrokeColor:
 205     case CSSPropertyTextDecorationColor:
 206         return true;
 207     default:
 208         return false;
 209     }
 210 }
 211 
 212 // Returns the number of characters which form a valid double
 213 // and are terminated by the given terminator character
 214 template &lt;typename CharacterType&gt;
 215 static int checkForValidDouble(const CharacterType* string, const CharacterType* end, const char terminator)
 216 {
 217     int length = end - string;
 218     if (length &lt; 1)
 219         return 0;
 220 
 221     bool decimalMarkSeen = false;
 222     int processedLength = 0;
 223 
 224     for (int i = 0; i &lt; length; ++i) {
 225         if (string[i] == terminator) {
 226             processedLength = i;
 227             break;
 228         }
 229         if (!isASCIIDigit(string[i])) {
 230             if (!decimalMarkSeen &amp;&amp; string[i] == &#39;.&#39;)
 231                 decimalMarkSeen = true;
 232             else
 233                 return 0;
 234         }
 235     }
 236 
 237     if (decimalMarkSeen &amp;&amp; processedLength == 1)
 238         return 0;
 239 
 240     return processedLength;
 241 }
 242 
 243 // Returns the number of characters consumed for parsing a valid double
 244 // terminated by the given terminator character
 245 template &lt;typename CharacterType&gt;
 246 static int parseDouble(const CharacterType* string, const CharacterType* end, const char terminator, double&amp; value)
 247 {
 248     int length = checkForValidDouble(string, end, terminator);
 249     if (!length)
 250         return 0;
 251 
 252     int position = 0;
 253     double localValue = 0;
 254 
 255     // The consumed characters here are guaranteed to be
 256     // ASCII digits with or without a decimal mark
 257     for (; position &lt; length; ++position) {
 258         if (string[position] == &#39;.&#39;)
 259             break;
 260         localValue = localValue * 10 + string[position] - &#39;0&#39;;
 261     }
 262 
 263     if (++position == length) {
 264         value = localValue;
 265         return length;
 266     }
 267 
 268     double fraction = 0;
 269     double scale = 1;
 270 
 271     const double maxScale = 1000000;
 272     while (position &lt; length &amp;&amp; scale &lt; maxScale) {
 273         fraction = fraction * 10 + string[position++] - &#39;0&#39;;
 274         scale *= 10;
 275     }
 276 
 277     value = localValue + fraction / scale;
 278     return length;
 279 }
 280 
 281 template &lt;typename CharacterType&gt;
 282 static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSPrimitiveValue::UnitType&amp; expect, int&amp; value)
 283 {
 284     const CharacterType* current = string;
 285     double localValue = 0;
 286     bool negative = false;
 287     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 288         current++;
 289     if (current != end &amp;&amp; *current == &#39;-&#39;) {
 290         negative = true;
 291         current++;
 292     }
 293     if (current == end || !isASCIIDigit(*current))
 294         return false;
 295     while (current != end &amp;&amp; isASCIIDigit(*current)) {
 296         double newValue = localValue * 10 + *current++ - &#39;0&#39;;
 297         if (newValue &gt;= 255) {
 298             // Clamp values at 255.
 299             localValue = 255;
 300             while (current != end &amp;&amp; isASCIIDigit(*current))
 301                 ++current;
 302             break;
 303         }
 304         localValue = newValue;
 305     }
 306 
 307     if (current == end)
 308         return false;
 309 
 310     if (expect == CSSPrimitiveValue::UnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))
 311         return false;
 312 
 313     if (*current == &#39;.&#39;) {
 314         // We already parsed the integral part, try to parse
 315         // the fraction part of the percentage value.
 316         double percentage = 0;
 317         int numCharactersParsed = parseDouble(current, end, &#39;%&#39;, percentage);
 318         if (!numCharactersParsed)
 319             return false;
 320         current += numCharactersParsed;
 321         if (*current != &#39;%&#39;)
 322             return false;
 323         localValue += percentage;
 324     }
 325 
 326     if (expect == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)
 327         return false;
 328 
 329     if (*current == &#39;%&#39;) {
 330         expect = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;
 331         localValue = localValue / 100.0 * 256.0;
 332         // Clamp values at 255 for percentages over 100%
 333         if (localValue &gt; 255)
 334             localValue = 255;
 335         current++;
 336     } else {
 337         expect = CSSPrimitiveValue::UnitType::CSS_NUMBER;
 338     }
 339 
 340     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 341         current++;
 342     if (current == end || *current++ != terminator)
 343         return false;
 344     // Clamp negative values at zero.
 345     value = negative ? 0 : static_cast&lt;int&gt;(localValue);
 346     string = current;
 347     return true;
 348 }
 349 
 350 template &lt;typename CharacterType&gt;
 351 static inline bool isTenthAlpha(const CharacterType* string, const int length)
 352 {
 353     // &quot;0.X&quot;
 354     if (length == 3 &amp;&amp; string[0] == &#39;0&#39; &amp;&amp; string[1] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[2]))
 355         return true;
 356 
 357     // &quot;.X&quot;
 358     if (length == 2 &amp;&amp; string[0] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[1]))
 359         return true;
 360 
 361     return false;
 362 }
 363 
 364 template &lt;typename CharacterType&gt;
 365 static inline bool parseAlphaValue(const CharacterType*&amp; string, const CharacterType* end, const char terminator, int&amp; value)
 366 {
 367     while (string != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*string))
 368         string++;
 369 
 370     bool negative = false;
 371 
 372     if (string != end &amp;&amp; *string == &#39;-&#39;) {
 373         negative = true;
 374         string++;
 375     }
 376 
 377     value = 0;
 378 
 379     int length = end - string;
 380     if (length &lt; 2)
 381         return false;
 382 
 383     if (string[length - 1] != terminator || !isASCIIDigit(string[length - 2]))
 384         return false;
 385 
 386     if (string[0] != &#39;0&#39; &amp;&amp; string[0] != &#39;1&#39; &amp;&amp; string[0] != &#39;.&#39;) {
 387         if (checkForValidDouble(string, end, terminator)) {
 388             value = negative ? 0 : 255;
 389             string = end;
 390             return true;
 391         }
 392         return false;
 393     }
 394 
 395     if (length == 2 &amp;&amp; string[0] != &#39;.&#39;) {
 396         value = !negative &amp;&amp; string[0] == &#39;1&#39; ? 255 : 0;
 397         string = end;
 398         return true;
 399     }
 400 
 401     if (isTenthAlpha(string, length - 1)) {
 402         static const int tenthAlphaValues[] = { 0, 25, 51, 76, 102, 127, 153, 179, 204, 230 };
 403         value = negative ? 0 : tenthAlphaValues[string[length - 2] - &#39;0&#39;];
 404         string = end;
 405         return true;
 406     }
 407 
 408     double alpha = 0;
 409     if (!parseDouble(string, end, terminator, alpha))
 410         return false;
 411     value = negative ? 0 : static_cast&lt;int&gt;(alpha * nextafter(256.0, 0.0));
 412     string = end;
 413     return true;
 414 }
 415 
 416 template &lt;typename CharacterType&gt;
 417 static inline bool mightBeRGBA(const CharacterType* characters, unsigned length)
 418 {
 419     if (length &lt; 5)
 420         return false;
 421     return characters[4] == &#39;(&#39;
 422         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 423         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 424         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;)
 425         &amp;&amp; isASCIIAlphaCaselessEqual(characters[3], &#39;a&#39;);
 426 }
 427 
 428 template &lt;typename CharacterType&gt;
 429 static inline bool mightBeRGB(const CharacterType* characters, unsigned length)
 430 {
 431     if (length &lt; 4)
 432         return false;
 433     return characters[3] == &#39;(&#39;
 434         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 435         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 436         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;);
 437 }
 438 
 439 template &lt;typename CharacterType&gt;
 440 static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
 441 {
 442     CSSPrimitiveValue::UnitType expect = CSSPrimitiveValue::UnitType::CSS_UNKNOWN;
 443 
 444     if (length &gt;= 4 &amp;&amp; characters[0] == &#39;#&#39;) {
 445         RGBA32 rgb;
 446         if (Color::parseHexColor(characters + 1, length - 1, rgb))
 447             return Color(rgb);
 448     }
 449 
 450     if (quirksMode &amp;&amp; (length == 3 || length == 6)) {
 451         RGBA32 rgb;
 452         if (Color::parseHexColor(characters, length, rgb))
 453             return Color(rgb);
 454     }
 455 
 456     // Try rgba() syntax.
 457     if (mightBeRGBA(characters, length)) {
 458         const CharacterType* current = characters + 5;
 459         const CharacterType* end = characters + length;
 460         int red;
 461         int green;
 462         int blue;
 463         int alpha;
 464 
 465         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 466             return Color();
 467         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 468             return Color();
 469         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, blue))
 470             return Color();
 471         if (!parseAlphaValue(current, end, &#39;)&#39;, alpha))
 472             return Color();
 473         if (current != end)
 474             return Color();
 475         return Color(makeRGBA(red, green, blue, alpha));
 476     }
 477 
 478     // Try rgb() syntax.
 479     if (mightBeRGB(characters, length)) {
 480         const CharacterType* current = characters + 4;
 481         const CharacterType* end = characters + length;
 482         int red;
 483         int green;
 484         int blue;
 485         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 486             return Color();
 487         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 488             return Color();
 489         if (!parseColorIntOrPercentage(current, end, &#39;)&#39;, expect, blue))
 490             return Color();
 491         if (current != end)
 492             return Color();
 493         return Color(makeRGB(red, green, blue));
 494     }
 495 
 496     return Color();
 497 }
 498 
 499 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode)
 500 {
 501     ASSERT(!string.isEmpty());
 502     CSSValueID valueID = cssValueKeywordID(string);
 503     if (StyleColor::isColorKeyword(valueID)) {
 504         if (!isValueAllowedInMode(valueID, parserMode))
 505             return nullptr;
 506         return CSSValuePool::singleton().createIdentifierValue(valueID);
 507     }
 508 
 509     bool quirksMode = isQuirksModeBehavior(parserMode);
 510 
 511     // Fast path for hex colors and rgb()/rgba() colors
 512     Color color;
 513     if (string.is8Bit())
 514         color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
 515     else
 516         color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
 517     if (!color.isValid())
 518         return nullptr;
 519     return CSSValuePool::singleton().createColorValue(color);
 520 }
 521 
<a name="2" id="anc2"></a><span class="line-modified"> 522 bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, CSSParserMode parserMode)</span>
 523 {
<a name="3" id="anc3"></a><span class="line-modified"> 524     if (valueID == CSSValueInvalid || !isValueAllowedInMode(valueID, parserMode))</span>




 525         return false;
 526 
 527     switch (propertyId) {
 528     case CSSPropertyAlignmentBaseline:
 529         // auto | baseline | before-edge | text-before-edge | middle |
 530         // central | after-edge | text-after-edge | ideographic | alphabetic |
 531         // hanging | mathematical
 532         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueBaseline
 533             || valueID == CSSValueMiddle || (valueID &gt;= CSSValueBeforeEdge &amp;&amp; valueID &lt;= CSSValueMathematical);
 534     case CSSPropertyAll:
 535         return false; // Only accepts css-wide keywords
 536     case CSSPropertyBackgroundRepeatX: // repeat | no-repeat
 537     case CSSPropertyBackgroundRepeatY: // repeat | no-repeat
 538         return valueID == CSSValueRepeat || valueID == CSSValueNoRepeat;
 539     case CSSPropertyBorderCollapse: // collapse | separate
 540         return valueID == CSSValueCollapse || valueID == CSSValueSeparate;
 541     case CSSPropertyBorderTopStyle: // &lt;border-style&gt;
 542     case CSSPropertyBorderRightStyle: // Defined as: none | hidden | dotted | dashed |
 543     case CSSPropertyBorderBottomStyle: // solid | double | groove | ridge | inset | outset
 544     case CSSPropertyBorderLeftStyle:
 545     case CSSPropertyBorderBlockEndStyle:
 546     case CSSPropertyBorderBlockStartStyle:
 547     case CSSPropertyBorderInlineEndStyle:
 548     case CSSPropertyBorderInlineStartStyle:
 549     case CSSPropertyColumnRuleStyle:
 550         return valueID &gt;= CSSValueNone &amp;&amp; valueID &lt;= CSSValueDouble;
 551     case CSSPropertyBoxSizing:
 552         return valueID == CSSValueBorderBox || valueID == CSSValueContentBox;
 553     case CSSPropertyBufferedRendering:
 554         return valueID == CSSValueAuto || valueID == CSSValueDynamic || valueID == CSSValueStatic;
 555     case CSSPropertyCaptionSide: // top | bottom | left | right
 556         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueTop || valueID == CSSValueBottom;
 557     case CSSPropertyClear: // none | left | right | both
 558         return valueID == CSSValueNone || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueBoth;
 559     case CSSPropertyClipRule:
 560     case CSSPropertyFillRule:
 561         return valueID == CSSValueNonzero || valueID == CSSValueEvenodd;
 562     case CSSPropertyColorInterpolation:
 563     case CSSPropertyColorInterpolationFilters:
 564         return valueID == CSSValueAuto || valueID == CSSValueSRGB || valueID == CSSValueLinearRGB;
 565     case CSSPropertyColorRendering:
 566         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality;
 567     case CSSPropertyDirection: // ltr | rtl
 568         return valueID == CSSValueLtr || valueID == CSSValueRtl;
 569     case CSSPropertyDisplay:
 570         // inline | block | list-item | inline-block | table |
 571         // inline-table | table-row-group | table-header-group | table-footer-group | table-row |
 572         // table-column-group | table-column | table-cell | table-caption | -webkit-box | -webkit-inline-box | none
 573         // flex | inline-flex | -webkit-flex | -webkit-inline-flex | grid | inline-grid
 574         return (valueID &gt;= CSSValueInline &amp;&amp; valueID &lt;= CSSValueContents) || valueID == CSSValueNone
<a name="4" id="anc4"></a><span class="line-modified"> 575             || valueID == CSSValueGrid || valueID == CSSValueInlineGrid;</span>
 576     case CSSPropertyDominantBaseline:
 577         // auto | use-script | no-change | reset-size | ideographic |
 578         // alphabetic | hanging | mathematical | central | middle |
 579         // text-after-edge | text-before-edge
 580         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueMiddle
 581             || (valueID &gt;= CSSValueUseScript &amp;&amp; valueID &lt;= CSSValueResetSize)
 582             || (valueID &gt;= CSSValueCentral &amp;&amp; valueID &lt;= CSSValueMathematical);
 583     case CSSPropertyEmptyCells: // show | hide
 584         return valueID == CSSValueShow || valueID == CSSValueHide;
 585     case CSSPropertyFloat: // left | right | none
 586         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;
 587     case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
 588         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
 589 #if ENABLE(CSS_COMPOSITING)
 590     case CSSPropertyIsolation: // auto | isolate
 591         return valueID == CSSValueAuto || valueID == CSSValueIsolate;
 592 #endif
 593     case CSSPropertyListStylePosition: // inside | outside
 594         return valueID == CSSValueInside || valueID == CSSValueOutside;
 595     case CSSPropertyListStyleType:
 596         // See section CSS_PROP_LIST_STYLE_TYPE of file CSSValueKeywords.in
 597         // for the list of supported list-style-types.
 598         return (valueID &gt;= CSSValueDisc &amp;&amp; valueID &lt;= CSSValueKatakanaIroha) || valueID == CSSValueNone;
 599     case CSSPropertyMaskType:
 600         return valueID == CSSValueLuminance || valueID == CSSValueAlpha;
 601     case CSSPropertyObjectFit:
 602         return valueID == CSSValueFill || valueID == CSSValueContain || valueID == CSSValueCover || valueID == CSSValueNone || valueID == CSSValueScaleDown;
 603     case CSSPropertyOutlineStyle: // (&lt;border-style&gt; except hidden) | auto
 604         return valueID == CSSValueAuto || valueID == CSSValueNone || (valueID &gt;= CSSValueInset &amp;&amp; valueID &lt;= CSSValueDouble);
 605     // FIXME-NEWPARSER: Support?
 606     // case CSSPropertyOverflowAnchor:
 607     //    return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAuto;
 608     case CSSPropertyOverflowWrap: // normal | break-word
 609     case CSSPropertyWordWrap:
 610         return valueID == CSSValueNormal || valueID == CSSValueBreakWord;
 611     case CSSPropertyOverflowX: // visible | hidden | scroll | auto | overlay (overlay is a synonym for auto)
 612         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay;
 613     case CSSPropertyOverflowY: // visible | hidden | scroll | auto | overlay | -webkit-paged-x | -webkit-paged-y (overlay is a synonym for auto)
 614         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay || valueID == CSSValueWebkitPagedX || valueID == CSSValueWebkitPagedY;
 615     case CSSPropertyBreakAfter:
 616     case CSSPropertyBreakBefore:
 617         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValuePage || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueRecto || valueID == CSSValueVerso || valueID == CSSValueAvoidColumn || valueID == CSSValueColumn;
 618     case CSSPropertyBreakInside:
 619         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
 620     case CSSPropertyPointerEvents:
 621         // none | visiblePainted | visibleFill | visibleStroke | visible |
 622         // painted | fill | stroke | auto | all | bounding-box
 623         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);
 624     case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
<a name="5" id="anc5"></a><span class="line-modified"> 625         return valueID == CSSValueStatic || valueID == CSSValueRelative || valueID == CSSValueAbsolute || valueID == CSSValueFixed || valueID == CSSValueWebkitSticky;</span>




 626     case CSSPropertyResize: // none | both | horizontal | vertical | auto
 627         return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
 628     // FIXME-NEWPARSER: Investigate this property.
 629     // case CSSPropertyScrollBehavior: // auto | smooth
 630     //     ASSERT(RuntimeEnabledFeatures::cssomSmoothScrollEnabled());
 631     //   return valueID == CSSValueAuto || valueID == CSSValueSmooth;
 632     case CSSPropertyShapeRendering:
 633         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
 634     case CSSPropertyStrokeLinejoin:
 635         return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
 636     case CSSPropertyStrokeLinecap:
 637         return valueID == CSSValueButt || valueID == CSSValueRound || valueID == CSSValueSquare;
 638     case CSSPropertyTableLayout: // auto | fixed
 639         return valueID == CSSValueAuto || valueID == CSSValueFixed;
 640     case CSSPropertyTextAlign:
 641         return (valueID &gt;= CSSValueWebkitAuto &amp;&amp; valueID &lt;= CSSValueWebkitMatchParent) || valueID == CSSValueStart || valueID == CSSValueEnd;
 642 #if ENABLE(CSS3_TEXT)
 643     case CSSPropertyWebkitTextAlignLast:
 644         // auto | start | end | left | right | center | justify
 645         return (valueID &gt;= CSSValueLeft &amp;&amp; valueID &lt;= CSSValueJustify) || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueAuto;
 646 #endif
 647     case CSSPropertyTextAnchor:
 648         return valueID == CSSValueStart || valueID == CSSValueMiddle || valueID == CSSValueEnd;
 649 // FIXME-NEWPARSER: Support
 650 //    case CSSPropertyTextCombineUpright:
 651 //        return valueID == CSSValueNone || valueID == CSSValueAll;
 652     case CSSPropertyTextDecorationStyle:
 653         // solid | double | dotted | dashed | wavy
 654         return valueID == CSSValueSolid || valueID == CSSValueDouble || valueID == CSSValueDotted || valueID == CSSValueDashed || valueID == CSSValueWavy;
 655 #if ENABLE(CSS3_TEXT)
 656     case CSSPropertyWebkitTextJustify:
 657         // auto | none | inter-word | distribute
 658         return valueID == CSSValueInterWord || valueID == CSSValueDistribute || valueID == CSSValueAuto || valueID == CSSValueNone;
 659 #endif
 660     case CSSPropertyWebkitTextOrientation: // mixed | upright | sideways | sideways-right
 661         return valueID == CSSValueMixed || valueID == CSSValueUpright || valueID == CSSValueSideways || valueID == CSSValueSidewaysRight;
 662     case CSSPropertyTextOverflow: // clip | ellipsis
 663         return valueID == CSSValueClip || valueID == CSSValueEllipsis;
 664     case CSSPropertyTextRendering: // auto | optimizeSpeed | optimizeLegibility | geometricPrecision
 665         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeLegibility || valueID == CSSValueGeometricPrecision;
 666     case CSSPropertyTextTransform: // capitalize | uppercase | lowercase | none
 667         return (valueID &gt;= CSSValueCapitalize &amp;&amp; valueID &lt;= CSSValueLowercase) || valueID == CSSValueNone;
 668     case CSSPropertyUnicodeBidi:
 669         return valueID == CSSValueNormal || valueID == CSSValueEmbed
 670             || valueID == CSSValueBidiOverride
 671             || valueID == CSSValueIsolate || valueID == CSSValueWebkitIsolate
 672             || valueID == CSSValueIsolateOverride || valueID == CSSValueWebkitIsolateOverride
 673             || valueID == CSSValuePlaintext || valueID == CSSValueWebkitPlaintext;
 674     case CSSPropertyVectorEffect:
 675         return valueID == CSSValueNone || valueID == CSSValueNonScalingStroke;
 676     case CSSPropertyVisibility: // visible | hidden | collapse
 677         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueCollapse;
 678     case CSSPropertyWebkitAppearance:
 679         return (valueID &gt;= CSSValueCheckbox &amp;&amp; valueID &lt;= CSSValueCapsLockIndicator) || valueID == CSSValueNone;
 680     case CSSPropertyWebkitBackfaceVisibility:
 681         return valueID == CSSValueVisible || valueID == CSSValueHidden;
 682 #if ENABLE(CSS_COMPOSITING)
 683     case CSSPropertyMixBlendMode:
 684         return valueID == CSSValueNormal || valueID == CSSValueMultiply || valueID == CSSValueScreen || valueID == CSSValueOverlay
 685             || valueID == CSSValueDarken || valueID == CSSValueLighten || valueID == CSSValueColorDodge || valueID == CSSValueColorBurn
 686             || valueID == CSSValueHardLight || valueID == CSSValueSoftLight || valueID == CSSValueDifference || valueID == CSSValueExclusion
 687             || valueID == CSSValueHue || valueID == CSSValueSaturation || valueID == CSSValueColor || valueID == CSSValueLuminosity || valueID == CSSValuePlusDarker || valueID == CSSValuePlusLighter;
 688 #endif
 689     case CSSPropertyWebkitBoxAlign:
 690         return valueID == CSSValueStretch || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueCenter || valueID == CSSValueBaseline;
 691 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 692     case CSSPropertyWebkitBoxDecorationBreak:
 693         return valueID == CSSValueClone || valueID == CSSValueSlice;
 694     case CSSPropertyWebkitBoxDirection:
 695         return valueID == CSSValueNormal || valueID == CSSValueReverse;
 696 #endif
 697     case CSSPropertyWebkitBoxLines:
 698         return valueID == CSSValueSingle || valueID == CSSValueMultiple;
 699     case CSSPropertyWebkitBoxOrient:
 700         return valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueInlineAxis || valueID == CSSValueBlockAxis;
 701     case CSSPropertyWebkitBoxPack:
 702         return valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueCenter || valueID == CSSValueJustify;
 703 #if ENABLE(CURSOR_VISIBILITY)
 704     case CSSPropertyWebkitCursorVisibility:
 705         return valueID == CSSValueAuto || valueID == CSSValueAutoHide;
 706 #endif
 707     case CSSPropertyColumnFill:
 708         return valueID == CSSValueAuto || valueID == CSSValueBalance;
 709     case CSSPropertyWebkitColumnAxis:
 710         return valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
 711     case CSSPropertyWebkitColumnProgression:
 712         return valueID == CSSValueNormal || valueID == CSSValueReverse;
 713     case CSSPropertyFlexDirection:
 714         return valueID == CSSValueRow || valueID == CSSValueRowReverse || valueID == CSSValueColumn || valueID == CSSValueColumnReverse;
 715     case CSSPropertyFlexWrap:
 716         return valueID == CSSValueNowrap || valueID == CSSValueWrap || valueID == CSSValueWrapReverse;
 717     case CSSPropertyWebkitHyphens:
 718         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueManual;
 719     case CSSPropertyWebkitFontKerning:
 720         return valueID == CSSValueAuto || valueID == CSSValueNormal || valueID == CSSValueNone;
 721     case CSSPropertyWebkitFontSmoothing:
 722         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueAntialiased || valueID == CSSValueSubpixelAntialiased;
 723     case CSSPropertyWebkitLineAlign:
 724         return valueID == CSSValueNone || valueID == CSSValueEdges;
<a name="6" id="anc6"></a><span class="line-modified"> 725     case CSSPropertyLineBreak: // auto | loose | normal | strict | after-white-space</span>
<span class="line-modified"> 726         return valueID == CSSValueAuto || valueID == CSSValueLoose || valueID == CSSValueNormal || valueID == CSSValueStrict || valueID == CSSValueAfterWhiteSpace;</span>
 727     case CSSPropertyWebkitLineSnap:
 728         return valueID == CSSValueNone || valueID == CSSValueBaseline || valueID == CSSValueContain;
 729     case CSSPropertyWebkitMarginAfterCollapse:
 730     case CSSPropertyWebkitMarginBeforeCollapse:
 731     case CSSPropertyWebkitMarginBottomCollapse:
 732     case CSSPropertyWebkitMarginTopCollapse:
 733         return valueID == CSSValueCollapse || valueID == CSSValueSeparate || valueID == CSSValueDiscard;
 734     case CSSPropertyWebkitPrintColorAdjust:
 735         return valueID == CSSValueExact || valueID == CSSValueEconomy;
 736     case CSSPropertyWebkitRtlOrdering:
 737         return valueID == CSSValueLogical || valueID == CSSValueVisual;
 738     case CSSPropertyWebkitRubyPosition:
 739         return valueID == CSSValueBefore || valueID == CSSValueAfter || valueID == CSSValueInterCharacter;
 740     case CSSPropertyWebkitTextCombine:
 741         return valueID == CSSValueNone || valueID == CSSValueHorizontal;
 742     case CSSPropertyWebkitTextSecurity: // disc | circle | square | none
 743         return valueID == CSSValueDisc || valueID == CSSValueCircle || valueID == CSSValueSquare || valueID == CSSValueNone;
 744     case CSSPropertyTransformStyle:
 745     case CSSPropertyWebkitTransformStyle:
 746         return valueID == CSSValueFlat || valueID == CSSValuePreserve3d;
 747     case CSSPropertyWebkitUserDrag: // auto | none | element
 748         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueElement;
 749     case CSSPropertyWebkitUserModify: // read-only | read-write
 750         return valueID == CSSValueReadOnly || valueID == CSSValueReadWrite || valueID == CSSValueReadWritePlaintextOnly;
 751     case CSSPropertyWebkitUserSelect: // auto | none | text | all
 752         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueText || valueID == CSSValueAll;
 753     case CSSPropertyWritingMode:
 754         // Note that horizontal-bt is not supported by the unprefixed version of
 755         // the property, only by the -webkit- version.
 756         return (valueID &gt;= CSSValueHorizontalTb &amp;&amp; valueID &lt;= CSSValueHorizontalBt)
 757             || valueID == CSSValueLrTb || valueID == CSSValueRlTb || valueID == CSSValueTbRl
 758             || valueID == CSSValueLr || valueID == CSSValueRl || valueID == CSSValueTb;
<a name="7" id="anc7"></a><span class="line-modified"> 759     case CSSPropertyWhiteSpace: // normal | pre | nowrap</span>
<span class="line-modified"> 760         return valueID == CSSValueNormal || valueID == CSSValuePre || valueID == CSSValuePreWrap || valueID == CSSValuePreLine || valueID == CSSValueNowrap;</span>
 761     case CSSPropertyWordBreak: // normal | break-all | keep-all | break-word (this is a custom extension)
 762         return valueID == CSSValueNormal || valueID == CSSValueBreakAll || valueID == CSSValueKeepAll || valueID == CSSValueBreakWord;
 763     case CSSPropertyWebkitBorderFit:
 764         return valueID == CSSValueBorder || valueID == CSSValueLines;
 765 #if ENABLE(CSS_TRAILING_WORD)
 766     case CSSPropertyAppleTrailingWord: // auto | -apple-partially-balanced
 767         return valueID == CSSValueAuto || valueID == CSSValueWebkitPartiallyBalanced;
 768 #endif
 769 #if ENABLE(APPLE_PAY)
 770     case CSSPropertyApplePayButtonStyle: // white | white-outline | black
 771         return valueID == CSSValueWhite || valueID == CSSValueWhiteOutline || valueID == CSSValueBlack;
 772     case CSSPropertyApplePayButtonType: // plain | buy | set-up | donate
 773         if (valueID == CSSValuePlain || valueID == CSSValueBuy || valueID == CSSValueSetUp || valueID == CSSValueDonate)
 774             return true;
 775 #if ENABLE(APPLE_PAY_SESSION_V4)
 776         // check-out | book | subscribe
 777         return valueID == CSSValueCheckOut || valueID == CSSValueBook || valueID == CSSValueSubscribe;
 778 #else
 779         return false;
 780 #endif
 781 #endif
 782     case CSSPropertyWebkitNbspMode: // normal | space
 783         return valueID == CSSValueNormal || valueID == CSSValueSpace;
 784     case CSSPropertyWebkitTextZoom:
 785         return valueID == CSSValueNormal || valueID == CSSValueReset;
 786 #if PLATFORM(IOS_FAMILY)
 787     // Apple specific property. These will never be standardized and is purely to
 788     // support custom WebKit-based Apple applications.
 789     case CSSPropertyWebkitTouchCallout:
 790         return valueID == CSSValueDefault || valueID == CSSValueNone;
 791 #endif
 792     case CSSPropertyWebkitMarqueeDirection:
 793         return valueID == CSSValueForwards || valueID == CSSValueBackwards || valueID == CSSValueAhead || valueID == CSSValueReverse || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueDown
 794             || valueID == CSSValueUp || valueID == CSSValueAuto;
 795     case CSSPropertyWebkitMarqueeStyle:
 796         return valueID == CSSValueNone || valueID == CSSValueSlide || valueID == CSSValueScroll || valueID == CSSValueAlternate;
 797     case CSSPropertyFontVariantPosition: // normal | sub | super
 798         return valueID == CSSValueNormal || valueID == CSSValueSub || valueID == CSSValueSuper;
 799     case CSSPropertyFontVariantCaps: // normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps
 800         return valueID == CSSValueNormal || valueID == CSSValueSmallCaps || valueID == CSSValueAllSmallCaps || valueID == CSSValuePetiteCaps || valueID == CSSValueAllPetiteCaps || valueID == CSSValueUnicase || valueID == CSSValueTitlingCaps;
 801     case CSSPropertyFontVariantAlternates: // We only support the normal and historical-forms values.
 802         return valueID == CSSValueNormal || valueID == CSSValueHistoricalForms;
<a name="8" id="anc8"></a><span class="line-modified"> 803 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 804     case CSSPropertyWebkitOverflowScrolling:
<a name="9" id="anc9"></a>

 805         return valueID == CSSValueAuto || valueID == CSSValueTouch;
 806 #endif
 807 #if ENABLE(VARIATION_FONTS)
 808     case CSSPropertyFontOpticalSizing:
 809         return valueID == CSSValueAuto || valueID == CSSValueNone;
 810 #endif
 811     default:
 812         ASSERT_NOT_REACHED();
 813         return false;
 814     }
 815 }
 816 
 817 bool CSSParserFastPaths::isKeywordPropertyID(CSSPropertyID propertyId)
 818 {
 819     switch (propertyId) {
 820     case CSSPropertyBorderBlockEndStyle:
 821     case CSSPropertyBorderBlockStartStyle:
 822     case CSSPropertyBorderBottomStyle:
 823     case CSSPropertyBorderCollapse:
 824     case CSSPropertyBorderInlineEndStyle:
 825     case CSSPropertyBorderInlineStartStyle:
 826     case CSSPropertyBorderLeftStyle:
 827     case CSSPropertyBorderRightStyle:
 828     case CSSPropertyBorderTopStyle:
 829     case CSSPropertyBoxSizing:
 830     case CSSPropertyBreakAfter:
 831     case CSSPropertyBreakBefore:
 832     case CSSPropertyBreakInside:
 833     case CSSPropertyCaptionSide:
 834     case CSSPropertyClear:
 835     case CSSPropertyColumnFill:
 836     case CSSPropertyWebkitColumnProgression:
 837     case CSSPropertyColumnRuleStyle:
 838     case CSSPropertyDirection:
 839     case CSSPropertyDisplay:
 840     case CSSPropertyEmptyCells:
 841     case CSSPropertyFlexDirection:
 842     case CSSPropertyFlexWrap:
 843     case CSSPropertyFloat:
 844     case CSSPropertyFontVariantAlternates:
 845     case CSSPropertyFontVariantCaps:
 846     case CSSPropertyFontVariantPosition:
 847     case CSSPropertyImageRendering:
 848     case CSSPropertyListStylePosition:
 849     case CSSPropertyListStyleType:
 850     case CSSPropertyObjectFit:
 851     case CSSPropertyOutlineStyle:
 852     case CSSPropertyOverflowWrap:
 853     case CSSPropertyOverflowX:
 854     case CSSPropertyOverflowY:
 855     case CSSPropertyPointerEvents:
 856     case CSSPropertyPosition:
 857     case CSSPropertyResize:
 858     case CSSPropertyTableLayout:
 859     case CSSPropertyTextAlign:
 860     case CSSPropertyTextOverflow:
 861     case CSSPropertyTextRendering:
 862     case CSSPropertyTextTransform:
 863     case CSSPropertyTransformStyle:
 864     case CSSPropertyUnicodeBidi:
 865     case CSSPropertyVisibility:
 866     case CSSPropertyWebkitAppearance:
 867     case CSSPropertyWebkitBackfaceVisibility:
 868     case CSSPropertyWebkitBorderFit:
 869     case CSSPropertyWebkitBoxAlign:
 870     case CSSPropertyWebkitBoxDirection:
 871     case CSSPropertyWebkitBoxLines:
 872     case CSSPropertyWebkitBoxOrient:
 873     case CSSPropertyWebkitBoxPack:
 874     case CSSPropertyWebkitColumnAxis:
 875     case CSSPropertyWebkitFontKerning:
 876     case CSSPropertyWebkitFontSmoothing:
 877     case CSSPropertyWebkitHyphens:
 878     case CSSPropertyWebkitLineAlign:
 879     case CSSPropertyLineBreak:
 880     case CSSPropertyWebkitLineSnap:
 881     case CSSPropertyWebkitMarginAfterCollapse:
 882     case CSSPropertyWebkitMarginBeforeCollapse:
 883     case CSSPropertyWebkitMarginBottomCollapse:
 884     case CSSPropertyWebkitMarginTopCollapse:
 885     case CSSPropertyWebkitMarqueeDirection:
 886     case CSSPropertyWebkitMarqueeStyle:
 887     case CSSPropertyWebkitNbspMode:
 888     case CSSPropertyWebkitPrintColorAdjust:
 889     case CSSPropertyWebkitRtlOrdering:
 890     case CSSPropertyWebkitRubyPosition:
 891     case CSSPropertyWebkitTextCombine:
 892     case CSSPropertyTextDecorationStyle:
 893     case CSSPropertyWebkitTextOrientation:
 894     case CSSPropertyWebkitTextSecurity:
 895     case CSSPropertyWebkitTextZoom:
 896     case CSSPropertyWebkitTransformStyle:
 897     case CSSPropertyWebkitUserDrag:
 898     case CSSPropertyWebkitUserModify:
 899     case CSSPropertyWebkitUserSelect:
 900     case CSSPropertyWhiteSpace:
 901     case CSSPropertyWordBreak:
 902     case CSSPropertyWordWrap:
 903 
 904     // SVG CSS properties from SVG 1.1, Appendix N: Property Index.
 905     case CSSPropertyAlignmentBaseline:
 906     case CSSPropertyBufferedRendering:
 907     case CSSPropertyClipRule:
 908     case CSSPropertyColorInterpolation:
 909     case CSSPropertyColorInterpolationFilters:
 910     case CSSPropertyColorRendering:
 911     case CSSPropertyDominantBaseline:
 912     case CSSPropertyFillRule:
 913     case CSSPropertyMaskType:
 914     case CSSPropertyShapeRendering:
 915     case CSSPropertyStrokeLinecap:
 916     case CSSPropertyStrokeLinejoin:
 917     case CSSPropertyTextAnchor:
 918     case CSSPropertyVectorEffect:
 919     case CSSPropertyWritingMode:
 920 
 921     // FIXME-NEWPARSER: Treat all as a keyword property.
 922     // case CSSPropertyAll:
 923 
 924     // FIXME-NEWPARSER: Add the following unprefixed properties:
 925     // case CSSPropertyBackfaceVisibility:
 926     // case CSSPropertyFontKerning:
 927     // case CSSPropertyHyphens:
 928     // case CSSPropertyOverflowAnchor:
 929     // case CSSPropertyScrollBehavior:
 930     // case CSSPropertyScrollSnapType:
 931     // case CSSPropertyTextAlignLast:
 932     // case CSSPropertyTextCombineUpright:
 933     // case CSSPropertyTextDecorationStyle:
 934     // case CSSPropertyTextJustify:
 935     // case CSSPropertyTextOrientation:
 936     // case CSSPropertyUserSelect:
 937 #if ENABLE(CSS_TRAILING_WORD)
 938     case CSSPropertyAppleTrailingWord:
 939 #endif
 940 #if ENABLE(CSS_COMPOSITING)
 941     case CSSPropertyIsolation:
 942     case CSSPropertyMixBlendMode:
 943 #endif
 944 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 945     case CSSPropertyWebkitBoxDecorationBreak:
 946 #endif
 947 #if ENABLE(CURSOR_VISIBILITY)
 948     case CSSPropertyWebkitCursorVisibility:
 949 #endif
<a name="10" id="anc10"></a><span class="line-modified"> 950 #if ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
 951     case CSSPropertyWebkitOverflowScrolling:
 952 #endif
 953 #if ENABLE(CSS3_TEXT)
 954     case CSSPropertyWebkitTextAlignLast:
 955     case CSSPropertyWebkitTextJustify:
 956 #endif
 957 #if PLATFORM(IOS_FAMILY)
 958     // Apple specific property. This will never be standardized and is purely to
 959     // support custom WebKit-based Apple applications.
 960     case CSSPropertyWebkitTouchCallout:
 961 #endif
 962 #if ENABLE(APPLE_PAY)
 963     case CSSPropertyApplePayButtonStyle:
 964     case CSSPropertyApplePayButtonType:
 965 #endif
 966 #if ENABLE(VARIATION_FONTS)
 967     case CSSPropertyFontOpticalSizing:
 968 #endif
 969         return true;
 970     default:
 971         return false;
 972     }
 973 }
 974 
 975 static bool isUniversalKeyword(const String&amp; string)
 976 {
 977     // These keywords can be used for all properties.
 978     return equalLettersIgnoringASCIICase(string, &quot;initial&quot;)
 979     || equalLettersIgnoringASCIICase(string, &quot;inherit&quot;)
 980     || equalLettersIgnoringASCIICase(string, &quot;unset&quot;)
 981     || equalLettersIgnoringASCIICase(string, &quot;revert&quot;);
 982 }
 983 
<a name="11" id="anc11"></a><span class="line-modified"> 984 static RefPtr&lt;CSSValue&gt; parseKeywordValue(CSSPropertyID propertyId, const String&amp; string, CSSParserMode parserMode)</span>
 985 {
 986     ASSERT(!string.isEmpty());
 987 
 988     if (!CSSParserFastPaths::isKeywordPropertyID(propertyId)) {
 989         // All properties accept the values of &quot;initial&quot; and &quot;inherit&quot;.
 990         if (!isUniversalKeyword(string))
 991             return nullptr;
 992 
 993         // Parse initial/inherit shorthands using the CSSPropertyParser.
 994         if (shorthandForProperty(propertyId).length())
 995             return nullptr;
 996 
 997         // Descriptors do not support css wide keywords.
 998         if (CSSProperty::isDescriptorOnly(propertyId))
 999             return nullptr;
1000     }
1001 
1002     CSSValueID valueID = cssValueKeywordID(string);
1003 
1004     if (!valueID)
1005         return nullptr;
1006 
1007     if (valueID == CSSValueInherit)
1008         return CSSValuePool::singleton().createInheritedValue();
1009     if (valueID == CSSValueInitial)
1010         return CSSValuePool::singleton().createExplicitInitialValue();
1011     if (valueID == CSSValueUnset)
1012         return CSSValuePool::singleton().createUnsetValue();
1013     if (valueID == CSSValueRevert)
1014         return CSSValuePool::singleton().createRevertValue();
1015 
<a name="12" id="anc12"></a><span class="line-modified">1016     if (CSSParserFastPaths::isValidKeywordPropertyAndValue(propertyId, valueID, parserMode))</span>
1017         return CSSPrimitiveValue::createIdentifier(valueID);
1018     return nullptr;
1019 }
1020 
1021 template &lt;typename CharType&gt;
1022 static bool parseTransformTranslateArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1023 {
1024     while (expectedCount) {
1025         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1026         if (delimiter == notFound)
1027             return false;
1028         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1029         CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
1030         double number;
1031         if (!parseSimpleLength(pos, argumentLength, unit, number))
1032             return false;
1033         if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)
1034             unit = CSSPrimitiveValue::UnitType::CSS_PX;
1035         if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER || (unit == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))
1036             return false;
1037         transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1038         pos += argumentLength + 1;
1039         --expectedCount;
1040     }
1041     return true;
1042 }
1043 
1044 template &lt;typename CharType&gt;
1045 static bool parseTransformAngleArgument(CharType*&amp; pos, CharType* end, CSSFunctionValue* transformValue)
1046 {
1047     size_t delimiter = WTF::find(pos, end - pos, &#39;)&#39;);
1048     if (delimiter == notFound)
1049         return false;
1050 
1051     unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1052     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
1053     double number;
1054     if (!parseSimpleAngle(pos, argumentLength, unit, number))
1055         return false;
1056     if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)
1057         unit = CSSPrimitiveValue::UnitType::CSS_DEG;
1058 
1059     transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1060     pos += argumentLength + 1;
1061 
1062     return true;
1063 }
1064 
1065 template &lt;typename CharType&gt;
1066 static bool parseTransformNumberArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1067 {
1068     while (expectedCount) {
1069         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1070         if (delimiter == notFound)
1071             return false;
1072         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1073         bool ok;
1074         double number = charactersToDouble(pos, argumentLength, &amp;ok);
1075         if (!ok)
1076             return false;
1077         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSPrimitiveValue::UnitType::CSS_NUMBER));
1078         pos += argumentLength + 1;
1079         --expectedCount;
1080     }
1081     return true;
1082 }
1083 
1084 static const int kShortestValidTransformStringLength = 9; // &quot;rotate(0)&quot;
1085 
1086 template &lt;typename CharType&gt;
1087 static RefPtr&lt;CSSFunctionValue&gt; parseSimpleTransformValue(CharType*&amp; pos, CharType* end)
1088 {
1089     if (end - pos &lt; kShortestValidTransformStringLength)
1090         return nullptr;
1091 
1092     const bool isTranslate = toASCIILower(pos[0]) == &#39;t&#39;
1093         &amp;&amp; toASCIILower(pos[1]) == &#39;r&#39;
1094         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1095         &amp;&amp; toASCIILower(pos[3]) == &#39;n&#39;
1096         &amp;&amp; toASCIILower(pos[4]) == &#39;s&#39;
1097         &amp;&amp; toASCIILower(pos[5]) == &#39;l&#39;
1098         &amp;&amp; toASCIILower(pos[6]) == &#39;a&#39;
1099         &amp;&amp; toASCIILower(pos[7]) == &#39;t&#39;
1100         &amp;&amp; toASCIILower(pos[8]) == &#39;e&#39;;
1101 
1102     if (isTranslate) {
1103         CSSValueID transformType;
1104         unsigned expectedArgumentCount = 1;
1105         unsigned argumentStart = 11;
1106         CharType c9 = toASCIILower(pos[9]);
1107         if (c9 == &#39;x&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1108             transformType = CSSValueTranslateX;
1109         } else if (c9 == &#39;y&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1110             transformType = CSSValueTranslateY;
1111         } else if (c9 == &#39;z&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1112             transformType = CSSValueTranslateZ;
1113         } else if (c9 == &#39;(&#39;) {
1114             transformType = CSSValueTranslate;
1115             expectedArgumentCount = 2;
1116             argumentStart = 10;
1117         } else if (c9 == &#39;3&#39; &amp;&amp; toASCIILower(pos[10]) == &#39;d&#39; &amp;&amp; pos[11] == &#39;(&#39;) {
1118             transformType = CSSValueTranslate3d;
1119             expectedArgumentCount = 3;
1120             argumentStart = 12;
1121         } else
1122             return nullptr;
1123 
1124         pos += argumentStart;
1125         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(transformType);
1126         if (!parseTransformTranslateArguments(pos, end, expectedArgumentCount, transformValue.get()))
1127             return nullptr;
1128         return transformValue;
1129     }
1130 
1131     const bool isMatrix3d = toASCIILower(pos[0]) == &#39;m&#39;
1132         &amp;&amp; toASCIILower(pos[1]) == &#39;a&#39;
1133         &amp;&amp; toASCIILower(pos[2]) == &#39;t&#39;
1134         &amp;&amp; toASCIILower(pos[3]) == &#39;r&#39;
1135         &amp;&amp; toASCIILower(pos[4]) == &#39;i&#39;
1136         &amp;&amp; toASCIILower(pos[5]) == &#39;x&#39;
1137         &amp;&amp; pos[6] == &#39;3&#39;
1138         &amp;&amp; toASCIILower(pos[7]) == &#39;d&#39;
1139         &amp;&amp; pos[8] == &#39;(&#39;;
1140 
1141     if (isMatrix3d) {
1142         pos += 9;
1143         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
1144         if (!parseTransformNumberArguments(pos, end, 16, transformValue.get()))
1145             return nullptr;
1146         return transformValue;
1147     }
1148 
1149     const bool isScale3d = toASCIILower(pos[0]) == &#39;s&#39;
1150         &amp;&amp; toASCIILower(pos[1]) == &#39;c&#39;
1151         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1152         &amp;&amp; toASCIILower(pos[3]) == &#39;l&#39;
1153         &amp;&amp; toASCIILower(pos[4]) == &#39;e&#39;
1154         &amp;&amp; pos[5] == &#39;3&#39;
1155         &amp;&amp; toASCIILower(pos[6]) == &#39;d&#39;
1156         &amp;&amp; pos[7] == &#39;(&#39;;
1157 
1158     if (isScale3d) {
1159         pos += 8;
1160         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(CSSValueScale3d);
1161         if (!parseTransformNumberArguments(pos, end, 3, transformValue.get()))
1162             return nullptr;
1163         return transformValue;
1164     }
1165 
1166     const bool isRotate = toASCIILower(pos[0]) == &#39;r&#39;
1167         &amp;&amp; toASCIILower(pos[1]) == &#39;o&#39;
1168         &amp;&amp; toASCIILower(pos[2]) == &#39;t&#39;
1169         &amp;&amp; toASCIILower(pos[3]) == &#39;a&#39;
1170         &amp;&amp; toASCIILower(pos[4]) == &#39;t&#39;
1171         &amp;&amp; toASCIILower(pos[5]) == &#39;e&#39;;
1172 
1173     if (isRotate) {
1174         CSSValueID transformType;
1175         unsigned argumentStart = 7;
1176         CharType c6 = toASCIILower(pos[6]);
1177         if (c6 == &#39;(&#39;) {
1178             transformType = CSSValueRotate;
1179         } else if (c6 == &#39;z&#39; &amp;&amp; pos[7] == &#39;(&#39;) {
1180             transformType = CSSValueRotateZ;
1181             argumentStart = 8;
1182         } else
1183             return nullptr;
1184 
1185         pos += argumentStart;
1186         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(transformType);
1187         if (!parseTransformAngleArgument(pos, end, transformValue.get()))
1188             return nullptr;
1189         return transformValue;
1190     }
1191 
1192     return nullptr;
1193 }
1194 
1195 template &lt;typename CharType&gt;
1196 static bool transformCanLikelyUseFastPath(const CharType* chars, unsigned length)
1197 {
1198     // Very fast scan that attempts to reject most transforms that couldn&#39;t
1199     // take the fast path. This avoids doing the malloc and string-&gt;double
1200     // conversions in parseSimpleTransformValue only to discard them when we
1201     // run into a transform component we don&#39;t understand.
1202     unsigned i = 0;
1203     while (i &lt; length) {
1204         if (isCSSSpace(chars[i])) {
1205             ++i;
1206             continue;
1207         }
1208 
1209         if (length - i &lt; kShortestValidTransformStringLength)
1210             return false;
1211 
1212         switch (toASCIILower(chars[i])) {
1213         case &#39;t&#39;:
1214             // translate, translateX, translateY, translateZ, translate3d.
1215             if (toASCIILower(chars[i + 8]) != &#39;e&#39;)
1216                 return false;
1217             i += 9;
1218             break;
1219         case &#39;m&#39;:
1220             // matrix3d.
1221             if (toASCIILower(chars[i + 7]) != &#39;d&#39;)
1222                 return false;
1223             i += 8;
1224             break;
1225         case &#39;s&#39;:
1226             // scale3d.
1227             if (toASCIILower(chars[i + 6]) != &#39;d&#39;)
1228                 return false;
1229             i += 7;
1230             break;
1231         case &#39;r&#39;:
1232             // rotate.
1233             if (toASCIILower(chars[i + 5]) != &#39;e&#39;)
1234                 return false;
1235             i += 6;
1236             // rotateZ
1237             if (toASCIILower(chars[i]) == &#39;z&#39;)
1238                 ++i;
1239             break;
1240 
1241         default:
1242             return false;
1243         }
1244         size_t argumentsEnd = WTF::find(chars, length, &#39;)&#39;, i);
1245         if (argumentsEnd == notFound)
1246             return false;
1247         // Advance to the end of the arguments.
1248         i = argumentsEnd + 1;
1249     }
1250     return i == length;
1251 }
1252 
1253 template &lt;typename CharType&gt;
1254 static RefPtr&lt;CSSValueList&gt; parseSimpleTransformList(const CharType* chars, unsigned length)
1255 {
1256     if (!transformCanLikelyUseFastPath(chars, length))
1257         return nullptr;
1258     const CharType*&amp; pos = chars;
1259     const CharType* end = chars + length;
1260     RefPtr&lt;CSSValueList&gt; transformList;
1261     while (pos &lt; end) {
1262         while (pos &lt; end &amp;&amp; isCSSSpace(*pos))
1263             ++pos;
1264         if (pos &gt;= end)
1265             break;
1266         RefPtr&lt;CSSFunctionValue&gt; transformValue = parseSimpleTransformValue(pos, end);
1267         if (!transformValue)
1268             return nullptr;
1269         if (!transformList)
1270             transformList = CSSValueList::createSpaceSeparated();
1271         transformList-&gt;append(*transformValue);
1272     }
1273     return transformList;
1274 }
1275 
1276 static RefPtr&lt;CSSValue&gt; parseSimpleTransform(CSSPropertyID propertyID, const String&amp; string)
1277 {
1278     ASSERT(!string.isEmpty());
1279     if (propertyID != CSSPropertyTransform)
1280         return nullptr;
1281     if (string.is8Bit())
1282         return parseSimpleTransformList(string.characters8(), string.length());
1283     return parseSimpleTransformList(string.characters16(), string.length());
1284 }
1285 
1286 static RefPtr&lt;CSSValue&gt; parseCaretColor(const String&amp; string, CSSParserMode parserMode)
1287 {
1288     ASSERT(!string.isEmpty());
1289     CSSValueID valueID = cssValueKeywordID(string);
1290     if (valueID == CSSValueAuto)
1291         return CSSValuePool::singleton().createIdentifierValue(valueID);
1292     return CSSParserFastPaths::parseColor(string, parserMode);
1293 }
1294 
<a name="13" id="anc13"></a><span class="line-modified">1295 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String&amp; string, CSSParserMode parserMode)</span>
1296 {
<a name="14" id="anc14"></a><span class="line-modified">1297     if (auto result = parseSimpleLengthValue(propertyID, string, parserMode))</span>
1298         return result;
1299     if (propertyID == CSSPropertyCaretColor)
<a name="15" id="anc15"></a><span class="line-modified">1300         return parseCaretColor(string, parserMode);</span>
1301     if (isColorPropertyID(propertyID))
<a name="16" id="anc16"></a><span class="line-modified">1302         return parseColor(string, parserMode);</span>
<span class="line-modified">1303     if (auto result = parseKeywordValue(propertyID, string, parserMode))</span>
1304         return result;
1305     return parseSimpleTransform(propertyID, string);
1306 }
1307 
1308 } // namespace WebCore
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>