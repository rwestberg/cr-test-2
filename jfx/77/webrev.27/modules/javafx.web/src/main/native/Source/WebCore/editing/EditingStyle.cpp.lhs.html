<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007, 2008, 2009, 2013 Apple Inc.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  15  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  16  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  17  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  18  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  19  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  20  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  21  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  22  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;EditingStyle.h&quot;
  29 
  30 #include &quot;ApplyStyleCommand.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
<a name="1" id="anc1"></a>
  32 #include &quot;CSSFontStyleValue.h&quot;
  33 #include &quot;CSSParser.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;CSSStyleRule.h&quot;
  36 #include &quot;CSSValueList.h&quot;
  37 #include &quot;CSSValuePool.h&quot;
  38 #include &quot;Editing.h&quot;
  39 #include &quot;Editor.h&quot;
<a name="2" id="anc2"></a>

  40 #include &quot;Frame.h&quot;
  41 #include &quot;HTMLFontElement.h&quot;
  42 #include &quot;HTMLInterchange.h&quot;
  43 #include &quot;HTMLNames.h&quot;
  44 #include &quot;HTMLSpanElement.h&quot;
  45 #include &quot;Node.h&quot;
  46 #include &quot;NodeTraversal.h&quot;
  47 #include &quot;QualifiedName.h&quot;
  48 #include &quot;RenderElement.h&quot;
  49 #include &quot;RenderStyle.h&quot;
  50 #include &quot;StyleFontSizeFunctions.h&quot;
  51 #include &quot;StyleProperties.h&quot;
  52 #include &quot;StyleResolver.h&quot;
  53 #include &quot;StyleRule.h&quot;
  54 #include &quot;StyledElement.h&quot;
  55 #include &quot;VisibleUnits.h&quot;
<a name="3" id="anc3"></a>
  56 
  57 namespace WebCore {
  58 
  59 // Editing style properties must be preserved during editing operation.
  60 // e.g. when a user inserts a new paragraph, all properties listed here must be copied to the new paragraph.
  61 static const CSSPropertyID editingProperties[] = {
  62     CSSPropertyCaretColor,
  63     CSSPropertyColor,
  64     CSSPropertyFontFamily,
  65     CSSPropertyFontSize,
  66     CSSPropertyFontStyle,
  67     CSSPropertyFontVariantCaps,
  68     CSSPropertyFontWeight,
  69     CSSPropertyLetterSpacing,
  70     CSSPropertyOrphans,
  71     CSSPropertyTextAlign,
  72     CSSPropertyTextIndent,
  73     CSSPropertyTextTransform,
  74     CSSPropertyWhiteSpace,
  75     CSSPropertyWidows,
  76     CSSPropertyWordSpacing,
  77 #if ENABLE(TOUCH_EVENTS)
  78     CSSPropertyWebkitTapHighlightColor,
  79 #endif
  80     CSSPropertyWebkitTextDecorationsInEffect,
  81     CSSPropertyWebkitTextFillColor,
  82 #if ENABLE(TEXT_AUTOSIZING)
  83     CSSPropertyWebkitTextSizeAdjust,
  84 #endif
  85     CSSPropertyWebkitTextStrokeColor,
  86     CSSPropertyWebkitTextStrokeWidth,
  87 
  88     // Non-inheritable properties
  89     CSSPropertyBackgroundColor,
  90     CSSPropertyTextDecoration,
  91 };
  92 
  93 const unsigned numAllEditingProperties = WTF_ARRAY_LENGTH(editingProperties);
  94 const unsigned numInheritableEditingProperties = numAllEditingProperties - 2;
  95 
  96 enum EditingPropertiesToInclude { OnlyInheritableEditingProperties, AllEditingProperties };
  97 template &lt;class StyleDeclarationType&gt;
  98 static Ref&lt;MutableStyleProperties&gt; copyEditingProperties(StyleDeclarationType* style, EditingPropertiesToInclude type)
  99 {
 100     if (type == AllEditingProperties)
 101         return style-&gt;copyPropertiesInSet(editingProperties, numAllEditingProperties);
 102     return style-&gt;copyPropertiesInSet(editingProperties, numInheritableEditingProperties);
 103 }
 104 
 105 static inline bool isEditingProperty(int id)
 106 {
 107     for (auto&amp; editingProperty : editingProperties) {
 108         if (editingProperty == id)
 109             return true;
 110     }
 111     return false;
 112 }
 113 
 114 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(ComputedStyleExtractor&amp; computedStyle, EditingStyle::PropertiesToInclude propertiesToInclude)
 115 {
 116     switch (propertiesToInclude) {
 117     case EditingStyle::OnlyEditingInheritableProperties:
 118         return copyEditingProperties(&amp;computedStyle, OnlyInheritableEditingProperties);
 119     case EditingStyle::EditingPropertiesInEffect:
 120         return copyEditingProperties(&amp;computedStyle, AllEditingProperties);
 121     case EditingStyle::AllProperties:
 122         break;
 123     }
 124     return computedStyle.copyProperties();
 125 }
 126 
 127 static Ref&lt;MutableStyleProperties&gt; copyPropertiesFromComputedStyle(Node* node, EditingStyle::PropertiesToInclude propertiesToInclude)
 128 {
 129     ComputedStyleExtractor computedStyle(node);
 130     return copyPropertiesFromComputedStyle(computedStyle, propertiesToInclude);
 131 }
 132 
 133 static RefPtr&lt;CSSValue&gt; extractPropertyValue(const StyleProperties&amp; style, CSSPropertyID propertyID)
 134 {
 135     return style.getPropertyCSSValue(propertyID);
 136 }
 137 
 138 static RefPtr&lt;CSSValue&gt; extractPropertyValue(ComputedStyleExtractor&amp; computedStyle, CSSPropertyID propertyID)
 139 {
 140     return computedStyle.propertyValue(propertyID);
 141 }
 142 
 143 template&lt;typename T&gt;
 144 int identifierForStyleProperty(T&amp; style, CSSPropertyID propertyID)
 145 {
 146     RefPtr&lt;CSSValue&gt; value = extractPropertyValue(style, propertyID);
 147     if (propertyID == CSSPropertyFontStyle &amp;&amp; is&lt;CSSFontStyleValue&gt;(value) &amp;&amp; downcast&lt;CSSFontStyleValue&gt;(value.get())-&gt;isItalicOrOblique())
 148         return CSSValueItalic;
 149     if (!is&lt;CSSPrimitiveValue&gt;(value))
 150         return 0;
 151     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID();
 152 }
 153 
 154 template&lt;typename T&gt; Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle);
 155 enum LegacyFontSizeMode { AlwaysUseLegacyFontSize, UseLegacyFontSizeOnlyIfPixelValuesMatch };
 156 static int legacyFontSizeFromCSSValue(Document&amp;, CSSPrimitiveValue*, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode);
 157 static bool hasTransparentBackgroundColor(StyleProperties*);
 158 static RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node*);
 159 
 160 class HTMLElementEquivalent {
 161     WTF_MAKE_FAST_ALLOCATED;
 162 public:
 163     HTMLElementEquivalent(CSSPropertyID, CSSValueID primitiveValue, const QualifiedName&amp; tagName);
 164     virtual ~HTMLElementEquivalent() = default;
 165 
 166     virtual bool matches(const Element&amp; element) const { return !m_tagName || element.hasTagName(*m_tagName); }
 167     virtual bool hasAttribute() const { return false; }
 168     virtual bool propertyExistsInStyle(const EditingStyle&amp; style) const { return style.m_mutableStyle &amp;&amp; style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID); }
 169     virtual bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const;
 170     virtual void addToStyle(Element*, EditingStyle*) const;
 171 
 172 protected:
 173     HTMLElementEquivalent(CSSPropertyID);
 174     HTMLElementEquivalent(CSSPropertyID, const QualifiedName&amp; tagName);
 175     const CSSPropertyID m_propertyID;
 176     const RefPtr&lt;CSSPrimitiveValue&gt; m_primitiveValue;
 177     const QualifiedName* m_tagName { nullptr }; // We can store a pointer because HTML tag names are const global.
 178 };
 179 
 180 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id)
 181     : m_propertyID(id)
 182 {
 183 }
 184 
 185 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName)
 186     : m_propertyID(id)
 187     , m_tagName(&amp;tagName)
 188 {
 189 }
 190 
 191 HTMLElementEquivalent::HTMLElementEquivalent(CSSPropertyID id, CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 192     : m_propertyID(id)
 193     , m_primitiveValue(CSSPrimitiveValue::createIdentifier(primitiveValue))
 194     , m_tagName(&amp;tagName)
 195 {
 196     ASSERT(primitiveValue != CSSValueInvalid);
 197 }
 198 
 199 bool HTMLElementEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 200 {
 201     RefPtr&lt;CSSValue&gt; value = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 202     return matches(element) &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == m_primitiveValue-&gt;valueID();
 203 }
 204 
 205 void HTMLElementEquivalent::addToStyle(Element*, EditingStyle* style) const
 206 {
 207     style-&gt;setProperty(m_propertyID, m_primitiveValue-&gt;cssText());
 208 }
 209 
 210 class HTMLTextDecorationEquivalent : public HTMLElementEquivalent {
 211 public:
 212     HTMLTextDecorationEquivalent(CSSValueID primitiveValue, const QualifiedName&amp; tagName)
 213         : HTMLElementEquivalent(CSSPropertyTextDecoration, primitiveValue, tagName)
 214         , m_isUnderline(primitiveValue == CSSValueUnderline)
 215     {
 216     }
 217 
 218     bool propertyExistsInStyle(const EditingStyle&amp; style) const override
 219     {
 220         if (changeInStyle(style) != TextDecorationChange::None)
 221             return true;
 222 
 223         if (!style.m_mutableStyle)
 224             return false;
 225 
 226         auto&amp; mutableStyle = *style.m_mutableStyle;
 227         return mutableStyle.getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect)
 228             || mutableStyle.getPropertyCSSValue(CSSPropertyTextDecoration);
 229     }
 230 
 231     bool valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const override
 232     {
 233         if (!matches(element))
 234             return false;
 235         auto change = changeInStyle(style);
 236         if (change != TextDecorationChange::None)
 237             return change == TextDecorationChange::Add;
 238         RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 239         if (!styleValue)
 240             styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
 241         return is&lt;CSSValueList&gt;(styleValue) &amp;&amp; downcast&lt;CSSValueList&gt;(*styleValue).hasValue(m_primitiveValue.get());
 242     }
 243 
 244 private:
 245     TextDecorationChange changeInStyle(const EditingStyle&amp; style) const
 246     {
 247         return m_isUnderline ? style.underlineChange() : style.strikeThroughChange();
 248     }
 249 
 250     bool m_isUnderline;
 251 };
 252 
 253 class HTMLAttributeEquivalent : public HTMLElementEquivalent {
 254 public:
 255     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName);
 256     HTMLAttributeEquivalent(CSSPropertyID, const QualifiedName&amp; attrName);
 257 
 258     bool matches(const Element&amp; element) const override { return HTMLElementEquivalent::matches(element) &amp;&amp; element.hasAttribute(m_attrName); }
 259     bool hasAttribute() const override { return true; }
 260     bool valueIsPresentInStyle(Element&amp;, const EditingStyle&amp;) const override;
 261     void addToStyle(Element*, EditingStyle*) const override;
 262     virtual RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const;
 263     inline const QualifiedName&amp; attributeName() const { return m_attrName; }
 264 
 265 protected:
 266     const QualifiedName&amp; m_attrName; // We can store a reference because HTML attribute names are const global.
 267 };
 268 
 269 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; tagName, const QualifiedName&amp; attrName)
 270     : HTMLElementEquivalent(id, tagName)
 271     , m_attrName(attrName)
 272 {
 273 }
 274 
 275 HTMLAttributeEquivalent::HTMLAttributeEquivalent(CSSPropertyID id, const QualifiedName&amp; attrName)
 276     : HTMLElementEquivalent(id)
 277     , m_attrName(attrName)
 278 {
 279 }
 280 
 281 bool HTMLAttributeEquivalent::valueIsPresentInStyle(Element&amp; element, const EditingStyle&amp; style) const
 282 {
 283     RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(&amp;element);
 284     RefPtr&lt;CSSValue&gt; styleValue = style.m_mutableStyle-&gt;getPropertyCSSValue(m_propertyID);
 285 
 286     return compareCSSValuePtr(value, styleValue);
 287 }
 288 
 289 void HTMLAttributeEquivalent::addToStyle(Element* element, EditingStyle* style) const
 290 {
 291     if (RefPtr&lt;CSSValue&gt; value = attributeValueAsCSSValue(element))
 292         style-&gt;setProperty(m_propertyID, value-&gt;cssText());
 293 }
 294 
 295 RefPtr&lt;CSSValue&gt; HTMLAttributeEquivalent::attributeValueAsCSSValue(Element* element) const
 296 {
 297     ASSERT(element);
<a name="4" id="anc4"></a><span class="line-modified"> 298     const AtomicString&amp; value = element-&gt;getAttribute(m_attrName);</span>
 299     if (value.isNull())
 300         return nullptr;
 301 
 302     RefPtr&lt;MutableStyleProperties&gt; dummyStyle;
 303     dummyStyle = MutableStyleProperties::create();
 304     dummyStyle-&gt;setProperty(m_propertyID, value);
 305     return dummyStyle-&gt;getPropertyCSSValue(m_propertyID);
 306 }
 307 
 308 class HTMLFontSizeEquivalent : public HTMLAttributeEquivalent {
 309 public:
 310     HTMLFontSizeEquivalent();
 311 
 312     RefPtr&lt;CSSValue&gt; attributeValueAsCSSValue(Element*) const override;
 313 };
 314 
 315 HTMLFontSizeEquivalent::HTMLFontSizeEquivalent()
 316     : HTMLAttributeEquivalent(CSSPropertyFontSize, HTMLNames::fontTag, HTMLNames::sizeAttr)
 317 {
 318 }
 319 
 320 RefPtr&lt;CSSValue&gt; HTMLFontSizeEquivalent::attributeValueAsCSSValue(Element* element) const
 321 {
 322     ASSERT(element);
<a name="5" id="anc5"></a><span class="line-modified"> 323     const AtomicString&amp; value = element-&gt;getAttribute(m_attrName);</span>
 324     if (value.isNull())
 325         return nullptr;
 326     CSSValueID size;
 327     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 328         return nullptr;
 329     return CSSPrimitiveValue::createIdentifier(size);
 330 }
 331 
 332 float EditingStyle::NoFontDelta = 0.0f;
 333 
 334 EditingStyle::EditingStyle()
 335     : m_shouldUseFixedDefaultFontSize(false)
 336     , m_underlineChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 337     , m_strikeThroughChange(static_cast&lt;unsigned&gt;(TextDecorationChange::None))
 338 {
 339 }
 340 
 341 EditingStyle::EditingStyle(Node* node, PropertiesToInclude propertiesToInclude)
 342     : EditingStyle()
 343 {
 344     init(node, propertiesToInclude);
 345 }
 346 
 347 EditingStyle::EditingStyle(const Position&amp; position, PropertiesToInclude propertiesToInclude)
 348     : EditingStyle()
 349 {
 350     init(position.deprecatedNode(), propertiesToInclude);
 351 }
 352 
 353 EditingStyle::EditingStyle(const CSSStyleDeclaration* style)
 354     : EditingStyle()
 355 {
 356     if (style)
 357         m_mutableStyle = style-&gt;copyProperties();
 358     extractFontSizeDelta();
 359 }
 360 
 361 EditingStyle::EditingStyle(const StyleProperties* style)
 362     : EditingStyle()
 363 {
 364     if (style)
 365         m_mutableStyle = style-&gt;mutableCopy();
 366     extractFontSizeDelta();
 367 }
 368 
 369 EditingStyle::EditingStyle(CSSPropertyID propertyID, const String&amp; value)
 370     : EditingStyle()
 371 {
 372     setProperty(propertyID, value);
 373     extractFontSizeDelta();
 374 }
 375 
 376 EditingStyle::EditingStyle(CSSPropertyID propertyID, CSSValueID value)
 377     : EditingStyle()
 378 {
 379     m_mutableStyle = MutableStyleProperties::create();
 380     m_mutableStyle-&gt;setProperty(propertyID, value);
 381     extractFontSizeDelta();
 382 }
 383 
 384 EditingStyle::~EditingStyle() = default;
 385 
 386 static Color cssValueToColor(CSSValue* colorValue)
 387 {
 388     if (!is&lt;CSSPrimitiveValue&gt;(colorValue))
 389         return Color::transparent;
 390 
 391     CSSPrimitiveValue&amp; primitiveColor = downcast&lt;CSSPrimitiveValue&gt;(*colorValue);
 392     if (primitiveColor.isRGBColor())
 393         return primitiveColor.color();
 394 
 395     return CSSParser::parseColor(colorValue-&gt;cssText());
 396 }
 397 
 398 template&lt;typename T&gt;
 399 static inline Color textColorFromStyle(T&amp; style)
 400 {
 401     return cssValueToColor(extractPropertyValue(style, CSSPropertyColor).get());
 402 }
 403 
 404 template&lt;typename T&gt;
 405 static inline Color caretColorFromStyle(T&amp; style)
 406 {
 407     return cssValueToColor(extractPropertyValue(style, CSSPropertyCaretColor).get());
 408 }
 409 
 410 template&lt;typename T&gt;
 411 static inline Color backgroundColorFromStyle(T&amp; style)
 412 {
 413     return cssValueToColor(extractPropertyValue(style, CSSPropertyBackgroundColor).get());
 414 }
 415 
 416 static inline Color rgbaBackgroundColorInEffect(Node* node)
 417 {
 418     return cssValueToColor(backgroundColorInEffect(node).get());
 419 }
 420 
 421 static int textAlignResolvingStartAndEnd(int textAlign, int direction)
 422 {
 423     switch (textAlign) {
 424     case CSSValueCenter:
 425     case CSSValueWebkitCenter:
 426         return CSSValueCenter;
 427     case CSSValueJustify:
 428         return CSSValueJustify;
 429     case CSSValueLeft:
 430     case CSSValueWebkitLeft:
 431         return CSSValueLeft;
 432     case CSSValueRight:
 433     case CSSValueWebkitRight:
 434         return CSSValueRight;
 435     case CSSValueStart:
 436         return direction != CSSValueRtl ? CSSValueLeft : CSSValueRight;
 437     case CSSValueEnd:
 438         return direction == CSSValueRtl ? CSSValueRight : CSSValueLeft;
 439     }
 440     return CSSValueInvalid;
 441 }
 442 
 443 template&lt;typename T&gt;
 444 static int textAlignResolvingStartAndEnd(T&amp; style)
 445 {
 446     return textAlignResolvingStartAndEnd(identifierForStyleProperty(style, CSSPropertyTextAlign), identifierForStyleProperty(style, CSSPropertyDirection));
 447 }
 448 
 449 void EditingStyle::init(Node* node, PropertiesToInclude propertiesToInclude)
 450 {
 451     if (isTabSpanTextNode(node))
 452         node = tabSpanNode(node)-&gt;parentNode();
 453     else if (isTabSpanNode(node))
 454         node = node-&gt;parentNode();
 455 
 456     ComputedStyleExtractor computedStyleAtPosition(node);
 457     // FIXME: It&#39;s strange to not set background-color and text-decoration when propertiesToInclude is EditingPropertiesInEffect.
 458     // However editing/selection/contains-boundaries.html fails without this ternary.
 459     m_mutableStyle = copyPropertiesFromComputedStyle(computedStyleAtPosition,
 460         propertiesToInclude == EditingPropertiesInEffect ? OnlyEditingInheritableProperties : propertiesToInclude);
 461 
 462     if (propertiesToInclude == EditingPropertiesInEffect) {
 463         if (RefPtr&lt;CSSValue&gt; value = backgroundColorInEffect(node))
 464             m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
 465         if (RefPtr&lt;CSSValue&gt; value = computedStyleAtPosition.propertyValue(CSSPropertyWebkitTextDecorationsInEffect)) {
 466             m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, value-&gt;cssText());
 467             m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 468         }
 469     }
 470 
 471     if (node &amp;&amp; node-&gt;computedStyle()) {
 472         auto* renderStyle = node-&gt;computedStyle();
 473         removeTextFillAndStrokeColorsIfNeeded(renderStyle);
 474         if (renderStyle-&gt;fontDescription().keywordSize())
 475             m_mutableStyle-&gt;setProperty(CSSPropertyFontSize, computedStyleAtPosition.getFontSizeCSSValuePreferringKeyword()-&gt;cssText());
 476     }
 477 
 478     m_shouldUseFixedDefaultFontSize = computedStyleAtPosition.useFixedFontDefaultSize();
 479     extractFontSizeDelta();
 480 }
 481 
 482 void EditingStyle::removeTextFillAndStrokeColorsIfNeeded(const RenderStyle* renderStyle)
 483 {
 484     // If a node&#39;s text fill color is invalid, then its children use
 485     // their font-color as their text fill color (they don&#39;t
 486     // inherit it).  Likewise for stroke color.
 487     if (!renderStyle-&gt;textFillColor().isValid())
 488         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextFillColor);
 489     if (!renderStyle-&gt;textStrokeColor().isValid())
 490         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextStrokeColor);
 491 }
 492 
 493 void EditingStyle::setProperty(CSSPropertyID propertyID, const String&amp; value, bool important)
 494 {
 495     if (!m_mutableStyle)
 496         m_mutableStyle = MutableStyleProperties::create();
 497 
 498     m_mutableStyle-&gt;setProperty(propertyID, value, important);
 499 }
 500 
 501 void EditingStyle::extractFontSizeDelta()
 502 {
 503     if (!m_mutableStyle)
 504         return;
 505 
 506     if (m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize)) {
 507         // Explicit font size overrides any delta.
 508         m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 509         return;
 510     }
 511 
 512     // Get the adjustment amount out of the style.
 513     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitFontSizeDelta);
 514     if (!is&lt;CSSPrimitiveValue&gt;(value))
 515         return;
 516 
 517     CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
 518 
 519     // Only PX handled now. If we handle more types in the future, perhaps
 520     // a switch statement here would be more appropriate.
 521     if (!primitiveValue.isPx())
 522         return;
 523 
 524     m_fontSizeDelta = primitiveValue.floatValue();
 525     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitFontSizeDelta);
 526 }
 527 
 528 bool EditingStyle::isEmpty() const
 529 {
 530     return (!m_mutableStyle || m_mutableStyle-&gt;isEmpty()) &amp;&amp; m_fontSizeDelta == NoFontDelta
 531         &amp;&amp; underlineChange() == TextDecorationChange::None &amp;&amp; strikeThroughChange() == TextDecorationChange::None;
 532 }
 533 
 534 Ref&lt;MutableStyleProperties&gt; EditingStyle::styleWithResolvedTextDecorations() const
 535 {
 536     bool hasTextDecorationChanges = underlineChange() != TextDecorationChange::None || strikeThroughChange() != TextDecorationChange::None;
 537     if (m_mutableStyle &amp;&amp; !hasTextDecorationChanges)
 538         return *m_mutableStyle;
 539 
 540     Ref&lt;MutableStyleProperties&gt; style = m_mutableStyle ? m_mutableStyle-&gt;mutableCopy() : MutableStyleProperties::create();
 541 
 542     Ref&lt;CSSValueList&gt; valueList = CSSValueList::createSpaceSeparated();
 543     if (underlineChange() == TextDecorationChange::Add)
 544         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline));
 545     if (strikeThroughChange() == TextDecorationChange::Add)
 546         valueList-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough));
 547 
 548     if (valueList-&gt;length())
 549         style-&gt;setProperty(CSSPropertyTextDecoration, valueList.ptr());
 550     else
 551         style-&gt;setProperty(CSSPropertyTextDecoration, CSSValuePool::singleton().createIdentifierValue(CSSValueNone));
 552 
 553     return style;
 554 }
 555 
 556 Optional&lt;WritingDirection&gt; EditingStyle::textDirection() const
 557 {
 558     if (!m_mutableStyle)
 559         return WTF::nullopt;
 560 
 561     RefPtr&lt;CSSValue&gt; unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
 562     if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
 563         return WTF::nullopt;
 564 
 565     CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
 566     if (unicodeBidiValue == CSSValueEmbed) {
 567         RefPtr&lt;CSSValue&gt; direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
 568         if (!is&lt;CSSPrimitiveValue&gt;(direction))
 569             return WTF::nullopt;
 570 
 571         return downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID() == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
 572     }
 573 
 574     if (unicodeBidiValue == CSSValueNormal)
 575         return WritingDirection::Natural;
 576 
 577     return WTF::nullopt;
 578 }
 579 
 580 void EditingStyle::setStyle(RefPtr&lt;MutableStyleProperties&gt;&amp;&amp; style)
 581 {
 582     m_mutableStyle = WTFMove(style);
 583     // FIXME: We should be able to figure out whether or not font is fixed width for mutable style.
 584     // We need to check font-family is monospace as in FontDescription but we don&#39;t want to duplicate code here.
 585     m_shouldUseFixedDefaultFontSize = false;
 586     extractFontSizeDelta();
 587 }
 588 
 589 void EditingStyle::overrideWithStyle(const StyleProperties&amp; style)
 590 {
 591     return mergeStyle(&amp;style, OverrideValues);
 592 }
 593 
 594 static void applyTextDecorationChangeToValueList(CSSValueList&amp; valueList, TextDecorationChange change, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)
 595 {
 596     switch (change) {
 597     case TextDecorationChange::None:
 598         break;
 599     case TextDecorationChange::Add:
 600         valueList.append(WTFMove(value));
 601         break;
 602     case TextDecorationChange::Remove:
 603         valueList.removeAll(&amp;value.get());
 604         break;
 605     }
 606 }
 607 
 608 void EditingStyle::overrideTypingStyleAt(const EditingStyle&amp; style, const Position&amp; position)
 609 {
 610     mergeStyle(style.m_mutableStyle.get(), OverrideValues);
 611 
 612     m_fontSizeDelta += style.m_fontSizeDelta;
 613 
 614     prepareToApplyAt(position, EditingStyle::PreserveWritingDirection);
 615 
 616     auto underlineChange = style.underlineChange();
 617     auto strikeThroughChange = style.strikeThroughChange();
 618     if (underlineChange == TextDecorationChange::None &amp;&amp; strikeThroughChange == TextDecorationChange::None)
 619         return;
 620 
 621     if (!m_mutableStyle)
 622         m_mutableStyle = MutableStyleProperties::create();
 623 
 624     auto&amp; cssValuePool = CSSValuePool::singleton();
 625     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
 626     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
 627     RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 628     RefPtr&lt;CSSValueList&gt; valueList;
 629     if (value &amp;&amp; value-&gt;isValueList()) {
 630         valueList = downcast&lt;CSSValueList&gt;(*value).copy();
 631         applyTextDecorationChangeToValueList(*valueList, underlineChange, WTFMove(underline));
 632         applyTextDecorationChangeToValueList(*valueList, strikeThroughChange, WTFMove(lineThrough));
 633     } else {
 634         valueList = CSSValueList::createSpaceSeparated();
 635         if (underlineChange == TextDecorationChange::Add)
 636             valueList-&gt;append(WTFMove(underline));
 637         if (strikeThroughChange == TextDecorationChange::Add)
 638             valueList-&gt;append(WTFMove(lineThrough));
 639     }
 640     m_mutableStyle-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, valueList.get());
 641 }
 642 
 643 void EditingStyle::clear()
 644 {
 645     m_mutableStyle = nullptr;
 646     m_shouldUseFixedDefaultFontSize = false;
 647     m_fontSizeDelta = NoFontDelta;
 648     setUnderlineChange(TextDecorationChange::None);
 649     setStrikeThroughChange(TextDecorationChange::None);
 650 }
 651 
 652 Ref&lt;EditingStyle&gt; EditingStyle::copy() const
 653 {
 654     auto copy = EditingStyle::create();
 655     if (m_mutableStyle)
 656         copy-&gt;m_mutableStyle = m_mutableStyle-&gt;mutableCopy();
 657     copy-&gt;m_shouldUseFixedDefaultFontSize = m_shouldUseFixedDefaultFontSize;
 658     copy-&gt;m_underlineChange = m_underlineChange;
 659     copy-&gt;m_strikeThroughChange = m_strikeThroughChange;
 660     copy-&gt;m_fontSizeDelta = m_fontSizeDelta;
 661     return copy;
 662 }
 663 
 664 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveBlockProperties()
 665 {
 666     auto blockProperties = EditingStyle::create();
 667     if (!m_mutableStyle)
 668         return blockProperties;
 669 
 670     blockProperties-&gt;m_mutableStyle = m_mutableStyle-&gt;copyBlockProperties();
 671     m_mutableStyle-&gt;removeBlockProperties();
 672 
 673     return blockProperties;
 674 }
 675 
 676 Ref&lt;EditingStyle&gt; EditingStyle::extractAndRemoveTextDirection()
 677 {
 678     auto textDirection = EditingStyle::create();
 679     textDirection-&gt;m_mutableStyle = MutableStyleProperties::create();
 680     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed, m_mutableStyle-&gt;propertyIsImportant(CSSPropertyUnicodeBidi));
 681     textDirection-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyDirection, m_mutableStyle-&gt;getPropertyValue(CSSPropertyDirection),
 682         m_mutableStyle-&gt;propertyIsImportant(CSSPropertyDirection));
 683 
 684     m_mutableStyle-&gt;removeProperty(CSSPropertyUnicodeBidi);
 685     m_mutableStyle-&gt;removeProperty(CSSPropertyDirection);
 686 
 687     return textDirection;
 688 }
 689 
 690 void EditingStyle::removeBlockProperties()
 691 {
 692     if (!m_mutableStyle)
 693         return;
 694 
 695     m_mutableStyle-&gt;removeBlockProperties();
 696 }
 697 
 698 void EditingStyle::removeStyleAddedByNode(Node* node)
 699 {
 700     if (!node || !node-&gt;parentNode())
 701         return;
 702     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node-&gt;parentNode(), EditingPropertiesInEffect);
 703     RefPtr&lt;MutableStyleProperties&gt; nodeStyle = copyPropertiesFromComputedStyle(node, EditingPropertiesInEffect);
 704     removeEquivalentProperties(*parentStyle);
 705     removeEquivalentProperties(*nodeStyle);
 706 }
 707 
 708 void EditingStyle::removeStyleConflictingWithStyleOfNode(Node&amp; node)
 709 {
 710     if (!node.parentNode() || !m_mutableStyle)
 711         return;
 712 
 713     RefPtr&lt;MutableStyleProperties&gt; parentStyle = copyPropertiesFromComputedStyle(node.parentNode(), EditingPropertiesInEffect);
 714     auto nodeStyle = EditingStyle::create(&amp;node, EditingPropertiesInEffect);
 715     nodeStyle-&gt;removeEquivalentProperties(*parentStyle);
 716 
 717     MutableStyleProperties* style = nodeStyle-&gt;style();
 718     unsigned propertyCount = style-&gt;propertyCount();
 719     for (unsigned i = 0; i &lt; propertyCount; ++i)
 720         m_mutableStyle-&gt;removeProperty(style-&gt;propertyAt(i).id());
 721 }
 722 
 723 void EditingStyle::collapseTextDecorationProperties()
 724 {
 725     if (!m_mutableStyle)
 726         return;
 727 
 728     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
 729     if (!textDecorationsInEffect)
 730         return;
 731 
 732     if (textDecorationsInEffect-&gt;isValueList())
 733         m_mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText(), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 734     else
 735         m_mutableStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 736     m_mutableStyle-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
 737 }
 738 
 739 // CSS properties that create a visual difference only when applied to text.
 740 static const CSSPropertyID textOnlyProperties[] = {
 741     CSSPropertyTextDecoration,
 742     CSSPropertyWebkitTextDecorationsInEffect,
 743     CSSPropertyFontStyle,
 744     CSSPropertyFontWeight,
 745     CSSPropertyColor,
 746 };
 747 
 748 TriState EditingStyle::triStateOfStyle(EditingStyle* style) const
 749 {
 750     if (!style || !style-&gt;m_mutableStyle)
 751         return FalseTriState;
 752     return triStateOfStyle(*style-&gt;m_mutableStyle, DoNotIgnoreTextOnlyProperties);
 753 }
 754 
 755 template&lt;typename T&gt;
 756 TriState EditingStyle::triStateOfStyle(T&amp; styleToCompare, ShouldIgnoreTextOnlyProperties shouldIgnoreTextOnlyProperties) const
 757 {
 758     if (!m_mutableStyle)
 759         return TrueTriState;
 760 
 761     RefPtr&lt;MutableStyleProperties&gt; difference = getPropertiesNotIn(*m_mutableStyle, styleToCompare);
 762 
 763     if (shouldIgnoreTextOnlyProperties == IgnoreTextOnlyProperties)
 764         difference-&gt;removePropertiesInSet(textOnlyProperties, WTF_ARRAY_LENGTH(textOnlyProperties));
 765 
 766     if (difference-&gt;isEmpty())
 767         return TrueTriState;
 768     if (difference-&gt;propertyCount() == m_mutableStyle-&gt;propertyCount())
 769         return FalseTriState;
 770 
 771     return MixedTriState;
 772 }
 773 
 774 TriState EditingStyle::triStateOfStyle(const VisibleSelection&amp; selection) const
 775 {
 776     if (!selection.isCaretOrRange())
 777         return FalseTriState;
 778 
 779     if (selection.isCaret())
 780         return triStateOfStyle(EditingStyle::styleAtSelectionStart(selection).get());
 781 
 782     TriState state = FalseTriState;
 783     bool nodeIsStart = true;
 784     for (Node* node = selection.start().deprecatedNode(); node; node = NodeTraversal::next(*node)) {
 785         if (node-&gt;renderer() &amp;&amp; node-&gt;hasEditableStyle()) {
 786             ComputedStyleExtractor computedStyle(node);
 787             TriState nodeState = triStateOfStyle(computedStyle, node-&gt;isTextNode() ? EditingStyle::DoNotIgnoreTextOnlyProperties : EditingStyle::IgnoreTextOnlyProperties);
 788             if (nodeIsStart) {
 789                 state = nodeState;
 790                 nodeIsStart = false;
 791             } else if (state != nodeState &amp;&amp; node-&gt;isTextNode()) {
 792                 state = MixedTriState;
 793                 break;
 794             }
 795         }
 796 
 797         if (node == selection.end().deprecatedNode())
 798             break;
 799     }
 800 
 801     return state;
 802 }
 803 
 804 static RefPtr&lt;CSSValueList&gt; textDecorationValueList(const StyleProperties&amp; properties)
 805 {
 806     RefPtr&lt;CSSValue&gt; value = properties.getPropertyCSSValue(CSSPropertyTextDecoration);
 807     if (!is&lt;CSSValueList&gt;(value))
 808         return nullptr;
 809     return downcast&lt;CSSValueList&gt;(value.get());
 810 }
 811 
 812 bool EditingStyle::conflictsWithInlineStyleOfElement(StyledElement&amp; element, RefPtr&lt;MutableStyleProperties&gt;* newInlineStylePtr, EditingStyle* extractedStyle) const
 813 {
 814     const StyleProperties* inlineStyle = element.inlineStyle();
 815     if (!inlineStyle)
 816         return false;
 817     bool conflicts = false;
 818     RefPtr&lt;MutableStyleProperties&gt; newInlineStyle;
 819     if (newInlineStylePtr) {
 820         newInlineStyle = inlineStyle-&gt;mutableCopy();
 821         *newInlineStylePtr = newInlineStyle;
 822     }
 823 
 824     bool shouldRemoveUnderline = underlineChange() == TextDecorationChange::Remove;
 825     bool shouldRemoveStrikeThrough = strikeThroughChange() == TextDecorationChange::Remove;
 826     if (shouldRemoveUnderline || shouldRemoveStrikeThrough) {
 827         if (RefPtr&lt;CSSValueList&gt; valueList = textDecorationValueList(*inlineStyle)) {
 828             auto newValueList = valueList-&gt;copy();
 829             auto extractedValueList = CSSValueList::createSpaceSeparated();
 830 
 831             Ref&lt;CSSPrimitiveValue&gt; underline = CSSValuePool::singleton().createIdentifierValue(CSSValueUnderline);
 832             if (shouldRemoveUnderline &amp;&amp; valueList-&gt;hasValue(underline.ptr())) {
 833                 if (!newInlineStyle)
 834                     return true;
 835                 newValueList-&gt;removeAll(underline.ptr());
 836                 extractedValueList-&gt;append(WTFMove(underline));
 837             }
 838 
 839             Ref&lt;CSSPrimitiveValue&gt; lineThrough = CSSValuePool::singleton().createIdentifierValue(CSSValueLineThrough);
 840             if (shouldRemoveStrikeThrough &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr())) {
 841                 if (!newInlineStyle)
 842                     return true;
 843                 newValueList-&gt;removeAll(lineThrough.ptr());
 844                 extractedValueList-&gt;append(WTFMove(lineThrough));
 845             }
 846 
 847             if (extractedValueList-&gt;length()) {
 848                 conflicts = true;
 849                 if (newValueList-&gt;length())
 850                     newInlineStyle-&gt;setProperty(CSSPropertyTextDecoration, WTFMove(newValueList));
 851                 else
 852                     newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 853 
 854                 if (extractedStyle) {
 855                     bool isImportant = inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration);
 856                     extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, extractedValueList-&gt;cssText(), isImportant);
 857                 }
 858             }
 859         }
 860     }
 861 
 862     unsigned propertyCount = m_mutableStyle ? m_mutableStyle-&gt;propertyCount() : 0;
 863     for (unsigned i = 0; i &lt; propertyCount; ++i) {
 864         CSSPropertyID propertyID = m_mutableStyle-&gt;propertyAt(i).id();
 865 
 866         // We don&#39;t override whitespace property of a tab span because that would collapse the tab into a space.
 867         if (propertyID == CSSPropertyWhiteSpace &amp;&amp; isTabSpanNode(&amp;element))
 868             continue;
 869 
 870         if (propertyID == CSSPropertyWebkitTextDecorationsInEffect &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyTextDecoration)) {
 871             if (!newInlineStyle)
 872                 return true;
 873             conflicts = true;
 874             newInlineStyle-&gt;removeProperty(CSSPropertyTextDecoration);
 875             if (extractedStyle)
 876                 extractedStyle-&gt;setProperty(CSSPropertyTextDecoration, inlineStyle-&gt;getPropertyValue(CSSPropertyTextDecoration), inlineStyle-&gt;propertyIsImportant(CSSPropertyTextDecoration));
 877         }
 878 
 879         if (!inlineStyle-&gt;getPropertyCSSValue(propertyID))
 880             continue;
 881 
 882         if (propertyID == CSSPropertyUnicodeBidi &amp;&amp; inlineStyle-&gt;getPropertyCSSValue(CSSPropertyDirection)) {
 883             if (!newInlineStyle)
 884                 return true;
 885             conflicts = true;
 886             newInlineStyle-&gt;removeProperty(CSSPropertyDirection);
 887             if (extractedStyle)
 888                 extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 889         }
 890 
 891         if (!newInlineStyle)
 892             return true;
 893 
 894         conflicts = true;
 895         newInlineStyle-&gt;removeProperty(propertyID);
 896         if (extractedStyle)
 897             extractedStyle-&gt;setProperty(propertyID, inlineStyle-&gt;getPropertyValue(propertyID), inlineStyle-&gt;propertyIsImportant(propertyID));
 898     }
 899 
 900     return conflicts;
 901 }
 902 
 903 static const Vector&lt;const HTMLElementEquivalent*&gt;&amp; htmlElementEquivalents()
 904 {
 905     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLElementEquivalent*&gt; {
 906         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::bTag),
 907         new HTMLElementEquivalent(CSSPropertyFontWeight, CSSValueBold, HTMLNames::strongTag),
 908         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSub, HTMLNames::subTag),
 909         new HTMLElementEquivalent(CSSPropertyVerticalAlign, CSSValueSuper, HTMLNames::supTag),
 910         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::iTag),
 911         new HTMLElementEquivalent(CSSPropertyFontStyle, CSSValueItalic, HTMLNames::emTag),
 912 
 913         new HTMLTextDecorationEquivalent(CSSValueUnderline, HTMLNames::uTag),
 914         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::sTag),
 915         new HTMLTextDecorationEquivalent(CSSValueLineThrough, HTMLNames::strikeTag),
 916     });
 917     return equivalents;
 918 }
 919 
 920 
 921 bool EditingStyle::conflictsWithImplicitStyleOfElement(HTMLElement&amp; element, EditingStyle* extractedStyle, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 922 {
 923     if (isEmpty())
 924         return false;
 925 
 926     for (auto&amp; equivalent : htmlElementEquivalents()) {
 927         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this)
 928             &amp;&amp; (shouldExtractMatchingStyle == ExtractMatchingStyle || !equivalent-&gt;valueIsPresentInStyle(element, *this))) {
 929             if (extractedStyle)
 930                 equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 931             return true;
 932         }
 933     }
 934     return false;
 935 }
 936 
 937 static const Vector&lt;const HTMLAttributeEquivalent*&gt;&amp; htmlAttributeEquivalents()
 938 {
 939     static const auto equivalents = makeNeverDestroyed(Vector&lt;const HTMLAttributeEquivalent*&gt; {
 940         // elementIsStyledSpanOrHTMLEquivalent depends on the fact each HTMLAttriuteEquivalent matches exactly one attribute
 941         // of exactly one element except dirAttr.
 942         new HTMLAttributeEquivalent(CSSPropertyColor, HTMLNames::fontTag, HTMLNames::colorAttr),
 943         new HTMLAttributeEquivalent(CSSPropertyFontFamily, HTMLNames::fontTag, HTMLNames::faceAttr),
 944         new HTMLFontSizeEquivalent,
 945 
 946         new HTMLAttributeEquivalent(CSSPropertyDirection, HTMLNames::dirAttr),
 947         new HTMLAttributeEquivalent(CSSPropertyUnicodeBidi, HTMLNames::dirAttr),
 948     });
 949     return equivalents;
 950 }
 951 
 952 bool EditingStyle::conflictsWithImplicitStyleOfAttributes(HTMLElement&amp; element) const
 953 {
 954     if (isEmpty())
 955         return false;
 956 
 957     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 958         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;propertyExistsInStyle(*this) &amp;&amp; !equivalent-&gt;valueIsPresentInStyle(element, *this))
 959             return true;
 960     }
 961 
 962     return false;
 963 }
 964 
 965 bool EditingStyle::extractConflictingImplicitStyleOfAttributes(HTMLElement&amp; element, ShouldPreserveWritingDirection shouldPreserveWritingDirection,
 966     EditingStyle* extractedStyle, Vector&lt;QualifiedName&gt;&amp; conflictingAttributes, ShouldExtractMatchingStyle shouldExtractMatchingStyle) const
 967 {
 968     // HTMLAttributeEquivalent::addToStyle doesn&#39;t support unicode-bidi and direction properties
 969     ASSERT(!extractedStyle || shouldPreserveWritingDirection == PreserveWritingDirection);
 970     if (!m_mutableStyle)
 971         return false;
 972 
 973     bool removed = false;
 974     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
 975         // unicode-bidi and direction are pushed down separately so don&#39;t push down with other styles.
 976         if (shouldPreserveWritingDirection == PreserveWritingDirection &amp;&amp; equivalent-&gt;attributeName() == HTMLNames::dirAttr)
 977             continue;
 978 
 979         if (!equivalent-&gt;matches(element) || !equivalent-&gt;propertyExistsInStyle(*this)
 980             || (shouldExtractMatchingStyle == DoNotExtractMatchingStyle &amp;&amp; equivalent-&gt;valueIsPresentInStyle(element, *this)))
 981             continue;
 982 
 983         if (extractedStyle)
 984             equivalent-&gt;addToStyle(&amp;element, extractedStyle);
 985         conflictingAttributes.append(equivalent-&gt;attributeName());
 986         removed = true;
 987     }
 988 
 989     return removed;
 990 }
 991 
 992 bool EditingStyle::styleIsPresentInComputedStyleOfNode(Node&amp; node) const
 993 {
 994     if (isEmpty())
 995         return true;
 996     ComputedStyleExtractor computedStyle(&amp;node);
 997 
 998     bool shouldAddUnderline = underlineChange() == TextDecorationChange::Add;
 999     bool shouldAddLineThrough = strikeThroughChange() == TextDecorationChange::Add;
1000     if (shouldAddUnderline || shouldAddLineThrough) {
1001         bool hasUnderline = false;
1002         bool hasLineThrough = false;
1003         if (RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyTextDecoration)) {
1004             if (value-&gt;isValueList()) {
1005                 auto&amp; cssValuePool = CSSValuePool::singleton();
1006                 const CSSValueList&amp; valueList = downcast&lt;CSSValueList&gt;(*value);
1007                 hasUnderline = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueUnderline).ptr());
1008                 hasLineThrough = valueList.hasValue(cssValuePool.createIdentifierValue(CSSValueLineThrough).ptr());
1009             }
1010         }
1011         if ((shouldAddUnderline &amp;&amp; !hasUnderline) || (shouldAddLineThrough &amp;&amp; !hasLineThrough))
1012             return false;
1013     }
1014 
1015     return !m_mutableStyle || getPropertiesNotIn(*m_mutableStyle, computedStyle)-&gt;isEmpty();
1016 }
1017 
1018 bool EditingStyle::elementIsStyledSpanOrHTMLEquivalent(const HTMLElement&amp; element)
1019 {
1020     bool elementIsSpanOrElementEquivalent = false;
1021     if (element.hasTagName(HTMLNames::spanTag))
1022         elementIsSpanOrElementEquivalent = true;
1023     else {
1024         for (auto&amp; equivalent : htmlElementEquivalents()) {
1025             if (equivalent-&gt;matches(element)) {
1026                 elementIsSpanOrElementEquivalent = true;
1027                 break;
1028             }
1029         }
1030     }
1031 
1032     if (!element.hasAttributes())
1033         return elementIsSpanOrElementEquivalent; // span, b, etc... without any attributes
1034 
1035     unsigned matchedAttributes = 0;
1036     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1037         if (equivalent-&gt;matches(element) &amp;&amp; equivalent-&gt;attributeName() != HTMLNames::dirAttr)
1038             matchedAttributes++;
1039     }
1040 
1041     if (!elementIsSpanOrElementEquivalent &amp;&amp; !matchedAttributes)
1042         return false; // element is not a span, a html element equivalent, or font element.
1043 
1044     if (element.attributeWithoutSynchronization(HTMLNames::classAttr) == AppleStyleSpanClass)
1045         matchedAttributes++;
1046 
1047     if (element.hasAttribute(HTMLNames::styleAttr)) {
1048         if (const StyleProperties* style = element.inlineStyle()) {
1049             unsigned propertyCount = style-&gt;propertyCount();
1050             for (unsigned i = 0; i &lt; propertyCount; ++i) {
1051                 if (!isEditingProperty(style-&gt;propertyAt(i).id()))
1052                     return false;
1053             }
1054         }
1055         matchedAttributes++;
1056     }
1057 
1058     // font with color attribute, span with style attribute, etc...
1059     ASSERT(matchedAttributes &lt;= element.attributeCount());
1060     return matchedAttributes &gt;= element.attributeCount();
1061 }
1062 
1063 void EditingStyle::prepareToApplyAt(const Position&amp; position, ShouldPreserveWritingDirection shouldPreserveWritingDirection)
1064 {
1065     if (!m_mutableStyle)
1066         return;
1067 
1068     // ReplaceSelectionCommand::handleStyleSpans() requires that this function only removes the editing style.
1069     // If this function was modified in the future to delete all redundant properties, then add a boolean value to indicate
1070     // which one of editingStyleAtPosition or computedStyle is called.
1071     auto editingStyleAtPosition = EditingStyle::create(position, EditingPropertiesInEffect);
1072     StyleProperties* styleAtPosition = editingStyleAtPosition-&gt;m_mutableStyle.get();
1073 
1074     RefPtr&lt;CSSValue&gt; unicodeBidi;
1075     RefPtr&lt;CSSValue&gt; direction;
1076     if (shouldPreserveWritingDirection == PreserveWritingDirection) {
1077         unicodeBidi = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi);
1078         direction = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyDirection);
1079     }
1080 
1081     removeEquivalentProperties(*styleAtPosition);
1082 
1083     if (textAlignResolvingStartAndEnd(*m_mutableStyle) == textAlignResolvingStartAndEnd(*styleAtPosition))
1084         m_mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1085 
1086     if (equalIgnoringSemanticColor(textColorFromStyle(*m_mutableStyle), textColorFromStyle(*styleAtPosition)))
1087         m_mutableStyle-&gt;removeProperty(CSSPropertyColor);
1088 
1089     if (equalIgnoringSemanticColor(caretColorFromStyle(*m_mutableStyle), caretColorFromStyle(*styleAtPosition)))
1090         m_mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1091 
1092     if (hasTransparentBackgroundColor(m_mutableStyle.get())
1093         || cssValueToColor(m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get()) == rgbaBackgroundColorInEffect(position.containerNode()))
1094         m_mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1095 
1096     if (is&lt;CSSPrimitiveValue&gt;(unicodeBidi)) {
1097         m_mutableStyle-&gt;setProperty(CSSPropertyUnicodeBidi, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID()));
1098         if (is&lt;CSSPrimitiveValue&gt;(direction))
1099             m_mutableStyle-&gt;setProperty(CSSPropertyDirection, static_cast&lt;CSSValueID&gt;(downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID()));
1100     }
1101 }
1102 
1103 void EditingStyle::mergeTypingStyle(Document&amp; document)
1104 {
1105     RefPtr&lt;EditingStyle&gt; typingStyle = document.frame()-&gt;selection().typingStyle();
1106     if (!typingStyle || typingStyle == this)
1107         return;
1108 
1109     mergeStyle(typingStyle-&gt;style(), OverrideValues);
1110 }
1111 
1112 void EditingStyle::mergeInlineStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)
1113 {
1114     if (!element.inlineStyle())
1115         return;
1116 
1117     switch (propertiesToInclude) {
1118     case AllProperties:
1119         mergeStyle(element.inlineStyle(), mode);
1120         return;
1121     case OnlyEditingInheritableProperties:
1122         mergeStyle(copyEditingProperties(element.inlineStyle(), OnlyInheritableEditingProperties).ptr(), mode);
1123         return;
1124     case EditingPropertiesInEffect:
1125         mergeStyle(copyEditingProperties(element.inlineStyle(), AllEditingProperties).ptr(), mode);
1126         return;
1127     }
1128 }
1129 
1130 static inline bool elementMatchesAndPropertyIsNotInInlineStyleDecl(const HTMLElementEquivalent&amp; equivalent, const StyledElement&amp; element,
1131     EditingStyle::CSSPropertyOverrideMode mode, EditingStyle&amp; style)
1132 {
1133     if (!equivalent.matches(element))
1134         return false;
1135     if (mode != EditingStyle::OverrideValues &amp;&amp; equivalent.propertyExistsInStyle(style))
1136         return false;
1137 
1138     return !element.inlineStyle() || !equivalent.propertyExistsInStyle(EditingStyle::create(element.inlineStyle()).get());
1139 }
1140 
1141 static RefPtr&lt;MutableStyleProperties&gt; extractEditingProperties(const StyleProperties* style, EditingStyle::PropertiesToInclude propertiesToInclude)
1142 {
1143     if (!style)
1144         return nullptr;
1145 
1146     switch (propertiesToInclude) {
1147     case EditingStyle::OnlyEditingInheritableProperties:
1148         return copyEditingProperties(style, OnlyInheritableEditingProperties);
1149     case EditingStyle::AllProperties:
1150     case EditingStyle::EditingPropertiesInEffect:
1151         break;
1152     }
1153     return copyEditingProperties(style, AllEditingProperties);
1154 }
1155 
1156 void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)
1157 {
1158     auto styleFromRules = EditingStyle::create();
1159     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element);
1160 
1161     if (element.inlineStyle())
1162         styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
1163 
1164     styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
1165     mergeStyle(styleFromRules-&gt;m_mutableStyle.get(), mode);
1166 
1167     for (auto&amp; equivalent : htmlElementEquivalents()) {
1168         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1169             equivalent-&gt;addToStyle(&amp;element, this);
1170     }
1171 
1172     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1173         if (equivalent-&gt;attributeName() == HTMLNames::dirAttr)
1174             continue; // We don&#39;t want to include directionality
1175         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1176             equivalent-&gt;addToStyle(&amp;element, this);
1177     }
1178 }
1179 
1180 Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate)
1181 {
1182     if (shouldAnnotate) {
1183         auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
1184 
1185         // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
1186         // to help us differentiate those styles from ones that the user has applied.
1187         // This helps us get the color of content pasted into blockquotes right.
1188         wrappingStyle-&gt;removeStyleAddedByNode(enclosingNodeOfType(firstPositionInOrBeforeNode(&amp;context), isMailBlockquote, CanCrossEditingBoundary));
1189 
1190         // Call collapseTextDecorationProperties first or otherwise it&#39;ll copy the value over from in-effect to text-decorations.
1191         wrappingStyle-&gt;collapseTextDecorationProperties();
1192 
1193         return wrappingStyle;
1194     }
1195 
1196     auto wrappingStyle = EditingStyle::create();
1197 
1198     // When not annotating for interchange, we only preserve inline style declarations.
1199     for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
1200         if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
1201             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), EditingStyle::DoNotOverrideValues, EditingStyle::EditingPropertiesInEffect);
1202     }
1203 
1204     return wrappingStyle;
1205 }
1206 
1207 
1208 static void mergeTextDecorationValues(CSSValueList&amp; mergedValue, const CSSValueList&amp; valueToMerge)
1209 {
1210     auto&amp; cssValuePool = CSSValuePool::singleton();
1211     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1212     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1213 
1214     if (valueToMerge.hasValue(underline.ptr()) &amp;&amp; !mergedValue.hasValue(underline.ptr()))
1215         mergedValue.append(WTFMove(underline));
1216 
1217     if (valueToMerge.hasValue(lineThrough.ptr()) &amp;&amp; !mergedValue.hasValue(lineThrough.ptr()))
1218         mergedValue.append(WTFMove(lineThrough));
1219 }
1220 
1221 void EditingStyle::mergeStyle(const StyleProperties* style, CSSPropertyOverrideMode mode)
1222 {
1223     if (!style)
1224         return;
1225 
1226     if (!m_mutableStyle) {
1227         m_mutableStyle = style-&gt;mutableCopy();
1228         return;
1229     }
1230 
1231     unsigned propertyCount = style-&gt;propertyCount();
1232     for (unsigned i = 0; i &lt; propertyCount; ++i) {
1233         StyleProperties::PropertyReference property = style-&gt;propertyAt(i);
1234         RefPtr&lt;CSSValue&gt; value = m_mutableStyle-&gt;getPropertyCSSValue(property.id());
1235 
1236         // text decorations never override values.
1237         if ((property.id() == CSSPropertyTextDecoration || property.id() == CSSPropertyWebkitTextDecorationsInEffect)
1238             &amp;&amp; is&lt;CSSValueList&gt;(*property.value()) &amp;&amp; value) {
1239             if (is&lt;CSSValueList&gt;(*value)) {
1240                 auto newValue = downcast&lt;CSSValueList&gt;(*value).copy();
1241                 mergeTextDecorationValues(newValue, downcast&lt;CSSValueList&gt;(*property.value()));
1242                 m_mutableStyle-&gt;setProperty(property.id(), WTFMove(newValue), property.isImportant());
1243                 continue;
1244             }
1245             value = nullptr; // text-decoration: none is equivalent to not having the property.
1246         }
1247 
1248         if (mode == OverrideValues || (mode == DoNotOverrideValues &amp;&amp; !value))
1249             m_mutableStyle-&gt;setProperty(property.id(), property.value(), property.isImportant());
1250     }
1251 
1252     int oldFontSizeDelta = m_fontSizeDelta;
1253     extractFontSizeDelta();
1254     m_fontSizeDelta += oldFontSizeDelta;
1255 }
1256 
1257 static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
1258 {
1259     auto style = MutableStyleProperties::create();
1260     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude)) {
1261         if (matchedRule-&gt;isStyleRule())
1262             style-&gt;mergeAndOverrideOnConflict(static_pointer_cast&lt;StyleRule&gt;(matchedRule)-&gt;properties());
1263     }
1264 
1265     return style;
1266 }
1267 
1268 void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
1269 {
1270     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
1271         StyleResolver::AuthorCSSRules);
1272     // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
1273     // over those from matched rules.
1274     if (m_mutableStyle)
1275         styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
1276 
1277     clear();
1278     m_mutableStyle = styleFromMatchedRules;
1279 }
1280 
<a name="6" id="anc6"></a>














1281 void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element)
1282 {
1283     mergeStyleFromRules(element);
1284 
1285     // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
1286     // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
1287     // FIXME: There are others like this, see &lt;rdar://problem/5195123&gt; Slashdot copy/paste fidelity problem
1288     auto fromComputedStyle = MutableStyleProperties::create();
1289     ComputedStyleExtractor computedStyle(&amp;element);
1290 
<a name="7" id="anc7"></a>
1291     {
1292         unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
1293         for (unsigned i = 0; i &lt; propertyCount; ++i) {
1294             StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
<a name="8" id="anc8"></a><span class="line-modified">1295             CSSValue* value = property.value();</span>
<span class="line-modified">1296             if (!is&lt;CSSPrimitiveValue&gt;(*value))</span>




1297                 continue;
<a name="9" id="anc9"></a><span class="line-modified">1298             if (downcast&lt;CSSPrimitiveValue&gt;(*value).isPercentage()) {</span>
1299                 if (auto computedPropertyValue = computedStyle.propertyValue(property.id()))
1300                     fromComputedStyle-&gt;addParsedProperty(CSSProperty(property.id(), WTFMove(computedPropertyValue)));
1301             }
1302         }
1303     }
<a name="10" id="anc10"></a>



1304     m_mutableStyle-&gt;mergeAndOverrideOnConflict(fromComputedStyle.get());
1305 }
1306 
1307 static void removePropertiesInStyle(MutableStyleProperties* styleToRemovePropertiesFrom, MutableStyleProperties* style)
1308 {
1309     unsigned propertyCount = style-&gt;propertyCount();
1310     Vector&lt;CSSPropertyID&gt; propertiesToRemove(propertyCount);
1311     for (unsigned i = 0; i &lt; propertyCount; ++i)
1312         propertiesToRemove[i] = style-&gt;propertyAt(i).id();
1313 
1314     styleToRemovePropertiesFrom-&gt;removePropertiesInSet(propertiesToRemove.data(), propertiesToRemove.size());
1315 }
1316 
1317 void EditingStyle::removeStyleFromRulesAndContext(StyledElement&amp; element, Node* context)
1318 {
1319     if (!m_mutableStyle)
1320         return;
1321 
1322     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
1323     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, StyleResolver::AllButEmptyCSSRules);
1324     if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
1325         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
1326 
1327     // 2. Remove style present in context and not overridden by matched rules.
1328     auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
1329     if (computedStyle-&gt;m_mutableStyle) {
1330         if (!computedStyle-&gt;m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor))
1331             computedStyle-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, CSSValueTransparent);
1332 
1333         removePropertiesInStyle(computedStyle-&gt;m_mutableStyle.get(), styleFromMatchedRules.get());
1334         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *computedStyle-&gt;m_mutableStyle);
1335     }
1336 
1337     // 3. If this element is a span and has display: inline or float: none, remove them unless they are overridden by rules.
1338     // These rules are added by serialization code to wrap text nodes.
1339     if (isStyleSpanOrSpanWithOnlyStyleAttribute(element)) {
1340         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyDisplay) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyDisplay) == CSSValueInline)
1341             m_mutableStyle-&gt;removeProperty(CSSPropertyDisplay);
1342         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyFloat) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyFloat) == CSSValueNone)
1343             m_mutableStyle-&gt;removeProperty(CSSPropertyFloat);
1344     }
1345 }
1346 
1347 void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
1348 {
1349     if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
1350         return;
1351 
1352     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, StyleResolver::UAAndUserCSSRules);
1353 
1354     removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
1355 }
1356 
1357 template&lt;typename T&gt;
1358 void EditingStyle::removeEquivalentProperties(T&amp; style)
1359 {
1360     Vector&lt;CSSPropertyID&gt; propertiesToRemove;
1361     for (auto&amp; property : m_mutableStyle-&gt;m_propertyVector) {
1362         if (style.propertyMatches(property.id(), property.value()))
1363             propertiesToRemove.append(property.id());
1364     }
1365     // FIXME: This should use mass removal.
1366     for (auto&amp; property : propertiesToRemove)
1367         m_mutableStyle-&gt;removeProperty(property);
1368 }
1369 
1370 void EditingStyle::forceInline()
1371 {
1372     if (!m_mutableStyle)
1373         m_mutableStyle = MutableStyleProperties::create();
1374     const bool propertyIsImportant = true;
1375     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueInline, propertyIsImportant);
1376 }
1377 
1378 void EditingStyle::addDisplayContents()
1379 {
1380     if (!m_mutableStyle)
1381         m_mutableStyle = MutableStyleProperties::create();
1382     m_mutableStyle-&gt;setProperty(CSSPropertyDisplay, CSSValueContents);
1383 }
1384 
1385 bool EditingStyle::convertPositionStyle()
1386 {
1387     if (!m_mutableStyle)
1388         return false;
1389 
1390     auto&amp; cssValuePool = CSSValuePool::singleton();
<a name="11" id="anc11"></a><span class="line-modified">1391     RefPtr&lt;CSSPrimitiveValue&gt; sticky = cssValuePool.createIdentifierValue(CSSValueWebkitSticky);</span>
1392     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, sticky.get())) {
1393         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueStatic), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1394         return false;
1395     }
1396     RefPtr&lt;CSSPrimitiveValue&gt; fixed = cssValuePool.createIdentifierValue(CSSValueFixed);
1397     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, fixed.get())) {
1398         m_mutableStyle-&gt;setProperty(CSSPropertyPosition, cssValuePool.createIdentifierValue(CSSValueAbsolute), m_mutableStyle-&gt;propertyIsImportant(CSSPropertyPosition));
1399         return true;
1400     }
1401     RefPtr&lt;CSSPrimitiveValue&gt; absolute = cssValuePool.createIdentifierValue(CSSValueAbsolute);
1402     if (m_mutableStyle-&gt;propertyMatches(CSSPropertyPosition, absolute.get()))
1403         return true;
1404     return false;
1405 }
1406 
1407 bool EditingStyle::isFloating()
1408 {
1409     RefPtr&lt;CSSValue&gt; v = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFloat);
1410     RefPtr&lt;CSSPrimitiveValue&gt; noneValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1411     return v &amp;&amp; !v-&gt;equals(*noneValue);
1412 }
1413 
1414 int EditingStyle::legacyFontSize(Document&amp; document) const
1415 {
1416     RefPtr&lt;CSSValue&gt; cssValue = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
1417     if (!is&lt;CSSPrimitiveValue&gt;(cssValue))
1418         return 0;
1419     return legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(cssValue.get()),
1420         m_shouldUseFixedDefaultFontSize, AlwaysUseLegacyFontSize);
1421 }
1422 
1423 bool EditingStyle::hasStyle(CSSPropertyID propertyID, const String&amp; value)
1424 {
1425     return EditingStyle::create(propertyID, value)-&gt;triStateOfStyle(this) != FalseTriState;
1426 }
1427 
1428 RefPtr&lt;EditingStyle&gt; EditingStyle::styleAtSelectionStart(const VisibleSelection&amp; selection, bool shouldUseBackgroundColorInEffect)
1429 {
1430     if (selection.isNone())
1431         return nullptr;
1432 
1433     Position position = adjustedSelectionStartForStyleComputation(selection);
1434 
1435     // If the pos is at the end of a text node, then this node is not fully selected.
1436     // Move it to the next deep equivalent position to avoid removing the style from this node.
1437     // e.g. if pos was at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;div&gt;world&lt;/div&gt;&lt;/b&gt;, we want Position(&quot;world&quot;, 0) instead.
1438     // We only do this for range because caret at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;/b&gt;world should give you font-weight: bold.
1439     Node* positionNode = position.containerNode();
1440     if (selection.isRange() &amp;&amp; positionNode &amp;&amp; positionNode-&gt;isTextNode() &amp;&amp; position.computeOffsetInContainerNode() == positionNode-&gt;maxCharacterOffset())
1441         position = nextVisuallyDistinctCandidate(position);
1442 
1443     Element* element = position.element();
1444     if (!element)
1445         return nullptr;
1446 
1447     auto style = EditingStyle::create(element, EditingStyle::AllProperties);
1448     style-&gt;mergeTypingStyle(element-&gt;document());
1449 
1450     // If background color is transparent, traverse parent nodes until we hit a different value or document root
1451     // Also, if the selection is a range, ignore the background color at the start of selection,
1452     // and find the background color of the common ancestor.
1453     if (shouldUseBackgroundColorInEffect &amp;&amp; (selection.isRange() || hasTransparentBackgroundColor(style-&gt;m_mutableStyle.get()))) {
1454         if (auto range = selection.toNormalizedRange()) {
1455             if (auto value = backgroundColorInEffect(range-&gt;commonAncestorContainer()))
1456                 style-&gt;setProperty(CSSPropertyBackgroundColor, value-&gt;cssText());
1457         }
1458     }
1459 
<a name="12" id="anc12"></a><span class="line-modified">1460     return WTFMove(style);</span>
1461 }
1462 
1463 WritingDirection EditingStyle::textDirectionForSelection(const VisibleSelection&amp; selection, EditingStyle* typingStyle, bool&amp; hasNestedOrMultipleEmbeddings)
1464 {
1465     hasNestedOrMultipleEmbeddings = true;
1466 
1467     if (selection.isNone())
1468         return WritingDirection::Natural;
1469 
1470     Position position = selection.start().downstream();
1471 
1472     Node* node = position.deprecatedNode();
1473     if (!node)
1474         return WritingDirection::Natural;
1475 
1476     Position end;
1477     if (selection.isRange()) {
1478         end = selection.end().upstream();
1479 
1480         Node* pastLast = Range::create(*end.document(), position.parentAnchoredEquivalent(), end.parentAnchoredEquivalent())-&gt;pastLastNode();
1481         for (Node* n = node; n &amp;&amp; n != pastLast; n = NodeTraversal::next(*n)) {
1482             if (!n-&gt;isStyledElement())
1483                 continue;
1484 
1485             RefPtr&lt;CSSValue&gt; unicodeBidi = ComputedStyleExtractor(n).propertyValue(CSSPropertyUnicodeBidi);
1486             if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1487                 continue;
1488 
1489             CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1490             if (unicodeBidiValue == CSSValueEmbed || unicodeBidiValue == CSSValueBidiOverride)
1491                 return WritingDirection::Natural;
1492         }
1493     }
1494 
1495     if (selection.isCaret()) {
1496         if (typingStyle) {
1497             if (auto direction = typingStyle-&gt;textDirection()) {
1498                 hasNestedOrMultipleEmbeddings = false;
1499                 return *direction;
1500             }
1501         }
1502         node = selection.visibleStart().deepEquivalent().deprecatedNode();
1503     }
1504 
1505     // The selection is either a caret with no typing attributes or a range in which no embedding is added, so just use the start position
1506     // to decide.
1507     Node* block = enclosingBlock(node);
1508     auto foundDirection = WritingDirection::Natural;
1509 
1510     for (; node != block; node = node-&gt;parentNode()) {
1511         if (!node-&gt;isStyledElement())
1512             continue;
1513 
1514         ComputedStyleExtractor computedStyle(node);
1515         RefPtr&lt;CSSValue&gt; unicodeBidi = computedStyle.propertyValue(CSSPropertyUnicodeBidi);
1516         if (!is&lt;CSSPrimitiveValue&gt;(unicodeBidi))
1517             continue;
1518 
1519         CSSValueID unicodeBidiValue = downcast&lt;CSSPrimitiveValue&gt;(*unicodeBidi).valueID();
1520         if (unicodeBidiValue == CSSValueNormal)
1521             continue;
1522 
1523         if (unicodeBidiValue == CSSValueBidiOverride)
1524             return WritingDirection::Natural;
1525 
1526         ASSERT(unicodeBidiValue == CSSValueEmbed);
1527         RefPtr&lt;CSSValue&gt; direction = computedStyle.propertyValue(CSSPropertyDirection);
1528         if (!is&lt;CSSPrimitiveValue&gt;(direction))
1529             continue;
1530 
1531         CSSValueID directionValue = downcast&lt;CSSPrimitiveValue&gt;(*direction).valueID();
1532         if (directionValue != CSSValueLtr &amp;&amp; directionValue != CSSValueRtl)
1533             continue;
1534 
1535         if (foundDirection != WritingDirection::Natural)
1536             return WritingDirection::Natural;
1537 
1538         // In the range case, make sure that the embedding element persists until the end of the range.
1539         if (selection.isRange() &amp;&amp; !end.deprecatedNode()-&gt;isDescendantOf(*node))
1540             return WritingDirection::Natural;
1541 
1542         foundDirection = directionValue == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
1543     }
1544     hasNestedOrMultipleEmbeddings = false;
1545     return foundDirection;
1546 }
1547 
1548 Ref&lt;EditingStyle&gt; EditingStyle::inverseTransformColorIfNeeded(Element&amp; element)
1549 {
1550     auto* renderer = element.renderer();
1551     if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
1552         return *this;
1553 
1554     bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
1555     bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
1556     if (!hasColor &amp;&amp; !hasBackgroundColor)
1557         return *this;
1558 
1559     auto styleWithInvertedColors = copy();
1560     ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
1561 
1562     const auto&amp; colorFilter = renderer-&gt;style().appleColorFilter();
1563     auto invertedColor = [&amp;](CSSPropertyID propertyID) {
1564         Color newColor = cssValueToColor(extractPropertyValue(*m_mutableStyle, propertyID).get());
1565         colorFilter.inverseTransformColor(newColor);
1566         styleWithInvertedColors-&gt;m_mutableStyle-&gt;setProperty(propertyID, newColor.cssText());
1567     };
1568 
1569     if (hasColor)
1570         invertedColor(CSSPropertyColor);
1571 
1572     if (hasBackgroundColor)
1573         invertedColor(CSSPropertyBackgroundColor);
1574 
1575     return styleWithInvertedColors;
1576 }
1577 
1578 static void reconcileTextDecorationProperties(MutableStyleProperties* style)
1579 {
1580     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = style-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
1581     RefPtr&lt;CSSValue&gt; textDecoration = style-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
1582     // We shouldn&#39;t have both text-decoration and -webkit-text-decorations-in-effect because that wouldn&#39;t make sense.
1583     ASSERT(!textDecorationsInEffect || !textDecoration);
1584     if (textDecorationsInEffect) {
1585         style-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText());
1586         style-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
1587         textDecoration = textDecorationsInEffect;
1588     }
1589 
1590     // If text-decoration is set to &quot;none&quot;, remove the property because we don&#39;t want to add redundant &quot;text-decoration: none&quot;.
1591     if (textDecoration &amp;&amp; !textDecoration-&gt;isValueList())
1592         style-&gt;removeProperty(CSSPropertyTextDecoration);
1593 }
1594 
1595 StyleChange::StyleChange(EditingStyle* style, const Position&amp; position)
1596     : m_applyBold(false)
1597     , m_applyItalic(false)
1598     , m_applyUnderline(false)
1599     , m_applyLineThrough(false)
1600     , m_applySubscript(false)
1601     , m_applySuperscript(false)
1602 {
1603     Document* document = position.deprecatedNode() ? &amp;position.deprecatedNode()-&gt;document() : 0;
1604     if (!style || style-&gt;isEmpty() || !document || !document-&gt;frame())
1605         return;
1606 
1607     Node* node = position.containerNode();
1608     if (!node)
1609         return;
1610 
1611     ComputedStyleExtractor computedStyle(node);
1612 
1613     // FIXME: take care of background-color in effect
1614     RefPtr&lt;MutableStyleProperties&gt; mutableStyle = style-&gt;style() ?
1615         getPropertiesNotIn(*style-&gt;style(), computedStyle) : MutableStyleProperties::create();
1616 
1617     reconcileTextDecorationProperties(mutableStyle.get());
1618     bool shouldStyleWithCSS = document-&gt;frame()-&gt;editor().shouldStyleWithCSS();
1619     if (!shouldStyleWithCSS)
1620         extractTextStyles(*document, *mutableStyle, computedStyle.useFixedFontDefaultSize());
1621 
1622     bool shouldAddUnderline = style-&gt;underlineChange() == TextDecorationChange::Add;
1623     bool shouldAddStrikeThrough = style-&gt;strikeThroughChange() == TextDecorationChange::Add;
1624     if (shouldAddUnderline || shouldAddStrikeThrough) {
1625         RefPtr&lt;CSSValue&gt; value = computedStyle.propertyValue(CSSPropertyWebkitTextDecorationsInEffect);
1626         if (!is&lt;CSSValueList&gt;(value))
1627             value = computedStyle.propertyValue(CSSPropertyTextDecoration);
1628 
1629         RefPtr&lt;CSSValueList&gt; valueList;
1630         if (is&lt;CSSValueList&gt;(value))
1631             valueList = downcast&lt;CSSValueList&gt;(value.get());
1632 
1633         auto&amp; cssValuePool = CSSValuePool::singleton();
1634         Ref&lt;CSSValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1635         bool hasUnderline = valueList &amp;&amp; valueList-&gt;hasValue(underline.ptr());
1636 
1637         Ref&lt;CSSValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1638         bool hasLineThrough = valueList &amp;&amp; valueList-&gt;hasValue(lineThrough.ptr());
1639 
1640         if (shouldStyleWithCSS) {
1641             valueList = valueList ? valueList-&gt;copy() : CSSValueList::createSpaceSeparated();
1642             if (shouldAddUnderline &amp;&amp; !hasUnderline)
1643                 valueList-&gt;append(WTFMove(underline));
1644             if (shouldAddStrikeThrough &amp;&amp; !hasLineThrough)
1645                 valueList-&gt;append(WTFMove(lineThrough));
1646             mutableStyle-&gt;setProperty(CSSPropertyTextDecoration, valueList.get());
1647         } else {
1648             m_applyUnderline = shouldAddUnderline &amp;&amp; !hasUnderline;
1649             m_applyLineThrough = shouldAddStrikeThrough &amp;&amp; !hasLineThrough;
1650         }
1651     }
1652 
1653     // Changing the whitespace style in a tab span would collapse the tab into a space.
1654     if (isTabSpanTextNode(position.deprecatedNode()) || isTabSpanNode((position.deprecatedNode())))
1655         mutableStyle-&gt;removeProperty(CSSPropertyWhiteSpace);
1656 
1657     // If unicode-bidi is present in mutableStyle and direction is not, then add direction to mutableStyle.
1658     // FIXME: Shouldn&#39;t this be done in getPropertiesNotIn?
1659     if (mutableStyle-&gt;getPropertyCSSValue(CSSPropertyUnicodeBidi) &amp;&amp; !style-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyDirection))
1660         mutableStyle-&gt;setProperty(CSSPropertyDirection, style-&gt;style()-&gt;getPropertyValue(CSSPropertyDirection));
1661 
1662     if (!mutableStyle-&gt;isEmpty())
1663         m_cssStyle = mutableStyle;
1664 }
1665 
1666 bool StyleChange::operator==(const StyleChange&amp; other)
1667 {
1668     if (m_applyBold != other.m_applyBold
1669         || m_applyItalic != other.m_applyItalic
1670         || m_applyUnderline != other.m_applyUnderline
1671         || m_applyLineThrough != other.m_applyLineThrough
1672         || m_applySubscript != other.m_applySubscript
1673         || m_applySuperscript != other.m_applySuperscript
1674         || m_applyFontColor != other.m_applyFontColor
1675         || m_applyFontFace != other.m_applyFontFace
1676         || m_applyFontSize != other.m_applyFontSize)
1677         return false;
1678 
1679     return (!m_cssStyle &amp;&amp; !other.m_cssStyle)
1680         || (m_cssStyle &amp;&amp; other.m_cssStyle &amp;&amp; m_cssStyle-&gt;asText() == other.m_cssStyle-&gt;asText());
1681 }
1682 
1683 static void setTextDecorationProperty(MutableStyleProperties&amp; style, const CSSValueList* newTextDecoration, CSSPropertyID propertyID)
1684 {
1685     if (newTextDecoration-&gt;length())
1686         style.setProperty(propertyID, newTextDecoration-&gt;cssText(), style.propertyIsImportant(propertyID));
1687     else {
1688         // text-decoration: none is redundant since it does not remove any text decorations.
1689         style.removeProperty(propertyID);
1690     }
1691 }
1692 
1693 void StyleChange::extractTextStyles(Document&amp; document, MutableStyleProperties&amp; style, bool shouldUseFixedFontDefaultSize)
1694 {
1695     if (identifierForStyleProperty(style, CSSPropertyFontWeight) == CSSValueBold) {
1696         style.removeProperty(CSSPropertyFontWeight);
1697         m_applyBold = true;
1698     }
1699 
1700     int fontStyle = identifierForStyleProperty(style, CSSPropertyFontStyle);
1701     if (fontStyle == CSSValueItalic || fontStyle == CSSValueOblique) {
1702         style.removeProperty(CSSPropertyFontStyle);
1703         m_applyItalic = true;
1704     }
1705 
1706     // Assuming reconcileTextDecorationProperties has been called, there should not be -webkit-text-decorations-in-effect
1707     // Furthermore, text-decoration: none has been trimmed so that text-decoration property is always a CSSValueList.
1708     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(CSSPropertyTextDecoration);
1709     if (is&lt;CSSValueList&gt;(textDecoration)) {
1710         auto&amp; cssValuePool = CSSValuePool::singleton();
1711         RefPtr&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1712         RefPtr&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1713 
1714         RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1715         if (newTextDecoration-&gt;removeAll(underline.get()))
1716             m_applyUnderline = true;
1717         if (newTextDecoration-&gt;removeAll(lineThrough.get()))
1718             m_applyLineThrough = true;
1719 
1720         // If trimTextDecorations, delete underline and line-through
1721         setTextDecorationProperty(style, newTextDecoration.get(), CSSPropertyTextDecoration);
1722     }
1723 
1724     int verticalAlign = identifierForStyleProperty(style, CSSPropertyVerticalAlign);
1725     switch (verticalAlign) {
1726     case CSSValueSub:
1727         style.removeProperty(CSSPropertyVerticalAlign);
1728         m_applySubscript = true;
1729         break;
1730     case CSSValueSuper:
1731         style.removeProperty(CSSPropertyVerticalAlign);
1732         m_applySuperscript = true;
1733         break;
1734     }
1735 
1736     if (style.getPropertyCSSValue(CSSPropertyColor)) {
1737         auto color = textColorFromStyle(style);
1738         if (color.isOpaque()) {
1739             m_applyFontColor = color.serialized();
1740             style.removeProperty(CSSPropertyColor);
1741         }
1742     }
1743 
1744     m_applyFontFace = style.getPropertyValue(CSSPropertyFontFamily);
1745     // Remove quotes for Outlook 2007 compatibility. See https://bugs.webkit.org/show_bug.cgi?id=79448
1746     m_applyFontFace.replaceWithLiteral(&#39;\&quot;&#39;, &quot;&quot;);
1747     style.removeProperty(CSSPropertyFontFamily);
1748 
1749     if (RefPtr&lt;CSSValue&gt; fontSize = style.getPropertyCSSValue(CSSPropertyFontSize)) {
1750         if (!is&lt;CSSPrimitiveValue&gt;(*fontSize))
1751             style.removeProperty(CSSPropertyFontSize); // Can&#39;t make sense of the number. Put no font size.
1752         else if (int legacyFontSize = legacyFontSizeFromCSSValue(document, downcast&lt;CSSPrimitiveValue&gt;(fontSize.get()),
1753                 shouldUseFixedFontDefaultSize, UseLegacyFontSizeOnlyIfPixelValuesMatch)) {
1754             m_applyFontSize = String::number(legacyFontSize);
1755             style.removeProperty(CSSPropertyFontSize);
1756         }
1757     }
1758 }
1759 
1760 static void diffTextDecorations(MutableStyleProperties&amp; style, CSSPropertyID propertID, CSSValue* refTextDecoration)
1761 {
1762     RefPtr&lt;CSSValue&gt; textDecoration = style.getPropertyCSSValue(propertID);
1763     if (!is&lt;CSSValueList&gt;(textDecoration) || !is&lt;CSSValueList&gt;(refTextDecoration))
1764         return;
1765 
1766     RefPtr&lt;CSSValueList&gt; newTextDecoration = downcast&lt;CSSValueList&gt;(*textDecoration).copy();
1767 
1768     for (auto&amp; value :  downcast&lt;CSSValueList&gt;(*refTextDecoration))
1769         newTextDecoration-&gt;removeAll(&amp;value.get());
1770 
1771     setTextDecorationProperty(style, newTextDecoration.get(), propertID);
1772 }
1773 
1774 static bool fontWeightIsBold(CSSValue&amp; fontWeight)
1775 {
1776     if (!is&lt;CSSPrimitiveValue&gt;(fontWeight))
1777         return false;
1778 
1779     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(fontWeight);
1780     switch (primitiveValue.valueID()) {
1781         case CSSValueNormal:
1782             return false;
1783         case CSSValueBold:
1784             return true;
1785         default:
1786             break;
1787     }
1788 
1789     ASSERT(primitiveValue.isNumber());
1790     return primitiveValue.floatValue() &gt;= static_cast&lt;float&gt;(boldThreshold());
1791 }
1792 
1793 template&lt;typename T&gt;
1794 static bool fontWeightIsBold(T&amp; style)
1795 {
1796     RefPtr&lt;CSSValue&gt; fontWeight = extractPropertyValue(style, CSSPropertyFontWeight);
1797     return fontWeight &amp;&amp; fontWeightIsBold(*fontWeight);
1798 }
1799 
1800 template&lt;typename T&gt;
1801 static Ref&lt;MutableStyleProperties&gt; extractPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1802 {
1803     auto result = EditingStyle::create(&amp;styleWithRedundantProperties);
1804     result-&gt;removeEquivalentProperties(baseStyle);
1805     ASSERT(result-&gt;style());
1806     Ref&lt;MutableStyleProperties&gt; mutableStyle = *result-&gt;style();
1807 
1808     RefPtr&lt;CSSValue&gt; baseTextDecorationsInEffect = extractPropertyValue(baseStyle, CSSPropertyWebkitTextDecorationsInEffect);
1809     diffTextDecorations(mutableStyle, CSSPropertyTextDecoration, baseTextDecorationsInEffect.get());
1810     diffTextDecorations(mutableStyle, CSSPropertyWebkitTextDecorationsInEffect, baseTextDecorationsInEffect.get());
1811 
1812     if (extractPropertyValue(baseStyle, CSSPropertyFontWeight) &amp;&amp; fontWeightIsBold(mutableStyle) == fontWeightIsBold(baseStyle))
1813         mutableStyle-&gt;removeProperty(CSSPropertyFontWeight);
1814 
1815     if (extractPropertyValue(baseStyle, CSSPropertyColor) &amp;&amp; equalIgnoringSemanticColor(textColorFromStyle(mutableStyle), textColorFromStyle(baseStyle)))
1816         mutableStyle-&gt;removeProperty(CSSPropertyColor);
1817 
1818     if (extractPropertyValue(baseStyle, CSSPropertyCaretColor) &amp;&amp; equalIgnoringSemanticColor(caretColorFromStyle(mutableStyle), caretColorFromStyle(baseStyle)))
1819         mutableStyle-&gt;removeProperty(CSSPropertyCaretColor);
1820 
1821     if (extractPropertyValue(baseStyle, CSSPropertyTextAlign)
1822         &amp;&amp; textAlignResolvingStartAndEnd(mutableStyle) == textAlignResolvingStartAndEnd(baseStyle))
1823         mutableStyle-&gt;removeProperty(CSSPropertyTextAlign);
1824 
1825     if (extractPropertyValue(baseStyle, CSSPropertyBackgroundColor) &amp;&amp; equalIgnoringSemanticColor(backgroundColorFromStyle(mutableStyle), backgroundColorFromStyle(baseStyle)))
1826         mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1827 
1828     return mutableStyle;
1829 }
1830 
1831 template&lt;typename T&gt;
1832 Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1833 {
1834     return extractPropertiesNotIn(styleWithRedundantProperties, baseStyle);
1835 }
1836 
1837 static bool isCSSValueLength(CSSPrimitiveValue* value)
1838 {
1839     return value-&gt;isFontIndependentLength();
1840 }
1841 
1842 int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
1843 {
1844     if (isCSSValueLength(value)) {
1845         int pixelFontSize = value-&gt;intValue(CSSPrimitiveValue::CSS_PX);
1846         int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
1847         // Use legacy font size only if pixel value matches exactly to that of legacy font size.
1848         int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
1849         if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
1850             return legacyFontSize;
1851 
1852         return 0;
1853     }
1854 
1855     if (CSSValueXSmall &lt;= value-&gt;valueID() &amp;&amp; value-&gt;valueID() &lt;= CSSValueWebkitXxxLarge)
1856         return value-&gt;valueID() - CSSValueXSmall + 1;
1857 
1858     return 0;
1859 }
1860 
1861 static bool isTransparentColorValue(CSSValue* value)
1862 {
1863     if (!value)
1864         return true;
1865     if (!is&lt;CSSPrimitiveValue&gt;(*value))
1866         return false;
1867     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
1868     if (primitiveValue.isRGBColor())
1869         return !primitiveValue.color().isVisible();
1870     return primitiveValue.valueID() == CSSValueTransparent;
1871 }
1872 
1873 bool hasTransparentBackgroundColor(StyleProperties* style)
1874 {
1875     return isTransparentColorValue(style-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor).get());
1876 }
1877 
1878 RefPtr&lt;CSSValue&gt; backgroundColorInEffect(Node* node)
1879 {
1880     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1881         if (auto value = ComputedStyleExtractor(ancestor).propertyValue(CSSPropertyBackgroundColor)) {
1882             if (!isTransparentColorValue(value.get()))
1883                 return value;
1884         }
1885     }
1886     return nullptr;
1887 }
1888 
1889 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>