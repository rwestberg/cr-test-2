<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2009 Torch Mobile, Inc.
   5  *  Copyright (C) 2015 Jordan Harband (ljharb@gmail.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;StringPrototype.h&quot;
  25 
  26 #include &quot;BuiltinNames.h&quot;
  27 #include &quot;ButterflyInlines.h&quot;
  28 #include &quot;CachedCall.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;FrameTracers.h&quot;
  31 #include &quot;InterpreterInlines.h&quot;
  32 #include &quot;IntlCollator.h&quot;
  33 #include &quot;IntlObject.h&quot;
  34 #include &quot;JITCodeInlines.h&quot;
  35 #include &quot;JSArray.h&quot;
  36 #include &quot;JSCBuiltins.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSGlobalObjectFunctions.h&quot;
  40 #include &quot;JSStringIterator.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;ObjectPrototype.h&quot;
  43 #include &quot;ParseInt.h&quot;
  44 #include &quot;PropertyNameArray.h&quot;
  45 #include &quot;RegExpCache.h&quot;
  46 #include &quot;RegExpConstructor.h&quot;
  47 #include &quot;RegExpGlobalDataInlines.h&quot;
  48 #include &quot;StringPrototypeInlines.h&quot;
  49 #include &quot;SuperSampler.h&quot;
  50 #include &lt;algorithm&gt;
  51 #include &lt;unicode/uconfig.h&gt;
  52 #include &lt;unicode/unorm2.h&gt;
  53 #include &lt;unicode/ustring.h&gt;
  54 #include &lt;wtf/ASCIICType.h&gt;
  55 #include &lt;wtf/MathExtras.h&gt;
  56 #include &lt;wtf/text/StringBuilder.h&gt;
  57 #include &lt;wtf/text/StringView.h&gt;
  58 #include &lt;wtf/unicode/Collator.h&gt;
  59 
  60 namespace JSC {
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringPrototype);
  63 
  64 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState*);
  65 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState*);
  66 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState*);
  67 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState*);
  68 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);
  69 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);
  70 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState*);
  71 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState*);
  72 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState*);
  73 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState*);
  74 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState*);
  75 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState*);
  76 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState*);
  77 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState*);
  78 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState*);
  79 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState*);
  80 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState*);
  81 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState*);
  88 
  89 }
  90 
  91 #include &quot;StringPrototype.lut.h&quot;
  92 
  93 namespace JSC {
  94 
  95 const ClassInfo StringPrototype::s_info = { &quot;String&quot;, &amp;StringObject::s_info, &amp;stringPrototypeTable, nullptr, CREATE_METHOD_TABLE(StringPrototype) };
  96 
  97 /* Source for StringConstructor.lut.h
  98 @begin stringPrototypeTable
  99     concat    JSBuiltin    DontEnum|Function 1
 100     match     JSBuiltin    DontEnum|Function 1
 101     matchAll  JSBuiltin    DontEnum|Function 1
 102     padStart  JSBuiltin    DontEnum|Function 1
 103     padEnd    JSBuiltin    DontEnum|Function 1
 104     repeat    JSBuiltin    DontEnum|Function 1
 105     replace   JSBuiltin    DontEnum|Function 2
 106     search    JSBuiltin    DontEnum|Function 1
 107     split     JSBuiltin    DontEnum|Function 1
 108     anchor    JSBuiltin    DontEnum|Function 1
 109     big       JSBuiltin    DontEnum|Function 0
 110     bold      JSBuiltin    DontEnum|Function 0
 111     blink     JSBuiltin    DontEnum|Function 0
 112     fixed     JSBuiltin    DontEnum|Function 0
 113     fontcolor JSBuiltin    DontEnum|Function 1
 114     fontsize  JSBuiltin    DontEnum|Function 1
 115     italics   JSBuiltin    DontEnum|Function 0
 116     link      JSBuiltin    DontEnum|Function 1
 117     small     JSBuiltin    DontEnum|Function 0
 118     strike    JSBuiltin    DontEnum|Function 0
 119     sub       JSBuiltin    DontEnum|Function 0
 120     sup       JSBuiltin    DontEnum|Function 0
 121 @end
 122 */
 123 
 124 // ECMA 15.5.4
 125 StringPrototype::StringPrototype(VM&amp; vm, Structure* structure)
 126     : StringObject(vm, structure)
 127 {
 128 }
 129 
 130 void StringPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, JSString* nameAndMessage)
 131 {
 132     Base::finishCreation(vm, nameAndMessage);
 133     ASSERT(inherits(vm, info()));
 134 
 135     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 136     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;valueOf, stringProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeValueOfIntrinsic);
 137     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charAt&quot;, stringProtoFuncCharAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharAtIntrinsic);
 138     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;charCodeAt&quot;, stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 139     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;codePointAt&quot;, stringProtoFuncCodePointAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 140     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, stringProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 141     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, stringProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 142     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingRegExpPrivateName(), stringProtoFuncReplaceUsingRegExp, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeReplaceRegExpIntrinsic);
 143     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().replaceUsingStringSearchPrivateName(), stringProtoFuncReplaceUsingStringSearch, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 144     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;slice&quot;, stringProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, StringPrototypeSliceIntrinsic);
 145     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substr&quot;, stringProtoFuncSubstr, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 146     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;substring&quot;, stringProtoFuncSubstring, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 147     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;toLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, StringPrototypeToLowerCaseIntrinsic);
 148     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 149     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;localeCompare&quot;, stringProtoFuncLocaleCompare, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 150 #if ENABLE(INTL)
 151     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLocaleLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 152     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToLocaleUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 153 #else
 154     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleLowerCase&quot;, stringProtoFuncToLowerCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 155     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleUpperCase&quot;, stringProtoFuncToUpperCase, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 156 #endif
 157     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;trim&quot;, stringProtoFuncTrim, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 158     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;startsWith&quot;, stringProtoFuncStartsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 159     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;endsWith&quot;, stringProtoFuncEndsWith, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 160     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, stringProtoFuncIncludes, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 161     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;normalize&quot;, stringProtoFuncNormalize, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 162     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().charCodeAtPrivateName(), stringProtoFuncCharCodeAt, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, CharCodeAtIntrinsic);
 163 
 164     JSFunction* trimStartFunction = JSFunction::create(vm, globalObject, 0, &quot;trimStart&quot;_s, stringProtoFuncTrimStart, NoIntrinsic);
 165     JSFunction* trimEndFunction = JSFunction::create(vm, globalObject, 0, &quot;trimEnd&quot;_s, stringProtoFuncTrimEnd, NoIntrinsic);
 166     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimStart&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 167     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimLeft&quot;), trimStartFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 168     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimEnd&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 169     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;trimRight&quot;), trimEndFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 170 
 171     JSFunction* iteratorFunction = JSFunction::create(vm, globalObject, 0, &quot;[Symbol.iterator]&quot;_s, stringProtoFuncIterator, NoIntrinsic);
 172     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, iteratorFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 173 
 174     // The constructor will be added later, after StringConstructor has been built
 175     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(0), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 176 }
 177 
 178 StringPrototype* StringPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 179 {
 180     JSString* empty = jsEmptyString(vm);
 181     StringPrototype* prototype = new (NotNull, allocateCell&lt;StringPrototype&gt;(vm.heap)) StringPrototype(vm, structure);
 182     prototype-&gt;finishCreation(vm, globalObject, empty);
 183     return prototype;
 184 }
 185 
 186 // ------------------------------ Functions --------------------------
 187 
 188 static NEVER_INLINE void substituteBackreferencesSlow(StringBuilder&amp; result, StringView replacement, StringView source, const int* ovector, RegExp* reg, size_t i)
 189 {
 190     bool hasNamedCaptures = reg &amp;&amp; reg-&gt;hasNamedCaptures();
 191     int offset = 0;
 192     do {
 193         if (i + 1 == replacement.length())
 194             break;
 195 
 196         UChar ref = replacement[i + 1];
 197         if (ref == &#39;$&#39;) {
 198             // &quot;$$&quot; -&gt; &quot;$&quot;
 199             ++i;
 200             result.append(replacement.substring(offset, i - offset));
 201             offset = i + 1;
 202             continue;
 203         }
 204 
 205         int backrefStart;
 206         int backrefLength;
 207         int advance = 0;
 208         if (ref == &#39;&amp;&#39;) {
 209             backrefStart = ovector[0];
 210             backrefLength = ovector[1] - backrefStart;
 211         } else if (ref == &#39;`&#39;) {
 212             backrefStart = 0;
 213             backrefLength = ovector[0];
 214         } else if (ref == &#39;\&#39;&#39;) {
 215             backrefStart = ovector[1];
 216             backrefLength = source.length() - backrefStart;
 217         } else if (reg &amp;&amp; ref == &#39;&lt;&#39;) {
 218             // Named back reference
 219             if (!hasNamedCaptures) {
 220                 result.append(replacement.substring(i, 2));
 221                 offset = i + 2;
 222                 advance = 1;
 223                 continue;
 224             }
 225 
 226             size_t closingBracket = replacement.find(&#39;&gt;&#39;, i + 2);
 227             if (closingBracket == WTF::notFound) {
 228                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
 229                 // Current proposed spec change throws a syntax error in this case.
 230                 // We have made the case that it makes more sense to treat this a literal
 231                 // If throwSyntaxError(exec, scope, &quot;Missing closing &#39;&gt;&#39; in replacement text&quot;);
 232                 continue;
 233             }
 234 
 235             unsigned nameLength = closingBracket - i - 2;
 236             unsigned backrefIndex = reg-&gt;subpatternForName(replacement.substring(i + 2, nameLength).toString());
 237 
 238             if (!backrefIndex || backrefIndex &gt; reg-&gt;numSubpatterns()) {
 239                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176434
 240                 // Proposed spec change throws a throw syntax error in this case.
 241                 // We have made the case that a non-existent back reference should be replaced with
 242                 // and empty string.
 243                 // throwSyntaxError(exec, scope, makeString(&quot;Replacement text references non-existent backreference \&quot;&quot; + replacement.substring(i + 2, nameLength).toString()));
 244                 backrefStart = 0;
 245                 backrefLength = 0;
 246             } else {
 247                 backrefStart = ovector[2 * backrefIndex];
 248                 backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 249             }
 250             advance = nameLength + 1;
 251         } else if (reg &amp;&amp; isASCIIDigit(ref)) {
 252             // 1- and 2-digit back references are allowed
 253             unsigned backrefIndex = ref - &#39;0&#39;;
 254             if (backrefIndex &gt; reg-&gt;numSubpatterns())
 255                 continue;
 256             if (replacement.length() &gt; i + 2) {
 257                 ref = replacement[i + 2];
 258                 if (isASCIIDigit(ref)) {
 259                     backrefIndex = 10 * backrefIndex + ref - &#39;0&#39;;
 260                     if (backrefIndex &gt; reg-&gt;numSubpatterns())
 261                         backrefIndex = backrefIndex / 10;   // Fall back to the 1-digit reference
 262                     else
 263                         advance = 1;
 264                 }
 265             }
 266             if (!backrefIndex)
 267                 continue;
 268             backrefStart = ovector[2 * backrefIndex];
 269             backrefLength = ovector[2 * backrefIndex + 1] - backrefStart;
 270         } else
 271             continue;
 272 
 273         if (i - offset)
 274             result.append(replacement.substring(offset, i - offset));
 275         i += 1 + advance;
 276         offset = i + 1;
 277         if (backrefStart &gt;= 0)
 278             result.append(source.substring(backrefStart, backrefLength));
 279     } while ((i = replacement.find(&#39;$&#39;, i + 1)) != notFound);
 280 
 281     if (replacement.length() - offset)
 282         result.append(replacement.substring(offset));
 283 }
 284 
 285 inline void substituteBackreferencesInline(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 286 {
 287     size_t i = replacement.find(&#39;$&#39;);
 288     if (UNLIKELY(i != notFound))
 289         return substituteBackreferencesSlow(result, replacement, source, ovector, reg, i);
 290 
 291     result.append(replacement);
 292 }
 293 
 294 void substituteBackreferences(StringBuilder&amp; result, const String&amp; replacement, StringView source, const int* ovector, RegExp* reg)
 295 {
 296     substituteBackreferencesInline(result, replacement, source, ovector, reg);
 297 }
 298 
 299 struct StringRange {
 300     StringRange(int pos, int len)
 301         : position(pos)
 302         , length(len)
 303     {
 304     }
 305 
 306     StringRange()
 307     {
 308     }
 309 
 310     int position;
 311     int length;
 312 };
 313 
 314 static ALWAYS_INLINE JSString* jsSpliceSubstrings(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount)
 315 {
 316     VM&amp; vm = exec-&gt;vm();
 317     auto scope = DECLARE_THROW_SCOPE(vm);
 318 
 319     if (rangeCount == 1) {
 320         int sourceSize = source.length();
 321         int position = substringRanges[0].position;
 322         int length = substringRanges[0].length;
 323         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 324             return sourceVal;
 325         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 326         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 327     }
 328 
 329     // We know that the sum of substringRanges lengths cannot exceed length of
 330     // source because the substringRanges were computed from the source string
 331     // in removeUsingRegExpSearch(). Hence, totalLength cannot exceed
 332     // String::MaxLength, and therefore, cannot overflow.
 333     Checked&lt;int, AssertNoOverflow&gt; totalLength = 0;
 334     for (int i = 0; i &lt; rangeCount; i++)
 335         totalLength += substringRanges[i].length;
 336     ASSERT(totalLength &lt;= String::MaxLength);
 337 
 338     if (!totalLength)
 339         return jsEmptyString(vm);
 340 
 341     if (source.is8Bit()) {
 342         LChar* buffer;
 343         const LChar* sourceData = source.characters8();
 344         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 345         if (!impl) {
 346             throwOutOfMemoryError(exec, scope);
 347             return nullptr;
 348         }
 349 
 350         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 351         for (int i = 0; i &lt; rangeCount; i++) {
 352             if (int srcLen = substringRanges[i].length) {
 353                 StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 354                 bufferPos += srcLen;
 355             }
 356         }
 357 
 358         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 359     }
 360 
 361     UChar* buffer;
 362     const UChar* sourceData = source.characters16();
 363 
 364     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 365     if (!impl) {
 366         throwOutOfMemoryError(exec, scope);
 367         return nullptr;
 368     }
 369 
 370     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 371     for (int i = 0; i &lt; rangeCount; i++) {
 372         if (int srcLen = substringRanges[i].length) {
 373             StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 374             bufferPos += srcLen;
 375         }
 376     }
 377 
 378     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 379 }
 380 
 381 static ALWAYS_INLINE JSString* jsSpliceSubstringsWithSeparators(ExecState* exec, JSString* sourceVal, const String&amp; source, const StringRange* substringRanges, int rangeCount, const String* separators, int separatorCount)
 382 {
 383     VM&amp; vm = exec-&gt;vm();
 384     auto scope = DECLARE_THROW_SCOPE(vm);
 385 
 386     if (rangeCount == 1 &amp;&amp; separatorCount == 0) {
 387         int sourceSize = source.length();
 388         int position = substringRanges[0].position;
 389         int length = substringRanges[0].length;
 390         if (position &lt;= 0 &amp;&amp; length &gt;= sourceSize)
 391             return sourceVal;
 392         // We could call String::substringSharingImpl(), but this would result in redundant checks.
 393         RELEASE_AND_RETURN(scope, jsString(vm, StringImpl::createSubstringSharingImpl(*source.impl(), std::max(0, position), std::min(sourceSize, length))));
 394     }
 395 
 396     Checked&lt;int, RecordOverflow&gt; totalLength = 0;
 397     bool allSeparators8Bit = true;
 398     for (int i = 0; i &lt; rangeCount; i++)
 399         totalLength += substringRanges[i].length;
 400     for (int i = 0; i &lt; separatorCount; i++) {
 401         totalLength += separators[i].length();
 402         if (separators[i].length() &amp;&amp; !separators[i].is8Bit())
 403             allSeparators8Bit = false;
 404     }
 405     if (totalLength.hasOverflowed()) {
 406         throwOutOfMemoryError(exec, scope);
 407         return nullptr;
 408     }
 409 
 410     if (!totalLength)
 411         return jsEmptyString(vm);
 412 
 413     if (source.is8Bit() &amp;&amp; allSeparators8Bit) {
 414         LChar* buffer;
 415         const LChar* sourceData = source.characters8();
 416 
 417         auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 418         if (!impl) {
 419             throwOutOfMemoryError(exec, scope);
 420             return nullptr;
 421         }
 422 
 423         int maxCount = std::max(rangeCount, separatorCount);
 424         Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 425         for (int i = 0; i &lt; maxCount; i++) {
 426             if (i &lt; rangeCount) {
 427                 if (int srcLen = substringRanges[i].length) {
 428                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), sourceData + substringRanges[i].position, srcLen);
 429                     bufferPos += srcLen;
 430                 }
 431             }
 432             if (i &lt; separatorCount) {
 433                 if (int sepLen = separators[i].length()) {
 434                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 435                     bufferPos += sepLen;
 436                 }
 437             }
 438         }
 439 
 440         RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 441     }
 442 
 443     UChar* buffer;
 444     auto impl = StringImpl::tryCreateUninitialized(totalLength.unsafeGet(), buffer);
 445     if (!impl) {
 446         throwOutOfMemoryError(exec, scope);
 447         return nullptr;
 448     }
 449 
 450     int maxCount = std::max(rangeCount, separatorCount);
 451     Checked&lt;int, AssertNoOverflow&gt; bufferPos = 0;
 452     for (int i = 0; i &lt; maxCount; i++) {
 453         if (i &lt; rangeCount) {
 454             if (int srcLen = substringRanges[i].length) {
 455                 if (source.is8Bit())
 456                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters8() + substringRanges[i].position, srcLen);
 457                 else
 458                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), source.characters16() + substringRanges[i].position, srcLen);
 459                 bufferPos += srcLen;
 460             }
 461         }
 462         if (i &lt; separatorCount) {
 463             if (int sepLen = separators[i].length()) {
 464                 if (separators[i].is8Bit())
 465                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters8(), sepLen);
 466                 else
 467                     StringImpl::copyCharacters(buffer + bufferPos.unsafeGet(), separators[i].characters16(), sepLen);
 468                 bufferPos += sepLen;
 469             }
 470         }
 471     }
 472 
 473     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(impl)));
 474 }
 475 
 476 #define OUT_OF_MEMORY(exec__, scope__) \
 477     do { \
 478         throwOutOfMemoryError(exec__, scope__); \
 479         return nullptr; \
 480     } while (false)
 481 
 482 static ALWAYS_INLINE JSString* removeUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; source, RegExp* regExp)
 483 {
 484     auto scope = DECLARE_THROW_SCOPE(vm);
 485     SuperSamplerScope superSamplerScope(false);
 486 
 487     size_t lastIndex = 0;
 488     unsigned startPosition = 0;
 489 
 490     Vector&lt;StringRange, 16&gt; sourceRanges;
 491     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 492     unsigned sourceLen = source.length();
 493 
 494     while (true) {
 495         MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition);
 496         RETURN_IF_EXCEPTION(scope, nullptr);
 497         if (!result)
 498             break;
 499 
 500         if (lastIndex &lt; result.start) {
 501             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 502                 OUT_OF_MEMORY(exec, scope);
 503         }
 504         lastIndex = result.end;
 505         startPosition = lastIndex;
 506 
 507         // special case of empty match
 508         if (result.empty()) {
 509             startPosition++;
 510             if (startPosition &gt; sourceLen)
 511                 break;
 512         }
 513     }
 514 
 515     if (!lastIndex)
 516         return string;
 517 
 518     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 519         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 520             OUT_OF_MEMORY(exec, scope);
 521     }
 522     RELEASE_AND_RETURN(scope, jsSpliceSubstrings(exec, string, source, sourceRanges.data(), sourceRanges.size()));
 523 }
 524 
 525 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(
 526     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, CallData&amp; callData,
 527     CallType callType, String&amp; replacementString, JSValue replaceValue)
 528 {
 529     auto scope = DECLARE_THROW_SCOPE(vm);
 530 
 531     String source = string-&gt;value(exec);
 532     RETURN_IF_EXCEPTION(scope, nullptr);
 533     unsigned sourceLen = source.length();
 534     RETURN_IF_EXCEPTION(scope, nullptr);
 535     RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(searchValue);
 536     RegExp* regExp = regExpObject-&gt;regExp();
 537     bool global = regExp-&gt;global();
 538     bool hasNamedCaptures = regExp-&gt;hasNamedCaptures();
 539 
 540     if (global) {
 541         // ES5.1 15.5.4.10 step 8.a.
 542         regExpObject-&gt;setLastIndex(exec, 0);
 543         RETURN_IF_EXCEPTION(scope, nullptr);
 544 
 545         if (callType == CallType::None &amp;&amp; !replacementString.length())
 546             RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, string, source, regExp));
 547     }
 548 
 549     // FIXME: This is wrong because we may be called directly from the FTL.
 550     // https://bugs.webkit.org/show_bug.cgi?id=154874
 551     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 552 
 553     size_t lastIndex = 0;
 554     unsigned startPosition = 0;
 555 
 556     Vector&lt;StringRange, 16&gt; sourceRanges;
 557     Vector&lt;String, 16&gt; replacements;
 558 
 559     // This is either a loop (if global is set) or a one-way (if not).
 560     if (global &amp;&amp; callType == CallType::JS) {
 561         // regExp-&gt;numSubpatterns() + 1 for pattern args, + 2 for match start and string
 562         int argCount = regExp-&gt;numSubpatterns() + 1 + 2;
 563         if (hasNamedCaptures)
 564             ++argCount;
 565         JSFunction* func = jsCast&lt;JSFunction*&gt;(replaceValue);
 566         CachedCall cachedCall(exec, func, argCount);
 567         RETURN_IF_EXCEPTION(scope, nullptr);
 568         while (true) {
 569             int* ovector;
 570             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 571             RETURN_IF_EXCEPTION(scope, nullptr);
 572             if (!result)
 573                 break;
 574 
 575             if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 576                 OUT_OF_MEMORY(exec, scope);
 577 
 578             cachedCall.clearArguments();
 579 
 580             JSObject* groups = nullptr;
 581 
 582             if (hasNamedCaptures) {
 583                 JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 584                 groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 585             }
 586 
 587             for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 588                 int matchStart = ovector[i * 2];
 589                 int matchLen = ovector[i * 2 + 1] - matchStart;
 590 
 591                 JSValue patternValue;
 592 
 593                 if (matchStart &lt; 0)
 594                     patternValue = jsUndefined();
 595                 else
 596                     patternValue = jsSubstring(vm, source, matchStart, matchLen);
 597 
 598                 cachedCall.appendArgument(patternValue);
 599 
 600                 if (i &amp;&amp; hasNamedCaptures) {
 601                     String groupName = regExp-&gt;getCaptureGroupName(i);
 602                     if (!groupName.isEmpty())
 603                         groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 604                 }
 605             }
 606 
 607             cachedCall.appendArgument(jsNumber(result.start));
 608             cachedCall.appendArgument(string);
 609             if (hasNamedCaptures)
 610                 cachedCall.appendArgument(groups);
 611 
 612             cachedCall.setThis(jsUndefined());
 613             if (UNLIKELY(cachedCall.hasOverflowedArguments())) {
 614                 throwOutOfMemoryError(exec, scope);
 615                 return nullptr;
 616             }
 617 
 618             JSValue jsResult = cachedCall.call();
 619             RETURN_IF_EXCEPTION(scope, nullptr);
 620             replacements.append(jsResult.toWTFString(exec));
 621             RETURN_IF_EXCEPTION(scope, nullptr);
 622 
 623             lastIndex = result.end;
 624             startPosition = lastIndex;
 625 
 626             // special case of empty match
 627             if (result.empty()) {
 628                 startPosition++;
 629                 if (startPosition &gt; sourceLen)
 630                     break;
 631             }
 632         }
 633     } else {
 634         do {
 635             int* ovector;
 636             MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, source, startPosition, &amp;ovector);
 637             RETURN_IF_EXCEPTION(scope, nullptr);
 638             if (!result)
 639                 break;
 640 
 641             if (callType != CallType::None) {
 642                 if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 643                     OUT_OF_MEMORY(exec, scope);
 644 
 645                 MarkedArgumentBuffer args;
 646                 JSObject* groups = nullptr;
 647 
 648                 if (hasNamedCaptures) {
 649                     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
 650                     groups = JSFinalObject::create(vm, JSFinalObject::createStructure(vm, globalObject, globalObject-&gt;objectPrototype(), 0));
 651                 }
 652 
 653                 for (unsigned i = 0; i &lt; regExp-&gt;numSubpatterns() + 1; ++i) {
 654                     int matchStart = ovector[i * 2];
 655                     int matchLen = ovector[i * 2 + 1] - matchStart;
 656 
 657                     JSValue patternValue;
 658 
 659                     if (matchStart &lt; 0)
 660                         patternValue = jsUndefined();
 661                     else {
 662                         patternValue = jsSubstring(vm, source, matchStart, matchLen);
 663                         RETURN_IF_EXCEPTION(scope, nullptr);
 664                     }
 665 
 666                     args.append(patternValue);
 667 
 668                     if (i &amp;&amp; hasNamedCaptures) {
 669                         String groupName = regExp-&gt;getCaptureGroupName(i);
 670                         if (!groupName.isEmpty())
 671                             groups-&gt;putDirect(vm, Identifier::fromString(vm, groupName), patternValue);
 672                     }
 673 
 674                 }
 675 
 676                 args.append(jsNumber(result.start));
 677                 args.append(string);
 678                 if (hasNamedCaptures)
 679                     args.append(groups);
 680                 if (UNLIKELY(args.hasOverflowed())) {
 681                     throwOutOfMemoryError(exec, scope);
 682                     return nullptr;
 683                 }
 684 
 685                 JSValue replacement = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 686                 RETURN_IF_EXCEPTION(scope, nullptr);
 687                 String replacementString = replacement.toWTFString(exec);
 688                 RETURN_IF_EXCEPTION(scope, nullptr);
 689                 replacements.append(replacementString);
 690                 RETURN_IF_EXCEPTION(scope, nullptr);
 691             } else {
 692                 int replLen = replacementString.length();
 693                 if (lastIndex &lt; result.start || replLen) {
 694                     if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, result.start - lastIndex)))
 695                         OUT_OF_MEMORY(exec, scope);
 696 
 697                     if (replLen) {
 698                         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 699                         substituteBackreferences(replacement, replacementString, source, ovector, regExp);
 700                         if (UNLIKELY(replacement.hasOverflowed()))
 701                             OUT_OF_MEMORY(exec, scope);
 702                         replacements.append(replacement.toString());
 703                     } else
 704                         replacements.append(String());
 705                 }
 706             }
 707 
 708             lastIndex = result.end;
 709             startPosition = lastIndex;
 710 
 711             // special case of empty match
 712             if (result.empty()) {
 713                 startPosition++;
 714                 if (startPosition &gt; sourceLen)
 715                     break;
 716             }
 717         } while (global);
 718     }
 719 
 720     if (!lastIndex &amp;&amp; replacements.isEmpty())
 721         return string;
 722 
 723     if (static_cast&lt;unsigned&gt;(lastIndex) &lt; sourceLen) {
 724         if (UNLIKELY(!sourceRanges.tryConstructAndAppend(lastIndex, sourceLen - lastIndex)))
 725             OUT_OF_MEMORY(exec, scope);
 726     }
 727     RELEASE_AND_RETURN(scope, jsSpliceSubstringsWithSeparators(exec, string, source, sourceRanges.data(), sourceRanges.size(), replacements.data(), replacements.size()));
 728 }
 729 
 730 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpEmptyStr(
 731     ExecState* exec, JSString* thisValue, RegExpObject* searchValue)
 732 {
 733     VM&amp; vm = exec-&gt;vm();
 734     NativeCallFrameTracer tracer(vm, exec);
 735     auto scope = DECLARE_THROW_SCOPE(vm);
 736 
 737     RegExp* regExp = searchValue-&gt;regExp();
 738     if (regExp-&gt;global()) {
 739         // ES5.1 15.5.4.10 step 8.a.
 740         searchValue-&gt;setLastIndex(exec, 0);
 741         RETURN_IF_EXCEPTION(scope, nullptr);
 742         String source = thisValue-&gt;value(exec);
 743         RETURN_IF_EXCEPTION(scope, nullptr);
 744         RELEASE_AND_RETURN(scope, removeUsingRegExpSearch(vm, exec, thisValue, source, regExp));
 745     }
 746 
 747     CallData callData;
 748     String replacementString = emptyString();
 749     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 750         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, JSValue()));
 751 }
 752 
 753 JSCell* JIT_OPERATION operationStringProtoFuncReplaceRegExpString(
 754     ExecState* exec, JSString* thisValue, RegExpObject* searchValue, JSString* replaceString)
 755 {
 756     VM&amp; vm = exec-&gt;vm();
 757     NativeCallFrameTracer tracer(vm, exec);
 758     auto scope = DECLARE_THROW_SCOPE(vm);
 759 
 760     CallData callData;
 761     String replacementString = replaceString-&gt;value(exec);
 762     RETURN_IF_EXCEPTION(scope, nullptr);
 763     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 764         vm, exec, thisValue, searchValue, callData, CallType::None, replacementString, replaceString));
 765 }
 766 
 767 static ALWAYS_INLINE JSString* replaceUsingRegExpSearch(VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 768 {
 769     auto scope = DECLARE_THROW_SCOPE(vm);
 770 
 771     String replacementString;
 772     CallData callData;
 773     CallType callType = getCallData(vm, replaceValue, callData);
 774     if (callType == CallType::None) {
 775         replacementString = replaceValue.toWTFString(exec);
 776         RETURN_IF_EXCEPTION(scope, nullptr);
 777     }
 778 
 779     RELEASE_AND_RETURN(scope, replaceUsingRegExpSearch(
 780         vm, exec, string, searchValue, callData, callType, replacementString, replaceValue));
 781 }
 782 
 783 static ALWAYS_INLINE JSString* replaceUsingStringSearch(VM&amp; vm, ExecState* exec, JSString* jsString, JSValue searchValue, JSValue replaceValue)
 784 {
 785     auto scope = DECLARE_THROW_SCOPE(vm);
 786 
 787     String string = jsString-&gt;value(exec);
 788     RETURN_IF_EXCEPTION(scope, nullptr);
 789     String searchString = searchValue.toWTFString(exec);
 790     RETURN_IF_EXCEPTION(scope, nullptr);
 791 
 792     size_t matchStart = string.find(searchString);
 793 
 794     if (matchStart == notFound)
 795         return jsString;
 796 
 797     CallData callData;
 798     CallType callType = getCallData(vm, replaceValue, callData);
 799     if (callType != CallType::None) {
 800         MarkedArgumentBuffer args;
 801         auto* substring = jsSubstring(vm, string, matchStart, searchString.impl()-&gt;length());
 802         RETURN_IF_EXCEPTION(scope, nullptr);
 803         args.append(substring);
 804         args.append(jsNumber(matchStart));
 805         args.append(jsString);
 806         ASSERT(!args.hasOverflowed());
 807         replaceValue = call(exec, replaceValue, callType, callData, jsUndefined(), args);
 808         RETURN_IF_EXCEPTION(scope, nullptr);
 809     }
 810 
 811     String replaceString = replaceValue.toWTFString(exec);
 812     RETURN_IF_EXCEPTION(scope, nullptr);
 813 
 814     StringImpl* stringImpl = string.impl();
 815     String leftPart(StringImpl::createSubstringSharingImpl(*stringImpl, 0, matchStart));
 816 
 817     size_t matchEnd = matchStart + searchString.impl()-&gt;length();
 818     int ovector[2] = { static_cast&lt;int&gt;(matchStart),  static_cast&lt;int&gt;(matchEnd)};
 819     String middlePart;
 820     if (callType != CallType::None)
 821         middlePart = replaceString;
 822     else {
 823         StringBuilder replacement(StringBuilder::OverflowHandler::RecordOverflow);
 824         substituteBackreferences(replacement, replaceString, string, ovector, 0);
 825         if (UNLIKELY(replacement.hasOverflowed()))
 826             OUT_OF_MEMORY(exec, scope);
 827         middlePart = replacement.toString();
 828     }
 829 
 830     size_t leftLength = stringImpl-&gt;length() - matchEnd;
 831     String rightPart(StringImpl::createSubstringSharingImpl(*stringImpl, matchEnd, leftLength));
 832     RELEASE_AND_RETURN(scope, JSC::jsString(exec, leftPart, middlePart, rightPart));
 833 }
 834 
 835 static inline bool checkObjectCoercible(JSValue thisValue)
 836 {
 837     if (thisValue.isString())
 838         return true;
 839 
 840     if (thisValue.isUndefinedOrNull())
 841         return false;
 842 
 843     if (thisValue.isObject() &amp;&amp; asObject(thisValue)-&gt;isEnvironment())
 844         return false;
 845 
 846     return true;
 847 }
 848 
 849 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeatCharacter(ExecState* exec)
 850 {
 851     VM&amp; vm = exec-&gt;vm();
 852     auto scope = DECLARE_THROW_SCOPE(vm);
 853 
 854     // For a string which length is single, instead of creating ropes,
 855     // allocating a sequential buffer and fill with the repeated string for efficiency.
 856     ASSERT(exec-&gt;argumentCount() == 2);
 857 
 858     ASSERT(exec-&gt;uncheckedArgument(0).isString());
 859     JSString* string = asString(exec-&gt;uncheckedArgument(0));
 860     ASSERT(string-&gt;length() == 1);
 861 
 862     JSValue repeatCountValue = exec-&gt;uncheckedArgument(1);
 863     RELEASE_ASSERT(repeatCountValue.isNumber());
 864     int32_t repeatCount;
 865     double value = repeatCountValue.asNumber();
 866     if (value &gt; JSString::MaxLength)
 867         return JSValue::encode(throwOutOfMemoryError(exec, scope));
 868     repeatCount = static_cast&lt;int32_t&gt;(value);
 869     ASSERT(repeatCount &gt;= 0);
 870     ASSERT(!repeatCountValue.isDouble() || repeatCountValue.asDouble() == repeatCount);
 871 
 872     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
 873     StringView view = viewWithString.view;
 874     ASSERT(view.length() == 1);
 875     scope.assertNoException();
 876     UChar character = view[0];
 877     scope.release();
 878     if (isLatin1(character))
 879         return JSValue::encode(repeatCharacter(*exec, static_cast&lt;LChar&gt;(character), repeatCount));
 880     return JSValue::encode(repeatCharacter(*exec, character, repeatCount));
 881 }
 882 
 883 ALWAYS_INLINE JSString* replace(
 884     VM&amp; vm, ExecState* exec, JSString* string, JSValue searchValue, JSValue replaceValue)
 885 {
 886     if (searchValue.inherits&lt;RegExpObject&gt;(vm))
 887         return replaceUsingRegExpSearch(vm, exec, string, searchValue, replaceValue);
 888     return replaceUsingStringSearch(vm, exec, string, searchValue, replaceValue);
 889 }
 890 
 891 ALWAYS_INLINE JSString* replace(
 892     VM&amp; vm, ExecState* exec, JSValue thisValue, JSValue searchValue, JSValue replaceValue)
 893 {
 894     auto scope = DECLARE_THROW_SCOPE(vm);
 895 
 896     if (!checkObjectCoercible(thisValue)) {
 897         throwVMTypeError(exec, scope);
 898         return nullptr;
 899     }
 900     JSString* string = thisValue.toString(exec);
 901     RETURN_IF_EXCEPTION(scope, nullptr);
 902     RELEASE_AND_RETURN(scope, replace(vm, exec, string, searchValue, replaceValue));
 903 }
 904 
 905 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingRegExp(ExecState* exec)
 906 {
 907     VM&amp; vm = exec-&gt;vm();
 908     auto scope = DECLARE_THROW_SCOPE(vm);
 909 
 910     JSString* string = exec-&gt;thisValue().toString(exec);
 911     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 912 
 913     JSValue searchValue = exec-&gt;argument(0);
 914     if (!searchValue.inherits&lt;RegExpObject&gt;(vm))
 915         return JSValue::encode(jsUndefined());
 916 
 917     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingRegExpSearch(vm, exec, string, searchValue, exec-&gt;argument(1))));
 918 }
 919 
 920 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplaceUsingStringSearch(ExecState* exec)
 921 {
 922     VM&amp; vm = exec-&gt;vm();
 923     auto scope = DECLARE_THROW_SCOPE(vm);
 924 
 925     JSString* string = exec-&gt;thisValue().toString(exec);
 926     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 927 
 928     RELEASE_AND_RETURN(scope, JSValue::encode(replaceUsingStringSearch(vm, exec, string, exec-&gt;argument(0), exec-&gt;argument(1))));
 929 }
 930 
 931 JSCell* JIT_OPERATION operationStringProtoFuncReplaceGeneric(
 932     ExecState* exec, EncodedJSValue thisValue, EncodedJSValue searchValue,
 933     EncodedJSValue replaceValue)
 934 {
 935     VM&amp; vm = exec-&gt;vm();
 936     NativeCallFrameTracer tracer(vm, exec);
 937 
 938     return replace(
 939         vm, exec, JSValue::decode(thisValue), JSValue::decode(searchValue),
 940         JSValue::decode(replaceValue));
 941 }
 942 
 943 EncodedJSValue JSC_HOST_CALL stringProtoFuncToString(ExecState* exec)
 944 {
 945     VM&amp; vm = exec-&gt;vm();
 946     auto scope = DECLARE_THROW_SCOPE(vm);
 947 
 948     JSValue thisValue = exec-&gt;thisValue();
 949     // Also used for valueOf.
 950 
 951     if (thisValue.isString())
 952         return JSValue::encode(thisValue);
 953 
 954     auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, thisValue);
 955     if (stringObject)
 956         return JSValue::encode(stringObject-&gt;internalValue());
 957 
 958     return throwVMTypeError(exec, scope);
 959 }
 960 
 961 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharAt(ExecState* exec)
 962 {
 963     VM&amp; vm = exec-&gt;vm();
 964     auto scope = DECLARE_THROW_SCOPE(vm);
 965 
 966     JSValue thisValue = exec-&gt;thisValue();
 967     if (!checkObjectCoercible(thisValue))
 968         return throwVMTypeError(exec, scope);
 969     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 970     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 971     StringView view = viewWithString.view;
 972     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 973     JSValue a0 = exec-&gt;argument(0);
 974     if (a0.isUInt32()) {
 975         uint32_t i = a0.asUInt32();
 976         if (i &lt; view.length())
 977             return JSValue::encode(jsSingleCharacterString(vm, view[i]));
 978         return JSValue::encode(jsEmptyString(vm));
 979     }
 980     double dpos = a0.toInteger(exec);
 981     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 982     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
 983         return JSValue::encode(jsSingleCharacterString(vm, view[static_cast&lt;unsigned&gt;(dpos)]));
 984     return JSValue::encode(jsEmptyString(vm));
 985 }
 986 
 987 EncodedJSValue JSC_HOST_CALL stringProtoFuncCharCodeAt(ExecState* exec)
 988 {
 989     VM&amp; vm = exec-&gt;vm();
 990     auto scope = DECLARE_THROW_SCOPE(vm);
 991 
 992     JSValue thisValue = exec-&gt;thisValue();
 993     if (!checkObjectCoercible(thisValue))
 994         return throwVMTypeError(exec, scope);
 995     auto viewWithString = thisValue.toString(exec)-&gt;viewWithUnderlyingString(exec);
 996     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 997     StringView view = viewWithString.view;
 998     JSValue a0 = exec-&gt;argument(0);
 999     if (a0.isUInt32()) {
1000         uint32_t i = a0.asUInt32();
1001         if (i &lt; view.length())
1002             return JSValue::encode(jsNumber(view[i]));
1003         return JSValue::encode(jsNaN());
1004     }
1005     double dpos = a0.toInteger(exec);
1006     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1007     if (dpos &gt;= 0 &amp;&amp; dpos &lt; view.length())
1008         return JSValue::encode(jsNumber(view[static_cast&lt;int&gt;(dpos)]));
1009     return JSValue::encode(jsNaN());
1010 }
1011 
1012 static inline UChar32 codePointAt(const String&amp; string, unsigned position, unsigned length)
1013 {
1014     RELEASE_ASSERT(position &lt; length);
1015     if (string.is8Bit())
1016         return string.characters8()[position];
1017     UChar32 character;
1018     U16_NEXT(string.characters16(), position, length, character);
1019     return character;
1020 }
1021 
1022 EncodedJSValue JSC_HOST_CALL stringProtoFuncCodePointAt(ExecState* exec)
1023 {
1024     VM&amp; vm = exec-&gt;vm();
1025     auto scope = DECLARE_THROW_SCOPE(vm);
1026 
1027     JSValue thisValue = exec-&gt;thisValue();
1028     if (!checkObjectCoercible(thisValue))
1029         return throwVMTypeError(exec, scope);
1030 
1031     String string = thisValue.toWTFString(exec);
1032     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1033     unsigned length = string.length();
1034 
1035     JSValue argument0 = exec-&gt;argument(0);
1036     if (argument0.isUInt32()) {
1037         unsigned position = argument0.asUInt32();
1038         if (position &lt; length)
1039             return JSValue::encode(jsNumber(codePointAt(string, position, length)));
1040         return JSValue::encode(jsUndefined());
1041     }
1042 
1043     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1044 
1045     double doublePosition = argument0.toInteger(exec);
1046     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1047     if (doublePosition &gt;= 0 &amp;&amp; doublePosition &lt; length)
1048         return JSValue::encode(jsNumber(codePointAt(string, static_cast&lt;unsigned&gt;(doublePosition), length)));
1049     return JSValue::encode(jsUndefined());
1050 }
1051 
1052 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState* exec)
1053 {
1054     VM&amp; vm = exec-&gt;vm();
1055     auto scope = DECLARE_THROW_SCOPE(vm);
1056 
1057     JSValue thisValue = exec-&gt;thisValue();
1058     if (!checkObjectCoercible(thisValue))
1059         return throwVMTypeError(exec, scope);
1060 
1061     JSValue a0 = exec-&gt;argument(0);
1062     JSValue a1 = exec-&gt;argument(1);
1063 
1064     JSString* thisJSString = thisValue.toString(exec);
1065     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1066     JSString* otherJSString = a0.toString(exec);
1067     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1068 
1069     unsigned pos = 0;
1070     if (!a1.isUndefined()) {
1071         int len = thisJSString-&gt;length();
1072         RELEASE_ASSERT(len &gt;= 0);
1073         if (a1.isUInt32())
1074             pos = std::min&lt;uint32_t&gt;(a1.asUInt32(), len);
1075         else {
1076             double dpos = a1.toInteger(exec);
1077             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1078             if (dpos &lt; 0)
1079                 dpos = 0;
1080             else if (dpos &gt; len)
1081                 dpos = len;
1082             pos = static_cast&lt;unsigned&gt;(dpos);
1083         }
1084     }
1085 
1086     if (thisJSString-&gt;length() &lt; otherJSString-&gt;length() + pos)
1087         return JSValue::encode(jsNumber(-1));
1088 
1089     auto thisViewWithString = thisJSString-&gt;viewWithUnderlyingString(exec);
1090     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1091     auto otherViewWithString = otherJSString-&gt;viewWithUnderlyingString(exec);
1092     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1093     size_t result = thisViewWithString.view.find(otherViewWithString.view, pos);
1094     if (result == notFound)
1095         return JSValue::encode(jsNumber(-1));
1096     return JSValue::encode(jsNumber(result));
1097 }
1098 
1099 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState* exec)
1100 {
1101     VM&amp; vm = exec-&gt;vm();
1102     auto scope = DECLARE_THROW_SCOPE(vm);
1103 
1104     JSValue thisValue = exec-&gt;thisValue();
1105     if (!checkObjectCoercible(thisValue))
1106         return throwVMTypeError(exec, scope);
1107 
1108     JSValue a0 = exec-&gt;argument(0);
1109     JSValue a1 = exec-&gt;argument(1);
1110 
1111     JSString* thisJSString = thisValue.toString(exec);
1112     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1113     unsigned len = thisJSString-&gt;length();
1114     JSString* otherJSString = a0.toString(exec);
1115     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1116 
1117     double dpos = a1.toIntegerPreserveNaN(exec);
1118     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1119     unsigned startPosition;
1120     if (dpos &lt; 0)
1121         startPosition = 0;
1122     else if (!(dpos &lt;= len)) // true for NaN
1123         startPosition = len;
1124     else
1125         startPosition = static_cast&lt;unsigned&gt;(dpos);
1126 
1127     if (len &lt; otherJSString-&gt;length())
1128         return JSValue::encode(jsNumber(-1));
1129 
1130     String thisString = thisJSString-&gt;value(exec);
1131     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1132     String otherString = otherJSString-&gt;value(exec);
1133     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1134     size_t result;
1135     if (!startPosition)
1136         result = thisString.startsWith(otherString) ? 0 : notFound;
1137     else
1138         result = thisString.reverseFind(otherString, startPosition);
1139     if (result == notFound)
1140         return JSValue::encode(jsNumber(-1));
1141     return JSValue::encode(jsNumber(result));
1142 }
1143 
1144 EncodedJSValue JSC_HOST_CALL stringProtoFuncSlice(ExecState* exec)
1145 {
1146     VM&amp; vm = exec-&gt;vm();
1147     auto scope = DECLARE_THROW_SCOPE(vm);
1148 
1149     JSValue thisValue = exec-&gt;thisValue();
1150     if (!checkObjectCoercible(thisValue))
1151         return throwVMTypeError(exec, scope);
1152     JSString* string = thisValue.toString(exec);
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
1155     JSValue a0 = exec-&gt;argument(0);
1156     JSValue a1 = exec-&gt;argument(1);
1157 
1158     int length = string-&gt;length();
1159     RELEASE_ASSERT(length &gt;= 0);
1160 
1161     // The arg processing is very much like ArrayProtoFunc::Slice
1162     double start = a0.toInteger(exec);
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1164     double end = a1.isUndefined() ? length : a1.toInteger(exec);
1165     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1166     RELEASE_AND_RETURN(scope, JSValue::encode(stringSlice(exec, vm, string, length, start, end)));
1167 }
1168 
1169 // Return true in case of early return (resultLength got to limitLength).
1170 template&lt;typename CharacterType&gt;
1171 static ALWAYS_INLINE bool splitStringByOneCharacterImpl(ExecState* exec, JSArray* result, JSValue originalValue, const String&amp; input, StringImpl* string, UChar separatorCharacter, size_t&amp; position, unsigned&amp; resultLength, unsigned limitLength)
1172 {
1173     VM&amp; vm = exec-&gt;vm();
1174     auto scope = DECLARE_THROW_SCOPE(vm);
1175 
1176     // 12. Let q = p.
1177     size_t matchPosition;
1178     const CharacterType* characters = string-&gt;characters&lt;CharacterType&gt;();
1179     // 13. Repeat, while q != s
1180     //   a. Call SplitMatch(S, q, R) and let z be its MatchResult result.
1181     //   b. If z is failure, then let q = q+1.
1182     //   c. Else, z is not failure
1183     while ((matchPosition = WTF::find(characters, string-&gt;length(), separatorCharacter, position)) != notFound) {
1184         // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1185         //    through q (exclusive).
1186         // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
1187         //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
1188         auto* substring = jsSubstring(exec, originalValue, input, position, matchPosition - position);
1189         RETURN_IF_EXCEPTION(scope, false);
1190         result-&gt;putDirectIndex(exec, resultLength, substring);
1191         RETURN_IF_EXCEPTION(scope, false);
1192         // 3. Increment lengthA by 1.
1193         // 4. If lengthA == lim, return A.
1194         if (++resultLength == limitLength)
1195             return true;
1196 
1197         // 5. Let p = e.
1198         // 8. Let q = p.
1199         position = matchPosition + 1;
1200     }
1201     return false;
1202 }
1203 
1204 // ES 21.1.3.17 String.prototype.split(separator, limit)
1205 EncodedJSValue JSC_HOST_CALL stringProtoFuncSplitFast(ExecState* exec)
1206 {
1207     VM&amp; vm = exec-&gt;vm();
1208     auto scope = DECLARE_THROW_SCOPE(vm);
1209     JSValue thisValue = exec-&gt;thisValue();
1210     ASSERT(checkObjectCoercible(thisValue));
1211 
1212     // 3. Let S be the result of calling ToString, giving it the this value as its argument.
1213     // 7. Let s be the number of characters in S.
1214     String input = thisValue.toWTFString(exec);
1215     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1216     ASSERT(!input.isNull());
1217 
1218     // 4. Let A be a new array created as if by the expression new Array()
1219     //    where Array is the standard built-in constructor with that name.
1220     JSArray* result = constructEmptyArray(exec, 0);
1221     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1222 
1223     // 5. Let lengthA be 0.
1224     unsigned resultLength = 0;
1225 
1226     // 6. If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit).
1227     JSValue limitValue = exec-&gt;uncheckedArgument(1);
1228     unsigned limit = limitValue.isUndefined() ? 0xFFFFFFFFu : limitValue.toUInt32(exec);
1229     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1230 
1231     // 8. Let p = 0.
1232     size_t position = 0;
1233 
1234     // 9. If separator is a RegExp object (its [[Class]] is &quot;RegExp&quot;), let R = separator;
1235     //    otherwise let R = ToString(separator).
1236     JSValue separatorValue = exec-&gt;uncheckedArgument(0);
1237     String separator = separatorValue.toWTFString(exec);
1238     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1239 
1240     // 10. If lim == 0, return A.
1241     if (!limit)
1242         return JSValue::encode(result);
1243 
1244     // 11. If separator is undefined, then
1245     if (separatorValue.isUndefined()) {
1246         // a. Call the [[DefineOwnProperty]] internal method of A with arguments &quot;0&quot;,
1247         scope.release();
1248         result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1249         // b. Return A.
1250         return JSValue::encode(result);
1251     }
1252 
1253     // 12. If s == 0, then
1254     if (input.isEmpty()) {
1255         // a. Let z be SplitMatch(S, 0, R) where S is input, R is separator.
1256         // b. If z is not false, return A.
1257         // c. Call CreateDataProperty(A, &quot;0&quot;, S).
1258         // d. Return A.
1259         if (!separator.isEmpty()) {
1260             scope.release();
1261             result-&gt;putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
1262         }
1263         return JSValue::encode(result);
1264     }
1265 
1266     // Optimized case for splitting on the empty string.
1267     if (separator.isEmpty()) {
1268         limit = std::min(limit, input.length());
1269         // Zero limt/input length handled in steps 9/11 respectively, above.
1270         ASSERT(limit);
1271 
1272         do {
1273             result-&gt;putDirectIndex(exec, position, jsSingleCharacterString(vm, input[position]));
1274             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1275         } while (++position &lt; limit);
1276 
1277         return JSValue::encode(result);
1278     }
1279 
1280     // 3 cases:
1281     // -separator length == 1, 8 bits
1282     // -separator length == 1, 16 bits
1283     // -separator length &gt; 1
1284     StringImpl* stringImpl = input.impl();
1285     StringImpl* separatorImpl = separator.impl();
1286     size_t separatorLength = separatorImpl-&gt;length();
1287 
1288     if (separatorLength == 1) {
1289         UChar separatorCharacter;
1290         if (separatorImpl-&gt;is8Bit())
1291             separatorCharacter = separatorImpl-&gt;characters8()[0];
1292         else
1293             separatorCharacter = separatorImpl-&gt;characters16()[0];
1294 
1295         if (stringImpl-&gt;is8Bit()) {
1296             if (splitStringByOneCharacterImpl&lt;LChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1297                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1298         } else {
1299             if (splitStringByOneCharacterImpl&lt;UChar&gt;(exec, result, thisValue, input, stringImpl, separatorCharacter, position, resultLength, limit))
1300                 RELEASE_AND_RETURN(scope, JSValue::encode(result));
1301         }
1302         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1303     } else {
1304         // 13. Let q = p.
1305         size_t matchPosition;
1306         // 14. Repeat, while q != s
1307         //   a. let e be SplitMatch(S, q, R).
1308         //   b. If e is failure, then let q = q+1.
1309         //   c. Else, e is an integer index &lt;= s.
1310         while ((matchPosition = stringImpl-&gt;find(separatorImpl, position)) != notFound) {
1311             // 1. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1312             //    through q (exclusive).
1313             // 2. Call CreateDataProperty(A, ToString(lengthA), T).
1314             auto* substring = jsSubstring(exec, thisValue, input, position, matchPosition - position);
1315             RETURN_IF_EXCEPTION(scope, { });
1316             result-&gt;putDirectIndex(exec, resultLength, substring);
1317             RETURN_IF_EXCEPTION(scope, { });
1318             // 3. Increment lengthA by 1.
1319             // 4. If lengthA == lim, return A.
1320             if (++resultLength == limit)
1321                 return JSValue::encode(result);
1322 
1323             // 5. Let p = e.
1324             // 6. Let q = p.
1325             position = matchPosition + separator.length();
1326         }
1327     }
1328 
1329     // 15. Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive)
1330     //     through s (exclusive).
1331     // 16. Call CreateDataProperty(A, ToString(lengthA), T).
1332     auto* substring = jsSubstring(exec, thisValue, input, position, input.length() - position);
1333     RETURN_IF_EXCEPTION(scope, { });
1334     scope.release();
1335     result-&gt;putDirectIndex(exec, resultLength++, substring);
1336 
1337     // 17. Return A.
1338     return JSValue::encode(result);
1339 }
1340 
1341 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstr(ExecState* exec)
1342 {
1343     VM&amp; vm = exec-&gt;vm();
1344     auto scope = DECLARE_THROW_SCOPE(vm);
1345 
1346     JSValue thisValue = exec-&gt;thisValue();
1347     if (!checkObjectCoercible(thisValue))
1348         return throwVMTypeError(exec, scope);
1349     unsigned len;
1350     JSString* jsString = 0;
1351     String uString;
1352     if (thisValue.isString()) {
1353         jsString = asString(thisValue);
1354         len = jsString-&gt;length();
1355     } else {
1356         uString = thisValue.toWTFString(exec);
1357         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1358         len = uString.length();
1359     }
1360 
1361     JSValue a0 = exec-&gt;argument(0);
1362     JSValue a1 = exec-&gt;argument(1);
1363 
1364     double start = a0.toInteger(exec);
1365     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1366     double length = a1.isUndefined() ? len : a1.toInteger(exec);
1367     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1368     if (start &gt;= len || length &lt;= 0)
1369         return JSValue::encode(jsEmptyString(vm));
1370     if (start &lt; 0) {
1371         start += len;
1372         if (start &lt; 0)
1373             start = 0;
1374     }
1375     if (start + length &gt; len)
1376         length = len - start;
1377     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1378     unsigned substringLength = static_cast&lt;unsigned&gt;(length);
1379     scope.release();
1380     if (jsString)
1381         return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
1382     return JSValue::encode(jsSubstring(vm, uString, substringStart, substringLength));
1383 }
1384 
1385 EncodedJSValue JSC_HOST_CALL builtinStringSubstrInternal(ExecState* exec)
1386 {
1387     // @substrInternal should not have any observable side effects (e.g. it should not call
1388     // GetMethod(..., @@toPrimitive) on the thisValue).
1389 
1390     // It is ok to use the default stringProtoFuncSubstr as the implementation of
1391     // @substrInternal because @substrInternal will only be called by builtins, which will
1392     // guarantee that we only pass it a string thisValue. As a result, stringProtoFuncSubstr
1393     // will not need to call toString() on the thisValue, and there will be no observable
1394     // side-effects.
1395     ASSERT(exec-&gt;thisValue().isString());
1396     return stringProtoFuncSubstr(exec);
1397 }
1398 
1399 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
1400 {
1401     VM&amp; vm = exec-&gt;vm();
1402     auto scope = DECLARE_THROW_SCOPE(vm);
1403 
1404     JSValue thisValue = exec-&gt;thisValue();
1405     if (!checkObjectCoercible(thisValue))
1406         return throwVMTypeError(exec, scope);
1407 
1408     JSString* jsString = thisValue.toString(exec);
1409     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1410 
1411     JSValue a0 = exec-&gt;argument(0);
1412     JSValue a1 = exec-&gt;argument(1);
1413     int len = jsString-&gt;length();
1414     RELEASE_ASSERT(len &gt;= 0);
1415 
1416     double start = a0.toNumber(exec);
1417     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1418     double end;
1419     if (!(start &gt;= 0)) // check for negative values or NaN
1420         start = 0;
1421     else if (start &gt; len)
1422         start = len;
1423     if (a1.isUndefined())
1424         end = len;
1425     else {
1426         end = a1.toNumber(exec);
1427         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1428         if (!(end &gt;= 0)) // check for negative values or NaN
1429             end = 0;
1430         else if (end &gt; len)
1431             end = len;
1432     }
1433     if (start &gt; end) {
1434         double temp = end;
1435         end = start;
1436         start = temp;
1437     }
1438     unsigned substringStart = static_cast&lt;unsigned&gt;(start);
1439     unsigned substringLength = static_cast&lt;unsigned&gt;(end) - substringStart;
1440     RELEASE_AND_RETURN(scope, JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength)));
1441 }
1442 
1443 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
1444 {
1445     VM&amp; vm = exec-&gt;vm();
1446     auto scope = DECLARE_THROW_SCOPE(vm);
1447 
1448     JSValue thisValue = exec-&gt;thisValue();
1449     if (!checkObjectCoercible(thisValue))
1450         return throwVMTypeError(exec, scope);
1451     JSString* sVal = thisValue.toString(exec);
1452     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1453     String s = sVal-&gt;value(exec);
1454     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1455     String lowercasedString = s.convertToLowercaseWithoutLocale();
1456     if (lowercasedString.impl() == s.impl())
1457         return JSValue::encode(sVal);
1458     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lowercasedString)));
1459 }
1460 
1461 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
1462 {
1463     VM&amp; vm = exec-&gt;vm();
1464     auto scope = DECLARE_THROW_SCOPE(vm);
1465 
1466     JSValue thisValue = exec-&gt;thisValue();
1467     if (!checkObjectCoercible(thisValue))
1468         return throwVMTypeError(exec, scope);
1469     JSString* sVal = thisValue.toString(exec);
1470     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1471     String s = sVal-&gt;value(exec);
1472     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1473     String uppercasedString = s.convertToUppercaseWithoutLocale();
1474     if (uppercasedString.impl() == s.impl())
1475         return JSValue::encode(sVal);
1476     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, uppercasedString)));
1477 }
1478 
1479 EncodedJSValue JSC_HOST_CALL stringProtoFuncLocaleCompare(ExecState* exec)
1480 {
1481     // 13.1.1 String.prototype.localeCompare (that [, locales [, options ]]) (ECMA-402 2.0)
1482     // http://ecma-international.org/publications/standards/Ecma-402.htm
1483 
1484     VM&amp; vm = exec-&gt;vm();
1485     auto scope = DECLARE_THROW_SCOPE(vm);
1486 
1487     // 1. Let O be RequireObjectCoercible(this value).
1488     JSValue thisValue = exec-&gt;thisValue();
1489     if (!checkObjectCoercible(thisValue))
1490         return throwVMTypeError(exec, scope, &quot;String.prototype.localeCompare requires that |this| not be null or undefined&quot;_s);
1491 
1492     // 2. Let S be ToString(O).
1493     // 3. ReturnIfAbrupt(S).
1494     String string = thisValue.toWTFString(exec);
1495     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1496 
1497     // 4. Let That be ToString(that).
1498     // 5. ReturnIfAbrupt(That).
1499     JSValue thatValue = exec-&gt;argument(0);
1500     String that = thatValue.toWTFString(exec);
1501     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1502 
1503 #if ENABLE(INTL)
1504     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1505     JSValue locales = exec-&gt;argument(1);
1506     JSValue options = exec-&gt;argument(2);
1507     IntlCollator* collator = nullptr;
1508     if (locales.isUndefined() &amp;&amp; options.isUndefined()) {
1509         collator = globalObject-&gt;defaultCollator(exec);
1510         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1511     } else {
1512         collator = IntlCollator::create(vm, globalObject-&gt;collatorStructure());
1513         collator-&gt;initializeCollator(*exec, locales, options);
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
1516     RELEASE_AND_RETURN(scope, JSValue::encode(collator-&gt;compareStrings(*exec, string, that)));
1517 #else
1518     return JSValue::encode(jsNumber(Collator().collate(string, that)));
1519 #endif
1520 }
1521 
1522 #if ENABLE(INTL)
1523 static EncodedJSValue toLocaleCase(ExecState* state, int32_t (*convertCase)(UChar*, int32_t, const UChar*, int32_t, const char*, UErrorCode*))
1524 {
1525     VM&amp; vm = state-&gt;vm();
1526     auto scope = DECLARE_THROW_SCOPE(vm);
1527 
1528     // 1. Let O be RequireObjectCoercible(this value).
1529     JSValue thisValue = state-&gt;thisValue();
1530     if (!checkObjectCoercible(thisValue))
1531         return throwVMTypeError(state, scope);
1532 
1533     // 2. Let S be ToString(O).
1534     JSString* sVal = thisValue.toString(state);
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1536     const String&amp; s = sVal-&gt;value(state);
1537 
1538     // 3. ReturnIfAbrupt(S).
1539     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1540 
1541     // Optimization for empty strings.
1542     if (s.isEmpty())
1543         return JSValue::encode(sVal);
1544 
1545     // 4. Let requestedLocales be CanonicalizeLocaleList(locales).
1546     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(*state, state-&gt;argument(0));
1547 
1548     // 5. ReturnIfAbrupt(requestedLocales).
1549     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1550 
1551     // 6. Let len be the number of elements in requestedLocales.
1552     size_t len = requestedLocales.size();
1553 
1554     // 7. If len &gt; 0, then
1555     // a. Let requestedLocale be the first element of requestedLocales.
1556     // 8. Else
1557     // a. Let requestedLocale be DefaultLocale().
1558     String requestedLocale = len &gt; 0 ? requestedLocales.first() : defaultLocale(*state);
1559 
1560     // 9. Let noExtensionsLocale be the String value that is requestedLocale with all Unicode locale extension sequences (6.2.1) removed.
1561     String noExtensionsLocale = removeUnicodeLocaleExtension(requestedLocale);
1562 
1563     // 10. Let availableLocales be a List with the language tags of the languages for which the Unicode character database contains language sensitive case mappings.
1564     // Note 1: As of Unicode 5.1, the availableLocales list contains the elements &quot;az&quot;, &quot;lt&quot;, and &quot;tr&quot;.
1565     const HashSet&lt;String&gt; availableLocales({ &quot;az&quot;_s, &quot;lt&quot;_s, &quot;tr&quot;_s });
1566 
1567     // 11. Let locale be BestAvailableLocale(availableLocales, noExtensionsLocale).
1568     String locale = bestAvailableLocale(availableLocales, noExtensionsLocale);
1569 
1570     // 12. If locale is undefined, let locale be &quot;und&quot;.
1571     if (locale.isNull())
1572         locale = &quot;und&quot;_s;
1573 
1574     CString utf8LocaleBuffer = locale.utf8();
1575     const StringView view(s);
1576     const int32_t viewLength = view.length();
1577 
1578     // Delegate the following steps to icu u_strToLower or u_strToUpper.
1579     // 13. Let cpList be a List containing in order the code points of S as defined in ES2015, 6.1.4, starting at the first element of S.
1580     // 14. For each code point c in cpList, if the Unicode Character Database provides a lower(/upper) case equivalent of c that is either language insensitive or for the language locale, then replace c in cpList with that/those equivalent code point(s).
1581     // 15. Let cuList be a new List.
1582     // 16. For each code point c in cpList, in order, append to cuList the elements of the UTF-16 Encoding (defined in ES2015, 6.1.4) of c.
1583     // 17. Let L be a String whose elements are, in order, the elements of cuList.
1584 
1585     // Most strings lower/upper case will be the same size as original, so try that first.
1586     UErrorCode error(U_ZERO_ERROR);
1587     Vector&lt;UChar&gt; buffer(viewLength);
1588     String lower;
1589     const int32_t resultLength = convertCase(buffer.data(), viewLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1590     if (U_SUCCESS(error))
1591         lower = String(buffer.data(), resultLength);
1592     else if (error == U_BUFFER_OVERFLOW_ERROR) {
1593         // Converted case needs more space than original. Try again.
1594         UErrorCode error(U_ZERO_ERROR);
1595         Vector&lt;UChar&gt; buffer(resultLength);
1596         convertCase(buffer.data(), resultLength, view.upconvertedCharacters(), viewLength, utf8LocaleBuffer.data(), &amp;error);
1597         if (U_FAILURE(error))
1598             return throwVMTypeError(state, scope, u_errorName(error));
1599         lower = String(buffer.data(), resultLength);
1600     } else
1601         return throwVMTypeError(state, scope, u_errorName(error));
1602 
1603     // 18. Return L.
1604     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, lower)));
1605 }
1606 
1607 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleLowerCase(ExecState* state)
1608 {
1609     // 13.1.2 String.prototype.toLocaleLowerCase ([locales])
1610     // http://ecma-international.org/publications/standards/Ecma-402.htm
1611     return toLocaleCase(state, u_strToLower);
1612 }
1613 
1614 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLocaleUpperCase(ExecState* state)
1615 {
1616     // 13.1.3 String.prototype.toLocaleUpperCase ([locales])
1617     // http://ecma-international.org/publications/standards/Ecma-402.htm
1618     // This function interprets a string value as a sequence of code points, as described in ES2015, 6.1.4. This function behaves in exactly the same way as String.prototype.toLocaleLowerCase, except that characters are mapped to their uppercase equivalents as specified in the Unicode character database.
1619     return toLocaleCase(state, u_strToUpper);
1620 }
1621 #endif // ENABLE(INTL)
1622 
1623 enum {
1624     TrimStart = 1,
1625     TrimEnd = 2
1626 };
1627 
1628 static inline JSValue trimString(ExecState* exec, JSValue thisValue, int trimKind)
1629 {
1630     VM&amp; vm = exec-&gt;vm();
1631     auto scope = DECLARE_THROW_SCOPE(vm);
1632 
1633     if (!checkObjectCoercible(thisValue))
1634         return throwTypeError(exec, scope);
1635     String str = thisValue.toWTFString(exec);
1636     RETURN_IF_EXCEPTION(scope, { });
1637 
1638     unsigned left = 0;
1639     if (trimKind &amp; TrimStart) {
1640         while (left &lt; str.length() &amp;&amp; isStrWhiteSpace(str[left]))
1641             left++;
1642     }
1643     unsigned right = str.length();
1644     if (trimKind &amp; TrimEnd) {
1645         while (right &gt; left &amp;&amp; isStrWhiteSpace(str[right - 1]))
1646             right--;
1647     }
1648 
1649     // Don&#39;t gc allocate a new string if we don&#39;t have to.
1650     if (left == 0 &amp;&amp; right == str.length() &amp;&amp; thisValue.isString())
1651         return thisValue;
1652 
1653     RELEASE_AND_RETURN(scope, jsString(vm, str.substringSharingImpl(left, right - left)));
1654 }
1655 
1656 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
1657 {
1658     JSValue thisValue = exec-&gt;thisValue();
1659     return JSValue::encode(trimString(exec, thisValue, TrimStart | TrimEnd));
1660 }
1661 
1662 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimStart(ExecState* exec)
1663 {
1664     JSValue thisValue = exec-&gt;thisValue();
1665     return JSValue::encode(trimString(exec, thisValue, TrimStart));
1666 }
1667 
1668 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimEnd(ExecState* exec)
1669 {
1670     JSValue thisValue = exec-&gt;thisValue();
1671     return JSValue::encode(trimString(exec, thisValue, TrimEnd));
1672 }
1673 
1674 static inline unsigned clampAndTruncateToUnsigned(double value, unsigned min, unsigned max)
1675 {
1676     if (value &lt; min)
1677         return min;
1678     if (value &gt; max)
1679         return max;
1680     return static_cast&lt;unsigned&gt;(value);
1681 }
1682 
1683 EncodedJSValue JSC_HOST_CALL stringProtoFuncStartsWith(ExecState* exec)
1684 {
1685     VM&amp; vm = exec-&gt;vm();
1686     auto scope = DECLARE_THROW_SCOPE(vm);
1687 
1688     JSValue thisValue = exec-&gt;thisValue();
1689     if (!checkObjectCoercible(thisValue))
1690         return throwVMTypeError(exec, scope);
1691 
1692     String stringToSearchIn = thisValue.toWTFString(exec);
1693     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1694 
1695     JSValue a0 = exec-&gt;argument(0);
1696     bool isRegularExpression = isRegExp(vm, exec, a0);
1697     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1698     if (isRegularExpression)
1699         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.startsWith cannot be a RegExp&quot;);
1700 
1701     String searchString = a0.toWTFString(exec);
1702     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1703 
1704     JSValue positionArg = exec-&gt;argument(1);
1705     unsigned start = 0;
1706     if (positionArg.isInt32())
1707         start = std::max(0, positionArg.asInt32());
1708     else {
1709         unsigned length = stringToSearchIn.length();
1710         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
1711         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1712     }
1713 
1714     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixStartingAt(searchString, start)));
1715 }
1716 
1717 EncodedJSValue JSC_HOST_CALL stringProtoFuncEndsWith(ExecState* exec)
1718 {
1719     VM&amp; vm = exec-&gt;vm();
1720     auto scope = DECLARE_THROW_SCOPE(vm);
1721 
1722     JSValue thisValue = exec-&gt;thisValue();
1723     if (!checkObjectCoercible(thisValue))
1724         return throwVMTypeError(exec, scope);
1725 
1726     String stringToSearchIn = thisValue.toWTFString(exec);
1727     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1728 
1729     JSValue a0 = exec-&gt;argument(0);
1730     bool isRegularExpression = isRegExp(vm, exec, a0);
1731     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1732     if (isRegularExpression)
1733         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.endsWith cannot be a RegExp&quot;);
1734 
1735     String searchString = a0.toWTFString(exec);
1736     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1737 
1738     unsigned length = stringToSearchIn.length();
1739 
1740     JSValue endPositionArg = exec-&gt;argument(1);
1741     unsigned end = length;
1742     if (endPositionArg.isInt32())
1743         end = std::max(0, endPositionArg.asInt32());
1744     else if (!endPositionArg.isUndefined()) {
1745         end = clampAndTruncateToUnsigned(endPositionArg.toInteger(exec), 0, length);
1746         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1747     }
1748 
1749     return JSValue::encode(jsBoolean(stringToSearchIn.hasInfixEndingAt(searchString, std::min(end, length))));
1750 }
1751 
1752 static EncodedJSValue JSC_HOST_CALL stringIncludesImpl(VM&amp; vm, ExecState* exec, String stringToSearchIn, String searchString, JSValue positionArg)
1753 {
1754     auto scope = DECLARE_THROW_SCOPE(vm);
1755     unsigned start = 0;
1756     if (positionArg.isInt32())
1757         start = std::max(0, positionArg.asInt32());
1758     else {
1759         unsigned length = stringToSearchIn.length();
1760         start = clampAndTruncateToUnsigned(positionArg.toInteger(exec), 0, length);
1761         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1762     }
1763 
1764     return JSValue::encode(jsBoolean(stringToSearchIn.find(searchString, start) != notFound));
1765 }
1766 
1767 EncodedJSValue JSC_HOST_CALL stringProtoFuncIncludes(ExecState* exec)
1768 {
1769     VM&amp; vm = exec-&gt;vm();
1770     auto scope = DECLARE_THROW_SCOPE(vm);
1771 
1772     JSValue thisValue = exec-&gt;thisValue();
1773     if (!checkObjectCoercible(thisValue))
1774         return throwVMTypeError(exec, scope);
1775 
1776     String stringToSearchIn = thisValue.toWTFString(exec);
1777     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1778 
1779     JSValue a0 = exec-&gt;argument(0);
1780     bool isRegularExpression = isRegExp(vm, exec, a0);
1781     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1782     if (isRegularExpression)
1783         return throwVMTypeError(exec, scope, &quot;Argument to String.prototype.includes cannot be a RegExp&quot;);
1784 
1785     String searchString = a0.toWTFString(exec);
1786     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1787 
1788     JSValue positionArg = exec-&gt;argument(1);
1789 
1790     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
1791 }
1792 
1793 EncodedJSValue JSC_HOST_CALL builtinStringIncludesInternal(ExecState* exec)
1794 {
1795     VM&amp; vm = exec-&gt;vm();
1796     auto scope = DECLARE_THROW_SCOPE(vm);
1797 
1798     JSValue thisValue = exec-&gt;thisValue();
1799     ASSERT(checkObjectCoercible(thisValue));
1800 
1801     String stringToSearchIn = thisValue.toWTFString(exec);
1802     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1803 
1804     JSValue a0 = exec-&gt;uncheckedArgument(0);
1805     String searchString = a0.toWTFString(exec);
1806     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1807 
1808     JSValue positionArg = exec-&gt;argument(1);
1809 
1810     RELEASE_AND_RETURN(scope, stringIncludesImpl(vm, exec, stringToSearchIn, searchString, positionArg));
1811 }
1812 
1813 EncodedJSValue JSC_HOST_CALL stringProtoFuncIterator(ExecState* exec)
1814 {
1815     VM&amp; vm = exec-&gt;vm();
1816     auto scope = DECLARE_THROW_SCOPE(vm);
1817 
1818     JSValue thisValue = exec-&gt;thisValue();
1819     if (!checkObjectCoercible(thisValue))
1820         return throwVMTypeError(exec, scope);
1821     JSString* string = thisValue.toString(exec);
1822     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1823     return JSValue::encode(JSStringIterator::create(exec, exec-&gt;jsCallee()-&gt;globalObject(vm)-&gt;stringIteratorStructure(), string));
1824 }
1825 
1826 enum class NormalizationForm { NFC, NFD, NFKC, NFKD };
1827 
1828 static constexpr bool normalizationAffects8Bit(NormalizationForm form)
1829 {
1830     switch (form) {
1831     case NormalizationForm::NFC:
1832         return false;
1833     case NormalizationForm::NFD:
1834         return true;
1835     case NormalizationForm::NFKC:
1836         return false;
1837     case NormalizationForm::NFKD:
1838         return true;
1839     default:
1840         ASSERT_NOT_REACHED();
1841     }
1842     return true;
1843 }
1844 
1845 static const UNormalizer2* normalizer(NormalizationForm form)
1846 {
1847     UErrorCode status = U_ZERO_ERROR;
1848     const UNormalizer2* normalizer = nullptr;
1849     switch (form) {
1850     case NormalizationForm::NFC:
1851         normalizer = unorm2_getNFCInstance(&amp;status);
1852         break;
1853     case NormalizationForm::NFD:
1854         normalizer = unorm2_getNFDInstance(&amp;status);
1855         break;
1856     case NormalizationForm::NFKC:
1857         normalizer = unorm2_getNFKCInstance(&amp;status);
1858         break;
1859     case NormalizationForm::NFKD:
1860         normalizer = unorm2_getNFKDInstance(&amp;status);
1861         break;
1862     }
1863     ASSERT(normalizer);
1864     ASSERT(U_SUCCESS(status));
1865     return normalizer;
1866 }
1867 
1868 static JSValue normalize(ExecState* exec, JSString* string, NormalizationForm form)
1869 {
1870     VM&amp; vm = exec-&gt;vm();
1871     auto scope = DECLARE_THROW_SCOPE(vm);
1872 
1873     auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
1874     RETURN_IF_EXCEPTION(scope, { });
1875 
1876     StringView view = viewWithString.view;
1877     if (view.is8Bit() &amp;&amp; (!normalizationAffects8Bit(form) || charactersAreAllASCII(view.characters8(), view.length())))
1878         RELEASE_AND_RETURN(scope, string);
1879 
1880     const UNormalizer2* normalizer = JSC::normalizer(form);
1881 
1882     // Since ICU does not offer functions that can perform normalization or check for
1883     // normalization with input that is Latin-1, we need to upconvert to UTF-16 at this point.
1884     auto characters = view.upconvertedCharacters();
1885 
1886     UErrorCode status = U_ZERO_ERROR;
1887     UBool isNormalized = unorm2_isNormalized(normalizer, characters, view.length(), &amp;status);
1888     ASSERT(U_SUCCESS(status));
1889     if (isNormalized)
1890         RELEASE_AND_RETURN(scope, string);
1891 
1892     int32_t normalizedStringLength = unorm2_normalize(normalizer, characters, view.length(), nullptr, 0, &amp;status);
1893     ASSERT(status == U_BUFFER_OVERFLOW_ERROR);
1894 
1895     UChar* buffer;
1896     auto result = StringImpl::tryCreateUninitialized(normalizedStringLength, buffer);
1897     if (!result)
1898         return throwOutOfMemoryError(exec, scope);
1899 
1900     status = U_ZERO_ERROR;
1901     unorm2_normalize(normalizer, characters, view.length(), buffer, normalizedStringLength, &amp;status);
1902     ASSERT(U_SUCCESS(status));
1903 
1904     RELEASE_AND_RETURN(scope, jsString(vm, WTFMove(result)));
1905 }
1906 
1907 EncodedJSValue JSC_HOST_CALL stringProtoFuncNormalize(ExecState* exec)
1908 {
1909     VM&amp; vm = exec-&gt;vm();
1910     auto scope = DECLARE_THROW_SCOPE(vm);
1911 
1912     JSValue thisValue = exec-&gt;thisValue();
1913     if (!checkObjectCoercible(thisValue))
1914         return throwVMTypeError(exec, scope);
1915     JSString* string = thisValue.toString(exec);
1916     RETURN_IF_EXCEPTION(scope, { });
1917 
1918     auto form = NormalizationForm::NFC;
1919     JSValue formValue = exec-&gt;argument(0);
1920     if (!formValue.isUndefined()) {
1921         String formString = formValue.toWTFString(exec);
1922         RETURN_IF_EXCEPTION(scope, { });
1923 
1924         if (formString == &quot;NFC&quot;)
1925             form = NormalizationForm::NFC;
1926         else if (formString == &quot;NFD&quot;)
1927             form = NormalizationForm::NFD;
1928         else if (formString == &quot;NFKC&quot;)
1929             form = NormalizationForm::NFKC;
1930         else if (formString == &quot;NFKD&quot;)
1931             form = NormalizationForm::NFKD;
1932         else
1933             return throwVMRangeError(exec, scope, &quot;argument does not match any normalization form&quot;_s);
1934     }
1935 
1936     RELEASE_AND_RETURN(scope, JSValue::encode(normalize(exec, string, form)));
1937 }
1938 
1939 } // namespace JSC
    </pre>
  </body>
</html>