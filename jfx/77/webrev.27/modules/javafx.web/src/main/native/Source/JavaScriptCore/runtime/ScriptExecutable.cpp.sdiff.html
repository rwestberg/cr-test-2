<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScriptExecutable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScopedArgumentsTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutable.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ScriptExecutable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;BatchedTransitionOptimizer.h&quot;
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;Debugger.h&quot;
 31 #include &quot;EvalCodeBlock.h&quot;
 32 #include &quot;FunctionCodeBlock.h&quot;

 33 #include &quot;IsoCellSetInlines.h&quot;
 34 #include &quot;JIT.h&quot;
 35 #include &quot;JSCInlines.h&quot;

 36 #include &quot;LLIntEntrypoint.h&quot;
 37 #include &quot;ModuleProgramCodeBlock.h&quot;
 38 #include &quot;Parser.h&quot;
 39 #include &quot;ProgramCodeBlock.h&quot;
 40 #include &quot;TypeProfiler.h&quot;
 41 #include &quot;VMInlines.h&quot;
 42 #include &lt;wtf/CommaPrinter.h&gt;
 43 
 44 namespace JSC {
 45 
 46 const ClassInfo ScriptExecutable::s_info = { &quot;ScriptExecutable&quot;, &amp;ExecutableBase::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ScriptExecutable) };
 47 
 48 ScriptExecutable::ScriptExecutable(Structure* structure, VM&amp; vm, const SourceCode&amp; source, bool isInStrictContext, DerivedContextType derivedContextType, bool isInArrowFunctionContext, EvalContextType evalContextType, Intrinsic intrinsic)
 49     : ExecutableBase(vm, structure)
 50     , m_source(source)
 51     , m_intrinsic(intrinsic)
 52     , m_features(isInStrictContext ? StrictModeFeature : 0)
 53     , m_hasCapturedVariables(false)
 54     , m_neverInline(false)
 55     , m_neverOptimize(false)
 56     , m_neverFTLOptimize(false)
 57     , m_isArrowFunctionContext(isInArrowFunctionContext)
 58     , m_canUseOSRExitFuzzing(true)

 59     , m_derivedContextType(static_cast&lt;unsigned&gt;(derivedContextType))
 60     , m_evalContextType(static_cast&lt;unsigned&gt;(evalContextType))
 61 {
 62 }
 63 
 64 void ScriptExecutable::destroy(JSCell* cell)
 65 {
 66     static_cast&lt;ScriptExecutable*&gt;(cell)-&gt;ScriptExecutable::~ScriptExecutable();
 67 }
 68 
 69 void ScriptExecutable::clearCode(IsoCellSet&amp; clearableCodeSet)
 70 {
<span class="line-removed"> 71 #if ENABLE(JIT)</span>
 72     m_jitCodeForCall = nullptr;
 73     m_jitCodeForConstruct = nullptr;
 74     m_jitCodeForCallWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();
 75     m_jitCodeForConstructWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();
<span class="line-removed"> 76 #endif</span>
<span class="line-removed"> 77     m_numParametersForCall = NUM_PARAMETERS_NOT_COMPILED;</span>
<span class="line-removed"> 78     m_numParametersForConstruct = NUM_PARAMETERS_NOT_COMPILED;</span>
 79 
 80     switch (type()) {
 81     case FunctionExecutableType: {
 82         FunctionExecutable* executable = static_cast&lt;FunctionExecutable*&gt;(this);
 83         executable-&gt;m_codeBlockForCall.clear();
 84         executable-&gt;m_codeBlockForConstruct.clear();
 85         break;
 86     }
 87     case EvalExecutableType: {
 88         EvalExecutable* executable = static_cast&lt;EvalExecutable*&gt;(this);
 89         executable-&gt;m_evalCodeBlock.clear();
 90         executable-&gt;m_unlinkedEvalCodeBlock.clear();
 91         break;
 92     }
 93     case ProgramExecutableType: {
 94         ProgramExecutable* executable = static_cast&lt;ProgramExecutable*&gt;(this);
 95         executable-&gt;m_programCodeBlock.clear();
 96         executable-&gt;m_unlinkedProgramCodeBlock.clear();
 97         break;
 98     }
 99     case ModuleProgramExecutableType: {
100         ModuleProgramExecutable* executable = static_cast&lt;ModuleProgramExecutable*&gt;(this);
101         executable-&gt;m_moduleProgramCodeBlock.clear();
102         executable-&gt;m_unlinkedModuleProgramCodeBlock.clear();
103         executable-&gt;m_moduleEnvironmentSymbolTable.clear();
104         break;
105     }
106     default:
107         RELEASE_ASSERT_NOT_REACHED();
108         break;
109     }
110 
111     ASSERT(&amp;VM::SpaceAndSet::setFor(*subspace()) == &amp;clearableCodeSet);
112     clearableCodeSet.remove(this);
113 }
114 
115 void ScriptExecutable::installCode(CodeBlock* codeBlock)
116 {
<span class="line-modified">117     installCode(*codeBlock-&gt;vm(), codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());</span>
118 }
119 
120 void ScriptExecutable::installCode(VM&amp; vm, CodeBlock* genericCodeBlock, CodeType codeType, CodeSpecializationKind kind)
121 {
122     if (genericCodeBlock)
123         CODEBLOCK_LOG_EVENT(genericCodeBlock, &quot;installCode&quot;, ());
124 
125     CodeBlock* oldCodeBlock = nullptr;
126 
127     switch (codeType) {
128     case GlobalCode: {
129         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
130         ProgramCodeBlock* codeBlock = static_cast&lt;ProgramCodeBlock*&gt;(genericCodeBlock);
131 
132         ASSERT(kind == CodeForCall);
133 
134         oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_programCodeBlock.get());
135         executable-&gt;m_programCodeBlock.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
136         break;
137     }
</pre>
<hr />
<pre>
163         FunctionCodeBlock* codeBlock = static_cast&lt;FunctionCodeBlock*&gt;(genericCodeBlock);
164 
165         switch (kind) {
166         case CodeForCall:
167             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForCall.get());
168             executable-&gt;m_codeBlockForCall.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
169             break;
170         case CodeForConstruct:
171             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForConstruct.get());
172             executable-&gt;m_codeBlockForConstruct.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
173             break;
174         }
175         break;
176     }
177     }
178 
179     switch (kind) {
180     case CodeForCall:
181         m_jitCodeForCall = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
182         m_jitCodeForCallWithArityCheck = nullptr;
<span class="line-removed">183         m_numParametersForCall = genericCodeBlock ? genericCodeBlock-&gt;numParameters() : NUM_PARAMETERS_NOT_COMPILED;</span>
184         break;
185     case CodeForConstruct:
186         m_jitCodeForConstruct = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
187         m_jitCodeForConstructWithArityCheck = nullptr;
<span class="line-removed">188         m_numParametersForConstruct = genericCodeBlock ? genericCodeBlock-&gt;numParameters() : NUM_PARAMETERS_NOT_COMPILED;</span>
189         break;
190     }
191 
192     auto&amp; clearableCodeSet = VM::SpaceAndSet::setFor(*subspace());
193     if (hasClearableCode(vm))
194         clearableCodeSet.add(this);
195     else
196         clearableCodeSet.remove(this);
197 
198     if (genericCodeBlock) {
199         RELEASE_ASSERT(genericCodeBlock-&gt;ownerExecutable() == this);
200         RELEASE_ASSERT(JITCode::isExecutableScript(genericCodeBlock-&gt;jitType()));
201 
202         if (UNLIKELY(Options::verboseOSR()))
203             dataLog(&quot;Installing &quot;, *genericCodeBlock, &quot;\n&quot;);
204 
205         if (UNLIKELY(vm.m_perBytecodeProfiler))
206             vm.m_perBytecodeProfiler-&gt;ensureBytecodesFor(genericCodeBlock);
207 
208         Debugger* debugger = genericCodeBlock-&gt;globalObject()-&gt;debugger();
209         if (UNLIKELY(debugger))
210             debugger-&gt;registerCodeBlock(genericCodeBlock);
211     }
212 
213     if (oldCodeBlock)
214         oldCodeBlock-&gt;unlinkIncomingCalls();
215 
216     vm.heap.writeBarrier(this);
217 }
218 
219 bool ScriptExecutable::hasClearableCode(VM&amp; vm) const
220 {
<span class="line-removed">221 #if ENABLE(JIT)</span>
222     if (m_jitCodeForCall
223         || m_jitCodeForConstruct
224         || m_jitCodeForCallWithArityCheck
225         || m_jitCodeForConstructWithArityCheck)
226         return true;
<span class="line-removed">227 #endif</span>
228 
229     if (structure(vm)-&gt;classInfo() == FunctionExecutable::info()) {
230         auto* executable = static_cast&lt;const FunctionExecutable*&gt;(this);
231         if (executable-&gt;m_codeBlockForCall || executable-&gt;m_codeBlockForConstruct)
232             return true;
233 
234     } else if (structure(vm)-&gt;classInfo() == EvalExecutable::info()) {
235         auto* executable = static_cast&lt;const EvalExecutable*&gt;(this);
236         if (executable-&gt;m_evalCodeBlock || executable-&gt;m_unlinkedEvalCodeBlock)
237             return true;
238 
239     } else if (structure(vm)-&gt;classInfo() == ProgramExecutable::info()) {
240         auto* executable = static_cast&lt;const ProgramExecutable*&gt;(this);
241         if (executable-&gt;m_programCodeBlock || executable-&gt;m_unlinkedProgramCodeBlock)
242             return true;
243 
244     } else if (structure(vm)-&gt;classInfo() == ModuleProgramExecutable::info()) {
245         auto* executable = static_cast&lt;const ModuleProgramExecutable*&gt;(this);
246         if (executable-&gt;m_moduleProgramCodeBlock
247             || executable-&gt;m_unlinkedModuleProgramCodeBlock
248             || executable-&gt;m_moduleEnvironmentSymbolTable)
249             return true;
250     }
251     return false;
252 }
253 
254 CodeBlock* ScriptExecutable::newCodeBlockFor(
<span class="line-modified">255     CodeSpecializationKind kind, JSFunction* function, JSScope* scope, JSObject*&amp; exception)</span>
256 {
<span class="line-modified">257     VM* vm = scope-&gt;vm();</span>
<span class="line-modified">258     auto throwScope = DECLARE_THROW_SCOPE(*vm);</span>
259 
<span class="line-modified">260     ASSERT(vm-&gt;heap.isDeferred());</span>
261     ASSERT(endColumn() != UINT_MAX);
262 
<span class="line-modified">263     JSGlobalObject* globalObject = scope-&gt;globalObject(*vm);</span>
264     ExecState* exec = globalObject-&gt;globalExec();
265 
<span class="line-modified">266     if (classInfo(*vm) == EvalExecutable::info()) {</span>
267         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
268         RELEASE_ASSERT(kind == CodeForCall);
269         RELEASE_ASSERT(!executable-&gt;m_evalCodeBlock);
270         RELEASE_ASSERT(!function);
271         auto codeBlock = EvalCodeBlock::create(vm,
272             executable, executable-&gt;m_unlinkedEvalCodeBlock.get(), scope);
273         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
274         if (!codeBlock) {
275             exception = throwException(
276                 exec, throwScope,
277                 createOutOfMemoryError(exec));
278             return nullptr;
279         }
280         return codeBlock;
281     }
282 
<span class="line-modified">283     if (classInfo(*vm) == ProgramExecutable::info()) {</span>
284         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
285         RELEASE_ASSERT(kind == CodeForCall);
286         RELEASE_ASSERT(!executable-&gt;m_programCodeBlock);
287         RELEASE_ASSERT(!function);
288         auto codeBlock = ProgramCodeBlock::create(vm,
289             executable, executable-&gt;m_unlinkedProgramCodeBlock.get(), scope);
290         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
291         if (!codeBlock) {
292             exception = throwException(
293                 exec, throwScope,
294                 createOutOfMemoryError(exec));
295             return nullptr;
296         }
297         return codeBlock;
298     }
299 
<span class="line-modified">300     if (classInfo(*vm) == ModuleProgramExecutable::info()) {</span>
301         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
302         RELEASE_ASSERT(kind == CodeForCall);
303         RELEASE_ASSERT(!executable-&gt;m_moduleProgramCodeBlock);
304         RELEASE_ASSERT(!function);
305         auto codeBlock = ModuleProgramCodeBlock::create(vm,
306             executable, executable-&gt;m_unlinkedModuleProgramCodeBlock.get(), scope);
307         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
308         if (!codeBlock) {
309             exception = throwException(
310                 exec, throwScope,
311                 createOutOfMemoryError(exec));
312             return nullptr;
313         }
314         return codeBlock;
315     }
316 
<span class="line-modified">317     RELEASE_ASSERT(classInfo(*vm) == FunctionExecutable::info());</span>
318     RELEASE_ASSERT(function);
319     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
320     RELEASE_ASSERT(!executable-&gt;codeBlockFor(kind));
321     ParserError error;
<span class="line-modified">322     DebuggerMode debuggerMode = globalObject-&gt;hasInteractiveDebugger() ? DebuggerOn : DebuggerOff;</span>









323     UnlinkedFunctionCodeBlock* unlinkedCodeBlock =
324         executable-&gt;m_unlinkedExecutable-&gt;unlinkedCodeBlockFor(
<span class="line-modified">325             *vm, executable-&gt;m_source, kind, debuggerMode, error,</span>
326             executable-&gt;parseMode());
327     recordParse(
328         executable-&gt;m_unlinkedExecutable-&gt;features(),
329         executable-&gt;m_unlinkedExecutable-&gt;hasCapturedVariables(),
330         lastLine(), endColumn());
331     if (!unlinkedCodeBlock) {
332         exception = throwException(
333             globalObject-&gt;globalExec(), throwScope,
<span class="line-modified">334             error.toErrorObject(globalObject, executable-&gt;m_source));</span>
335         return nullptr;
336     }
337 
338     RELEASE_AND_RETURN(throwScope, FunctionCodeBlock::create(vm, executable, unlinkedCodeBlock, scope));
339 }
340 
341 CodeBlock* ScriptExecutable::newReplacementCodeBlockFor(
342     CodeSpecializationKind kind)
343 {
<span class="line-modified">344     VM&amp; vm = *this-&gt;vm();</span>
345     if (classInfo(vm) == EvalExecutable::info()) {
346         RELEASE_ASSERT(kind == CodeForCall);
347         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
348         EvalCodeBlock* baseline = static_cast&lt;EvalCodeBlock*&gt;(
349             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">350         EvalCodeBlock* result = EvalCodeBlock::create(&amp;vm,</span>
351             CodeBlock::CopyParsedBlock, *baseline);
352         result-&gt;setAlternative(vm, baseline);
353         return result;
354     }
355 
356     if (classInfo(vm) == ProgramExecutable::info()) {
357         RELEASE_ASSERT(kind == CodeForCall);
358         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
359         ProgramCodeBlock* baseline = static_cast&lt;ProgramCodeBlock*&gt;(
360             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">361         ProgramCodeBlock* result = ProgramCodeBlock::create(&amp;vm,</span>
362             CodeBlock::CopyParsedBlock, *baseline);
363         result-&gt;setAlternative(vm, baseline);
364         return result;
365     }
366 
367     if (classInfo(vm) == ModuleProgramExecutable::info()) {
368         RELEASE_ASSERT(kind == CodeForCall);
369         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
370         ModuleProgramCodeBlock* baseline = static_cast&lt;ModuleProgramCodeBlock*&gt;(
371             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">372         ModuleProgramCodeBlock* result = ModuleProgramCodeBlock::create(&amp;vm,</span>
373             CodeBlock::CopyParsedBlock, *baseline);
374         result-&gt;setAlternative(vm, baseline);
375         return result;
376     }
377 
378     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
379     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
380     FunctionCodeBlock* baseline = static_cast&lt;FunctionCodeBlock*&gt;(
381         executable-&gt;codeBlockFor(kind)-&gt;baselineVersion());
<span class="line-modified">382     FunctionCodeBlock* result = FunctionCodeBlock::create(&amp;vm,</span>
383         CodeBlock::CopyParsedBlock, *baseline);
384     result-&gt;setAlternative(vm, baseline);
385     return result;
386 }
387 
<span class="line-modified">388 static void setupLLInt(VM&amp; vm, CodeBlock* codeBlock)</span>
389 {
<span class="line-modified">390     LLInt::setEntrypoint(vm, codeBlock);</span>
391 }
392 
393 static void setupJIT(VM&amp; vm, CodeBlock* codeBlock)
394 {
395 #if ENABLE(JIT)
<span class="line-modified">396     CompilationResult result = JIT::compile(&amp;vm, codeBlock, JITCompilationMustSucceed);</span>
397     RELEASE_ASSERT(result == CompilationSuccessful);
398 #else
399     UNUSED_PARAM(vm);
400     UNUSED_PARAM(codeBlock);
401     UNREACHABLE_FOR_PLATFORM();
402 #endif
403 }
404 
<span class="line-modified">405 JSObject* ScriptExecutable::prepareForExecutionImpl(</span>
406     VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)
407 {
408     auto throwScope = DECLARE_THROW_SCOPE(vm);
409     DeferGCForAWhile deferGC(vm.heap);
410 
<span class="line-modified">411     if (vm.getAndClearFailNextNewCodeBlock()) {</span>
412         auto&amp; state = *scope-&gt;globalObject(vm)-&gt;globalExec();
413         return throwException(&amp;state, throwScope, createError(&amp;state, &quot;Forced Failure&quot;_s));
414     }
415 
<span class="line-modified">416     JSObject* exception = nullptr;</span>
417     CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);
418     resultCodeBlock = codeBlock;
419     EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);
420     if (UNLIKELY(!codeBlock))
421         return exception;
422 
423     if (Options::validateBytecode())
424         codeBlock-&gt;validate();
425 
426     if (Options::useLLInt())
<span class="line-modified">427         setupLLInt(vm, codeBlock);</span>
428     else
429         setupJIT(vm, codeBlock);
430 
431     installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
432     return nullptr;
433 }
434 























































435 CodeBlockHash ScriptExecutable::hashFor(CodeSpecializationKind kind) const
436 {
437     return CodeBlockHash(source(), kind);
438 }
439 
440 Optional&lt;int&gt; ScriptExecutable::overrideLineNumber(VM&amp; vm) const
441 {
442     if (inherits&lt;FunctionExecutable&gt;(vm))
443         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;overrideLineNumber();
444     return WTF::nullopt;
445 }
446 
447 unsigned ScriptExecutable::typeProfilingStartOffset(VM&amp; vm) const
448 {
449     if (inherits&lt;FunctionExecutable&gt;(vm))
450         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingStartOffset(vm);
451     if (inherits&lt;EvalExecutable&gt;(vm))
452         return UINT_MAX;
453     return 0;
454 }
455 
456 unsigned ScriptExecutable::typeProfilingEndOffset(VM&amp; vm) const
457 {
458     if (inherits&lt;FunctionExecutable&gt;(vm))
459         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingEndOffset(vm);
460     if (inherits&lt;EvalExecutable&gt;(vm))
461         return UINT_MAX;
<span class="line-modified">462     return m_source.length() - 1;</span>



































463 }
464 
465 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;BatchedTransitionOptimizer.h&quot;
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;Debugger.h&quot;
 31 #include &quot;EvalCodeBlock.h&quot;
 32 #include &quot;FunctionCodeBlock.h&quot;
<span class="line-added"> 33 #include &quot;GlobalExecutable.h&quot;</span>
 34 #include &quot;IsoCellSetInlines.h&quot;
 35 #include &quot;JIT.h&quot;
 36 #include &quot;JSCInlines.h&quot;
<span class="line-added"> 37 #include &quot;JSTemplateObjectDescriptor.h&quot;</span>
 38 #include &quot;LLIntEntrypoint.h&quot;
 39 #include &quot;ModuleProgramCodeBlock.h&quot;
 40 #include &quot;Parser.h&quot;
 41 #include &quot;ProgramCodeBlock.h&quot;
 42 #include &quot;TypeProfiler.h&quot;
 43 #include &quot;VMInlines.h&quot;
 44 #include &lt;wtf/CommaPrinter.h&gt;
 45 
 46 namespace JSC {
 47 
 48 const ClassInfo ScriptExecutable::s_info = { &quot;ScriptExecutable&quot;, &amp;ExecutableBase::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ScriptExecutable) };
 49 
 50 ScriptExecutable::ScriptExecutable(Structure* structure, VM&amp; vm, const SourceCode&amp; source, bool isInStrictContext, DerivedContextType derivedContextType, bool isInArrowFunctionContext, EvalContextType evalContextType, Intrinsic intrinsic)
 51     : ExecutableBase(vm, structure)
 52     , m_source(source)
 53     , m_intrinsic(intrinsic)
 54     , m_features(isInStrictContext ? StrictModeFeature : 0)
 55     , m_hasCapturedVariables(false)
 56     , m_neverInline(false)
 57     , m_neverOptimize(false)
 58     , m_neverFTLOptimize(false)
 59     , m_isArrowFunctionContext(isInArrowFunctionContext)
 60     , m_canUseOSRExitFuzzing(true)
<span class="line-added"> 61     , m_codeForGeneratorBodyWasGenerated(false)</span>
 62     , m_derivedContextType(static_cast&lt;unsigned&gt;(derivedContextType))
 63     , m_evalContextType(static_cast&lt;unsigned&gt;(evalContextType))
 64 {
 65 }
 66 
 67 void ScriptExecutable::destroy(JSCell* cell)
 68 {
 69     static_cast&lt;ScriptExecutable*&gt;(cell)-&gt;ScriptExecutable::~ScriptExecutable();
 70 }
 71 
 72 void ScriptExecutable::clearCode(IsoCellSet&amp; clearableCodeSet)
 73 {

 74     m_jitCodeForCall = nullptr;
 75     m_jitCodeForConstruct = nullptr;
 76     m_jitCodeForCallWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();
 77     m_jitCodeForConstructWithArityCheck = MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;();



 78 
 79     switch (type()) {
 80     case FunctionExecutableType: {
 81         FunctionExecutable* executable = static_cast&lt;FunctionExecutable*&gt;(this);
 82         executable-&gt;m_codeBlockForCall.clear();
 83         executable-&gt;m_codeBlockForConstruct.clear();
 84         break;
 85     }
 86     case EvalExecutableType: {
 87         EvalExecutable* executable = static_cast&lt;EvalExecutable*&gt;(this);
 88         executable-&gt;m_evalCodeBlock.clear();
 89         executable-&gt;m_unlinkedEvalCodeBlock.clear();
 90         break;
 91     }
 92     case ProgramExecutableType: {
 93         ProgramExecutable* executable = static_cast&lt;ProgramExecutable*&gt;(this);
 94         executable-&gt;m_programCodeBlock.clear();
 95         executable-&gt;m_unlinkedProgramCodeBlock.clear();
 96         break;
 97     }
 98     case ModuleProgramExecutableType: {
 99         ModuleProgramExecutable* executable = static_cast&lt;ModuleProgramExecutable*&gt;(this);
100         executable-&gt;m_moduleProgramCodeBlock.clear();
101         executable-&gt;m_unlinkedModuleProgramCodeBlock.clear();
102         executable-&gt;m_moduleEnvironmentSymbolTable.clear();
103         break;
104     }
105     default:
106         RELEASE_ASSERT_NOT_REACHED();
107         break;
108     }
109 
110     ASSERT(&amp;VM::SpaceAndSet::setFor(*subspace()) == &amp;clearableCodeSet);
111     clearableCodeSet.remove(this);
112 }
113 
114 void ScriptExecutable::installCode(CodeBlock* codeBlock)
115 {
<span class="line-modified">116     installCode(codeBlock-&gt;vm(), codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());</span>
117 }
118 
119 void ScriptExecutable::installCode(VM&amp; vm, CodeBlock* genericCodeBlock, CodeType codeType, CodeSpecializationKind kind)
120 {
121     if (genericCodeBlock)
122         CODEBLOCK_LOG_EVENT(genericCodeBlock, &quot;installCode&quot;, ());
123 
124     CodeBlock* oldCodeBlock = nullptr;
125 
126     switch (codeType) {
127     case GlobalCode: {
128         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
129         ProgramCodeBlock* codeBlock = static_cast&lt;ProgramCodeBlock*&gt;(genericCodeBlock);
130 
131         ASSERT(kind == CodeForCall);
132 
133         oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_programCodeBlock.get());
134         executable-&gt;m_programCodeBlock.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
135         break;
136     }
</pre>
<hr />
<pre>
162         FunctionCodeBlock* codeBlock = static_cast&lt;FunctionCodeBlock*&gt;(genericCodeBlock);
163 
164         switch (kind) {
165         case CodeForCall:
166             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForCall.get());
167             executable-&gt;m_codeBlockForCall.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
168             break;
169         case CodeForConstruct:
170             oldCodeBlock = ExecutableToCodeBlockEdge::deactivateAndUnwrap(executable-&gt;m_codeBlockForConstruct.get());
171             executable-&gt;m_codeBlockForConstruct.setMayBeNull(vm, this, ExecutableToCodeBlockEdge::wrapAndActivate(codeBlock));
172             break;
173         }
174         break;
175     }
176     }
177 
178     switch (kind) {
179     case CodeForCall:
180         m_jitCodeForCall = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
181         m_jitCodeForCallWithArityCheck = nullptr;

182         break;
183     case CodeForConstruct:
184         m_jitCodeForConstruct = genericCodeBlock ? genericCodeBlock-&gt;jitCode() : nullptr;
185         m_jitCodeForConstructWithArityCheck = nullptr;

186         break;
187     }
188 
189     auto&amp; clearableCodeSet = VM::SpaceAndSet::setFor(*subspace());
190     if (hasClearableCode(vm))
191         clearableCodeSet.add(this);
192     else
193         clearableCodeSet.remove(this);
194 
195     if (genericCodeBlock) {
196         RELEASE_ASSERT(genericCodeBlock-&gt;ownerExecutable() == this);
197         RELEASE_ASSERT(JITCode::isExecutableScript(genericCodeBlock-&gt;jitType()));
198 
199         if (UNLIKELY(Options::verboseOSR()))
200             dataLog(&quot;Installing &quot;, *genericCodeBlock, &quot;\n&quot;);
201 
202         if (UNLIKELY(vm.m_perBytecodeProfiler))
203             vm.m_perBytecodeProfiler-&gt;ensureBytecodesFor(genericCodeBlock);
204 
205         Debugger* debugger = genericCodeBlock-&gt;globalObject()-&gt;debugger();
206         if (UNLIKELY(debugger))
207             debugger-&gt;registerCodeBlock(genericCodeBlock);
208     }
209 
210     if (oldCodeBlock)
211         oldCodeBlock-&gt;unlinkIncomingCalls();
212 
213     vm.heap.writeBarrier(this);
214 }
215 
216 bool ScriptExecutable::hasClearableCode(VM&amp; vm) const
217 {

218     if (m_jitCodeForCall
219         || m_jitCodeForConstruct
220         || m_jitCodeForCallWithArityCheck
221         || m_jitCodeForConstructWithArityCheck)
222         return true;

223 
224     if (structure(vm)-&gt;classInfo() == FunctionExecutable::info()) {
225         auto* executable = static_cast&lt;const FunctionExecutable*&gt;(this);
226         if (executable-&gt;m_codeBlockForCall || executable-&gt;m_codeBlockForConstruct)
227             return true;
228 
229     } else if (structure(vm)-&gt;classInfo() == EvalExecutable::info()) {
230         auto* executable = static_cast&lt;const EvalExecutable*&gt;(this);
231         if (executable-&gt;m_evalCodeBlock || executable-&gt;m_unlinkedEvalCodeBlock)
232             return true;
233 
234     } else if (structure(vm)-&gt;classInfo() == ProgramExecutable::info()) {
235         auto* executable = static_cast&lt;const ProgramExecutable*&gt;(this);
236         if (executable-&gt;m_programCodeBlock || executable-&gt;m_unlinkedProgramCodeBlock)
237             return true;
238 
239     } else if (structure(vm)-&gt;classInfo() == ModuleProgramExecutable::info()) {
240         auto* executable = static_cast&lt;const ModuleProgramExecutable*&gt;(this);
241         if (executable-&gt;m_moduleProgramCodeBlock
242             || executable-&gt;m_unlinkedModuleProgramCodeBlock
243             || executable-&gt;m_moduleEnvironmentSymbolTable)
244             return true;
245     }
246     return false;
247 }
248 
249 CodeBlock* ScriptExecutable::newCodeBlockFor(
<span class="line-modified">250     CodeSpecializationKind kind, JSFunction* function, JSScope* scope, Exception*&amp; exception)</span>
251 {
<span class="line-modified">252     VM&amp; vm = scope-&gt;vm();</span>
<span class="line-modified">253     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
254 
<span class="line-modified">255     ASSERT(vm.heap.isDeferred());</span>
256     ASSERT(endColumn() != UINT_MAX);
257 
<span class="line-modified">258     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
259     ExecState* exec = globalObject-&gt;globalExec();
260 
<span class="line-modified">261     if (classInfo(vm) == EvalExecutable::info()) {</span>
262         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
263         RELEASE_ASSERT(kind == CodeForCall);
264         RELEASE_ASSERT(!executable-&gt;m_evalCodeBlock);
265         RELEASE_ASSERT(!function);
266         auto codeBlock = EvalCodeBlock::create(vm,
267             executable, executable-&gt;m_unlinkedEvalCodeBlock.get(), scope);
268         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
269         if (!codeBlock) {
270             exception = throwException(
271                 exec, throwScope,
272                 createOutOfMemoryError(exec));
273             return nullptr;
274         }
275         return codeBlock;
276     }
277 
<span class="line-modified">278     if (classInfo(vm) == ProgramExecutable::info()) {</span>
279         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
280         RELEASE_ASSERT(kind == CodeForCall);
281         RELEASE_ASSERT(!executable-&gt;m_programCodeBlock);
282         RELEASE_ASSERT(!function);
283         auto codeBlock = ProgramCodeBlock::create(vm,
284             executable, executable-&gt;m_unlinkedProgramCodeBlock.get(), scope);
285         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
286         if (!codeBlock) {
287             exception = throwException(
288                 exec, throwScope,
289                 createOutOfMemoryError(exec));
290             return nullptr;
291         }
292         return codeBlock;
293     }
294 
<span class="line-modified">295     if (classInfo(vm) == ModuleProgramExecutable::info()) {</span>
296         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
297         RELEASE_ASSERT(kind == CodeForCall);
298         RELEASE_ASSERT(!executable-&gt;m_moduleProgramCodeBlock);
299         RELEASE_ASSERT(!function);
300         auto codeBlock = ModuleProgramCodeBlock::create(vm,
301             executable, executable-&gt;m_unlinkedModuleProgramCodeBlock.get(), scope);
302         EXCEPTION_ASSERT(throwScope.exception() || codeBlock);
303         if (!codeBlock) {
304             exception = throwException(
305                 exec, throwScope,
306                 createOutOfMemoryError(exec));
307             return nullptr;
308         }
309         return codeBlock;
310     }
311 
<span class="line-modified">312     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());</span>
313     RELEASE_ASSERT(function);
314     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
315     RELEASE_ASSERT(!executable-&gt;codeBlockFor(kind));
316     ParserError error;
<span class="line-modified">317     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();</span>
<span class="line-added">318     // We continue using the same CodeGenerationMode for Generators because live generator objects can</span>
<span class="line-added">319     // keep the state which is only valid with the CodeBlock compiled with the same CodeGenerationMode.</span>
<span class="line-added">320     if (isGeneratorOrAsyncFunctionBodyParseMode(executable-&gt;parseMode())) {</span>
<span class="line-added">321         if (!m_codeForGeneratorBodyWasGenerated) {</span>
<span class="line-added">322             m_codeGenerationModeForGeneratorBody = codeGenerationMode;</span>
<span class="line-added">323             m_codeForGeneratorBodyWasGenerated = true;</span>
<span class="line-added">324         } else</span>
<span class="line-added">325             codeGenerationMode = m_codeGenerationModeForGeneratorBody;</span>
<span class="line-added">326     }</span>
327     UnlinkedFunctionCodeBlock* unlinkedCodeBlock =
328         executable-&gt;m_unlinkedExecutable-&gt;unlinkedCodeBlockFor(
<span class="line-modified">329             vm, executable-&gt;source(), kind, codeGenerationMode, error,</span>
330             executable-&gt;parseMode());
331     recordParse(
332         executable-&gt;m_unlinkedExecutable-&gt;features(),
333         executable-&gt;m_unlinkedExecutable-&gt;hasCapturedVariables(),
334         lastLine(), endColumn());
335     if (!unlinkedCodeBlock) {
336         exception = throwException(
337             globalObject-&gt;globalExec(), throwScope,
<span class="line-modified">338             error.toErrorObject(globalObject, executable-&gt;source()));</span>
339         return nullptr;
340     }
341 
342     RELEASE_AND_RETURN(throwScope, FunctionCodeBlock::create(vm, executable, unlinkedCodeBlock, scope));
343 }
344 
345 CodeBlock* ScriptExecutable::newReplacementCodeBlockFor(
346     CodeSpecializationKind kind)
347 {
<span class="line-modified">348     VM&amp; vm = this-&gt;vm();</span>
349     if (classInfo(vm) == EvalExecutable::info()) {
350         RELEASE_ASSERT(kind == CodeForCall);
351         EvalExecutable* executable = jsCast&lt;EvalExecutable*&gt;(this);
352         EvalCodeBlock* baseline = static_cast&lt;EvalCodeBlock*&gt;(
353             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">354         EvalCodeBlock* result = EvalCodeBlock::create(vm,</span>
355             CodeBlock::CopyParsedBlock, *baseline);
356         result-&gt;setAlternative(vm, baseline);
357         return result;
358     }
359 
360     if (classInfo(vm) == ProgramExecutable::info()) {
361         RELEASE_ASSERT(kind == CodeForCall);
362         ProgramExecutable* executable = jsCast&lt;ProgramExecutable*&gt;(this);
363         ProgramCodeBlock* baseline = static_cast&lt;ProgramCodeBlock*&gt;(
364             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">365         ProgramCodeBlock* result = ProgramCodeBlock::create(vm,</span>
366             CodeBlock::CopyParsedBlock, *baseline);
367         result-&gt;setAlternative(vm, baseline);
368         return result;
369     }
370 
371     if (classInfo(vm) == ModuleProgramExecutable::info()) {
372         RELEASE_ASSERT(kind == CodeForCall);
373         ModuleProgramExecutable* executable = jsCast&lt;ModuleProgramExecutable*&gt;(this);
374         ModuleProgramCodeBlock* baseline = static_cast&lt;ModuleProgramCodeBlock*&gt;(
375             executable-&gt;codeBlock()-&gt;baselineVersion());
<span class="line-modified">376         ModuleProgramCodeBlock* result = ModuleProgramCodeBlock::create(vm,</span>
377             CodeBlock::CopyParsedBlock, *baseline);
378         result-&gt;setAlternative(vm, baseline);
379         return result;
380     }
381 
382     RELEASE_ASSERT(classInfo(vm) == FunctionExecutable::info());
383     FunctionExecutable* executable = jsCast&lt;FunctionExecutable*&gt;(this);
384     FunctionCodeBlock* baseline = static_cast&lt;FunctionCodeBlock*&gt;(
385         executable-&gt;codeBlockFor(kind)-&gt;baselineVersion());
<span class="line-modified">386     FunctionCodeBlock* result = FunctionCodeBlock::create(vm,</span>
387         CodeBlock::CopyParsedBlock, *baseline);
388     result-&gt;setAlternative(vm, baseline);
389     return result;
390 }
391 
<span class="line-modified">392 static void setupLLInt(CodeBlock* codeBlock)</span>
393 {
<span class="line-modified">394     LLInt::setEntrypoint(codeBlock);</span>
395 }
396 
397 static void setupJIT(VM&amp; vm, CodeBlock* codeBlock)
398 {
399 #if ENABLE(JIT)
<span class="line-modified">400     CompilationResult result = JIT::compile(vm, codeBlock, JITCompilationMustSucceed);</span>
401     RELEASE_ASSERT(result == CompilationSuccessful);
402 #else
403     UNUSED_PARAM(vm);
404     UNUSED_PARAM(codeBlock);
405     UNREACHABLE_FOR_PLATFORM();
406 #endif
407 }
408 
<span class="line-modified">409 Exception* ScriptExecutable::prepareForExecutionImpl(</span>
410     VM&amp; vm, JSFunction* function, JSScope* scope, CodeSpecializationKind kind, CodeBlock*&amp; resultCodeBlock)
411 {
412     auto throwScope = DECLARE_THROW_SCOPE(vm);
413     DeferGCForAWhile deferGC(vm.heap);
414 
<span class="line-modified">415     if (UNLIKELY(vm.getAndClearFailNextNewCodeBlock())) {</span>
416         auto&amp; state = *scope-&gt;globalObject(vm)-&gt;globalExec();
417         return throwException(&amp;state, throwScope, createError(&amp;state, &quot;Forced Failure&quot;_s));
418     }
419 
<span class="line-modified">420     Exception* exception = nullptr;</span>
421     CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);
422     resultCodeBlock = codeBlock;
423     EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);
424     if (UNLIKELY(!codeBlock))
425         return exception;
426 
427     if (Options::validateBytecode())
428         codeBlock-&gt;validate();
429 
430     if (Options::useLLInt())
<span class="line-modified">431         setupLLInt(codeBlock);</span>
432     else
433         setupJIT(vm, codeBlock);
434 
435     installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());
436     return nullptr;
437 }
438 
<span class="line-added">439 ScriptExecutable* ScriptExecutable::topLevelExecutable()</span>
<span class="line-added">440 {</span>
<span class="line-added">441     switch (type()) {</span>
<span class="line-added">442     case FunctionExecutableType:</span>
<span class="line-added">443         return jsCast&lt;FunctionExecutable*&gt;(this)-&gt;topLevelExecutable();</span>
<span class="line-added">444     default:</span>
<span class="line-added">445         return this;</span>
<span class="line-added">446     }</span>
<span class="line-added">447 }</span>
<span class="line-added">448 </span>
<span class="line-added">449 JSArray* ScriptExecutable::createTemplateObject(ExecState* exec, JSTemplateObjectDescriptor* descriptor)</span>
<span class="line-added">450 {</span>
<span class="line-added">451     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">452     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">453 </span>
<span class="line-added">454     TemplateObjectMap&amp; templateObjectMap = ensureTemplateObjectMap(vm);</span>
<span class="line-added">455     TemplateObjectMap::AddResult result;</span>
<span class="line-added">456     {</span>
<span class="line-added">457         auto locker = holdLock(cellLock());</span>
<span class="line-added">458         result = templateObjectMap.add(descriptor-&gt;endOffset(), WriteBarrier&lt;JSArray&gt;());</span>
<span class="line-added">459     }</span>
<span class="line-added">460     if (JSArray* array = result.iterator-&gt;value.get())</span>
<span class="line-added">461         return array;</span>
<span class="line-added">462     JSArray* templateObject = descriptor-&gt;createTemplateObject(exec);</span>
<span class="line-added">463     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">464     result.iterator-&gt;value.set(vm, this, templateObject);</span>
<span class="line-added">465     return templateObject;</span>
<span class="line-added">466 }</span>
<span class="line-added">467 </span>
<span class="line-added">468 auto ScriptExecutable::ensureTemplateObjectMapImpl(std::unique_ptr&lt;TemplateObjectMap&gt;&amp; dest) -&gt; TemplateObjectMap&amp;</span>
<span class="line-added">469 {</span>
<span class="line-added">470     if (dest)</span>
<span class="line-added">471         return *dest;</span>
<span class="line-added">472     auto result = makeUnique&lt;TemplateObjectMap&gt;();</span>
<span class="line-added">473     WTF::storeStoreFence();</span>
<span class="line-added">474     dest = WTFMove(result);</span>
<span class="line-added">475     return *dest;</span>
<span class="line-added">476 }</span>
<span class="line-added">477 </span>
<span class="line-added">478 auto ScriptExecutable::ensureTemplateObjectMap(VM&amp; vm) -&gt; TemplateObjectMap&amp;</span>
<span class="line-added">479 {</span>
<span class="line-added">480     switch (type()) {</span>
<span class="line-added">481     case FunctionExecutableType:</span>
<span class="line-added">482         return static_cast&lt;FunctionExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);</span>
<span class="line-added">483     case EvalExecutableType:</span>
<span class="line-added">484         return static_cast&lt;EvalExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);</span>
<span class="line-added">485     case ProgramExecutableType:</span>
<span class="line-added">486         return static_cast&lt;ProgramExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);</span>
<span class="line-added">487     case ModuleProgramExecutableType:</span>
<span class="line-added">488     default:</span>
<span class="line-added">489         ASSERT(type() == ModuleProgramExecutableType);</span>
<span class="line-added">490         return static_cast&lt;ModuleProgramExecutable*&gt;(this)-&gt;ensureTemplateObjectMap(vm);</span>
<span class="line-added">491     }</span>
<span class="line-added">492 }</span>
<span class="line-added">493 </span>
494 CodeBlockHash ScriptExecutable::hashFor(CodeSpecializationKind kind) const
495 {
496     return CodeBlockHash(source(), kind);
497 }
498 
499 Optional&lt;int&gt; ScriptExecutable::overrideLineNumber(VM&amp; vm) const
500 {
501     if (inherits&lt;FunctionExecutable&gt;(vm))
502         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;overrideLineNumber();
503     return WTF::nullopt;
504 }
505 
506 unsigned ScriptExecutable::typeProfilingStartOffset(VM&amp; vm) const
507 {
508     if (inherits&lt;FunctionExecutable&gt;(vm))
509         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingStartOffset(vm);
510     if (inherits&lt;EvalExecutable&gt;(vm))
511         return UINT_MAX;
512     return 0;
513 }
514 
515 unsigned ScriptExecutable::typeProfilingEndOffset(VM&amp; vm) const
516 {
517     if (inherits&lt;FunctionExecutable&gt;(vm))
518         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;typeProfilingEndOffset(vm);
519     if (inherits&lt;EvalExecutable&gt;(vm))
520         return UINT_MAX;
<span class="line-modified">521     return source().length() - 1;</span>
<span class="line-added">522 }</span>
<span class="line-added">523 </span>
<span class="line-added">524 void ScriptExecutable::recordParse(CodeFeatures features, bool hasCapturedVariables, int lastLine, unsigned endColumn)</span>
<span class="line-added">525 {</span>
<span class="line-added">526     switch (type()) {</span>
<span class="line-added">527     case FunctionExecutableType:</span>
<span class="line-added">528         // Since UnlinkedFunctionExecutable holds the information to calculate lastLine and endColumn, we do not need to remember them in ScriptExecutable&#39;s fields.</span>
<span class="line-added">529         jsCast&lt;FunctionExecutable*&gt;(this)-&gt;recordParse(features, hasCapturedVariables);</span>
<span class="line-added">530         return;</span>
<span class="line-added">531     default:</span>
<span class="line-added">532         jsCast&lt;GlobalExecutable*&gt;(this)-&gt;recordParse(features, hasCapturedVariables, lastLine, endColumn);</span>
<span class="line-added">533         return;</span>
<span class="line-added">534     }</span>
<span class="line-added">535 }</span>
<span class="line-added">536 </span>
<span class="line-added">537 int ScriptExecutable::lastLine() const</span>
<span class="line-added">538 {</span>
<span class="line-added">539     switch (type()) {</span>
<span class="line-added">540     case FunctionExecutableType:</span>
<span class="line-added">541         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;lastLine();</span>
<span class="line-added">542     default:</span>
<span class="line-added">543         return jsCast&lt;const GlobalExecutable*&gt;(this)-&gt;lastLine();</span>
<span class="line-added">544     }</span>
<span class="line-added">545     return 0;</span>
<span class="line-added">546 }</span>
<span class="line-added">547 </span>
<span class="line-added">548 unsigned ScriptExecutable::endColumn() const</span>
<span class="line-added">549 {</span>
<span class="line-added">550     switch (type()) {</span>
<span class="line-added">551     case FunctionExecutableType:</span>
<span class="line-added">552         return jsCast&lt;const FunctionExecutable*&gt;(this)-&gt;endColumn();</span>
<span class="line-added">553     default:</span>
<span class="line-added">554         return jsCast&lt;const GlobalExecutable*&gt;(this)-&gt;endColumn();</span>
<span class="line-added">555     }</span>
<span class="line-added">556     return 0;</span>
557 }
558 
559 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ScopedArgumentsTable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutable.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>