<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;HTMLMediaElement.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ApplicationCacheHost.h&quot;
  32 #include &quot;ApplicationCacheResource.h&quot;
  33 #include &quot;Attribute.h&quot;
  34 #include &quot;Blob.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CommonVM.h&quot;
<a name="2" id="anc2"></a>
  39 #include &quot;ContentSecurityPolicy.h&quot;
  40 #include &quot;ContentType.h&quot;
  41 #include &quot;CookieJar.h&quot;
<a name="3" id="anc3"></a>
  42 #include &quot;DeprecatedGlobalSettings.h&quot;
  43 #include &quot;DiagnosticLoggingClient.h&quot;
  44 #include &quot;DiagnosticLoggingKeys.h&quot;
  45 #include &quot;Document.h&quot;
  46 #include &quot;DocumentLoader.h&quot;
  47 #include &quot;ElementChildIterator.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameLoaderClient.h&quot;
  52 #include &quot;FrameView.h&quot;
<a name="4" id="anc4"></a>
  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;HTMLSourceElement.h&quot;
  55 #include &quot;HTMLVideoElement.h&quot;
  56 #include &quot;InspectorInstrumentation.h&quot;
  57 #include &quot;JSDOMException.h&quot;
  58 #include &quot;JSDOMPromiseDeferred.h&quot;
  59 #include &quot;JSHTMLMediaElement.h&quot;
  60 #include &quot;Logging.h&quot;
  61 #include &quot;MIMETypeRegistry.h&quot;
  62 #include &quot;MediaController.h&quot;
  63 #include &quot;MediaControls.h&quot;
  64 #include &quot;MediaDocument.h&quot;
  65 #include &quot;MediaError.h&quot;
  66 #include &quot;MediaFragmentURIParser.h&quot;
  67 #include &quot;MediaList.h&quot;
  68 #include &quot;MediaPlayer.h&quot;
  69 #include &quot;MediaQueryEvaluator.h&quot;
  70 #include &quot;MediaResourceLoader.h&quot;
  71 #include &quot;NetworkingContext.h&quot;
  72 #include &quot;Page.h&quot;
  73 #include &quot;PageGroup.h&quot;
  74 #include &quot;PlatformMediaSessionManager.h&quot;
  75 #include &quot;ProgressTracker.h&quot;
<a name="5" id="anc5"></a><span class="line-removed">  76 #include &quot;PublicSuffix.h&quot;</span>
  77 #include &quot;Quirks.h&quot;
<a name="6" id="anc6"></a>
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTheme.h&quot;
  80 #include &quot;RenderVideo.h&quot;
  81 #include &quot;RenderView.h&quot;
  82 #include &quot;ResourceLoadInfo.h&quot;
  83 #include &quot;ScriptController.h&quot;
  84 #include &quot;ScriptDisallowedScope.h&quot;
  85 #include &quot;ScriptSourceCode.h&quot;
  86 #include &quot;SecurityOriginData.h&quot;
  87 #include &quot;SecurityPolicy.h&quot;
  88 #include &quot;Settings.h&quot;
  89 #include &quot;ShadowRoot.h&quot;
  90 #include &quot;TimeRanges.h&quot;
  91 #include &quot;UserContentController.h&quot;
  92 #include &quot;UserGestureIndicator.h&quot;
  93 #include &quot;VideoPlaybackQuality.h&quot;
  94 #include &lt;JavaScriptCore/Uint8Array.h&gt;
  95 #include &lt;limits&gt;
  96 #include &lt;pal/SessionID.h&gt;
  97 #include &lt;pal/system/SleepDisabler.h&gt;
  98 #include &lt;wtf/Algorithms.h&gt;
  99 #include &lt;wtf/IsoMallocInlines.h&gt;
 100 #include &lt;wtf/Language.h&gt;
 101 #include &lt;wtf/MathExtras.h&gt;
 102 #include &lt;wtf/MemoryPressureHandler.h&gt;
 103 #include &lt;wtf/Ref.h&gt;
 104 #include &lt;wtf/text/CString.h&gt;
 105 
 106 #if ENABLE(VIDEO_TRACK)
 107 #include &quot;AudioTrackList.h&quot;
 108 #include &quot;HTMLTrackElement.h&quot;
 109 #include &quot;InbandGenericTextTrack.h&quot;
 110 #include &quot;InbandTextTrackPrivate.h&quot;
 111 #include &quot;InbandWebVTTTextTrack.h&quot;
 112 #include &quot;RuntimeEnabledFeatures.h&quot;
 113 #include &quot;TextTrackCueList.h&quot;
 114 #include &quot;TextTrackList.h&quot;
 115 #include &quot;VideoTrackList.h&quot;
 116 #endif
 117 
 118 #if ENABLE(WEB_AUDIO)
 119 #include &quot;AudioSourceProvider.h&quot;
 120 #include &quot;MediaElementAudioSourceNode.h&quot;
 121 #endif
 122 
 123 #if PLATFORM(IOS_FAMILY)
 124 #include &quot;RuntimeApplicationChecks.h&quot;
 125 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 126 #endif
 127 
 128 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 129 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 130 #endif
 131 
 132 #if ENABLE(MEDIA_SESSION)
 133 #include &quot;MediaSession.h&quot;
 134 #endif
 135 
 136 #if ENABLE(MEDIA_SOURCE)
 137 #include &quot;DOMWindow.h&quot;
 138 #include &quot;MediaSource.h&quot;
 139 #endif
 140 
 141 #if ENABLE(MEDIA_STREAM)
 142 #include &quot;DOMURL.h&quot;
 143 #include &quot;MediaStream.h&quot;
<a name="7" id="anc7"></a><span class="line-removed"> 144 #include &quot;MediaStreamRegistry.h&quot;</span>
 145 #endif
 146 
 147 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 148 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 149 #include &quot;WebKitMediaKeys.h&quot;
 150 #endif
 151 
 152 #if ENABLE(ENCRYPTED_MEDIA)
 153 #include &quot;MediaEncryptedEvent.h&quot;
 154 #include &quot;MediaKeys.h&quot;
 155 #endif
 156 
 157 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 158 #include &quot;JSMediaControlsHost.h&quot;
 159 #include &quot;MediaControlsHost.h&quot;
 160 #include &lt;JavaScriptCore/ScriptObject.h&gt;
 161 #endif
 162 
 163 #if ENABLE(ENCRYPTED_MEDIA)
 164 #include &quot;NotImplemented.h&quot;
 165 #endif
 166 
 167 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 168 #include &quot;VideoFullscreenModel.h&quot;
 169 #endif
 170 
 171 namespace WTF {
 172 template &lt;&gt;
 173 struct LogArgument&lt;URL&gt; {
 174     static String toString(const URL&amp; url)
 175     {
 176 #if !LOG_DISABLED
 177         static const unsigned maximumURLLengthForLogging = 512;
 178 
 179         if (url.string().length() &lt; maximumURLLengthForLogging)
 180             return url.string();
 181         return url.string().substring(0, maximumURLLengthForLogging) + &quot;...&quot;;
 182 #else
 183         UNUSED_PARAM(url);
 184         return &quot;[url]&quot;;
 185 #endif
 186     }
 187 };
 188 }
 189 
 190 
 191 namespace WebCore {
 192 
 193 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLMediaElement);
 194 
 195 using namespace PAL;
 196 
 197 static const Seconds SeekRepeatDelay { 100_ms };
 198 static const double SeekTime = 0.2;
 199 static const Seconds ScanRepeatDelay { 1.5_s };
 200 static const double ScanMaximumRate = 8;
 201 static const double AutoplayInterferenceTimeThreshold = 10;
 202 static const Seconds hideMediaControlsAfterEndedDelay { 6_s };
 203 
 204 #ifndef LOG_CACHED_TIME_WARNINGS
 205 // Default to not logging warnings about excessive drift in the cached media time because it adds a
 206 // fair amount of overhead and logging.
 207 #define LOG_CACHED_TIME_WARNINGS 0
 208 #endif
 209 
 210 #if ENABLE(MEDIA_SOURCE)
 211 // URL protocol used to signal that the media source API is being used.
 212 static const char* mediaSourceBlobProtocol = &quot;blob&quot;;
 213 #endif
 214 
 215 #if ENABLE(MEDIA_STREAM)
 216 // URL protocol used to signal that the media stream API is being used.
 217 static const char* mediaStreamBlobProtocol = &quot;blob&quot;;
 218 #endif
 219 
 220 using namespace HTMLNames;
 221 
 222 String convertEnumerationToString(HTMLMediaElement::ReadyState enumerationValue)
 223 {
 224     static const NeverDestroyed&lt;String&gt; values[] = {
 225         MAKE_STATIC_STRING_IMPL(&quot;HAVE_NOTHING&quot;),
 226         MAKE_STATIC_STRING_IMPL(&quot;HAVE_METADATA&quot;),
 227         MAKE_STATIC_STRING_IMPL(&quot;HAVE_CURRENT_DATA&quot;),
 228         MAKE_STATIC_STRING_IMPL(&quot;HAVE_FUTURE_DATA&quot;),
 229         MAKE_STATIC_STRING_IMPL(&quot;HAVE_ENOUGH_DATA&quot;),
 230     };
 231     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_NOTHING) == 0, &quot;HTMLMediaElementEnums::HAVE_NOTHING is not 0 as expected&quot;);
 232     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_METADATA) == 1, &quot;HTMLMediaElementEnums::HAVE_METADATA is not 1 as expected&quot;);
 233     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_CURRENT_DATA) == 2, &quot;HTMLMediaElementEnums::HAVE_CURRENT_DATA is not 2 as expected&quot;);
 234     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_FUTURE_DATA) == 3, &quot;HTMLMediaElementEnums::HAVE_FUTURE_DATA is not 3 as expected&quot;);
 235     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_ENOUGH_DATA) == 4, &quot;HTMLMediaElementEnums::HAVE_ENOUGH_DATA is not 4 as expected&quot;);
 236     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 237     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 238 }
 239 
 240 String convertEnumerationToString(HTMLMediaElement::NetworkState enumerationValue)
 241 {
 242     static const NeverDestroyed&lt;String&gt; values[] = {
 243         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_EMPTY&quot;),
 244         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_IDLE&quot;),
 245         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_LOADING&quot;),
 246         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_NO_SOURCE&quot;),
 247     };
 248     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_EMPTY) == 0, &quot;HTMLMediaElementEnums::NETWORK_EMPTY is not 0 as expected&quot;);
 249     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_IDLE) == 1, &quot;HTMLMediaElementEnums::NETWORK_IDLE is not 1 as expected&quot;);
 250     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_LOADING) == 2, &quot;HTMLMediaElementEnums::NETWORK_LOADING is not 2 as expected&quot;);
 251     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_NO_SOURCE) == 3, &quot;HTMLMediaElementEnums::NETWORK_NO_SOURCE is not 3 as expected&quot;);
 252     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 253     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 254 }
 255 
 256 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState enumerationValue)
 257 {
 258     static const NeverDestroyed&lt;String&gt; values[] = {
 259         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
 260         MAKE_STATIC_STRING_IMPL(&quot;PreventedAutoplay&quot;),
 261         MAKE_STATIC_STRING_IMPL(&quot;StartedWithUserGesture&quot;),
 262         MAKE_STATIC_STRING_IMPL(&quot;StartedWithoutUserGesture&quot;),
 263     };
 264     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::None) == 0, &quot;AutoplayEventPlaybackState::None is not 0 as expected&quot;);
 265     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::PreventedAutoplay) == 1, &quot;AutoplayEventPlaybackState::PreventedAutoplay is not 1 as expected&quot;);
 266     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithUserGesture) == 2, &quot;AutoplayEventPlaybackState::StartedWithUserGesture is not 2 as expected&quot;);
 267     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
 268     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 269     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 270 }
 271 
 272 typedef HashMap&lt;Document*, HashSet&lt;HTMLMediaElement*&gt;&gt; DocumentElementSetMap;
 273 static DocumentElementSetMap&amp; documentToElementSetMap()
 274 {
 275     static NeverDestroyed&lt;DocumentElementSetMap&gt; map;
 276     return map;
 277 }
 278 
 279 static void addElementToDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)
 280 {
 281     DocumentElementSetMap&amp; map = documentToElementSetMap();
 282     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);
 283     set.add(&amp;element);
 284     map.add(&amp;document, set);
 285 }
 286 
 287 static void removeElementFromDocumentMap(HTMLMediaElement&amp; element, Document&amp; document)
 288 {
 289     DocumentElementSetMap&amp; map = documentToElementSetMap();
 290     HashSet&lt;HTMLMediaElement*&gt; set = map.take(&amp;document);
 291     set.remove(&amp;element);
 292     if (!set.isEmpty())
 293         map.add(&amp;document, set);
 294 }
 295 
 296 #if ENABLE(VIDEO_TRACK)
 297 
 298 class TrackDisplayUpdateScope {
 299 public:
 300     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 301         : m_element(element)
 302     {
 303         m_element.beginIgnoringTrackDisplayUpdateRequests();
 304     }
 305     ~TrackDisplayUpdateScope()
 306     {
 307         m_element.endIgnoringTrackDisplayUpdateRequests();
 308     }
 309 
 310 private:
 311     HTMLMediaElement&amp; m_element;
 312 };
 313 
<a name="8" id="anc8"></a>
 314 
 315 struct HTMLMediaElement::TrackGroup {
 316     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 317 
 318     TrackGroup(GroupKind kind)
 319         : kind(kind)
 320     {
 321     }
 322 
 323     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 324     RefPtr&lt;TextTrack&gt; visibleTrack;
 325     RefPtr&lt;TextTrack&gt; defaultTrack;
 326     GroupKind kind;
 327     bool hasSrcLang { false };
 328 };
<a name="9" id="anc9"></a><span class="line-removed"> 329 #endif</span>
 330 
 331 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 332 {
 333     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 334     return elements;
 335 }
 336 
 337 #if ENABLE(MEDIA_SESSION)
 338 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 339 
 340 static IDToElementMap&amp; elementIDsToElements()
 341 {
 342     static NeverDestroyed&lt;IDToElementMap&gt; map;
 343     return map;
 344 }
 345 
 346 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 347 {
 348     if (id == HTMLMediaElementInvalidID)
 349         return nullptr;
 350 
 351     return elementIDsToElements().get(id);
 352 }
 353 
 354 static uint64_t nextElementID()
 355 {
 356     static uint64_t elementID = 0;
 357     return ++elementID;
 358 }
 359 #endif
 360 
 361 struct MediaElementSessionInfo {
 362     const MediaElementSession* session;
 363     MediaElementSession::PlaybackControlsPurpose purpose;
 364 
 365     MonotonicTime timeOfLastUserInteraction;
 366     bool canShowControlsManager : 1;
 367     bool isVisibleInViewportOrFullscreen : 1;
 368     bool isLargeEnoughForMainContent : 1;
 369     bool isPlayingAudio : 1;
 370 };
 371 
 372 static MediaElementSessionInfo mediaElementSessionInfoForSession(const MediaElementSession&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 373 {
 374     const HTMLMediaElement&amp; element = session.element();
 375     return {
 376         &amp;session,
 377         purpose,
 378         session.mostRecentUserInteractionTime(),
 379         session.canShowControlsManager(purpose),
 380         element.isFullscreen() || element.isVisibleInViewport(),
 381         session.isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls),
 382         element.isPlaying() &amp;&amp; element.hasAudio() &amp;&amp; !element.muted()
 383     };
 384 }
 385 
 386 static bool preferMediaControlsForCandidateSessionOverOtherCandidateSession(const MediaElementSessionInfo&amp; session, const MediaElementSessionInfo&amp; otherSession)
 387 {
 388     MediaElementSession::PlaybackControlsPurpose purpose = session.purpose;
 389     ASSERT(purpose == otherSession.purpose);
 390 
 391     // For the controls manager, prioritize visible media over offscreen media.
 392     if (purpose == MediaElementSession::PlaybackControlsPurpose::ControlsManager &amp;&amp; session.isVisibleInViewportOrFullscreen != otherSession.isVisibleInViewportOrFullscreen)
 393         return session.isVisibleInViewportOrFullscreen;
 394 
 395     // For Now Playing, prioritize elements that would normally satisfy main content.
 396     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying &amp;&amp; session.isLargeEnoughForMainContent != otherSession.isLargeEnoughForMainContent)
 397         return session.isLargeEnoughForMainContent;
 398 
 399     // As a tiebreaker, prioritize elements that the user recently interacted with.
 400     return session.timeOfLastUserInteraction &gt; otherSession.timeOfLastUserInteraction;
 401 }
 402 
 403 static bool mediaSessionMayBeConfusedWithMainContent(const MediaElementSessionInfo&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 404 {
 405     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying)
 406         return session.isPlayingAudio;
 407 
 408     if (!session.isVisibleInViewportOrFullscreen)
 409         return false;
 410 
 411     if (!session.isLargeEnoughForMainContent)
 412         return false;
 413 
 414     // Even if this video is not a candidate, if it is visible to the user and large enough
 415     // to be main content, it poses a risk for being confused with main content.
 416     return true;
 417 }
 418 
<a name="10" id="anc10"></a><span class="line-removed"> 419 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed"> 420 static uint64_t nextLogIdentifier()</span>
<span class="line-removed"> 421 {</span>
<span class="line-removed"> 422     static uint64_t logIdentifier = cryptographicallyRandomNumber();</span>
<span class="line-removed"> 423     return ++logIdentifier;</span>
<span class="line-removed"> 424 }</span>
<span class="line-removed"> 425 #endif</span>
<span class="line-removed"> 426 </span>
 427 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 428     : HTMLElement(tagName, document)
 429     , ActiveDOMObject(document)
 430     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 431     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 432     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 433     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 434     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
 435     , m_asyncEventQueue(*this)
 436     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 437     , m_firstTimePlaying(true)
 438     , m_playing(false)
 439     , m_isWaitingUntilMediaCanStart(false)
 440     , m_shouldDelayLoadEvent(false)
 441     , m_haveFiredLoadedData(false)
 442     , m_inActiveDocument(true)
 443     , m_autoplaying(true)
 444     , m_muted(false)
 445     , m_explicitlyMuted(false)
 446     , m_initiallyMuted(false)
 447     , m_paused(true)
 448     , m_seeking(false)
 449     , m_seekRequested(false)
 450     , m_sentStalledEvent(false)
 451     , m_sentEndEvent(false)
 452     , m_pausedInternal(false)
 453     , m_closedCaptionsVisible(false)
 454     , m_webkitLegacyClosedCaptionOverride(false)
 455     , m_completelyLoaded(false)
 456     , m_havePreparedToPlay(false)
 457     , m_parsingInProgress(createdByParser)
<a name="11" id="anc11"></a><span class="line-removed"> 458     , m_shouldBufferData(true)</span>
 459     , m_elementIsHidden(document.hidden())
 460     , m_creatingControls(false)
 461     , m_receivedLayoutSizeChanged(false)
 462     , m_hasEverNotifiedAboutPlaying(false)
 463     , m_hasEverHadAudio(false)
 464     , m_hasEverHadVideo(false)
 465 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 466     , m_mediaControlsDependOnPageScaleFactor(false)
 467     , m_haveSetUpCaptionContainer(false)
 468 #endif
 469     , m_isScrubbingRemotely(false)
 470 #if ENABLE(VIDEO_TRACK)
 471     , m_tracksAreReady(true)
 472     , m_haveVisibleTextTrack(false)
 473     , m_processingPreferenceChange(false)
 474 #endif
 475 #if !RELEASE_LOG_DISABLED
 476     , m_logger(&amp;document.logger())
<a name="12" id="anc12"></a><span class="line-modified"> 477     , m_logIdentifier(nextLogIdentifier())</span>
 478 #endif
 479 {
 480     allMediaElements().add(this);
 481 
 482     ALWAYS_LOG(LOGIDENTIFIER);
 483 
 484     setHasCustomStyleResolveCallbacks();
 485 
 486     InspectorInstrumentation::addEventListenersToNode(*this);
 487 }
 488 
 489 void HTMLMediaElement::finishInitialization()
 490 {
<a name="13" id="anc13"></a><span class="line-modified"> 491     m_mediaSession = std::make_unique&lt;MediaElementSession&gt;(*this);</span>
 492 
 493     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 494     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
 495 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 496     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
 497 #endif
 498     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
 499     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
 500 
 501     auto&amp; document = this-&gt;document();
 502     auto* page = document.page();
 503 
 504     if (document.settings().invisibleAutoplayNotPermitted())
 505         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted);
 506 
 507     if (document.ownerElement() || !document.isMediaDocument()) {
 508         const auto&amp; topDocument = document.topDocument();
 509         const bool isProcessingUserGesture = processingUserGestureForMedia();
 510         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 511         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 512 
 513         if (shouldVideoPlaybackRequireUserGesture) {
 514             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
 515             if (document.settings().requiresUserGestureToLoadVideo())
 516                 m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForLoad);
 517         }
 518 
 519         if (page &amp;&amp; page-&gt;isLowPowerModeEnabled())
 520             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
 521 
 522         if (shouldAudioPlaybackRequireUserGesture)
 523             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
 524 
 525 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 526         if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
 527             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
 528 #endif
 529 
 530         if (!document.settings().mediaDataLoadsAutomatically())
 531             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
 532 
 533         if (document.settings().mainContentUserGestureOverrideEnabled())
 534             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
 535     }
 536 
 537 #if PLATFORM(IOS_FAMILY)
 538     if (!document.settings().videoPlaybackRequiresUserGesture() &amp;&amp; !document.settings().audioPlaybackRequiresUserGesture()) {
 539         // Relax RequireUserGestureForFullscreen when videoPlaybackRequiresUserGesture and audioPlaybackRequiresUserGesture is not set:
 540         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 541     }
 542 #endif
 543 
 544 #if ENABLE(MEDIA_SESSION)
 545     m_elementID = nextElementID();
 546     elementIDsToElements().add(m_elementID, this);
 547 
 548     setSessionInternal(document.defaultMediaSession());
 549 #endif
 550 
 551     registerWithDocument(document);
 552 
 553 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 554     AudioSession::sharedSession().addMutedStateObserver(this);
 555 #endif
 556 
 557     mediaSession().clientWillBeginAutoplaying();
 558 }
 559 
 560 // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.
 561 static unsigned s_destructorCount = 0;
 562 
 563 bool HTMLMediaElement::isRunningDestructor()
 564 {
 565     return !!s_destructorCount;
 566 }
 567 
 568 class HTMLMediaElementDestructorScope {
 569 public:
 570     HTMLMediaElementDestructorScope() { ++s_destructorCount; }
 571     ~HTMLMediaElementDestructorScope() { --s_destructorCount; }
 572 };
 573 
 574 HTMLMediaElement::~HTMLMediaElement()
 575 {
 576     HTMLMediaElementDestructorScope destructorScope;
 577     ALWAYS_LOG(LOGIDENTIFIER);
 578 
 579     beginIgnoringTrackDisplayUpdateRequests();
 580     allMediaElements().remove(this);
 581 
 582     m_asyncEventQueue.close();
 583 
 584     setShouldDelayLoadEvent(false);
 585     unregisterWithDocument(document());
 586 
 587 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 588     AudioSession::sharedSession().removeMutedStateObserver(this);
 589 #endif
 590 
 591 #if ENABLE(VIDEO_TRACK)
 592     if (m_audioTracks)
 593         m_audioTracks-&gt;clearElement();
 594     if (m_textTracks)
 595         m_textTracks-&gt;clearElement();
 596     if (m_videoTracks)
 597         m_videoTracks-&gt;clearElement();
 598 #endif
 599 
 600 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 601     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
 602         m_hasPlaybackTargetAvailabilityListeners = false;
 603         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
 604         updateMediaState();
 605     }
 606 #endif
 607 
 608     if (m_mediaController) {
 609         m_mediaController-&gt;removeMediaElement(*this);
 610         m_mediaController = nullptr;
 611     }
 612 
 613 #if ENABLE(MEDIA_SOURCE)
 614     detachMediaSource();
 615 #endif
 616 
 617 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 618     webkitSetMediaKeys(nullptr);
 619 #endif
 620 
 621 #if ENABLE(ENCRYPTED_MEDIA)
 622     if (m_mediaKeys) {
 623         m_mediaKeys-&gt;detachCDMClient(*this);
 624         if (m_player)
 625             m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
 626     }
 627 #endif
 628 
 629 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 630     if (m_isolatedWorld)
 631         m_isolatedWorld-&gt;clearWrappers();
 632 #endif
 633 
 634 #if ENABLE(MEDIA_SESSION)
 635     if (m_session) {
 636         m_session-&gt;removeMediaElement(*this);
 637         m_session = nullptr;
 638     }
 639 
 640     elementIDsToElements().remove(m_elementID);
 641 #endif
 642 
 643     m_seekTaskQueue.close();
 644     m_resumeTaskQueue.close();
 645     m_promiseTaskQueue.close();
 646     m_pauseAfterDetachedTaskQueue.close();
 647     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
 648     m_resourceSelectionTaskQueue.close();
 649     m_visibilityChangeTaskQueue.close();
 650 #if ENABLE(ENCRYPTED_MEDIA)
 651     m_encryptedMediaQueue.close();
 652 #endif
 653 
 654     m_completelyLoaded = true;
 655 
 656     if (m_player) {
 657         m_player-&gt;invalidate();
 658         m_player = nullptr;
 659     }
 660 
 661     m_mediaSession = nullptr;
 662     schedulePlaybackControlsManagerUpdate();
 663 }
<a name="14" id="anc14"></a><span class="line-removed"> 664 </span>
<span class="line-removed"> 665 static bool needsAutoplayPlayPauseEventsQuirk(const Document&amp; document)</span>
<span class="line-removed"> 666 {</span>
<span class="line-removed"> 667     auto* page = document.page();</span>
<span class="line-removed"> 668     if (!page || !page-&gt;settings().needsSiteSpecificQuirks())</span>
<span class="line-removed"> 669         return false;</span>
<span class="line-removed"> 670 </span>
<span class="line-removed"> 671     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed"> 672     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::SynthesizedPauseEvents);</span>
<span class="line-removed"> 673 }</span>
<span class="line-removed"> 674 </span>
 675 RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
 676 {
<a name="15" id="anc15"></a><span class="line-removed"> 677     auto allSessions = PlatformMediaSessionManager::sharedManager().currentSessionsMatching([] (const PlatformMediaSession&amp; session) {</span>
<span class="line-removed"> 678         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-removed"> 679     });</span>
<span class="line-removed"> 680 </span>
 681     Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
 682     bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<a name="16" id="anc16"></a><span class="line-modified"> 683     for (auto&amp; session : allSessions) {</span>
<span class="line-modified"> 684         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(*session), purpose);</span>


 685         if (mediaElementSessionInfo.canShowControlsManager)
 686             candidateSessions.append(mediaElementSessionInfo);
 687         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 688             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<a name="17" id="anc17"></a><span class="line-modified"> 689     }</span>
 690 
 691     if (!candidateSessions.size())
 692         return nullptr;
 693 
 694     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 695     auto strongestSessionCandidate = candidateSessions.first();
 696     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 697         return nullptr;
 698 
 699     return &amp;strongestSessionCandidate.session-&gt;element();
 700 }
 701 
 702 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 703 {
 704     m_mediaSession-&gt;registerWithDocument(document);
 705 
 706     if (m_isWaitingUntilMediaCanStart)
 707         document.addMediaCanStartListener(*this);
 708 
 709 #if !PLATFORM(IOS_FAMILY)
 710     document.registerForMediaVolumeCallbacks(*this);
 711     document.registerForPrivateBrowsingStateChangedCallbacks(*this);
 712 #endif
 713 
 714     document.registerForVisibilityStateChangedCallbacks(*this);
 715 
 716 #if ENABLE(VIDEO_TRACK)
 717     if (m_requireCaptionPreferencesChangedCallbacks)
 718         document.registerForCaptionPreferencesChangedCallbacks(*this);
 719 #endif
 720 
 721 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 722     if (m_mediaControlsDependOnPageScaleFactor)
 723         document.registerForPageScaleFactorChangedCallbacks(*this);
 724     document.registerForUserInterfaceLayoutDirectionChangedCallbacks(*this);
 725 #endif
 726 
 727 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 728     document.registerForDocumentSuspensionCallbacks(*this);
 729 #endif
 730 
 731     document.registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);
 732 
 733     document.addAudioProducer(*this);
 734     addElementToDocumentMap(*this, document);
 735 
 736 #if ENABLE(MEDIA_STREAM)
 737     document.registerForMediaStreamStateChangeCallbacks(*this);
 738 #endif
 739 
 740     document.addApplicationStateChangeListener(*this);
 741 }
 742 
 743 void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
 744 {
 745     m_mediaSession-&gt;unregisterWithDocument(document);
 746 
 747     if (m_isWaitingUntilMediaCanStart)
 748         document.removeMediaCanStartListener(*this);
 749 
 750 #if !PLATFORM(IOS_FAMILY)
 751     document.unregisterForMediaVolumeCallbacks(*this);
 752     document.unregisterForPrivateBrowsingStateChangedCallbacks(*this);
 753 #endif
 754 
 755     document.unregisterForVisibilityStateChangedCallbacks(*this);
 756 
 757 #if ENABLE(VIDEO_TRACK)
 758     if (m_requireCaptionPreferencesChangedCallbacks)
 759         document.unregisterForCaptionPreferencesChangedCallbacks(*this);
 760 #endif
 761 
 762 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 763     if (m_mediaControlsDependOnPageScaleFactor)
 764         document.unregisterForPageScaleFactorChangedCallbacks(*this);
 765     document.unregisterForUserInterfaceLayoutDirectionChangedCallbacks(*this);
 766 #endif
 767 
 768 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 769     document.unregisterForDocumentSuspensionCallbacks(*this);
 770 #endif
 771 
 772     document.unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(*this);
 773 
 774     document.removeAudioProducer(*this);
 775     removeElementFromDocumentMap(*this, document);
 776 
 777 #if ENABLE(MEDIA_STREAM)
 778     document.unregisterForMediaStreamStateChangeCallbacks(*this);
 779 #endif
 780 
 781     document.removeApplicationStateChangeListener(*this);
 782 }
 783 
 784 void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 785 {
 786     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
 787     if (m_shouldDelayLoadEvent) {
 788         oldDocument.decrementLoadEventDelayCount();
 789         newDocument.incrementLoadEventDelayCount();
 790     }
 791 
 792     unregisterWithDocument(oldDocument);
 793     registerWithDocument(newDocument);
 794 
 795     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
 796     updateShouldAutoplay();
 797 }
 798 
 799 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 800 void HTMLMediaElement::prepareForDocumentSuspension()
 801 {
 802     m_mediaSession-&gt;unregisterWithDocument(document());
 803 }
 804 
 805 void HTMLMediaElement::resumeFromDocumentSuspension()
 806 {
 807     m_mediaSession-&gt;registerWithDocument(document());
 808     updateShouldAutoplay();
 809 }
 810 #endif
 811 
 812 bool HTMLMediaElement::supportsFocus() const
 813 {
 814     if (document().isMediaDocument())
 815         return false;
 816 
 817     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 818     return controls() ||  HTMLElement::supportsFocus();
 819 }
 820 
 821 bool HTMLMediaElement::isMouseFocusable() const
 822 {
 823     return false;
 824 }
 825 
<a name="18" id="anc18"></a><span class="line-modified"> 826 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>





 827 {
 828     if (name == srcAttr) {
 829         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 830         // Location of the Media Resource
 831         // 12 February 2017
 832 
 833         // If a src attribute of a media element is set or changed, the user
 834         // agent must invoke the media element&#39;s media element load algorithm.
 835         if (!value.isNull())
 836             prepareForLoad();
 837     } else if (name == controlsAttr)
 838         configureMediaControls();
 839     else if (name == loopAttr)
 840         updateSleepDisabling();
 841     else if (name == preloadAttr) {
 842         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
 843             m_preload = MediaPlayer::None;
 844         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
 845             m_preload = MediaPlayer::MetaData;
 846         else {
 847             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 848             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
 849             m_preload = MediaPlayer::Auto;
 850         }
 851 
 852         // The attribute must be ignored if the autoplay attribute is present
 853         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 854             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 855 
 856     } else if (name == mediagroupAttr)
 857         setMediaGroup(value);
 858     else if (name == autoplayAttr) {
 859         if (processingUserGestureForMedia())
<a name="19" id="anc19"></a><span class="line-modified"> 860             removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
 861     } else if (name == titleAttr) {
 862         if (m_mediaSession)
 863             m_mediaSession-&gt;clientCharacteristicsChanged();
 864     }
 865     else
 866         HTMLElement::parseAttribute(name, value);
 867 }
 868 
 869 void HTMLMediaElement::finishParsingChildren()
 870 {
 871     HTMLElement::finishParsingChildren();
 872     m_parsingInProgress = false;
 873 
 874 #if ENABLE(VIDEO_TRACK)
 875     if (childrenOfType&lt;HTMLTrackElement&gt;(*this).first())
 876         scheduleConfigureTextTracks();
 877 #endif
 878 }
 879 
 880 bool HTMLMediaElement::rendererIsNeeded(const RenderStyle&amp; style)
 881 {
 882     return controls() &amp;&amp; HTMLElement::rendererIsNeeded(style);
 883 }
 884 
 885 RenderPtr&lt;RenderElement&gt; HTMLMediaElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 886 {
 887     return createRenderer&lt;RenderMedia&gt;(*this, WTFMove(style));
 888 }
 889 
 890 bool HTMLMediaElement::childShouldCreateRenderer(const Node&amp; child) const
 891 {
 892 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 893     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 894 #else
 895     if (!hasMediaControls())
 896         return false;
 897     // &lt;media&gt; doesn&#39;t allow its content, including shadow subtree, to
 898     // be rendered. So this should return false for most of the children.
 899     // One exception is a shadow tree built for rendering controls which should be visible.
 900     // So we let them go here by comparing its subtree root with one of the controls.
 901     return &amp;mediaControls()-&gt;treeScope() == &amp;child.treeScope()
 902         &amp;&amp; hasShadowRootParent(child)
 903         &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 904 #endif
 905 }
 906 
 907 Node::InsertedIntoAncestorResult HTMLMediaElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 908 {
 909     INFO_LOG(LOGIDENTIFIER);
 910 
 911     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 912     if (insertionType.connectedToDocument)
 913         setInActiveDocument(true);
 914 
 915     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 916 }
 917 
 918 void HTMLMediaElement::didFinishInsertingNode()
 919 {
 920     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
 921 
 922     INFO_LOG(LOGIDENTIFIER);
 923 
 924     if (m_inActiveDocument &amp;&amp; m_networkState == NETWORK_EMPTY &amp;&amp; !attributeWithoutSynchronization(srcAttr).isEmpty())
 925         prepareForLoad();
 926 
 927     if (!m_explicitlyMuted) {
 928         m_explicitlyMuted = true;
 929         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
 930         m_mediaSession-&gt;canProduceAudioChanged();
 931     }
 932 
 933     configureMediaControls();
 934 }
 935 
 936 void HTMLMediaElement::pauseAfterDetachedTask()
 937 {
 938     // If we were re-inserted into an active document, no need to pause.
 939     if (m_inActiveDocument)
 940         return;
 941 
 942     if (hasMediaControls())
 943         mediaControls()-&gt;hide();
 944     if (m_networkState &gt; NETWORK_EMPTY)
 945         pause();
 946     if (m_videoFullscreenMode != VideoFullscreenModeNone)
 947         exitFullscreen();
 948 
 949     if (!m_player)
 950         return;
 951 
 952     size_t extraMemoryCost = m_player-&gt;extraMemoryCost();
 953     if (extraMemoryCost &gt; m_reportedExtraMemoryCost) {
 954         JSC::VM&amp; vm = commonVM();
 955         JSC::JSLockHolder lock(vm);
 956 
 957         size_t extraMemoryCostDelta = extraMemoryCost - m_reportedExtraMemoryCost;
 958         m_reportedExtraMemoryCost = extraMemoryCost;
 959         // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
 960         // https://bugs.webkit.org/show_bug.cgi?id=142595
 961         vm.heap.deprecatedReportExtraMemory(extraMemoryCostDelta);
 962     }
 963 }
 964 
 965 void HTMLMediaElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 966 {
 967     INFO_LOG(LOGIDENTIFIER);
 968 
 969     setInActiveDocument(false);
 970     if (removalType.disconnectedFromDocument) {
 971         // Pause asynchronously to let the operation that removed us finish, in case we get inserted back into a document.
 972         m_pauseAfterDetachedTaskQueue.enqueueTask(std::bind(&amp;HTMLMediaElement::pauseAfterDetachedTask, this));
 973     }
 974 
 975     if (m_mediaSession)
 976         m_mediaSession-&gt;clientCharacteristicsChanged();
 977 
 978     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 979 }
 980 
 981 void HTMLMediaElement::willAttachRenderers()
 982 {
 983     ASSERT(!renderer());
 984 }
 985 
 986 inline void HTMLMediaElement::updateRenderer()
 987 {
 988     if (auto* renderer = this-&gt;renderer())
 989         renderer-&gt;updateFromElement();
 990 }
 991 
 992 void HTMLMediaElement::didAttachRenderers()
 993 {
 994     if (auto* renderer = this-&gt;renderer()) {
 995         renderer-&gt;updateFromElement();
 996         if (m_mediaSession &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay())
 997             renderer-&gt;registerForVisibleInViewportCallback();
 998     }
 999     updateShouldAutoplay();
1000 }
1001 
1002 void HTMLMediaElement::willDetachRenderers()
1003 {
1004     if (auto* renderer = this-&gt;renderer())
1005         renderer-&gt;unregisterForVisibleInViewportCallback();
1006 }
1007 
1008 void HTMLMediaElement::didDetachRenderers()
1009 {
1010     updateShouldAutoplay();
1011 }
1012 
1013 void HTMLMediaElement::didRecalcStyle(Style::Change)
1014 {
1015     updateRenderer();
1016 }
1017 
1018 void HTMLMediaElement::scheduleNextSourceChild()
1019 {
1020     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
1021     m_resourceSelectionTaskQueue.enqueueTask([this] {
1022         loadNextSourceChild();
1023     });
1024 }
1025 
1026 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)
1027 {
1028     m_hasEverHadAudio |= hasAudio();
1029     m_hasEverHadVideo |= hasVideo();
1030 }
1031 
<a name="20" id="anc20"></a><span class="line-modified">1032 void HTMLMediaElement::scheduleEvent(const AtomicString&amp; eventName)</span>
1033 {
1034     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
1035 
1036     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
1037     // will trigger an ASSERT if this element has been marked for deletion.
1038 
1039     m_asyncEventQueue.enqueueEvent(WTFMove(event));
1040 }
1041 
1042 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
1043 {
1044     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1045         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1046     });
1047 }
1048 
1049 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
1050 {
1051     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1052         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
1053     });
1054 }
1055 
1056 void HTMLMediaElement::rejectPendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises, Ref&lt;DOMException&gt;&amp;&amp; error)
1057 {
1058     for (auto&amp; promise : pendingPlayPromises)
1059         promise.rejectType&lt;IDLInterface&lt;DOMException&gt;&gt;(error);
1060 }
1061 
1062 void HTMLMediaElement::resolvePendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises)
1063 {
1064     for (auto&amp; promise : pendingPlayPromises)
1065         promise.resolve();
1066 }
1067 
1068 void HTMLMediaElement::scheduleNotifyAboutPlaying()
1069 {
1070     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1071         notifyAboutPlaying(WTFMove(pendingPlayPromises));
1072     });
1073 }
1074 
1075 void HTMLMediaElement::notifyAboutPlaying(PlayPromiseVector&amp;&amp; pendingPlayPromises)
1076 {
1077     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // The &#39;playing&#39; event can make arbitrary DOM mutations.
1078     m_playbackStartedTime = currentMediaTime().toDouble();
1079     m_hasEverNotifiedAboutPlaying = true;
1080     dispatchEvent(Event::create(eventNames().playingEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
1081     resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1082 
1083     schedulePlaybackControlsManagerUpdate();
1084 }
1085 
1086 bool HTMLMediaElement::hasEverNotifiedAboutPlaying() const
1087 {
1088     return m_hasEverNotifiedAboutPlaying;
1089 }
1090 
1091 void HTMLMediaElement::scheduleCheckPlaybackTargetCompatability()
1092 {
1093     if (m_checkPlaybackTargetCompatablityTask.hasPendingTask())
1094         return;
1095 
1096     auto logSiteIdentifier = LOGIDENTIFIER;
1097     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1098     m_checkPlaybackTargetCompatablityTask.scheduleTask([this, logSiteIdentifier] {
1099         UNUSED_PARAM(logSiteIdentifier);
1100         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1101         checkPlaybackTargetCompatablity();
1102     });
1103 }
1104 
1105 void HTMLMediaElement::checkPlaybackTargetCompatablity()
1106 {
1107 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="21" id="anc21"></a>

1108     if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<a name="22" id="anc22"></a><span class="line-modified">1109         INFO_LOG(LOGIDENTIFIER, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>

1110         m_failedToPlayToWirelessTarget = true;
1111         m_player-&gt;setShouldPlayToPlaybackTarget(false);
1112     }
1113 #endif
1114 }
1115 
1116 MediaError* HTMLMediaElement::error() const
1117 {
1118     return m_error.get();
1119 }
1120 
1121 void HTMLMediaElement::setSrcObject(MediaProvider&amp;&amp; mediaProvider)
1122 {
1123     // FIXME: Setting the srcObject attribute may cause other changes to the media element&#39;s internal state:
1124     // Specifically, if srcObject is specified, the UA must use it as the source of media, even if the src
1125     // attribute is also set or children are present. If the value of srcObject is replaced or set to null
1126     // the UA must re-run the media element load algorithm.
1127     //
1128     // https://bugs.webkit.org/show_bug.cgi?id=124896
1129 
1130 
1131     // https://www.w3.org/TR/html51/semantics-embedded-content.html#dom-htmlmediaelement-srcobject
1132     // 4.7.14.2. Location of the media resource
1133     // srcObject: On setting, it must set the element’s assigned media provider object to the new
1134     // value, and then invoke the element’s media element load algorithm.
1135     INFO_LOG(LOGIDENTIFIER);
1136     m_mediaProvider = WTFMove(mediaProvider);
1137     prepareForLoad();
1138 }
1139 
<a name="23" id="anc23"></a><span class="line-modified">1140 void HTMLMediaElement::setCrossOrigin(const AtomicString&amp; value)</span>
1141 {
1142     setAttributeWithoutSynchronization(crossoriginAttr, value);
1143 }
1144 
1145 String HTMLMediaElement::crossOrigin() const
1146 {
1147     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1148 }
1149 
1150 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1151 {
1152     return m_networkState;
1153 }
1154 
1155 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1156 {
1157     MediaEngineSupportParameters parameters;
1158     ContentType contentType(mimeType);
1159     parameters.type = contentType;
1160     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1161     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1162     String canPlay;
1163 
1164     // 4.8.10.3
1165     switch (support)
1166     {
1167         case MediaPlayer::IsNotSupported:
1168             canPlay = emptyString();
1169             break;
1170         case MediaPlayer::MayBeSupported:
1171             canPlay = &quot;maybe&quot;_s;
1172             break;
1173         case MediaPlayer::IsSupported:
1174             canPlay = &quot;probably&quot;_s;
1175             break;
1176     }
1177 
<a name="24" id="anc24"></a><span class="line-modified">1178     DEBUG_LOG(LOGIDENTIFIER, &quot;[&quot;, mimeType, &quot;] -&gt; &quot;, canPlay);</span>
1179 
1180     return canPlay;
1181 }
1182 
1183 double HTMLMediaElement::getStartDate() const
1184 {
1185     if (!m_player)
1186         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1187     return m_player-&gt;getStartDate().toDouble();
1188 }
1189 
1190 void HTMLMediaElement::load()
1191 {
1192     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1193 
1194     INFO_LOG(LOGIDENTIFIER);
1195 
<a name="25" id="anc25"></a><span class="line-removed">1196     if (processingUserGestureForMedia())</span>
<span class="line-removed">1197         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
<span class="line-removed">1198 </span>
1199     prepareForLoad();
1200     m_resourceSelectionTaskQueue.enqueueTask([this] {
1201         prepareToPlay();
1202     });
1203 }
1204 
1205 void HTMLMediaElement::prepareForLoad()
1206 {
1207     // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
1208     // The Media Element Load Algorithm
1209     // 12 February 2017
1210 
<a name="26" id="anc26"></a><span class="line-modified">1211     INFO_LOG(LOGIDENTIFIER);</span>



1212 
1213     // 1 - Abort any already-running instance of the resource selection algorithm for this element.
1214     // Perform the cleanup required for the resource load algorithm to run.
1215     stopPeriodicTimers();
1216     m_resourceSelectionTaskQueue.cancelAllTasks();
1217     // FIXME: Figure out appropriate place to reset LoadTextTrackResource if necessary and set m_pendingActionFlags to 0 here.
1218     m_sentEndEvent = false;
1219     m_sentStalledEvent = false;
1220     m_haveFiredLoadedData = false;
1221     m_completelyLoaded = false;
1222     m_havePreparedToPlay = false;
1223     m_displayMode = Unknown;
1224     m_currentSrc = URL();
1225 
1226 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1227     m_failedToPlayToWirelessTarget = false;
1228 #endif
1229 
1230     m_loadState = WaitingForSource;
1231     m_currentSourceNode = nullptr;
1232 
1233     if (!document().hasBrowsingContext())
1234         return;
1235 
1236     createMediaPlayer();
1237 
1238     // 2 - Let pending tasks be a list of all tasks from the media element&#39;s media element event task source in one of the task queues.
1239     // 3 - For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
1240     // 4 - Remove each task in pending tasks from its task queue
1241     cancelPendingEventsAndCallbacks();
1242 
1243     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1244     // a task to fire a simple event named abort at the media element.
1245     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1246         scheduleEvent(eventNames().abortEvent);
1247 
1248     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1249     if (m_networkState != NETWORK_EMPTY) {
1250         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1251         scheduleEvent(eventNames().emptiedEvent);
1252 
1253         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1254         m_networkState = NETWORK_EMPTY;
1255 
1256         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1257 #if ENABLE(MEDIA_SOURCE)
1258         detachMediaSource();
1259 #endif
1260 
<a name="27" id="anc27"></a><span class="line-removed">1261 #if ENABLE(VIDEO_TRACK)</span>
1262         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1263         forgetResourceSpecificTracks();
<a name="28" id="anc28"></a><span class="line-removed">1264 #endif</span>
1265 
1266         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1267         m_readyState = HAVE_NOTHING;
1268         m_readyStateMaximum = HAVE_NOTHING;
1269 
1270         // 6.6 - If the paused attribute is false, then set it to true.
1271         m_paused = true;
1272 
1273         // 6.7 - If seeking is true, set it to false.
1274         clearSeeking();
1275 
1276         // 6.8 - Set the current playback position to 0.
1277         //       Set the official playback position to 0.
1278         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1279         m_lastSeekTime = MediaTime::zeroTime();
1280         m_playedTimeRanges = TimeRanges::create();
1281         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1282 
1283         // 4.9 - Set the initial playback position to 0.
1284         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
1285         // above.
1286         refreshCachedTime();
1287 
1288         invalidateCachedTime();
1289 
1290         // 4.10 - Set the timeline offset to Not-a-Number (NaN).
1291         // 4.11 - Update the duration attribute to Not-a-Number (NaN).
1292 
1293         updateMediaController();
1294 #if ENABLE(VIDEO_TRACK)
1295         updateActiveTextTrackCues(MediaTime::zeroTime());
1296 #endif
1297     }
1298 
1299     // 7 - Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.
1300     setPlaybackRate(defaultPlaybackRate());
1301 
1302     // 8 - Set the error attribute to null and the autoplaying flag to true.
1303     m_error = nullptr;
1304     m_autoplaying = true;
1305     mediaSession().clientWillBeginAutoplaying();
1306 
1307     if (!MediaPlayer::isAvailable())
1308         noneSupported();
1309     else {
1310         // 9 - Invoke the media element&#39;s resource selection algorithm.
1311         // Note, unless the restriction on requiring user action has been removed,
1312         // do not begin downloading data.
1313         if (m_mediaSession-&gt;dataLoadingPermitted())
1314             selectMediaResource();
1315     }
1316 
1317     // 10 - Note: Playback of any previously playing media resource for this element stops.
1318 
1319     configureMediaControls();
1320 }
1321 
1322 void HTMLMediaElement::selectMediaResource()
1323 {
1324     // https://www.w3.org/TR/2016/REC-html51-20161101/semantics-embedded-content.html#resource-selection-algorithm
1325     // The Resource Selection Algorithm
1326 
1327     // 1. Set the element’s networkState attribute to the NETWORK_NO_SOURCE value.
1328     m_networkState = NETWORK_NO_SOURCE;
1329 
1330     // 2. Set the element’s show poster flag to true.
1331     setDisplayMode(Poster);
1332 
1333     // 3. Set the media element’s delaying-the-load-event flag to true (this delays the load event).
1334     setShouldDelayLoadEvent(true);
1335 
1336     // 4. in parallel await a stable state, allowing the task that invoked this algorithm to continue.
1337     if (m_resourceSelectionTaskQueue.hasPendingTasks())
1338         return;
1339 
1340     if (!m_mediaSession-&gt;pageAllowsDataLoading()) {
1341         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to load in background, waiting&quot;);
1342         setShouldDelayLoadEvent(false);
1343         if (m_isWaitingUntilMediaCanStart)
1344             return;
1345         m_isWaitingUntilMediaCanStart = true;
1346         document().addMediaCanStartListener(*this);
1347         return;
1348     }
1349 
1350     // Once the page has allowed an element to load media, it is free to load at will. This allows a
1351     // playlist that starts in a foreground tab to continue automatically if the tab is subsequently
1352     // put into the background.
1353     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
1354 
1355     auto logSiteIdentifier = LOGIDENTIFIER;
1356     UNUSED_PARAM(logSiteIdentifier);
1357 
1358     m_resourceSelectionTaskQueue.enqueueTask([this, logSiteIdentifier]  {
1359 
1360         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1361 
1362         // 5. If the media element’s blocked-on-parser flag is false, then populate the list of pending text tracks.
1363 #if ENABLE(VIDEO_TRACK)
1364         if (hasMediaControls())
1365             mediaControls()-&gt;changedClosedCaptionsVisibility();
1366 
1367         // HTMLMediaElement::textTracksAreReady will need &quot;... the text tracks whose mode was not in the
1368         // disabled state when the element&#39;s resource selection algorithm last started&quot;.
1369         // FIXME: Update this to match &quot;populate the list of pending text tracks&quot; step.
1370         m_textTracksWhenResourceSelectionBegan.clear();
1371         if (m_textTracks) {
1372             for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
1373                 RefPtr&lt;TextTrack&gt; track = m_textTracks-&gt;item(i);
1374                 if (track-&gt;mode() != TextTrack::Mode::Disabled)
1375                     m_textTracksWhenResourceSelectionBegan.append(track);
1376             }
1377         }
1378 #endif
1379 
1380         enum Mode { None, Object, Attribute, Children };
1381         Mode mode = None;
1382 
1383         if (m_mediaProvider) {
1384             // 6. If the media element has an assigned media provider object, then let mode be object.
1385             mode = Object;
1386         } else if (hasAttributeWithoutSynchronization(srcAttr)) {
1387             //    Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.
1388             mode = Attribute;
1389             ASSERT(m_player);
1390             if (!m_player) {
1391                 ERROR_LOG(logSiteIdentifier, &quot; has srcAttr but m_player is not created&quot;);
1392                 return;
1393             }
1394         } else if (auto firstSource = childrenOfType&lt;HTMLSourceElement&gt;(*this).first()) {
1395             //    Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute,
1396             //    but does have a source element child, then let mode be children and let candidate be the first such source element
1397             //    child in tree order.
1398             mode = Children;
1399             m_nextChildNodeToConsider = firstSource;
1400             m_currentSourceNode = nullptr;
1401         } else {
1402             //  Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source
1403             //  element child: set the networkState to NETWORK_EMPTY, and abort these steps; the synchronous section ends.
1404             m_loadState = WaitingForSource;
1405             setShouldDelayLoadEvent(false);
1406             m_networkState = NETWORK_EMPTY;
1407 
1408             ALWAYS_LOG(logSiteIdentifier, &quot;nothing to load&quot;);
1409             return;
1410         }
1411 
1412         // 7. Set the media element’s networkState to NETWORK_LOADING.
1413         m_networkState = NETWORK_LOADING;
1414 
1415         // 8. Queue a task to fire a simple event named loadstart at the media element.
1416         scheduleEvent(eventNames().loadstartEvent);
1417 
1418         // 9. Run the appropriate steps from the following list:
1419         // ↳ If mode is object
1420         if (mode == Object) {
1421             // 1. Set the currentSrc attribute to the empty string.
1422             m_currentSrc = URL();
1423 
1424             // 2. End the synchronous section, continuing the remaining steps in parallel.
1425             // 3. Run the resource fetch algorithm with the assigned media provider object.
1426             switchOn(m_mediaProvider.value(),
1427 #if ENABLE(MEDIA_STREAM)
1428                 [this](RefPtr&lt;MediaStream&gt; stream) { m_mediaStreamSrcObject = stream; },
1429 #endif
1430 #if ENABLE(MEDIA_SOURCE)
1431                 [this](RefPtr&lt;MediaSource&gt; source) { m_mediaSource = source; },
1432 #endif
1433                 [this](RefPtr&lt;Blob&gt; blob) { m_blob = blob; }
1434             );
1435 
1436             ContentType contentType;
1437             loadResource(URL(), contentType, String());
1438             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;srcObject&#39; property&quot;);
1439 
1440             //    If that algorithm returns without aborting this one, then the load failed.
1441             // 4. Failed with media provider: Reaching this step indicates that the media resource
1442             //    failed to load. Queue a task to run the dedicated media source failure steps.
1443             // 5. Wait for the task queued by the previous step to have executed.
1444             // 6. Abort these steps. The element won’t attempt to load another resource until this
1445             //    algorithm is triggered again.
1446             return;
1447         }
1448 
1449         // ↳ If mode is attribute
1450         if (mode == Attribute) {
1451             m_loadState = LoadingFromSrcAttr;
1452 
1453             // 1. If the src attribute’s value is the empty string, then end the synchronous section,
1454             //    and jump down to the failed with attribute step below.
1455             // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
1456             //    specified by the src attribute’s value relative to the media element when the src
1457             //    attribute was last changed.
1458             URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
1459             if (absoluteURL.isEmpty()) {
1460                 mediaLoadingFailed(MediaPlayer::FormatError);
1461                 ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
1462                 return;
1463             }
1464 
1465             if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
1466                 mediaLoadingFailed(MediaPlayer::FormatError);
1467                 return;
1468             }
1469 
1470             // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
1471             m_currentSrc = absoluteURL;
1472 
1473             // 4. End the synchronous section, continuing the remaining steps in parallel.
1474             // 5. If absolute URL was obtained successfully, run the resource fetch algorithm with absolute
1475             //    URL. If that algorithm returns without aborting this one, then the load failed.
1476 
1477             // No type or key system information is available when the url comes
1478             // from the &#39;src&#39; attribute so MediaPlayer
1479             // will have to pick a media engine based on the file extension.
1480             ContentType contentType;
1481             loadResource(absoluteURL, contentType, String());
1482             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;src&#39; attribute url&quot;);
1483 
1484             // 6. Failed with attribute: Reaching this step indicates that the media resource failed to load
1485             //    or that the given URL could not be resolved. Queue a task to run the dedicated media source failure steps.
1486             // 7. Wait for the task queued by the previous step to have executed.
1487             // 8. Abort these steps. The element won’t attempt to load another resource until this algorithm is triggered again.
1488             return;
1489         }
1490 
1491         // ↳ Otherwise (mode is children)
1492         // (Ctd. in loadNextSourceChild())
1493         loadNextSourceChild();
1494     });
1495 }
1496 
1497 void HTMLMediaElement::loadNextSourceChild()
1498 {
1499     ContentType contentType;
1500     String keySystem;
1501     URL mediaURL = selectNextSourceChild(&amp;contentType, &amp;keySystem, Complain);
1502     if (!mediaURL.isValid()) {
1503         waitForSourceChange();
1504         return;
1505     }
1506 
1507     // Recreate the media player for the new url
1508     createMediaPlayer();
1509 
1510     m_loadState = LoadingFromSourceElement;
1511     loadResource(mediaURL, contentType, keySystem);
1512 }
1513 
1514 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1515 {
1516     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1517 
<a name="29" id="anc29"></a><span class="line-modified">1518     INFO_LOG(LOGIDENTIFIER, initialURL, contentType.raw(), keySystem);</span>
1519 
1520     RefPtr&lt;Frame&gt; frame = document().frame();
1521     if (!frame) {
1522         mediaLoadingFailed(MediaPlayer::FormatError);
1523         return;
1524     }
1525 
1526     Page* page = frame-&gt;page();
1527     if (!page) {
1528         mediaLoadingFailed(MediaPlayer::FormatError);
1529         return;
1530     }
1531 
1532     URL url = initialURL;
1533     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
1534         mediaLoadingFailed(MediaPlayer::FormatError);
1535         return;
1536     }
1537 
1538 #if ENABLE(CONTENT_EXTENSIONS)
1539     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<a name="30" id="anc30"></a><span class="line-modified">1540         if (page-&gt;userContentProvider().processContentExtensionRulesForLoad(url, ResourceType::Media, *documentLoader).blockedLoad) {</span>
1541             mediaLoadingFailed(MediaPlayer::FormatError);
1542             return;
1543         }
1544     }
1545 #endif
1546 
1547     // The resource fetch algorithm
1548     m_networkState = NETWORK_LOADING;
1549 
1550     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1551     ApplicationCacheResource* resource = nullptr;
1552     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1553         // Resources that are not present in the manifest will always fail to load (at least, after the
1554         // cache has been primed the first time), making the testing of offline applications simpler.
1555         if (!resource || resource-&gt;path().isEmpty()) {
1556             mediaLoadingFailed(MediaPlayer::NetworkError);
1557             return;
1558         }
1559     }
1560 
1561     // Log that we started loading a media element.
1562     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1563 
1564     m_firstTimePlaying = true;
1565 
1566     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1567     // cache is an internal detail not exposed through the media element API.
1568     m_currentSrc = url;
1569 
1570     if (resource) {
1571         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<a name="31" id="anc31"></a><span class="line-modified">1572         INFO_LOG(LOGIDENTIFIER, &quot;will load &quot;, url, &quot; from app cache&quot;);</span>
1573     }
1574 
1575     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1576 
1577     startProgressEventTimer();
1578 
1579     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();
1580     m_player-&gt;setPrivateBrowsingMode(privateMode);
1581 
1582     // Reset display mode to force a recalculation of what to show because we are resetting the player.
1583     setDisplayMode(Unknown);
1584 
1585     if (!autoplay() &amp;&amp; !m_havePreparedToPlay)
1586         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1587     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1588 
1589     if (!m_explicitlyMuted) {
1590         m_explicitlyMuted = true;
1591         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1592         m_mediaSession-&gt;canProduceAudioChanged();
1593     }
1594 
1595     updateVolume();
1596 
1597     bool loadAttempted = false;
1598 #if ENABLE(MEDIA_SOURCE)
1599     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1600         m_mediaSource = MediaSource::lookup(url.string());
1601 
1602     if (m_mediaSource) {
1603         loadAttempted = true;
1604 
1605         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
1606         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {
1607             // Forget our reference to the MediaSource, so we leave it alone
1608             // while processing remainder of load failure.
1609             m_mediaSource = nullptr;
1610             mediaLoadingFailed(MediaPlayer::FormatError);
1611         }
1612     }
1613 #endif
<a name="32" id="anc32"></a><span class="line-removed">1614 </span>
1615 #if ENABLE(MEDIA_STREAM)
<a name="33" id="anc33"></a><span class="line-modified">1616     if (!loadAttempted) {</span>
<span class="line-modified">1617         if (!m_mediaStreamSrcObject &amp;&amp; url.protocolIs(mediaStreamBlobProtocol))</span>
<span class="line-modified">1618             m_mediaStreamSrcObject = MediaStreamRegistry::shared().lookUp(url);</span>
<span class="line-modified">1619 </span>
<span class="line-modified">1620         if (m_mediaStreamSrcObject) {</span>
<span class="line-removed">1621             loadAttempted = true;</span>
<span class="line-removed">1622             ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-removed">1623             if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-removed">1624                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
<span class="line-removed">1625         }</span>
1626     }
1627 #endif
1628 
1629     if (!loadAttempted &amp;&amp; m_blob) {
1630         loadAttempted = true;
1631         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1632         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
1633             mediaLoadingFailed(MediaPlayer::FormatError);
1634     }
1635 
1636     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
1637         mediaLoadingFailed(MediaPlayer::FormatError);
1638 
1639     // If there is no poster to display, allow the media engine to render video frames as soon as
1640     // they are available.
1641     updateDisplayState();
1642 
1643     updateRenderer();
1644 }
1645 
1646 #if ENABLE(VIDEO_TRACK)
1647 
1648 static bool trackIndexCompare(TextTrack* a, TextTrack* b)
1649 {
1650     return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
1651 }
1652 
1653 static bool eventTimeCueCompare(const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; a, const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; b)
1654 {
1655     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1656     // times first).
1657     if (a.first != b.first)
1658         return a.first - b.first &lt; MediaTime::zeroTime();
1659 
1660     // If the cues belong to different text tracks, it doesn&#39;t make sense to
1661     // compare the two tracks by the relative cue order, so return the relative
1662     // track order.
1663     if (a.second-&gt;track() != b.second-&gt;track())
1664         return trackIndexCompare(a.second-&gt;track(), b.second-&gt;track());
1665 
1666     // 12 - Further sort tasks in events that have the same time by the
1667     // relative text track cue order of the text track cues associated
1668     // with these tasks.
1669     return a.second-&gt;isOrderedBefore(b.second);
1670 }
1671 
1672 static bool compareCueInterval(const CueInterval&amp; one, const CueInterval&amp; two)
1673 {
1674     return one.data()-&gt;isOrderedBefore(two.data());
1675 }
1676 
1677 static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
1678 {
1679     return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
1680 }
1681 
1682 void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
1683 {
1684     // 4.8.10.8 Playing the media resource
1685 
1686     //  If the current playback position changes while the steps are running,
1687     //  then the user agent must wait for the steps to complete, and then must
1688     //  immediately rerun the steps.
1689     if (ignoreTrackDisplayUpdateRequests())
1690         return;
1691 
1692     // 1 - Let current cues be a list of cues, initialized to contain all the
1693     // cues of all the hidden, showing, or showing by default text tracks of the
1694     // media element (not the disabled ones) whose start times are less than or
1695     // equal to the current playback position and whose end times are greater
1696     // than the current playback position.
1697     CueList currentCues;
1698 
1699     // The user agent must synchronously unset [the text track cue active] flag
1700     // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
1701     auto movieTimeInterval = m_cueTree.createInterval(movieTime, movieTime);
1702     if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
1703         currentCues = m_cueTree.allOverlaps(movieTimeInterval);
1704         if (currentCues.size() &gt; 1)
1705             std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
1706     }
1707 
1708     CueList previousCues;
1709     CueList missedCues;
1710 
1711     // 2 - Let other cues be a list of cues, initialized to contain all the cues
1712     // of hidden, showing, and showing by default text tracks of the media
1713     // element that are not present in current cues.
1714     previousCues = m_currentlyActiveCues;
1715 
1716     // 3 - Let last time be the current playback position at the time this
1717     // algorithm was last run for this media element, if this is not the first
1718     // time it has run.
1719     MediaTime lastTime = m_lastTextTrackUpdateTime;
1720 
1721     // 4 - If the current playback position has, since the last time this
1722     // algorithm was run, only changed through its usual monotonic increase
1723     // during normal playback, then let missed cues be the list of cues in other
1724     // cues whose start times are greater than or equal to last time and whose
1725     // end times are less than or equal to the current playback position.
1726     // Otherwise, let missed cues be an empty list.
1727     if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
1728         for (auto&amp; cue : m_cueTree.allOverlaps(m_cueTree.createInterval(lastTime, movieTime))) {
1729             // Consider cues that may have been missed since the last seek time.
1730             if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
1731                 missedCues.append(cue);
1732         }
1733     }
1734 
1735     m_lastTextTrackUpdateTime = movieTime;
1736 
1737     // 5 - If the time was reached through the usual monotonic increase of the
1738     // current playback position during normal playback, and if the user agent
1739     // has not fired a timeupdate event at the element in the past 15 to 250ms
1740     // and is not still running event handlers for such an event, then the user
1741     // agent must queue a task to fire a simple event named timeupdate at the
1742     // element. (In the other cases, such as explicit seeks, relevant events get
1743     // fired as part of the overall process of changing the current playback
1744     // position.)
1745     if (!m_paused &amp;&amp; m_lastSeekTime &lt;= lastTime)
1746         scheduleTimeupdateEvent(false);
1747 
1748     // Explicitly cache vector sizes, as their content is constant from here.
1749     size_t currentCuesSize = currentCues.size();
1750     size_t missedCuesSize = missedCues.size();
1751     size_t previousCuesSize = previousCues.size();
1752 
1753     // 6 - If all of the cues in current cues have their text track cue active
1754     // flag set, none of the cues in other cues have their text track cue active
1755     // flag set, and missed cues is empty, then abort these steps.
1756     bool activeSetChanged = missedCuesSize;
1757 
1758     for (size_t i = 0; !activeSetChanged &amp;&amp; i &lt; previousCuesSize; ++i)
1759         if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
1760             activeSetChanged = true;
1761 
1762     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1763         RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
1764 
1765         if (cue-&gt;isRenderable())
1766             toVTTCue(cue.get())-&gt;updateDisplayTree(movieTime);
1767 
1768         if (!cue-&gt;isActive())
1769             activeSetChanged = true;
1770     }
1771 
1772     MediaTime nextInterestingTime = MediaTime::invalidTime();
1773     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1774         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1775 
1776     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);
1777     if (nextCue)
1778         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1779 
1780     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1781 
1782     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1783         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1784             if (!weakThis)
1785                 return;
1786 
<a name="34" id="anc34"></a><span class="line-modified">1787             auto currentMediaTime = weakThis-&gt;currentMediaTime();</span>
<span class="line-modified">1788             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime:&quot;, currentMediaTime);</span>
<span class="line-modified">1789             weakThis-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
1790         }, nextInterestingTime);
1791     }
1792 
1793     if (!activeSetChanged)
1794         return;
1795 
1796     // 7 - If the time was reached through the usual monotonic increase of the
1797     // current playback position during normal playback, and there are cues in
1798     // other cues that have their text track cue pause-on-exi flag set and that
1799     // either have their text track cue active flag set or are also in missed
1800     // cues, then immediately pause the media element.
1801     for (size_t i = 0; !m_paused &amp;&amp; i &lt; previousCuesSize; ++i) {
1802         if (previousCues[i].data()-&gt;pauseOnExit()
1803             &amp;&amp; previousCues[i].data()-&gt;isActive()
1804             &amp;&amp; !currentCues.contains(previousCues[i]))
1805             pause();
1806     }
1807 
1808     for (size_t i = 0; !m_paused &amp;&amp; i &lt; missedCuesSize; ++i) {
1809         if (missedCues[i].data()-&gt;pauseOnExit())
1810             pause();
1811     }
1812 
1813     // 8 - Let events be a list of tasks, initially empty. Each task in this
1814     // list will be associated with a text track, a text track cue, and a time,
1815     // which are used to sort the list before the tasks are queued.
1816     Vector&lt;std::pair&lt;MediaTime, TextTrackCue*&gt;&gt; eventTasks;
1817 
1818     // 8 - Let affected tracks be a list of text tracks, initially empty.
1819     Vector&lt;TextTrack*&gt; affectedTracks;
1820 
1821     for (size_t i = 0; i &lt; missedCuesSize; ++i) {
1822         // 9 - For each text track cue in missed cues, prepare an event named enter
1823         // for the TextTrackCue object with the text track cue start time.
1824         eventTasks.append({ missedCues[i].data()-&gt;startMediaTime(), missedCues[i].data() });
1825 
1826         // 10 - For each text track [...] in missed cues, prepare an event
1827         // named exit for the TextTrackCue object with the  with the later of
1828         // the text track cue end time and the text track cue start time.
1829 
1830         // Note: An explicit task is added only if the cue is NOT a zero or
1831         // negative length cue. Otherwise, the need for an exit event is
1832         // checked when these tasks are actually queued below. This doesn&#39;t
1833         // affect sorting events before dispatch either, because the exit
1834         // event has the same time as the enter event.
1835         if (missedCues[i].data()-&gt;startMediaTime() &lt; missedCues[i].data()-&gt;endMediaTime())
1836             eventTasks.append({ missedCues[i].data()-&gt;endMediaTime(), missedCues[i].data() });
1837     }
1838 
1839     for (size_t i = 0; i &lt; previousCuesSize; ++i) {
1840         // 10 - For each text track cue in other cues that has its text
1841         // track cue active flag set prepare an event named exit for the
1842         // TextTrackCue object with the text track cue end time.
1843         if (!currentCues.contains(previousCues[i]))
1844             eventTasks.append({ previousCues[i].data()-&gt;endMediaTime(), previousCues[i].data() });
1845     }
1846 
1847     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1848         // 11 - For each text track cue in current cues that does not have its
1849         // text track cue active flag set, prepare an event named enter for the
1850         // TextTrackCue object with the text track cue start time.
1851         if (!previousCues.contains(currentCues[i]))
1852             eventTasks.append({ currentCues[i].data()-&gt;startMediaTime(), currentCues[i].data() });
1853     }
1854 
1855     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1856     // times first).
1857     std::sort(eventTasks.begin(), eventTasks.end(), eventTimeCueCompare);
1858 
1859     for (auto&amp; eventTask : eventTasks) {
1860         if (!affectedTracks.contains(eventTask.second-&gt;track()))
1861             affectedTracks.append(eventTask.second-&gt;track());
1862 
1863         // 13 - Queue each task in events, in list order.
1864 
1865         // Each event in eventTasks may be either an enterEvent or an exitEvent,
1866         // depending on the time that is associated with the event. This
1867         // correctly identifies the type of the event, if the startTime is
1868         // less than the endTime in the cue.
1869         if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
1870             auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1871             enterEvent-&gt;setTarget(eventTask.second);
1872             m_asyncEventQueue.enqueueEvent(WTFMove(enterEvent));
1873 
1874             auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1875             exitEvent-&gt;setTarget(eventTask.second);
1876             m_asyncEventQueue.enqueueEvent(WTFMove(exitEvent));
1877         } else {
1878             RefPtr&lt;Event&gt; event;
1879             if (eventTask.first == eventTask.second-&gt;startMediaTime())
1880                 event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1881             else
1882                 event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1883             event-&gt;setTarget(eventTask.second);
1884             m_asyncEventQueue.enqueueEvent(WTFMove(event));
1885         }
1886     }
1887 
1888     // 14 - Sort affected tracks in the same order as the text tracks appear in
1889     // the media element&#39;s list of text tracks, and remove duplicates.
1890     std::sort(affectedTracks.begin(), affectedTracks.end(), trackIndexCompare);
1891 
1892     // 15 - For each text track in affected tracks, in the list order, queue a
1893     // task to fire a simple event named cuechange at the TextTrack object, and, ...
1894     for (auto&amp; affectedTrack : affectedTracks) {
1895         auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1896         event-&gt;setTarget(affectedTrack);
1897         m_asyncEventQueue.enqueueEvent(WTFMove(event));
1898 
1899         // ... if the text track has a corresponding track element, to then fire a
1900         // simple event named cuechange at the track element as well.
1901         if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
1902             auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1903             auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
1904             ASSERT(trackElement);
1905             event-&gt;setTarget(trackElement);
1906             m_asyncEventQueue.enqueueEvent(WTFMove(event));
1907         }
1908     }
1909 
1910     // 16 - Set the text track cue active flag of all the cues in the current
1911     // cues, and unset the text track cue active flag of all the cues in the
1912     // other cues.
1913     for (size_t i = 0; i &lt; currentCuesSize; ++i)
1914         currentCues[i].data()-&gt;setIsActive(true);
1915 
1916     for (size_t i = 0; i &lt; previousCuesSize; ++i)
1917         if (!currentCues.contains(previousCues[i]))
1918             previousCues[i].data()-&gt;setIsActive(false);
1919 
1920     // Update the current active cues.
1921     m_currentlyActiveCues = currentCues;
1922 
1923     if (activeSetChanged)
1924         updateTextTrackDisplay();
1925 }
1926 
1927 bool HTMLMediaElement::textTracksAreReady() const
1928 {
1929     // 4.8.10.12.1 Text track model
1930     // ...
1931     // The text tracks of a media element are ready if all the text tracks whose mode was not
1932     // in the disabled state when the element&#39;s resource selection algorithm last started now
1933     // have a text track readiness state of loaded or failed to load.
1934     for (unsigned i = 0; i &lt; m_textTracksWhenResourceSelectionBegan.size(); ++i) {
1935         if (m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::Loading
1936             || m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::NotLoaded)
1937             return false;
1938     }
1939 
1940     return true;
1941 }
1942 
1943 void HTMLMediaElement::textTrackReadyStateChanged(TextTrack* track)
1944 {
1945     if (track-&gt;readinessState() != TextTrack::Loading
1946         &amp;&amp; track-&gt;mode() != TextTrack::Mode::Disabled) {
1947         // The display trees exist as long as the track is active, in this case,
1948         // and if the same track is loaded again (for example if the src attribute was changed),
1949         // cues can be accumulated with the old ones, that&#39;s why they needs to be flushed
1950         if (hasMediaControls())
1951             mediaControls()-&gt;clearTextDisplayContainer();
1952         updateTextTrackDisplay();
1953     }
1954     if (m_player &amp;&amp; m_textTracksWhenResourceSelectionBegan.contains(track)) {
1955         if (track-&gt;readinessState() != TextTrack::Loading)
1956             setReadyState(m_player-&gt;readyState());
1957     } else {
1958         // The track readiness state might have changed as a result of the user
1959         // clicking the captions button. In this case, a check whether all the
1960         // resources have failed loading should be done in order to hide the CC button.
1961         if (hasMediaControls() &amp;&amp; track-&gt;readinessState() == TextTrack::FailedToLoad)
1962             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
1963     }
1964 }
1965 
1966 void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
1967 {
1968     if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
1969         m_audioTracks-&gt;scheduleChangeEvent();
1970     if (processingUserGestureForMedia())
<a name="35" id="anc35"></a><span class="line-modified">1971         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
1972 }
1973 
1974 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1975 {
1976     bool trackIsLoaded = true;
1977     if (track.trackType() == TextTrack::TrackElement) {
1978         trackIsLoaded = false;
1979         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1980             if (&amp;trackElement.track() == &amp;track) {
1981                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1982                     trackIsLoaded = true;
1983                 break;
1984             }
1985         }
1986     }
1987 
1988     // If this is the first added track, create the list of text tracks.
1989     if (!m_textTracks)
1990         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
1991 
1992     // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
1993     track.setHasBeenConfigured(true);
1994 
1995     if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
1996         textTrackAddCues(track, *track.cues());
1997 
1998     configureTextTrackDisplay(AssumeTextTrackVisibilityChanged);
1999 
2000     if (m_textTracks &amp;&amp; m_textTracks-&gt;contains(track))
2001         m_textTracks-&gt;scheduleChangeEvent();
2002 
2003 #if ENABLE(AVF_CAPTIONS)
2004     if (track.trackType() == TextTrack::TrackElement &amp;&amp; m_player)
2005         m_player-&gt;notifyTrackModeChanged();
2006 #endif
2007 }
2008 
2009 void HTMLMediaElement::videoTrackSelectedChanged(VideoTrack&amp; track)
2010 {
2011     if (m_videoTracks &amp;&amp; m_videoTracks-&gt;contains(track))
2012         m_videoTracks-&gt;scheduleChangeEvent();
2013 }
2014 
2015 void HTMLMediaElement::textTrackKindChanged(TextTrack&amp; track)
2016 {
2017     if (track.kind() != TextTrack::Kind::Captions &amp;&amp; track.kind() != TextTrack::Kind::Subtitles &amp;&amp; track.mode() == TextTrack::Mode::Showing)
2018         track.setMode(TextTrack::Mode::Hidden);
2019 }
2020 
2021 void HTMLMediaElement::beginIgnoringTrackDisplayUpdateRequests()
2022 {
2023     ++m_ignoreTrackDisplayUpdate;
2024 }
2025 
2026 void HTMLMediaElement::endIgnoringTrackDisplayUpdateRequests()
2027 {
2028     ASSERT(m_ignoreTrackDisplayUpdate);
2029     --m_ignoreTrackDisplayUpdate;
2030     if (!m_ignoreTrackDisplayUpdate &amp;&amp; m_inActiveDocument)
2031         updateActiveTextTrackCues(currentMediaTime());
2032 }
2033 
2034 void HTMLMediaElement::textTrackAddCues(TextTrack&amp; track, const TextTrackCueList&amp; cues)
2035 {
2036     if (track.mode() == TextTrack::Mode::Disabled)
2037         return;
2038 
2039     TrackDisplayUpdateScope scope { *this };
2040     for (unsigned i = 0; i &lt; cues.length(); ++i)
2041         textTrackAddCue(track, *cues.item(i));
2042 }
2043 
2044 void HTMLMediaElement::textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp; cues)
2045 {
2046     TrackDisplayUpdateScope scope { *this };
2047     for (unsigned i = 0; i &lt; cues.length(); ++i) {
2048         auto&amp; cue = *cues.item(i);
2049         textTrackRemoveCue(*cue.track(), cue);
2050     }
2051 }
2052 
2053 void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
2054 {
2055     if (track.mode() == TextTrack::Mode::Disabled)
2056         return;
2057 
2058     // Negative duration cues need be treated in the interval tree as
2059     // zero-length cues.
2060     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2061 
2062     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);
2063     if (!m_cueTree.contains(interval))
2064         m_cueTree.add(interval);
2065     updateActiveTextTrackCues(currentMediaTime());
2066 }
2067 
2068 void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
2069 {
2070     // Negative duration cues need to be treated in the interval tree as
2071     // zero-length cues.
2072     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2073 
2074     CueInterval interval = m_cueTree.createInterval(cue.startMediaTime(), endTime, &amp;cue);
2075     m_cueTree.remove(interval);
2076 
2077     // Since the cue will be removed from the media element and likely the
2078     // TextTrack might also be destructed, notifying the region of the cue
2079     // removal shouldn&#39;t be done.
2080     if (cue.isRenderable())
2081         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
2082 
2083     size_t index = m_currentlyActiveCues.find(interval);
2084     if (index != notFound) {
2085         cue.setIsActive(false);
2086         m_currentlyActiveCues.remove(index);
2087     }
2088 
2089     if (cue.isRenderable())
2090         toVTTCue(&amp;cue)-&gt;removeDisplayTree();
2091     updateActiveTextTrackCues(currentMediaTime());
2092 
2093     if (cue.isRenderable())
2094         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
2095 }
2096 
2097 #endif
2098 
2099 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2100 {
2101     // Elements in user agent show tree should load whatever the embedding document policy is.
2102     if (isInUserAgentShadowTree)
2103         return true;
2104 
2105     ASSERT(element.document().contentSecurityPolicy());
2106     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2107 }
2108 
2109 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2110 {
2111     if (!url.isValid()) {
2112         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2113         return false;
2114     }
2115 
2116     RefPtr&lt;Frame&gt; frame = document().frame();
2117     if (!frame || !document().securityOrigin().canDisplay(url)) {
<a name="36" id="anc36"></a><span class="line-modified">2118         if (actionIfInvalid == Complain)</span>
2119             FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
2120             ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
<a name="37" id="anc37"></a>
2121         return false;
2122     }
2123 
2124     if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
2125         ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
2126         return false;
2127     }
2128 
2129     return true;
2130 }
2131 
2132 void HTMLMediaElement::startProgressEventTimer()
2133 {
2134     if (m_progressEventTimer.isActive())
2135         return;
2136 
2137     m_previousProgressTime = MonotonicTime::now();
2138     // 350ms is not magic, it is in the spec!
2139     m_progressEventTimer.startRepeating(350_ms);
2140 }
2141 
2142 void HTMLMediaElement::waitForSourceChange()
2143 {
2144     INFO_LOG(LOGIDENTIFIER);
2145 
2146     stopPeriodicTimers();
2147     m_loadState = WaitingForSource;
2148 
2149     // 6.17 - Waiting: Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value
2150     m_networkState = NETWORK_NO_SOURCE;
2151 
2152     // 6.18 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2153     setShouldDelayLoadEvent(false);
2154 
2155     updateDisplayState();
2156     updateRenderer();
2157 }
2158 
2159 void HTMLMediaElement::noneSupported()
2160 {
2161     if (m_error)
2162         return;
2163 
2164     INFO_LOG(LOGIDENTIFIER);
2165 
2166     stopPeriodicTimers();
2167     m_loadState = WaitingForSource;
2168     m_currentSourceNode = nullptr;
2169 
2170     // 4.8.10.5
2171     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2172     // URL could not be resolved. In one atomic operation, run the following steps:
2173 
2174     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2175     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2176     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2177 
<a name="38" id="anc38"></a><span class="line-removed">2178 #if ENABLE(VIDEO_TRACK)</span>
2179     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2180     forgetResourceSpecificTracks();
<a name="39" id="anc39"></a><span class="line-removed">2181 #endif</span>
2182 
2183     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2184     m_networkState = NETWORK_NO_SOURCE;
2185 
2186     // 7 - Queue a task to fire a simple event named error at the media element.
2187     scheduleEvent(eventNames().errorEvent);
2188 
2189     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2190 
2191 #if ENABLE(MEDIA_SOURCE)
2192     detachMediaSource();
2193 #endif
2194 
2195     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2196     setShouldDelayLoadEvent(false);
2197 
2198     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2199     // the element won&#39;t attempt to load another resource.
2200 
2201     updateDisplayState();
2202     updateRenderer();
2203 }
2204 
2205 void HTMLMediaElement::mediaLoadingFailedFatally(MediaPlayer::NetworkState error)
2206 {
2207     // 1 - The user agent should cancel the fetching process.
2208     stopPeriodicTimers();
2209     m_loadState = WaitingForSource;
2210 
2211     // 2 - Set the error attribute to a new MediaError object whose code attribute is
2212     // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
2213     if (error == MediaPlayer::NetworkError)
2214         m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
2215     else if (error == MediaPlayer::DecodeError)
2216         m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
2217     else
2218         ASSERT_NOT_REACHED();
2219 
2220     // 3 - Queue a task to fire a simple event named error at the media element.
2221     scheduleEvent(eventNames().errorEvent);
2222 
2223 #if ENABLE(MEDIA_SOURCE)
2224     detachMediaSource();
2225 #endif
2226 
2227     // 4 - Set the element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a
2228     // task to fire a simple event called emptied at the element.
2229     m_networkState = NETWORK_EMPTY;
2230     scheduleEvent(eventNames().emptiedEvent);
2231 
2232     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2233     setShouldDelayLoadEvent(false);
2234 
2235     // 6 - Abort the overall resource selection algorithm.
2236     m_currentSourceNode = nullptr;
2237 
2238 #if PLATFORM(COCOA)
2239     if (is&lt;MediaDocument&gt;(document()))
2240         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();
2241 #endif
2242 }
2243 
2244 void HTMLMediaElement::cancelPendingEventsAndCallbacks()
2245 {
2246     INFO_LOG(LOGIDENTIFIER);
2247     m_asyncEventQueue.cancelAllEvents();
2248 
2249     for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
2250         source.cancelPendingErrorEvent();
2251 
2252     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
2253 }
2254 
2255 void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)
2256 {
2257     beginProcessingMediaPlayerCallback();
2258     setNetworkState(m_player-&gt;networkState());
2259     endProcessingMediaPlayerCallback();
2260 }
2261 
2262 static void logMediaLoadRequest(Page* page, const String&amp; mediaEngine, const String&amp; errorMessage, bool succeeded)
2263 {
2264     if (!page)
2265         return;
2266 
2267     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page-&gt;diagnosticLoggingClient();
2268     if (!succeeded) {
2269         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::mediaLoadingFailedKey(), errorMessage, DiagnosticLoggingResultFail, ShouldSample::No);
2270         return;
2271     }
2272 
2273     diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::mediaLoadedKey(), mediaEngine, ShouldSample::No);
2274 
2275     if (!page-&gt;hasSeenAnyMediaEngine())
2276         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsAtLeastOneMediaEngineKey(), emptyString(), ShouldSample::No);
2277 
2278     if (!page-&gt;hasSeenMediaEngine(mediaEngine))
2279         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
2280 
2281     page-&gt;sawMediaEngine(mediaEngine);
2282 }
2283 
2284 static String stringForNetworkState(MediaPlayer::NetworkState state)
2285 {
2286     switch (state) {
2287     case MediaPlayer::Empty: return &quot;Empty&quot;_s;
2288     case MediaPlayer::Idle: return &quot;Idle&quot;_s;
2289     case MediaPlayer::Loading: return &quot;Loading&quot;_s;
2290     case MediaPlayer::Loaded: return &quot;Loaded&quot;_s;
2291     case MediaPlayer::FormatError: return &quot;FormatError&quot;_s;
2292     case MediaPlayer::NetworkError: return &quot;NetworkError&quot;_s;
2293     case MediaPlayer::DecodeError: return &quot;DecodeError&quot;_s;
2294     default: return emptyString();
2295     }
2296 }
2297 
2298 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2299 {
2300     stopPeriodicTimers();
2301 
2302     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2303     // &lt;source&gt; children, schedule the next one
2304     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2305 
2306         // resource selection algorithm
2307         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2308         if (m_currentSourceNode)
2309             m_currentSourceNode-&gt;scheduleErrorEvent();
2310         else
2311             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2312 
2313         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2314 
<a name="40" id="anc40"></a><span class="line-removed">2315 #if ENABLE(VIDEO_TRACK)</span>
2316         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2317         forgetResourceSpecificTracks();
<a name="41" id="anc41"></a><span class="line-removed">2318 #endif</span>
2319 
2320         if (havePotentialSourceChild()) {
2321             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2322             scheduleNextSourceChild();
2323         } else {
2324             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2325             waitForSourceChange();
2326         }
2327 
2328         return;
2329     }
2330 
2331     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)
2332         mediaLoadingFailedFatally(error);
2333     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)
2334         noneSupported();
2335 
2336     updateDisplayState();
2337     if (hasMediaControls()) {
2338         mediaControls()-&gt;reset();
2339         mediaControls()-&gt;reportedError();
2340     }
2341 
2342     ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
2343 
2344     logMediaLoadRequest(document().page(), String(), stringForNetworkState(error), false);
2345 
2346     m_mediaSession-&gt;clientCharacteristicsChanged();
2347 }
2348 
2349 void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
2350 {
2351     if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
2352         ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
2353 
2354     if (state == MediaPlayer::Empty) {
2355         // Just update the cached state and leave, we can&#39;t do anything.
2356         m_networkState = NETWORK_EMPTY;
2357         return;
2358     }
2359 
2360     if (state == MediaPlayer::FormatError || state == MediaPlayer::NetworkError || state == MediaPlayer::DecodeError) {
2361         mediaLoadingFailed(state);
2362         return;
2363     }
2364 
2365     if (state == MediaPlayer::Idle) {
2366         if (m_networkState &gt; NETWORK_IDLE) {
2367             changeNetworkStateFromLoadingToIdle();
2368             setShouldDelayLoadEvent(false);
2369         } else {
2370             m_networkState = NETWORK_IDLE;
2371         }
2372     }
2373 
2374     if (state == MediaPlayer::Loading) {
2375         if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
2376             startProgressEventTimer();
2377         m_networkState = NETWORK_LOADING;
2378     }
2379 
2380     if (state == MediaPlayer::Loaded) {
2381         if (m_networkState != NETWORK_IDLE)
2382             changeNetworkStateFromLoadingToIdle();
2383         m_completelyLoaded = true;
2384     }
2385 
2386     if (hasMediaControls())
2387         mediaControls()-&gt;updateStatusDisplay();
2388 }
2389 
2390 void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
2391 {
2392     m_progressEventTimer.stop();
2393     if (hasMediaControls() &amp;&amp; m_player-&gt;didLoadingProgress())
2394         mediaControls()-&gt;bufferingProgressed();
2395 
2396     // Schedule one last progress event so we guarantee that at least one is fired
2397     // for files that load very quickly.
2398     scheduleEvent(eventNames().progressEvent);
2399     scheduleEvent(eventNames().suspendEvent);
2400     m_networkState = NETWORK_IDLE;
2401 }
2402 
2403 void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)
2404 {
2405     beginProcessingMediaPlayerCallback();
2406 
2407     setReadyState(m_player-&gt;readyState());
2408 
2409     endProcessingMediaPlayerCallback();
2410 }
2411 
2412 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2413 {
<a name="42" id="anc42"></a><span class="line-modified">2414     if (isAutoplaying()</span>
<span class="line-modified">2415         &amp;&amp; mediaSession().autoplayPermitted()</span>
<span class="line-modified">2416         &amp;&amp; paused()</span>
<span class="line-modified">2417         &amp;&amp; autoplay()</span>
<span class="line-modified">2418         &amp;&amp; !pausedForUserInteraction()</span>
<span class="line-modified">2419         &amp;&amp; !document().isSandboxed(SandboxAutomaticFeatures)</span>
<span class="line-modified">2420         &amp;&amp; m_readyState == HAVE_ENOUGH_DATA)</span>
<span class="line-modified">2421         return mediaSession().playbackPermitted();</span>




















2422 
<a name="43" id="anc43"></a><span class="line-modified">2423     ALWAYS_LOG(LOGIDENTIFIER, &quot;page consent required&quot;);</span>
<span class="line-modified">2424     return MediaPlaybackDenialReason::PageConsentRequired;</span>







2425 }
2426 
2427 void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
2428 {
<a name="44" id="anc44"></a><span class="line-modified">2429     auto&amp; document = this-&gt;document();</span>
<span class="line-removed">2430     if (!needsAutoplayPlayPauseEventsQuirk(document) &amp;&amp; !needsAutoplayPlayPauseEventsQuirk(document.topDocument()))</span>
2431         return;
2432 
2433     ALWAYS_LOG(LOGIDENTIFIER);
2434     scheduleEvent(eventNames().playingEvent);
2435     scheduleEvent(eventNames().pauseEvent);
2436 }
2437 
2438 void HTMLMediaElement::setReadyState(MediaPlayer::ReadyState state)
2439 {
2440     // Set &quot;wasPotentiallyPlaying&quot; BEFORE updating m_readyState, potentiallyPlaying() uses it
2441     bool wasPotentiallyPlaying = potentiallyPlaying();
2442 
2443     ReadyState oldState = m_readyState;
2444     ReadyState newState = static_cast&lt;ReadyState&gt;(state);
2445 
2446 #if ENABLE(VIDEO_TRACK)
2447     bool tracksAreReady = textTracksAreReady();
2448 
2449     if (newState == oldState &amp;&amp; m_tracksAreReady == tracksAreReady)
2450         return;
2451 
2452     m_tracksAreReady = tracksAreReady;
2453 #else
2454     if (newState == oldState)
2455         return;
2456     bool tracksAreReady = true;
2457 #endif
2458 
2459     ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_readyState);
2460 
2461     if (tracksAreReady)
2462         m_readyState = newState;
2463     else {
2464         // If a media file has text tracks the readyState may not progress beyond HAVE_FUTURE_DATA until
2465         // the text tracks are ready, regardless of the state of the media file.
2466         if (newState &lt;= HAVE_METADATA)
2467             m_readyState = newState;
2468         else
2469             m_readyState = HAVE_CURRENT_DATA;
2470     }
2471 
2472     if (oldState &gt; m_readyStateMaximum)
2473         m_readyStateMaximum = oldState;
2474 
2475     if (m_networkState == NETWORK_EMPTY)
2476         return;
2477 
2478     if (m_seeking) {
2479         // 4.8.10.9, step 11
2480         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
2481             scheduleEvent(eventNames().waitingEvent);
2482 
2483         // 4.8.10.10 step 14 &amp; 15.
2484         if (m_seekRequested &amp;&amp; !m_player-&gt;seeking() &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA)
2485             finishSeek();
2486     } else {
2487         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA) {
2488             // 4.8.10.8
2489             invalidateCachedTime();
2490             scheduleTimeupdateEvent(false);
2491             scheduleEvent(eventNames().waitingEvent);
2492         }
2493     }
2494 
2495     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; oldState &lt; HAVE_METADATA) {
2496         prepareMediaFragmentURI();
2497         scheduleEvent(eventNames().durationchangeEvent);
2498         scheduleResizeEvent();
2499         scheduleEvent(eventNames().loadedmetadataEvent);
2500 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2501         if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent))
2502             enqueuePlaybackTargetAvailabilityChangedEvent();
2503 #endif
2504         m_initiallyMuted = m_volume &lt; 0.05 || muted();
2505 
2506         if (hasMediaControls())
2507             mediaControls()-&gt;loadedMetadata();
2508         updateRenderer();
2509 
2510         if (is&lt;MediaDocument&gt;(document()))
2511             downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
2512 
2513         logMediaLoadRequest(document().page(), m_player-&gt;engineDescription(), String(), true);
2514 
2515 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2516         scheduleUpdateMediaState();
2517 #endif
2518 
2519         m_mediaSession-&gt;clientCharacteristicsChanged();
2520     }
2521 
2522     bool shouldUpdateDisplayState = false;
2523 
2524     if (m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; oldState &lt; HAVE_CURRENT_DATA) {
2525         if (!m_haveFiredLoadedData) {
2526             m_haveFiredLoadedData = true;
2527             scheduleEvent(eventNames().loadeddataEvent);
2528             // FIXME: It&#39;s not clear that it&#39;s correct to skip these two operations just
2529             // because m_haveFiredLoadedData is already true. At one time we were skipping
2530             // the call to setShouldDelayLoadEvent, which was definitely incorrect.
2531             shouldUpdateDisplayState = true;
2532             applyMediaFragmentURI();
2533         }
2534         setShouldDelayLoadEvent(false);
2535     }
2536 
2537     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt;= HAVE_CURRENT_DATA &amp;&amp; tracksAreReady) {
2538         scheduleEvent(eventNames().canplayEvent);
2539         shouldUpdateDisplayState = true;
2540     }
2541 
2542     if (m_readyState == HAVE_ENOUGH_DATA &amp;&amp; oldState &lt; HAVE_ENOUGH_DATA &amp;&amp; tracksAreReady) {
2543         if (oldState &lt;= HAVE_CURRENT_DATA)
2544             scheduleEvent(eventNames().canplayEvent);
2545 
2546         scheduleEvent(eventNames().canplaythroughEvent);
2547 
2548         auto success = canTransitionFromAutoplayToPlay();
2549         if (success) {
2550             m_paused = false;
2551             invalidateCachedTime();
2552             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
2553             m_playbackStartedTime = currentMediaTime().toDouble();
2554             scheduleEvent(eventNames().playEvent);
2555         } else if (success.value() == MediaPlaybackDenialReason::UserGestureRequired) {
2556             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2557             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2558         }
2559 
2560         shouldUpdateDisplayState = true;
2561     }
2562 
2563     // If we transition to the Future Data state and we&#39;re about to begin playing, ensure playback is actually permitted first,
2564     // honoring any playback denial reasons such as the requirement of a user gesture.
2565     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt; HAVE_FUTURE_DATA &amp;&amp; potentiallyPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
2566         auto canTransition = canTransitionFromAutoplayToPlay();
2567         if (canTransition &amp;&amp; canTransition.value() == MediaPlaybackDenialReason::UserGestureRequired)
2568             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2569 
2570         pauseInternal();
2571         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2572     }
2573 
2574     if (shouldUpdateDisplayState) {
2575         updateDisplayState();
2576         if (hasMediaControls()) {
2577             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
2578             mediaControls()-&gt;updateStatusDisplay();
2579         }
2580     }
2581 
2582     updatePlayState();
2583     updateMediaController();
2584 #if ENABLE(VIDEO_TRACK)
2585     updateActiveTextTrackCues(currentMediaTime());
2586 #endif
2587 }
2588 
2589 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
2590 RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
2591 {
2592     return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
2593 }
2594 
2595 bool HTMLMediaElement::mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array* initData)
2596 {
2597     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2598         return false;
2599 
2600     if (!hasEventListeners(&quot;webkitneedkey&quot;)
2601 #if ENABLE(ENCRYPTED_MEDIA)
2602         // Only fire an error if ENCRYPTED_MEDIA is not enabled, to give clients of the
2603         // &quot;encrypted&quot; event a chance to handle it without resulting in a synthetic error.
2604         &amp;&amp; (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2605 #endif
2606         ) {
2607         m_error = MediaError::create(MediaError::MEDIA_ERR_ENCRYPTED);
2608         scheduleEvent(eventNames().errorEvent);
2609         return false;
2610     }
2611 
2612     auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
2613     event-&gt;setTarget(this);
2614     m_asyncEventQueue.enqueueEvent(WTFMove(event));
2615 
2616     return true;
2617 }
2618 
2619 String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
2620 {
2621     auto* page = document().page();
2622     if (!page || page-&gt;usesEphemeralSession())
2623         return emptyString();
2624 
2625     String storageDirectory = document().settings().mediaKeysStorageDirectory();
2626     if (storageDirectory.isEmpty())
2627         return emptyString();
2628 
2629     return FileSystem::pathByAppendingComponent(storageDirectory, document().securityOrigin().data().databaseIdentifier());
2630 }
2631 
2632 void HTMLMediaElement::webkitSetMediaKeys(WebKitMediaKeys* mediaKeys)
2633 {
2634     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2635         return;
2636 
2637     if (m_webKitMediaKeys == mediaKeys)
2638         return;
2639 
2640     if (m_webKitMediaKeys)
2641         m_webKitMediaKeys-&gt;setMediaElement(nullptr);
2642     m_webKitMediaKeys = mediaKeys;
2643     if (m_webKitMediaKeys)
2644         m_webKitMediaKeys-&gt;setMediaElement(this);
2645 }
2646 
2647 void HTMLMediaElement::keyAdded()
2648 {
2649     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2650         return;
2651 
2652     if (m_player)
2653         m_player-&gt;keyAdded();
2654 }
2655 
2656 #endif
2657 
2658 #if ENABLE(ENCRYPTED_MEDIA)
2659 
2660 MediaKeys* HTMLMediaElement::mediaKeys() const
2661 {
2662     return m_mediaKeys.get();
2663 }
2664 
2665 void HTMLMediaElement::setMediaKeys(MediaKeys* mediaKeys, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
2666 {
2667     // https://w3c.github.io/encrypted-media/#dom-htmlmediaelement-setmediakeys
2668     // W3C Editor&#39;s Draft 23 June 2017
2669 
2670     // 1. If this object&#39;s attaching media keys value is true, return a promise rejected with an InvalidStateError.
2671     if (m_attachingMediaKeys) {
2672         promise-&gt;reject(InvalidStateError);
2673         return;
2674     }
2675 
2676     // 2. If mediaKeys and the mediaKeys attribute are the same object, return a resolved promise.
2677     if (mediaKeys == m_mediaKeys) {
2678         promise-&gt;resolve();
2679         return;
2680     }
2681 
2682     // 3. Let this object&#39;s attaching media keys value be true.
2683     m_attachingMediaKeys = true;
2684 
2685     // 4. Let promise be a new promise.
2686     // 5. Run the following steps in parallel:
2687     m_encryptedMediaQueue.enqueueTask([this, mediaKeys = RefPtr&lt;MediaKeys&gt;(mediaKeys), promise = WTFMove(promise)]() mutable {
2688         // 5.1. If all the following conditions hold:
2689         //      - mediaKeys is not null,
2690         //      - the CDM instance represented by mediaKeys is already in use by another media element
2691         //      - the user agent is unable to use it with this element
2692         //      then let this object&#39;s attaching media keys value be false and reject promise with a QuotaExceededError.
2693         // FIXME: ^
2694 
2695         // 5.2. If the mediaKeys attribute is not null, run the following steps:
2696         if (m_mediaKeys) {
2697             // 5.2.1. If the user agent or CDM do not support removing the association, let this object&#39;s attaching media keys value be false and reject promise with a NotSupportedError.
2698             // 5.2.2. If the association cannot currently be removed, let this object&#39;s attaching media keys value be false and reject promise with an InvalidStateError.
2699             // 5.2.3. Stop using the CDM instance represented by the mediaKeys attribute to decrypt media data and remove the association with the media element.
2700             // 5.2.4. If the preceding step failed, let this object&#39;s attaching media keys value be false and reject promise with the appropriate error name.
2701             // FIXME: ^
2702 
2703             m_mediaKeys-&gt;detachCDMClient(*this);
2704             if (m_player)
2705                 m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
2706         }
2707 
2708         // 5.3. If mediaKeys is not null, run the following steps:
2709         if (mediaKeys) {
2710             // 5.3.1. Associate the CDM instance represented by mediaKeys with the media element for decrypting media data.
2711             mediaKeys-&gt;attachCDMClient(*this);
2712             if (m_player)
2713                 m_player-&gt;cdmInstanceAttached(mediaKeys-&gt;cdmInstance());
2714 
2715             // 5.3.2. If the preceding step failed, run the following steps:
2716             //   5.3.2.1. Set the mediaKeys attribute to null.
2717             //   5.3.2.2. Let this object&#39;s attaching media keys value be false.
2718             //   5.3.2.3. Reject promise with a new DOMException whose name is the appropriate error name.
2719             // FIXME: ^
2720 
2721             // 5.3.3. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on the media element.
2722             m_encryptedMediaQueue.enqueueTask([this] {
2723                 attemptToResumePlaybackIfNecessary();
2724             });
2725         }
2726 
2727         // 5.4. Set the mediaKeys attribute to mediaKeys.
2728         // 5.5. Let this object&#39;s attaching media keys value be false.
2729         // 5.6. Resolve promise.
2730         m_mediaKeys = WTFMove(mediaKeys);
2731         m_attachingMediaKeys = false;
2732         promise-&gt;resolve();
2733     });
2734 
2735     // 6. Return promise.
2736 }
2737 
2738 void HTMLMediaElement::mediaPlayerInitializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
2739 {
2740     if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2741         return;
2742 
2743     // https://w3c.github.io/encrypted-media/#initdata-encountered
2744     // W3C Editor&#39;s Draft 23 June 2017
2745 
2746     // 1. Let the media element be the specified HTMLMediaElement object.
2747     // 2. Let initDataType be the empty string.
2748     // 3. Let initData be null.
2749     // 4. If the media data is CORS-same-origin and not mixed content, run the following steps:
2750     //   4.1. Let initDataType be the string representing the Initialization Data Type of the Initialization Data.
2751     //   4.2. Let initData be the Initialization Data.
2752     // FIXME: ^
2753 
2754     // 5. Queue a task to create an event named encrypted that does not bubble and is not cancellable using the
2755     //    MediaEncryptedEvent interface with its type attribute set to encrypted and its isTrusted attribute
2756     //    initialized to true, and dispatch it at the media element.
2757     //    The event interface MediaEncryptedEvent has:
2758     //      initDataType = initDataType
2759     //      initData = initData
2760     MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
2761     m_asyncEventQueue.enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));
2762 }
2763 
2764 void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
2765 {
2766     if (!m_player)
2767         return;
2768 
2769     if (!m_player-&gt;waitingForKey() &amp;&amp; m_playbackBlockedWaitingForKey) {
2770         // https://w3c.github.io/encrypted-media/#resume-playback
2771         // W3C Editor&#39;s Draft 23 June 2017
2772 
2773         // NOTE: continued from HTMLMediaElement::attemptToDecrypt().
2774         // 4. If the user agent can advance the current playback position in the direction of playback:
2775         //   4.1. Set the media element&#39;s decryption blocked waiting for key value to false.
2776         // FIXME: ^
2777         //   4.2. Set the media element&#39;s playback blocked waiting for key value to false.
2778         m_playbackBlockedWaitingForKey = false;
2779 
2780         //   4.3. Set the media element&#39;s readyState value to HAVE_CURRENT_DATA, HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA as appropriate.
2781         setReadyState(m_player-&gt;readyState());
2782 
2783         return;
2784     }
2785 
2786     // https://www.w3.org/TR/encrypted-media/#wait-for-key
2787     // W3C Recommendation 18 September 2017
2788 
2789     // The Wait for Key algorithm queues a waitingforkey event and
2790     // updates readyState. It should only be called when the
2791     // HTMLMediaElement object is potentially playing and its
2792     // readyState is equal to HAVE_FUTURE_DATA or greater. Requests to
2793     // run this algorithm include a target HTMLMediaElement object.
2794 
2795     // The following steps are run:
2796 
2797     // 1. Let the media element be the specified HTMLMediaElement
2798     // object.
2799     // 2. If the media element&#39;s playback blocked waiting for key
2800     // value is true, abort these steps.
2801     if (m_playbackBlockedWaitingForKey)
2802         return;
2803 
2804     // 3. Set the media element&#39;s playback blocked waiting for key
2805     // value to true.
2806     m_playbackBlockedWaitingForKey = true;
2807 
2808     // NOTE
2809     // As a result of the above step, the media element will become a
2810     // blocked media element if it wasn&#39;t already. In that case, the
2811     // media element will stop playback.
2812 
2813     // 4. Follow the steps for the first matching condition from the
2814     // following list:
2815 
2816     // If data for the immediate current playback position is
2817     // available
2818     // Set the readyState of media element to HAVE_CURRENT_DATA.
2819     // Otherwise
2820     // Set the readyState of media element to HAVE_METADATA.
2821     ReadyState nextReadyState = buffered()-&gt;contain(currentTime()) ? HAVE_CURRENT_DATA : HAVE_METADATA;
2822     if (nextReadyState &lt; m_readyState)
2823         setReadyState(static_cast&lt;MediaPlayer::ReadyState&gt;(nextReadyState));
2824 
2825     // NOTE
2826     // In other words, if the video frame and audio data for the
2827     // current playback position have been decoded because they were
2828     // unencrypted and/or successfully decrypted, set readyState to
2829     // HAVE_CURRENT_DATA. Otherwise, including if this was previously
2830     // the case but the data is no longer available, set readyState to
2831     // HAVE_METADATA.
2832 
2833     // 5. Queue a task to fire a simple event named waitingforkey at the
2834     // media element.
2835     scheduleEvent(eventNames().waitingforkeyEvent);
2836 
2837     // 6. Suspend playback.
2838     // GStreamer handles this without suspending explicitly.
2839 }
2840 
2841 void HTMLMediaElement::attemptToDecrypt()
2842 {
2843     // https://w3c.github.io/encrypted-media/#attempt-to-decrypt
2844     // W3C Editor&#39;s Draft 23 June 2017
2845 
2846     // 1. Let the media element be the specified HTMLMediaElement object.
2847     // 2. If the media element&#39;s encrypted block queue is empty, abort these steps.
2848     // FIXME: ^
2849 
2850     // 3. If the media element&#39;s mediaKeys attribute is not null, run the following steps:
2851     if (m_mediaKeys) {
2852         // 3.1. Let media keys be the MediaKeys object referenced by that attribute.
2853         // 3.2. Let cdm be the CDM instance represented by media keys&#39;s cdm instance value.
2854         auto&amp; cdmInstance = m_mediaKeys-&gt;cdmInstance();
2855 
2856         // 3.3. If cdm is no longer usable for any reason, run the following steps:
2857         //   3.3.1. Run the media data is corrupted steps of the resource fetch algorithm.
2858         //   3.3.2. Run the CDM Unavailable algorithm on media keys.
2859         //   3.3.3. Abort these steps.
2860         // FIXME: ^
2861 
2862         // 3.4. If there is at least one MediaKeySession created by the media keys that is not closed, run the following steps:
2863         if (m_mediaKeys-&gt;hasOpenSessions()) {
2864             // Continued in MediaPlayer::attemptToDecryptWithInstance().
2865             if (m_player)
2866                 m_player-&gt;attemptToDecryptWithInstance(cdmInstance);
2867         }
2868     }
2869 
2870     // 4. Set the media element&#39;s decryption blocked waiting for key value to true.
2871     // FIXME: ^
2872 }
2873 
2874 void HTMLMediaElement::attemptToResumePlaybackIfNecessary()
2875 {
2876     // https://w3c.github.io/encrypted-media/#resume-playback
2877     // W3C Editor&#39;s Draft 23 June 2017
2878 
2879     // 1. Let the media element be the specified HTMLMediaElement object.
2880     // 2. If the media element&#39;s playback blocked waiting for key is false, abort these steps.
2881     if (!m_playbackBlockedWaitingForKey)
2882         return;
2883 
2884     // 3. Run the Attempt to Decrypt algorithm on the media element.
2885     attemptToDecrypt();
2886 
2887     // NOTE: continued in HTMLMediaElement::waitingForKeyChanged()
2888 }
2889 
2890 void HTMLMediaElement::cdmClientAttemptToResumePlaybackIfNecessary()
2891 {
2892     attemptToResumePlaybackIfNecessary();
2893 }
2894 
2895 #endif // ENABLE(ENCRYPTED_MEDIA)
2896 
2897 void HTMLMediaElement::progressEventTimerFired()
2898 {
2899     ASSERT(m_player);
2900     if (m_networkState != NETWORK_LOADING)
2901         return;
2902 
2903     MonotonicTime time = MonotonicTime::now();
2904     Seconds timedelta = time - m_previousProgressTime;
2905 
2906     if (m_player-&gt;didLoadingProgress()) {
2907         scheduleEvent(eventNames().progressEvent);
2908         m_previousProgressTime = time;
2909         m_sentStalledEvent = false;
2910         updateRenderer();
2911         if (hasMediaControls())
2912             mediaControls()-&gt;bufferingProgressed();
2913     } else if (timedelta &gt; 3_s &amp;&amp; !m_sentStalledEvent) {
2914         scheduleEvent(eventNames().stalledEvent);
2915         m_sentStalledEvent = true;
2916         setShouldDelayLoadEvent(false);
2917     }
2918 }
2919 
2920 void HTMLMediaElement::rewind(double timeDelta)
2921 {
2922     setCurrentTime(std::max(currentMediaTime() - MediaTime::createWithDouble(timeDelta), minTimeSeekable()));
2923 }
2924 
2925 void HTMLMediaElement::returnToRealtime()
2926 {
2927     setCurrentTime(maxTimeSeekable());
2928 }
2929 
2930 void HTMLMediaElement::addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end)
2931 {
2932     DEBUG_LOG(LOGIDENTIFIER, MediaTimeRange { start, end });
2933     if (!m_playedTimeRanges)
2934         m_playedTimeRanges = TimeRanges::create();
2935     m_playedTimeRanges-&gt;ranges().add(start, end);
2936 }
2937 
2938 bool HTMLMediaElement::supportsScanning() const
2939 {
2940     return m_player ? m_player-&gt;supportsScanning() : false;
2941 }
2942 
2943 void HTMLMediaElement::prepareToPlay()
2944 {
2945     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2946 
2947     INFO_LOG(LOGIDENTIFIER);
2948     if (m_havePreparedToPlay || !document().hasBrowsingContext())
2949         return;
2950     m_havePreparedToPlay = true;
2951     if (m_player)
2952         m_player-&gt;prepareToPlay();
2953 }
2954 
2955 void HTMLMediaElement::fastSeek(double time)
2956 {
2957     fastSeek(MediaTime::createWithDouble(time));
2958 }
2959 
2960 void HTMLMediaElement::fastSeek(const MediaTime&amp; time)
2961 {
2962     INFO_LOG(LOGIDENTIFIER, time);
2963     // 4.7.10.9 Seeking
2964     // 9. If the approximate-for-speed flag is set, adjust the new playback position to a value that will
2965     // allow for playback to resume promptly. If new playback position before this step is before current
2966     // playback position, then the adjusted new playback position must also be before the current playback
2967     // position. Similarly, if the new playback position before this step is after current playback position,
2968     // then the adjusted new playback position must also be after the current playback position.
2969     refreshCachedTime();
2970 
2971     MediaTime delta = time - currentMediaTime();
2972     MediaTime negativeTolerance = delta &lt; MediaTime::zeroTime() ? MediaTime::positiveInfiniteTime() : delta;
2973     seekWithTolerance(time, negativeTolerance, MediaTime::zeroTime(), true);
2974 }
2975 
2976 void HTMLMediaElement::seek(const MediaTime&amp; time)
2977 {
2978     INFO_LOG(LOGIDENTIFIER, time);
2979     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), true);
2980 }
2981 
2982 void HTMLMediaElement::seekInternal(const MediaTime&amp; time)
2983 {
2984     INFO_LOG(LOGIDENTIFIER, time);
2985     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), false);
2986 }
2987 
2988 void HTMLMediaElement::seekWithTolerance(const MediaTime&amp; inTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM)
2989 {
2990     // 4.8.10.9 Seeking
2991     MediaTime time = inTime;
2992 
2993     // 1 - Set the media element&#39;s show poster flag to false.
2994     setDisplayMode(Video);
2995 
2996     // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
2997     if (m_readyState == HAVE_NOTHING || !m_player)
2998         return;
2999 
3000     // If the media engine has been told to postpone loading data, let it go ahead now.
3001     if (m_preload &lt; MediaPlayer::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
3002         prepareToPlay();
3003 
3004     // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
3005     refreshCachedTime();
3006     MediaTime now = currentMediaTime();
3007 
3008     // 3 - If the element&#39;s seeking IDL attribute is true, then another instance of this algorithm is
3009     // already running. Abort that other instance of the algorithm without waiting for the step that
3010     // it is running to complete.
3011     if (m_seekTaskQueue.hasPendingTask()) {
3012         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
3013         m_seekTaskQueue.cancelTask();
3014         if (m_pendingSeek) {
3015             now = m_pendingSeek-&gt;now;
3016             m_pendingSeek = nullptr;
3017         }
3018         m_pendingSeekType = NoSeek;
3019     }
3020 
3021     // 4 - Set the seeking IDL attribute to true.
3022     // The flag will be cleared when the engine tells us the time has actually changed.
3023     m_seeking = true;
3024     if (m_playing) {
3025         if (m_lastSeekTime &lt; now)
3026             addPlayedRange(m_lastSeekTime, now);
3027     }
3028     m_lastSeekTime = time;
3029 
3030     // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
3031     // the script. The remainder of these steps must be run asynchronously.
<a name="45" id="anc45"></a><span class="line-modified">3032     m_pendingSeek = std::make_unique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
3033     if (fromDOM) {
3034         INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
3035         m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
3036     } else
3037         seekTask();
3038 
3039     if (processingUserGestureForMedia())
3040         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3041 }
3042 
3043 void HTMLMediaElement::seekTask()
3044 {
3045     INFO_LOG(LOGIDENTIFIER);
3046 
3047     if (!m_player) {
3048         clearSeeking();
3049         return;
3050     }
3051 
3052     ASSERT(m_pendingSeek);
3053     MediaTime now = m_pendingSeek-&gt;now;
3054     MediaTime time = m_pendingSeek-&gt;targetTime;
3055     MediaTime negativeTolerance = m_pendingSeek-&gt;negativeTolerance;
3056     MediaTime positiveTolerance = m_pendingSeek-&gt;positiveTolerance;
3057     m_pendingSeek = nullptr;
3058 
3059     ASSERT(negativeTolerance &gt;= MediaTime::zeroTime());
3060 
3061     // 6 - If the new playback position is later than the end of the media resource, then let it be the end
3062     // of the media resource instead.
3063     time = std::min(time, durationMediaTime());
3064 
3065     // 7 - If the new playback position is less than the earliest possible position, let it be that position instead.
3066     MediaTime earliestTime = m_player-&gt;startTime();
3067     time = std::max(time, earliestTime);
3068 
3069     // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
3070     // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
3071     // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
3072     // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
3073     // fire a &#39;seeked&#39; event.
<a name="46" id="anc46"></a><span class="line-modified">3074     if (willLog(WTFLogLevelDebug)) {</span>
3075         MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
3076         if (time != mediaTime)
<a name="47" id="anc47"></a><span class="line-modified">3077             DEBUG_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
3078     }
3079 
3080     time = m_player-&gt;mediaTimeForTimeValue(time);
3081 
3082     // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
3083     // seekable attribute, then let it be the position in one of the ranges given in the seekable attribute
3084     // that is the nearest to the new playback position. ... If there are no ranges given in the seekable
3085     // attribute then set the seeking IDL attribute to false and abort these steps.
3086     RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
3087     bool noSeekRequired = !seekableRanges-&gt;length();
3088 
3089     // Short circuit seeking to the current time by just firing the events if no seek is required.
3090     // Don&#39;t skip calling the media engine if 1) we are in poster mode (because a seek should always cancel
3091     // poster display), or 2) if there is a pending fast seek, or 3) if this seek is not an exact seek
3092     SeekType thisSeekType = (negativeTolerance == MediaTime::zeroTime() &amp;&amp; positiveTolerance == MediaTime::zeroTime()) ? Precise : Fast;
3093     if (!noSeekRequired &amp;&amp; time == now &amp;&amp; thisSeekType == Precise &amp;&amp; m_pendingSeekType != Fast &amp;&amp; displayMode() != Poster)
3094         noSeekRequired = true;
3095 
3096 #if ENABLE(MEDIA_SOURCE)
3097     // Always notify the media engine of a seek if the source is not closed. This ensures that the source is
3098     // always in a flushed state when the &#39;seeking&#39; event fires.
3099     if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
3100         noSeekRequired = false;
3101 #endif
3102 
3103     if (noSeekRequired) {
<a name="48" id="anc48"></a><span class="line-modified">3104         INFO_LOG(LOGIDENTIFIER, &quot;seek to &quot;, time, &quot; ignored&quot;);</span>
3105         if (time == now) {
3106             scheduleEvent(eventNames().seekingEvent);
3107             scheduleTimeupdateEvent(false);
3108             scheduleEvent(eventNames().seekedEvent);
3109         }
3110         clearSeeking();
3111         return;
3112     }
3113     time = seekableRanges-&gt;ranges().nearest(time);
3114 
3115     m_sentEndEvent = false;
3116     m_lastSeekTime = time;
3117     m_pendingSeekType = thisSeekType;
3118     m_seeking = true;
3119 
3120     // 10 - Queue a task to fire a simple event named seeking at the element.
3121     scheduleEvent(eventNames().seekingEvent);
3122 
3123     // 11 - Set the current playback position to the given new playback position
3124     m_seekRequested = true;
3125     m_player-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
3126 
3127     // 12 - Wait until the user agent has established whether or not the media data for the new playback
3128     // position is available, and, if it is, until it has decoded enough data to play back that position.
3129     // 13 - Await a stable state. The synchronous section consists of all the remaining steps of this algorithm.
3130 }
3131 
3132 void HTMLMediaElement::clearSeeking()
3133 {
3134     m_seeking = false;
3135     m_seekRequested = false;
3136     m_pendingSeekType = NoSeek;
3137     invalidateCachedTime();
3138 }
3139 
3140 void HTMLMediaElement::finishSeek()
3141 {
3142     // 4.8.10.9 Seeking
3143     // 14 - Set the seeking IDL attribute to false.
3144     clearSeeking();
3145 
3146     INFO_LOG(LOGIDENTIFIER, &quot;current time = &quot;, currentMediaTime());
3147 
3148     // 15 - Run the time maches on steps.
3149     // Handled by mediaPlayerTimeChanged().
3150 
3151     // 16 - Queue a task to fire a simple event named timeupdate at the element.
3152     scheduleEvent(eventNames().timeupdateEvent);
3153 
3154     // 17 - Queue a task to fire a simple event named seeked at the element.
3155     scheduleEvent(eventNames().seekedEvent);
3156 
3157     if (m_mediaSession)
3158         m_mediaSession-&gt;clientCharacteristicsChanged();
3159 
3160 #if ENABLE(MEDIA_SOURCE)
3161     if (m_mediaSource)
3162         m_mediaSource-&gt;monitorSourceBuffers();
3163 #endif
3164 }
3165 
3166 HTMLMediaElement::ReadyState HTMLMediaElement::readyState() const
3167 {
3168     return m_readyState;
3169 }
3170 
3171 MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
3172 {
3173     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::Unknown;
3174 }
3175 
3176 bool HTMLMediaElement::hasAudio() const
3177 {
3178     return m_player ? m_player-&gt;hasAudio() : false;
3179 }
3180 
3181 bool HTMLMediaElement::seeking() const
3182 {
3183     return m_seeking;
3184 }
3185 
3186 void HTMLMediaElement::refreshCachedTime() const
3187 {
3188     if (!m_player)
3189         return;
3190 
3191     m_cachedTime = m_player-&gt;currentTime();
3192     if (!m_cachedTime) {
3193         // Do not use m_cachedTime until the media engine returns a non-zero value because we can&#39;t
3194         // estimate current time until playback actually begins.
3195         invalidateCachedTime();
3196         return;
3197     }
3198 
3199     m_clockTimeAtLastCachedTimeUpdate = MonotonicTime::now();
3200 }
3201 
3202 void HTMLMediaElement::invalidateCachedTime() const
3203 {
3204     m_cachedTime = MediaTime::invalidTime();
3205     if (!m_player || !m_player-&gt;maximumDurationToCacheMediaTime())
3206         return;
3207 
3208     // Don&#39;t try to cache movie time when playback first starts as the time reported by the engine
3209     // sometimes fluctuates for a short amount of time, so the cached time will be off if we take it
3210     // too early.
3211     static const Seconds minimumTimePlayingBeforeCacheSnapshot = 500_ms;
3212 
3213     m_minimumClockTimeToUpdateCachedTime = MonotonicTime::now() + minimumTimePlayingBeforeCacheSnapshot;
3214 }
3215 
3216 // playback state
3217 double HTMLMediaElement::currentTime() const
3218 {
3219     return currentMediaTime().toDouble();
3220 }
3221 
3222 MediaTime HTMLMediaElement::currentMediaTime() const
3223 {
3224 #if LOG_CACHED_TIME_WARNINGS
3225     static const MediaTime minCachedDeltaForWarning = MediaTime::create(1, 100);
3226 #endif
3227 
3228     if (!m_player)
3229         return MediaTime::zeroTime();
3230 
3231     if (m_seeking) {
3232         INFO_LOG(LOGIDENTIFIER, &quot;seeking, returning&quot;, m_lastSeekTime);
3233         return m_lastSeekTime;
3234     }
3235 
3236     if (m_cachedTime.isValid() &amp;&amp; m_paused) {
3237 #if LOG_CACHED_TIME_WARNINGS
3238         MediaTime delta = m_cachedTime - m_player-&gt;currentTime();
3239         if (delta &gt; minCachedDeltaForWarning)
3240             WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when paused&quot;);
3241 #endif
3242         return m_cachedTime;
3243     }
3244 
3245     // Is it too soon use a cached time?
3246     MonotonicTime now = MonotonicTime::now();
3247     double maximumDurationToCacheMediaTime = m_player-&gt;maximumDurationToCacheMediaTime();
3248 
3249     if (maximumDurationToCacheMediaTime &amp;&amp; m_cachedTime.isValid() &amp;&amp; !m_paused &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime) {
3250         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3251 
3252         // Not too soon, use the cached time only if it hasn&#39;t expired.
3253         if (clockDelta.seconds() &lt; maximumDurationToCacheMediaTime) {
3254             MediaTime adjustedCacheTime = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds());
3255 
3256 #if LOG_CACHED_TIME_WARNINGS
3257             MediaTime delta = adjustedCacheTime - m_player-&gt;currentTime();
3258             if (delta &gt; minCachedDeltaForWarning)
3259                 WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when playing&quot;);
3260 #endif
3261             return adjustedCacheTime;
3262         }
3263     }
3264 
3265 #if LOG_CACHED_TIME_WARNINGS
3266     if (maximumDurationToCacheMediaTime &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime &amp;&amp; m_cachedTime != MediaPlayer::invalidTime()) {
3267         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3268         MediaTime delta = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds()) - m_player-&gt;currentTime();
3269         WARNING_LOG(LOGIDENTIFIER, &quot;cached time was &quot;, delta, &quot; seconds off of media time when it expired&quot;);
3270     }
3271 #endif
3272 
3273     refreshCachedTime();
3274 
3275     if (m_cachedTime.isInvalid())
3276         return MediaTime::zeroTime();
3277 
3278     return m_cachedTime;
3279 }
3280 
3281 void HTMLMediaElement::setCurrentTime(double time)
3282 {
3283     setCurrentTime(MediaTime::createWithDouble(time));
3284 }
3285 
3286 void HTMLMediaElement::setCurrentTimeWithTolerance(double time, double toleranceBefore, double toleranceAfter)
3287 {
3288     seekWithTolerance(MediaTime::createWithDouble(time), MediaTime::createWithDouble(toleranceBefore), MediaTime::createWithDouble(toleranceAfter), true);
3289 }
3290 
3291 void HTMLMediaElement::setCurrentTime(const MediaTime&amp; time)
3292 {
3293     if (m_mediaController)
3294         return;
3295 
3296     seekInternal(time);
3297 }
3298 
3299 ExceptionOr&lt;void&gt; HTMLMediaElement::setCurrentTimeForBindings(double time)
3300 {
3301     if (m_mediaController)
3302         return Exception { InvalidStateError };
3303     seek(MediaTime::createWithDouble(time));
3304     return { };
3305 }
3306 
3307 double HTMLMediaElement::duration() const
3308 {
3309     return durationMediaTime().toDouble();
3310 }
3311 
3312 MediaTime HTMLMediaElement::durationMediaTime() const
3313 {
3314     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)
3315         return m_player-&gt;duration();
3316 
3317     return MediaTime::invalidTime();
3318 }
3319 
3320 bool HTMLMediaElement::paused() const
3321 {
3322     // As of this writing, JavaScript garbage collection calls this function directly. In the past
3323     // we had problems where this was called on an object after a bad cast. The assertion below
3324     // made our regression test detect the problem, so we should keep it because of that. But note
3325     // that the value of the assertion relies on the compiler not being smart enough to know that
3326     // isHTMLUnknownElement is guaranteed to return false for an HTMLMediaElement.
3327     ASSERT(!isHTMLUnknownElement());
3328 
3329     return m_paused;
3330 }
3331 
3332 double HTMLMediaElement::defaultPlaybackRate() const
3333 {
3334 #if ENABLE(MEDIA_STREAM)
3335     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3336     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3337     // A MediaStream is not seekable. Therefore, this attribute must always have the
3338     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3339     // that the ratechange event will not fire.
3340     if (m_mediaStreamSrcObject)
3341         return 1;
3342 #endif
3343 
3344     return m_defaultPlaybackRate;
3345 }
3346 
3347 void HTMLMediaElement::setDefaultPlaybackRate(double rate)
3348 {
3349 #if ENABLE(MEDIA_STREAM)
3350     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3351     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3352     // A MediaStream is not seekable. Therefore, this attribute must always have the
3353     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3354     // that the ratechange event will not fire.
3355     if (m_mediaStreamSrcObject)
3356         return;
3357 #endif
3358 
3359     if (m_defaultPlaybackRate == rate)
3360         return;
3361 
3362     ALWAYS_LOG(LOGIDENTIFIER, rate);
3363     m_defaultPlaybackRate = rate;
3364     scheduleEvent(eventNames().ratechangeEvent);
3365 }
3366 
3367 double HTMLMediaElement::effectivePlaybackRate() const
3368 {
3369     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_reportedPlaybackRate;
3370 }
3371 
3372 double HTMLMediaElement::requestedPlaybackRate() const
3373 {
3374     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_requestedPlaybackRate;
3375 }
3376 
3377 double HTMLMediaElement::playbackRate() const
3378 {
3379 #if ENABLE(MEDIA_STREAM)
3380     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3381     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3382     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3383     // means that the ratechange event will not fire.
3384     if (m_mediaStreamSrcObject)
3385         return 1;
3386 #endif
3387 
3388     return m_requestedPlaybackRate;
3389 }
3390 
3391 void HTMLMediaElement::setPlaybackRate(double rate)
3392 {
3393     ALWAYS_LOG(LOGIDENTIFIER, rate);
3394 
3395 #if ENABLE(MEDIA_STREAM)
3396     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3397     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3398     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3399     // means that the ratechange event will not fire.
3400     if (m_mediaStreamSrcObject)
3401         return;
3402 #endif
3403 
3404     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != rate &amp;&amp; !m_mediaController)
3405         m_player-&gt;setRate(rate);
3406 
3407     if (m_requestedPlaybackRate != rate) {
3408         m_reportedPlaybackRate = m_requestedPlaybackRate = rate;
3409         invalidateCachedTime();
3410         scheduleEvent(eventNames().ratechangeEvent);
3411     }
3412 }
3413 
3414 void HTMLMediaElement::updatePlaybackRate()
3415 {
3416     double requestedRate = requestedPlaybackRate();
3417     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != requestedRate)
3418         m_player-&gt;setRate(requestedRate);
3419 }
3420 
3421 bool HTMLMediaElement::webkitPreservesPitch() const
3422 {
3423     return m_webkitPreservesPitch;
3424 }
3425 
3426 void HTMLMediaElement::setWebkitPreservesPitch(bool preservesPitch)
3427 {
3428     INFO_LOG(LOGIDENTIFIER, preservesPitch);
3429 
3430     m_webkitPreservesPitch = preservesPitch;
3431 
3432     if (!m_player)
3433         return;
3434 
3435     m_player-&gt;setPreservesPitch(preservesPitch);
3436 }
3437 
3438 bool HTMLMediaElement::ended() const
3439 {
3440 #if ENABLE(MEDIA_STREAM)
3441     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3442     // When the MediaStream state moves from the active to the inactive state, the User Agent
3443     // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
3444     if (m_mediaStreamSrcObject &amp;&amp; m_player &amp;&amp; m_player-&gt;ended())
3445         return true;
3446 #endif
3447 
3448     // 4.8.10.8 Playing the media resource
3449     // The ended attribute must return true if the media element has ended
3450     // playback and the direction of playback is forwards, and false otherwise.
3451     return endedPlayback() &amp;&amp; requestedPlaybackRate() &gt; 0;
3452 }
3453 
3454 bool HTMLMediaElement::autoplay() const
3455 {
3456     return hasAttributeWithoutSynchronization(autoplayAttr);
3457 }
3458 
3459 String HTMLMediaElement::preload() const
3460 {
3461 #if ENABLE(MEDIA_STREAM)
3462     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3463     // &quot;preload&quot; - On getting: none. On setting: ignored.
3464     if (m_mediaStreamSrcObject)
3465         return &quot;none&quot;_s;
3466 #endif
3467 
3468     switch (m_preload) {
3469     case MediaPlayer::None:
3470         return &quot;none&quot;_s;
3471     case MediaPlayer::MetaData:
3472         return &quot;metadata&quot;_s;
3473     case MediaPlayer::Auto:
3474         return &quot;auto&quot;_s;
3475     }
3476 
3477     ASSERT_NOT_REACHED();
3478     return String();
3479 }
3480 
3481 void HTMLMediaElement::setPreload(const String&amp; preload)
3482 {
3483     INFO_LOG(LOGIDENTIFIER, preload);
3484 #if ENABLE(MEDIA_STREAM)
3485     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3486     // &quot;preload&quot; - On getting: none. On setting: ignored.
3487     if (m_mediaStreamSrcObject)
3488         return;
3489 #endif
3490 
3491     setAttributeWithoutSynchronization(preloadAttr, preload);
3492 }
3493 
3494 void HTMLMediaElement::play(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
3495 {
3496     ALWAYS_LOG(LOGIDENTIFIER);
3497 
3498     auto success = m_mediaSession-&gt;playbackPermitted();
3499     if (!success) {
3500         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3501             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3502         promise.reject(NotAllowedError);
3503         return;
3504     }
3505 
3506     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
3507         promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
3508         return;
3509     }
3510 
3511     if (processingUserGestureForMedia())
<a name="49" id="anc49"></a><span class="line-modified">3512         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
3513 
3514     m_pendingPlayPromises.append(WTFMove(promise));
3515     playInternal();
3516 }
3517 
3518 void HTMLMediaElement::play()
3519 {
3520     ALWAYS_LOG(LOGIDENTIFIER);
3521 
3522     auto success = m_mediaSession-&gt;playbackPermitted();
3523     if (!success) {
3524         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3525             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3526         return;
3527     }
3528     if (processingUserGestureForMedia())
<a name="50" id="anc50"></a><span class="line-modified">3529         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
3530 
3531     playInternal();
3532 }
3533 
3534 void HTMLMediaElement::playInternal()
3535 {
3536     ALWAYS_LOG(LOGIDENTIFIER);
3537 
3538     if (isSuspended()) {
<a name="51" id="anc51"></a><span class="line-modified">3539         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
3540         return;
3541     }
3542 
3543     if (!document().hasBrowsingContext()) {
<a name="52" id="anc52"></a><span class="line-modified">3544         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
3545         return;
3546     }
3547 
3548     if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<a name="53" id="anc53"></a><span class="line-modified">3549         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
3550         return;
3551     }
3552 
3553     // 4.8.10.9. Playing the media resource
3554     if (!m_player || m_networkState == NETWORK_EMPTY)
3555         selectMediaResource();
3556 
3557     if (endedPlayback())
3558         seekInternal(MediaTime::zeroTime());
3559 
3560     if (m_mediaController)
3561         m_mediaController-&gt;bringElementUpToSpeed(*this);
3562 
3563     if (m_paused) {
3564         m_paused = false;
3565         invalidateCachedTime();
<a name="54" id="anc54"></a><span class="line-modified">3566         m_playbackStartedTime = currentMediaTime().toDouble();</span>





3567         scheduleEvent(eventNames().playEvent);
3568 
3569 #if ENABLE(MEDIA_SESSION)
3570         // 6.3 Activating a media session from a media element
3571         // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
3572         // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then
3573         // 1. Let media session be the value of the current media session.
3574         // 2. If we are not currently in media session&#39;s list of active participating media elements then append
3575         //    ourselves to this list.
3576         // 3. Let activated be the result of running the media session invocation algorithm for media session.
3577         // 4. If activated is failure, pause ourselves.
3578         if (m_readyState == HAVE_ENOUGH_DATA || m_readyState == HAVE_FUTURE_DATA) {
3579             if (m_session) {
3580                 m_session-&gt;addActiveMediaElement(*this);
3581 
3582                 if (m_session-&gt;kind() == MediaSessionKind::Content) {
3583                     if (Page* page = document().page())
3584                         page-&gt;chrome().client().focusedContentMediaElementDidChange(m_elementID);
3585                 }
3586 
3587                 if (!m_session-&gt;invoke()) {
3588                     pause();
3589                     return;
3590                 }
3591             }
3592         }
3593 #endif
3594         if (m_readyState &lt;= HAVE_CURRENT_DATA)
3595             scheduleEvent(eventNames().waitingEvent);
3596     } else if (m_readyState &gt;= HAVE_FUTURE_DATA)
3597         scheduleResolvePendingPlayPromises();
3598 
3599     if (processingUserGestureForMedia()) {
3600         if (m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay) {
3601             handleAutoplayEvent(AutoplayEvent::DidPlayMediaWithUserGesture);
3602             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3603         } else
3604             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithUserGesture);
3605     } else
3606         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
3607 
3608     m_autoplaying = false;
3609     updatePlayState();
3610 }
3611 
3612 void HTMLMediaElement::pause()
3613 {
3614     ALWAYS_LOG(LOGIDENTIFIER);
3615 
3616     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
3617 
3618     if (m_waitingToEnterFullscreen)
3619         m_waitingToEnterFullscreen = false;
3620 
3621     if (!m_mediaSession-&gt;playbackPermitted())
3622         return;
3623 
3624     if (processingUserGestureForMedia())
<a name="55" id="anc55"></a><span class="line-modified">3625         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3626 
3627     pauseInternal();
3628 }
3629 
3630 
3631 void HTMLMediaElement::pauseInternal()
3632 {
3633     ALWAYS_LOG(LOGIDENTIFIER);
3634 
3635     if (isSuspended()) {
<a name="56" id="anc56"></a><span class="line-modified">3636         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
3637         return;
3638     }
3639 
3640     if (!document().hasBrowsingContext()) {
<a name="57" id="anc57"></a><span class="line-modified">3641         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
3642         return;
3643     }
3644 
3645     if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<a name="58" id="anc58"></a><span class="line-modified">3646         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
3647         return;
3648     }
3649 
3650     // 4.8.10.9. Playing the media resource
3651     if (!m_player || m_networkState == NETWORK_EMPTY) {
3652         // Unless the restriction on media requiring user action has been lifted
3653         // don&#39;t trigger loading if a script calls pause().
3654         if (!m_mediaSession-&gt;playbackPermitted())
3655             return;
3656         selectMediaResource();
3657     }
3658 
3659     m_autoplaying = false;
3660 
3661     if (processingUserGestureForMedia())
3662         userDidInterfereWithAutoplay();
3663 
3664     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3665 
3666     if (!m_paused) {
3667         m_paused = true;
3668         scheduleTimeupdateEvent(false);
3669         scheduleEvent(eventNames().pauseEvent);
3670         scheduleRejectPendingPlayPromises(DOMException::create(AbortError));
3671         if (MemoryPressureHandler::singleton().isUnderMemoryPressure())
3672             purgeBufferedDataIfPossible();
3673     }
3674 
3675     updatePlayState();
3676 }
3677 
3678 #if ENABLE(MEDIA_SOURCE)
3679 
3680 void HTMLMediaElement::detachMediaSource()
3681 {
3682     if (!m_mediaSource)
3683         return;
3684 
3685     m_mediaSource-&gt;detachFromElement(*this);
3686     m_mediaSource = nullptr;
3687 }
3688 
3689 #endif
3690 
3691 bool HTMLMediaElement::loop() const
3692 {
3693     return hasAttributeWithoutSynchronization(loopAttr);
3694 }
3695 
<a name="59" id="anc59"></a><span class="line-modified">3696 void HTMLMediaElement::setLoop(bool b)</span>
3697 {
<a name="60" id="anc60"></a><span class="line-modified">3698     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">3699     setBooleanAttribute(loopAttr, b);</span>
3700 }
3701 
3702 bool HTMLMediaElement::controls() const
3703 {
3704     RefPtr&lt;Frame&gt; frame = document().frame();
3705 
3706     // always show controls when scripting is disabled
3707     if (frame &amp;&amp; !frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
3708         return true;
3709 
3710     return hasAttributeWithoutSynchronization(controlsAttr);
3711 }
3712 
<a name="61" id="anc61"></a><span class="line-modified">3713 void HTMLMediaElement::setControls(bool b)</span>
3714 {
<a name="62" id="anc62"></a><span class="line-modified">3715     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">3716     setBooleanAttribute(controlsAttr, b);</span>
3717 }
3718 
3719 double HTMLMediaElement::volume() const
3720 {
3721     return m_volume;
3722 }
3723 
3724 ExceptionOr&lt;void&gt; HTMLMediaElement::setVolume(double volume)
3725 {
3726     INFO_LOG(LOGIDENTIFIER, volume);
3727 
3728     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
3729         return Exception { IndexSizeError };
3730 
<a name="63" id="anc63"></a><span class="line-removed">3731 #if !PLATFORM(IOS_FAMILY)</span>
3732     if (m_volume == volume)
3733         return { };
3734 
<a name="64" id="anc64"></a>
3735     if (volume &amp;&amp; processingUserGestureForMedia())
<a name="65" id="anc65"></a><span class="line-modified">3736         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3737 
3738     m_volume = volume;
3739     m_volumeInitialized = true;
3740     updateVolume();
3741     scheduleEvent(eventNames().volumechangeEvent);
3742 
3743     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3744         pauseInternal();
3745         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3746     }
<a name="66" id="anc66"></a>










3747 #endif
<a name="67" id="anc67"></a>
3748     return { };
3749 }
3750 
3751 bool HTMLMediaElement::muted() const
3752 {
3753     return m_explicitlyMuted ? m_muted : hasAttributeWithoutSynchronization(mutedAttr);
3754 }
3755 
3756 void HTMLMediaElement::setMuted(bool muted)
3757 {
3758     INFO_LOG(LOGIDENTIFIER, muted);
3759 
3760     bool mutedStateChanged = m_muted != muted;
3761     if (mutedStateChanged || !m_explicitlyMuted) {
3762         if (processingUserGestureForMedia()) {
<a name="68" id="anc68"></a><span class="line-modified">3763             removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3764 
3765             if (hasAudio() &amp;&amp; muted)
3766                 userDidInterfereWithAutoplay();
3767         }
3768 
3769         m_muted = muted;
3770         m_explicitlyMuted = true;
3771 
3772         // Avoid recursion when the player reports volume changes.
3773         if (!processingMediaPlayerCallback()) {
3774             if (m_player) {
3775                 m_player-&gt;setMuted(effectiveMuted());
3776                 if (hasMediaControls())
3777                     mediaControls()-&gt;changedMute();
3778             }
3779         }
3780 
3781         if (mutedStateChanged)
3782             scheduleEvent(eventNames().volumechangeEvent);
3783 
3784         updateShouldPlay();
3785 
3786 #if ENABLE(MEDIA_SESSION)
3787         document().updateIsPlayingMedia(m_elementID);
3788 #else
3789         document().updateIsPlayingMedia();
3790 #endif
3791 
3792 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3793         scheduleUpdateMediaState();
3794 #endif
3795         m_mediaSession-&gt;canProduceAudioChanged();
3796     }
3797 
3798     schedulePlaybackControlsManagerUpdate();
3799 }
3800 
3801 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
3802 void HTMLMediaElement::hardwareMutedStateDidChange(AudioSession* session)
3803 {
3804     if (!session-&gt;isMuted())
3805         return;
3806 
3807     if (!hasAudio())
3808         return;
3809 
3810     if (effectiveMuted() || !volume())
3811         return;
3812 
3813     INFO_LOG(LOGIDENTIFIER);
3814     userDidInterfereWithAutoplay();
3815 }
3816 #endif
3817 
3818 void HTMLMediaElement::togglePlayState()
3819 {
3820     INFO_LOG(LOGIDENTIFIER, &quot;canPlay() is &quot;, canPlay());
3821 
3822     // We can safely call the internal play/pause methods, which don&#39;t check restrictions, because
3823     // this method is only called from the built-in media controller
3824     if (canPlay()) {
3825         updatePlaybackRate();
3826         playInternal();
3827     } else
3828         pauseInternal();
3829 }
3830 
3831 void HTMLMediaElement::beginScrubbing()
3832 {
3833     INFO_LOG(LOGIDENTIFIER, &quot;paused() is &quot;, paused());
3834 
3835     if (!paused()) {
3836         if (ended()) {
3837             // Because a media element stays in non-paused state when it reaches end, playback resumes
3838             // when the slider is dragged from the end to another position unless we pause first. Do
3839             // a &quot;hard pause&quot; so an event is generated, since we want to stay paused after scrubbing finishes.
3840             pause();
3841         } else {
3842             // Not at the end but we still want to pause playback so the media engine doesn&#39;t try to
3843             // continue playing during scrubbing. Pause without generating an event as we will
3844             // unpause after scrubbing finishes.
3845             setPausedInternal(true);
3846         }
3847     }
3848 
3849     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3850 }
3851 
3852 void HTMLMediaElement::endScrubbing()
3853 {
3854     INFO_LOG(LOGIDENTIFIER, &quot;m_pausedInternal is&quot;, m_pausedInternal);
3855 
3856     if (m_pausedInternal)
3857         setPausedInternal(false);
3858 }
3859 
3860 void HTMLMediaElement::beginScanning(ScanDirection direction)
3861 {
3862     m_scanType = supportsScanning() ? Scan : Seek;
3863     m_scanDirection = direction;
3864 
3865     if (m_scanType == Seek) {
3866         // Scanning by seeking requires the video to be paused during scanning.
3867         m_actionAfterScan = paused() ? Nothing : Play;
3868         pause();
3869     } else {
3870         // Scanning by scanning requires the video to be playing during scanninging.
3871         m_actionAfterScan = paused() ? Pause : Nothing;
3872         play();
3873         setPlaybackRate(nextScanRate());
3874     }
3875 
3876     m_scanTimer.start(0_s, m_scanType == Seek ? SeekRepeatDelay : ScanRepeatDelay);
3877 }
3878 
3879 void HTMLMediaElement::endScanning()
3880 {
3881     if (m_scanType == Scan)
3882         setPlaybackRate(defaultPlaybackRate());
3883 
3884     if (m_actionAfterScan == Play)
3885         play();
3886     else if (m_actionAfterScan == Pause)
3887         pause();
3888 
3889     if (m_scanTimer.isActive())
3890         m_scanTimer.stop();
3891 }
3892 
3893 double HTMLMediaElement::nextScanRate()
3894 {
3895     double rate = std::min(ScanMaximumRate, fabs(playbackRate() * 2));
3896     if (m_scanDirection == Backward)
3897         rate *= -1;
3898 #if PLATFORM(IOS_FAMILY)
3899     rate = std::min(std::max(rate, minFastReverseRate()), maxFastForwardRate());
3900 #endif
3901     return rate;
3902 }
3903 
3904 void HTMLMediaElement::scanTimerFired()
3905 {
3906     if (m_scanType == Seek) {
3907         double seekTime = m_scanDirection == Forward ? SeekTime : -SeekTime;
3908         setCurrentTime(currentTime() + seekTime);
3909     } else
3910         setPlaybackRate(nextScanRate());
3911 }
3912 
3913 // The spec says to fire periodic timeupdate events (those sent while playing) every
3914 // &quot;15 to 250ms&quot;, we choose the slowest frequency
3915 static const Seconds maxTimeupdateEventFrequency { 250_ms };
3916 
3917 void HTMLMediaElement::startPlaybackProgressTimer()
3918 {
3919     if (m_playbackProgressTimer.isActive())
3920         return;
3921 
3922     m_previousProgressTime = MonotonicTime::now();
3923     m_playbackProgressTimer.startRepeating(maxTimeupdateEventFrequency);
3924 }
3925 
3926 void HTMLMediaElement::playbackProgressTimerFired()
3927 {
3928     ASSERT(m_player);
3929 
3930     if (m_fragmentEndTime.isValid() &amp;&amp; currentMediaTime() &gt;= m_fragmentEndTime &amp;&amp; requestedPlaybackRate() &gt; 0) {
3931         m_fragmentEndTime = MediaTime::invalidTime();
3932         if (!m_mediaController &amp;&amp; !m_paused) {
3933             // changes paused to true and fires a simple event named pause at the media element.
3934             pauseInternal();
3935         }
3936     }
3937 
3938     scheduleTimeupdateEvent(true);
3939 
3940     if (!requestedPlaybackRate())
3941         return;
3942 
3943     if (!m_paused &amp;&amp; hasMediaControls())
3944         mediaControls()-&gt;playbackProgressed();
3945 
3946 #if ENABLE(VIDEO_TRACK)
3947     updateActiveTextTrackCues(currentMediaTime());
3948 #endif
3949 
3950 #if ENABLE(MEDIA_SOURCE)
3951     if (m_mediaSource)
3952         m_mediaSource-&gt;monitorSourceBuffers();
3953 #endif
3954 
3955     bool playbackStarted = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithUserGesture || m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture;
3956     if (!seeking() &amp;&amp; playbackStarted &amp;&amp; currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold) {
3957         handleAutoplayEvent(m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture ? AutoplayEvent::DidAutoplayMediaPastThresholdWithoutUserInterference : AutoplayEvent::DidPlayMediaWithUserGesture);
3958         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3959     }
3960 }
3961 
3962 void HTMLMediaElement::scheduleTimeupdateEvent(bool periodicEvent)
3963 {
3964     MonotonicTime now = MonotonicTime::now();
3965     Seconds timedelta = now - m_clockTimeAtLastUpdateEvent;
3966 
3967     // throttle the periodic events
3968     if (periodicEvent &amp;&amp; timedelta &lt; maxTimeupdateEventFrequency)
3969         return;
3970 
3971     // Some media engines make multiple &quot;time changed&quot; callbacks at the same time, but we only want one
3972     // event at a given time so filter here
3973     MediaTime movieTime = currentMediaTime();
3974     if (movieTime != m_lastTimeUpdateEventMovieTime) {
3975         scheduleEvent(eventNames().timeupdateEvent);
3976         m_clockTimeAtLastUpdateEvent = now;
3977         m_lastTimeUpdateEventMovieTime = movieTime;
3978     }
3979 }
3980 
3981 bool HTMLMediaElement::canPlay() const
3982 {
3983     return paused() || ended() || m_readyState &lt; HAVE_METADATA;
3984 }
3985 
3986 double HTMLMediaElement::percentLoaded() const
3987 {
3988     if (!m_player)
3989         return 0;
3990     MediaTime duration = m_player-&gt;duration();
3991 
3992     if (!duration || duration.isPositiveInfinite() || duration.isNegativeInfinite())
3993         return 0;
3994 
3995     MediaTime buffered = MediaTime::zeroTime();
3996     bool ignored;
3997     std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges = m_player-&gt;buffered();
3998     for (unsigned i = 0; i &lt; timeRanges-&gt;length(); ++i) {
3999         MediaTime start = timeRanges-&gt;start(i, ignored);
4000         MediaTime end = timeRanges-&gt;end(i, ignored);
4001         buffered += end - start;
4002     }
4003     return buffered.toDouble() / duration.toDouble();
4004 }
4005 
4006 #if ENABLE(VIDEO_TRACK)
4007 
4008 void HTMLMediaElement::mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp; track)
4009 {
4010     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
4011         pauseInternal();
4012         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
4013     }
4014 
4015     addAudioTrack(AudioTrack::create(*this, track));
4016 }
4017 
4018 void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
4019 {
4020     // 4.8.10.12.2 Sourcing in-band text tracks
4021     // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
4022     auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
4023     textTrack-&gt;setMediaElement(this);
4024 
4025     // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
4026     // as defined by the relevant specification. If there is no label in that data, then the label must
4027     // be set to the empty string.
4028     // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
4029     // for the format in question.
4030     // 4. If the new text track&#39;s kind is metadata, then set the text track in-band metadata track dispatch type
4031     // as follows, based on the type of the media resource:
4032     // 5. Populate the new text track&#39;s list of cues with the cues parsed so far, folllowing the guidelines for exposing
4033     // cues, and begin updating it dynamically as necessary.
4034     //   - Thess are all done by the media engine.
4035 
4036     // 6. Set the new text track&#39;s readiness state to loaded.
4037     textTrack-&gt;setReadinessState(TextTrack::Loaded);
4038 
4039     // 7. Set the new text track&#39;s mode to the mode consistent with the user&#39;s preferences and the requirements of
4040     // the relevant specification for the data.
4041     //  - This will happen in configureTextTracks()
4042     scheduleConfigureTextTracks();
4043 
4044     // 8. Add the new text track to the media element&#39;s list of text tracks.
4045     // 9. Fire an event with the name addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent
4046     // interface, with the track attribute initialized to the text track&#39;s TextTrack object, at the media element&#39;s
4047     // textTracks attribute&#39;s TextTrackList object.
4048     addTextTrack(WTFMove(textTrack));
4049 }
4050 
4051 void HTMLMediaElement::mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp; track)
4052 {
4053     addVideoTrack(VideoTrack::create(*this, track));
4054 }
4055 
4056 void HTMLMediaElement::mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp; track)
4057 {
4058     track.willBeRemoved();
4059 }
4060 
4061 void HTMLMediaElement::mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp; track)
4062 {
4063     track.willBeRemoved();
4064 }
4065 
4066 void HTMLMediaElement::mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp; track)
4067 {
4068     track.willBeRemoved();
4069 }
4070 
4071 void HTMLMediaElement::closeCaptionTracksChanged()
4072 {
4073     if (hasMediaControls())
4074         mediaControls()-&gt;closedCaptionTracksChanged();
4075 }
4076 
4077 void HTMLMediaElement::addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4078 {
4079     ensureAudioTracks().append(WTFMove(track));
4080 }
4081 
4082 void HTMLMediaElement::addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track)
4083 {
4084     if (!m_requireCaptionPreferencesChangedCallbacks) {
4085         m_requireCaptionPreferencesChangedCallbacks = true;
4086         Document&amp; document = this-&gt;document();
4087         document.registerForCaptionPreferencesChangedCallbacks(*this);
4088         if (Page* page = document.page())
4089             m_captionDisplayMode = page-&gt;group().captionPreferences().captionDisplayMode();
4090     }
4091 
4092     ensureTextTracks().append(WTFMove(track));
4093 
4094     closeCaptionTracksChanged();
4095 }
4096 
4097 void HTMLMediaElement::addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4098 {
4099     ensureVideoTracks().append(WTFMove(track));
4100 }
4101 
4102 void HTMLMediaElement::removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4103 {
4104     track-&gt;clearClient();
4105     m_audioTracks-&gt;remove(track.get());
4106 }
4107 
4108 void HTMLMediaElement::removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track, bool scheduleEvent)
4109 {
4110     TrackDisplayUpdateScope scope { *this };
4111     if (auto cues = makeRefPtr(track-&gt;cues()))
4112         textTrackRemoveCues(track, *cues);
4113     track-&gt;clearClient();
4114     if (m_textTracks)
4115         m_textTracks-&gt;remove(track, scheduleEvent);
4116 
4117     closeCaptionTracksChanged();
4118 }
4119 
4120 void HTMLMediaElement::removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4121 {
4122     track-&gt;clearClient();
4123     m_videoTracks-&gt;remove(track);
4124 }
4125 
4126 void HTMLMediaElement::forgetResourceSpecificTracks()
4127 {
4128     while (m_audioTracks &amp;&amp;  m_audioTracks-&gt;length())
4129         removeAudioTrack(*m_audioTracks-&gt;lastItem());
4130 
4131     if (m_textTracks) {
4132         TrackDisplayUpdateScope scope { *this };
4133         for (int i = m_textTracks-&gt;length() - 1; i &gt;= 0; --i) {
4134             auto track = makeRef(*m_textTracks-&gt;item(i));
4135             if (track-&gt;trackType() == TextTrack::InBand)
4136                 removeTextTrack(WTFMove(track), false);
4137         }
4138     }
4139 
4140     while (m_videoTracks &amp;&amp;  m_videoTracks-&gt;length())
4141         removeVideoTrack(*m_videoTracks-&gt;lastItem());
4142 }
4143 
4144 ExceptionOr&lt;TextTrack&amp;&gt; HTMLMediaElement::addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language)
4145 {
4146     // 4.8.10.12.4 Text track API
4147     // The addTextTrack(kind, label, language) method of media elements, when invoked, must run the following steps:
4148 
4149     // 1. If kind is not one of the following strings, then throw a SyntaxError exception and abort these steps
4150     if (!TextTrack::isValidKindKeyword(kind))
4151         return Exception { TypeError };
4152 
4153     // 2. If the label argument was omitted, let label be the empty string.
4154     // 3. If the language argument was omitted, let language be the empty string.
4155     // 4. Create a new TextTrack object.
4156 
4157     // 5. Create a new text track corresponding to the new object, and set its text track kind to kind, its text
4158     // track label to label, its text track language to language...
4159     auto track = TextTrack::create(ActiveDOMObject::scriptExecutionContext(), this, kind, emptyString(), label, language);
4160     auto&amp; trackReference = track.get();
4161 
4162     // Note, due to side effects when changing track parameters, we have to
4163     // first append the track to the text track list.
4164 
4165     // 6. Add the new text track to the media element&#39;s list of text tracks.
4166     addTextTrack(WTFMove(track));
4167 
4168     // ... its text track readiness state to the text track loaded state ...
4169     trackReference.setReadinessState(TextTrack::Loaded);
4170 
4171     // ... its text track mode to the text track hidden mode, and its text track list of cues to an empty list ...
4172     trackReference.setMode(TextTrack::Mode::Hidden);
4173 
4174     return trackReference;
4175 }
4176 
4177 AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
4178 {
4179     if (!m_audioTracks)
4180         m_audioTracks = AudioTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4181 
4182     return *m_audioTracks;
4183 }
4184 
4185 TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
4186 {
4187     if (!m_textTracks)
4188         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4189 
4190     return *m_textTracks;
4191 }
4192 
4193 VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
4194 {
4195     if (!m_videoTracks)
4196         m_videoTracks = VideoTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
4197 
4198     return *m_videoTracks;
4199 }
4200 
4201 void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
4202 {
4203     ASSERT(trackElement.hasTagName(trackTag));
4204 
4205     // 4.8.10.12.3 Sourcing out-of-band text tracks
4206     // When a track element&#39;s parent element changes and the new parent is a media element,
4207     // then the user agent must add the track element&#39;s corresponding text track to the
4208     // media element&#39;s list of text tracks ... [continues in TextTrackList::append]
4209     addTextTrack(trackElement.track());
4210 
4211     // Do not schedule the track loading until parsing finishes so we don&#39;t start before all tracks
4212     // in the markup have been added.
4213     if (!m_parsingInProgress)
4214         scheduleConfigureTextTracks();
4215 
4216     if (hasMediaControls())
4217         mediaControls()-&gt;closedCaptionTracksChanged();
4218 }
4219 
4220 void HTMLMediaElement::didRemoveTextTrack(HTMLTrackElement&amp; trackElement)
4221 {
4222     ASSERT(trackElement.hasTagName(trackTag));
4223 
4224     auto&amp; textTrack = trackElement.track();
4225 
4226     textTrack.setHasBeenConfigured(false);
4227 
4228     if (!m_textTracks)
4229         return;
4230 
4231     // 4.8.10.12.3 Sourcing out-of-band text tracks
4232     // When a track element&#39;s parent element changes and the old parent was a media element,
4233     // then the user agent must remove the track element&#39;s corresponding text track from the
4234     // media element&#39;s list of text tracks.
4235     removeTextTrack(textTrack);
4236 
4237     m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
4238 }
4239 
<a name="69" id="anc69"></a><span class="line-removed">4240 #if ENABLE(VIDEO_TRACK)</span>
4241 void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
4242 {
4243     ASSERT(group.tracks.size());
4244 
4245     Page* page = document().page();
4246     CaptionUserPreferences* captionPreferences = page ? &amp;page-&gt;group().captionPreferences() : 0;
4247     CaptionUserPreferences::CaptionDisplayMode displayMode = captionPreferences ? captionPreferences-&gt;captionDisplayMode() : CaptionUserPreferences::Automatic;
4248 
4249     // First, find the track in the group that should be enabled (if any).
4250     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; currentlyEnabledTracks;
4251     RefPtr&lt;TextTrack&gt; trackToEnable;
4252     RefPtr&lt;TextTrack&gt; defaultTrack;
4253     RefPtr&lt;TextTrack&gt; fallbackTrack;
4254     RefPtr&lt;TextTrack&gt; forcedSubitleTrack;
4255     int highestTrackScore = 0;
4256     int highestForcedScore = 0;
4257 
4258     // If there is a visible track, it has already been configured so it won&#39;t be considered in the loop below. We don&#39;t want to choose another
4259     // track if it is less suitable, and we do want to disable it if another track is more suitable.
4260     int alreadyVisibleTrackScore = 0;
4261     if (group.visibleTrack &amp;&amp; captionPreferences) {
4262         alreadyVisibleTrackScore = captionPreferences-&gt;textTrackSelectionScore(group.visibleTrack.get(), this);
4263         currentlyEnabledTracks.append(group.visibleTrack);
4264     }
4265 
4266     for (size_t i = 0; i &lt; group.tracks.size(); ++i) {
4267         RefPtr&lt;TextTrack&gt; textTrack = group.tracks[i];
4268 
4269         if (m_processingPreferenceChange &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4270             currentlyEnabledTracks.append(textTrack);
4271 
4272         int trackScore = captionPreferences ? captionPreferences-&gt;textTrackSelectionScore(textTrack.get(), this) : 0;
4273         INFO_LOG(LOGIDENTIFIER, &quot;&#39;&quot;, textTrack-&gt;kindKeyword(), &quot;&#39; track with language &#39;&quot;, textTrack-&gt;language(), &quot;&#39; and BCP 47 language &#39;&quot;, textTrack-&gt;validBCP47Language(), &quot;&#39; has score &quot;, trackScore);
4274 
4275         if (trackScore) {
4276 
4277             // * If the text track kind is { [subtitles or captions] [descriptions] } and the user has indicated an interest in having a
4278             // track with this text track kind, text track language, and text track label enabled, and there is no
4279             // other text track in the media element&#39;s list of text tracks with a text track kind of either subtitles
4280             // or captions whose text track mode is showing
4281             // ...
4282             // * If the text track kind is chapters and the text track language is one that the user agent has reason
4283             // to believe is appropriate for the user, and there is no other text track in the media element&#39;s list of
4284             // text tracks with a text track kind of chapters whose text track mode is showing
4285             //    Let the text track mode be showing.
4286             if (trackScore &gt; highestTrackScore &amp;&amp; trackScore &gt; alreadyVisibleTrackScore) {
4287                 highestTrackScore = trackScore;
4288                 trackToEnable = textTrack;
4289             }
4290 
4291             if (!defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4292                 defaultTrack = textTrack;
4293             if (!defaultTrack &amp;&amp; !fallbackTrack)
4294                 fallbackTrack = textTrack;
4295             if (textTrack-&gt;containsOnlyForcedSubtitles() &amp;&amp; trackScore &gt; highestForcedScore) {
4296                 forcedSubitleTrack = textTrack;
4297                 highestForcedScore = trackScore;
4298             }
4299         } else if (!group.visibleTrack &amp;&amp; !defaultTrack &amp;&amp; textTrack-&gt;isDefault()) {
4300             // * If the track element has a default attribute specified, and there is no other text track in the media
4301             // element&#39;s list of text tracks whose text track mode is showing or showing by default
4302             //    Let the text track mode be showing by default.
4303             if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly)
4304                 defaultTrack = textTrack;
4305         }
4306     }
4307 
4308     if (displayMode != CaptionUserPreferences::Manual) {
4309         if (!trackToEnable &amp;&amp; defaultTrack)
4310             trackToEnable = defaultTrack;
4311 
4312         // If no track matches the user&#39;s preferred language, none was marked as &#39;default&#39;, and there is a forced subtitle track
4313         // in the same language as the language of the primary audio track, enable it.
4314         if (!trackToEnable &amp;&amp; forcedSubitleTrack)
4315             trackToEnable = forcedSubitleTrack;
4316 
4317         // If no track matches, don&#39;t disable an already visible track unless preferences say they all should be off.
4318         if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly) {
4319             if (!trackToEnable &amp;&amp; !defaultTrack &amp;&amp; group.visibleTrack)
4320                 trackToEnable = group.visibleTrack;
4321         }
4322 
4323         // If no track matches the user&#39;s preferred language and non was marked &#39;default&#39;, enable the first track
4324         // because the user has explicitly stated a preference for this kind of track.
4325         if (!trackToEnable &amp;&amp; fallbackTrack)
4326             trackToEnable = fallbackTrack;
4327 
4328         if (trackToEnable)
4329             m_subtitleTrackLanguage = trackToEnable-&gt;language();
4330         else
4331             m_subtitleTrackLanguage = emptyString();
4332     }
4333 
4334     if (currentlyEnabledTracks.size()) {
4335         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4336             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4337             if (textTrack != trackToEnable)
4338                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4339         }
4340     }
4341 
4342     if (trackToEnable) {
4343         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4344 
4345         // If user preferences indicate we should always display captions, make sure we reflect the
4346         // proper status via the webkitClosedCaptionsVisible API call:
4347         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4348             m_webkitLegacyClosedCaptionOverride = true;
4349     }
4350 
4351     m_processingPreferenceChange = false;
4352 }
<a name="70" id="anc70"></a><span class="line-modified">4353 #endif</span>
4354 static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
4355 {
4356     JSC::VM&amp; vm = globalObject.vm();
4357     auto scope = DECLARE_THROW_SCOPE(vm);
4358     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
4359 
4360     // Retrieve the controller through the JS object graph
4361     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4362     if (!mediaJSWrapperObject)
4363         return JSC::jsNull();
4364 
<a name="71" id="anc71"></a><span class="line-modified">4365     JSC::Identifier controlsHost = JSC::Identifier::fromString(&amp;vm, &quot;controlsHost&quot;);</span>
4366     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
4367     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4368 
4369     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4370     if (!controlsHostJSWrapperObject)
4371         return JSC::jsNull();
4372 
<a name="72" id="anc72"></a><span class="line-modified">4373     JSC::Identifier controllerID = JSC::Identifier::fromString(&amp;vm, &quot;controller&quot;);</span>
4374     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
4375     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4376 
4377     return controllerJSWrapper;
4378 }
4379 
4380 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4381 {
4382     ASSERT(!m_creatingControls);
4383     m_creatingControls = true;
4384     ensureUserAgentShadowRoot();
4385     m_creatingControls = false;
4386 }
4387 
4388 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4389 {
4390     Page* page = document().page();
4391     if (!page)
4392         return false;
4393 
4394     auto pendingActivity = makePendingActivity(*this);
4395     auto&amp; world = ensureIsolatedWorld();
4396     auto&amp; scriptController = document().frame()-&gt;script();
4397     auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
4398     auto&amp; vm = globalObject-&gt;vm();
4399     JSC::JSLockHolder lock(vm);
4400     auto scope = DECLARE_THROW_SCOPE(vm);
4401     auto* exec = globalObject-&gt;globalExec();
4402 
4403     RETURN_IF_EXCEPTION(scope, false);
4404 
4405     return task(*globalObject, *exec, scriptController, world);
4406 }
4407 
4408 void HTMLMediaElement::updateCaptionContainer()
4409 {
4410 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4411     if (m_haveSetUpCaptionContainer)
4412         return;
4413 
4414     if (!ensureMediaControlsInjectedScript())
4415         return;
4416 
4417     ensureMediaControlsShadowRoot();
4418 
4419     if (!m_mediaControlsHost)
4420         m_mediaControlsHost = MediaControlsHost::create(this);
4421 
4422     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
4423         auto&amp; vm = globalObject.vm();
4424         auto scope = DECLARE_CATCH_SCOPE(vm);
4425         auto controllerValue = controllerJSValue(exec, globalObject, *this);
4426         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4427         if (!controllerObject)
4428             return false;
4429 
4430         // The media controls script must provide a method on the Controller object with the following details.
4431         // Name: updateCaptionContainer
4432         // Parameters:
4433         //     None
4434         // Return value:
4435         //     None
<a name="73" id="anc73"></a><span class="line-modified">4436         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;updateCaptionContainer&quot;));</span>
4437         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4438         if (!methodObject)
4439             return false;
4440 
4441         JSC::CallData callData;
4442         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4443         if (callType == JSC::CallType::None)
4444             return false;
4445 
4446         JSC::MarkedArgumentBuffer noArguments;
4447         ASSERT(!noArguments.hasOverflowed());
4448         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);
4449         scope.clearException();
4450 
4451         m_haveSetUpCaptionContainer = true;
4452 
4453         return true;
4454     });
4455 
4456 #endif
4457 }
4458 
4459 void HTMLMediaElement::layoutSizeChanged()
4460 {
4461 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4462     if (auto frameView = makeRefPtr(document().view())) {
4463         auto task = [this, protectedThis = makeRef(*this)] {
4464             if (auto root = userAgentShadowRoot())
4465                 root-&gt;dispatchEvent(Event::create(&quot;resize&quot;, Event::CanBubble::No, Event::IsCancelable::No));
4466         };
4467         frameView-&gt;queuePostLayoutCallback(WTFMove(task));
4468     }
4469 #endif
4470 
4471     if (!m_receivedLayoutSizeChanged) {
4472         m_receivedLayoutSizeChanged = true;
4473         schedulePlaybackControlsManagerUpdate();
4474     }
4475 
4476     // If the video is a candidate for main content, we should register it for viewport visibility callbacks
4477     // if it hasn&#39;t already been registered.
4478     if (renderer() &amp;&amp; m_mediaSession &amp;&amp; !m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay() &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForMediaControls())
4479         renderer()-&gt;registerForVisibleInViewportCallback();
4480 }
4481 
4482 void HTMLMediaElement::visibilityDidChange()
4483 {
4484     updateShouldAutoplay();
4485 }
4486 
4487 void HTMLMediaElement::setSelectedTextTrack(TextTrack* trackToSelect)
4488 {
4489     auto* trackList = textTracks();
4490     if (!trackList || !trackList-&gt;length())
4491         return;
4492 
4493     if (trackToSelect == TextTrack::captionMenuAutomaticItem()) {
4494         if (captionDisplayMode() != CaptionUserPreferences::Automatic)
4495             m_textTracks-&gt;scheduleChangeEvent();
4496     } else if (trackToSelect == TextTrack::captionMenuOffItem()) {
4497         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i)
4498             trackList-&gt;item(i)-&gt;setMode(TextTrack::Mode::Disabled);
4499 
4500         if (captionDisplayMode() != CaptionUserPreferences::ForcedOnly &amp;&amp; !trackList-&gt;isChangeEventScheduled())
4501             m_textTracks-&gt;scheduleChangeEvent();
4502     } else {
4503         if (!trackToSelect || !trackList-&gt;contains(*trackToSelect))
4504             return;
4505 
4506         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i) {
4507             auto&amp; track = *trackList-&gt;item(i);
4508             if (&amp;track != trackToSelect)
4509                 track.setMode(TextTrack::Mode::Disabled);
4510             else
4511                 track.setMode(TextTrack::Mode::Showing);
4512         }
4513     }
4514 
4515     if (!document().page())
4516         return;
4517 
4518     auto&amp; captionPreferences = document().page()-&gt;group().captionPreferences();
4519     CaptionUserPreferences::CaptionDisplayMode displayMode;
4520     if (trackToSelect == TextTrack::captionMenuOffItem())
4521         displayMode = CaptionUserPreferences::ForcedOnly;
4522     else if (trackToSelect == TextTrack::captionMenuAutomaticItem())
4523         displayMode = CaptionUserPreferences::Automatic;
4524     else {
4525         displayMode = CaptionUserPreferences::AlwaysOn;
4526         if (trackToSelect-&gt;validBCP47Language().length())
4527             captionPreferences.setPreferredLanguage(trackToSelect-&gt;validBCP47Language());
4528     }
4529 
4530     captionPreferences.setCaptionDisplayMode(displayMode);
4531 }
4532 
4533 void HTMLMediaElement::scheduleConfigureTextTracks()
4534 {
4535     if (m_configureTextTracksTask.hasPendingTask())
4536         return;
4537 
4538     auto logSiteIdentifier = LOGIDENTIFIER;
4539     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
4540     m_configureTextTracksTask.scheduleTask([this, logSiteIdentifier] {
4541         UNUSED_PARAM(logSiteIdentifier);
4542         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
4543         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
4544         configureTextTracks();
4545     });
4546 }
4547 
4548 void HTMLMediaElement::configureTextTracks()
4549 {
4550     TrackGroup captionAndSubtitleTracks(TrackGroup::CaptionsAndSubtitles);
4551     TrackGroup descriptionTracks(TrackGroup::Description);
4552     TrackGroup chapterTracks(TrackGroup::Chapter);
4553     TrackGroup metadataTracks(TrackGroup::Metadata);
4554     TrackGroup otherTracks(TrackGroup::Other);
4555 
4556     if (!m_textTracks)
4557         return;
4558 
4559     for (size_t i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
4560         RefPtr&lt;TextTrack&gt; textTrack = m_textTracks-&gt;item(i);
4561         if (!textTrack)
4562             continue;
4563 
4564         auto kind = textTrack-&gt;kind();
4565         TrackGroup* currentGroup;
4566         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions || kind == TextTrack::Kind::Forced)
4567             currentGroup = &amp;captionAndSubtitleTracks;
4568         else if (kind == TextTrack::Kind::Descriptions)
4569             currentGroup = &amp;descriptionTracks;
4570         else if (kind == TextTrack::Kind::Chapters)
4571             currentGroup = &amp;chapterTracks;
4572         else if (kind == TextTrack::Kind::Metadata)
4573             currentGroup = &amp;metadataTracks;
4574         else
4575             currentGroup = &amp;otherTracks;
4576 
4577         if (!currentGroup-&gt;visibleTrack &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4578             currentGroup-&gt;visibleTrack = textTrack;
4579         if (!currentGroup-&gt;defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4580             currentGroup-&gt;defaultTrack = textTrack;
4581 
4582         // Do not add this track to the group if it has already been automatically configured
4583         // as we only want to call configureTextTrack once per track so that adding another
4584         // track after the initial configuration doesn&#39;t reconfigure every track - only those
4585         // that should be changed by the new addition. For example all metadata tracks are
4586         // disabled by default, and we don&#39;t want a track that has been enabled by script
4587         // to be disabled automatically when a new metadata track is added later.
4588         if (textTrack-&gt;hasBeenConfigured())
4589             continue;
4590 
4591         if (textTrack-&gt;language().length())
4592             currentGroup-&gt;hasSrcLang = true;
4593         currentGroup-&gt;tracks.append(textTrack);
4594     }
4595 
4596     if (captionAndSubtitleTracks.tracks.size())
4597         configureTextTrackGroup(captionAndSubtitleTracks);
4598     if (descriptionTracks.tracks.size())
4599         configureTextTrackGroup(descriptionTracks);
4600     if (chapterTracks.tracks.size())
4601         configureTextTrackGroup(chapterTracks);
4602     if (metadataTracks.tracks.size())
4603         configureTextTrackGroup(metadataTracks);
4604     if (otherTracks.tracks.size())
4605         configureTextTrackGroup(otherTracks);
4606 
4607     updateCaptionContainer();
4608     configureTextTrackDisplay();
4609     if (hasMediaControls())
4610         mediaControls()-&gt;closedCaptionTracksChanged();
4611 }
4612 #endif
4613 
4614 bool HTMLMediaElement::havePotentialSourceChild()
4615 {
4616     // Stash the current &lt;source&gt; node and next nodes so we can restore them after checking
4617     // to see there is another potential.
4618     RefPtr&lt;HTMLSourceElement&gt; currentSourceNode = m_currentSourceNode;
4619     RefPtr&lt;HTMLSourceElement&gt; nextNode = m_nextChildNodeToConsider;
4620 
4621     URL nextURL = selectNextSourceChild(0, 0, DoNothing);
4622 
4623     m_currentSourceNode = currentSourceNode;
4624     m_nextChildNodeToConsider = nextNode;
4625 
4626     return nextURL.isValid();
4627 }
4628 
4629 URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
4630 {
4631     UNUSED_PARAM(keySystem);
4632 
4633     // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<a name="74" id="anc74"></a><span class="line-modified">4634     bool shouldLog = willLog(WTFLogLevelDebug) &amp;&amp; actionIfInvalid != DoNothing;</span>
4635     if (shouldLog)
4636         INFO_LOG(LOGIDENTIFIER);
4637 
4638     if (!m_nextChildNodeToConsider) {
4639         if (shouldLog)
4640             INFO_LOG(LOGIDENTIFIER, &quot;end of list, stopping&quot;);
4641         return URL();
4642     }
4643 
4644     // Because the DOM may be mutated in the course of the following algorithm,
4645     // keep strong references to each of the child source nodes, and verify that
4646     // each still is a child of this media element before using.
4647     Vector&lt;Ref&lt;HTMLSourceElement&gt;&gt; potentialSourceNodes;
4648     auto sources = childrenOfType&lt;HTMLSourceElement&gt;(*this);
4649     for (auto next = m_nextChildNodeToConsider ? sources.beginAt(*m_nextChildNodeToConsider) : sources.begin(), end = sources.end(); next != end; ++next)
4650         potentialSourceNodes.append(*next);
4651 
4652     for (auto&amp; source : potentialSourceNodes) {
4653         if (source-&gt;parentNode() != this)
4654             continue;
4655 
4656         // If candidate does not have a src attribute, or if its src attribute&#39;s value is the empty string ... jump down to the failed step below
4657         auto mediaURL = source-&gt;getNonEmptyURLAttribute(srcAttr);
4658         String type;
4659         if (shouldLog)
4660             INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, mediaURL);
4661         if (mediaURL.isEmpty())
4662             goto CheckAgain;
4663 
4664         if (auto* media = source-&gt;parsedMediaAttribute(document())) {
4665             if (shouldLog)
4666                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;media&#39; is &quot;, source-&gt;attributeWithoutSynchronization(mediaAttr));
4667             auto* renderer = this-&gt;renderer();
4668             LOG(MediaQueries, &quot;HTMLMediaElement %p selectNextSourceChild evaluating media queries&quot;, this);
4669             if (!MediaQueryEvaluator { &quot;screen&quot;, document(), renderer ? &amp;renderer-&gt;style() : nullptr }.evaluate(*media))
4670                 goto CheckAgain;
4671         }
4672 
4673         type = source-&gt;attributeWithoutSynchronization(typeAttr);
4674         if (type.isEmpty() &amp;&amp; mediaURL.protocolIsData())
4675             type = mimeTypeFromDataURL(mediaURL);
4676         if (!type.isEmpty()) {
4677             if (shouldLog)
4678                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;type&#39; is &quot;, type);
4679             MediaEngineSupportParameters parameters;
4680             parameters.type = ContentType(type);
4681             parameters.url = mediaURL;
4682 #if ENABLE(MEDIA_SOURCE)
4683             parameters.isMediaSource = mediaURL.protocolIs(mediaSourceBlobProtocol);
4684 #endif
4685 #if ENABLE(MEDIA_STREAM)
4686             parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
4687 #endif
4688             if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
4689                 parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
4690 
4691             if (!MediaPlayer::supportsType(parameters))
4692                 goto CheckAgain;
4693         }
4694 
4695         // Is it safe to load this url?
4696         if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
4697             goto CheckAgain;
4698 
4699         // A &#39;beforeload&#39; event handler can mutate the DOM, so check to see if the source element is still a child node.
4700         if (source-&gt;parentNode() != this) {
4701             INFO_LOG(LOGIDENTIFIER, &quot;&#39;beforeload&#39; removed current element&quot;);
4702             continue;
4703         }
4704 
4705         // Making it this far means the &lt;source&gt; looks reasonable.
4706         if (contentType)
4707             *contentType = ContentType(type);
4708         m_nextChildNodeToConsider = Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source);
4709         m_currentSourceNode = WTFMove(source);
4710 
4711         if (shouldLog)
4712             INFO_LOG(LOGIDENTIFIER, &quot; = &quot;, mediaURL);
4713 
4714         return mediaURL;
4715 
4716 CheckAgain:
4717         if (actionIfInvalid == Complain)
4718             source-&gt;scheduleErrorEvent();
4719     }
4720 
4721     m_currentSourceNode = nullptr;
4722     m_nextChildNodeToConsider = nullptr;
4723 
4724 #if !LOG_DISABLED
4725     if (shouldLog)
4726         INFO_LOG(LOGIDENTIFIER, &quot;failed&quot;);
4727 #endif
4728     return URL();
4729 }
4730 
4731 void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
4732 {
<a name="75" id="anc75"></a><span class="line-modified">4733     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4734         URL url = source.getNonEmptyURLAttribute(srcAttr);
4735         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4736     }
4737 
4738     if (!document().hasBrowsingContext()) {
4739         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted inside a document without a browsing context is not loaded&quot;);
4740         return;
4741     }
4742 
4743     // We should only consider a &lt;source&gt; element when there is not src attribute at all.
4744     if (hasAttributeWithoutSynchronization(srcAttr))
4745         return;
4746 
4747     // 4.8.8 - If a source element is inserted as a child of a media element that has no src
4748     // attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke
4749     // the media element&#39;s resource selection algorithm.
4750     if (m_networkState == NETWORK_EMPTY) {
4751         m_nextChildNodeToConsider = &amp;source;
4752 #if PLATFORM(IOS_FAMILY)
4753         if (m_mediaSession-&gt;dataLoadingPermitted())
4754 #endif
4755             selectMediaResource();
4756         return;
4757     }
4758 
4759     if (m_currentSourceNode &amp;&amp; &amp;source == Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode)) {
4760         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted immediately after current source&quot;);
4761         m_nextChildNodeToConsider = &amp;source;
4762         return;
4763     }
4764 
4765     if (m_nextChildNodeToConsider)
4766         return;
4767 
4768     // 4.8.9.5, resource selection algorithm, source elements section:
4769     // 21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
4770     // 22. Asynchronously await a stable state...
4771     // 23. Set the element&#39;s delaying-the-load-event flag back to true (this delays the load event again, in case
4772     // it hasn&#39;t been fired yet).
4773     setShouldDelayLoadEvent(true);
4774 
4775     // 24. Set the networkState back to NETWORK_LOADING.
4776     m_networkState = NETWORK_LOADING;
4777 
4778     // 25. Jump back to the find next candidate step above.
4779     m_nextChildNodeToConsider = &amp;source;
4780     scheduleNextSourceChild();
4781 }
4782 
4783 void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
4784 {
<a name="76" id="anc76"></a><span class="line-modified">4785     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4786         URL url = source.getNonEmptyURLAttribute(srcAttr);
4787         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4788     }
4789 
4790     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4791         return;
4792 
4793     if (&amp;source == m_nextChildNodeToConsider) {
4794         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4795         INFO_LOG(LOGIDENTIFIER);
4796     } else if (&amp;source == m_currentSourceNode) {
4797         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4798         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4799         // inserted in a video or audio element will have no effect.
4800         m_currentSourceNode = nullptr;
<a name="77" id="anc77"></a><span class="line-modified">4801         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode set to 0&quot;);</span>
4802     }
4803 }
4804 
4805 void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
4806 {
4807     INFO_LOG(LOGIDENTIFIER);
4808 
4809 #if ENABLE(VIDEO_TRACK)
4810     updateActiveTextTrackCues(currentMediaTime());
4811 #endif
4812 
4813     beginProcessingMediaPlayerCallback();
4814 
4815     invalidateCachedTime();
4816     bool wasSeeking = seeking();
4817 
4818     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4819     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4820         finishSeek();
4821 
4822     // Always call scheduleTimeupdateEvent when the media engine reports a time discontinuity,
4823     // it will only queue a &#39;timeupdate&#39; event if we haven&#39;t already posted one at the current
4824     // movie time.
4825     else
4826         scheduleTimeupdateEvent(false);
4827 
4828     MediaTime now = currentMediaTime();
4829     MediaTime dur = durationMediaTime();
4830     double playbackRate = requestedPlaybackRate();
4831 
4832     // When the current playback position reaches the end of the media resource then the user agent must follow these steps:
4833     if (dur &amp;&amp; dur.isValid() &amp;&amp; !dur.isPositiveInfinite() &amp;&amp; !dur.isNegativeInfinite()) {
4834         // If the media element has a loop attribute specified and does not have a current media controller,
4835         if (loop() &amp;&amp; !m_mediaController &amp;&amp; playbackRate &gt; 0) {
4836             m_sentEndEvent = false;
4837             // then seek to the earliest possible position of the media resource and abort these steps when the direction of
4838             // playback is forwards,
4839             if (now &gt;= dur)
4840                 seekInternal(MediaTime::zeroTime());
4841         } else if ((now &lt;= MediaTime::zeroTime() &amp;&amp; playbackRate &lt; 0) || (now &gt;= dur &amp;&amp; playbackRate &gt; 0)) {
4842             // If the media element does not have a current media controller, and the media element
4843             // has still ended playback and paused is false,
4844             if (!m_mediaController &amp;&amp; !m_paused) {
4845                 // changes paused to true and fires a simple event named pause at the media element.
4846                 m_paused = true;
4847                 scheduleEvent(eventNames().pauseEvent);
4848                 m_mediaSession-&gt;clientWillPausePlayback();
4849             }
4850             // Queue a task to fire a simple event named ended at the media element.
4851             if (!m_sentEndEvent) {
4852                 m_sentEndEvent = true;
4853                 scheduleEvent(eventNames().endedEvent);
4854                 if (!wasSeeking)
4855                     addBehaviorRestrictionsOnEndIfNecessary();
4856                 setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
4857             }
4858             setPlaying(false);
4859             // If the media element has a current media controller, then report the controller state
4860             // for the media element&#39;s current media controller.
4861             updateMediaController();
4862         } else
4863             m_sentEndEvent = false;
4864     } else {
4865 #if ENABLE(MEDIA_STREAM)
4866         if (m_mediaStreamSrcObject) {
4867             // http://w3c.github.io/mediacapture-main/#event-mediastream-inactive
4868             // 6. MediaStreams in Media Elements
4869             // When the MediaStream state moves from the active to the inactive state, the User Agent
4870             // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
4871             // Note that once ended equals true the HTMLMediaElement will not play media even if new
4872             // MediaStreamTrack&#39;s are added to the MediaStream (causing it to return to the active
4873             // state) unless autoplay is true or the web application restarts the element, e.g.,
4874             // by calling play()
4875             if (!m_sentEndEvent &amp;&amp; m_player &amp;&amp; m_player-&gt;ended()) {
4876                 m_sentEndEvent = true;
4877                 scheduleEvent(eventNames().endedEvent);
4878                 if (!wasSeeking)
4879                     addBehaviorRestrictionsOnEndIfNecessary();
4880                 m_paused = true;
4881                 setPlaying(false);
4882             }
4883         } else
4884 #endif
4885         m_sentEndEvent = false;
4886     }
4887 
4888     scheduleUpdatePlayState();
4889     endProcessingMediaPlayerCallback();
4890 }
4891 
4892 void HTMLMediaElement::addBehaviorRestrictionsOnEndIfNecessary()
4893 {
4894     if (isFullscreen())
4895         return;
4896 
4897     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
4898     m_playbackControlsManagerBehaviorRestrictionsTimer.stop();
4899     m_playbackControlsManagerBehaviorRestrictionsTimer.startOneShot(hideMediaControlsAfterEndedDelay);
4900 }
4901 
4902 void HTMLMediaElement::handleSeekToPlaybackPosition(double position)
4903 {
4904 #if PLATFORM(MAC)
4905     // FIXME: This should ideally use faskSeek, but this causes MediaRemote&#39;s playhead to flicker upon release.
4906     // Please see &lt;rdar://problem/28457219&gt; for more details.
4907     seek(MediaTime::createWithDouble(position));
4908     m_seekToPlaybackPositionEndedTimer.stop();
4909     m_seekToPlaybackPositionEndedTimer.startOneShot(500_ms);
4910 
4911     if (!m_isScrubbingRemotely) {
4912         m_isScrubbingRemotely = true;
4913         if (!paused())
4914             pauseInternal();
4915     }
4916 #else
4917     fastSeek(position);
4918 #endif
4919 }
4920 
4921 void HTMLMediaElement::seekToPlaybackPositionEndedTimerFired()
4922 {
4923 #if PLATFORM(MAC)
4924     if (!m_isScrubbingRemotely)
4925         return;
4926 
4927     PlatformMediaSessionManager::sharedManager().sessionDidEndRemoteScrubbing(*m_mediaSession);
4928     m_isScrubbingRemotely = false;
4929     m_seekToPlaybackPositionEndedTimer.stop();
4930 #endif
4931 }
4932 
4933 void HTMLMediaElement::mediaPlayerVolumeChanged(MediaPlayer*)
4934 {
4935     INFO_LOG(LOGIDENTIFIER);
4936 
4937     beginProcessingMediaPlayerCallback();
4938     if (m_player) {
4939         double vol = m_player-&gt;volume();
4940         if (vol != m_volume) {
4941             m_volume = vol;
4942             updateVolume();
4943             scheduleEvent(eventNames().volumechangeEvent);
4944         }
4945     }
4946     endProcessingMediaPlayerCallback();
4947 }
4948 
4949 void HTMLMediaElement::mediaPlayerMuteChanged(MediaPlayer*)
4950 {
4951     INFO_LOG(LOGIDENTIFIER);
4952 
4953     beginProcessingMediaPlayerCallback();
4954     if (m_player)
4955         setMuted(m_player-&gt;muted());
4956     endProcessingMediaPlayerCallback();
4957 }
4958 
4959 void HTMLMediaElement::mediaPlayerDurationChanged(MediaPlayer* player)
4960 {
4961     INFO_LOG(LOGIDENTIFIER);
4962 
4963     beginProcessingMediaPlayerCallback();
4964 
4965     scheduleEvent(eventNames().durationchangeEvent);
4966     mediaPlayerCharacteristicChanged(player);
4967 
4968     MediaTime now = currentMediaTime();
4969     MediaTime dur = durationMediaTime();
4970     if (now &gt; dur)
4971         seekInternal(dur);
4972 
4973     endProcessingMediaPlayerCallback();
4974 }
4975 
4976 void HTMLMediaElement::mediaPlayerRateChanged(MediaPlayer*)
4977 {
4978     beginProcessingMediaPlayerCallback();
4979 
4980     // Stash the rate in case the one we tried to set isn&#39;t what the engine is
4981     // using (eg. it can&#39;t handle the rate we set)
4982     m_reportedPlaybackRate = m_player-&gt;rate();
4983 
4984     INFO_LOG(LOGIDENTIFIER, &quot;rate: &quot;, m_reportedPlaybackRate);
4985 
4986     if (m_playing)
4987         invalidateCachedTime();
4988 
4989     updateSleepDisabling();
4990 
4991     endProcessingMediaPlayerCallback();
4992 }
4993 
4994 void HTMLMediaElement::mediaPlayerPlaybackStateChanged(MediaPlayer*)
4995 {
4996     INFO_LOG(LOGIDENTIFIER);
4997 
4998     if (!m_player || m_pausedInternal)
4999         return;
5000 
5001     beginProcessingMediaPlayerCallback();
5002     if (m_player-&gt;paused())
5003         pauseInternal();
5004     else
5005         playInternal();
5006 
5007     updateSleepDisabling();
5008 
5009     endProcessingMediaPlayerCallback();
5010 }
5011 
5012 void HTMLMediaElement::mediaPlayerSawUnsupportedTracks(MediaPlayer*)
5013 {
5014     INFO_LOG(LOGIDENTIFIER);
5015 
5016     // The MediaPlayer came across content it cannot completely handle.
5017     // This is normally acceptable except when we are in a standalone
5018     // MediaDocument. If so, tell the document what has happened.
5019     if (is&lt;MediaDocument&gt;(document()))
5020         downcast&lt;MediaDocument&gt;(document()).mediaElementSawUnsupportedTracks();
5021 }
5022 
5023 void HTMLMediaElement::mediaPlayerResourceNotSupported(MediaPlayer*)
5024 {
5025     INFO_LOG(LOGIDENTIFIER);
5026 
5027     // The MediaPlayer came across content which no installed engine supports.
5028     mediaLoadingFailed(MediaPlayer::FormatError);
5029 }
5030 
5031 // MediaPlayerPresentation methods
5032 void HTMLMediaElement::mediaPlayerRepaint(MediaPlayer*)
5033 {
5034     beginProcessingMediaPlayerCallback();
5035     updateDisplayState();
5036     if (auto* renderer = this-&gt;renderer())
5037         renderer-&gt;repaint();
5038     endProcessingMediaPlayerCallback();
5039 }
5040 
5041 void HTMLMediaElement::mediaPlayerSizeChanged(MediaPlayer*)
5042 {
5043     INFO_LOG(LOGIDENTIFIER);
5044 
5045     if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
5046         downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
5047 
5048     beginProcessingMediaPlayerCallback();
5049     if (m_readyState &gt; HAVE_NOTHING)
5050         scheduleResizeEventIfSizeChanged();
5051     updateRenderer();
5052     endProcessingMediaPlayerCallback();
5053 }
5054 
5055 bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated(MediaPlayer*)
5056 {
5057     auto* renderer = this-&gt;renderer();
5058     return is&lt;RenderVideo&gt;(renderer)
5059         &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
5060 }
5061 
5062 void HTMLMediaElement::mediaPlayerRenderingModeChanged(MediaPlayer*)
5063 {
5064     INFO_LOG(LOGIDENTIFIER);
5065 
5066     // Kick off a fake recalcStyle that will update the compositing tree.
5067     invalidateStyleAndLayerComposition();
5068 }
5069 
5070 bool HTMLMediaElement::mediaPlayerAcceleratedCompositingEnabled()
5071 {
5072     return document().settings().acceleratedCompositingEnabled();
5073 }
5074 
5075 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
5076 
5077 GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const
5078 {
5079     auto* page = document().page();
5080     if (!page)
5081         return nullptr;
5082     return page-&gt;chrome().client().graphicsDeviceAdapter();
5083 }
5084 
5085 #endif
5086 
5087 void HTMLMediaElement::scheduleMediaEngineWasUpdated()
5088 {
5089     if (m_mediaEngineUpdatedTask.hasPendingTask())
5090         return;
5091 
5092     auto logSiteIdentifier = LOGIDENTIFIER;
5093     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5094     m_mediaEngineUpdatedTask.scheduleTask([this, logSiteIdentifier] {
5095         UNUSED_PARAM(logSiteIdentifier);
5096         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5097         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // mediaEngineWasUpdated calls methods that can trigger arbitrary DOM mutations.
5098         mediaEngineWasUpdated();
5099     });
5100 }
5101 
5102 void HTMLMediaElement::mediaEngineWasUpdated()
5103 {
5104     INFO_LOG(LOGIDENTIFIER);
5105     beginProcessingMediaPlayerCallback();
5106     updateRenderer();
5107     endProcessingMediaPlayerCallback();
5108 
5109     m_mediaSession-&gt;mediaEngineUpdated();
5110 
5111 #if ENABLE(WEB_AUDIO)
5112     if (m_audioSourceNode &amp;&amp; audioSourceProvider()) {
5113         m_audioSourceNode-&gt;lock();
5114         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
5115         m_audioSourceNode-&gt;unlock();
5116     }
5117 #endif
5118 
5119 #if ENABLE(ENCRYPTED_MEDIA)
5120     if (m_player &amp;&amp; m_mediaKeys)
5121         m_player-&gt;cdmInstanceAttached(m_mediaKeys-&gt;cdmInstance());
5122 #endif
5123 
5124 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
5125     if (!m_player)
5126         return;
5127     m_player-&gt;setVideoFullscreenFrame(m_videoFullscreenFrame);
5128     m_player-&gt;setVideoFullscreenGravity(m_videoFullscreenGravity);
5129     m_player-&gt;setVideoFullscreenLayer(m_videoFullscreenLayer.get());
5130 #endif
5131 
5132 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5133     scheduleUpdateMediaState();
5134 #endif
5135 }
5136 
5137 void HTMLMediaElement::mediaPlayerEngineUpdated(MediaPlayer*)
5138 {
5139     INFO_LOG(LOGIDENTIFIER);
5140 
5141 #if ENABLE(MEDIA_SOURCE)
5142     m_droppedVideoFrames = 0;
5143 #endif
5144 
5145     m_havePreparedToPlay = false;
5146 
5147     scheduleMediaEngineWasUpdated();
5148 }
5149 
5150 void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable(MediaPlayer*)
5151 {
5152     INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
5153 
5154     beginProcessingMediaPlayerCallback();
5155     if (displayMode() == PosterWaitingForVideo) {
5156         setDisplayMode(Video);
5157         mediaPlayerRenderingModeChanged(m_player.get());
5158     }
5159     endProcessingMediaPlayerCallback();
5160 }
5161 
5162 void HTMLMediaElement::mediaPlayerCharacteristicChanged(MediaPlayer*)
5163 {
5164     INFO_LOG(LOGIDENTIFIER);
5165 
5166     beginProcessingMediaPlayerCallback();
5167 
5168 #if ENABLE(VIDEO_TRACK)
5169     if (captionDisplayMode() == CaptionUserPreferences::Automatic &amp;&amp; m_subtitleTrackLanguage != m_player-&gt;languageOfPrimaryAudioTrack())
5170         markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
5171 #endif
5172 
5173     if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
5174         setDisplayMode(Video);
5175         mediaPlayerRenderingModeChanged(m_player.get());
5176     }
5177 
5178     if (hasMediaControls())
5179         mediaControls()-&gt;reset();
5180     updateRenderer();
5181 
5182     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
5183         pauseInternal();
5184         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
5185     }
5186 
5187 #if ENABLE(MEDIA_SESSION)
5188     document().updateIsPlayingMedia(m_elementID);
5189 #else
5190     document().updateIsPlayingMedia();
5191 #endif
5192 
5193     m_hasEverHadAudio |= hasAudio();
5194     m_hasEverHadVideo |= hasVideo();
5195 
5196     m_mediaSession-&gt;canProduceAudioChanged();
5197 
5198     updateSleepDisabling();
5199 
5200     endProcessingMediaPlayerCallback();
5201 }
5202 
5203 Ref&lt;TimeRanges&gt; HTMLMediaElement::buffered() const
5204 {
5205     if (!m_player)
5206         return TimeRanges::create();
5207 
5208 #if ENABLE(MEDIA_SOURCE)
5209     if (m_mediaSource)
5210         return TimeRanges::create(*m_mediaSource-&gt;buffered());
5211 #endif
5212 
5213     return TimeRanges::create(*m_player-&gt;buffered());
5214 }
5215 
5216 double HTMLMediaElement::maxBufferedTime() const
5217 {
5218     auto bufferedRanges = buffered();
5219     unsigned numRanges = bufferedRanges-&gt;length();
5220     if (!numRanges)
5221         return 0;
5222     return bufferedRanges.get().ranges().end(numRanges - 1).toDouble();
5223 }
5224 
5225 Ref&lt;TimeRanges&gt; HTMLMediaElement::played()
5226 {
5227     if (m_playing) {
5228         MediaTime time = currentMediaTime();
5229         if (time &gt; m_lastSeekTime)
5230             addPlayedRange(m_lastSeekTime, time);
5231     }
5232 
5233     if (!m_playedTimeRanges)
5234         m_playedTimeRanges = TimeRanges::create();
5235 
5236     return m_playedTimeRanges-&gt;copy();
5237 }
5238 
5239 Ref&lt;TimeRanges&gt; HTMLMediaElement::seekable() const
5240 {
5241 #if ENABLE(MEDIA_SOURCE)
5242     if (m_mediaSource)
5243         return m_mediaSource-&gt;seekable();
5244 #endif
5245 
5246     if (m_player)
5247         return TimeRanges::create(*m_player-&gt;seekable());
5248 
5249     return TimeRanges::create();
5250 }
5251 
5252 double HTMLMediaElement::seekableTimeRangesLastModifiedTime() const
5253 {
5254     return m_player ? m_player-&gt;seekableTimeRangesLastModifiedTime() : 0;
5255 }
5256 
5257 double HTMLMediaElement::liveUpdateInterval() const
5258 {
5259     return m_player ? m_player-&gt;liveUpdateInterval() : 0;
5260 }
5261 
5262 bool HTMLMediaElement::potentiallyPlaying() const
5263 {
5264     if (isBlockedOnMediaController())
5265         return false;
5266 
5267     if (!couldPlayIfEnoughData())
5268         return false;
5269 
5270     if (m_readyState &gt;= HAVE_FUTURE_DATA)
5271         return true;
5272 
5273     return m_readyStateMaximum &gt;= HAVE_FUTURE_DATA &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA;
5274 }
5275 
5276 bool HTMLMediaElement::couldPlayIfEnoughData() const
5277 {
5278     if (paused())
5279         return false;
5280 
5281     if (endedPlayback())
5282         return false;
5283 
5284     if (stoppedDueToErrors())
5285         return false;
5286 
5287     if (pausedForUserInteraction())
5288         return false;
5289 
5290     return true;
5291 }
5292 
5293 bool HTMLMediaElement::endedPlayback() const
5294 {
5295     MediaTime dur = durationMediaTime();
5296     if (!m_player || !dur.isValid())
5297         return false;
5298 
5299     // 4.8.10.8 Playing the media resource
5300 
5301     // A media element is said to have ended playback when the element&#39;s
5302     // readyState attribute is HAVE_METADATA or greater,
5303     if (m_readyState &lt; HAVE_METADATA)
5304         return false;
5305 
5306     // and the current playback position is the end of the media resource and the direction
5307     // of playback is forwards, Either the media element does not have a loop attribute specified,
5308     // or the media element has a current media controller.
5309     MediaTime now = currentMediaTime();
5310     if (requestedPlaybackRate() &gt; 0)
5311         return dur &gt; MediaTime::zeroTime() &amp;&amp; now &gt;= dur &amp;&amp; (!loop() || m_mediaController);
5312 
5313     // or the current playback position is the earliest possible position and the direction
5314     // of playback is backwards
5315     if (requestedPlaybackRate() &lt; 0)
5316         return now &lt;= MediaTime::zeroTime();
5317 
5318     return false;
5319 }
5320 
5321 bool HTMLMediaElement::stoppedDueToErrors() const
5322 {
5323     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; m_error) {
5324         RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
5325         if (!seekableRanges-&gt;contain(currentTime()))
5326             return true;
5327     }
5328 
5329     return false;
5330 }
5331 
5332 bool HTMLMediaElement::pausedForUserInteraction() const
5333 {
5334     if (m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted)
5335         return true;
5336 
5337     return false;
5338 }
5339 
5340 MediaTime HTMLMediaElement::minTimeSeekable() const
5341 {
5342     return m_player ? m_player-&gt;minTimeSeekable() : MediaTime::zeroTime();
5343 }
5344 
5345 MediaTime HTMLMediaElement::maxTimeSeekable() const
5346 {
5347     return m_player ? m_player-&gt;maxTimeSeekable() : MediaTime::zeroTime();
5348 }
5349 
5350 void HTMLMediaElement::updateVolume()
5351 {
5352     if (!m_player)
5353         return;
5354 #if PLATFORM(IOS_FAMILY)
5355     // Only the user can change audio volume so update the cached volume and post the changed event.
5356     float volume = m_player-&gt;volume();
5357     if (m_volume != volume) {
5358         m_volume = volume;
5359         scheduleEvent(eventNames().volumechangeEvent);
5360     }
5361 #else
5362     // Avoid recursion when the player reports volume changes.
5363     if (!processingMediaPlayerCallback()) {
<a name="78" id="anc78"></a><span class="line-modified">5364         Page* page = document().page();</span>
<span class="line-modified">5365         double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-removed">5366         bool shouldMute = effectiveMuted();</span>
<span class="line-removed">5367 </span>
<span class="line-removed">5368         if (m_mediaController) {</span>
<span class="line-removed">5369             volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-removed">5370             shouldMute = m_mediaController-&gt;muted() || (page &amp;&amp; page-&gt;isAudioMuted());</span>
<span class="line-removed">5371         }</span>
<span class="line-removed">5372 </span>
<span class="line-removed">5373 #if ENABLE(MEDIA_SESSION)</span>
<span class="line-removed">5374         if (m_shouldDuck)</span>
<span class="line-removed">5375             volumeMultiplier *= 0.25;</span>
<span class="line-removed">5376 #endif</span>
<span class="line-removed">5377 </span>
<span class="line-removed">5378         m_player-&gt;setMuted(shouldMute);</span>
<span class="line-removed">5379         m_player-&gt;setVolume(m_volume * volumeMultiplier);</span>
5380     }
5381 
5382 #if ENABLE(MEDIA_SESSION)
5383     document().updateIsPlayingMedia(m_elementID);
5384 #else
5385     document().updateIsPlayingMedia();
5386 #endif
5387 
5388     if (hasMediaControls())
5389         mediaControls()-&gt;changedVolume();
5390 #endif
5391 }
5392 
5393 void HTMLMediaElement::scheduleUpdatePlayState()
5394 {
5395     if (m_updatePlayStateTask.hasPendingTask())
5396         return;
5397 
5398     auto logSiteIdentifier = LOGIDENTIFIER;
5399     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5400     m_updatePlayStateTask.scheduleTask([this, logSiteIdentifier] {
5401         UNUSED_PARAM(logSiteIdentifier);
5402         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5403         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updatePlayState calls methods that can trigger arbitrary DOM mutations.
5404         updatePlayState();
5405     });
5406 }
5407 
5408 void HTMLMediaElement::updatePlayState()
5409 {
5410     if (!m_player)
5411         return;
5412 
5413     if (m_pausedInternal) {
5414         if (!m_player-&gt;paused())
5415             m_player-&gt;pause();
5416         refreshCachedTime();
5417         m_playbackProgressTimer.stop();
5418         if (hasMediaControls())
5419             mediaControls()-&gt;playbackStopped();
5420         return;
5421     }
5422 
5423     bool shouldBePlaying = potentiallyPlaying();
5424     bool playerPaused = m_player-&gt;paused();
5425 
5426     INFO_LOG(LOGIDENTIFIER, &quot;shouldBePlaying = &quot;, shouldBePlaying, &quot;, playerPaused = &quot;, playerPaused);
5427 
5428     if (shouldBePlaying &amp;&amp; playerPaused &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; (m_waitingToEnterFullscreen || !isFullscreen())) {
5429         if (!m_waitingToEnterFullscreen)
5430             enterFullscreen();
5431 
5432 #if PLATFORM(WATCHOS)
5433         // FIXME: Investigate doing this for all builds.
5434         return;
5435 #endif
5436     }
5437 
5438     if (shouldBePlaying) {
5439         schedulePlaybackControlsManagerUpdate();
5440 
5441         setDisplayMode(Video);
5442         invalidateCachedTime();
5443 
5444         if (playerPaused) {
5445             m_mediaSession-&gt;clientWillBeginPlayback();
5446 
<a name="79" id="anc79"></a><span class="line-modified">5447             // Set rate, muted before calling play in case they were set before the media engine was setup.</span>
<span class="line-modified">5448             // The media engine should just stash the rate and muted values since it isn&#39;t already playing.</span>
5449             m_player-&gt;setRate(requestedPlaybackRate());
5450             m_player-&gt;setMuted(effectiveMuted());
<a name="80" id="anc80"></a>
5451 
5452             if (m_firstTimePlaying) {
5453                 // Log that a media element was played.
5454                 if (auto* page = document().page())
5455                     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
5456                 m_firstTimePlaying = false;
5457             }
5458 
5459             m_player-&gt;play();
5460         }
5461 
5462         if (hasMediaControls())
5463             mediaControls()-&gt;playbackStarted();
5464 
5465         startPlaybackProgressTimer();
5466         setPlaying(true);
5467     } else {
5468         schedulePlaybackControlsManagerUpdate();
5469 
5470         if (!playerPaused)
5471             m_player-&gt;pause();
5472         refreshCachedTime();
5473 
5474         m_playbackProgressTimer.stop();
5475         setPlaying(false);
5476         MediaTime time = currentMediaTime();
5477         if (time &gt; m_lastSeekTime)
5478             addPlayedRange(m_lastSeekTime, time);
5479 
5480         if (couldPlayIfEnoughData())
5481             prepareToPlay();
5482 
5483         if (hasMediaControls())
5484             mediaControls()-&gt;playbackStopped();
5485     }
5486 
5487     updateMediaController();
5488     updateRenderer();
5489 
5490     m_hasEverHadAudio |= hasAudio();
5491     m_hasEverHadVideo |= hasVideo();
5492 }
5493 
5494 void HTMLMediaElement::setPlaying(bool playing)
5495 {
5496     if (playing &amp;&amp; m_mediaSession)
5497         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
5498 
5499     if (m_playing == playing)
5500         return;
5501 
5502     m_playing = playing;
5503 
5504     if (m_playing)
5505         scheduleNotifyAboutPlaying();
5506 
5507 #if ENABLE(MEDIA_SESSION)
5508     document().updateIsPlayingMedia(m_elementID);
5509 #else
5510     document().updateIsPlayingMedia();
5511 #endif
5512 
5513 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5514     scheduleUpdateMediaState();
5515 #endif
5516 }
5517 
5518 void HTMLMediaElement::setPausedInternal(bool b)
5519 {
5520     m_pausedInternal = b;
5521     scheduleUpdatePlayState();
5522 }
5523 
5524 void HTMLMediaElement::stopPeriodicTimers()
5525 {
5526     m_progressEventTimer.stop();
5527     m_playbackProgressTimer.stop();
5528 }
5529 
5530 void HTMLMediaElement::cancelPendingTasks()
5531 {
5532     m_configureTextTracksTask.cancelTask();
5533     m_checkPlaybackTargetCompatablityTask.cancelTask();
5534     m_updateMediaStateTask.cancelTask();
5535     m_mediaEngineUpdatedTask.cancelTask();
5536     m_updatePlayStateTask.cancelTask();
<a name="81" id="anc81"></a>


5537 }
5538 
5539 void HTMLMediaElement::userCancelledLoad()
5540 {
5541     INFO_LOG(LOGIDENTIFIER);
5542 
5543     // FIXME: We should look to reconcile the iOS and non-iOS code (below).
5544 #if PLATFORM(IOS_FAMILY)
5545     if (m_networkState == NETWORK_EMPTY || m_readyState &gt;= HAVE_METADATA)
5546         return;
5547 #else
5548     if (m_networkState == NETWORK_EMPTY || m_completelyLoaded)
5549         return;
5550 #endif
5551 
5552     // If the media data fetching process is aborted by the user:
5553 
5554     // 1 - The user agent should cancel the fetching process.
5555     clearMediaPlayer();
5556 
5557     // 2 - Set the error attribute to a new MediaError object whose code attribute is set to MEDIA_ERR_ABORTED.
5558     m_error = MediaError::create(MediaError::MEDIA_ERR_ABORTED);
5559 
5560     // 3 - Queue a task to fire a simple event named error at the media element.
5561     scheduleEvent(eventNames().abortEvent);
5562 
5563 #if ENABLE(MEDIA_SOURCE)
5564     detachMediaSource();
5565 #endif
5566 
5567     // 4 - If the media element&#39;s readyState attribute has a value equal to HAVE_NOTHING, set the
5568     // element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a task to fire a
5569     // simple event named emptied at the element. Otherwise, set the element&#39;s networkState
5570     // attribute to the NETWORK_IDLE value.
5571     if (m_readyState == HAVE_NOTHING) {
5572         m_networkState = NETWORK_EMPTY;
5573         scheduleEvent(eventNames().emptiedEvent);
5574     }
5575     else
5576         m_networkState = NETWORK_IDLE;
5577 
5578     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
5579     setShouldDelayLoadEvent(false);
5580 
5581     // 6 - Abort the overall resource selection algorithm.
5582     m_currentSourceNode = nullptr;
5583 
5584     // Reset m_readyState since m_player is gone.
5585     m_readyState = HAVE_NOTHING;
5586     updateMediaController();
5587 
5588 #if ENABLE(VIDEO_TRACK)
5589     auto* context = scriptExecutionContext();
5590     if (!context || context-&gt;activeDOMObjectsAreStopped())
5591         return; // Document is about to be destructed. Avoid updating layout in updateActiveTextTrackCues.
5592 
5593     updateActiveTextTrackCues(MediaTime::zeroTime());
5594 #endif
5595 }
5596 
5597 void HTMLMediaElement::clearMediaPlayer()
5598 {
5599 #if ENABLE(MEDIA_STREAM)
5600     if (!m_settingMediaStreamSrcObject)
5601         m_mediaStreamSrcObject = nullptr;
5602 #endif
5603 
5604 #if ENABLE(MEDIA_SOURCE)
5605     detachMediaSource();
5606 #endif
5607 
5608     m_blob = nullptr;
5609 
5610 #if ENABLE(VIDEO_TRACK)
5611     forgetResourceSpecificTracks();
5612 #endif
5613 
5614 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5615     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
5616         m_hasPlaybackTargetAvailabilityListeners = false;
5617         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5618 
5619         // Send an availability event in case scripts want to hide the picker when the element
5620         // doesn&#39;t support playback to a target.
5621         enqueuePlaybackTargetAvailabilityChangedEvent();
5622     }
5623 
5624     if (m_isPlayingToWirelessTarget)
5625         setIsPlayingToWirelessTarget(false);
5626 #endif
5627 
5628     if (m_isWaitingUntilMediaCanStart) {
5629         m_isWaitingUntilMediaCanStart = false;
5630         document().removeMediaCanStartListener(*this);
5631     }
5632 
5633     if (m_player) {
5634         m_player-&gt;invalidate();
5635         m_player = nullptr;
5636     }
5637     schedulePlaybackControlsManagerUpdate();
5638 
5639     stopPeriodicTimers();
5640     cancelPendingTasks();
5641 
5642     m_loadState = WaitingForSource;
5643 
5644 #if ENABLE(VIDEO_TRACK)
5645     if (m_textTracks)
5646         configureTextTrackDisplay();
5647 #endif
5648 
5649     m_mediaSession-&gt;clientCharacteristicsChanged();
5650     m_mediaSession-&gt;canProduceAudioChanged();
5651 
5652     m_resourceSelectionTaskQueue.cancelAllTasks();
5653 
5654     updateSleepDisabling();
5655 }
5656 
5657 bool HTMLMediaElement::canSuspendForDocumentSuspension() const
5658 {
5659     return true;
5660 }
5661 
5662 const char* HTMLMediaElement::activeDOMObjectName() const
5663 {
5664     return &quot;HTMLMediaElement&quot;;
5665 }
5666 
5667 void HTMLMediaElement::stopWithoutDestroyingMediaPlayer()
5668 {
5669     INFO_LOG(LOGIDENTIFIER);
5670 
5671     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5672         exitFullscreen();
5673 
5674     setPreparedToReturnVideoLayerToInline(true);
5675 
5676     schedulePlaybackControlsManagerUpdate();
5677     setInActiveDocument(false);
5678 
5679     // Stop the playback without generating events
5680     setPlaying(false);
5681     setPausedInternal(true);
5682     m_mediaSession-&gt;stopSession();
5683 
5684     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
5685 
5686     userCancelledLoad();
5687 
5688     updateRenderer();
5689 
5690     stopPeriodicTimers();
5691 
5692     updateSleepDisabling();
5693 }
5694 
5695 void HTMLMediaElement::closeTaskQueues()
5696 {
5697     m_configureTextTracksTask.close();
5698     m_checkPlaybackTargetCompatablityTask.close();
5699     m_updateMediaStateTask.close();
5700     m_mediaEngineUpdatedTask.close();
5701     m_updatePlayStateTask.close();
5702     m_resumeTaskQueue.close();
5703     m_seekTaskQueue.close();
5704     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5705     m_seekTaskQueue.close();
5706     m_resumeTaskQueue.close();
5707     m_promiseTaskQueue.close();
5708     m_pauseAfterDetachedTaskQueue.close();
5709     m_resourceSelectionTaskQueue.close();
5710     m_visibilityChangeTaskQueue.close();
5711 #if ENABLE(ENCRYPTED_MEDIA)
5712     m_encryptedMediaQueue.close();
5713 #endif
5714     m_asyncEventQueue.close();
<a name="82" id="anc82"></a>


5715 }
5716 
5717 void HTMLMediaElement::contextDestroyed()
5718 {
5719     closeTaskQueues();
5720     m_pendingPlayPromises.clear();
5721 
5722     ActiveDOMObject::contextDestroyed();
5723 }
5724 
5725 void HTMLMediaElement::stop()
5726 {
5727     INFO_LOG(LOGIDENTIFIER);
5728 
5729     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5730     stopWithoutDestroyingMediaPlayer();
5731     closeTaskQueues();
5732 
5733     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5734     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5735     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5736     // loaded and calling it again won&#39;t cause any problems.
5737     clearMediaPlayer();
5738 
5739     m_mediaSession-&gt;stopSession();
5740 }
5741 
5742 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5743 {
5744     INFO_LOG(LOGIDENTIFIER);
5745     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5746 
5747     m_resumeTaskQueue.cancelTask();
5748 
5749     switch (reason) {
5750     case ReasonForSuspension::PageCache:
5751         stopWithoutDestroyingMediaPlayer();
5752         m_asyncEventQueue.suspend();
<a name="83" id="anc83"></a><span class="line-modified">5753         setShouldBufferData(false);</span>
5754         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5755         break;
5756     case ReasonForSuspension::PageWillBeSuspended:
5757     case ReasonForSuspension::JavaScriptDebuggerPaused:
5758     case ReasonForSuspension::WillDeferLoading:
5759         // Do nothing, we don&#39;t pause media playback in these cases.
5760         break;
5761     }
5762 }
5763 
5764 void HTMLMediaElement::resume()
5765 {
5766     INFO_LOG(LOGIDENTIFIER);
5767 
5768     setInActiveDocument(true);
5769 
5770     m_asyncEventQueue.resume();
5771 
<a name="84" id="anc84"></a><span class="line-removed">5772     setShouldBufferData(true);</span>
<span class="line-removed">5773 </span>
5774     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5775         document().addMediaCanStartListener(*this);
5776     else
5777         setPausedInternal(false);
5778 
5779     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
<a name="85" id="anc85"></a>
5780 
5781     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
5782         // Restart the load if it was aborted in the middle by moving the document to the page cache.
5783         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5784         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5785         // This behavior is not specified but it seems like a sensible thing to do.
5786         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5787         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5788     }
5789 
5790     updateRenderer();
5791 }
5792 
5793 bool HTMLMediaElement::hasPendingActivity() const
5794 {
5795     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;
5796 }
5797 
5798 void HTMLMediaElement::mediaVolumeDidChange()
5799 {
5800     INFO_LOG(LOGIDENTIFIER);
5801     updateVolume();
5802 }
5803 
5804 void HTMLMediaElement::visibilityStateChanged()
5805 {
5806     bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
5807     if (elementIsHidden == m_elementIsHidden)
5808         return;
5809 
5810     m_elementIsHidden = elementIsHidden;
5811     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, !m_elementIsHidden);
5812 
5813     updateSleepDisabling();
5814     m_mediaSession-&gt;visibilityChanged();
5815     if (m_player)
5816         m_player-&gt;setVisible(!m_elementIsHidden);
5817 
5818     bool isPlayingAudio = isPlaying() &amp;&amp; hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
5819     if (!isPlayingAudio) {
5820         if (m_elementIsHidden) {
5821             ALWAYS_LOG(LOGIDENTIFIER, &quot;Suspending playback after going to the background&quot;);
5822             m_mediaSession-&gt;beginInterruption(PlatformMediaSession::EnteringBackground);
5823         } else {
5824             ALWAYS_LOG(LOGIDENTIFIER, &quot;Resuming playback after entering foreground&quot;);
5825             m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
5826         }
5827     }
5828 }
5829 
5830 #if ENABLE(VIDEO_TRACK)
5831 bool HTMLMediaElement::requiresTextTrackRepresentation() const
5832 {
5833     return (m_videoFullscreenMode != VideoFullscreenModeNone) &amp;&amp; m_player ? m_player-&gt;requiresTextTrackRepresentation() : false;
5834 }
5835 
5836 void HTMLMediaElement::setTextTrackRepresentation(TextTrackRepresentation* representation)
5837 {
5838     if (m_player)
5839         m_player-&gt;setTextTrackRepresentation(representation);
5840 }
5841 
5842 void HTMLMediaElement::syncTextTrackBounds()
5843 {
5844     if (m_player)
5845         m_player-&gt;syncTextTrackBounds();
5846 }
5847 #endif // ENABLE(VIDEO_TRACK)
5848 
5849 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5850 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5851 {
5852     ALWAYS_LOG(LOGIDENTIFIER);
5853     if (processingUserGestureForMedia())
<a name="86" id="anc86"></a><span class="line-modified">5854         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
5855     m_mediaSession-&gt;showPlaybackTargetPicker();
5856 }
5857 
5858 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5859 {
5860     enqueuePlaybackTargetAvailabilityChangedEvent();
5861 }
5862 
5863 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)
5864 {
5865     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());
5866 }
5867 
5868 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5869 {
5870     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5871         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5872             return;
5873         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
5874 
5875         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5876         configureMediaControls();
5877         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5878         m_mediaSession-&gt;canProduceAudioChanged();
5879         scheduleUpdateMediaState();
5880         updateSleepDisabling();
5881 
5882         m_failedToPlayToWirelessTarget = false;
5883         scheduleCheckPlaybackTargetCompatability();
5884 
5885         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5886     });
5887 }
5888 
5889 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5890 {
<a name="87" id="anc87"></a><span class="line-modified">5891     DEBUG_LOG(LOGIDENTIFIER, &quot;dispatching &#39;&quot;, event.type(), &quot;&#39;&quot;);</span>



5892 
5893     HTMLElement::dispatchEvent(event);
5894 }
5895 
<a name="88" id="anc88"></a><span class="line-modified">5896 bool HTMLMediaElement::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
5897 {
5898     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5899         return Node::addEventListener(eventType, WTFMove(listener), options);
5900 
5901     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5902     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5903         return false;
5904 
5905     if (isFirstAvailabilityChangedListener) {
5906         m_hasPlaybackTargetAvailabilityListeners = true;
5907         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5908     }
5909 
5910     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5911 
5912     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5913     return true;
5914 }
5915 
<a name="89" id="anc89"></a><span class="line-modified">5916 bool HTMLMediaElement::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
5917 {
5918     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5919         return Node::removeEventListener(eventType, listener, options);
5920 
5921     if (!Node::removeEventListener(eventType, listener, options))
5922         return false;
5923 
5924     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5925     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5926     if (didRemoveLastAvailabilityChangedListener) {
5927         m_hasPlaybackTargetAvailabilityListeners = false;
5928         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5929         scheduleUpdateMediaState();
5930     }
5931 
5932     return true;
5933 }
5934 
5935 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5936 {
5937     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
5938     INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
5939     auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
5940     event-&gt;setTarget(this);
5941     m_asyncEventQueue.enqueueEvent(WTFMove(event));
5942     scheduleUpdateMediaState();
5943 }
5944 
5945 void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
5946 {
5947     ALWAYS_LOG(LOGIDENTIFIER);
5948     if (m_player)
5949         m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
5950 }
5951 
5952 void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
5953 {
5954     ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
5955 
5956     if (m_player)
5957         m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
5958 }
5959 
5960 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
5961 
5962 bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
5963 {
5964     INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5965     return m_isPlayingToWirelessTarget;
5966 }
5967 
5968 void HTMLMediaElement::setPlayingOnSecondScreen(bool value)
5969 {
5970     if (value == m_playingOnSecondScreen)
5971         return;
5972 
5973     m_playingOnSecondScreen = value;
5974 
5975 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5976     scheduleUpdateMediaState();
5977 #endif
5978 }
5979 
5980 double HTMLMediaElement::minFastReverseRate() const
5981 {
5982     return m_player ? m_player-&gt;minFastReverseRate() : 0;
5983 }
5984 
5985 double HTMLMediaElement::maxFastForwardRate() const
5986 {
5987     return m_player ? m_player-&gt;maxFastForwardRate() : 0;
5988 }
5989 
5990 bool HTMLMediaElement::isFullscreen() const
5991 {
5992     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5993         return true;
5994 
5995 #if ENABLE(FULLSCREEN_API)
<a name="90" id="anc90"></a><span class="line-modified">5996     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
5997         return true;
5998 #endif
5999 
6000     return false;
6001 }
6002 
6003 bool HTMLMediaElement::isStandardFullscreen() const
6004 {
6005 #if ENABLE(FULLSCREEN_API)
<a name="91" id="anc91"></a><span class="line-modified">6006     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
6007         return true;
6008 #endif
6009 
6010     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6011 }
6012 
6013 void HTMLMediaElement::toggleStandardFullscreenState()
6014 {
6015     if (isStandardFullscreen())
6016         exitFullscreen();
6017     else
6018         enterFullscreen();
6019 }
6020 
6021 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6022 {
6023     INFO_LOG(LOGIDENTIFIER);
6024     ASSERT(mode != VideoFullscreenModeNone);
6025 
6026     if (m_videoFullscreenMode == mode)
6027         return;
6028 
6029     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6030     m_waitingToEnterFullscreen = true;
6031 
6032 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6033     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<a name="92" id="anc92"></a><span class="line-modified">6034         document().requestFullScreenForElement(this, Document::ExemptIFrameAllowFullScreenRequirement);</span>
6035         return;
6036     }
6037 #endif
6038 
6039     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6040         if (document().hidden()) {
6041             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6042             return;
6043         }
6044 
6045         fullscreenModeChanged(mode);
6046         configureMediaControls();
6047         if (hasMediaControls())
6048             mediaControls()-&gt;enteredFullscreen();
6049         if (is&lt;HTMLVideoElement&gt;(*this)) {
6050             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6051             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
6052                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6053                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6054             }
6055         }
6056     });
6057 }
6058 
6059 void HTMLMediaElement::enterFullscreen()
6060 {
6061     enterFullscreen(VideoFullscreenModeStandard);
6062 }
6063 
6064 void HTMLMediaElement::exitFullscreen()
6065 {
6066     INFO_LOG(LOGIDENTIFIER);
6067 
6068     m_waitingToEnterFullscreen = false;
6069 
6070 #if ENABLE(FULLSCREEN_API)
<a name="93" id="anc93"></a><span class="line-modified">6071     if (document().settings().fullScreenEnabled() &amp;&amp; document().webkitCurrentFullScreenElement() == this) {</span>
<span class="line-modified">6072         if (document().webkitIsFullScreen())</span>
<span class="line-modified">6073             document().webkitCancelFullScreen();</span>
6074 
6075         if (m_videoFullscreenMode == VideoFullscreenModeStandard)
6076             return;
6077     }
6078 #endif
6079 
6080     ASSERT(m_videoFullscreenMode != VideoFullscreenModeNone);
6081     VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6082     fullscreenModeChanged(VideoFullscreenModeNone);
6083 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6084     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaControlsAfterPresentationModeChange calls methods that can trigger arbitrary DOM mutations.
6085     updateMediaControlsAfterPresentationModeChange();
6086 #endif
6087     if (hasMediaControls())
6088         mediaControls()-&gt;exitedFullscreen();
6089 
6090     if (!document().page() || !is&lt;HTMLVideoElement&gt;(*this))
6091         return;
6092 
6093     if (!paused() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback()) {
6094         if (!document().settings().allowsInlineMediaPlaybackAfterFullscreen() || isVideoTooSmallForInlinePlayback())
6095             pauseInternal();
6096         else {
6097             // Allow inline playback, but set a flag so pausing and starting again (e.g. when scrubbing or looping) won&#39;t go back to fullscreen.
6098             // Also set the controls attribute so the user will be able to control playback.
6099             m_temporarilyAllowingInlinePlaybackAfterFullscreen = true;
6100             setControls(true);
6101         }
6102     }
6103 
6104 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6105     if (document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
6106         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(downcast&lt;HTMLVideoElement&gt;(*this), VideoFullscreenModeNone);
6107     else
6108 #endif
6109     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(oldVideoFullscreenMode)) {
6110         if (m_videoFullscreenStandby)
6111             document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6112         else
6113             document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6114         scheduleEvent(eventNames().webkitendfullscreenEvent);
<a name="94" id="anc94"></a><span class="line-removed">6115         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);</span>
6116     }
6117 }
6118 
6119 WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
6120 {
6121     ASSERT(is&lt;HTMLVideoElement&gt;(*this));
6122     if (m_videoFullscreenStandby == value)
6123         return;
6124 
6125     if (!document().page())
6126         return;
6127 
6128     if (!document().page()-&gt;chrome().client().supportsVideoFullscreenStandby())
6129         return;
6130 
6131     m_videoFullscreenStandby = value;
6132 
6133 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6134     if (m_player)
6135         m_player-&gt;videoFullscreenStandbyChanged();
6136 #endif
6137 
6138     if (m_videoFullscreenStandby || m_videoFullscreenMode != VideoFullscreenModeNone)
6139         document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6140     else
6141         document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6142 }
6143 
6144 void HTMLMediaElement::willBecomeFullscreenElement()
6145 {
6146 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6147     HTMLMediaElementEnums::VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6148 #endif
6149 
6150     fullscreenModeChanged(VideoFullscreenModeStandard);
6151 
6152 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6153     switch (oldVideoFullscreenMode) {
6154     case VideoFullscreenModeNone:
6155     case VideoFullscreenModeStandard:
6156         // Don&#39;t need to do anything if we are not in any special fullscreen mode or it&#39;s already
6157         // in standard fullscreen mode.
6158         break;
6159     case VideoFullscreenModePictureInPicture:
6160         if (is&lt;HTMLVideoElement&gt;(*this))
6161             downcast&lt;HTMLVideoElement&gt;(this)-&gt;exitToFullscreenModeWithoutAnimationIfPossible(oldVideoFullscreenMode, VideoFullscreenModeStandard);
6162         break;
6163     }
6164 #endif
6165 
6166     Element::willBecomeFullscreenElement();
6167 }
6168 
6169 void HTMLMediaElement::didBecomeFullscreenElement()
6170 {
6171     m_waitingToEnterFullscreen = false;
6172     if (hasMediaControls())
6173         mediaControls()-&gt;enteredFullscreen();
6174     scheduleUpdatePlayState();
6175 }
6176 
6177 void HTMLMediaElement::willStopBeingFullscreenElement()
6178 {
6179     if (hasMediaControls())
6180         mediaControls()-&gt;exitedFullscreen();
6181 
6182     if (fullscreenMode() == VideoFullscreenModeStandard)
6183         fullscreenModeChanged(VideoFullscreenModeNone);
6184 }
6185 
6186 PlatformLayer* HTMLMediaElement::platformLayer() const
6187 {
6188     return m_player ? m_player-&gt;platformLayer() : nullptr;
6189 }
6190 
6191 void HTMLMediaElement::setPreparedToReturnVideoLayerToInline(bool value)
6192 {
6193     m_preparedForInline = value;
6194     if (m_preparedForInline &amp;&amp; m_preparedForInlineCompletionHandler) {
6195         m_preparedForInlineCompletionHandler();
6196         m_preparedForInlineCompletionHandler = nullptr;
6197     }
6198 }
6199 
6200 void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6201 {
6202     ASSERT(!m_preparedForInlineCompletionHandler);
6203     if (m_preparedForInline)  {
6204         completionHandler();
6205         return;
6206     }
6207 
6208     m_preparedForInlineCompletionHandler = WTFMove(completionHandler);
6209 }
6210 
6211 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6212 
6213 void HTMLMediaElement::willExitFullscreen()
6214 {
6215     if (m_player)
6216         m_player-&gt;updateVideoFullscreenInlineImage();
6217 }
6218 
6219 bool HTMLMediaElement::isVideoLayerInline()
6220 {
6221     return !m_videoFullscreenLayer;
6222 };
6223 
6224 void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6225 {
6226     m_videoFullscreenLayer = platformLayer;
6227     if (!m_player) {
6228         completionHandler();
6229         return;
6230     }
6231 
6232     m_player-&gt;setVideoFullscreenLayer(platformLayer, WTFMove(completionHandler));
6233     invalidateStyleAndLayerComposition();
6234 #if ENABLE(VIDEO_TRACK)
6235     updateTextTrackDisplay();
6236 #endif
6237 }
6238 
6239 void HTMLMediaElement::setVideoFullscreenFrame(FloatRect frame)
6240 {
6241     m_videoFullscreenFrame = frame;
6242     if (m_player)
6243         m_player-&gt;setVideoFullscreenFrame(frame);
6244 }
6245 
6246 void HTMLMediaElement::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
6247 {
6248     m_videoFullscreenGravity = gravity;
6249     if (m_player)
6250         m_player-&gt;setVideoFullscreenGravity(gravity);
6251 }
6252 
6253 #else
6254 
6255 bool HTMLMediaElement::isVideoLayerInline()
6256 {
6257     return true;
6258 };
6259 
6260 #endif
6261 
6262 bool HTMLMediaElement::hasClosedCaptions() const
6263 {
6264     if (m_player &amp;&amp; m_player-&gt;hasClosedCaptions())
6265         return true;
6266 
6267 #if ENABLE(VIDEO_TRACK)
6268     if (!m_textTracks)
6269         return false;
6270 
6271     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6272         auto&amp; track = *m_textTracks-&gt;item(i);
6273         if (track.readinessState() == TextTrack::FailedToLoad)
6274             continue;
6275         if (track.kind() == TextTrack::Kind::Captions || track.kind() == TextTrack::Kind::Subtitles)
6276             return true;
6277     }
6278 #endif
6279 
6280     return false;
6281 }
6282 
6283 bool HTMLMediaElement::closedCaptionsVisible() const
6284 {
6285     return m_closedCaptionsVisible;
6286 }
6287 
6288 #if ENABLE(VIDEO_TRACK)
6289 
6290 void HTMLMediaElement::updateTextTrackDisplay()
6291 {
6292 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6293     ensureMediaControlsShadowRoot();
6294     if (!m_mediaControlsHost)
6295         m_mediaControlsHost = MediaControlsHost::create(this);
6296     m_mediaControlsHost-&gt;updateTextTrackContainer();
6297 #else
6298     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6299         return;
6300 
6301     mediaControls()-&gt;updateTextTrackDisplay();
6302 #endif
6303 }
6304 
6305 #endif
6306 
6307 void HTMLMediaElement::setClosedCaptionsVisible(bool closedCaptionVisible)
6308 {
6309     INFO_LOG(LOGIDENTIFIER, closedCaptionVisible);
6310 
6311     m_closedCaptionsVisible = false;
6312 
6313     if (!m_player || !hasClosedCaptions())
6314         return;
6315 
6316     m_closedCaptionsVisible = closedCaptionVisible;
6317     m_player-&gt;setClosedCaptionsVisible(closedCaptionVisible);
6318 
6319 #if ENABLE(VIDEO_TRACK)
6320     markCaptionAndSubtitleTracksAsUnconfigured(Immediately);
6321     updateTextTrackDisplay();
6322 #else
6323     if (hasMediaControls())
6324         mediaControls()-&gt;changedClosedCaptionsVisibility();
6325 #endif
6326 }
6327 
6328 void HTMLMediaElement::setWebkitClosedCaptionsVisible(bool visible)
6329 {
6330     m_webkitLegacyClosedCaptionOverride = visible;
6331     setClosedCaptionsVisible(visible);
6332 }
6333 
6334 bool HTMLMediaElement::webkitClosedCaptionsVisible() const
6335 {
6336     return m_webkitLegacyClosedCaptionOverride &amp;&amp; m_closedCaptionsVisible;
6337 }
6338 
6339 
6340 bool HTMLMediaElement::webkitHasClosedCaptions() const
6341 {
6342     return hasClosedCaptions();
6343 }
6344 
6345 #if ENABLE(MEDIA_STATISTICS)
6346 unsigned HTMLMediaElement::webkitAudioDecodedByteCount() const
6347 {
6348     if (!m_player)
6349         return 0;
6350     return m_player-&gt;audioDecodedByteCount();
6351 }
6352 
6353 unsigned HTMLMediaElement::webkitVideoDecodedByteCount() const
6354 {
6355     if (!m_player)
6356         return 0;
6357     return m_player-&gt;videoDecodedByteCount();
6358 }
6359 #endif
6360 
6361 void HTMLMediaElement::mediaCanStart(Document&amp; document)
6362 {
6363     ASSERT_UNUSED(document, &amp;document == &amp;this-&gt;document());
6364     INFO_LOG(LOGIDENTIFIER, &quot;m_isWaitingUntilMediaCanStart = &quot;, m_isWaitingUntilMediaCanStart, &quot;, m_pausedInternal = &quot;, m_pausedInternal);
6365 
6366     ASSERT(m_isWaitingUntilMediaCanStart || m_pausedInternal);
6367     if (m_isWaitingUntilMediaCanStart) {
6368         m_isWaitingUntilMediaCanStart = false;
6369         selectMediaResource();
6370     }
6371     if (m_pausedInternal)
6372         setPausedInternal(false);
6373 }
6374 
6375 bool HTMLMediaElement::isURLAttribute(const Attribute&amp; attribute) const
6376 {
6377     return attribute.name() == srcAttr || HTMLElement::isURLAttribute(attribute);
6378 }
6379 
6380 void HTMLMediaElement::setShouldDelayLoadEvent(bool shouldDelay)
6381 {
6382     if (m_shouldDelayLoadEvent == shouldDelay)
6383         return;
6384 
6385     INFO_LOG(LOGIDENTIFIER, shouldDelay);
6386 
6387     m_shouldDelayLoadEvent = shouldDelay;
6388     if (shouldDelay)
6389         document().incrementLoadEventDelayCount();
6390     else
6391         document().decrementLoadEventDelayCount();
6392 }
6393 
6394 static String&amp; sharedMediaCacheDirectory()
6395 {
6396     static NeverDestroyed&lt;String&gt; sharedMediaCacheDirectory;
6397     return sharedMediaCacheDirectory;
6398 }
6399 
6400 void HTMLMediaElement::setMediaCacheDirectory(const String&amp; path)
6401 {
6402     sharedMediaCacheDirectory() = path;
6403 }
6404 
6405 const String&amp; HTMLMediaElement::mediaCacheDirectory()
6406 {
6407     return sharedMediaCacheDirectory();
6408 }
6409 
6410 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; HTMLMediaElement::originsInMediaCache(const String&amp; path)
6411 {
6412     return MediaPlayer::originsInMediaCache(path);
6413 }
6414 
6415 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6416 {
6417     MediaPlayer::clearMediaCache(path, modifiedSince);
6418 }
6419 
6420 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6421 {
6422     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6423 }
6424 
6425 void HTMLMediaElement::resetMediaEngines()
6426 {
6427     MediaPlayer::resetMediaEngines();
6428 }
6429 
<a name="95" id="anc95"></a><span class="line-modified">6430 void HTMLMediaElement::privateBrowsingStateDidChange()</span>
6431 {
6432     if (!m_player)
6433         return;
6434 
<a name="96" id="anc96"></a><span class="line-modified">6435     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();</span>
<span class="line-removed">6436     m_player-&gt;setPrivateBrowsingMode(privateMode);</span>
6437 }
6438 
6439 MediaControls* HTMLMediaElement::mediaControls() const
6440 {
6441 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6442     return nullptr;
6443 #else
6444     auto root = userAgentShadowRoot();
6445     if (!root)
6446         return nullptr;
6447 
6448     return childrenOfType&lt;MediaControls&gt;(*root).first();
6449 #endif
6450 }
6451 
6452 bool HTMLMediaElement::hasMediaControls() const
6453 {
6454 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6455     return false;
6456 #else
6457 
6458     if (auto userAgent = userAgentShadowRoot()) {
6459         RefPtr&lt;Node&gt; node = childrenOfType&lt;MediaControls&gt;(*root).first();
6460         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isMediaControls());
6461         return node;
6462     }
6463 
6464     return false;
6465 #endif
6466 }
6467 
6468 bool HTMLMediaElement::createMediaControls()
6469 {
6470 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6471     ensureMediaControlsShadowRoot();
6472     return false;
6473 #else
6474     if (hasMediaControls())
6475         return true;
6476 
6477     auto mediaControls = MediaControls::create(document());
6478     if (!mediaControls)
6479         return false;
6480 
6481     mediaControls-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6482     mediaControls-&gt;reset();
6483     if (isFullscreen())
6484         mediaControls-&gt;enteredFullscreen();
6485 
6486     ensureUserAgentShadowRoot().appendChild(mediaControls);
6487 
6488     if (!controls() || !isConnected())
6489         mediaControls-&gt;hide();
6490 
6491     return true;
6492 #endif
6493 }
6494 
6495 bool HTMLMediaElement::shouldForceControlsDisplay() const
6496 {
6497     // Always create controls for autoplay video that requires user gesture due to being in low power mode.
6498     return isVideo() &amp;&amp; autoplay() &amp;&amp; m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
6499 }
6500 
6501 void HTMLMediaElement::configureMediaControls()
6502 {
6503     bool requireControls = controls();
6504 
6505     // Always create controls for video when fullscreen playback is required.
6506     if (isVideo() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback())
6507         requireControls = true;
6508 
6509     if (shouldForceControlsDisplay())
6510         requireControls = true;
6511 
6512     // Always create controls when in full screen mode.
6513     if (isFullscreen())
6514         requireControls = true;
6515 
6516 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6517     if (m_isPlayingToWirelessTarget)
6518         requireControls = true;
6519 #endif
6520 
6521 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6522     if (!requireControls || !isConnected() || !inActiveDocument())
6523         return;
6524 
6525     ensureMediaControlsShadowRoot();
6526 #else
6527     if (!requireControls || !isConnected() || !inActiveDocument()) {
6528         if (hasMediaControls())
6529             mediaControls()-&gt;hide();
6530         return;
6531     }
6532 
6533     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6534         return;
6535 
6536     mediaControls()-&gt;show();
6537 #endif
6538 }
6539 
6540 #if ENABLE(VIDEO_TRACK)
6541 void HTMLMediaElement::configureTextTrackDisplay(TextTrackVisibilityCheckType checkType)
6542 {
6543     ALWAYS_LOG(LOGIDENTIFIER);
6544     ASSERT(m_textTracks);
6545 
6546     if (m_processingPreferenceChange)
6547         return;
6548 
6549     if (document().activeDOMObjectsAreStopped())
6550         return;
6551 
6552     bool haveVisibleTextTrack = false;
6553     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6554         if (m_textTracks-&gt;item(i)-&gt;mode() == TextTrack::Mode::Showing) {
6555             haveVisibleTextTrack = true;
6556             break;
6557         }
6558     }
6559 
6560     if (checkType == CheckTextTrackVisibility &amp;&amp; m_haveVisibleTextTrack == haveVisibleTextTrack) {
6561         updateActiveTextTrackCues(currentMediaTime());
6562         return;
6563     }
6564 
6565     m_haveVisibleTextTrack = haveVisibleTextTrack;
6566     m_closedCaptionsVisible = m_haveVisibleTextTrack;
6567 
6568 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6569     if (!m_haveVisibleTextTrack)
6570         return;
6571 
6572     ensureMediaControlsShadowRoot();
6573 #else
6574     if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
6575         return;
6576     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6577         return;
6578 
6579     mediaControls()-&gt;changedClosedCaptionsVisibility();
6580 
6581     updateTextTrackDisplay();
6582     updateActiveTextTrackCues(currentMediaTime());
6583 #endif
6584 }
6585 
6586 void HTMLMediaElement::captionPreferencesChanged()
6587 {
6588     if (!isVideo())
6589         return;
6590 
6591     if (hasMediaControls())
6592         mediaControls()-&gt;textTrackPreferencesChanged();
6593 
6594 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6595     if (m_mediaControlsHost)
6596         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();
6597 #endif
6598 
6599     if (m_player)
6600         m_player-&gt;tracksChanged();
6601 
6602     if (!document().page())
6603         return;
6604 
6605     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6606     if (captionDisplayMode() == displayMode)
6607         return;
6608 
6609     m_captionDisplayMode = displayMode;
6610     setWebkitClosedCaptionsVisible(captionDisplayMode() == CaptionUserPreferences::AlwaysOn);
6611 }
6612 
6613 CaptionUserPreferences::CaptionDisplayMode HTMLMediaElement::captionDisplayMode()
6614 {
6615     if (!m_captionDisplayMode.hasValue()) {
6616         if (document().page())
6617             m_captionDisplayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6618         else
6619             m_captionDisplayMode = CaptionUserPreferences::Automatic;
6620     }
6621 
6622     return m_captionDisplayMode.value();
6623 }
6624 
6625 void HTMLMediaElement::markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode mode)
6626 {
6627     if (!m_textTracks)
6628         return;
6629 
6630     INFO_LOG(LOGIDENTIFIER);
6631 
6632     // Mark all tracks as not &quot;configured&quot; so that configureTextTracks()
6633     // will reconsider which tracks to display in light of new user preferences
6634     // (e.g. default tracks should not be displayed if the user has turned off
6635     // captions and non-default tracks should be displayed based on language
6636     // preferences if the user has turned captions on).
6637     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6638         auto&amp; track = *m_textTracks-&gt;item(i);
6639         auto kind = track.kind();
6640         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions)
6641             track.setHasBeenConfigured(false);
6642     }
6643 
6644     m_processingPreferenceChange = true;
6645     m_configureTextTracksTask.cancelTask();
6646     if (mode == Immediately) {
6647         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
6648         configureTextTracks();
6649     }
6650     else
6651         scheduleConfigureTextTracks();
6652 }
6653 
6654 #endif
6655 
6656 void HTMLMediaElement::createMediaPlayer()
6657 {
6658     INFO_LOG(LOGIDENTIFIER);
6659 
6660 #if ENABLE(WEB_AUDIO)
6661     if (m_audioSourceNode)
6662         m_audioSourceNode-&gt;lock();
6663 #endif
6664 
6665 #if ENABLE(MEDIA_SOURCE)
6666     detachMediaSource();
6667 #endif
6668 
6669 #if ENABLE(VIDEO_TRACK)
6670     forgetResourceSpecificTracks();
6671 #endif
6672 
6673 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6674     if (m_isPlayingToWirelessTarget)
6675         setIsPlayingToWirelessTarget(false);
6676 #endif
6677 
6678     m_player = MediaPlayer::create(*this);
<a name="97" id="anc97"></a><span class="line-modified">6679     m_player-&gt;setShouldBufferData(m_shouldBufferData);</span>
6680     schedulePlaybackControlsManagerUpdate();
6681 
6682 #if ENABLE(WEB_AUDIO)
6683     if (m_audioSourceNode) {
6684         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6685         if (audioSourceProvider())
6686             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6687 
6688         m_audioSourceNode-&gt;unlock();
6689     }
6690 #endif
6691 
6692 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6693     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
6694         m_hasPlaybackTargetAvailabilityListeners = true;
6695         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6696         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6697     }
6698 #endif
6699 
6700     updateSleepDisabling();
6701 }
6702 
6703 #if ENABLE(WEB_AUDIO)
6704 void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
6705 {
6706     m_audioSourceNode = sourceNode;
6707 
6708     if (audioSourceProvider())
6709         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6710 }
6711 
6712 AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
6713 {
6714     if (m_player)
6715         return m_player-&gt;audioSourceProvider();
6716 
6717     return 0;
6718 }
6719 #endif
6720 
6721 const String&amp; HTMLMediaElement::mediaGroup() const
6722 {
6723     return m_mediaGroup;
6724 }
6725 
6726 void HTMLMediaElement::setMediaGroup(const String&amp; group)
6727 {
6728     if (m_mediaGroup == group)
6729         return;
6730     m_mediaGroup = group;
6731 
6732     // When a media element is created with a mediagroup attribute, and when a media element&#39;s mediagroup
6733     // attribute is set, changed, or removed, the user agent must run the following steps:
6734     // 1. Let m [this] be the media element in question.
6735     // 2. Let m have no current media controller, if it currently has one.
6736     setController(nullptr);
6737 
6738     // 3. If m&#39;s mediagroup attribute is being removed, then abort these steps.
6739     if (group.isEmpty())
6740         return;
6741 
6742     // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
6743     // of these elements are not actually in the Document),
6744     HashSet&lt;HTMLMediaElement*&gt; elements = documentToElementSetMap().get(&amp;document());
6745     for (auto&amp; element : elements) {
6746         if (element == this)
6747             continue;
6748 
6749         // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
6750         // the new value of m&#39;s mediagroup attribute,
6751         if (element-&gt;mediaGroup() == group) {
6752             //  then let controller be that media element&#39;s current media controller.
6753             setController(element-&gt;controller());
6754             return;
6755         }
6756     }
6757 
6758     // Otherwise, let controller be a newly created MediaController.
6759     setController(MediaController::create(document()));
6760 }
6761 
6762 MediaController* HTMLMediaElement::controller() const
6763 {
6764     return m_mediaController.get();
6765 }
6766 
6767 void HTMLMediaElement::setController(RefPtr&lt;MediaController&gt;&amp;&amp; controller)
6768 {
6769     if (m_mediaController)
6770         m_mediaController-&gt;removeMediaElement(*this);
6771 
6772     m_mediaController = WTFMove(controller);
6773 
6774     if (m_mediaController)
6775         m_mediaController-&gt;addMediaElement(*this);
6776 
6777     if (hasMediaControls())
6778         mediaControls()-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6779 }
6780 
6781 void HTMLMediaElement::setControllerForBindings(MediaController* controller)
6782 {
6783     // 4.8.10.11.2 Media controllers: controller attribute.
6784     // On setting, it must first remove the element&#39;s mediagroup attribute, if any,
6785     setMediaGroup({ });
6786     // and then set the current media controller to the given value.
6787     setController(controller);
6788 }
6789 
6790 void HTMLMediaElement::updateMediaController()
6791 {
6792     if (m_mediaController)
6793         m_mediaController-&gt;reportControllerState();
6794 }
6795 
6796 bool HTMLMediaElement::isBlocked() const
6797 {
6798     // A media element is a blocked media element if its readyState attribute is in the
6799     // HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state,
6800     if (m_readyState &lt;= HAVE_CURRENT_DATA)
6801         return true;
6802 
6803     // or if the element has paused for user interaction.
6804     return pausedForUserInteraction();
6805 }
6806 
6807 bool HTMLMediaElement::isBlockedOnMediaController() const
6808 {
6809     if (!m_mediaController)
6810         return false;
6811 
6812     // A media element is blocked on its media controller if the MediaController is a blocked
6813     // media controller,
6814     if (m_mediaController-&gt;isBlocked())
6815         return true;
6816 
6817     // or if its media controller position is either before the media resource&#39;s earliest possible
6818     // position relative to the MediaController&#39;s timeline or after the end of the media resource
6819     // relative to the MediaController&#39;s timeline.
6820     double mediaControllerPosition = m_mediaController-&gt;currentTime();
6821     if (mediaControllerPosition &lt; 0 || mediaControllerPosition &gt; duration())
6822         return true;
6823 
6824     return false;
6825 }
6826 
6827 void HTMLMediaElement::prepareMediaFragmentURI()
6828 {
6829     MediaFragmentURIParser fragmentParser(m_currentSrc);
6830     MediaTime dur = durationMediaTime();
6831 
6832     MediaTime start = fragmentParser.startTime();
6833     if (start.isValid() &amp;&amp; start &gt; MediaTime::zeroTime()) {
6834         m_fragmentStartTime = start;
6835         if (m_fragmentStartTime &gt; dur)
6836             m_fragmentStartTime = dur;
6837     } else
6838         m_fragmentStartTime = MediaTime::invalidTime();
6839 
6840     MediaTime end = fragmentParser.endTime();
6841     if (end.isValid() &amp;&amp; end &gt; MediaTime::zeroTime() &amp;&amp; (!m_fragmentStartTime.isValid() || end &gt; m_fragmentStartTime)) {
6842         m_fragmentEndTime = end;
6843         if (m_fragmentEndTime &gt; dur)
6844             m_fragmentEndTime = dur;
6845     } else
6846         m_fragmentEndTime = MediaTime::invalidTime();
6847 
6848     if (m_fragmentStartTime.isValid() &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
6849         prepareToPlay();
6850 }
6851 
6852 void HTMLMediaElement::applyMediaFragmentURI()
6853 {
6854     if (m_fragmentStartTime.isValid()) {
6855         m_sentEndEvent = false;
6856         seek(m_fragmentStartTime);
6857     }
6858 }
6859 
6860 void HTMLMediaElement::updateSleepDisabling()
6861 {
6862     SleepType shouldDisableSleep = this-&gt;shouldDisableSleep();
6863     if (shouldDisableSleep == SleepType::None &amp;&amp; m_sleepDisabler)
6864         m_sleepDisabler = nullptr;
6865     else if (shouldDisableSleep != SleepType::None) {
6866         auto type = shouldDisableSleep == SleepType::Display ? PAL::SleepDisabler::Type::Display : PAL::SleepDisabler::Type::System;
6867         if (!m_sleepDisabler || m_sleepDisabler-&gt;type() != type)
6868             m_sleepDisabler = PAL::SleepDisabler::create(&quot;com.apple.WebCore: HTMLMediaElement playback&quot;, type);
6869     }
6870 
6871     if (m_player)
6872         m_player-&gt;setShouldDisableSleep(shouldDisableSleep == SleepType::Display);
6873 }
6874 
6875 #if ENABLE(MEDIA_STREAM)
6876 static inline bool isRemoteMediaStreamVideoTrack(RefPtr&lt;MediaStreamTrack&gt;&amp; item)
6877 {
6878     auto* track = item.get();
6879     return track-&gt;privateTrack().type() == RealtimeMediaSource::Type::Video &amp;&amp; !track-&gt;isCaptureTrack() &amp;&amp; !track-&gt;isCanvas();
6880 }
6881 #endif
6882 
6883 HTMLMediaElement::SleepType HTMLMediaElement::shouldDisableSleep() const
6884 {
6885 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(GTK) &amp;&amp; !PLATFORM(WPE)
6886     return SleepType::None;
6887 #endif
6888     if (!m_player || m_player-&gt;paused() || loop())
6889         return SleepType::None;
6890 
6891 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6892     // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
6893     if (m_isPlayingToWirelessTarget)
6894         return SleepType::System;
6895 #endif
6896 
<a name="98" id="anc98"></a><span class="line-modified">6897     bool shouldBeAbleToSleep = !hasVideo() || !hasAudio();</span>



6898 #if ENABLE(MEDIA_STREAM)
6899     // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
6900     // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
6901     shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
6902 #endif
6903 
6904     if (shouldBeAbleToSleep)
6905         return SleepType::None;
6906 
6907     if (m_elementIsHidden)
6908         return SleepType::System;
6909 
6910     return SleepType::Display;
6911 }
6912 
6913 String HTMLMediaElement::mediaPlayerReferrer() const
6914 {
6915     RefPtr&lt;Frame&gt; frame = document().frame();
6916     if (!frame)
6917         return String();
6918 
6919     return SecurityPolicy::generateReferrerHeader(document().referrerPolicy(), m_currentSrc, frame-&gt;loader().outgoingReferrer());
6920 }
6921 
6922 String HTMLMediaElement::mediaPlayerUserAgent() const
6923 {
6924     RefPtr&lt;Frame&gt; frame = document().frame();
6925     if (!frame)
6926         return String();
6927 
6928     return frame-&gt;loader().userAgent(m_currentSrc);
6929 }
6930 
6931 #if ENABLE(AVF_CAPTIONS)
6932 
6933 static inline PlatformTextTrack::TrackKind toPlatform(TextTrack::Kind kind)
6934 {
6935     switch (kind) {
6936     case TextTrack::Kind::Captions:
6937         return PlatformTextTrack::Caption;
6938     case TextTrack::Kind::Chapters:
6939         return PlatformTextTrack::Chapter;
6940     case TextTrack::Kind::Descriptions:
6941         return PlatformTextTrack::Description;
6942     case TextTrack::Kind::Forced:
6943         return PlatformTextTrack::Forced;
6944     case TextTrack::Kind::Metadata:
6945         return PlatformTextTrack::MetaData;
6946     case TextTrack::Kind::Subtitles:
6947         return PlatformTextTrack::Subtitle;
6948     }
6949     ASSERT_NOT_REACHED();
6950     return PlatformTextTrack::Caption;
6951 }
6952 
6953 static inline PlatformTextTrack::TrackMode toPlatform(TextTrack::Mode mode)
6954 {
6955     switch (mode) {
6956     case TextTrack::Mode::Disabled:
6957         return PlatformTextTrack::Disabled;
6958     case TextTrack::Mode::Hidden:
6959         return PlatformTextTrack::Hidden;
6960     case TextTrack::Mode::Showing:
6961         return PlatformTextTrack::Showing;
6962     }
6963     ASSERT_NOT_REACHED();
6964     return PlatformTextTrack::Disabled;
6965 }
6966 
6967 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; HTMLMediaElement::outOfBandTrackSources()
6968 {
6969     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources;
6970     for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
6971         URL url = trackElement.getNonEmptyURLAttribute(srcAttr);
6972         if (url.isEmpty())
6973             continue;
6974 
6975         if (!isAllowedToLoadMediaURL(*this, url, trackElement.isInUserAgentShadowTree()))
6976             continue;
6977 
6978         auto&amp; track = trackElement.track();
6979         auto kind = track.kind();
6980 
6981         // FIXME: The switch statement below preserves existing behavior where we ignore chapters and metadata tracks.
6982         // If we confirm this behavior is valuable, we should remove this comment. Otherwise, remove both comment and switch.
6983         switch (kind) {
6984         case TextTrack::Kind::Captions:
6985         case TextTrack::Kind::Descriptions:
6986         case TextTrack::Kind::Forced:
6987         case TextTrack::Kind::Subtitles:
6988             break;
6989         case TextTrack::Kind::Chapters:
6990         case TextTrack::Kind::Metadata:
6991             continue;
6992         }
6993 
6994         outOfBandTrackSources.append(PlatformTextTrack::createOutOfBand(trackElement.label(), trackElement.srclang(), url.string(), toPlatform(track.mode()), toPlatform(kind), track.uniqueId(), trackElement.isDefault()));
6995     }
6996 
6997     return outOfBandTrackSources;
6998 }
6999 
7000 #endif
7001 
7002 void HTMLMediaElement::mediaPlayerEnterFullscreen()
7003 {
7004     enterFullscreen();
7005 }
7006 
7007 void HTMLMediaElement::mediaPlayerExitFullscreen()
7008 {
7009     exitFullscreen();
7010 }
7011 
7012 bool HTMLMediaElement::mediaPlayerIsFullscreen() const
7013 {
7014     return isFullscreen();
7015 }
7016 
7017 bool HTMLMediaElement::mediaPlayerIsFullscreenPermitted() const
7018 {
7019     return m_mediaSession-&gt;fullscreenPermitted();
7020 }
7021 
7022 bool HTMLMediaElement::mediaPlayerIsVideo() const
7023 {
7024     return isVideo();
7025 }
7026 
7027 LayoutRect HTMLMediaElement::mediaPlayerContentBoxRect() const
7028 {
7029     auto* renderer = this-&gt;renderer();
7030     if (!renderer)
7031         return { };
7032     return renderer-&gt;enclosingBox().contentBoxRect();
7033 }
7034 
7035 float HTMLMediaElement::mediaPlayerContentsScale() const
7036 {
7037     if (auto page = document().page())
7038         return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
7039     return 1;
7040 }
7041 
7042 void HTMLMediaElement::mediaPlayerSetSize(const IntSize&amp; size)
7043 {
7044     setIntegralAttribute(widthAttr, size.width());
7045     setIntegralAttribute(heightAttr, size.height());
7046 }
7047 
7048 void HTMLMediaElement::mediaPlayerPause()
7049 {
7050     pause();
7051 }
7052 
7053 void HTMLMediaElement::mediaPlayerPlay()
7054 {
7055     play();
7056 }
7057 
7058 bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
7059 {
7060     return !m_volumeInitialized;
7061 }
7062 
7063 bool HTMLMediaElement::mediaPlayerIsPaused() const
7064 {
7065     return paused();
7066 }
7067 
7068 bool HTMLMediaElement::mediaPlayerIsLooping() const
7069 {
7070     return loop();
7071 }
7072 
7073 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7074 {
7075     return &amp;document().cachedResourceLoader();
7076 }
7077 
7078 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7079 {
7080     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7081 
7082     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7083 
<a name="99" id="anc99"></a><span class="line-modified">7084     return WTFMove(mediaResourceLoader);</span>
7085 }
7086 
7087 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7088 {
7089     return m_lastMediaResourceLoaderForTesting.get();
7090 }
7091 
7092 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7093 {
7094     if (Page* page = document().page())
7095         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();
7096 
7097     return false;
7098 }
7099 
7100 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7101 {
7102     return mediaCacheDirectory();
7103 }
7104 
7105 String HTMLMediaElement::sourceApplicationIdentifier() const
7106 {
7107     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7108         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7109             return networkingContext-&gt;sourceApplicationIdentifier();
7110     }
7111     return emptyString();
7112 }
7113 
7114 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7115 {
<a name="100" id="anc100"></a><span class="line-removed">7116 #if ENABLE(VIDEO_TRACK)</span>
7117     if (Page* page = document().page())
7118         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<a name="101" id="anc101"></a><span class="line-removed">7119 #endif</span>
7120     return Vector&lt;String&gt;();
7121 }
7122 
7123 #if PLATFORM(IOS_FAMILY)
7124 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7125 {
7126     return DeprecatedGlobalSettings::networkInterfaceName();
7127 }
7128 
7129 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7130 {
7131     if (auto* page = document().page())
7132         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7133     return false;
7134 }
7135 #endif
7136 
7137 bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const
7138 {
7139     return document().isMediaDocument();
7140 }
7141 
7142 void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
7143 {
7144     if (!m_player)
7145         return;
7146 
7147     if (auto* page = document().page())
7148         page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValue(DiagnosticLoggingKeys::engineFailedToLoadKey(), m_player-&gt;engineDescription(), m_player-&gt;platformErrorCode(), 4, ShouldSample::No);
7149 }
7150 
7151 double HTMLMediaElement::mediaPlayerRequestedPlaybackRate() const
7152 {
7153     return potentiallyPlaying() ? requestedPlaybackRate() : 0;
7154 }
7155 
7156 const Vector&lt;ContentType&gt;&amp; HTMLMediaElement::mediaContentTypesRequiringHardwareSupport() const
7157 {
7158     return document().settings().mediaContentTypesRequiringHardwareSupport();
7159 }
7160 
7161 bool HTMLMediaElement::mediaPlayerShouldCheckHardwareSupport() const
7162 {
7163     if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback())
7164         return true;
7165 
7166     if (m_loadState == LoadingFromSourceElement &amp;&amp; m_currentSourceNode &amp;&amp; !m_nextChildNodeToConsider)
7167         return false;
7168 
7169     if (m_loadState == LoadingFromSrcAttr)
7170         return false;
7171 
7172     return true;
7173 }
7174 
7175 #if USE(GSTREAMER)
7176 void HTMLMediaElement::requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback)
7177 {
7178     if (!document().page())
7179         return;
7180 
7181     document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
7182 }
7183 #endif
7184 
<a name="102" id="anc102"></a><span class="line-modified">7185 void HTMLMediaElement::removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
7186 {
7187     MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
7188         (MediaElementSession::RequireUserGestureForLoad
7189 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7190         | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
7191         | MediaElementSession::RequireUserGestureToAutoplayToExternalDevice
7192 #endif
7193         | MediaElementSession::RequireUserGestureForVideoRateChange
7194         | MediaElementSession::RequireUserGestureForAudioRateChange
7195         | MediaElementSession::RequireUserGestureForFullscreen
7196         | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
7197         | MediaElementSession::InvisibleAutoplayNotPermitted
7198         | MediaElementSession::RequireUserGestureToControlControlsManager);
7199 
<a name="103" id="anc103"></a>

7200     m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
7201     document().topDocument().noteUserInteractionWithMediaElement();
7202 }
7203 
7204 void HTMLMediaElement::updateRateChangeRestrictions()
7205 {
7206     const auto&amp; document = this-&gt;document();
7207     if (!document.ownerElement() &amp;&amp; document.isMediaDocument())
7208         return;
7209 
7210     const auto&amp; topDocument = document.topDocument();
7211     if (topDocument.videoPlaybackRequiresUserGesture())
7212         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7213     else
7214         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7215 
7216     if (topDocument.audioPlaybackRequiresUserGesture())
7217         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7218     else
7219         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7220 }
7221 
7222 RefPtr&lt;VideoPlaybackQuality&gt; HTMLMediaElement::getVideoPlaybackQuality()
7223 {
7224     RefPtr&lt;DOMWindow&gt; domWindow = document().domWindow();
7225     double timestamp = domWindow ? 1000 * domWindow-&gt;nowTimestamp() : 0;
7226 
7227     auto metrics = m_player ? m_player-&gt;videoPlaybackQualityMetrics() : WTF::nullopt;
7228     if (!metrics)
7229         return VideoPlaybackQuality::create(timestamp, { });
7230 
7231 #if ENABLE(MEDIA_SOURCE)
7232     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7233     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7234 #endif
7235 
7236     return VideoPlaybackQuality::create(timestamp, metrics.value());
7237 }
7238 
7239 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7240 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7241 {
7242     if (!m_isolatedWorld)
7243         m_isolatedWorld = DOMWrapperWorld::create(commonVM());
7244     return *m_isolatedWorld;
7245 }
7246 
7247 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7248 {
<a name="104" id="anc104"></a><span class="line-modified">7249     DEBUG_LOG(LOGIDENTIFIER);</span>
7250 
7251     Page* page = document().page();
7252     if (!page)
7253         return false;
7254 
7255     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7256     if (!mediaControlsScript.length())
7257         return false;
7258 
7259     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
7260         auto&amp; vm = globalObject.vm();
7261         auto scope = DECLARE_CATCH_SCOPE(vm);
7262 
<a name="105" id="anc105"></a><span class="line-modified">7263         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
7264         if (functionValue.isFunction(vm))
7265             return true;
7266 
7267 #ifndef NDEBUG
7268         // Setting a scriptURL allows the source to be debuggable in the inspector.
7269         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7270 #else
7271         URL scriptURL;
7272 #endif
7273         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);
7274         if (UNLIKELY(scope.exception())) {
7275             scope.clearException();
7276             return false;
7277         }
7278 
7279         return true;
7280     });
7281 }
7282 
7283 void HTMLMediaElement::updatePageScaleFactorJSProperty()
7284 {
7285     Page* page = document().page();
7286     if (!page)
7287         return;
7288 
7289     setControllerJSProperty(&quot;pageScaleFactor&quot;, JSC::jsNumber(page-&gt;pageScaleFactor()));
7290 }
7291 
7292 void HTMLMediaElement::updateUsesLTRUserInterfaceLayoutDirectionJSProperty()
7293 {
7294     Page* page = document().page();
7295     if (!page)
7296         return;
7297 
7298     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7299     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7300 }
7301 
7302 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7303 {
7304     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7305         auto&amp; vm = globalObject.vm();
7306         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7307         if (controllerValue.isNull())
7308             return false;
7309 
7310         JSC::PutPropertySlot propertySlot(controllerValue);
7311         auto* controllerObject = controllerValue.toObject(&amp;exec);
7312         if (!controllerObject)
7313             return false;
7314 
<a name="106" id="anc106"></a><span class="line-modified">7315         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(&amp;exec, propertyName), propertyValue, propertySlot);</span>
7316 
7317         return true;
7318     });
7319 }
7320 
7321 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7322 {
<a name="107" id="anc107"></a><span class="line-modified">7323     DEBUG_LOG(LOGIDENTIFIER);</span>
7324 
7325     if (!ensureMediaControlsInjectedScript())
7326         return;
7327 
7328     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7329         auto&amp; vm = globalObject.vm();
7330         auto scope = DECLARE_CATCH_SCOPE(vm);
7331 
7332         // The media controls script must provide a method with the following details.
7333         // Name: createControls
7334         // Parameters:
7335         //     1. The ShadowRoot element that will hold the controls.
7336         //     2. This object (and HTMLMediaElement).
7337         //     3. The MediaControlsHost object.
7338         // Return value:
7339         //     A reference to the created media controller instance.
7340 
<a name="108" id="anc108"></a><span class="line-modified">7341         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
7342         if (functionValue.isUndefinedOrNull())
7343             return false;
7344 
7345         if (!m_mediaControlsHost)
7346             m_mediaControlsHost = MediaControlsHost::create(this);
7347 
7348         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);
7349         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);
7350 
7351         JSC::MarkedArgumentBuffer argList;
7352         argList.append(toJS(&amp;exec, &amp;globalObject, root));
7353         argList.append(mediaJSWrapper);
7354         argList.append(mediaControlsHostJSWrapper);
7355         ASSERT(!argList.hasOverflowed());
7356 
7357         auto* function = functionValue.toObject(&amp;exec);
7358         scope.assertNoException();
7359         JSC::CallData callData;
7360         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7361         if (callType == JSC::CallType::None)
7362             return false;
7363 
7364         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);
7365         scope.clearException();
7366         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7367         if (!controllerObject)
7368             return false;
7369 
7370         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
7371         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
7372         scope.assertNoException();
<a name="109" id="anc109"></a><span class="line-modified">7373         auto controlsHost = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controlsHost&quot;);</span>
7374 
7375         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
7376 
<a name="110" id="anc110"></a><span class="line-modified">7377         mediaJSWrapperObject-&gt;putDirect(exec.vm(), controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7378 
7379         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7380         if (!mediaControlsHostJSWrapperObject)
7381             return false;
7382 
<a name="111" id="anc111"></a><span class="line-modified">7383         auto controller = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controller&quot;);</span>
7384 
7385         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
7386 
<a name="112" id="anc112"></a><span class="line-modified">7387         mediaControlsHostJSWrapperObject-&gt;putDirect(exec.vm(), controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7388 
7389         updatePageScaleFactorJSProperty();
7390         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7391 
7392         if (UNLIKELY(scope.exception()))
7393             scope.clearException();
7394 
7395         return true;
7396     });
7397 }
7398 
7399 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7400 {
<a name="113" id="anc113"></a><span class="line-modified">7401     DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, dependsOnPageScale);</span>
7402 
7403     if (document().settings().mediaControlsScaleWithPageZoom()) {
<a name="114" id="anc114"></a><span class="line-modified">7404         DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, &quot;forced to false by Settings value&quot;);</span>
7405         m_mediaControlsDependOnPageScaleFactor = false;
7406         return;
7407     }
7408 
7409     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
7410         return;
7411 
7412     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
7413 
7414     if (m_mediaControlsDependOnPageScaleFactor)
7415         document().registerForPageScaleFactorChangedCallbacks(*this);
7416     else
7417         document().unregisterForPageScaleFactorChangedCallbacks(*this);
7418 }
7419 
7420 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7421 {
7422     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7423     // stopped/suspended the object.
7424     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7425         return;
7426 
<a name="115" id="anc115"></a>


7427     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7428         auto&amp; vm = globalObject.vm();
7429         auto scope = DECLARE_THROW_SCOPE(vm);
7430 
7431         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7432         auto* controllerObject = controllerValue.toObject(&amp;exec);
7433 
7434         RETURN_IF_EXCEPTION(scope, false);
7435 
<a name="116" id="anc116"></a><span class="line-modified">7436         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;handlePresentationModeChange&quot;));</span>
7437         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7438             return false;
7439 
7440         auto* function = functionValue.toObject(&amp;exec);
7441         scope.assertNoException();
7442         JSC::CallData callData;
7443         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7444         if (callType == JSC::CallType::None)
7445             return false;
7446 
7447         JSC::MarkedArgumentBuffer argList;
7448         ASSERT(!argList.hasOverflowed());
7449         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7450 
7451         return true;
7452     });
7453 }
7454 
7455 void HTMLMediaElement::pageScaleFactorChanged()
7456 {
7457     updatePageScaleFactorJSProperty();
7458 }
7459 
7460 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7461 {
7462     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7463 }
7464 
7465 String HTMLMediaElement::getCurrentMediaControlsStatus()
7466 {
7467     ensureMediaControlsShadowRoot();
7468 
7469     String status;
7470     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7471         auto&amp; vm = globalObject.vm();
7472         auto scope = DECLARE_THROW_SCOPE(vm);
7473 
7474         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7475         auto* controllerObject = controllerValue.toObject(&amp;exec);
7476 
7477         RETURN_IF_EXCEPTION(scope, false);
7478 
<a name="117" id="anc117"></a><span class="line-modified">7479         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;getCurrentControlsStatus&quot;));</span>
7480         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7481             return false;
7482 
7483         auto* function = functionValue.toObject(&amp;exec);
7484         scope.assertNoException();
7485         JSC::CallData callData;
7486         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7487         JSC::MarkedArgumentBuffer argList;
7488         ASSERT(!argList.hasOverflowed());
7489         if (callType == JSC::CallType::None)
7490             return false;
7491 
7492         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7493 
7494         RETURN_IF_EXCEPTION(scope, false);
7495 
7496         status = outputValue.getString(&amp;exec);
7497         return true;
7498     });
7499 
7500     return status;
7501 }
7502 #endif // ENABLE(MEDIA_CONTROLS_SCRIPT)
7503 
7504 unsigned long long HTMLMediaElement::fileSize() const
7505 {
7506     if (m_player)
7507         return m_player-&gt;fileSize();
7508 
7509     return 0;
7510 }
7511 
7512 PlatformMediaSession::MediaType HTMLMediaElement::mediaType() const
7513 {
7514     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA) {
7515         if (hasVideo() &amp;&amp; hasAudio() &amp;&amp; !muted())
7516             return PlatformMediaSession::VideoAudio;
7517         return hasVideo() ? PlatformMediaSession::Video : PlatformMediaSession::Audio;
7518     }
7519 
7520     return presentationType();
7521 }
7522 
7523 PlatformMediaSession::MediaType HTMLMediaElement::presentationType() const
7524 {
7525     if (hasTagName(HTMLNames::videoTag))
7526         return muted() ? PlatformMediaSession::Video : PlatformMediaSession::VideoAudio;
7527 
7528     return PlatformMediaSession::Audio;
7529 }
7530 
7531 PlatformMediaSession::DisplayType HTMLMediaElement::displayType() const
7532 {
7533     if (m_videoFullscreenMode == VideoFullscreenModeStandard)
7534         return PlatformMediaSession::Fullscreen;
7535     if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7536         return PlatformMediaSession::Optimized;
7537     if (m_videoFullscreenMode == VideoFullscreenModeNone)
7538         return PlatformMediaSession::Normal;
7539 
7540     ASSERT_NOT_REACHED();
7541     return PlatformMediaSession::Normal;
7542 }
7543 
7544 PlatformMediaSession::CharacteristicsFlags HTMLMediaElement::characteristics() const
7545 {
7546     if (m_readyState &lt; HAVE_METADATA)
7547         return PlatformMediaSession::HasNothing;
7548 
7549     PlatformMediaSession::CharacteristicsFlags state = PlatformMediaSession::HasNothing;
7550     if (isVideo() &amp;&amp; hasVideo())
7551         state |= PlatformMediaSession::HasVideo;
7552     if (this-&gt;hasAudio())
7553         state |= PlatformMediaSession::HasAudio;
7554 
7555     return state;
7556 }
7557 
7558 bool HTMLMediaElement::canProduceAudio() const
7559 {
7560 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7561     // Because the remote target could unmute playback without notifying us, we must assume
7562     // that we may be playing audio.
7563     if (m_isPlayingToWirelessTarget)
7564         return true;
7565 #endif
7566 
7567     if (muted())
7568         return false;
7569 
7570     return m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA &amp;&amp; hasAudio();
7571 }
7572 
7573 bool HTMLMediaElement::isSuspended() const
7574 {
7575     return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
7576 }
7577 
7578 #if ENABLE(MEDIA_SOURCE)
7579 size_t HTMLMediaElement::maximumSourceBufferSize(const SourceBuffer&amp; buffer) const
7580 {
7581     return m_mediaSession-&gt;maximumMediaSourceBufferSize(buffer);
7582 }
7583 #endif
7584 
7585 void HTMLMediaElement::suspendPlayback()
7586 {
7587     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7588     if (!paused())
7589         pause();
7590 }
7591 
7592 void HTMLMediaElement::resumeAutoplaying()
7593 {
7594     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7595     m_autoplaying = true;
7596 
7597     if (canTransitionFromAutoplayToPlay())
7598         play();
7599 }
7600 
7601 void HTMLMediaElement::mayResumePlayback(bool shouldResume)
7602 {
7603     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7604     if (paused() &amp;&amp; shouldResume)
7605         play();
7606 }
7607 
7608 String HTMLMediaElement::mediaSessionTitle() const
7609 {
7610     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7611         return emptyString();
7612 
7613     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7614     if (!title.isEmpty())
7615         return title;
7616 
7617     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7618     if (!title.isEmpty())
7619         return title;
7620 
7621     title = m_currentSrc.host().toString();
7622 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
7623     if (!title.isEmpty())
7624         title = decodeHostName(title);
7625 #endif
<a name="118" id="anc118"></a><span class="line-removed">7626 #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
7627     if (!title.isEmpty()) {
<a name="119" id="anc119"></a><span class="line-modified">7628         auto domain = topPrivatelyControlledDomain(title);</span>
7629         if (!domain.isEmpty())
<a name="120" id="anc120"></a><span class="line-modified">7630             title = domain;</span>
7631     }
<a name="121" id="anc121"></a><span class="line-removed">7632 #endif</span>
7633 
7634     return title;
7635 }
7636 
7637 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7638 {
7639     auto&amp; url = m_currentSrc.string();
7640     return url.impl() ? url.impl()-&gt;hash() : 0;
7641 }
7642 
7643 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7644 {
7645     INFO_LOG(LOGIDENTIFIER, command);
7646 
7647     UserGestureIndicator remoteControlUserGesture(ProcessingUserGesture, &amp;document());
7648     switch (command) {
7649     case PlatformMediaSession::PlayCommand:
7650         play();
7651         break;
7652     case PlatformMediaSession::StopCommand:
7653     case PlatformMediaSession::PauseCommand:
7654         pause();
7655         break;
7656     case PlatformMediaSession::TogglePlayPauseCommand:
7657         canPlay() ? play() : pause();
7658         break;
7659     case PlatformMediaSession::BeginSeekingBackwardCommand:
7660         beginScanning(Backward);
7661         break;
7662     case PlatformMediaSession::BeginSeekingForwardCommand:
7663         beginScanning(Forward);
7664         break;
7665     case PlatformMediaSession::EndSeekingBackwardCommand:
7666     case PlatformMediaSession::EndSeekingForwardCommand:
7667         endScanning();
7668         break;
7669     case PlatformMediaSession::SeekToPlaybackPositionCommand:
7670         ASSERT(argument);
7671         if (argument)
7672             handleSeekToPlaybackPosition(argument-&gt;asDouble);
7673         break;
7674     default:
7675         { } // Do nothing
7676     }
7677 }
7678 
<a name="122" id="anc122"></a><span class="line-removed">7679 static bool needsSeekingSupportQuirk(Document&amp; document)</span>
<span class="line-removed">7680 {</span>
<span class="line-removed">7681     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">7682         return false;</span>
<span class="line-removed">7683 </span>
<span class="line-removed">7684     auto host = document.topDocument().url().host();</span>
<span class="line-removed">7685     return equalLettersIgnoringASCIICase(host, &quot;netflix.com&quot;) || host.endsWithIgnoringASCIICase(&quot;.netflix.com&quot;);</span>
<span class="line-removed">7686 }</span>
<span class="line-removed">7687 </span>
7688 bool HTMLMediaElement::supportsSeeking() const
7689 {
<a name="123" id="anc123"></a><span class="line-modified">7690     return !needsSeekingSupportQuirk(document()) &amp;&amp; !isLiveStream();</span>
7691 }
7692 
7693 bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
7694 {
7695     if (type == PlatformMediaSession::EnteringBackground) {
7696         if (isPlayingToExternalTarget()) {
7697             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7698             return true;
7699         }
<a name="124" id="anc124"></a>



7700         if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7701             return true;
7702 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
7703         if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
7704             return true;
7705 #endif
7706     } else if (type == PlatformMediaSession::SuspendedUnderLock) {
7707         if (isPlayingToExternalTarget()) {
7708             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7709             return true;
7710         }
<a name="125" id="anc125"></a>



7711     }
7712     return false;
7713 }
7714 
7715 bool HTMLMediaElement::processingUserGestureForMedia() const
7716 {
7717     return document().processingUserGestureForMedia();
7718 }
<a name="126" id="anc126"></a>





7719 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7720 
7721 void HTMLMediaElement::scheduleUpdateMediaState()
7722 {
7723     if (m_updateMediaStateTask.hasPendingTask())
7724         return;
7725 
7726     auto logSiteIdentifier = LOGIDENTIFIER;
7727     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
7728     m_updateMediaStateTask.scheduleTask([this, logSiteIdentifier] {
7729         UNUSED_PARAM(logSiteIdentifier);
7730         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
7731         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaState calls methods that can trigger arbitrary DOM mutations.
7732         updateMediaState();
7733     });
7734 }
7735 
7736 void HTMLMediaElement::updateMediaState()
7737 {
7738     MediaProducer::MediaStateFlags state = mediaState();
7739     if (m_mediaState == state)
7740         return;
7741 
7742     m_mediaState = state;
7743     m_mediaSession-&gt;mediaStateDidChange(m_mediaState);
7744 #if ENABLE(MEDIA_SESSION)
7745     document().updateIsPlayingMedia(m_elementID);
7746 #else
7747     document().updateIsPlayingMedia();
7748 #endif
7749 }
7750 #endif
7751 
7752 MediaProducer::MediaStateFlags HTMLMediaElement::mediaState() const
7753 {
7754     MediaStateFlags state = IsNotPlaying;
7755 
7756     bool hasActiveVideo = isVideo() &amp;&amp; hasVideo();
7757     bool hasAudio = this-&gt;hasAudio();
7758     if (isPlayingToExternalTarget())
7759         state |= IsPlayingToExternalDevice;
7760 
7761 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7762     if (m_hasPlaybackTargetAvailabilityListeners) {
7763         state |= HasPlaybackTargetAvailabilityListener;
7764         if (!m_mediaSession-&gt;wirelessVideoPlaybackDisabled())
7765             state |= RequiresPlaybackTargetMonitoring;
7766     }
7767 
7768     bool requireUserGesture = m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
7769     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; !requireUserGesture &amp;&amp; !m_failedToPlayToWirelessTarget)
7770         state |= ExternalDeviceAutoPlayCandidate;
7771 
7772     if (hasActiveVideo || hasAudio)
7773         state |= HasAudioOrVideo;
7774 
7775     if (hasActiveVideo &amp;&amp; endedPlayback())
7776         state |= DidPlayToEnd;
7777 #endif
7778 
7779     if (!isPlaying())
7780         return state;
7781 
7782     if (hasAudio &amp;&amp; !muted() &amp;&amp; volume())
7783         state |= IsPlayingAudio;
7784 
7785     if (hasActiveVideo)
7786         state |= IsPlayingVideo;
7787 
7788     return state;
7789 }
7790 
7791 void HTMLMediaElement::handleAutoplayEvent(AutoplayEvent event)
7792 {
7793     if (Page* page = document().page()) {
7794         bool hasAudio = this-&gt;hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
7795         bool wasPlaybackPrevented = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay;
7796         bool hasMainContent = m_mediaSession &amp;&amp; m_mediaSession-&gt;isMainContentForPurposesOfAutoplayEvents();
7797         ALWAYS_LOG(LOGIDENTIFIER, &quot;hasAudio = &quot;, hasAudio, &quot; wasPlaybackPrevented = &quot;, wasPlaybackPrevented, &quot; hasMainContent = &quot;, hasMainContent);
7798 
7799         OptionSet&lt;AutoplayEventFlags&gt; flags;
7800         if (hasAudio)
7801             flags.add(AutoplayEventFlags::HasAudio);
7802         if (wasPlaybackPrevented)
7803             flags.add(AutoplayEventFlags::PlaybackWasPrevented);
7804         if (hasMainContent)
7805             flags.add(AutoplayEventFlags::MediaIsMainContent);
7806 
7807         page-&gt;chrome().client().handleAutoplayEvent(event, flags);
7808     }
7809 }
7810 
7811 void HTMLMediaElement::userDidInterfereWithAutoplay()
7812 {
7813     if (m_autoplayEventPlaybackState != AutoplayEventPlaybackState::StartedWithoutUserGesture)
7814         return;
7815 
7816     // Only consider interference in the first 10 seconds of automatic playback.
7817     if (currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold)
7818         return;
7819 
7820     ALWAYS_LOG(LOGIDENTIFIER);
7821     handleAutoplayEvent(AutoplayEvent::UserDidInterfereWithPlayback);
7822     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
7823 }
7824 
7825 void HTMLMediaElement::setAutoplayEventPlaybackState(AutoplayEventPlaybackState reason)
7826 {
7827     ALWAYS_LOG(LOGIDENTIFIER, reason);
7828 
7829     m_autoplayEventPlaybackState = reason;
7830 
7831     if (reason == AutoplayEventPlaybackState::PreventedAutoplay) {
7832         dispatchPlayPauseEventsIfNeedsQuirks();
7833         handleAutoplayEvent(AutoplayEvent::DidPreventMediaFromPlaying);
7834     }
7835 }
7836 
7837 void HTMLMediaElement::pageMutedStateDidChange()
7838 {
7839     updateVolume();
7840 
7841     if (Page* page = document().page()) {
7842         if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
7843             userDidInterfereWithAutoplay();
7844     }
7845 }
7846 
<a name="127" id="anc127"></a>













7847 bool HTMLMediaElement::effectiveMuted() const
7848 {
<a name="128" id="anc128"></a><span class="line-modified">7849     return muted() || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
7850 }
7851 
<a name="129" id="anc129"></a><span class="line-modified">7852 bool HTMLMediaElement::doesHaveAttribute(const AtomicString&amp; attribute, AtomicString* value) const</span>
7853 {
7854     QualifiedName attributeName(nullAtom(), attribute, nullAtom());
7855 
7856     auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
7857     if (elementValue.isNull())
7858         return false;
7859 
7860     if (attributeName == HTMLNames::x_itunes_inherit_uri_query_componentAttr &amp;&amp; !document().settings().enableInheritURIQueryComponent())
7861         return false;
7862 
7863     if (value)
7864         *value = elementValue;
7865 
7866     return true;
7867 }
7868 
<a name="130" id="anc130"></a><span class="line-modified">7869 void HTMLMediaElement::setShouldBufferData(bool shouldBuffer)</span>
7870 {
<a name="131" id="anc131"></a><span class="line-modified">7871     if (shouldBuffer == m_shouldBufferData)</span>
7872         return;
7873 
<a name="132" id="anc132"></a><span class="line-modified">7874     m_shouldBufferData = shouldBuffer;</span>


7875     if (m_player)
<a name="133" id="anc133"></a><span class="line-modified">7876         m_player-&gt;setShouldBufferData(shouldBuffer);</span>
7877 }
7878 
7879 void HTMLMediaElement::purgeBufferedDataIfPossible()
7880 {
<a name="134" id="anc134"></a><span class="line-modified">7881 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">7882     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;dataBufferingPermitted())</span>

7883         return;
7884 
7885     if (isPlayingToExternalTarget()) {
7886         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7887         return;
7888     }
7889 
<a name="135" id="anc135"></a><span class="line-modified">7890     // This is called to relieve memory pressure. Turning off buffering causes the media playback</span>
<span class="line-removed">7891     // daemon to release memory associated with queued-up video frames.</span>
<span class="line-removed">7892     // We turn it back on right away, but new frames won&#39;t get loaded unless playback is resumed.</span>
<span class="line-removed">7893     INFO_LOG(LOGIDENTIFIER, &quot;toggling data buffering&quot;);</span>
<span class="line-removed">7894     setShouldBufferData(false);</span>
<span class="line-removed">7895     setShouldBufferData(true);</span>
<span class="line-removed">7896 #endif</span>
7897 }
7898 
7899 bool HTMLMediaElement::canSaveMediaData() const
7900 {
7901     if (m_player)
7902         return m_player-&gt;canSaveMediaData();
7903 
7904     return false;
7905 }
7906 
7907 #if ENABLE(MEDIA_SESSION)
7908 double HTMLMediaElement::playerVolume() const
7909 {
7910     return m_player ? m_player-&gt;volume() : 0;
7911 }
7912 
7913 MediaSession* HTMLMediaElement::session() const
7914 {
7915     RefPtr&lt;MediaSession&gt; session = m_session.get();
7916     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
7917         return nullptr;
7918 
7919     return session.get();
7920 }
7921 
7922 void HTMLMediaElement::setSession(MediaSession* session)
7923 {
7924     // 6.1. Extensions to the HTMLMediaElement interface
7925     // 1. Let m be the media element in question.
7926     // 2. Let old media session be m’s current media session, if it has one, and null otherwise.
7927     // 3. Let m’s current media session be the new value or the top-level browsing context’s media session if the new value is null.
7928     // 4. Let new media session be m’s current media session.
7929 
7930     // 5. Update media sessions: If old media session and new media session are the same (whether both null or both the same media session), then terminate these steps.
7931     if (m_session.get() == session)
7932         return;
7933 
7934     if (m_session) {
7935         // 6. If m is an audio-producing participant of old media session, then pause m and remove m from old media session’s list of audio-producing participants.
7936         if (m_session-&gt;isMediaElementActive(*this))
7937             pause();
7938 
7939         m_session-&gt;removeMediaElement(*this);
7940 
7941         // 7. If old media session is not null and no longer has one or more audio-producing participants, then run the media session deactivation algorithm for old media session.
7942         if (!m_session-&gt;hasActiveMediaElements())
7943             m_session-&gt;deactivate();
7944     }
7945 
7946     if (session)
7947         setSessionInternal(*session);
7948     else
7949         setSessionInternal(document().defaultMediaSession());
7950 }
7951 
7952 void HTMLMediaElement::setSessionInternal(MediaSession&amp; session)
7953 {
7954     m_session = &amp;session;
7955     session.addMediaElement(*this);
7956     m_kind = session.kind();
7957 }
7958 
7959 void HTMLMediaElement::setShouldDuck(bool duck)
7960 {
7961     if (m_shouldDuck == duck)
7962         return;
7963 
7964     m_shouldDuck = duck;
7965     updateVolume();
7966 }
7967 
7968 #endif
7969 
7970 void HTMLMediaElement::allowsMediaDocumentInlinePlaybackChanged()
7971 {
7972     if (potentiallyPlaying() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; !isFullscreen())
7973         enterFullscreen();
7974 }
7975 
7976 bool HTMLMediaElement::isVideoTooSmallForInlinePlayback()
7977 {
7978     auto* renderer = this-&gt;renderer();
7979 
7980     if (!renderer || !is&lt;RenderVideo&gt;(*renderer))
7981         return true;
7982 
7983     IntRect videoBox = downcast&lt;RenderVideo&gt;(*renderer).videoBox();
7984     return (videoBox.width() &lt;= 1 || videoBox.height() &lt;= 1);
7985 }
7986 
7987 void HTMLMediaElement::isVisibleInViewportChanged()
7988 {
7989     m_visibilityChangeTaskQueue.enqueueTask([this] {
7990         m_mediaSession-&gt;isVisibleInViewportChanged();
7991         updateShouldAutoplay();
7992         schedulePlaybackControlsManagerUpdate();
7993     });
7994 }
7995 
7996 void HTMLMediaElement::updateShouldAutoplay()
7997 {
7998     if (!autoplay())
7999         return;
8000 
8001     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
8002         return;
8003 
8004     bool canAutoplay = mediaSession().autoplayPermitted();
8005     if (canAutoplay
8006         &amp;&amp; m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted
8007         &amp;&amp; m_mediaSession-&gt;interruptionType() == PlatformMediaSession::InvisibleAutoplay)
8008         m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
8009     else if (!canAutoplay
8010         &amp;&amp; m_mediaSession-&gt;state() != PlatformMediaSession::Interrupted)
8011         m_mediaSession-&gt;beginInterruption(PlatformMediaSession::InvisibleAutoplay);
8012 }
8013 
8014 void HTMLMediaElement::updateShouldPlay()
8015 {
8016     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
8017         pauseInternal();
8018         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
8019     } else if (canTransitionFromAutoplayToPlay())
8020         play();
8021 }
8022 
8023 void HTMLMediaElement::resetPlaybackSessionState()
8024 {
8025     if (m_mediaSession)
8026         m_mediaSession-&gt;resetPlaybackSessionState();
8027 }
8028 
8029 bool HTMLMediaElement::isVisibleInViewport() const
8030 {
8031     auto renderer = this-&gt;renderer();
8032     return renderer &amp;&amp; renderer-&gt;visibleInViewportState() == VisibleInViewportState::Yes;
8033 }
8034 
8035 void HTMLMediaElement::schedulePlaybackControlsManagerUpdate()
8036 {
8037     Page* page = document().page();
8038     if (!page)
8039         return;
8040     page-&gt;schedulePlaybackControlsManagerUpdate();
8041 }
8042 
8043 void HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired()
8044 {
8045     if (m_playbackControlsManagerBehaviorRestrictionsQueue.hasPendingTask())
8046         return;
8047 
8048     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager))
8049         return;
8050 
8051     RefPtr&lt;HTMLMediaElement&gt; protectedThis(this);
8052     m_playbackControlsManagerBehaviorRestrictionsQueue.scheduleTask([protectedThis] () {
8053         MediaElementSession* mediaElementSession = protectedThis-&gt;m_mediaSession.get();
8054         if (protectedThis-&gt;isPlaying() || mediaElementSession-&gt;state() == PlatformMediaSession::Autoplaying || mediaElementSession-&gt;state() == PlatformMediaSession::Playing)
8055             return;
8056 
8057         mediaElementSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
8058         protectedThis-&gt;schedulePlaybackControlsManagerUpdate();
8059     });
8060 }
8061 
8062 bool HTMLMediaElement::shouldOverrideBackgroundLoadingRestriction() const
8063 {
8064     if (isPlayingToExternalTarget())
8065         return true;
8066 
8067     return m_videoFullscreenMode == VideoFullscreenModePictureInPicture;
8068 }
8069 
8070 void HTMLMediaElement::fullscreenModeChanged(VideoFullscreenMode mode)
8071 {
8072     if (m_videoFullscreenMode == mode)
8073         return;
8074 
8075     m_videoFullscreenMode = mode;
8076     visibilityStateChanged();
8077     schedulePlaybackControlsManagerUpdate();
8078 }
8079 
8080 #if !RELEASE_LOG_DISABLED
8081 WTFLogChannel&amp; HTMLMediaElement::logChannel() const
8082 {
8083     return LogMedia;
8084 }
8085 #endif
8086 
8087 bool HTMLMediaElement::willLog(WTFLogLevel level) const
8088 {
8089 #if !RELEASE_LOG_DISABLED
8090     return m_logger-&gt;willLog(logChannel(), level);
8091 #else
8092     UNUSED_PARAM(level);
8093     return false;
8094 #endif
8095 }
8096 
8097 void HTMLMediaElement::applicationWillResignActive()
8098 {
8099     if (m_player)
8100         m_player-&gt;applicationWillResignActive();
8101 }
8102 
8103 void HTMLMediaElement::applicationDidBecomeActive()
8104 {
8105     if (m_player)
8106         m_player-&gt;applicationDidBecomeActive();
8107 }
8108 
8109 void HTMLMediaElement::setInActiveDocument(bool inActiveDocument)
8110 {
8111     if (inActiveDocument == m_inActiveDocument)
8112         return;
8113 
8114     m_inActiveDocument = inActiveDocument;
8115     m_mediaSession-&gt;inActiveDocumentChanged();
8116 }
8117 
<a name="136" id="anc136"></a>













8118 }
8119 
8120 #endif
<a name="137" id="anc137"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="137" type="hidden" />
</body>
</html>