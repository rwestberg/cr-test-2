<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RadioButtonGroups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Range.h&quot;
  27 
  28 #include &quot;Comment.h&quot;
  29 #include &quot;DOMRect.h&quot;
  30 #include &quot;DOMRectList.h&quot;
  31 #include &quot;DocumentFragment.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;HTMLBodyElement.h&quot;
  37 #include &quot;HTMLElement.h&quot;
  38 #include &quot;HTMLHtmlElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;NodeTraversal.h&quot;
  41 #include &quot;NodeWithIndex.h&quot;
  42 #include &quot;ProcessingInstruction.h&quot;

  43 #include &quot;RenderBoxModelObject.h&quot;
  44 #include &quot;RenderText.h&quot;

  45 #include &quot;ScopedEventQueue.h&quot;
  46 #include &quot;TextIterator.h&quot;
  47 #include &quot;VisiblePosition.h&quot;
  48 #include &quot;VisibleUnits.h&quot;
  49 #include &quot;markup.h&quot;
  50 #include &lt;stdio.h&gt;
  51 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  52 #include &lt;wtf/text/CString.h&gt;
  53 #include &lt;wtf/text/StringBuilder.h&gt;
  54 
  55 #if PLATFORM(IOS_FAMILY)
  56 #include &quot;SelectionRect.h&quot;
  57 #endif
  58 
  59 namespace WebCore {
  60 
  61 using namespace HTMLNames;
  62 
  63 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, rangeCounter, (&quot;Range&quot;));
  64 
</pre>
<hr />
<pre>
 541     case Node::CDATA_SECTION_NODE:
 542     case Node::COMMENT_NODE:
 543     case Node::PROCESSING_INSTRUCTION_NODE:
 544         return downcast&lt;CharacterData&gt;(node).length();
 545     case Node::ELEMENT_NODE:
 546     case Node::DOCUMENT_NODE:
 547     case Node::DOCUMENT_FRAGMENT_NODE:
 548         return downcast&lt;ContainerNode&gt;(node).countChildNodes();
 549     }
 550     ASSERT_NOT_REACHED();
 551     return 0;
 552 }
 553 
 554 ExceptionOr&lt;RefPtr&lt;DocumentFragment&gt;&gt; Range::processContents(ActionType action)
 555 {
 556     RefPtr&lt;DocumentFragment&gt; fragment;
 557     if (action == Extract || action == Clone)
 558         fragment = DocumentFragment::create(ownerDocument());
 559 
 560     if (collapsed())
<span class="line-modified"> 561         return WTFMove(fragment);</span>
 562 
 563     RefPtr&lt;Node&gt; commonRoot = commonAncestorContainer();
 564     ASSERT(commonRoot);
 565 
 566     if (&amp;startContainer() == &amp;endContainer()) {
 567         auto result = processContentsBetweenOffsets(action, fragment, &amp;startContainer(), m_start.offset(), m_end.offset());
 568         if (result.hasException())
 569             return result.releaseException();
<span class="line-modified"> 570         return WTFMove(fragment);</span>
 571     }
 572 
 573     // Since mutation events can modify the range during the process, the boundary points need to be saved.
 574     RangeBoundaryPoint originalStart(m_start);
 575     RangeBoundaryPoint originalEnd(m_end);
 576 
 577     // what is the highest node that partially selects the start / end of the range?
 578     RefPtr&lt;Node&gt; partialStart = highestAncestorUnderCommonRoot(originalStart.container(), commonRoot.get());
 579     RefPtr&lt;Node&gt; partialEnd = highestAncestorUnderCommonRoot(originalEnd.container(), commonRoot.get());
 580 
 581     // Start and end containers are different.
 582     // There are three possibilities here:
 583     // 1. Start container == commonRoot (End container must be a descendant)
 584     // 2. End container == commonRoot (Start container must be a descendant)
 585     // 3. Neither is commonRoot, they are both descendants
 586     //
 587     // In case 3, we grab everything after the start (up until a direct child
 588     // of commonRoot) into leftContents, and everything before the end (up until
 589     // a direct child of commonRoot) into rightContents. Then we process all
 590     // commonRoot children between leftContents and rightContents
</pre>
<hr />
<pre>
 643         auto result = fragment-&gt;appendChild(*leftContents);
 644         if (result.hasException())
 645             return result.releaseException();
 646     }
 647 
 648     if (processStart) {
 649         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 650         for (Node* node = processStart.get(); node &amp;&amp; node != processEnd; node = node-&gt;nextSibling())
 651             nodes.append(*node);
 652         auto result = processNodes(action, nodes, commonRoot.get(), fragment.get());
 653         if (result.hasException())
 654             return result.releaseException();
 655     }
 656 
 657     if ((action == Extract || action == Clone) &amp;&amp; rightContents) {
 658         auto result = fragment-&gt;appendChild(*rightContents);
 659         if (result.hasException())
 660             return result.releaseException();
 661     }
 662 
<span class="line-modified"> 663     return WTFMove(fragment);</span>
 664 }
 665 
 666 static inline ExceptionOr&lt;void&gt; deleteCharacterData(CharacterData&amp; data, unsigned startOffset, unsigned endOffset)
 667 {
 668     if (data.length() - endOffset) {
 669         auto result = data.deleteData(endOffset, data.length() - endOffset);
 670         if (result.hasException())
 671             return result.releaseException();
 672     }
 673     if (startOffset) {
 674         auto result = data.deleteData(0, startOffset);
 675         if (result.hasException())
 676             return result.releaseException();
 677     }
 678     return { };
 679 }
 680 
 681 static ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processContentsBetweenOffsets(Range::ActionType action, RefPtr&lt;DocumentFragment&gt; fragment, RefPtr&lt;Node&gt; container, unsigned startOffset, unsigned endOffset)
 682 {
 683     ASSERT(container);
</pre>
<hr />
<pre>
 744                 result = fragment;
 745             else
 746                 result = container-&gt;cloneNode(false);
 747         }
 748         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 749         Node* n = container-&gt;firstChild();
 750         for (unsigned i = startOffset; n &amp;&amp; i; i--)
 751             n = n-&gt;nextSibling();
 752         for (unsigned i = startOffset; n &amp;&amp; i &lt; endOffset; i++, n = n-&gt;nextSibling()) {
 753             if (action != Range::Delete &amp;&amp; n-&gt;isDocumentTypeNode()) {
 754                 return Exception { HierarchyRequestError };
 755             }
 756             nodes.append(*n);
 757         }
 758         auto processResult = processNodes(action, nodes, container.get(), result);
 759         if (processResult.hasException())
 760             return processResult.releaseException();
 761         break;
 762     }
 763 
<span class="line-modified"> 764     return WTFMove(result);</span>
 765 }
 766 
 767 static ExceptionOr&lt;void&gt; processNodes(Range::ActionType action, Vector&lt;Ref&lt;Node&gt;&gt;&amp; nodes, Node* oldContainer, RefPtr&lt;Node&gt; newContainer)
 768 {
 769     for (auto&amp; node : nodes) {
 770         switch (action) {
 771         case Range::Delete: {
 772             auto result = oldContainer-&gt;removeChild(node);
 773             if (result.hasException())
 774                 return result.releaseException();
 775             break;
 776         }
 777         case Range::Extract: {
 778             auto result = newContainer-&gt;appendChild(node); // will remove node from its parent
 779             if (result.hasException())
 780                 return result.releaseException();
 781             break;
 782         }
 783         case Range::Clone: {
 784             auto result = newContainer-&gt;appendChild(node-&gt;cloneNode(true));
</pre>
<hr />
<pre>
 842                     if (result.hasException())
 843                         return result.releaseException();
 844                 }
 845                 break;
 846             case Range::Clone:
 847                 if (direction == ProcessContentsForward) {
 848                     auto result = clonedContainer-&gt;appendChild(child-&gt;cloneNode(true));
 849                     if (result.hasException())
 850                         return result.releaseException();
 851                 } else {
 852                     auto result = clonedContainer-&gt;insertBefore(child-&gt;cloneNode(true), clonedContainer-&gt;firstChild());
 853                     if (result.hasException())
 854                         return result.releaseException();
 855                 }
 856                 break;
 857             }
 858         }
 859         firstChildInAncestorToProcess = direction == ProcessContentsForward ? ancestor-&gt;nextSibling() : ancestor-&gt;previousSibling();
 860     }
 861 
<span class="line-modified"> 862     return WTFMove(clonedContainer);</span>
 863 }
 864 
 865 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::extractContents()
 866 {
 867     auto result = processContents(Extract);
 868     if (result.hasException())
 869         return result.releaseException();
 870     return result.releaseReturnValue().releaseNonNull();
 871 }
 872 
 873 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::cloneContents()
 874 {
 875     auto result = processContents(Clone);
 876     if (result.hasException())
 877         return result.releaseException();
 878     return result.releaseReturnValue().releaseNonNull();
 879 }
 880 
 881 ExceptionOr&lt;void&gt; Range::insertNode(Ref&lt;Node&gt;&amp;&amp; node)
 882 {
</pre>
<hr />
<pre>
 927         return insertResult.releaseException();
 928 
 929     if (collapsed())
 930         return setEnd(WTFMove(parent), newOffset);
 931 
 932     return { };
 933 }
 934 
 935 String Range::toString() const
 936 {
 937     StringBuilder builder;
 938 
 939     Node* pastLast = pastLastNode();
 940     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
 941         auto type = node-&gt;nodeType();
 942         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
 943             auto&amp; data = downcast&lt;CharacterData&gt;(*node).data();
 944             unsigned length = data.length();
 945             unsigned start = node == &amp;startContainer() ? std::min(m_start.offset(), length) : 0U;
 946             unsigned end = node == &amp;endContainer() ? std::min(std::max(start, m_end.offset()), length) : length;
<span class="line-modified"> 947             builder.append(data, start, end - start);</span>
 948         }
 949     }
 950 
 951     return builder.toString();
 952 }
 953 
 954 String Range::text() const
 955 {
 956     // We need to update layout, since plainText uses line boxes in the render tree.
 957     // FIXME: As with innerText, we&#39;d like this to work even if there are no render objects.
 958     startContainer().document().updateLayout();
 959 
 960     return plainText(this);
 961 }
 962 
 963 // https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
 964 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::createContextualFragment(const String&amp; markup)
 965 {
 966     Node&amp; node = startContainer();
 967     RefPtr&lt;Element&gt; element;
</pre>
<hr />
<pre>
1142 
1143 Node* Range::pastLastNode() const
1144 {
1145     if (endContainer().isCharacterDataNode())
1146         return NodeTraversal::nextSkippingChildren(endContainer());
1147     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
1148         return child;
1149     return NodeTraversal::nextSkippingChildren(endContainer());
1150 }
1151 
1152 IntRect Range::absoluteBoundingBox() const
1153 {
1154     IntRect result;
1155     Vector&lt;IntRect&gt; rects;
1156     absoluteTextRects(rects);
1157     for (auto&amp; rect : rects)
1158         result.unite(rect);
1159     return result;
1160 }
1161 
<span class="line-modified">1162 Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, RespectClippingForTextRects respectClippingForTextRects) const</span>
1163 {
1164     unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1165     unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1166 
1167     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed);
1168 
<span class="line-modified">1169     if (respectClippingForTextRects == RespectClippingForTextRects::Yes) {</span>
1170         Vector&lt;FloatRect&gt; clippedRects;
1171         clippedRects.reserveInitialCapacity(textQuads.size());
1172 
1173         auto absoluteClippedOverflowRect = renderText.absoluteClippedOverflowRect();
1174 
1175         for (auto&amp; quad : textQuads) {
1176             auto clippedRect = intersection(quad.boundingBox(), absoluteClippedOverflowRect);
1177             if (!clippedRect.isEmpty())
1178                 clippedRects.uncheckedAppend(clippedRect);
1179         }
1180 
1181         return clippedRects;
1182     }
1183 
1184     Vector&lt;FloatRect&gt; floatRects;
1185     floatRects.reserveInitialCapacity(textQuads.size());
1186     for (auto&amp; quad : textQuads)
1187         floatRects.uncheckedAppend(quad.boundingBox());
1188     return floatRects;
1189 }
1190 
<span class="line-modified">1191 void Range::absoluteTextRects(Vector&lt;IntRect&gt;&amp; rects, bool useSelectionHeight, RangeInFixedPosition* inFixed, RespectClippingForTextRects respectClippingForTextRects) const</span>
1192 {
1193     // FIXME: This function should probably return FloatRects.
1194 
1195     bool allFixed = true;
1196     bool someFixed = false;
1197 
1198     Node* stopNode = pastLastNode();
1199     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1200         RenderObject* renderer = node-&gt;renderer();
1201         if (!renderer)
1202             continue;
1203         bool isFixed = false;
1204         if (renderer-&gt;isBR())
1205             renderer-&gt;absoluteRects(rects, flooredLayoutPoint(renderer-&gt;localToAbsolute()));
1206         else if (is&lt;RenderText&gt;(*renderer)) {
<span class="line-modified">1207             auto rectsForRenderer = absoluteRectsForRangeInText(node, downcast&lt;RenderText&gt;(*renderer), useSelectionHeight, isFixed, respectClippingForTextRects);</span>
1208             for (auto&amp; rect : rectsForRenderer)
1209                 rects.append(enclosingIntRect(rect));
1210         } else
1211             continue;
1212         allFixed &amp;= isFixed;
1213         someFixed |= isFixed;
1214     }
1215 
1216     if (inFixed)
1217         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1218 }
1219 
1220 void Range::absoluteTextQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool useSelectionHeight, RangeInFixedPosition* inFixed) const
1221 {
1222     bool allFixed = true;
1223     bool someFixed = false;
1224 
1225     Node* stopNode = pastLastNode();
1226     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1227         RenderObject* renderer = node-&gt;renderer();
</pre>
<hr />
<pre>
1776         return Exception { TypeError };
1777     auto result = setStart(*startContainer, start.deepEquivalent().computeOffsetInContainerNode());
1778     if (result.hasException())
1779         return result.releaseException();
1780     auto* endContainer = end.deepEquivalent().containerNode();
1781     if (!endContainer)
1782         return Exception { TypeError };
1783     return setEnd(*endContainer, end.deepEquivalent().computeOffsetInContainerNode());
1784 }
1785 
1786 Ref&lt;DOMRectList&gt; Range::getClientRects() const
1787 {
1788     return DOMRectList::create(borderAndTextRects(CoordinateSpace::Client));
1789 }
1790 
1791 Ref&lt;DOMRect&gt; Range::getBoundingClientRect() const
1792 {
1793     return DOMRect::create(boundingRect(CoordinateSpace::Client));
1794 }
1795 
<span class="line-modified">1796 Vector&lt;FloatRect&gt; Range::borderAndTextRects(CoordinateSpace space, RespectClippingForTextRects respectClippingForTextRects) const</span>
1797 {
1798     Vector&lt;FloatRect&gt; rects;
1799 
1800     ownerDocument().updateLayoutIgnorePendingStylesheets();
1801 
1802     Node* stopNode = pastLastNode();

1803 
1804     HashSet&lt;Node*&gt; selectedElementsSet;
1805     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1806         if (is&lt;Element&gt;(*node))
1807             selectedElementsSet.add(node);
1808     }
1809 
1810     // Don&#39;t include elements that are only partially selected.
1811     Node* lastNode = m_end.childBefore() ? m_end.childBefore() : &amp;endContainer();
1812     for (Node* parent = lastNode-&gt;parentNode(); parent; parent = parent-&gt;parentNode())
1813         selectedElementsSet.remove(parent);
1814 


1815     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
<span class="line-modified">1816         if (is&lt;Element&gt;(*node) &amp;&amp; selectedElementsSet.contains(node) &amp;&amp; (!node-&gt;parentNode() || !selectedElementsSet.contains(node-&gt;parentNode()))) {</span>
1817             if (auto* renderer = downcast&lt;Element&gt;(*node).renderBoxModelObject()) {













1818                 Vector&lt;FloatQuad&gt; elementQuads;
1819                 renderer-&gt;absoluteQuads(elementQuads);
1820                 if (space == CoordinateSpace::Client)
1821                     node-&gt;document().convertAbsoluteToClientQuads(elementQuads, renderer-&gt;style());
1822 
1823                 for (auto&amp; quad : elementQuads)
1824                     rects.append(quad.boundingBox());
1825             }
1826         } else if (is&lt;Text&gt;(*node)) {
1827             if (auto* renderer = downcast&lt;Text&gt;(*node).renderer()) {
1828                 bool isFixed;
<span class="line-modified">1829                 auto clippedRects = absoluteRectsForRangeInText(node, *renderer, false, isFixed, respectClippingForTextRects);</span>
1830                 if (space == CoordinateSpace::Client)
1831                     node-&gt;document().convertAbsoluteToClientRects(clippedRects, renderer-&gt;style());
1832 
1833                 rects.appendVector(clippedRects);
1834             }
1835         }
1836     }
1837 






1838     return rects;
1839 }
1840 
<span class="line-modified">1841 FloatRect Range::boundingRect(CoordinateSpace space, RespectClippingForTextRects respectClippingForTextRects) const</span>
1842 {
1843     FloatRect result;
<span class="line-modified">1844     for (auto&amp; rect : borderAndTextRects(space, respectClippingForTextRects))</span>
<span class="line-modified">1845         result.unite(rect);</span>
1846     return result;
1847 }
1848 
<span class="line-modified">1849 FloatRect Range::absoluteBoundingRect(RespectClippingForTextRects respectClippingForTextRects) const</span>
1850 {
<span class="line-modified">1851     return boundingRect(CoordinateSpace::Absolute, respectClippingForTextRects);</span>
1852 }
1853 
1854 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const RangeBoundaryPoint&amp; r)
1855 {
1856     return ts &lt;&lt; r.toPosition();
1857 }
1858 
1859 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const Range&amp; r)
1860 {
1861     return ts &lt;&lt; &quot;Range: &quot; &lt;&lt; &quot;start: &quot; &lt;&lt; r.startPosition() &lt;&lt; &quot; end: &quot; &lt;&lt; r.endPosition();
1862 }
1863 
1864 } // namespace WebCore
1865 
1866 #if ENABLE(TREE_DEBUGGING)
1867 
1868 void showTree(const WebCore::Range* range)
1869 {
1870     if (range &amp;&amp; range-&gt;boundaryPointsValid()) {
1871         range-&gt;startContainer().showTreeAndMark(&amp;range-&gt;startContainer(), &quot;S&quot;, &amp;range-&gt;endContainer(), &quot;E&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Range.h&quot;
  27 
  28 #include &quot;Comment.h&quot;
  29 #include &quot;DOMRect.h&quot;
  30 #include &quot;DOMRectList.h&quot;
  31 #include &quot;DocumentFragment.h&quot;
  32 #include &quot;Editing.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;HTMLBodyElement.h&quot;
  37 #include &quot;HTMLElement.h&quot;
  38 #include &quot;HTMLHtmlElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;NodeTraversal.h&quot;
  41 #include &quot;NodeWithIndex.h&quot;
  42 #include &quot;ProcessingInstruction.h&quot;
<span class="line-added">  43 #include &quot;RenderBlock.h&quot;</span>
  44 #include &quot;RenderBoxModelObject.h&quot;
  45 #include &quot;RenderText.h&quot;
<span class="line-added">  46 #include &quot;RenderView.h&quot;</span>
  47 #include &quot;ScopedEventQueue.h&quot;
  48 #include &quot;TextIterator.h&quot;
  49 #include &quot;VisiblePosition.h&quot;
  50 #include &quot;VisibleUnits.h&quot;
  51 #include &quot;markup.h&quot;
  52 #include &lt;stdio.h&gt;
  53 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  54 #include &lt;wtf/text/CString.h&gt;
  55 #include &lt;wtf/text/StringBuilder.h&gt;
  56 
  57 #if PLATFORM(IOS_FAMILY)
  58 #include &quot;SelectionRect.h&quot;
  59 #endif
  60 
  61 namespace WebCore {
  62 
  63 using namespace HTMLNames;
  64 
  65 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, rangeCounter, (&quot;Range&quot;));
  66 
</pre>
<hr />
<pre>
 543     case Node::CDATA_SECTION_NODE:
 544     case Node::COMMENT_NODE:
 545     case Node::PROCESSING_INSTRUCTION_NODE:
 546         return downcast&lt;CharacterData&gt;(node).length();
 547     case Node::ELEMENT_NODE:
 548     case Node::DOCUMENT_NODE:
 549     case Node::DOCUMENT_FRAGMENT_NODE:
 550         return downcast&lt;ContainerNode&gt;(node).countChildNodes();
 551     }
 552     ASSERT_NOT_REACHED();
 553     return 0;
 554 }
 555 
 556 ExceptionOr&lt;RefPtr&lt;DocumentFragment&gt;&gt; Range::processContents(ActionType action)
 557 {
 558     RefPtr&lt;DocumentFragment&gt; fragment;
 559     if (action == Extract || action == Clone)
 560         fragment = DocumentFragment::create(ownerDocument());
 561 
 562     if (collapsed())
<span class="line-modified"> 563         return fragment;</span>
 564 
 565     RefPtr&lt;Node&gt; commonRoot = commonAncestorContainer();
 566     ASSERT(commonRoot);
 567 
 568     if (&amp;startContainer() == &amp;endContainer()) {
 569         auto result = processContentsBetweenOffsets(action, fragment, &amp;startContainer(), m_start.offset(), m_end.offset());
 570         if (result.hasException())
 571             return result.releaseException();
<span class="line-modified"> 572         return fragment;</span>
 573     }
 574 
 575     // Since mutation events can modify the range during the process, the boundary points need to be saved.
 576     RangeBoundaryPoint originalStart(m_start);
 577     RangeBoundaryPoint originalEnd(m_end);
 578 
 579     // what is the highest node that partially selects the start / end of the range?
 580     RefPtr&lt;Node&gt; partialStart = highestAncestorUnderCommonRoot(originalStart.container(), commonRoot.get());
 581     RefPtr&lt;Node&gt; partialEnd = highestAncestorUnderCommonRoot(originalEnd.container(), commonRoot.get());
 582 
 583     // Start and end containers are different.
 584     // There are three possibilities here:
 585     // 1. Start container == commonRoot (End container must be a descendant)
 586     // 2. End container == commonRoot (Start container must be a descendant)
 587     // 3. Neither is commonRoot, they are both descendants
 588     //
 589     // In case 3, we grab everything after the start (up until a direct child
 590     // of commonRoot) into leftContents, and everything before the end (up until
 591     // a direct child of commonRoot) into rightContents. Then we process all
 592     // commonRoot children between leftContents and rightContents
</pre>
<hr />
<pre>
 645         auto result = fragment-&gt;appendChild(*leftContents);
 646         if (result.hasException())
 647             return result.releaseException();
 648     }
 649 
 650     if (processStart) {
 651         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 652         for (Node* node = processStart.get(); node &amp;&amp; node != processEnd; node = node-&gt;nextSibling())
 653             nodes.append(*node);
 654         auto result = processNodes(action, nodes, commonRoot.get(), fragment.get());
 655         if (result.hasException())
 656             return result.releaseException();
 657     }
 658 
 659     if ((action == Extract || action == Clone) &amp;&amp; rightContents) {
 660         auto result = fragment-&gt;appendChild(*rightContents);
 661         if (result.hasException())
 662             return result.releaseException();
 663     }
 664 
<span class="line-modified"> 665     return fragment;</span>
 666 }
 667 
 668 static inline ExceptionOr&lt;void&gt; deleteCharacterData(CharacterData&amp; data, unsigned startOffset, unsigned endOffset)
 669 {
 670     if (data.length() - endOffset) {
 671         auto result = data.deleteData(endOffset, data.length() - endOffset);
 672         if (result.hasException())
 673             return result.releaseException();
 674     }
 675     if (startOffset) {
 676         auto result = data.deleteData(0, startOffset);
 677         if (result.hasException())
 678             return result.releaseException();
 679     }
 680     return { };
 681 }
 682 
 683 static ExceptionOr&lt;RefPtr&lt;Node&gt;&gt; processContentsBetweenOffsets(Range::ActionType action, RefPtr&lt;DocumentFragment&gt; fragment, RefPtr&lt;Node&gt; container, unsigned startOffset, unsigned endOffset)
 684 {
 685     ASSERT(container);
</pre>
<hr />
<pre>
 746                 result = fragment;
 747             else
 748                 result = container-&gt;cloneNode(false);
 749         }
 750         Vector&lt;Ref&lt;Node&gt;&gt; nodes;
 751         Node* n = container-&gt;firstChild();
 752         for (unsigned i = startOffset; n &amp;&amp; i; i--)
 753             n = n-&gt;nextSibling();
 754         for (unsigned i = startOffset; n &amp;&amp; i &lt; endOffset; i++, n = n-&gt;nextSibling()) {
 755             if (action != Range::Delete &amp;&amp; n-&gt;isDocumentTypeNode()) {
 756                 return Exception { HierarchyRequestError };
 757             }
 758             nodes.append(*n);
 759         }
 760         auto processResult = processNodes(action, nodes, container.get(), result);
 761         if (processResult.hasException())
 762             return processResult.releaseException();
 763         break;
 764     }
 765 
<span class="line-modified"> 766     return result;</span>
 767 }
 768 
 769 static ExceptionOr&lt;void&gt; processNodes(Range::ActionType action, Vector&lt;Ref&lt;Node&gt;&gt;&amp; nodes, Node* oldContainer, RefPtr&lt;Node&gt; newContainer)
 770 {
 771     for (auto&amp; node : nodes) {
 772         switch (action) {
 773         case Range::Delete: {
 774             auto result = oldContainer-&gt;removeChild(node);
 775             if (result.hasException())
 776                 return result.releaseException();
 777             break;
 778         }
 779         case Range::Extract: {
 780             auto result = newContainer-&gt;appendChild(node); // will remove node from its parent
 781             if (result.hasException())
 782                 return result.releaseException();
 783             break;
 784         }
 785         case Range::Clone: {
 786             auto result = newContainer-&gt;appendChild(node-&gt;cloneNode(true));
</pre>
<hr />
<pre>
 844                     if (result.hasException())
 845                         return result.releaseException();
 846                 }
 847                 break;
 848             case Range::Clone:
 849                 if (direction == ProcessContentsForward) {
 850                     auto result = clonedContainer-&gt;appendChild(child-&gt;cloneNode(true));
 851                     if (result.hasException())
 852                         return result.releaseException();
 853                 } else {
 854                     auto result = clonedContainer-&gt;insertBefore(child-&gt;cloneNode(true), clonedContainer-&gt;firstChild());
 855                     if (result.hasException())
 856                         return result.releaseException();
 857                 }
 858                 break;
 859             }
 860         }
 861         firstChildInAncestorToProcess = direction == ProcessContentsForward ? ancestor-&gt;nextSibling() : ancestor-&gt;previousSibling();
 862     }
 863 
<span class="line-modified"> 864     return clonedContainer;</span>
 865 }
 866 
 867 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::extractContents()
 868 {
 869     auto result = processContents(Extract);
 870     if (result.hasException())
 871         return result.releaseException();
 872     return result.releaseReturnValue().releaseNonNull();
 873 }
 874 
 875 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::cloneContents()
 876 {
 877     auto result = processContents(Clone);
 878     if (result.hasException())
 879         return result.releaseException();
 880     return result.releaseReturnValue().releaseNonNull();
 881 }
 882 
 883 ExceptionOr&lt;void&gt; Range::insertNode(Ref&lt;Node&gt;&amp;&amp; node)
 884 {
</pre>
<hr />
<pre>
 929         return insertResult.releaseException();
 930 
 931     if (collapsed())
 932         return setEnd(WTFMove(parent), newOffset);
 933 
 934     return { };
 935 }
 936 
 937 String Range::toString() const
 938 {
 939     StringBuilder builder;
 940 
 941     Node* pastLast = pastLastNode();
 942     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
 943         auto type = node-&gt;nodeType();
 944         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
 945             auto&amp; data = downcast&lt;CharacterData&gt;(*node).data();
 946             unsigned length = data.length();
 947             unsigned start = node == &amp;startContainer() ? std::min(m_start.offset(), length) : 0U;
 948             unsigned end = node == &amp;endContainer() ? std::min(std::max(start, m_end.offset()), length) : length;
<span class="line-modified"> 949             builder.appendSubstring(data, start, end - start);</span>
 950         }
 951     }
 952 
 953     return builder.toString();
 954 }
 955 
 956 String Range::text() const
 957 {
 958     // We need to update layout, since plainText uses line boxes in the render tree.
 959     // FIXME: As with innerText, we&#39;d like this to work even if there are no render objects.
 960     startContainer().document().updateLayout();
 961 
 962     return plainText(this);
 963 }
 964 
 965 // https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
 966 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::createContextualFragment(const String&amp; markup)
 967 {
 968     Node&amp; node = startContainer();
 969     RefPtr&lt;Element&gt; element;
</pre>
<hr />
<pre>
1144 
1145 Node* Range::pastLastNode() const
1146 {
1147     if (endContainer().isCharacterDataNode())
1148         return NodeTraversal::nextSkippingChildren(endContainer());
1149     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
1150         return child;
1151     return NodeTraversal::nextSkippingChildren(endContainer());
1152 }
1153 
1154 IntRect Range::absoluteBoundingBox() const
1155 {
1156     IntRect result;
1157     Vector&lt;IntRect&gt; rects;
1158     absoluteTextRects(rects);
1159     for (auto&amp; rect : rects)
1160         result.unite(rect);
1161     return result;
1162 }
1163 
<span class="line-modified">1164 Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1165 {
1166     unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1167     unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1168 
1169     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed);
1170 
<span class="line-modified">1171     if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {</span>
1172         Vector&lt;FloatRect&gt; clippedRects;
1173         clippedRects.reserveInitialCapacity(textQuads.size());
1174 
1175         auto absoluteClippedOverflowRect = renderText.absoluteClippedOverflowRect();
1176 
1177         for (auto&amp; quad : textQuads) {
1178             auto clippedRect = intersection(quad.boundingBox(), absoluteClippedOverflowRect);
1179             if (!clippedRect.isEmpty())
1180                 clippedRects.uncheckedAppend(clippedRect);
1181         }
1182 
1183         return clippedRects;
1184     }
1185 
1186     Vector&lt;FloatRect&gt; floatRects;
1187     floatRects.reserveInitialCapacity(textQuads.size());
1188     for (auto&amp; quad : textQuads)
1189         floatRects.uncheckedAppend(quad.boundingBox());
1190     return floatRects;
1191 }
1192 
<span class="line-modified">1193 void Range::absoluteTextRects(Vector&lt;IntRect&gt;&amp; rects, bool useSelectionHeight, RangeInFixedPosition* inFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1194 {
1195     // FIXME: This function should probably return FloatRects.
1196 
1197     bool allFixed = true;
1198     bool someFixed = false;
1199 
1200     Node* stopNode = pastLastNode();
1201     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1202         RenderObject* renderer = node-&gt;renderer();
1203         if (!renderer)
1204             continue;
1205         bool isFixed = false;
1206         if (renderer-&gt;isBR())
1207             renderer-&gt;absoluteRects(rects, flooredLayoutPoint(renderer-&gt;localToAbsolute()));
1208         else if (is&lt;RenderText&gt;(*renderer)) {
<span class="line-modified">1209             auto rectsForRenderer = absoluteRectsForRangeInText(node, downcast&lt;RenderText&gt;(*renderer), useSelectionHeight, isFixed, rectOptions);</span>
1210             for (auto&amp; rect : rectsForRenderer)
1211                 rects.append(enclosingIntRect(rect));
1212         } else
1213             continue;
1214         allFixed &amp;= isFixed;
1215         someFixed |= isFixed;
1216     }
1217 
1218     if (inFixed)
1219         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1220 }
1221 
1222 void Range::absoluteTextQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool useSelectionHeight, RangeInFixedPosition* inFixed) const
1223 {
1224     bool allFixed = true;
1225     bool someFixed = false;
1226 
1227     Node* stopNode = pastLastNode();
1228     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1229         RenderObject* renderer = node-&gt;renderer();
</pre>
<hr />
<pre>
1778         return Exception { TypeError };
1779     auto result = setStart(*startContainer, start.deepEquivalent().computeOffsetInContainerNode());
1780     if (result.hasException())
1781         return result.releaseException();
1782     auto* endContainer = end.deepEquivalent().containerNode();
1783     if (!endContainer)
1784         return Exception { TypeError };
1785     return setEnd(*endContainer, end.deepEquivalent().computeOffsetInContainerNode());
1786 }
1787 
1788 Ref&lt;DOMRectList&gt; Range::getClientRects() const
1789 {
1790     return DOMRectList::create(borderAndTextRects(CoordinateSpace::Client));
1791 }
1792 
1793 Ref&lt;DOMRect&gt; Range::getBoundingClientRect() const
1794 {
1795     return DOMRect::create(boundingRect(CoordinateSpace::Client));
1796 }
1797 
<span class="line-modified">1798 Vector&lt;FloatRect&gt; Range::borderAndTextRects(CoordinateSpace space, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1799 {
1800     Vector&lt;FloatRect&gt; rects;
1801 
1802     ownerDocument().updateLayoutIgnorePendingStylesheets();
1803 
1804     Node* stopNode = pastLastNode();
<span class="line-added">1805     bool useVisibleBounds = rectOptions.contains(BoundingRectBehavior::UseVisibleBounds);</span>
1806 
1807     HashSet&lt;Node*&gt; selectedElementsSet;
1808     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1809         if (is&lt;Element&gt;(*node))
1810             selectedElementsSet.add(node);
1811     }
1812 
1813     // Don&#39;t include elements that are only partially selected.
1814     Node* lastNode = m_end.childBefore() ? m_end.childBefore() : &amp;endContainer();
1815     for (Node* parent = lastNode-&gt;parentNode(); parent; parent = parent-&gt;parentNode())
1816         selectedElementsSet.remove(parent);
1817 
<span class="line-added">1818     OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };</span>
<span class="line-added">1819 </span>
1820     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
<span class="line-modified">1821         if (is&lt;Element&gt;(*node) &amp;&amp; selectedElementsSet.contains(node) &amp;&amp; (useVisibleBounds || !node-&gt;parentNode() || !selectedElementsSet.contains(node-&gt;parentNode()))) {</span>
1822             if (auto* renderer = downcast&lt;Element&gt;(*node).renderBoxModelObject()) {
<span class="line-added">1823                 if (useVisibleBounds) {</span>
<span class="line-added">1824                     auto localBounds = renderer-&gt;borderBoundingBox();</span>
<span class="line-added">1825                     auto rootClippedBounds = renderer-&gt;computeVisibleRectInContainer(localBounds, &amp;renderer-&gt;view(), { false, false, visibleRectOptions });</span>
<span class="line-added">1826                     if (!rootClippedBounds)</span>
<span class="line-added">1827                         continue;</span>
<span class="line-added">1828                     auto snappedBounds = snapRectToDevicePixels(*rootClippedBounds, node-&gt;document().deviceScaleFactor());</span>
<span class="line-added">1829                     if (space == CoordinateSpace::Client)</span>
<span class="line-added">1830                         node-&gt;document().convertAbsoluteToClientRect(snappedBounds, renderer-&gt;style());</span>
<span class="line-added">1831                     rects.append(snappedBounds);</span>
<span class="line-added">1832 </span>
<span class="line-added">1833                     continue;</span>
<span class="line-added">1834                 }</span>
<span class="line-added">1835 </span>
1836                 Vector&lt;FloatQuad&gt; elementQuads;
1837                 renderer-&gt;absoluteQuads(elementQuads);
1838                 if (space == CoordinateSpace::Client)
1839                     node-&gt;document().convertAbsoluteToClientQuads(elementQuads, renderer-&gt;style());
1840 
1841                 for (auto&amp; quad : elementQuads)
1842                     rects.append(quad.boundingBox());
1843             }
1844         } else if (is&lt;Text&gt;(*node)) {
1845             if (auto* renderer = downcast&lt;Text&gt;(*node).renderer()) {
1846                 bool isFixed;
<span class="line-modified">1847                 auto clippedRects = absoluteRectsForRangeInText(node, *renderer, false, isFixed, rectOptions);</span>
1848                 if (space == CoordinateSpace::Client)
1849                     node-&gt;document().convertAbsoluteToClientRects(clippedRects, renderer-&gt;style());
1850 
1851                 rects.appendVector(clippedRects);
1852             }
1853         }
1854     }
1855 
<span class="line-added">1856     if (rectOptions.contains(BoundingRectBehavior::IgnoreTinyRects)) {</span>
<span class="line-added">1857         rects.removeAllMatching([&amp;] (const FloatRect&amp; rect) -&gt; bool {</span>
<span class="line-added">1858             return rect.area() &lt;= 1;</span>
<span class="line-added">1859         });</span>
<span class="line-added">1860     }</span>
<span class="line-added">1861 </span>
1862     return rects;
1863 }
1864 
<span class="line-modified">1865 FloatRect Range::boundingRect(CoordinateSpace space, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1866 {
1867     FloatRect result;
<span class="line-modified">1868     for (auto&amp; rect : borderAndTextRects(space, rectOptions))</span>
<span class="line-modified">1869         result.uniteIfNonZero(rect);</span>
1870     return result;
1871 }
1872 
<span class="line-modified">1873 FloatRect Range::absoluteBoundingRect(OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1874 {
<span class="line-modified">1875     return boundingRect(CoordinateSpace::Absolute, rectOptions);</span>
1876 }
1877 
1878 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const RangeBoundaryPoint&amp; r)
1879 {
1880     return ts &lt;&lt; r.toPosition();
1881 }
1882 
1883 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, const Range&amp; r)
1884 {
1885     return ts &lt;&lt; &quot;Range: &quot; &lt;&lt; &quot;start: &quot; &lt;&lt; r.startPosition() &lt;&lt; &quot; end: &quot; &lt;&lt; r.endPosition();
1886 }
1887 
1888 } // namespace WebCore
1889 
1890 #if ENABLE(TREE_DEBUGGING)
1891 
1892 void showTree(const WebCore::Range* range)
1893 {
1894     if (range &amp;&amp; range-&gt;boundaryPointsValid()) {
1895         range-&gt;startContainer().showTreeAndMark(&amp;range-&gt;startContainer(), &quot;S&quot;, &amp;range-&gt;endContainer(), &quot;E&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="RadioButtonGroups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>