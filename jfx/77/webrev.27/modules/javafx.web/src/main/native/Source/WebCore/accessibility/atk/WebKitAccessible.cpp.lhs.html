<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/WebKitAccessible.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008 Nuanti Ltd.
   3  * Copyright (C) 2009 Jan Alonzo
   4  * Copyright (C) 2009, 2010, 2011, 2012, 2019 Igalia S.L.
   5  * Copyright (C) 2013 Samsung Electronics
   6  *
   7  * Portions from Mozilla a11y, copyright as follows:
   8  *
   9  * The Original Code is mozilla.org code.
  10  *
  11  * The Initial Developer of the Original Code is
  12  * Sun Microsystems, Inc.
  13  * Portions created by the Initial Developer are Copyright (C) 2002
  14  * the Initial Developer. All Rights Reserved.
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Library General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24  * Library General Public License for more details.
  25  *
  26  * You should have received a copy of the GNU Library General Public License
  27  * along with this library; see the file COPYING.LIB.  If not, write to
  28  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29  * Boston, MA 02110-1301, USA.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;WebKitAccessible.h&quot;
  34 
<a name="1" id="anc1"></a><span class="line-modified">  35 #if HAVE(ACCESSIBILITY)</span>
  36 
  37 #include &quot;AXObjectCache.h&quot;
  38 #include &quot;AccessibilityList.h&quot;
  39 #include &quot;AccessibilityListBoxOption.h&quot;
  40 #include &quot;AccessibilityTable.h&quot;
  41 #include &quot;AccessibilityTableCell.h&quot;
  42 #include &quot;AccessibilityTableRow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;Editing.h&quot;
  45 #include &quot;Frame.h&quot;
  46 #include &quot;FrameView.h&quot;
  47 #include &quot;HTMLNames.h&quot;
  48 #include &quot;HTMLTableElement.h&quot;
  49 #include &quot;HostWindow.h&quot;
  50 #include &quot;RenderAncestorIterator.h&quot;
  51 #include &quot;RenderBlock.h&quot;
  52 #include &quot;RenderObject.h&quot;
  53 #include &quot;SVGElement.h&quot;
  54 #include &quot;Settings.h&quot;
  55 #include &quot;TextIterator.h&quot;
  56 #include &quot;VisibleUnits.h&quot;
  57 #include &quot;WebKitAccessibleHyperlink.h&quot;
  58 #include &quot;WebKitAccessibleInterfaceAction.h&quot;
  59 #include &quot;WebKitAccessibleInterfaceComponent.h&quot;
  60 #include &quot;WebKitAccessibleInterfaceDocument.h&quot;
  61 #include &quot;WebKitAccessibleInterfaceEditableText.h&quot;
  62 #include &quot;WebKitAccessibleInterfaceHyperlinkImpl.h&quot;
  63 #include &quot;WebKitAccessibleInterfaceHypertext.h&quot;
  64 #include &quot;WebKitAccessibleInterfaceImage.h&quot;
  65 #include &quot;WebKitAccessibleInterfaceSelection.h&quot;
  66 #include &quot;WebKitAccessibleInterfaceTable.h&quot;
  67 #include &quot;WebKitAccessibleInterfaceTableCell.h&quot;
  68 #include &quot;WebKitAccessibleInterfaceText.h&quot;
  69 #include &quot;WebKitAccessibleInterfaceValue.h&quot;
  70 #include &quot;WebKitAccessibleUtil.h&quot;
  71 #include &lt;glib/gprintf.h&gt;
  72 #include &lt;wtf/glib/WTFGType.h&gt;
  73 #include &lt;wtf/text/CString.h&gt;
  74 
  75 using namespace WebCore;
  76 
  77 struct _WebKitAccessiblePrivate {
  78     AccessibilityObject* object;
  79 
  80     // Cached data for AtkObject.
  81     CString accessibleName;
  82     CString accessibleDescription;
  83 
  84     // Cached data for AtkAction.
  85     CString actionName;
  86     CString actionKeyBinding;
  87 
  88     // Cached data for AtkDocument.
  89     CString documentLocale;
  90     CString documentType;
  91     CString documentEncoding;
  92     CString documentURI;
  93 
  94     // Cached data for AtkImage.
  95     CString imageDescription;
  96 };
  97 
  98 WEBKIT_DEFINE_TYPE(WebKitAccessible, webkit_accessible, ATK_TYPE_OBJECT)
  99 
 100 static AccessibilityObject* fallbackObject()
 101 {
 102     static AccessibilityObject* object = &amp;AccessibilityListBoxOption::create().leakRef();
 103     return object;
 104 }
 105 
 106 static const gchar* webkitAccessibleGetName(AtkObject* object)
 107 {
 108     auto* accessible = WEBKIT_ACCESSIBLE(object);
 109     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 110 
 111     Vector&lt;AccessibilityText&gt; textOrder;
 112     accessible-&gt;priv-&gt;object-&gt;accessibilityText(textOrder);
 113 
 114     for (const auto&amp; text : textOrder) {
 115         // FIXME: This check is here because AccessibilityNodeObject::titleElementText()
 116         // appends an empty String for the LabelByElementText source when there is a
 117         // titleUIElement(). Removing this check makes some fieldsets lose their name.
 118         if (text.text.isEmpty())
 119             continue;
 120 
 121         // WebCore Accessibility should provide us with the text alternative computation
 122         // in the order defined by that spec. So take the first thing that our platform
 123         // does not expose via the AtkObject description.
 124         if (text.textSource != AccessibilityTextSource::Help &amp;&amp; text.textSource != AccessibilityTextSource::Summary)
 125             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleName, text.text.utf8());
 126     }
 127 
 128     return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleName, &quot;&quot;);
 129 }
 130 
 131 static const gchar* webkitAccessibleGetDescription(AtkObject* object)
 132 {
 133     auto* accessible = WEBKIT_ACCESSIBLE(object);
 134     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 135 
 136     Vector&lt;AccessibilityText&gt; textOrder;
 137     accessible-&gt;priv-&gt;object-&gt;accessibilityText(textOrder);
 138 
 139     bool nameTextAvailable = false;
 140     for (const auto&amp; text : textOrder) {
 141         // WebCore Accessibility should provide us with the text alternative computation
 142         // in the order defined by that spec. So take the first thing that our platform
 143         // does not expose via the AtkObject name.
 144         if (text.textSource == AccessibilityTextSource::Help || text.textSource == AccessibilityTextSource::Summary)
 145             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, text.text.utf8());
 146 
 147         // If there is no other text alternative, the title tag contents will have been
 148         // used for the AtkObject name. We don&#39;t want to duplicate it here.
 149         if (text.textSource == AccessibilityTextSource::TitleTag &amp;&amp; nameTextAvailable)
 150             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, text.text.utf8());
 151 
 152         nameTextAvailable = true;
 153     }
 154 
 155     return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedAccessibleDescription, &quot;&quot;);
 156 }
 157 
 158 static void removeAtkRelationByType(AtkRelationSet* relationSet, AtkRelationType relationType)
 159 {
 160     int count = atk_relation_set_get_n_relations(relationSet);
 161     for (int i = 0; i &lt; count; i++) {
 162         AtkRelation* relation = atk_relation_set_get_relation(relationSet, i);
 163         if (atk_relation_get_relation_type(relation) == relationType) {
 164             atk_relation_set_remove(relationSet, relation);
 165             break;
 166         }
 167     }
 168 }
 169 
 170 static void setAtkRelationSetFromCoreObject(AccessibilityObject* coreObject, AtkRelationSet* relationSet)
 171 {
 172     // Elements with aria-labelledby should have the labelled-by relation as per the ARIA AAM spec.
 173     // Controls with a label element and fieldsets with a legend element should also use this relation
 174     // as per the HTML AAM spec. The reciprocal label-for relation should also be used.
 175     removeAtkRelationByType(relationSet, ATK_RELATION_LABELLED_BY);
 176     removeAtkRelationByType(relationSet, ATK_RELATION_LABEL_FOR);
 177     if (coreObject-&gt;isControl()) {
 178         if (AccessibilityObject* label = coreObject-&gt;correspondingLabelForControlElement())
 179             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(label-&gt;wrapper()));
 180     } else if (coreObject-&gt;isFieldset()) {
 181         if (AccessibilityObject* label = coreObject-&gt;titleUIElement())
 182             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(label-&gt;wrapper()));
 183     } else if (coreObject-&gt;roleValue() == AccessibilityRole::Legend) {
 184         if (RenderBlock* renderFieldset = ancestorsOfType&lt;RenderBlock&gt;(*coreObject-&gt;renderer()).first()) {
 185             if (renderFieldset-&gt;isFieldset()) {
 186                 AccessibilityObject* fieldset = coreObject-&gt;axObjectCache()-&gt;getOrCreate(renderFieldset);
 187                 atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(fieldset-&gt;wrapper()));
 188             }
 189         }
 190     } else if (AccessibilityObject* control = coreObject-&gt;correspondingControlForLabelElement())
 191         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(control-&gt;wrapper()));
 192     else {
 193         AccessibilityObject::AccessibilityChildrenVector ariaLabelledByElements;
 194         coreObject-&gt;ariaLabelledByElements(ariaLabelledByElements);
 195         for (const auto&amp; accessibilityObject : ariaLabelledByElements)
 196             atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABELLED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 197     }
 198 
 199     // Elements referenced by aria-labelledby should have the label-for relation as per the ARIA AAM spec.
 200     AccessibilityObject::AccessibilityChildrenVector labels;
 201     coreObject-&gt;ariaLabelledByReferencingElements(labels);
 202     for (const auto&amp; accessibilityObject : labels)
 203         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_LABEL_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 204 
 205     // Elements with aria-flowto should have the flows-to relation as per the ARIA AAM spec.
 206     removeAtkRelationByType(relationSet, ATK_RELATION_FLOWS_TO);
 207     AccessibilityObject::AccessibilityChildrenVector ariaFlowToElements;
 208     coreObject-&gt;ariaFlowToElements(ariaFlowToElements);
 209     for (const auto&amp; accessibilityObject : ariaFlowToElements)
 210         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_FLOWS_TO, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 211 
 212     // Elements referenced by aria-flowto should have the flows-from relation as per the ARIA AAM spec.
 213     removeAtkRelationByType(relationSet, ATK_RELATION_FLOWS_FROM);
 214     AccessibilityObject::AccessibilityChildrenVector flowFrom;
 215     coreObject-&gt;ariaFlowToReferencingElements(flowFrom);
 216     for (const auto&amp; accessibilityObject : flowFrom)
 217         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_FLOWS_FROM, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 218 
 219     // Elements with aria-describedby should have the described-by relation as per the ARIA AAM spec.
 220     removeAtkRelationByType(relationSet, ATK_RELATION_DESCRIBED_BY);
 221     AccessibilityObject::AccessibilityChildrenVector ariaDescribedByElements;
 222     coreObject-&gt;ariaDescribedByElements(ariaDescribedByElements);
 223     for (const auto&amp; accessibilityObject : ariaDescribedByElements)
 224         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DESCRIBED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 225 
 226     // Elements referenced by aria-describedby should have the description-for relation as per the ARIA AAM spec.
 227     removeAtkRelationByType(relationSet, ATK_RELATION_DESCRIPTION_FOR);
 228     AccessibilityObject::AccessibilityChildrenVector describers;
 229     coreObject-&gt;ariaDescribedByReferencingElements(describers);
 230     for (const auto&amp; accessibilityObject : describers)
 231         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DESCRIPTION_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 232 
 233     // Elements with aria-controls should have the controller-for relation as per the ARIA AAM spec.
 234     removeAtkRelationByType(relationSet, ATK_RELATION_CONTROLLER_FOR);
 235     AccessibilityObject::AccessibilityChildrenVector ariaControls;
 236     coreObject-&gt;ariaControlsElements(ariaControls);
 237     for (const auto&amp; accessibilityObject : ariaControls)
 238         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_CONTROLLER_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 239 
 240     // Elements referenced by aria-controls should have the controlled-by relation as per the ARIA AAM spec.
 241     removeAtkRelationByType(relationSet, ATK_RELATION_CONTROLLED_BY);
 242     AccessibilityObject::AccessibilityChildrenVector controllers;
 243     coreObject-&gt;ariaControlsReferencingElements(controllers);
 244     for (const auto&amp; accessibilityObject : controllers)
 245         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_CONTROLLED_BY, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 246 
 247     // Elements with aria-owns should have the node-parent-of relation as per the ARIA AAM spec.
 248     removeAtkRelationByType(relationSet, ATK_RELATION_NODE_PARENT_OF);
 249     AccessibilityObject::AccessibilityChildrenVector ariaOwns;
 250     coreObject-&gt;ariaOwnsElements(ariaOwns);
 251     for (const auto&amp; accessibilityObject : ariaOwns)
 252         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_NODE_PARENT_OF, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 253 
 254     // Elements referenced by aria-owns should have the node-child-of relation as per the ARIA AAM spec.
 255     removeAtkRelationByType(relationSet, ATK_RELATION_NODE_CHILD_OF);
 256     AccessibilityObject::AccessibilityChildrenVector owners;
 257     coreObject-&gt;ariaOwnsReferencingElements(owners);
 258     for (const auto&amp; accessibilityObject : owners)
 259         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_NODE_CHILD_OF, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 260 
 261 #if ATK_CHECK_VERSION(2, 25, 2)
 262     // Elements with aria-details should have the details relation as per the ARIA AAM spec.
 263     removeAtkRelationByType(relationSet, ATK_RELATION_DETAILS);
 264     AccessibilityObject::AccessibilityChildrenVector ariaDetails;
 265     coreObject-&gt;ariaDetailsElements(ariaDetails);
 266     for (const auto&amp; accessibilityObject : ariaDetails)
 267         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DETAILS, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 268 
 269     // Elements referenced by aria-details should have the details-for relation as per the ARIA AAM spec.
 270     removeAtkRelationByType(relationSet, ATK_RELATION_DETAILS_FOR);
 271     AccessibilityObject::AccessibilityChildrenVector details;
 272     coreObject-&gt;ariaDetailsReferencingElements(details);
 273     for (const auto&amp; accessibilityObject : details)
 274         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_DETAILS_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 275 
 276     // Elements with aria-errormessage should have the error-message relation as per the ARIA AAM spec.
 277     removeAtkRelationByType(relationSet, ATK_RELATION_ERROR_MESSAGE);
 278     AccessibilityObject::AccessibilityChildrenVector ariaErrorMessage;
 279     coreObject-&gt;ariaErrorMessageElements(ariaErrorMessage);
 280     for (const auto&amp; accessibilityObject : ariaErrorMessage)
 281         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_ERROR_MESSAGE, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 282 
 283     // Elements referenced by aria-errormessage should have the error-for relation as per the ARIA AAM spec.
 284     removeAtkRelationByType(relationSet, ATK_RELATION_ERROR_FOR);
 285     AccessibilityObject::AccessibilityChildrenVector errors;
 286     coreObject-&gt;ariaErrorMessageReferencingElements(errors);
 287     for (const auto&amp; accessibilityObject : errors)
 288         atk_relation_set_add_relation_by_type(relationSet, ATK_RELATION_ERROR_FOR, ATK_OBJECT(accessibilityObject-&gt;wrapper()));
 289 #endif
 290 }
 291 
 292 static bool isRootObject(AccessibilityObject* coreObject)
 293 {
 294     // The root accessible object in WebCore is always an object with
 295     // the ScrolledArea role with one child with the WebArea role.
 296     if (!coreObject || !coreObject-&gt;isScrollView())
 297         return false;
 298 
 299     AccessibilityObject* firstChild = coreObject-&gt;firstChild();
 300     return firstChild &amp;&amp; firstChild-&gt;isWebArea();
 301 }
 302 
 303 static AtkObject* webkitAccessibleGetParent(AtkObject* object)
 304 {
 305     auto* accessible = WEBKIT_ACCESSIBLE(object);
 306     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 307 
 308     // Check first if the parent has been already set.
 309     AtkObject* accessibleParent = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;get_parent(object);
 310     if (accessibleParent)
 311         return accessibleParent;
 312 
 313     // Parent not set yet, so try to find it in the hierarchy.
 314     auto* coreObject = accessible-&gt;priv-&gt;object;
 315     auto* coreParent = coreObject-&gt;parentObjectUnignored();
 316     if (!coreParent &amp;&amp; isRootObject(coreObject)) {
 317         // The top level object claims to not have a parent. This makes it
 318         // impossible for assistive technologies to ascend the accessible
 319         // hierarchy all the way to the application. (Bug 30489)
 320         if (!coreObject-&gt;document())
 321             return nullptr;
 322     }
 323 
 324     return coreParent ? ATK_OBJECT(coreParent-&gt;wrapper()) : nullptr;
 325 }
 326 
 327 static gint webkitAccessibleGetNChildren(AtkObject* object)
 328 {
 329     auto* accessible = WEBKIT_ACCESSIBLE(object);
 330     returnValIfWebKitAccessibleIsInvalid(accessible, 0);
 331 
 332     return accessible-&gt;priv-&gt;object-&gt;children().size();
 333 }
 334 
 335 static AtkObject* webkitAccessibleRefChild(AtkObject* object, gint index)
 336 {
 337     auto* accessible = WEBKIT_ACCESSIBLE(object);
 338     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 339 
 340     if (index &lt; 0)
 341         return nullptr;
 342 
 343     const auto&amp; children = accessible-&gt;priv-&gt;object-&gt;children();
 344     if (static_cast&lt;size_t&gt;(index) &gt;= children.size())
 345         return nullptr;
 346 
 347     auto&amp; coreChild = children[index];
 348     if (!coreChild)
 349         return nullptr;
 350 
 351     auto* child = coreChild-&gt;wrapper();
 352     if (!child)
 353         return nullptr;
 354 
 355     atk_object_set_parent(ATK_OBJECT(child), object);
 356     return ATK_OBJECT(g_object_ref(child));
 357 }
 358 
 359 static gint webkitAccessibleGetIndexInParent(AtkObject* object)
 360 {
 361     auto* accessible = WEBKIT_ACCESSIBLE(object);
 362     returnValIfWebKitAccessibleIsInvalid(accessible, -1);
 363 
 364     auto* coreObject = accessible-&gt;priv-&gt;object;
 365     auto* parent = coreObject-&gt;parentObjectUnignored();
 366     if (!parent &amp;&amp; isRootObject(coreObject)) {
 367         if (!coreObject-&gt;document())
 368             return -1;
 369 
 370         auto* atkParent = parent ? ATK_OBJECT(parent-&gt;wrapper()) : nullptr;
 371         if (!atkParent)
 372             return -1;
 373 
 374         unsigned count = atk_object_get_n_accessible_children(atkParent);
 375         for (unsigned i = 0; i &lt; count; ++i) {
 376             GRefPtr&lt;AtkObject&gt; child = adoptGRef(atk_object_ref_accessible_child(atkParent, i));
 377             if (child.get() == object)
 378                 return i;
 379         }
 380     }
 381 
 382     if (!parent)
 383         return -1;
 384 
 385     size_t index = parent-&gt;children().find(coreObject);
 386     return (index == WTF::notFound) ? -1 : index;
 387 }
 388 
 389 static AtkAttributeSet* webkitAccessibleGetAttributes(AtkObject* object)
 390 {
 391     auto* accessible = WEBKIT_ACCESSIBLE(object);
 392     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
 393 
 394     AtkAttributeSet* attributeSet = nullptr;
 395 #if PLATFORM(GTK)
 396     attributeSet = addToAtkAttributeSet(attributeSet, &quot;toolkit&quot;, &quot;WebKitGtk&quot;);
<a name="2" id="anc2"></a>

 397 #endif
 398 
 399     auto* coreObject = accessible-&gt;priv-&gt;object;
 400 
 401     // Hack needed for WebKit2 tests because obtaining an element by its ID
 402     // cannot be done from the UIProcess. Assistive technologies have no need
 403     // for this information.
 404     Element* element = coreObject-&gt;element() ? coreObject-&gt;element() : coreObject-&gt;actionElement();
 405     if (element) {
 406         String tagName = element-&gt;tagName();
 407         if (!tagName.isEmpty())
 408             attributeSet = addToAtkAttributeSet(attributeSet, &quot;tag&quot;, tagName.convertToASCIILowercase().utf8().data());
 409         String id = element-&gt;getIdAttribute().string();
 410         if (!id.isEmpty())
 411             attributeSet = addToAtkAttributeSet(attributeSet, &quot;html-id&quot;, id.utf8().data());
 412     }
 413 
 414     int level = coreObject-&gt;isHeading() ? coreObject-&gt;headingLevel() : coreObject-&gt;hierarchicalLevel();
 415     if (level) {
 416         String value = String::number(level);
 417         attributeSet = addToAtkAttributeSet(attributeSet, &quot;level&quot;, value.utf8().data());
 418     }
 419 
 420     if (coreObject-&gt;roleValue() == AccessibilityRole::MathElement) {
 421         if (coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSubscript))
 422             attributeSet = addToAtkAttributeSet(attributeSet, &quot;multiscript-type&quot;, &quot;pre&quot;);
 423         else if (coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSubscript))
 424             attributeSet = addToAtkAttributeSet(attributeSet, &quot;multiscript-type&quot;, &quot;post&quot;);
 425     }
 426 
 427     if (is&lt;AccessibilityTable&gt;(*coreObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*coreObject).isExposableThroughAccessibility()) {
 428         auto&amp; table = downcast&lt;AccessibilityTable&gt;(*coreObject);
 429         int rowCount = table.axRowCount();
 430         if (rowCount)
 431             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowcount&quot;, String::number(rowCount).utf8().data());
 432 
 433         int columnCount = table.axColumnCount();
 434         if (columnCount)
 435             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colcount&quot;, String::number(columnCount).utf8().data());
 436     } else if (is&lt;AccessibilityTableRow&gt;(*coreObject)) {
 437         auto&amp; row = downcast&lt;AccessibilityTableRow&gt;(*coreObject);
 438         int rowIndex = row.axRowIndex();
 439         if (rowIndex != -1)
 440             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowindex&quot;, String::number(rowIndex).utf8().data());
 441     } else if (is&lt;AccessibilityTableCell&gt;(*coreObject)) {
 442         auto&amp; cell = downcast&lt;AccessibilityTableCell&gt;(*coreObject);
 443         int rowIndex = cell.axRowIndex();
 444         if (rowIndex != -1)
 445             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowindex&quot;, String::number(rowIndex).utf8().data());
 446 
 447         int columnIndex = cell.axColumnIndex();
 448         if (columnIndex != -1)
 449             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colindex&quot;, String::number(columnIndex).utf8().data());
 450 
 451         int rowSpan = cell.axRowSpan();
 452         if (rowSpan != -1)
 453             attributeSet = addToAtkAttributeSet(attributeSet, &quot;rowspan&quot;, String::number(rowSpan).utf8().data());
 454 
 455         int columnSpan = cell.axColumnSpan();
 456         if (columnSpan != -1)
 457             attributeSet = addToAtkAttributeSet(attributeSet, &quot;colspan&quot;, String::number(columnSpan).utf8().data());
 458     }
 459 
 460     String placeholder = coreObject-&gt;placeholderValue();
 461     if (!placeholder.isEmpty())
 462         attributeSet = addToAtkAttributeSet(attributeSet, &quot;placeholder-text&quot;, placeholder.utf8().data());
 463 
 464     if (coreObject-&gt;supportsAutoComplete())
 465         attributeSet = addToAtkAttributeSet(attributeSet, &quot;autocomplete&quot;, coreObject-&gt;autoCompleteValue().utf8().data());
 466 
 467     if (coreObject-&gt;supportsHasPopup())
<a name="3" id="anc3"></a><span class="line-modified"> 468         attributeSet = addToAtkAttributeSet(attributeSet, &quot;haspopup&quot;, coreObject-&gt;hasPopupValue().utf8().data());</span>
 469 
 470     if (coreObject-&gt;supportsCurrent())
 471         attributeSet = addToAtkAttributeSet(attributeSet, &quot;current&quot;, coreObject-&gt;currentValue().utf8().data());
 472 
 473     // The Core AAM states that an explicitly-set value should be exposed, including &quot;none&quot;.
 474     if (coreObject-&gt;hasAttribute(HTMLNames::aria_sortAttr)) {
 475         switch (coreObject-&gt;sortDirection()) {
 476         case AccessibilitySortDirection::Invalid:
 477             break;
 478         case AccessibilitySortDirection::Ascending:
 479             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;ascending&quot;);
 480             break;
 481         case AccessibilitySortDirection::Descending:
 482             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;descending&quot;);
 483             break;
 484         case AccessibilitySortDirection::Other:
 485             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;other&quot;);
 486             break;
 487         case AccessibilitySortDirection::None:
 488             attributeSet = addToAtkAttributeSet(attributeSet, &quot;sort&quot;, &quot;none&quot;);
 489         }
 490     }
 491 
 492     if (coreObject-&gt;supportsPosInSet())
 493         attributeSet = addToAtkAttributeSet(attributeSet, &quot;posinset&quot;, String::number(coreObject-&gt;posInSet()).utf8().data());
 494 
 495     if (coreObject-&gt;supportsSetSize())
 496         attributeSet = addToAtkAttributeSet(attributeSet, &quot;setsize&quot;, String::number(coreObject-&gt;setSize()).utf8().data());
 497 
 498     String isReadOnly = coreObject-&gt;readOnlyValue();
 499     if (!isReadOnly.isEmpty())
 500         attributeSet = addToAtkAttributeSet(attributeSet, &quot;readonly&quot;, isReadOnly.utf8().data());
 501 
 502     String valueDescription = coreObject-&gt;valueDescription();
 503     if (!valueDescription.isEmpty())
 504         attributeSet = addToAtkAttributeSet(attributeSet, &quot;valuetext&quot;, valueDescription.utf8().data());
 505 
 506     // According to the W3C Core Accessibility API Mappings 1.1, section 5.4.1 General Rules:
 507     // &quot;User agents must expose the WAI-ARIA role string if the API supports a mechanism to do so.&quot;
 508     // In the case of ATK, the mechanism to do so is an object attribute pair (xml-roles:&quot;string&quot;).
 509     // We cannot use the computedRoleString for this purpose because it is not limited to elements
 510     // with ARIA roles, and it might not contain the actual ARIA role value (e.g. DPub ARIA).
 511     String roleString = coreObject-&gt;getAttribute(HTMLNames::roleAttr);
 512     if (!roleString.isEmpty())
 513         attributeSet = addToAtkAttributeSet(attributeSet, &quot;xml-roles&quot;, roleString.utf8().data());
 514 
 515     String computedRoleString = coreObject-&gt;computedRoleString();
 516     if (!computedRoleString.isEmpty()) {
 517         attributeSet = addToAtkAttributeSet(attributeSet, &quot;computed-role&quot;, computedRoleString.utf8().data());
 518 
 519         // The HTML AAM maps several elements to ARIA landmark roles. In order for the type of landmark
 520         // to be obtainable in the same fashion as an ARIA landmark, fall back on the computedRoleString.
<a name="4" id="anc4"></a><span class="line-modified"> 521         if (coreObject-&gt;ariaRoleAttribute() == AccessibilityRole::Unknown &amp;&amp; coreObject-&gt;isLandmark())</span>



 522             attributeSet = addToAtkAttributeSet(attributeSet, &quot;xml-roles&quot;, computedRoleString.utf8().data());
 523     }
 524 
 525     String roleDescription = coreObject-&gt;roleDescription();
 526     if (!roleDescription.isEmpty())
 527         attributeSet = addToAtkAttributeSet(attributeSet, &quot;roledescription&quot;, roleDescription.utf8().data());
 528 
 529     // We need to expose the live region attributes even if the live region is currently disabled/off.
 530     if (auto liveContainer = coreObject-&gt;liveRegionAncestor(false)) {
 531         String liveStatus = liveContainer-&gt;liveRegionStatus();
 532         String relevant = liveContainer-&gt;liveRegionRelevant();
<a name="5" id="anc5"></a><span class="line-modified"> 533         bool isAtomic = liveContainer-&gt;liveRegionAtomic();</span>
 534         String liveRole = roleString.isEmpty() ? computedRoleString : roleString;
 535 
 536         // According to the Core AAM, we need to expose the above properties with &quot;container-&quot; prefixed
 537         // object attributes regardless of whether the container is this object, or an ancestor of it.
 538         attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-live&quot;, liveStatus.utf8().data());
 539         attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-relevant&quot;, relevant.utf8().data());
<a name="6" id="anc6"></a><span class="line-modified"> 540         if (isAtomic)</span>
 541             attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-atomic&quot;, &quot;true&quot;);
 542         if (!liveRole.isEmpty())
 543             attributeSet = addToAtkAttributeSet(attributeSet, &quot;container-live-role&quot;, liveRole.utf8().data());
 544 
 545         // According to the Core AAM, if this object is the live region (rather than its descendant),
 546         // we must expose the above properties on the object without a &quot;container-&quot; prefix.
 547         if (liveContainer == coreObject) {
 548             attributeSet = addToAtkAttributeSet(attributeSet, &quot;live&quot;, liveStatus.utf8().data());
 549             attributeSet = addToAtkAttributeSet(attributeSet, &quot;relevant&quot;, relevant.utf8().data());
<a name="7" id="anc7"></a><span class="line-modified"> 550             if (isAtomic)</span>
 551                 attributeSet = addToAtkAttributeSet(attributeSet, &quot;atomic&quot;, &quot;true&quot;);
<a name="8" id="anc8"></a><span class="line-modified"> 552         } else if (!isAtomic &amp;&amp; coreObject-&gt;liveRegionAtomic())</span>
 553             attributeSet = addToAtkAttributeSet(attributeSet, &quot;atomic&quot;, &quot;true&quot;);
 554     }
 555 
 556     // The Core AAM states the author-provided value should be exposed as-is.
 557     String dropEffect = coreObject-&gt;getAttribute(HTMLNames::aria_dropeffectAttr);
 558     if (!dropEffect.isEmpty())
 559         attributeSet = addToAtkAttributeSet(attributeSet, &quot;dropeffect&quot;, dropEffect.utf8().data());
 560 
 561     if (coreObject-&gt;isARIAGrabbed())
 562         attributeSet = addToAtkAttributeSet(attributeSet, &quot;grabbed&quot;, &quot;true&quot;);
 563     else if (coreObject-&gt;supportsARIADragging())
 564         attributeSet = addToAtkAttributeSet(attributeSet, &quot;grabbed&quot;, &quot;false&quot;);
 565 
 566     // The Core AAM states the author-provided value should be exposed as-is.
<a name="9" id="anc9"></a><span class="line-modified"> 567     const AtomicString&amp; keyShortcuts = coreObject-&gt;keyShortcutsValue();</span>
 568     if (!keyShortcuts.isEmpty())
 569         attributeSet = addToAtkAttributeSet(attributeSet, &quot;keyshortcuts&quot;, keyShortcuts.string().utf8().data());
 570 
 571     return attributeSet;
 572 }
 573 
 574 static AtkRole atkRole(AccessibilityObject* coreObject)
 575 {
 576     switch (coreObject-&gt;roleValue()) {
 577     case AccessibilityRole::ApplicationAlert:
 578         return ATK_ROLE_ALERT;
 579     case AccessibilityRole::ApplicationAlertDialog:
 580     case AccessibilityRole::ApplicationDialog:
 581         return ATK_ROLE_DIALOG;
 582     case AccessibilityRole::ApplicationStatus:
 583         return ATK_ROLE_STATUSBAR;
 584     case AccessibilityRole::Unknown:
 585         return ATK_ROLE_UNKNOWN;
 586     case AccessibilityRole::Audio:
<a name="10" id="anc10"></a><span class="line-removed"> 587 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 588         return ATK_ROLE_AUDIO;
<a name="11" id="anc11"></a><span class="line-removed"> 589 #endif</span>
 590     case AccessibilityRole::Video:
<a name="12" id="anc12"></a><span class="line-removed"> 591 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 592         return ATK_ROLE_VIDEO;
<a name="13" id="anc13"></a><span class="line-removed"> 593 #endif</span>
<span class="line-removed"> 594         return ATK_ROLE_EMBEDDED;</span>
 595     case AccessibilityRole::Button:
 596         return ATK_ROLE_PUSH_BUTTON;
 597     case AccessibilityRole::Switch:
 598     case AccessibilityRole::ToggleButton:
 599         return ATK_ROLE_TOGGLE_BUTTON;
 600     case AccessibilityRole::RadioButton:
 601         return ATK_ROLE_RADIO_BUTTON;
 602     case AccessibilityRole::CheckBox:
 603         return ATK_ROLE_CHECK_BOX;
 604     case AccessibilityRole::Slider:
 605         return ATK_ROLE_SLIDER;
 606     case AccessibilityRole::TabGroup:
 607     case AccessibilityRole::TabList:
 608         return ATK_ROLE_PAGE_TAB_LIST;
 609     case AccessibilityRole::TextField:
 610     case AccessibilityRole::TextArea:
 611     case AccessibilityRole::SearchField:
 612         return ATK_ROLE_ENTRY;
 613     case AccessibilityRole::StaticText:
<a name="14" id="anc14"></a><span class="line-removed"> 614 #if ATK_CHECK_VERSION(2, 15, 2)</span>
 615         return ATK_ROLE_STATIC;
<a name="15" id="anc15"></a><span class="line-removed"> 616 #else</span>
<span class="line-removed"> 617         return ATK_ROLE_TEXT;</span>
<span class="line-removed"> 618 #endif</span>
 619     case AccessibilityRole::Outline:
 620     case AccessibilityRole::Tree:
 621         return ATK_ROLE_TREE;
 622     case AccessibilityRole::TreeItem:
 623         return ATK_ROLE_TREE_ITEM;
 624     case AccessibilityRole::MenuBar:
 625         return ATK_ROLE_MENU_BAR;
 626     case AccessibilityRole::MenuListPopup:
 627     case AccessibilityRole::Menu:
 628         return ATK_ROLE_MENU;
 629     case AccessibilityRole::MenuListOption:
 630     case AccessibilityRole::MenuItem:
 631     case AccessibilityRole::MenuButton:
 632         return ATK_ROLE_MENU_ITEM;
 633     case AccessibilityRole::MenuItemCheckbox:
 634         return ATK_ROLE_CHECK_MENU_ITEM;
 635     case AccessibilityRole::MenuItemRadio:
 636         return ATK_ROLE_RADIO_MENU_ITEM;
 637     case AccessibilityRole::Column:
 638         // return ATK_ROLE_TABLE_COLUMN_HEADER; // Is this right?
 639         return ATK_ROLE_UNKNOWN; // Matches Mozilla
 640     case AccessibilityRole::Row:
 641         return ATK_ROLE_TABLE_ROW;
 642     case AccessibilityRole::Toolbar:
 643         return ATK_ROLE_TOOL_BAR;
<a name="16" id="anc16"></a>

 644     case AccessibilityRole::BusyIndicator:
<a name="17" id="anc17"></a><span class="line-removed"> 645         return ATK_ROLE_PROGRESS_BAR; // Is this right?</span>
 646     case AccessibilityRole::ProgressIndicator:
<a name="18" id="anc18"></a><span class="line-modified"> 647         return coreObject-&gt;isMeter() ? ATK_ROLE_LEVEL_BAR : ATK_ROLE_PROGRESS_BAR;</span>
 648     case AccessibilityRole::Window:
 649         return ATK_ROLE_WINDOW;
 650     case AccessibilityRole::PopUpButton:
 651         return coreObject-&gt;hasPopup() ? ATK_ROLE_PUSH_BUTTON : ATK_ROLE_COMBO_BOX;
 652     case AccessibilityRole::ComboBox:
 653         return ATK_ROLE_COMBO_BOX;
 654     case AccessibilityRole::SplitGroup:
 655         return ATK_ROLE_SPLIT_PANE;
 656     case AccessibilityRole::Splitter:
 657         return ATK_ROLE_SEPARATOR;
<a name="19" id="anc19"></a><span class="line-removed"> 658     case AccessibilityRole::ColorWell:</span>
 659 #if PLATFORM(GTK)
<a name="20" id="anc20"></a>
 660         // ATK_ROLE_COLOR_CHOOSER is defined as a dialog (i.e. it&#39;s what appears when you push the button).
 661         return ATK_ROLE_PUSH_BUTTON;
 662 #endif
 663     case AccessibilityRole::List:
 664         return ATK_ROLE_LIST;
 665     case AccessibilityRole::ScrollBar:
 666         return ATK_ROLE_SCROLL_BAR;
 667     case AccessibilityRole::ScrollArea:
 668     case AccessibilityRole::TabPanel:
 669         return ATK_ROLE_SCROLL_PANE;
 670     case AccessibilityRole::Grid:
 671     case AccessibilityRole::Table:
 672         return ATK_ROLE_TABLE;
 673     case AccessibilityRole::TreeGrid:
 674         return ATK_ROLE_TREE_TABLE;
 675     case AccessibilityRole::Application:
 676         return ATK_ROLE_APPLICATION;
 677     case AccessibilityRole::ApplicationGroup:
 678     case AccessibilityRole::Feed:
 679     case AccessibilityRole::Figure:
 680     case AccessibilityRole::GraphicsObject:
 681     case AccessibilityRole::Group:
 682     case AccessibilityRole::RadioGroup:
 683     case AccessibilityRole::SVGRoot:
 684         return ATK_ROLE_PANEL;
 685     case AccessibilityRole::RowHeader:
 686         return ATK_ROLE_ROW_HEADER;
 687     case AccessibilityRole::ColumnHeader:
 688         return ATK_ROLE_COLUMN_HEADER;
 689     case AccessibilityRole::Caption:
 690         return ATK_ROLE_CAPTION;
 691     case AccessibilityRole::Cell:
 692     case AccessibilityRole::GridCell:
 693         return coreObject-&gt;inheritsPresentationalRole() ? ATK_ROLE_SECTION : ATK_ROLE_TABLE_CELL;
 694     case AccessibilityRole::Link:
 695     case AccessibilityRole::WebCoreLink:
 696     case AccessibilityRole::ImageMapLink:
 697         return ATK_ROLE_LINK;
 698     case AccessibilityRole::ImageMap:
 699         return ATK_ROLE_IMAGE_MAP;
 700     case AccessibilityRole::GraphicsSymbol:
 701     case AccessibilityRole::Image:
 702         return ATK_ROLE_IMAGE;
 703     case AccessibilityRole::ListMarker:
 704         return ATK_ROLE_TEXT;
 705     case AccessibilityRole::DocumentArticle:
<a name="21" id="anc21"></a><span class="line-removed"> 706 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 707         return ATK_ROLE_ARTICLE;
<a name="22" id="anc22"></a><span class="line-removed"> 708 #endif</span>
 709     case AccessibilityRole::Document:
 710     case AccessibilityRole::GraphicsDocument:
 711         return ATK_ROLE_DOCUMENT_FRAME;
 712     case AccessibilityRole::DocumentNote:
 713         return ATK_ROLE_COMMENT;
 714     case AccessibilityRole::Heading:
 715         return ATK_ROLE_HEADING;
 716     case AccessibilityRole::ListBox:
 717         // https://rawgit.com/w3c/aria/master/core-aam/core-aam.html#role-map-listbox
 718         return coreObject-&gt;isDescendantOfRole(AccessibilityRole::ComboBox) ? ATK_ROLE_MENU : ATK_ROLE_LIST_BOX;
 719     case AccessibilityRole::ListItem:
 720         return coreObject-&gt;inheritsPresentationalRole() ? ATK_ROLE_SECTION : ATK_ROLE_LIST_ITEM;
 721     case AccessibilityRole::ListBoxOption:
 722         return coreObject-&gt;isDescendantOfRole(AccessibilityRole::ComboBox) ? ATK_ROLE_MENU_ITEM : ATK_ROLE_LIST_ITEM;
 723     case AccessibilityRole::Paragraph:
 724         return ATK_ROLE_PARAGRAPH;
 725     case AccessibilityRole::Label:
 726     case AccessibilityRole::Legend:
 727         return ATK_ROLE_LABEL;
 728     case AccessibilityRole::Blockquote:
<a name="23" id="anc23"></a><span class="line-removed"> 729 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 730         return ATK_ROLE_BLOCK_QUOTE;
<a name="24" id="anc24"></a><span class="line-removed"> 731 #endif</span>
<span class="line-removed"> 732     case AccessibilityRole::Footnote:</span>
 733 #if ATK_CHECK_VERSION(2, 25, 2)
<a name="25" id="anc25"></a>
 734         return ATK_ROLE_FOOTNOTE;
 735 #endif
 736     case AccessibilityRole::ApplicationTextGroup:
 737     case AccessibilityRole::Div:
 738     case AccessibilityRole::Pre:
 739     case AccessibilityRole::SVGText:
 740     case AccessibilityRole::TextGroup:
 741         return ATK_ROLE_SECTION;
 742     case AccessibilityRole::Footer:
 743         return ATK_ROLE_FOOTER;
 744     case AccessibilityRole::Form:
<a name="26" id="anc26"></a><span class="line-removed"> 745 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 746         if (coreObject-&gt;ariaRoleAttribute() != AccessibilityRole::Unknown)
 747             return ATK_ROLE_LANDMARK;
<a name="27" id="anc27"></a><span class="line-removed"> 748 #endif</span>
 749         return ATK_ROLE_FORM;
 750     case AccessibilityRole::Canvas:
 751         return ATK_ROLE_CANVAS;
 752     case AccessibilityRole::HorizontalRule:
 753         return ATK_ROLE_SEPARATOR;
 754     case AccessibilityRole::SpinButton:
 755         return ATK_ROLE_SPIN_BUTTON;
 756     case AccessibilityRole::Tab:
 757         return ATK_ROLE_PAGE_TAB;
 758     case AccessibilityRole::UserInterfaceTooltip:
 759         return ATK_ROLE_TOOL_TIP;
 760     case AccessibilityRole::WebArea:
 761         return ATK_ROLE_DOCUMENT_WEB;
 762     case AccessibilityRole::WebApplication:
 763         return ATK_ROLE_EMBEDDED;
<a name="28" id="anc28"></a><span class="line-removed"> 764 #if ATK_CHECK_VERSION(2, 11, 3)</span>
 765     case AccessibilityRole::ApplicationLog:
 766         return ATK_ROLE_LOG;
 767     case AccessibilityRole::ApplicationMarquee:
 768         return ATK_ROLE_MARQUEE;
 769     case AccessibilityRole::ApplicationTimer:
 770         return ATK_ROLE_TIMER;
 771     case AccessibilityRole::Definition:
 772         return ATK_ROLE_DEFINITION;
 773     case AccessibilityRole::DocumentMath:
 774         return ATK_ROLE_MATH;
 775     case AccessibilityRole::MathElement:
 776         if (coreObject-&gt;isMathRow())
 777             return ATK_ROLE_PANEL;
 778         if (coreObject-&gt;isMathTable())
 779             return ATK_ROLE_TABLE;
 780         if (coreObject-&gt;isMathTableRow())
 781             return ATK_ROLE_TABLE_ROW;
 782         if (coreObject-&gt;isMathTableCell())
 783             return ATK_ROLE_TABLE_CELL;
 784         if (coreObject-&gt;isMathSubscriptSuperscript() || coreObject-&gt;isMathMultiscript())
 785             return ATK_ROLE_SECTION;
<a name="29" id="anc29"></a><span class="line-removed"> 786 #if ATK_CHECK_VERSION(2, 15, 4)</span>
 787         if (coreObject-&gt;isMathFraction())
 788             return ATK_ROLE_MATH_FRACTION;
 789         if (coreObject-&gt;isMathSquareRoot() || coreObject-&gt;isMathRoot())
 790             return ATK_ROLE_MATH_ROOT;
 791         if (coreObject-&gt;isMathScriptObject(AccessibilityMathScriptObjectType::Subscript)
 792             || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSubscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSubscript))
 793             return ATK_ROLE_SUBSCRIPT;
 794         if (coreObject-&gt;isMathScriptObject(AccessibilityMathScriptObjectType::Superscript)
 795             || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PreSuperscript) || coreObject-&gt;isMathMultiscriptObject(AccessibilityMathMultiscriptObjectType::PostSuperscript))
 796             return ATK_ROLE_SUPERSCRIPT;
<a name="30" id="anc30"></a><span class="line-removed"> 797 #endif</span>
<span class="line-removed"> 798 #if ATK_CHECK_VERSION(2, 15, 2)</span>
 799         if (coreObject-&gt;isMathToken())
 800             return ATK_ROLE_STATIC;
<a name="31" id="anc31"></a><span class="line-removed"> 801 #endif</span>
 802         return ATK_ROLE_UNKNOWN;
 803     case AccessibilityRole::LandmarkBanner:
 804     case AccessibilityRole::LandmarkComplementary:
 805     case AccessibilityRole::LandmarkContentInfo:
 806     case AccessibilityRole::LandmarkDocRegion:
 807     case AccessibilityRole::LandmarkMain:
 808     case AccessibilityRole::LandmarkNavigation:
 809     case AccessibilityRole::LandmarkRegion:
 810     case AccessibilityRole::LandmarkSearch:
 811         return ATK_ROLE_LANDMARK;
<a name="32" id="anc32"></a><span class="line-removed"> 812 #endif</span>
<span class="line-removed"> 813 #if ATK_CHECK_VERSION(2, 11, 4)</span>
 814     case AccessibilityRole::DescriptionList:
 815         return ATK_ROLE_DESCRIPTION_LIST;
 816     case AccessibilityRole::Term:
 817     case AccessibilityRole::DescriptionListTerm:
 818         return ATK_ROLE_DESCRIPTION_TERM;
 819     case AccessibilityRole::DescriptionListDetail:
 820         return ATK_ROLE_DESCRIPTION_VALUE;
<a name="33" id="anc33"></a>




 821 #endif
<a name="34" id="anc34"></a><span class="line-modified"> 822     case AccessibilityRole::Inline:</span>
<span class="line-modified"> 823 #if ATK_CHECK_VERSION(2, 15, 4)</span>
<span class="line-modified"> 824         if (coreObject-&gt;isSubscriptStyleGroup())</span>
<span class="line-modified"> 825             return ATK_ROLE_SUBSCRIPT;</span>
<span class="line-removed"> 826         if (coreObject-&gt;isSuperscriptStyleGroup())</span>
<span class="line-removed"> 827             return ATK_ROLE_SUPERSCRIPT;</span>
<span class="line-removed"> 828 #endif</span>
<span class="line-removed"> 829 #if ATK_CHECK_VERSION(2, 15, 2)</span>
 830         return ATK_ROLE_STATIC;
<a name="35" id="anc35"></a>





 831     case AccessibilityRole::SVGTextPath:
 832     case AccessibilityRole::SVGTSpan:
 833     case AccessibilityRole::Time:
 834         return ATK_ROLE_STATIC;
<a name="36" id="anc36"></a><span class="line-removed"> 835 #endif</span>
 836     default:
 837         return ATK_ROLE_UNKNOWN;
 838     }
 839 }
 840 
 841 static AtkRole webkitAccessibleGetRole(AtkObject* object)
 842 {
 843     // ATK_ROLE_UNKNOWN should only be applied in cases where there is a valid
 844     // WebCore accessible object for which the platform role mapping is unknown.
 845     auto* accessible = WEBKIT_ACCESSIBLE(object);
 846     returnValIfWebKitAccessibleIsInvalid(accessible, ATK_ROLE_INVALID);
 847 
 848     // Note: Why doesn&#39;t WebCore have a password field for this
 849     if (accessible-&gt;priv-&gt;object-&gt;isPasswordField())
 850         return ATK_ROLE_PASSWORD_TEXT;
 851 
 852     return atkRole(accessible-&gt;priv-&gt;object);
 853 }
 854 
 855 static bool isTextWithCaret(AccessibilityObject* coreObject)
 856 {
 857     if (!coreObject || !coreObject-&gt;isAccessibilityRenderObject())
 858         return false;
 859 
 860     Document* document = coreObject-&gt;document();
 861     if (!document)
 862         return false;
 863 
 864     Frame* frame = document-&gt;frame();
 865     if (!frame)
 866         return false;
 867 
 868     if (!frame-&gt;settings().caretBrowsingEnabled())
 869         return false;
 870 
 871     // Check text objects and paragraphs only.
 872     auto* axObject = coreObject-&gt;wrapper();
 873     AtkRole role = axObject ? atk_object_get_role(ATK_OBJECT(axObject)) : ATK_ROLE_INVALID;
 874     if (role != ATK_ROLE_TEXT &amp;&amp; role != ATK_ROLE_PARAGRAPH)
 875         return false;
 876 
 877     // Finally, check whether the caret is set in the current object.
 878     VisibleSelection selection = coreObject-&gt;selection();
 879     if (!selection.isCaret())
 880         return false;
 881 
 882     return selectionBelongsToObject(coreObject, selection);
 883 }
 884 
 885 static void setAtkStateSetFromCoreObject(AccessibilityObject* coreObject, AtkStateSet* stateSet)
 886 {
 887     AccessibilityObject* parent = coreObject-&gt;parentObject();
 888     bool isListBoxOption = parent &amp;&amp; parent-&gt;isListBox();
 889 
 890     // Please keep the state list in alphabetical order
 891     if ((isListBoxOption &amp;&amp; coreObject-&gt;isSelectedOptionActive())
 892         || coreObject-&gt;currentState() != AccessibilityCurrentState::False)
 893         atk_state_set_add_state(stateSet, ATK_STATE_ACTIVE);
 894 
 895     if (coreObject-&gt;isBusy())
 896         atk_state_set_add_state(stateSet, ATK_STATE_BUSY);
 897 
<a name="37" id="anc37"></a><span class="line-removed"> 898 #if ATK_CHECK_VERSION(2,11,2)</span>
 899     if (coreObject-&gt;supportsChecked() &amp;&amp; coreObject-&gt;canSetValueAttribute())
 900         atk_state_set_add_state(stateSet, ATK_STATE_CHECKABLE);
<a name="38" id="anc38"></a><span class="line-removed"> 901 #endif</span>
 902 
 903     if (coreObject-&gt;isChecked())
 904         atk_state_set_add_state(stateSet, ATK_STATE_CHECKED);
 905 
 906     if ((coreObject-&gt;isTextControl() || coreObject-&gt;isNonNativeTextControl()) &amp;&amp; coreObject-&gt;canSetValueAttribute())
 907         atk_state_set_add_state(stateSet, ATK_STATE_EDITABLE);
 908 
 909     // FIXME: Put both ENABLED and SENSITIVE together here for now
 910     if (coreObject-&gt;isEnabled()) {
 911         atk_state_set_add_state(stateSet, ATK_STATE_ENABLED);
 912         atk_state_set_add_state(stateSet, ATK_STATE_SENSITIVE);
 913     }
 914 
 915     if (coreObject-&gt;canSetExpandedAttribute())
 916         atk_state_set_add_state(stateSet, ATK_STATE_EXPANDABLE);
 917 
 918     if (coreObject-&gt;isExpanded())
 919         atk_state_set_add_state(stateSet, ATK_STATE_EXPANDED);
 920 
 921     if (coreObject-&gt;canSetFocusAttribute())
 922         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 923 
 924     // According to the Core AAM, if the element which is focused has a valid aria-activedescendant,
 925     // we should not expose the focused state on the element which is actually focused, but instead
 926     // on its active descendant.
 927     if ((coreObject-&gt;isFocused() &amp;&amp; !coreObject-&gt;activeDescendant()) || isTextWithCaret(coreObject))
 928         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 929     else if (coreObject-&gt;isActiveDescendantOfFocusedContainer()) {
 930         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 931         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 932     }
 933 
 934     if (coreObject-&gt;orientation() == AccessibilityOrientation::Horizontal)
 935         atk_state_set_add_state(stateSet, ATK_STATE_HORIZONTAL);
 936     else if (coreObject-&gt;orientation() == AccessibilityOrientation::Vertical)
 937         atk_state_set_add_state(stateSet, ATK_STATE_VERTICAL);
 938 
 939     if (coreObject-&gt;hasPopup())
 940         atk_state_set_add_state(stateSet, ATK_STATE_HAS_POPUP);
 941 
 942     if (coreObject-&gt;isIndeterminate())
 943         atk_state_set_add_state(stateSet, ATK_STATE_INDETERMINATE);
 944     else if (coreObject-&gt;isCheckboxOrRadio() || coreObject-&gt;isMenuItem() || coreObject-&gt;isToggleButton()) {
 945         if (coreObject-&gt;checkboxOrRadioValue() == AccessibilityButtonState::Mixed)
 946             atk_state_set_add_state(stateSet, ATK_STATE_INDETERMINATE);
 947     }
 948 
 949     if (coreObject-&gt;isModalNode())
 950         atk_state_set_add_state(stateSet, ATK_STATE_MODAL);
 951 
 952     if (coreObject-&gt;invalidStatus() != &quot;false&quot;)
 953         atk_state_set_add_state(stateSet, ATK_STATE_INVALID_ENTRY);
 954 
 955     if (coreObject-&gt;isMultiSelectable())
 956         atk_state_set_add_state(stateSet, ATK_STATE_MULTISELECTABLE);
 957 
 958     // TODO: ATK_STATE_OPAQUE
 959 
 960     if (coreObject-&gt;isPressed())
 961         atk_state_set_add_state(stateSet, ATK_STATE_PRESSED);
 962 
<a name="39" id="anc39"></a><span class="line-removed"> 963 #if ATK_CHECK_VERSION(2,15,3)</span>
 964     if (!coreObject-&gt;canSetValueAttribute() &amp;&amp; (coreObject-&gt;supportsReadOnly()))
 965         atk_state_set_add_state(stateSet, ATK_STATE_READ_ONLY);
<a name="40" id="anc40"></a><span class="line-removed"> 966 #endif</span>
 967 
 968     if (coreObject-&gt;isRequired())
 969         atk_state_set_add_state(stateSet, ATK_STATE_REQUIRED);
 970 
 971     // TODO: ATK_STATE_SELECTABLE_TEXT
 972 
 973     if (coreObject-&gt;canSetSelectedAttribute()) {
 974         atk_state_set_add_state(stateSet, ATK_STATE_SELECTABLE);
 975         // Items in focusable lists have both STATE_SELECT{ABLE,ED}
 976         // and STATE_FOCUS{ABLE,ED}. We&#39;ll fake the latter based on
 977         // the former.
 978         if (isListBoxOption)
 979             atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
 980     }
 981 
 982     if (coreObject-&gt;isSelected()) {
 983         atk_state_set_add_state(stateSet, ATK_STATE_SELECTED);
 984         // Items in focusable lists have both STATE_SELECT{ABLE,ED}
 985         // and STATE_FOCUS{ABLE,ED}. We&#39;ll fake the latter based on the
 986         // former.
 987         if (isListBoxOption)
 988             atk_state_set_add_state(stateSet, ATK_STATE_FOCUSED);
 989     }
 990 
 991     // FIXME: Group both SHOWING and VISIBLE here for now
 992     // Not sure how to handle this in WebKit, see bug
 993     // http://bugzilla.gnome.org/show_bug.cgi?id=509650 for other
 994     // issues with SHOWING vs VISIBLE.
 995     if (!coreObject-&gt;isOffScreen()) {
 996         atk_state_set_add_state(stateSet, ATK_STATE_SHOWING);
 997         atk_state_set_add_state(stateSet, ATK_STATE_VISIBLE);
 998     }
 999 
1000     // Mutually exclusive, so we group these two
1001     if (coreObject-&gt;roleValue() == AccessibilityRole::TextArea || coreObject-&gt;ariaIsMultiline())
1002         atk_state_set_add_state(stateSet, ATK_STATE_MULTI_LINE);
1003     else if (coreObject-&gt;roleValue() == AccessibilityRole::TextField || coreObject-&gt;roleValue() == AccessibilityRole::SearchField)
1004         atk_state_set_add_state(stateSet, ATK_STATE_SINGLE_LINE);
1005 
1006     // TODO: ATK_STATE_SENSITIVE
1007 
1008     if (coreObject-&gt;supportsAutoComplete() &amp;&amp; coreObject-&gt;autoCompleteValue() != &quot;none&quot;)
1009         atk_state_set_add_state(stateSet, ATK_STATE_SUPPORTS_AUTOCOMPLETION);
1010 
1011     if (coreObject-&gt;isVisited())
1012         atk_state_set_add_state(stateSet, ATK_STATE_VISITED);
1013 }
1014 
1015 static AtkStateSet* webkitAccessibleRefStateSet(AtkObject* object)
1016 {
1017     auto* accessible = WEBKIT_ACCESSIBLE(object);
1018     AtkStateSet* stateSet = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;ref_state_set(object);
1019 
1020     // Make sure the layout is updated to really know whether the object
1021     // is defunct or not, so we can return the proper state.
1022     accessible-&gt;priv-&gt;object-&gt;updateBackingStore();
1023 
1024     if (accessible-&gt;priv-&gt;object == fallbackObject()) {
1025         atk_state_set_add_state(stateSet, ATK_STATE_DEFUNCT);
1026         return stateSet;
1027     }
1028 
1029     // Text objects must be focusable.
1030     AtkRole role = atk_object_get_role(object);
1031     if (role == ATK_ROLE_TEXT || role == ATK_ROLE_PARAGRAPH)
1032         atk_state_set_add_state(stateSet, ATK_STATE_FOCUSABLE);
1033 
1034     setAtkStateSetFromCoreObject(accessible-&gt;priv-&gt;object, stateSet);
1035     return stateSet;
1036 }
1037 
1038 static AtkRelationSet* webkitAccessibleRefRelationSet(AtkObject* object)
1039 {
1040     auto* accessible = WEBKIT_ACCESSIBLE(object);
1041     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
1042 
1043     AtkRelationSet* relationSet = ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;ref_relation_set(object);
1044     setAtkRelationSetFromCoreObject(accessible-&gt;priv-&gt;object, relationSet);
1045     return relationSet;
1046 }
1047 
1048 static void webkitAccessibleInit(AtkObject* object, gpointer data)
1049 {
1050     if (ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;initialize)
1051         ATK_OBJECT_CLASS(webkit_accessible_parent_class)-&gt;initialize(object, data);
1052 
1053     WebKitAccessible* accessible = WEBKIT_ACCESSIBLE(object);
1054     accessible-&gt;priv-&gt;object = reinterpret_cast&lt;AccessibilityObject*&gt;(data);
1055 }
1056 
1057 static const gchar* webkitAccessibleGetObjectLocale(AtkObject* object)
1058 {
1059     auto* accessible = WEBKIT_ACCESSIBLE(object);
1060     returnValIfWebKitAccessibleIsInvalid(accessible, nullptr);
1061 
1062     if (ATK_IS_DOCUMENT(object)) {
1063         // TODO: Should we fall back on lang xml:lang when the following comes up empty?
1064         String language = accessible-&gt;priv-&gt;object-&gt;language();
1065         if (!language.isEmpty())
1066             return webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedDocumentLocale, language.utf8());
1067 
1068     } else if (ATK_IS_TEXT(object)) {
1069         const gchar* locale = nullptr;
1070 
1071         AtkAttributeSet* textAttributes = atk_text_get_default_attributes(ATK_TEXT(object));
1072         for (auto* attributes = textAttributes; attributes; attributes = attributes-&gt;next) {
1073             auto* atkAttribute = static_cast&lt;AtkAttribute*&gt;(attributes-&gt;data);
1074             if (!strcmp(atkAttribute-&gt;name, atk_text_attribute_get_name(ATK_TEXT_ATTR_LANGUAGE))) {
1075                 locale = webkitAccessibleCacheAndReturnAtkProperty(accessible, AtkCachedDocumentLocale, atkAttribute-&gt;value);
1076                 break;
1077             }
1078         }
1079         atk_attribute_set_free(textAttributes);
1080 
1081         return locale;
1082     }
1083 
1084     return nullptr;
1085 }
1086 
1087 static void webkit_accessible_class_init(WebKitAccessibleClass* klass)
1088 {
1089     auto* atkObjectClass = ATK_OBJECT_CLASS(klass);
1090     atkObjectClass-&gt;initialize = webkitAccessibleInit;
1091     atkObjectClass-&gt;get_name = webkitAccessibleGetName;
1092     atkObjectClass-&gt;get_description = webkitAccessibleGetDescription;
1093     atkObjectClass-&gt;get_parent = webkitAccessibleGetParent;
1094     atkObjectClass-&gt;get_n_children = webkitAccessibleGetNChildren;
1095     atkObjectClass-&gt;ref_child = webkitAccessibleRefChild;
1096     atkObjectClass-&gt;get_role = webkitAccessibleGetRole;
1097     atkObjectClass-&gt;ref_state_set = webkitAccessibleRefStateSet;
1098     atkObjectClass-&gt;get_index_in_parent = webkitAccessibleGetIndexInParent;
1099     atkObjectClass-&gt;get_attributes = webkitAccessibleGetAttributes;
1100     atkObjectClass-&gt;ref_relation_set = webkitAccessibleRefRelationSet;
1101     atkObjectClass-&gt;get_object_locale = webkitAccessibleGetObjectLocale;
1102 }
1103 
1104 static const GInterfaceInfo atkInterfacesInitFunctions[] = {
1105     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleActionInterfaceInit)), nullptr, nullptr},
1106     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleSelectionInterfaceInit)), nullptr, nullptr},
1107     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleEditableTextInterfaceInit)), nullptr, nullptr},
1108     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTextInterfaceInit)), nullptr, nullptr},
1109     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleComponentInterfaceInit)), nullptr, nullptr},
1110     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleImageInterfaceInit)), nullptr, nullptr},
1111     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTableInterfaceInit)), nullptr, nullptr},
<a name="41" id="anc41"></a><span class="line-removed">1112 #if ATK_CHECK_VERSION(2,11,90)</span>
1113     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleTableCellInterfaceInit)), nullptr, nullptr},
<a name="42" id="anc42"></a><span class="line-removed">1114 #endif</span>
1115     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleHypertextInterfaceInit)), nullptr, nullptr},
1116     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleHyperlinkImplInterfaceInit)), nullptr, nullptr},
1117     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleDocumentInterfaceInit)), nullptr, nullptr},
1118     {reinterpret_cast&lt;GInterfaceInitFunc&gt;(reinterpret_cast&lt;GCallback&gt;(webkitAccessibleValueInterfaceInit)), nullptr, nullptr}
1119 };
1120 
1121 enum WAIType {
1122     WAIAction,
1123     WAISelection,
1124     WAIEditableText,
1125     WAIText,
1126     WAIComponent,
1127     WAIImage,
1128     WAITable,
<a name="43" id="anc43"></a><span class="line-removed">1129 #if ATK_CHECK_VERSION(2,11,90)</span>
1130     WAITableCell,
<a name="44" id="anc44"></a><span class="line-removed">1131 #endif</span>
1132     WAIHypertext,
1133     WAIHyperlink,
1134     WAIDocument,
1135     WAIValue,
1136 };
1137 
1138 static GType atkInterfaceTypeFromWAIType(WAIType type)
1139 {
1140     switch (type) {
1141     case WAIAction:
1142         return ATK_TYPE_ACTION;
1143     case WAISelection:
1144         return ATK_TYPE_SELECTION;
1145     case WAIEditableText:
1146         return ATK_TYPE_EDITABLE_TEXT;
1147     case WAIText:
1148         return ATK_TYPE_TEXT;
1149     case WAIComponent:
1150         return ATK_TYPE_COMPONENT;
1151     case WAIImage:
1152         return ATK_TYPE_IMAGE;
1153     case WAITable:
1154         return ATK_TYPE_TABLE;
<a name="45" id="anc45"></a><span class="line-removed">1155 #if ATK_CHECK_VERSION(2,11,90)</span>
1156     case WAITableCell:
1157         return ATK_TYPE_TABLE_CELL;
<a name="46" id="anc46"></a><span class="line-removed">1158 #endif</span>
1159     case WAIHypertext:
1160         return ATK_TYPE_HYPERTEXT;
1161     case WAIHyperlink:
1162         return ATK_TYPE_HYPERLINK_IMPL;
1163     case WAIDocument:
1164         return ATK_TYPE_DOCUMENT;
1165     case WAIValue:
1166         return ATK_TYPE_VALUE;
1167     }
1168 
1169     return G_TYPE_INVALID;
1170 }
1171 
1172 static bool roleIsTextType(AccessibilityRole role)
1173 {
1174     return role == AccessibilityRole::Paragraph
1175         || role == AccessibilityRole::Heading
1176         || role == AccessibilityRole::Div
1177         || role == AccessibilityRole::Cell
1178         || role == AccessibilityRole::Link
1179         || role == AccessibilityRole::WebCoreLink
1180         || role == AccessibilityRole::ListItem
1181         || role == AccessibilityRole::Pre
1182         || role == AccessibilityRole::GridCell
1183         || role == AccessibilityRole::TextGroup
1184         || role == AccessibilityRole::ApplicationTextGroup
1185         || role == AccessibilityRole::ApplicationGroup;
1186 }
1187 
1188 static guint16 interfaceMaskFromObject(AccessibilityObject* coreObject)
1189 {
1190     guint16 interfaceMask = 0;
1191 
1192     // Component interface is always supported
1193     interfaceMask |= 1 &lt;&lt; WAIComponent;
1194 
1195     AccessibilityRole role = coreObject-&gt;roleValue();
1196 
1197     // Action
1198     // As the implementation of the AtkAction interface is a very
1199     // basic one (just relays in executing the default action for each
1200     // object, and only supports having one action per object), it is
1201     // better just to implement this interface for every instance of
1202     // the WebKitAccessible class and let WebCore decide what to do.
1203     interfaceMask |= 1 &lt;&lt; WAIAction;
1204 
1205     // Selection
1206     if (coreObject-&gt;canHaveSelectedChildren() || coreObject-&gt;isMenuList())
1207         interfaceMask |= 1 &lt;&lt; WAISelection;
1208 
1209     // Get renderer if available.
1210     RenderObject* renderer = nullptr;
1211     if (coreObject-&gt;isAccessibilityRenderObject())
1212         renderer = coreObject-&gt;renderer();
1213 
1214     // Hyperlink (links and embedded objects).
1215     if (coreObject-&gt;isLink() || (renderer &amp;&amp; renderer-&gt;isReplaced()))
1216         interfaceMask |= 1 &lt;&lt; WAIHyperlink;
1217 
1218     // Text, Editable Text &amp; Hypertext
1219     if (role == AccessibilityRole::StaticText || coreObject-&gt;isMenuListOption())
1220         interfaceMask |= 1 &lt;&lt; WAIText;
1221     else if (coreObject-&gt;isTextControl() || coreObject-&gt;isNonNativeTextControl()) {
1222         interfaceMask |= 1 &lt;&lt; WAIText;
1223         if (coreObject-&gt;canSetValueAttribute())
1224             interfaceMask |= 1 &lt;&lt; WAIEditableText;
1225     } else if (!coreObject-&gt;isWebArea()) {
1226         if (role != AccessibilityRole::Table) {
1227             interfaceMask |= 1 &lt;&lt; WAIHypertext;
1228             if ((renderer &amp;&amp; renderer-&gt;childrenInline()) || roleIsTextType(role) || coreObject-&gt;isMathToken())
1229                 interfaceMask |= 1 &lt;&lt; WAIText;
1230         }
1231 
1232         // Add the TEXT interface for list items whose
1233         // first accessible child has a text renderer
1234         if (role == AccessibilityRole::ListItem) {
1235             const auto&amp; children = coreObject-&gt;children();
1236             if (!children.isEmpty())
1237                 interfaceMask |= interfaceMaskFromObject(children[0].get());
1238         }
1239     }
1240 
1241     // Image
1242     if (coreObject-&gt;isImage())
1243         interfaceMask |= 1 &lt;&lt; WAIImage;
1244 
1245     // Table
1246     if (coreObject-&gt;isTable())
1247         interfaceMask |= 1 &lt;&lt; WAITable;
1248 
<a name="47" id="anc47"></a><span class="line-removed">1249 #if ATK_CHECK_VERSION(2,11,90)</span>
1250     if (role == AccessibilityRole::Cell || role == AccessibilityRole::GridCell || role == AccessibilityRole::ColumnHeader || role == AccessibilityRole::RowHeader)
1251         interfaceMask |= 1 &lt;&lt; WAITableCell;
<a name="48" id="anc48"></a><span class="line-removed">1252 #endif</span>
1253 
1254     // Document
1255     if (role == AccessibilityRole::WebArea)
1256         interfaceMask |= 1 &lt;&lt; WAIDocument;
1257 
1258     // Value
1259     if (coreObject-&gt;supportsRangeValue())
1260         interfaceMask |= 1 &lt;&lt; WAIValue;
1261 
1262 #if ENABLE(INPUT_TYPE_COLOR)
1263     // Color type.
1264     if (role == AccessibilityRole::ColorWell)
1265         interfaceMask |= 1 &lt;&lt; WAIText;
1266 #endif
1267 
1268     return interfaceMask;
1269 }
1270 
1271 static const char* uniqueAccessibilityTypeName(guint16 interfaceMask)
1272 {
1273 #define WAI_TYPE_NAME_LEN (30) // Enough for prefix + 5 hex characters (max).
1274     static char name[WAI_TYPE_NAME_LEN + 1];
1275 
1276     g_sprintf(name, &quot;WAIType%x&quot;, interfaceMask);
1277     name[WAI_TYPE_NAME_LEN] = &#39;\0&#39;;
1278 
1279     return name;
1280 }
1281 
1282 static GType accessibilityTypeFromObject(AccessibilityObject* coreObject)
1283 {
1284     static const GTypeInfo typeInfo = {
1285         sizeof(WebKitAccessibleClass),
1286         nullptr, // GBaseInitFunc
1287         nullptr, // GBaseFinalizeFunc
1288         nullptr, // GClassInitFunc
1289         nullptr, // GClassFinalizeFunc
1290         nullptr, // class data
1291         sizeof(WebKitAccessible), // instance size
1292         0, // nb preallocs
1293         nullptr, // GInstanceInitFunc
1294         nullptr // value table
1295     };
1296 
1297     guint16 interfaceMask = interfaceMaskFromObject(coreObject);
1298     const char* atkTypeName = uniqueAccessibilityTypeName(interfaceMask);
1299     if (GType type = g_type_from_name(atkTypeName))
1300         return type;
1301 
1302     GType type = g_type_register_static(WEBKIT_TYPE_ACCESSIBLE, atkTypeName, &amp;typeInfo, static_cast&lt;GTypeFlags&gt;(0));
1303     for (unsigned i = 0; i &lt; G_N_ELEMENTS(atkInterfacesInitFunctions); ++i) {
1304         if (interfaceMask &amp; (1 &lt;&lt; i)) {
1305             g_type_add_interface_static(type,
1306                 atkInterfaceTypeFromWAIType(static_cast&lt;WAIType&gt;(i)),
1307                 &amp;atkInterfacesInitFunctions[i]);
1308         }
1309     }
1310 
1311     return type;
1312 }
1313 
1314 WebKitAccessible* webkitAccessibleNew(AccessibilityObject* coreObject)
1315 {
1316     auto* object = ATK_OBJECT(g_object_new(accessibilityTypeFromObject(coreObject), nullptr));
1317     atk_object_initialize(object, coreObject);
1318     return WEBKIT_ACCESSIBLE(object);
1319 }
1320 
1321 AccessibilityObject&amp; webkitAccessibleGetAccessibilityObject(WebKitAccessible* accessible)
1322 {
1323     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1324     return *accessible-&gt;priv-&gt;object;
1325 }
1326 
1327 void webkitAccessibleDetach(WebKitAccessible* accessible)
1328 {
1329     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1330     ASSERT(accessible-&gt;priv-&gt;object != fallbackObject());
1331 
1332     if (accessible-&gt;priv-&gt;object-&gt;roleValue() == AccessibilityRole::WebArea)
1333         atk_object_notify_state_change(ATK_OBJECT(accessible), ATK_STATE_DEFUNCT, TRUE);
1334 
1335     // We replace the WebCore AccessibilityObject with a fallback object that
1336     // provides default implementations to avoid repetitive null-checking after
1337     // detachment.
1338     accessible-&gt;priv-&gt;object = fallbackObject();
1339 }
1340 
1341 bool webkitAccessibleIsDetached(WebKitAccessible* accessible)
1342 {
1343     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1344     return accessible-&gt;priv-&gt;object == fallbackObject();
1345 }
1346 
1347 const char* webkitAccessibleCacheAndReturnAtkProperty(WebKitAccessible* accessible, AtkCachedProperty property, CString&amp;&amp; value)
1348 {
1349     ASSERT(WEBKIT_IS_ACCESSIBLE(accessible));
1350 
1351     WebKitAccessiblePrivate* priv = accessible-&gt;priv;
1352     CString* propertyPtr = nullptr;
1353 
1354     switch (property) {
1355     case AtkCachedAccessibleName:
1356         propertyPtr = &amp;priv-&gt;accessibleName;
1357         break;
1358     case AtkCachedAccessibleDescription:
1359         propertyPtr = &amp;priv-&gt;accessibleDescription;
1360         break;
1361     case AtkCachedActionName:
1362         propertyPtr = &amp;priv-&gt;actionName;
1363         break;
1364     case AtkCachedActionKeyBinding:
1365         propertyPtr = &amp;priv-&gt;actionKeyBinding;
1366         break;
1367     case AtkCachedDocumentLocale:
1368         propertyPtr = &amp;priv-&gt;documentLocale;
1369         break;
1370     case AtkCachedDocumentType:
1371         propertyPtr = &amp;priv-&gt;documentType;
1372         break;
1373     case AtkCachedDocumentEncoding:
1374         propertyPtr = &amp;priv-&gt;documentEncoding;
1375         break;
1376     case AtkCachedDocumentURI:
1377         propertyPtr = &amp;priv-&gt;documentURI;
1378         break;
1379     case AtkCachedImageDescription:
1380         propertyPtr = &amp;priv-&gt;imageDescription;
1381         break;
1382     default:
1383         ASSERT_NOT_REACHED();
1384     }
1385 
1386     // Don&#39;t invalidate old memory if not stricly needed, since other
1387     // callers might be still holding on to it.
1388     if (*propertyPtr != value)
1389         *propertyPtr = WTFMove(value);
1390 
1391     return (*propertyPtr).data();
1392 }
1393 
<a name="49" id="anc49"></a><span class="line-modified">1394 #endif // HAVE(ACCESSIBILITY)</span>
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>