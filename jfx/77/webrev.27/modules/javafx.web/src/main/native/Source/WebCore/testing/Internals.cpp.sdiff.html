<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InternalSettings.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Internals.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ActiveDOMCallbackMicrotask.h&quot;
  32 #include &quot;ActivityState.h&quot;
  33 #include &quot;AnimationTimeline.h&quot;
  34 #include &quot;ApplicationCacheStorage.h&quot;
  35 #include &quot;AudioSession.h&quot;
  36 #include &quot;Autofill.h&quot;
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSSupportsRule.h&quot;
  44 #include &quot;CacheStorageConnection.h&quot;
  45 #include &quot;CacheStorageProvider.h&quot;
  46 #include &quot;CachedImage.h&quot;
  47 #include &quot;CachedResourceLoader.h&quot;
  48 #include &quot;CertificateInfo.h&quot;
  49 #include &quot;Chrome.h&quot;

  50 #include &quot;ClientOrigin.h&quot;
  51 #include &quot;ComposedTreeIterator.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;Cursor.h&quot;

  54 #include &quot;DOMRect.h&quot;
  55 #include &quot;DOMRectList.h&quot;
  56 #include &quot;DOMStringList.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DeprecatedGlobalSettings.h&quot;

  59 #include &quot;DisabledAdaptations.h&quot;
  60 #include &quot;DisplayList.h&quot;
  61 #include &quot;Document.h&quot;
  62 #include &quot;DocumentLoader.h&quot;
  63 #include &quot;DocumentMarkerController.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;Editor.h&quot;
  66 #include &quot;Element.h&quot;
  67 #include &quot;EventHandler.h&quot;


  68 #include &quot;ExtendableEvent.h&quot;
  69 #include &quot;ExtensionStyleSheets.h&quot;
  70 #include &quot;FetchResponse.h&quot;
  71 #include &quot;File.h&quot;
  72 #include &quot;FontCache.h&quot;
  73 #include &quot;FormController.h&quot;
  74 #include &quot;Frame.h&quot;
  75 #include &quot;FrameLoader.h&quot;
  76 #include &quot;FrameView.h&quot;

  77 #include &quot;GCObservation.h&quot;
  78 #include &quot;GridPosition.h&quot;
  79 #include &quot;HEVCUtilities.h&quot;
  80 #include &quot;HTMLAnchorElement.h&quot;
  81 #include &quot;HTMLCanvasElement.h&quot;
  82 #include &quot;HTMLIFrameElement.h&quot;
  83 #include &quot;HTMLImageElement.h&quot;
  84 #include &quot;HTMLInputElement.h&quot;
  85 #include &quot;HTMLLinkElement.h&quot;
  86 #include &quot;HTMLNames.h&quot;
  87 #include &quot;HTMLPictureElement.h&quot;
  88 #include &quot;HTMLPlugInElement.h&quot;
  89 #include &quot;HTMLPreloadScanner.h&quot;
  90 #include &quot;HTMLSelectElement.h&quot;
  91 #include &quot;HTMLTextAreaElement.h&quot;
  92 #include &quot;HTMLVideoElement.h&quot;
  93 #include &quot;HistoryController.h&quot;
  94 #include &quot;HistoryItem.h&quot;
  95 #include &quot;HitTestResult.h&quot;
<span class="line-removed">  96 #include &quot;IDBRequest.h&quot;</span>
<span class="line-removed">  97 #include &quot;IDBTransaction.h&quot;</span>
  98 #include &quot;InspectorClient.h&quot;
  99 #include &quot;InspectorController.h&quot;
 100 #include &quot;InspectorFrontendClientLocal.h&quot;
 101 #include &quot;InspectorOverlay.h&quot;
 102 #include &quot;InstrumentingAgents.h&quot;
 103 #include &quot;IntRect.h&quot;
 104 #include &quot;InternalSettings.h&quot;
 105 #include &quot;JSImageData.h&quot;
 106 #include &quot;LibWebRTCProvider.h&quot;
 107 #include &quot;LoaderStrategy.h&quot;
 108 #include &quot;MallocStatistics.h&quot;

 109 #include &quot;MediaEngineConfigurationFactory.h&quot;
 110 #include &quot;MediaPlayer.h&quot;
 111 #include &quot;MediaProducer.h&quot;
 112 #include &quot;MediaResourceLoader.h&quot;
 113 #include &quot;MediaStreamTrack.h&quot;
 114 #include &quot;MemoryCache.h&quot;
 115 #include &quot;MemoryInfo.h&quot;
 116 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 117 #include &quot;MockPageOverlay.h&quot;
 118 #include &quot;MockPageOverlayClient.h&quot;

 119 #include &quot;NetworkLoadInformation.h&quot;
 120 #include &quot;Page.h&quot;
 121 #include &quot;PageCache.h&quot;
 122 #include &quot;PageOverlay.h&quot;
 123 #include &quot;PathUtilities.h&quot;
 124 #include &quot;PlatformKeyboardEvent.h&quot;
 125 #include &quot;PlatformMediaSessionManager.h&quot;
 126 #include &quot;PlatformScreen.h&quot;
 127 #include &quot;PlatformStrategies.h&quot;
 128 #include &quot;PluginData.h&quot;
 129 #include &quot;PrintContext.h&quot;
 130 #include &quot;PseudoElement.h&quot;
 131 #include &quot;Range.h&quot;
 132 #include &quot;ReadableStream.h&quot;
 133 #include &quot;RenderEmbeddedObject.h&quot;
 134 #include &quot;RenderLayerBacking.h&quot;
 135 #include &quot;RenderLayerCompositor.h&quot;
 136 #include &quot;RenderMenuList.h&quot;
 137 #include &quot;RenderTreeAsText.h&quot;
 138 #include &quot;RenderView.h&quot;
</pre>
<hr />
<pre>
 196 #if ENABLE(INPUT_TYPE_COLOR)
 197 #include &quot;ColorChooser.h&quot;
 198 #endif
 199 
 200 #if ENABLE(MOUSE_CURSOR_SCALE)
 201 #include &lt;wtf/dtoa.h&gt;
 202 #endif
 203 
 204 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 205 #include &quot;LegacyCDM.h&quot;
 206 #include &quot;LegacyMockCDM.h&quot;
 207 #endif
 208 
 209 #if ENABLE(ENCRYPTED_MEDIA)
 210 #include &quot;MockCDMFactory.h&quot;
 211 #endif
 212 
 213 #if ENABLE(VIDEO_TRACK)
 214 #include &quot;CaptionUserPreferences.h&quot;
 215 #include &quot;PageGroup.h&quot;

 216 #endif
 217 
 218 #if ENABLE(VIDEO)
 219 #include &quot;HTMLMediaElement.h&quot;
 220 #include &quot;TimeRanges.h&quot;
 221 #endif
 222 
 223 #if ENABLE(WEBGL)
 224 #include &quot;WebGLRenderingContext.h&quot;
 225 #endif
 226 
 227 #if ENABLE(SPEECH_SYNTHESIS)
 228 #include &quot;DOMWindowSpeechSynthesis.h&quot;
 229 #include &quot;PlatformSpeechSynthesizerMock.h&quot;
 230 #include &quot;SpeechSynthesis.h&quot;
 231 #endif
 232 
 233 #if ENABLE(MEDIA_STREAM)
 234 #include &quot;MediaRecorder.h&quot;
 235 #include &quot;MediaRecorderPrivateMock.h&quot;
</pre>
<hr />
<pre>
 249 #include &quot;MockContentFilterSettings.h&quot;
 250 #endif
 251 
 252 #if ENABLE(WEB_AUDIO)
 253 #include &quot;AudioContext.h&quot;
 254 #endif
 255 
 256 #if ENABLE(MEDIA_SESSION)
 257 #include &quot;MediaSession.h&quot;
 258 #include &quot;MediaSessionManager.h&quot;
 259 #endif
 260 
 261 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 262 #include &quot;MediaPlaybackTargetContext.h&quot;
 263 #endif
 264 
 265 #if ENABLE(POINTER_LOCK)
 266 #include &quot;PointerLockController.h&quot;
 267 #endif
 268 





 269 #if USE(QUICK_LOOK)
 270 #include &quot;MockPreviewLoaderClient.h&quot;
 271 #include &quot;PreviewLoader.h&quot;
 272 #endif
 273 
 274 #if ENABLE(APPLE_PAY)
 275 #include &quot;MockPaymentCoordinator.h&quot;
 276 #include &quot;PaymentCoordinator.h&quot;
 277 #endif
 278 
 279 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 280 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 281 #endif
 282 
 283 #if PLATFORM(MAC)
 284 #include &quot;GraphicsContext3DManager.h&quot;
 285 #endif
 286 
 287 using JSC::CallData;
 288 using JSC::CallType;
</pre>
<hr />
<pre>
 303 using namespace Inspector;
 304 
 305 using namespace HTMLNames;
 306 
 307 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 308 public:
 309     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 310     virtual ~InspectorStubFrontend();
 311 
 312 private:
 313     void attachWindow(DockSide) final { }
 314     void detachWindow() final { }
 315     void closeWindow() final;
 316     void reopen() final { }
 317     void bringToFront() final { }
 318     String localizedStringsURL() final { return String(); }
 319     void inspectedURLChanged(const String&amp;) final { }
 320     void showCertificate(const CertificateInfo&amp;) final { }
 321     void setAttachedWindowHeight(unsigned) final { }
 322     void setAttachedWindowWidth(unsigned) final { }

 323 
 324     void sendMessageToFrontend(const String&amp; message) final;
 325     ConnectionType connectionType() const final { return ConnectionType::Local; }
 326 
<span class="line-removed"> 327     Page* frontendPage() const</span>
<span class="line-removed"> 328     {</span>
<span class="line-removed"> 329         if (!m_frontendWindow || !m_frontendWindow-&gt;document())</span>
<span class="line-removed"> 330             return nullptr;</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332         return m_frontendWindow-&gt;document()-&gt;page();</span>
<span class="line-removed"> 333     }</span>
<span class="line-removed"> 334 </span>
 335     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
<span class="line-removed"> 336     InspectorController&amp; m_frontendController;</span>
 337 };
 338 
 339 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
<span class="line-modified"> 340     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), std::make_unique&lt;InspectorFrontendClientLocal::Settings&gt;())</span>
 341     , m_frontendWindow(frontendWindow.copyRef())
<span class="line-removed"> 342     , m_frontendController(frontendPage()-&gt;inspectorController())</span>
 343 {
 344     ASSERT_ARG(frontendWindow, frontendWindow);
 345 
<span class="line-modified"> 346     m_frontendController.setInspectorFrontendClient(this);</span>
 347     inspectedPage.inspectorController().connectFrontend(*this);
 348 }
 349 
 350 InspectorStubFrontend::~InspectorStubFrontend()
 351 {
 352     closeWindow();
 353 }
 354 
 355 void InspectorStubFrontend::closeWindow()
 356 {
 357     if (!m_frontendWindow)
 358         return;
 359 
<span class="line-modified"> 360     m_frontendController.setInspectorFrontendClient(nullptr);</span>
 361     inspectedPage()-&gt;inspectorController().disconnectFrontend(*this);
 362 
 363     m_frontendWindow-&gt;close();
 364     m_frontendWindow = nullptr;
 365 }
 366 
 367 void InspectorStubFrontend::sendMessageToFrontend(const String&amp; message)
 368 {
<span class="line-modified"> 369     ASSERT_ARG(message, !message.isEmpty());</span>
<span class="line-removed"> 370 </span>
<span class="line-removed"> 371     InspectorClient::doDispatchMessageOnFrontendPage(frontendPage(), message);</span>
 372 }
 373 
 374 static bool markerTypeFrom(const String&amp; markerType, DocumentMarker::MarkerType&amp; result)
 375 {
 376     if (equalLettersIgnoringASCIICase(markerType, &quot;spelling&quot;))
 377         result = DocumentMarker::Spelling;
 378     else if (equalLettersIgnoringASCIICase(markerType, &quot;grammar&quot;))
 379         result = DocumentMarker::Grammar;
 380     else if (equalLettersIgnoringASCIICase(markerType, &quot;textmatch&quot;))
 381         result = DocumentMarker::TextMatch;
 382     else if (equalLettersIgnoringASCIICase(markerType, &quot;replacement&quot;))
 383         result = DocumentMarker::Replacement;
 384     else if (equalLettersIgnoringASCIICase(markerType, &quot;correctionindicator&quot;))
 385         result = DocumentMarker::CorrectionIndicator;
 386     else if (equalLettersIgnoringASCIICase(markerType, &quot;rejectedcorrection&quot;))
 387         result = DocumentMarker::RejectedCorrection;
 388     else if (equalLettersIgnoringASCIICase(markerType, &quot;autocorrected&quot;))
 389         result = DocumentMarker::Autocorrected;
 390     else if (equalLettersIgnoringASCIICase(markerType, &quot;spellcheckingexemption&quot;))
 391         result = DocumentMarker::SpellCheckingExemption;
</pre>
<hr />
<pre>
 431 }
 432 
 433 Internals::~Internals()
 434 {
 435 #if ENABLE(MEDIA_STREAM)
 436     if (m_track)
 437         m_track-&gt;source().removeObserver(*this);
 438 #endif
 439 }
 440 
 441 void Internals::resetToConsistentState(Page&amp; page)
 442 {
 443     page.setPageScaleFactor(1, IntPoint(0, 0));
 444     page.setPagination(Pagination());
 445     page.setPaginationLineGridEnabled(false);
 446 
 447     page.setDefersLoading(false);
 448 
 449     page.mainFrame().setTextZoomFactor(1.0f);
 450 
<span class="line-modified"> 451     page.setCompositingPolicyOverride(WTF::nullopt);</span>
 452 
 453     FrameView* mainFrameView = page.mainFrame().view();
 454     if (mainFrameView) {
 455         page.setHeaderHeight(0);
 456         page.setFooterHeight(0);
 457         page.setTopContentInset(0);
 458         mainFrameView-&gt;setUseFixedLayout(false);
 459         mainFrameView-&gt;setFixedLayoutSize(IntSize());

 460 #if USE(COORDINATED_GRAPHICS)
 461         mainFrameView-&gt;setFixedVisibleContentRect(IntRect());
 462 #endif
 463         if (auto* backing = mainFrameView-&gt;tiledBacking())
 464             backing-&gt;setTileSizeUpdateDelayDisabledForTesting(false);
 465     }
 466 
 467     WTF::clearDefaultPortForProtocolMapForTesting();
 468     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 469     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 470     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 471 #if ENABLE(VIDEO_TRACK)
 472     page.group().captionPreferences().setTestingMode(true);
 473     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 474     page.group().captionPreferences().setTestingMode(false);
 475 #endif
 476     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 477         page.mainFrame().editor().toggleContinuousSpellChecking();
 478     if (page.mainFrame().editor().isOverwriteModeEnabled())
 479         page.mainFrame().editor().toggleOverwriteModeEnabled();
 480     page.mainFrame().loader().clearTestingOverrides();
 481     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 482 #if ENABLE(VIDEO)
 483     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 484     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 485 #endif
<span class="line-modified"> 486 #if HAVE(ACCESSIBILITY)</span>

 487     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 488     AXObjectCache::disableAccessibility();
 489 #endif
 490 
 491     MockPageOverlayClient::singleton().uninstallAllOverlays();
 492 
 493 #if ENABLE(CONTENT_FILTERING)
 494     MockContentFilterSettings::reset();
 495 #endif
 496 
 497 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 498     page.setMockMediaPlaybackTargetPickerEnabled(true);
 499     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 500 #endif
 501 
 502     page.setShowAllPlugins(false);
 503     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 504 
 505 #if USE(QUICK_LOOK)
 506     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
 507     PreviewLoader::setClientForTesting(nullptr);
 508 #endif
 509 
 510     printContextForTesting() = nullptr;
 511 
 512 #if USE(LIBWEBRTC)
 513     auto&amp; rtcProvider = page.libWebRTCProvider();
 514     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 515     rtcProvider.disableNonLocalhostConnections();
 516     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);

 517 #endif
 518 
 519     page.settings().setStorageAccessAPIEnabled(false);
 520     page.setFullscreenAutoHideDuration(0_s);
 521     page.setFullscreenInsets({ });
 522     page.setFullscreenControlsHidden(false);
 523 
 524     MediaEngineConfigurationFactory::disableMock();




 525 }
 526 
 527 Internals::Internals(Document&amp; document)
 528     : ContextDestructionObserver(&amp;document)
 529 #if ENABLE(MEDIA_STREAM)
 530     , m_orientationNotifier(0)
 531 #endif
 532 {
 533 #if ENABLE(VIDEO_TRACK)
 534     if (document.page())
 535         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 536 #endif
 537 
 538 #if ENABLE(MEDIA_STREAM)
 539     setMockMediaCaptureDevicesEnabled(true);
 540     setMediaCaptureRequiresSecureConnection(false);
 541 #endif
 542 
 543 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 544     if (document.page())
 545         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 546 #endif
 547 
 548     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 549         setAutomaticSpellingCorrectionEnabled(true);
 550         setAutomaticQuoteSubstitutionEnabled(false);
 551         setAutomaticDashSubstitutionEnabled(false);
 552         setAutomaticLinkDetectionEnabled(false);
 553         setAutomaticTextReplacementEnabled(true);
 554     }
 555 
 556     setConsoleMessageListener(nullptr);
 557 
 558 #if ENABLE(APPLE_PAY)
 559     auto* frame = document.frame();
 560     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 561         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
<span class="line-modified"> 562         frame-&gt;page()-&gt;setPaymentCoordinator(std::make_unique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));</span>
 563     }
 564 #endif
 565 }
 566 
 567 Document* Internals::contextDocument() const
 568 {
 569     return downcast&lt;Document&gt;(scriptExecutionContext());
 570 }
 571 
 572 Frame* Internals::frame() const
 573 {
 574     if (!contextDocument())
 575         return nullptr;
 576     return contextDocument()-&gt;frame();
 577 }
 578 
 579 InternalSettings* Internals::settings() const
 580 {
 581     Document* document = contextDocument();
 582     if (!document)
</pre>
<hr />
<pre>
 811 static BitmapImage* bitmapImageFromImageElement(HTMLImageElement&amp; element)
 812 {
 813     auto* image = imageFromImageElement(element);
 814     return image &amp;&amp; is&lt;BitmapImage&gt;(image) ? &amp;downcast&lt;BitmapImage&gt;(*image) : nullptr;
 815 }
 816 
 817 #if USE(CG)
 818 static PDFDocumentImage* pdfDocumentImageFromImageElement(HTMLImageElement&amp; element)
 819 {
 820     auto* image = imageFromImageElement(element);
 821     return image &amp;&amp; is&lt;PDFDocumentImage&gt;(image) ? &amp;downcast&lt;PDFDocumentImage&gt;(*image) : nullptr;
 822 }
 823 #endif
 824 
 825 unsigned Internals::imageFrameIndex(HTMLImageElement&amp; element)
 826 {
 827     auto* bitmapImage = bitmapImageFromImageElement(element);
 828     return bitmapImage ? bitmapImage-&gt;currentFrame() : 0;
 829 }
 830 












 831 void Internals::setImageFrameDecodingDuration(HTMLImageElement&amp; element, float duration)
 832 {
 833     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 834         bitmapImage-&gt;setFrameDecodingDurationForTesting(Seconds { duration });
 835 }
 836 
 837 void Internals::resetImageAnimation(HTMLImageElement&amp; element)
 838 {
 839     if (auto* image = imageFromImageElement(element))
 840         image-&gt;resetAnimation();
 841 }
 842 
 843 bool Internals::isImageAnimating(HTMLImageElement&amp; element)
 844 {
 845     auto* image = imageFromImageElement(element);
 846     return image &amp;&amp; (image-&gt;isAnimating() || image-&gt;animationPending());
 847 }
 848 





 849 void Internals::setClearDecoderAfterAsyncFrameRequestForTesting(HTMLImageElement&amp; element, bool enabled)
 850 {
 851     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 852         bitmapImage-&gt;setClearDecoderAfterAsyncFrameRequestForTesting(enabled);
 853 }
 854 
 855 unsigned Internals::imageDecodeCount(HTMLImageElement&amp; element)
 856 {
 857     auto* bitmapImage = bitmapImageFromImageElement(element);
 858     return bitmapImage ? bitmapImage-&gt;decodeCountForTesting() : 0;
 859 }
 860 
 861 unsigned Internals::pdfDocumentCachingCount(HTMLImageElement&amp; element)
 862 {
 863 #if USE(CG)
 864     auto* pdfDocumentImage = pdfDocumentImageFromImageElement(element);
 865     return pdfDocumentImage ? pdfDocumentImage-&gt;cachingCountForTesting() : 0;
 866 #else
 867     UNUSED_PARAM(element);
 868     return 0;
</pre>
<hr />
<pre>
1010         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1011             if (Document* document = frame-&gt;document())
1012                 document-&gt;timeline().resumeAnimations();
1013         }
1014     } else {
1015         document-&gt;frame()-&gt;animation().resumeAnimationsForDocument(document);
1016 
1017         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1018             if (Document* document = frame-&gt;document())
1019                 frame-&gt;animation().resumeAnimationsForDocument(document);
1020         }
1021     }
1022 
1023     return { };
1024 }
1025 
1026 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnElement(const String&amp; animationName, double pauseTime, Element&amp; element)
1027 {
1028     if (pauseTime &lt; 0)
1029         return Exception { InvalidAccessError };
<span class="line-modified">1030     return frame()-&gt;animation().pauseAnimationAtTime(element, AtomicString(animationName), pauseTime);</span>
1031 }
1032 
1033 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnPseudoElement(const String&amp; animationName, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1034 {
1035     if (pauseTime &lt; 0)
1036         return Exception { InvalidAccessError };
1037 
1038     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1039         return Exception { InvalidAccessError };
1040 
1041     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1042     if (!pseudoElement)
1043         return Exception { InvalidAccessError };
1044 
<span class="line-modified">1045     return frame()-&gt;animation().pauseAnimationAtTime(*pseudoElement, AtomicString(animationName), pauseTime);</span>
1046 }
1047 
1048 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnElement(const String&amp; propertyName, double pauseTime, Element&amp; element)
1049 {
1050     if (pauseTime &lt; 0)
1051         return Exception { InvalidAccessError };
1052     return frame()-&gt;animation().pauseTransitionAtTime(element, propertyName, pauseTime);
1053 }
1054 
1055 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnPseudoElement(const String&amp; property, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1056 {
1057     if (pauseTime &lt; 0)
1058         return Exception { InvalidAccessError };
1059 
1060     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1061         return Exception { InvalidAccessError };
1062 
1063     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1064     if (!pseudoElement)
1065         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
1084         return frame()-&gt;document()-&gt;timeline().numberOfAnimationTimelineInvalidationsForTesting();
1085     return 0;
1086 }
1087 
1088 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; Internals::pseudoElement(Element&amp; element, const String&amp; pseudoId)
1089 {
1090     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1091         return Exception { InvalidAccessError };
1092 
1093     return pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1094 }
1095 
1096 ExceptionOr&lt;String&gt; Internals::elementRenderTreeAsText(Element&amp; element)
1097 {
1098     element.document().updateStyleIfNeeded();
1099 
1100     String representation = externalRepresentation(&amp;element);
1101     if (representation.isEmpty())
1102         return Exception { InvalidAccessError };
1103 
<span class="line-modified">1104     return WTFMove(representation);</span>
1105 }
1106 
1107 bool Internals::hasPausedImageAnimations(Element&amp; element)
1108 {
1109     return element.renderer() &amp;&amp; element.renderer()-&gt;hasPausedImageAnimations();
1110 }
1111 
1112 bool Internals::isPaintingFrequently(Element&amp; element)
1113 {
1114     return element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer() &amp;&amp; element.renderer()-&gt;enclosingLayer()-&gt;paintingFrequently();
1115 }
1116 
1117 void Internals::incrementFrequentPaintCounter(Element&amp; element)
1118 {
1119     if (element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer())
1120         element.renderer()-&gt;enclosingLayer()-&gt;simulateFrequentPaint();
1121 }
1122 
1123 Ref&lt;CSSComputedStyleDeclaration&gt; Internals::computedStyleIncludingVisitedInfo(Element&amp; element) const
1124 {
</pre>
<hr />
<pre>
1380     if (mainItem-&gt;target() == uniqueName)
1381         mainItem-&gt;setDocumentState(state);
1382     else if (HistoryItem* subItem = mainItem-&gt;childItemWithTarget(uniqueName))
1383         subItem-&gt;setDocumentState(state);
1384     else
1385         return Exception { InvalidAccessError };
1386     return { };
1387 }
1388 
1389 #if ENABLE(SPEECH_SYNTHESIS)
1390 
1391 void Internals::enableMockSpeechSynthesizer()
1392 {
1393     Document* document = contextDocument();
1394     if (!document || !document-&gt;domWindow())
1395         return;
1396     SpeechSynthesis* synthesis = DOMWindowSpeechSynthesis::speechSynthesis(*document-&gt;domWindow());
1397     if (!synthesis)
1398         return;
1399 
<span class="line-modified">1400     synthesis-&gt;setPlatformSynthesizer(std::make_unique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));</span>
1401 }
1402 
1403 #endif
1404 
1405 #if ENABLE(WEB_RTC)
1406 
1407 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1408 {
1409     if (!LibWebRTCProvider::webRTCAvailable())
1410         return;
1411 
1412     connection.emulatePlatformEvent(action);
1413 }
1414 
1415 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1416 {
<span class="line-modified">1417     // FIXME: We should upgrade mocks to support unified plan APIs, until then use plan B in tests using mock.</span>
<span class="line-removed">1418 </span>
<span class="line-removed">1419     ASSERT(!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());</span>
1420     if (!LibWebRTCProvider::webRTCAvailable())
1421         return;
1422 
1423 #if USE(LIBWEBRTC)
1424     Document* document = contextDocument();
1425     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1426     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1427 #else
1428     UNUSED_PARAM(testCase);
1429 #endif
1430 }
1431 
1432 void Internals::setICECandidateFiltering(bool enabled)
1433 {
1434     auto* page = contextDocument()-&gt;page();
1435     if (!page)
1436         return;
1437 
1438     auto&amp; rtcController = page-&gt;rtcController();
1439     if (enabled)
</pre>
<hr />
<pre>
1460 }
1461 
1462 void Internals::stopPeerConnection(RTCPeerConnection&amp; connection)
1463 {
1464     ActiveDOMObject&amp; object = connection;
1465     object.stop();
1466 }
1467 
1468 void Internals::clearPeerConnectionFactory()
1469 {
1470 #if USE(LIBWEBRTC)
1471     if (auto* page = contextDocument()-&gt;page())
1472         page-&gt;libWebRTCProvider().clearFactory();
1473 #endif
1474 }
1475 
1476 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1477 {
1478     connection.applyRotationForOutgoingVideoSources();
1479 }








1480 #endif
1481 
1482 #if ENABLE(MEDIA_STREAM)




1483 
1484 void Internals::setMockMediaCaptureDevicesEnabled(bool enabled)
1485 {
1486     Document* document = contextDocument();
1487     if (auto* page = document-&gt;page())
1488         page-&gt;settings().setMockCaptureDevicesEnabled(enabled);
1489 }
1490 
1491 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1492 {
1493     Document* document = contextDocument();
1494     if (auto* page = document-&gt;page())
1495         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1496 }
1497 
1498 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1499 {
1500     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1501 }
1502 
</pre>
<hr />
<pre>
1528 Ref&lt;DOMRect&gt; Internals::boundingBox(Element&amp; element)
1529 {
1530     element.document().updateLayoutIgnorePendingStylesheets();
1531     auto renderer = element.renderer();
1532     if (!renderer)
1533         return DOMRect::create();
1534     return DOMRect::create(renderer-&gt;absoluteBoundingBoxRectIgnoringTransforms());
1535 }
1536 
1537 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::inspectorHighlightRects()
1538 {
1539     Document* document = contextDocument();
1540     if (!document || !document-&gt;page())
1541         return Exception { InvalidAccessError };
1542 
1543     Highlight highlight;
1544     document-&gt;page()-&gt;inspectorController().getHighlight(highlight, InspectorOverlay::CoordinateSystem::View);
1545     return DOMRectList::create(highlight.quads);
1546 }
1547 
<span class="line-removed">1548 ExceptionOr&lt;String&gt; Internals::inspectorHighlightObject()</span>
<span class="line-removed">1549 {</span>
<span class="line-removed">1550     Document* document = contextDocument();</span>
<span class="line-removed">1551     if (!document || !document-&gt;page())</span>
<span class="line-removed">1552         return Exception { InvalidAccessError };</span>
<span class="line-removed">1553 </span>
<span class="line-removed">1554     return document-&gt;page()-&gt;inspectorController().buildObjectForHighlightedNodes()-&gt;toJSONString();</span>
<span class="line-removed">1555 }</span>
<span class="line-removed">1556 </span>
1557 ExceptionOr&lt;unsigned&gt; Internals::markerCountForNode(Node&amp; node, const String&amp; markerType)
1558 {
1559     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1560     if (!markerTypesFrom(markerType, markerTypes))
1561         return Exception { SyntaxError };
1562 
1563     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1564     return node.document().markers().markersFor(node, markerTypes).size();
1565 }
1566 
1567 ExceptionOr&lt;RenderedDocumentMarker*&gt; Internals::markerAt(Node&amp; node, const String&amp; markerType, unsigned index)
1568 {
1569     node.document().updateLayoutIgnorePendingStylesheets();
1570 
1571     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1572     if (!markerTypesFrom(markerType, markerTypes))
1573         return Exception { SyntaxError };
1574 
1575     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1576 
</pre>
<hr />
<pre>
1598         return result.releaseException();
1599     auto marker = result.releaseReturnValue();
1600     if (!marker)
1601         return String();
1602     return String { marker-&gt;description() };
1603 }
1604 
1605 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1606 {
1607     DocumentMarker::MarkerType markerType;
1608     if (!markerTypeFrom(markerTypeString, markerType))
1609         return Exception { SyntaxError };
1610 
1611     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1612     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1613 
1614     StringBuilder rectString;
1615     rectString.appendLiteral(&quot;marker rects: &quot;);
1616     for (const auto&amp; rect : rects) {
1617         rectString.append(&#39;(&#39;);
<span class="line-modified">1618         rectString.appendNumber(rect.x());</span>
1619         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1620         rectString.appendNumber(rect.y());</span>
1621         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1622         rectString.appendNumber(rect.width());</span>
1623         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1624         rectString.appendNumber(rect.height());</span>
1625         rectString.appendLiteral(&quot;) &quot;);
1626     }
1627     return rectString.toString();
1628 }
1629 
1630 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1631 {
1632     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1633     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1634 }
1635 
1636 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1637 {
1638     Document* document = contextDocument();
1639     if (!document || !document-&gt;frame())
1640         return Exception { InvalidAccessError };
1641     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1642     return { };
1643 }
1644 
</pre>
<hr />
<pre>
1811 {
1812     if (is&lt;HTMLInputElement&gt;(textField))
1813         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1814 
1815     if (is&lt;HTMLTextAreaElement&gt;(textField))
1816         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1817 
1818     return Exception { InvalidNodeTypeError };
1819 }
1820 
1821 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1822 {
1823     return element.shouldAutocomplete();
1824 }
1825 
1826 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
1827 {
1828     element.setAutoFilled(enabled);
1829 }
1830 





1831 static AutoFillButtonType toAutoFillButtonType(Internals::AutoFillButtonType type)
1832 {
1833     switch (type) {
1834     case Internals::AutoFillButtonType::None:
1835         return AutoFillButtonType::None;
1836     case Internals::AutoFillButtonType::Credentials:
1837         return AutoFillButtonType::Credentials;
1838     case Internals::AutoFillButtonType::Contacts:
1839         return AutoFillButtonType::Contacts;
1840     case Internals::AutoFillButtonType::StrongPassword:
1841         return AutoFillButtonType::StrongPassword;
1842     case Internals::AutoFillButtonType::CreditCard:
1843         return AutoFillButtonType::CreditCard;
1844     }
1845     ASSERT_NOT_REACHED();
1846     return AutoFillButtonType::None;
1847 }
1848 
1849 static Internals::AutoFillButtonType toInternalsAutoFillButtonType(AutoFillButtonType type)
1850 {
</pre>
<hr />
<pre>
1915 {
1916     size_t location = 0;
1917     size_t unusedLength = 0;
1918     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, location, unusedLength);
1919     return location;
1920 }
1921 
1922 unsigned Internals::lengthFromRange(Element&amp; scope, const Range&amp; range)
1923 {
1924     size_t unusedLocation = 0;
1925     size_t length = 0;
1926     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, unusedLocation, length);
1927     return length;
1928 }
1929 
1930 String Internals::rangeAsText(const Range&amp; range)
1931 {
1932     return range.text();
1933 }
1934 





1935 Ref&lt;Range&gt; Internals::subrange(Range&amp; range, int rangeLocation, int rangeLength)
1936 {
1937     return TextIterator::subrange(range, rangeLocation, rangeLength);
1938 }
1939 
1940 RefPtr&lt;Range&gt; Internals::rangeOfStringNearLocation(const Range&amp; searchRange, const String&amp; text, unsigned targetOffset)
1941 {
1942     return findClosestPlainText(searchRange, text, { }, targetOffset);
1943 }
1944 
1945 #if !PLATFORM(MAC)
1946 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeForDictionaryLookupAtLocation(int, int)
1947 {
1948     return Exception { InvalidAccessError };
1949 }
1950 #endif
1951 
1952 ExceptionOr&lt;void&gt; Internals::setDelegatesScrolling(bool enabled)
1953 {
1954     Document* document = contextDocument();
</pre>
<hr />
<pre>
2127     if (!code || code.isNull() || code.isUndefined()) {
2128         GetCallerCodeBlockFunctor iter;
2129         exec-&gt;iterate(iter);
2130         CodeBlock* codeBlock = iter.codeBlock();
2131         executable = codeBlock-&gt;ownerExecutable();
2132     } else if (code.isFunction(vm)) {
2133         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(exec));
2134         executable = funcObj-&gt;jsExecutable();
2135     } else
2136         return String();
2137 
2138     unsigned startLine = executable-&gt;firstLine();
2139     unsigned startColumn = executable-&gt;startColumn();
2140     unsigned endLine = executable-&gt;lastLine();
2141     unsigned endColumn = executable-&gt;endColumn();
2142 
2143     StringBuilder result;
2144 
2145     if (executable-&gt;isFunctionExecutable()) {
2146         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
<span class="line-modified">2147         String inferredName = funcExecutable-&gt;inferredName().string();</span>
2148         result.appendLiteral(&quot;function \&quot;&quot;);
2149         result.append(inferredName);
2150         result.append(&#39;&quot;&#39;);
2151     } else if (executable-&gt;isEvalExecutable())
2152         result.appendLiteral(&quot;eval&quot;);
2153     else if (executable-&gt;isModuleProgramExecutable())
2154         result.appendLiteral(&quot;module&quot;);
2155     else if (executable-&gt;isProgramExecutable())
2156         result.appendLiteral(&quot;program&quot;);
2157     else
2158         ASSERT_NOT_REACHED();
2159 
2160     result.appendLiteral(&quot; { &quot;);
2161     result.appendNumber(startLine);
2162     result.append(&#39;:&#39;);
2163     result.appendNumber(startColumn);
2164     result.appendLiteral(&quot; - &quot;);
2165     result.appendNumber(endLine);
2166     result.append(&#39;:&#39;);
2167     result.appendNumber(endColumn);
</pre>
<hr />
<pre>
2218     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticQuoteSubstitutionEnabled())
2219         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticQuoteSubstitution();
2220 #else
2221     UNUSED_PARAM(enabled);
2222 #endif
2223 }
2224 
2225 void Internals::setAutomaticLinkDetectionEnabled(bool enabled)
2226 {
2227     if (!contextDocument() || !contextDocument()-&gt;frame())
2228         return;
2229 
2230 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2231     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticLinkDetectionEnabled())
2232         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticLinkDetection();
2233 #else
2234     UNUSED_PARAM(enabled);
2235 #endif
2236 }
2237 







2238 void Internals::setAutomaticDashSubstitutionEnabled(bool enabled)
2239 {
2240     if (!contextDocument() || !contextDocument()-&gt;frame())
2241         return;
2242 
2243 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2244     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticDashSubstitutionEnabled())
2245         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticDashSubstitution();
2246 #else
2247     UNUSED_PARAM(enabled);
2248 #endif
2249 }
2250 
2251 void Internals::setAutomaticTextReplacementEnabled(bool enabled)
2252 {
2253     if (!contextDocument() || !contextDocument()-&gt;frame())
2254         return;
2255 
2256 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2257     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticTextReplacementEnabled())
</pre>
<hr />
<pre>
2323         {&quot;Backwards&quot;, Backwards},
2324         {&quot;WrapAround&quot;, WrapAround},
2325         {&quot;StartInSelection&quot;, StartInSelection},
2326         {&quot;DoNotRevealSelection&quot;, DoNotRevealSelection},
2327         {&quot;AtWordEnds&quot;, AtWordEnds},
2328         {&quot;DoNotTraverseFlatTree&quot;, DoNotTraverseFlatTree},
2329     };
2330     FindOptions result;
2331     for (auto&amp; option : optionList) {
2332         bool found = false;
2333         for (auto&amp; flag : flagList) {
2334             if (flag.name == option) {
2335                 result.add(flag.value);
2336                 found = true;
2337                 break;
2338             }
2339         }
2340         if (!found)
2341             return Exception { SyntaxError };
2342     }
<span class="line-modified">2343     return WTFMove(result);</span>
2344 }
2345 
2346 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeOfString(const String&amp; text, RefPtr&lt;Range&gt;&amp;&amp; referenceRange, const Vector&lt;String&gt;&amp; findOptions)
2347 {
2348     Document* document = contextDocument();
2349     if (!document || !document-&gt;frame())
2350         return Exception { InvalidAccessError };
2351 
2352     auto parsedOptions = parseFindOptions(findOptions);
2353     if (parsedOptions.hasException())
2354         return parsedOptions.releaseException();
2355 
2356     return document-&gt;frame()-&gt;editor().rangeOfString(text, referenceRange.get(), parsedOptions.releaseReturnValue());
2357 }
2358 
2359 ExceptionOr&lt;unsigned&gt; Internals::countMatchesForText(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions, const String&amp; markMatches)
2360 {
2361     Document* document = contextDocument();
2362     if (!document || !document-&gt;frame())
2363         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
2366     if (parsedOptions.hasException())
2367         return parsedOptions.releaseException();
2368 
2369     bool mark = markMatches == &quot;mark&quot;;
2370     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2371 }
2372 
2373 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2374 {
2375     Document* document = contextDocument();
2376     if (!document || !document-&gt;page())
2377         return Exception { InvalidAccessError };
2378 
2379     auto parsedOptions = parseFindOptions(findOptions);
2380     if (parsedOptions.hasException())
2381         return parsedOptions.releaseException();
2382 
2383     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2384 }
2385 

2386 unsigned Internals::numberOfIDBTransactions() const
2387 {
<span class="line-removed">2388 #if ENABLE(INDEXED_DATABASE)</span>
2389     return IDBTransaction::numberOfIDBTransactions;
<span class="line-removed">2390 #else</span>
<span class="line-removed">2391     return 0;</span>
<span class="line-removed">2392 #endif</span>
2393 }

2394 
2395 unsigned Internals::numberOfLiveNodes() const
2396 {
2397     unsigned nodeCount = 0;
2398     for (auto* document : Document::allDocuments())
2399         nodeCount += document-&gt;referencingNodeCount();
2400     return nodeCount;
2401 }
2402 
2403 unsigned Internals::numberOfLiveDocuments() const
2404 {
2405     return Document::allDocuments().size();
2406 }
2407 
2408 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2409 {
2410     return document.referencingNodeCount();
2411 }
2412 
2413 #if ENABLE(INTERSECTION_OBSERVER)
</pre>
<hr />
<pre>
2434 #else
2435     return false;
2436 #endif
2437 }
2438 
2439 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2440 {
2441 #if ENABLE(SERVICE_WORKER)
2442     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(document.sessionID()).serverConnectionIdentifier(), document.identifier() }.toString();
2443 #else
2444     UNUSED_PARAM(document);
2445     return String();
2446 #endif
2447 }
2448 
2449 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2450 {
2451     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2452     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2453     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
<span class="line-modified">2454     m_inspectorFrontend = std::make_unique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));</span>
2455     return frontendWindowProxy;
2456 }
2457 
2458 void Internals::closeDummyInspectorFrontend()
2459 {
2460     m_inspectorFrontend = nullptr;
2461 }
2462 
2463 ExceptionOr&lt;void&gt; Internals::setInspectorIsUnderTest(bool isUnderTest)
2464 {
2465     Page* page = contextDocument()-&gt;frame()-&gt;page();
2466     if (!page)
2467         return Exception { InvalidAccessError };
2468 
2469     page-&gt;inspectorController().setIsUnderTest(isUnderTest);
2470     return { };
2471 }
2472 
2473 bool Internals::hasGrammarMarker(int from, int length)
2474 {
</pre>
<hr />
<pre>
2505         return Exception { InvalidAccessError };
2506 
2507     return document-&gt;isPageBoxVisible(pageNumber);
2508 }
2509 
2510 static LayerTreeFlags toLayerTreeFlags(unsigned short flags)
2511 {
2512     LayerTreeFlags layerTreeFlags = 0;
2513     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2514         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2515     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2516         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2517     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2518         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2519     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2520         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2521     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2522         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2523     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2524         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;


2525     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2526         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2527     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2528         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;


2529 
2530     return layerTreeFlags;
2531 }
2532 
2533 // FIXME: Remove the document argument. It is almost always the same as
2534 // contextDocument(), with the exception of a few tests that pass a
2535 // different document, and could just make the call through another Internals
2536 // instance instead.
2537 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2538 {
2539     if (!document.frame())
2540         return Exception { InvalidAccessError };
2541 
2542     document.updateLayoutIgnorePendingStylesheets();
2543     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2544 }
2545 
2546 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2547 {
2548     Document* document = contextDocument();
</pre>
<hr />
<pre>
2950     Document* document = contextDocument();
2951     if (!document || !document-&gt;view())
2952         return Exception { InvalidAccessError };
2953 
2954     document-&gt;view()-&gt;setFixedLayoutSize(IntSize(width, height));
2955     return { };
2956 }
2957 
2958 ExceptionOr&lt;void&gt; Internals::setViewExposedRect(float x, float y, float width, float height)
2959 {
2960     Document* document = contextDocument();
2961     if (!document || !document-&gt;view())
2962         return Exception { InvalidAccessError };
2963 
2964     document-&gt;view()-&gt;setViewExposedRect(FloatRect(x, y, width, height));
2965     return { };
2966 }
2967 
2968 void Internals::setPrinting(int width, int height)
2969 {
<span class="line-modified">2970     printContextForTesting() = std::make_unique&lt;PrintContext&gt;(frame());</span>
2971     printContextForTesting()-&gt;begin(width, height);
2972 }
2973 
2974 void Internals::setHeaderHeight(float height)
2975 {
2976     Document* document = contextDocument();
2977     if (!document || !document-&gt;view())
2978         return;
2979 
2980     document-&gt;page()-&gt;setHeaderHeight(height);
2981 }
2982 
2983 void Internals::setFooterHeight(float height)
2984 {
2985     Document* document = contextDocument();
2986     if (!document || !document-&gt;view())
2987         return;
2988 
2989     document-&gt;page()-&gt;setFooterHeight(height);
2990 }
2991 
2992 void Internals::setTopContentInset(float contentInset)
2993 {
2994     Document* document = contextDocument();
2995     if (!document || !document-&gt;page())
2996         return;
2997 
2998     document-&gt;page()-&gt;setTopContentInset(contentInset);
2999 }
3000 
3001 #if ENABLE(FULLSCREEN_API)
3002 
3003 void Internals::webkitWillEnterFullScreenForElement(Element&amp; element)
3004 {
3005     Document* document = contextDocument();
3006     if (!document)
3007         return;
<span class="line-modified">3008     document-&gt;webkitWillEnterFullScreen(element);</span>
3009 }
3010 
3011 void Internals::webkitDidEnterFullScreenForElement(Element&amp;)
3012 {
3013     Document* document = contextDocument();
3014     if (!document)
3015         return;
<span class="line-modified">3016     document-&gt;webkitDidEnterFullScreen();</span>
3017 }
3018 
3019 void Internals::webkitWillExitFullScreenForElement(Element&amp;)
3020 {
3021     Document* document = contextDocument();
3022     if (!document)
3023         return;
<span class="line-modified">3024     document-&gt;webkitWillExitFullScreen();</span>
3025 }
3026 
3027 void Internals::webkitDidExitFullScreenForElement(Element&amp;)
3028 {
3029     Document* document = contextDocument();
3030     if (!document)
3031         return;
<span class="line-modified">3032     document-&gt;webkitDidExitFullScreen();</span>
3033 }
3034 
3035 bool Internals::isAnimatingFullScreen() const
3036 {
3037     Document* document = contextDocument();
3038     if (!document)
3039         return false;
<span class="line-modified">3040     return document-&gt;isAnimatingFullScreen();</span>
3041 }
3042 
3043 #endif
3044 
3045 void Internals::setFullscreenInsets(FullscreenInsets insets)
3046 {
3047     Page* page = contextDocument()-&gt;frame()-&gt;page();
3048     ASSERT(page);
3049 
3050     page-&gt;setFullscreenInsets(FloatBoxExtent(insets.top, insets.right, insets.bottom, insets.left));
3051 }
3052 
3053 void Internals::setFullscreenAutoHideDuration(double duration)
3054 {
3055     Page* page = contextDocument()-&gt;frame()-&gt;page();
3056     ASSERT(page);
3057 
3058     page-&gt;setFullscreenAutoHideDuration(Seconds(duration));
3059 }
3060 
</pre>
<hr />
<pre>
3319 
3320 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3321 {
3322     Document* document = contextDocument();
3323     if (!document || !document-&gt;frame())
3324         return Exception { InvalidAccessError };
3325 
3326 #if !PLATFORM(IOS_FAMILY)
3327     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3328 
3329     StringBuilder result;
3330     result.appendLiteral(&quot;type=&quot;);
3331     result.append(cursorTypeToString(cursor.type()));
3332     result.appendLiteral(&quot; hotSpot=&quot;);
3333     result.appendNumber(cursor.hotSpot().x());
3334     result.append(&#39;,&#39;);
3335     result.appendNumber(cursor.hotSpot().y());
3336     if (cursor.image()) {
3337         FloatSize size = cursor.image()-&gt;size();
3338         result.appendLiteral(&quot; image=&quot;);
<span class="line-modified">3339         result.appendNumber(size.width());</span>
3340         result.append(&#39;x&#39;);
<span class="line-modified">3341         result.appendNumber(size.height());</span>
3342     }
3343 #if ENABLE(MOUSE_CURSOR_SCALE)
3344     if (cursor.imageScaleFactor() != 1) {
3345         result.appendLiteral(&quot; scale=&quot;);
<span class="line-modified">3346         result.appendNumber(cursor.imageScaleFactor(), 8);</span>
3347     }
3348 #endif
3349     return result.toString();
3350 #else
3351     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3352 #endif
3353 }
3354 
3355 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3356 {
3357     auto&amp; bytes = value-&gt;data();
3358     return ArrayBuffer::create(bytes.data(), bytes.size());
3359 }
3360 
3361 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3362 {
3363     Vector&lt;uint8_t&gt; bytes;
3364     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3365     return SerializedScriptValue::adopt(WTFMove(bytes));
3366 }
</pre>
<hr />
<pre>
3377 
3378 void Internals::setUsesMockScrollAnimator(bool enabled)
3379 {
3380     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3381 }
3382 
3383 void Internals::forceReload(bool endToEnd)
3384 {
3385     OptionSet&lt;ReloadOption&gt; reloadOptions;
3386     if (endToEnd)
3387         reloadOptions.add(ReloadOption::FromOrigin);
3388 
3389     frame()-&gt;loader().reload(reloadOptions);
3390 }
3391 
3392 void Internals::reloadExpiredOnly()
3393 {
3394     frame()-&gt;loader().reload(ReloadOption::ExpiredOnly);
3395 }
3396 
<span class="line-modified">3397 void Internals::enableAutoSizeMode(bool enabled, int minimumWidth, int minimumHeight, int maximumWidth, int maximumHeight)</span>
3398 {
3399     auto* document = contextDocument();
3400     if (!document || !document-&gt;view())
3401         return;
<span class="line-modified">3402     document-&gt;view()-&gt;enableAutoSizeMode(enabled, IntSize(minimumWidth, minimumHeight), IntSize(maximumWidth, maximumHeight));</span>
3403 }
3404 
3405 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
3406 
3407 void Internals::initializeMockCDM()
3408 {
<span class="line-modified">3409     LegacyCDM::registerCDMFactory([] (LegacyCDM* cdm) { return std::make_unique&lt;LegacyMockCDM&gt;(cdm); },</span>
3410         LegacyMockCDM::supportsKeySystem, LegacyMockCDM::supportsKeySystemAndMimeType);
3411 }
3412 
3413 #endif
3414 
3415 #if ENABLE(ENCRYPTED_MEDIA)
3416 
3417 Ref&lt;MockCDMFactory&gt; Internals::registerMockCDM()
3418 {
3419     return MockCDMFactory::create();
3420 }
3421 
3422 #endif
3423 
3424 String Internals::markerTextForListItem(Element&amp; element)
3425 {
3426     return WebCore::markerTextForListItem(&amp;element);
3427 }
3428 
3429 String Internals::toolTipFromElement(Element&amp; element) const
</pre>
<hr />
<pre>
3483     if (equalLettersIgnoringASCIICase(characteristic, &quot;legible&quot;))
3484         return element.hasClosedCaptions();
3485 
3486     return Exception { SyntaxError };
3487 }
3488 
3489 void Internals::beginSimulatedHDCPError(HTMLMediaElement&amp; element)
3490 {
3491     if (auto player = element.player())
3492         player-&gt;beginSimulatedHDCPError();
3493 }
3494 
3495 void Internals::endSimulatedHDCPError(HTMLMediaElement&amp; element)
3496 {
3497     if (auto player = element.player())
3498         player-&gt;endSimulatedHDCPError();
3499 }
3500 
3501 bool Internals::elementShouldBufferData(HTMLMediaElement&amp; element)
3502 {
<span class="line-modified">3503     return element.shouldBufferData();</span>
3504 }
3505 
















3506 #endif
3507 
3508 bool Internals::isSelectPopupVisible(HTMLSelectElement&amp; element)
3509 {
3510     element.document().updateLayoutIgnorePendingStylesheets();
3511 
3512     auto* renderer = element.renderer();
3513     if (!is&lt;RenderMenuList&gt;(renderer))
3514         return false;
3515 
3516 #if !PLATFORM(IOS_FAMILY)
3517     return downcast&lt;RenderMenuList&gt;(*renderer).popupIsVisible();
3518 #else
3519     return false;
3520 #endif
3521 }
3522 
3523 ExceptionOr&lt;String&gt; Internals::captionsStyleSheetOverride()
3524 {
3525     Document* document = contextDocument();
</pre>
<hr />
<pre>
3569 
3570 #if ENABLE(VIDEO_TRACK)
3571     auto&amp; captionPreferences = document-&gt;page()-&gt;group().captionPreferences();
3572 
3573     if (equalLettersIgnoringASCIICase(mode, &quot;automatic&quot;))
3574         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Automatic);
3575     else if (equalLettersIgnoringASCIICase(mode, &quot;forcedonly&quot;))
3576         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::ForcedOnly);
3577     else if (equalLettersIgnoringASCIICase(mode, &quot;alwayson&quot;))
3578         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::AlwaysOn);
3579     else if (equalLettersIgnoringASCIICase(mode, &quot;manual&quot;))
3580         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Manual);
3581     else
3582         return Exception { SyntaxError };
3583 #else
3584     UNUSED_PARAM(mode);
3585 #endif
3586     return { };
3587 }
3588 










3589 #if ENABLE(VIDEO)
3590 
3591 Ref&lt;TimeRanges&gt; Internals::createTimeRanges(Float32Array&amp; startTimes, Float32Array&amp; endTimes)
3592 {
3593     ASSERT(startTimes.length() == endTimes.length());
3594     Ref&lt;TimeRanges&gt; ranges = TimeRanges::create();
3595 
3596     unsigned count = std::min(startTimes.length(), endTimes.length());
3597     for (unsigned i = 0; i &lt; count; ++i)
3598         ranges-&gt;add(startTimes.item(i), endTimes.item(i));
3599     return ranges;
3600 }
3601 
3602 double Internals::closestTimeToTimeRanges(double time, TimeRanges&amp; ranges)
3603 {
3604     return ranges.nearest(time);
3605 }
3606 
3607 #endif
3608 
</pre>
<hr />
<pre>
3630     return downcast&lt;HTMLPlugInElement&gt;(element).isReplacementObscured();
3631 }
3632 
3633 ExceptionOr&lt;String&gt; Internals::unavailablePluginReplacementText(Element&amp; element)
3634 {
3635     if (!is&lt;HTMLPlugInElement&gt;(element))
3636         return Exception { InvalidAccessError };
3637 
3638     auto* renderer = element.renderer();
3639     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
3640         return String { };
3641 
3642     return String { downcast&lt;RenderEmbeddedObject&gt;(*renderer).pluginReplacementTextIfUnavailable() };
3643 }
3644 
3645 bool Internals::isPluginSnapshotted(Element&amp; element)
3646 {
3647     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot;
3648 }
3649 





3650 #if ENABLE(MEDIA_SOURCE)
3651 
3652 void Internals::initializeMockMediaSource()
3653 {
3654 #if USE(AVFOUNDATION)
3655     WebCore::DeprecatedGlobalSettings::setAVFoundationEnabled(false);
3656 #endif
3657 #if USE(GSTREAMER)
3658     WebCore::DeprecatedGlobalSettings::setGStreamerEnabled(false);
3659 #endif
3660     MediaPlayerFactorySupport::callRegisterMediaEngine(MockMediaPlayerMediaSource::registerMediaEngine);
3661 }
3662 
<span class="line-modified">3663 Vector&lt;String&gt; Internals::bufferedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomicString&amp; trackID)</span>
3664 {
3665     return buffer.bufferedSamplesForTrackID(trackID);
3666 }
3667 
<span class="line-modified">3668 Vector&lt;String&gt; Internals::enqueuedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomicString&amp; trackID)</span>
3669 {
3670     return buffer.enqueuedSamplesForTrackID(trackID);
3671 }
3672 





3673 void Internals::setShouldGenerateTimestamps(SourceBuffer&amp; buffer, bool flag)
3674 {
3675     buffer.setShouldGenerateTimestamps(flag);
3676 }
3677 





3678 #endif
3679 
3680 void Internals::enableMockMediaCapabilities()
3681 {
3682     MediaEngineConfigurationFactory::enableMock();
3683 }
3684 
3685 #if ENABLE(VIDEO)
3686 
3687 ExceptionOr&lt;void&gt; Internals::beginMediaSessionInterruption(const String&amp; interruptionString)
3688 {
3689     PlatformMediaSession::InterruptionType interruption = PlatformMediaSession::SystemInterruption;
3690 
3691     if (equalLettersIgnoringASCIICase(interruptionString, &quot;system&quot;))
3692         interruption = PlatformMediaSession::SystemInterruption;
3693     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;systemsleep&quot;))
3694         interruption = PlatformMediaSession::SystemSleep;
3695     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;enteringbackground&quot;))
3696         interruption = PlatformMediaSession::EnteringBackground;
3697     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;suspendedunderlock&quot;))
</pre>
<hr />
<pre>
3820         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
3821             restrictions |= MediaElementSession::NoRestrictions;
3822         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforload&quot;))
3823             restrictions |= MediaElementSession::RequireUserGestureForLoad;
3824         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforvideoratechange&quot;))
3825             restrictions |= MediaElementSession::RequireUserGestureForVideoRateChange;
3826         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforfullscreen&quot;))
3827             restrictions |= MediaElementSession::RequireUserGestureForFullscreen;
3828         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoloadmedia&quot;))
3829             restrictions |= MediaElementSession::RequirePageConsentToLoadMedia;
3830         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoresumemedia&quot;))
3831             restrictions |= MediaElementSession::RequirePageConsentToResumeMedia;
3832 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3833         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergesturetoshowplaybacktargetpicker&quot;))
3834             restrictions |= MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker;
3835         if (equalLettersIgnoringASCIICase(restrictionString, &quot;wirelessvideoplaybackdisabled&quot;))
3836             restrictions |= MediaElementSession::WirelessVideoPlaybackDisabled;
3837 #endif
3838         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudioratechange&quot;))
3839             restrictions |= MediaElementSession::RequireUserGestureForAudioRateChange;
<span class="line-removed">3840         if (equalLettersIgnoringASCIICase(restrictionString, &quot;metadatapreloadingnotpermitted&quot;))</span>
<span class="line-removed">3841             restrictions |= MediaElementSession::MetadataPreloadingNotPermitted;</span>
3842         if (equalLettersIgnoringASCIICase(restrictionString, &quot;autopreloadingnotpermitted&quot;))
3843             restrictions |= MediaElementSession::AutoPreloadingNotPermitted;
3844         if (equalLettersIgnoringASCIICase(restrictionString, &quot;invisibleautoplaynotpermitted&quot;))
3845             restrictions |= MediaElementSession::InvisibleAutoplayNotPermitted;
3846         if (equalLettersIgnoringASCIICase(restrictionString, &quot;overrideusergesturerequirementformaincontent&quot;))
3847             restrictions |= MediaElementSession::OverrideUserGestureRequirementForMainContent;
3848     }
3849     element.mediaSession().addBehaviorRestriction(restrictions);
3850 }
3851 
3852 ExceptionOr&lt;void&gt; Internals::postRemoteControlCommand(const String&amp; commandString, float argument)
3853 {
3854     PlatformMediaSession::RemoteControlCommandType command;
3855     PlatformMediaSession::RemoteCommandArgument parameter { argument };
3856 
3857     if (equalLettersIgnoringASCIICase(commandString, &quot;play&quot;))
3858         command = PlatformMediaSession::PlayCommand;
3859     else if (equalLettersIgnoringASCIICase(commandString, &quot;pause&quot;))
3860         command = PlatformMediaSession::PauseCommand;
3861     else if (equalLettersIgnoringASCIICase(commandString, &quot;stop&quot;))
</pre>
<hr />
<pre>
4043     Document* document = contextDocument();
4044     if (!document || !document-&gt;page())
4045         return Exception { InvalidAccessError };
4046 
4047     document-&gt;updateLayoutIgnorePendingStylesheets();
4048 
4049     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
4050 }
4051 
4052 void Internals::setPageMuted(StringView statesString)
4053 {
4054     Document* document = contextDocument();
4055     if (!document)
4056         return;
4057 
4058     WebCore::MediaProducer::MutedStateFlags state = MediaProducer::NoneMuted;
4059     for (StringView stateString : statesString.split(&#39;,&#39;)) {
4060         if (equalLettersIgnoringASCIICase(stateString, &quot;audio&quot;))
4061             state |= MediaProducer::AudioIsMuted;
4062         if (equalLettersIgnoringASCIICase(stateString, &quot;capturedevices&quot;))
<span class="line-modified">4063             state |= MediaProducer::CaptureDevicesAreMuted;</span>


4064     }
4065 
4066     if (Page* page = document-&gt;page())
4067         page-&gt;setMuted(state);
4068 }
4069 
4070 String Internals::pageMediaState()
4071 {
4072     Document* document = contextDocument();
4073     if (!document || !document-&gt;page())
4074         return emptyString();
4075 
4076     WebCore::MediaProducer::MediaStateFlags state = document-&gt;page()-&gt;mediaState();
4077     StringBuilder string;
4078     if (state &amp; MediaProducer::IsPlayingAudio)
4079         string.append(&quot;IsPlayingAudio,&quot;);
4080     if (state &amp; MediaProducer::IsPlayingVideo)
4081         string.append(&quot;IsPlayingVideo,&quot;);
4082     if (state &amp; MediaProducer::IsPlayingToExternalDevice)
4083         string.append(&quot;IsPlayingToExternalDevice,&quot;);
</pre>
<hr />
<pre>
4132 }
4133 
4134 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4135 {
4136     Document* document = contextDocument();
4137     if (!document || !document-&gt;page())
4138         return Exception { InvalidAccessError };
4139     return document-&gt;page()-&gt;defersLoading();
4140 }
4141 
4142 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4143 {
4144     Document* document = contextDocument();
4145     if (!document)
4146         return nullptr;
4147 
4148     URL url = document-&gt;completeURL(path);
4149     if (!url.isLocalFile())
4150         return nullptr;
4151 
<span class="line-modified">4152     return File::create(url.fileSystemPath());</span>
4153 }
4154 
4155 void Internals::queueMicroTask(int testNumber)
4156 {
4157     Document* document = contextDocument();
4158     if (!document)
4159         return;
4160 
<span class="line-modified">4161     auto microtask = std::make_unique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *document, [document, testNumber]() {</span>
4162         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4163     });
4164 
4165     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));
4166 }
4167 
4168 #if ENABLE(CONTENT_FILTERING)
4169 
4170 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4171 {
4172     return MockContentFilterSettings::singleton();
4173 }
4174 
4175 #endif
4176 
4177 #if ENABLE(CSS_SCROLL_SNAP)
4178 
4179 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4180 {
4181     bool justStarting = true;
</pre>
<hr />
<pre>
4334     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
4335     globalObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(globalObject, &amp;state, privateName, propertySlot);
4336     value = propertySlot.getValue(&amp;state, privateName);
4337     ASSERT(value.isFunction(vm));
4338 
4339     JSObject* function = value.getObject();
4340     CallData callData;
4341     CallType callType = JSC::getCallData(vm, function, callData);
4342     ASSERT(callType != JSC::CallType::None);
4343     MarkedArgumentBuffer arguments;
4344     arguments.append(buffer);
4345     arguments.append(srcByteOffset);
4346     arguments.append(srcLength);
4347     ASSERT(!arguments.hasOverflowed());
4348 
4349     return JSC::call(&amp;state, function, callType, callData, JSC::jsUndefined(), arguments);
4350 }
4351 
4352 #endif
4353 
<span class="line-modified">4354 String Internals::resourceLoadStatisticsForOrigin(const String&amp; origin)</span>
4355 {
<span class="line-modified">4356     return ResourceLoadObserver::shared().statisticsForOrigin(origin);</span>




4357 }
4358 
4359 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4360 {
4361     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4362 }
4363 
<span class="line-removed">4364 void Internals::setUserGrantsStorageAccess(bool value)</span>
<span class="line-removed">4365 {</span>
<span class="line-removed">4366     Document* document = contextDocument();</span>
<span class="line-removed">4367     if (!document)</span>
<span class="line-removed">4368         return;</span>
<span class="line-removed">4369 </span>
<span class="line-removed">4370     document-&gt;setUserGrantsStorageAccessOverride(value);</span>
<span class="line-removed">4371 }</span>
<span class="line-removed">4372 </span>
4373 String Internals::composedTreeAsText(Node&amp; node)
4374 {
4375     if (!is&lt;ContainerNode&gt;(node))
4376         return emptyString();
4377     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4378 }
4379 
4380 bool Internals::isProcessingUserGesture()
4381 {
4382     return UserGestureIndicator::processingUserGesture();
4383 }
4384 
4385 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4386 {
4387     UserGestureIndicator gestureIndicator(ProcessingUserGesture, contextDocument());
4388     callback-&gt;handleEvent();
4389 }
4390 









4391 double Internals::lastHandledUserGestureTimestamp()
4392 {
4393     Document* document = contextDocument();
4394     if (!document)
4395         return 0;
4396 
4397     return document-&gt;lastHandledUserGestureTimestamp().secondsSinceEpoch().value();
4398 }
4399 
4400 RefPtr&lt;GCObservation&gt; Internals::observeGC(JSC::JSValue value)
4401 {
4402     if (!value.isObject())
4403         return nullptr;
4404     return GCObservation::create(asObject(value));
4405 }
4406 
4407 void Internals::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
4408 {
4409     Document* document = contextDocument();
4410     if (!document)
4411         return;
4412 
4413     Page* page = document-&gt;page();
4414     if (!page)
4415         return;
4416 
4417     page-&gt;setUserInterfaceLayoutDirection(userInterfaceLayoutDirection == UserInterfaceLayoutDirection::LTR ? WebCore::UserInterfaceLayoutDirection::LTR : WebCore::UserInterfaceLayoutDirection::RTL);
4418 }
4419 
4420 #if !PLATFORM(COCOA)
4421 
4422 bool Internals::userPrefersReducedMotion() const
4423 {
4424     return false;
4425 }
4426 







4427 #endif
4428 
4429 void Internals::reportBacktrace()
4430 {
4431     WTFReportBacktrace();
4432 }
4433 
4434 void Internals::setBaseWritingDirection(BaseWritingDirection direction)
4435 {
4436     if (auto* document = contextDocument()) {
4437         if (auto* frame = document-&gt;frame()) {
4438             switch (direction) {
4439             case BaseWritingDirection::Ltr:
4440                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::LeftToRight);
4441                 break;
4442             case BaseWritingDirection::Rtl:
4443                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::RightToLeft);
4444                 break;
4445             case BaseWritingDirection::Natural:
4446                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::Natural);
</pre>
<hr />
<pre>
4527             break;
4528         }
4529     }
4530 
4531     return accessKeyModifierStrings;
4532 }
4533 
4534 void Internals::setQuickLookPassword(const String&amp; password)
4535 {
4536 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4537     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
4538     PreviewLoader::setClientForTesting(&amp;quickLookHandleClient);
4539     quickLookHandleClient.setPassword(password);
4540 #else
4541     UNUSED_PARAM(password);
4542 #endif
4543 }
4544 
4545 void Internals::setAsRunningUserScripts(Document&amp; document)
4546 {
<span class="line-modified">4547     document.topDocument().setAsRunningUserScripts();</span>






4548 }

4549 
4550 #if ENABLE(WEBGL)
4551 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
4552 {
4553     context.simulateContextChanged();
4554 }
4555 
4556 void Internals::failNextGPUStatusCheck(WebGLRenderingContext&amp; context)
4557 {
4558     context.setFailNextGPUStatusCheck();
4559 }
4560 
4561 bool Internals::hasLowAndHighPowerGPUs()
4562 {
4563 #if PLATFORM(MAC)
4564     return WebCore::hasLowAndHighPowerGPUs();
4565 #else
4566     return false;
4567 #endif
4568 }
</pre>
<hr />
<pre>
4594 
4595     if (!isFocusedAndActive)
4596         state.remove({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4597     else
4598         state.add({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4599 
4600     page.setActivityState(state);
4601 }
4602 
4603 #if ENABLE(WEB_RTC)
4604 void Internals::setH264HardwareEncoderAllowed(bool allowed)
4605 {
4606     auto* document = contextDocument();
4607     if (!document || !document-&gt;page())
4608         return;
4609     document-&gt;page()-&gt;libWebRTCProvider().setH264HardwareEncoderAllowed(allowed);
4610 }
4611 #endif
4612 
4613 #if ENABLE(MEDIA_STREAM)







4614 
4615 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4616 {
4617     auto&amp; source = track.source();
4618     if (!source.isCaptureSource())
4619         return;
4620     m_orientationNotifier.orientationChanged(orientation);
4621     source.monitorOrientation(m_orientationNotifier);
4622 }
4623 
4624 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4625 {
4626     m_track = &amp;track;
4627     m_track-&gt;source().addObserver(*this);
4628 }
4629 
4630 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4631 {
4632     m_nextTrackFramePromise = WTFMove(promise);
4633 }
</pre>
<hr />
<pre>
4667 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4668 {
4669     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4670 }
4671 
4672 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4673 {
4674     track.source().captureFailed();
4675 }
4676 
4677 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4678 {
4679     track.setIdForTesting(WTFMove(id));
4680 }
4681 
4682 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4683 {
4684     track.source().setInterruptedForTesting(interrupted);
4685 }
4686 









4687 #endif
4688 
4689 String Internals::audioSessionCategory() const
4690 {
4691 #if USE(AUDIO_SESSION)
4692     switch (AudioSession::sharedSession().category()) {
4693     case AudioSession::AmbientSound:
4694         return &quot;AmbientSound&quot;_s;
4695     case AudioSession::SoloAmbientSound:
4696         return &quot;SoloAmbientSound&quot;_s;
4697     case AudioSession::MediaPlayback:
4698         return &quot;MediaPlayback&quot;_s;
4699     case AudioSession::RecordAudio:
4700         return &quot;RecordAudio&quot;_s;
4701     case AudioSession::PlayAndRecord:
4702         return &quot;PlayAndRecord&quot;_s;
4703     case AudioSession::AudioProcessing:
4704         return &quot;AudioProcessing&quot;_s;
4705     case AudioSession::None:
4706         return &quot;None&quot;_s;
</pre>
<hr />
<pre>
4708 #endif
4709     return emptyString();
4710 }
4711 
4712 double Internals::preferredAudioBufferSize() const
4713 {
4714 #if USE(AUDIO_SESSION)
4715     return AudioSession::sharedSession().preferredBufferSize();
4716 #endif
4717     return 0;
4718 }
4719 
4720 bool Internals::audioSessionActive() const
4721 {
4722 #if USE(AUDIO_SESSION)
4723     return AudioSession::sharedSession().isActive();
4724 #endif
4725     return false;
4726 }
4727 















4728 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4729 {
4730     auto* document = contextDocument();
4731     if (!document)
4732         return;
4733 
4734     if (!m_cacheStorageConnection) {
4735         if (auto* page = contextDocument()-&gt;page())
4736             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4737         if (!m_cacheStorageConnection)
4738             return;
4739     }
4740     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
4741         ASSERT_UNUSED(result, !result);
4742         promise.resolve();
4743     });
4744 }
4745 
4746 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
4747 {
4748     auto* document = contextDocument();
4749     if (!document)
4750         return;
4751 
4752     if (!m_cacheStorageConnection) {
4753         if (auto* page = contextDocument()-&gt;page())
4754             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4755         if (!m_cacheStorageConnection)
4756             return;
4757     }
4758     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
4759         promise.resolve(result);
4760     });
4761 }
4762 
















4763 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
4764 {
4765     if (!contextDocument())
4766         return;
4767 
4768     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
4769 }
4770 
4771 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
4772 {
4773     response.setBodySizeWithPadding(size);
4774 }
4775 
4776 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
4777 {
4778     return response.bodySizeWithPadding();
4779 }
4780 
4781 #if ENABLE(SERVICE_WORKER)
4782 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
</pre>
<hr />
<pre>
4850 
4851 void Internals::setCaptureExtraNetworkLoadMetricsEnabled(bool value)
4852 {
4853     platformStrategies()-&gt;loaderStrategy()-&gt;setCaptureExtraNetworkLoadMetricsEnabled(value);
4854 }
4855 
4856 String Internals::ongoingLoadsDescriptions() const
4857 {
4858     StringBuilder builder;
4859     builder.append(&#39;[&#39;);
4860     bool isStarting = true;
4861     for (auto&amp; identifier : platformStrategies()-&gt;loaderStrategy()-&gt;ongoingLoads()) {
4862         if (isStarting)
4863             isStarting = false;
4864         else
4865             builder.append(&#39;,&#39;);
4866 
4867         builder.append(&#39;[&#39;);
4868 
4869         for (auto&amp; info : platformStrategies()-&gt;loaderStrategy()-&gt;intermediateLoadInformationFromResourceLoadIdentifier(identifier))
<span class="line-modified">4870             builder.append(makeString(&quot;[&quot;, (int)info.type, &quot;,\&quot;&quot;, info.request.url().string(), &quot;\&quot;,\&quot;&quot;, info.request.httpMethod(), &quot;\&quot;,&quot;, info.response.httpStatusCode(), &quot;]&quot;));</span>
4871 
4872         builder.append(&#39;]&#39;);
4873     }
4874     builder.append(&#39;]&#39;);
4875     return builder.toString();
4876 }
4877 
4878 void Internals::reloadWithoutContentExtensions()
4879 {
4880     if (auto* frame = this-&gt;frame())
4881         frame-&gt;loader().reload(ReloadOption::DisableContentBlockers);
4882 }
4883 
4884 void Internals::setUseSystemAppearance(bool value)
4885 {
4886     if (!contextDocument() || !contextDocument()-&gt;page())
4887         return;
4888     contextDocument()-&gt;page()-&gt;setUseSystemAppearance(value);
4889 }
4890 
4891 size_t Internals::pluginCount()
4892 {
4893     if (!contextDocument() || !contextDocument()-&gt;page())
4894         return 0;
4895 
4896     return contextDocument()-&gt;page()-&gt;pluginData().webVisiblePlugins().size();
4897 }
4898 
4899 void Internals::notifyResourceLoadObserver()
4900 {
<span class="line-modified">4901     ResourceLoadObserver::shared().notifyObserver();</span>
4902 }
4903 
4904 unsigned Internals::primaryScreenDisplayID()
4905 {
4906 #if PLATFORM(MAC)
4907     return WebCore::primaryScreenDisplayID();
4908 #else
4909     return 0;
4910 #endif
4911 }
4912 
4913 bool Internals::capsLockIsOn()
4914 {
4915     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
4916 }
4917 
4918 bool Internals::supportsVCPEncoder()
4919 {
4920 #if defined(ENABLE_VCP_ENCODER)
<span class="line-modified">4921     return ENABLE_VCP_ENCODER;</span>
4922 #else
4923     return false;
4924 #endif
4925 }
4926 
4927 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
4928 {
4929     return WebCore::parseHEVCCodecParameters(codecString);
4930 }
4931 
4932 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
4933 {
4934     auto* document = contextDocument();
4935     if (!document)
4936         return { };
4937 
4938     auto* page = document-&gt;page();
4939     if (!page)
4940         return { };
4941 
4942     Vector&lt;Cookie&gt; cookies;
4943     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
4944     return WTF::map(cookies, [](auto&amp; cookie) {
4945         return CookieData { cookie };
4946     });
4947 }
4948 
4949 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
4950 {
4951     auto* localFrame = frame();
4952     if (!localFrame)
4953         return;
4954     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
4955 }
4956 
































































4957 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ActiveDOMCallbackMicrotask.h&quot;
  32 #include &quot;ActivityState.h&quot;
  33 #include &quot;AnimationTimeline.h&quot;
  34 #include &quot;ApplicationCacheStorage.h&quot;
  35 #include &quot;AudioSession.h&quot;
  36 #include &quot;Autofill.h&quot;
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSSupportsRule.h&quot;
  44 #include &quot;CacheStorageConnection.h&quot;
  45 #include &quot;CacheStorageProvider.h&quot;
  46 #include &quot;CachedImage.h&quot;
  47 #include &quot;CachedResourceLoader.h&quot;
  48 #include &quot;CertificateInfo.h&quot;
  49 #include &quot;Chrome.h&quot;
<span class="line-added">  50 #include &quot;ChromeClient.h&quot;</span>
  51 #include &quot;ClientOrigin.h&quot;
  52 #include &quot;ComposedTreeIterator.h&quot;
  53 #include &quot;CookieJar.h&quot;
  54 #include &quot;Cursor.h&quot;
<span class="line-added">  55 #include &quot;CustomHeaderFields.h&quot;</span>
  56 #include &quot;DOMRect.h&quot;
  57 #include &quot;DOMRectList.h&quot;
  58 #include &quot;DOMStringList.h&quot;
  59 #include &quot;DOMWindow.h&quot;
  60 #include &quot;DeprecatedGlobalSettings.h&quot;
<span class="line-added">  61 #include &quot;DiagnosticLoggingClient.h&quot;</span>
  62 #include &quot;DisabledAdaptations.h&quot;
  63 #include &quot;DisplayList.h&quot;
  64 #include &quot;Document.h&quot;
  65 #include &quot;DocumentLoader.h&quot;
  66 #include &quot;DocumentMarkerController.h&quot;
  67 #include &quot;DocumentTimeline.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;Element.h&quot;
  70 #include &quot;EventHandler.h&quot;
<span class="line-added">  71 #include &quot;EventListener.h&quot;</span>
<span class="line-added">  72 #include &quot;EventNames.h&quot;</span>
  73 #include &quot;ExtendableEvent.h&quot;
  74 #include &quot;ExtensionStyleSheets.h&quot;
  75 #include &quot;FetchResponse.h&quot;
  76 #include &quot;File.h&quot;
  77 #include &quot;FontCache.h&quot;
  78 #include &quot;FormController.h&quot;
  79 #include &quot;Frame.h&quot;
  80 #include &quot;FrameLoader.h&quot;
  81 #include &quot;FrameView.h&quot;
<span class="line-added">  82 #include &quot;FullscreenManager.h&quot;</span>
  83 #include &quot;GCObservation.h&quot;
  84 #include &quot;GridPosition.h&quot;
  85 #include &quot;HEVCUtilities.h&quot;
  86 #include &quot;HTMLAnchorElement.h&quot;
  87 #include &quot;HTMLCanvasElement.h&quot;
  88 #include &quot;HTMLIFrameElement.h&quot;
  89 #include &quot;HTMLImageElement.h&quot;
  90 #include &quot;HTMLInputElement.h&quot;
  91 #include &quot;HTMLLinkElement.h&quot;
  92 #include &quot;HTMLNames.h&quot;
  93 #include &quot;HTMLPictureElement.h&quot;
  94 #include &quot;HTMLPlugInElement.h&quot;
  95 #include &quot;HTMLPreloadScanner.h&quot;
  96 #include &quot;HTMLSelectElement.h&quot;
  97 #include &quot;HTMLTextAreaElement.h&quot;
  98 #include &quot;HTMLVideoElement.h&quot;
  99 #include &quot;HistoryController.h&quot;
 100 #include &quot;HistoryItem.h&quot;
 101 #include &quot;HitTestResult.h&quot;


 102 #include &quot;InspectorClient.h&quot;
 103 #include &quot;InspectorController.h&quot;
 104 #include &quot;InspectorFrontendClientLocal.h&quot;
 105 #include &quot;InspectorOverlay.h&quot;
 106 #include &quot;InstrumentingAgents.h&quot;
 107 #include &quot;IntRect.h&quot;
 108 #include &quot;InternalSettings.h&quot;
 109 #include &quot;JSImageData.h&quot;
 110 #include &quot;LibWebRTCProvider.h&quot;
 111 #include &quot;LoaderStrategy.h&quot;
 112 #include &quot;MallocStatistics.h&quot;
<span class="line-added"> 113 #include &quot;MediaDevices.h&quot;</span>
 114 #include &quot;MediaEngineConfigurationFactory.h&quot;
 115 #include &quot;MediaPlayer.h&quot;
 116 #include &quot;MediaProducer.h&quot;
 117 #include &quot;MediaResourceLoader.h&quot;
 118 #include &quot;MediaStreamTrack.h&quot;
 119 #include &quot;MemoryCache.h&quot;
 120 #include &quot;MemoryInfo.h&quot;
 121 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 122 #include &quot;MockPageOverlay.h&quot;
 123 #include &quot;MockPageOverlayClient.h&quot;
<span class="line-added"> 124 #include &quot;NavigatorMediaDevices.h&quot;</span>
 125 #include &quot;NetworkLoadInformation.h&quot;
 126 #include &quot;Page.h&quot;
 127 #include &quot;PageCache.h&quot;
 128 #include &quot;PageOverlay.h&quot;
 129 #include &quot;PathUtilities.h&quot;
 130 #include &quot;PlatformKeyboardEvent.h&quot;
 131 #include &quot;PlatformMediaSessionManager.h&quot;
 132 #include &quot;PlatformScreen.h&quot;
 133 #include &quot;PlatformStrategies.h&quot;
 134 #include &quot;PluginData.h&quot;
 135 #include &quot;PrintContext.h&quot;
 136 #include &quot;PseudoElement.h&quot;
 137 #include &quot;Range.h&quot;
 138 #include &quot;ReadableStream.h&quot;
 139 #include &quot;RenderEmbeddedObject.h&quot;
 140 #include &quot;RenderLayerBacking.h&quot;
 141 #include &quot;RenderLayerCompositor.h&quot;
 142 #include &quot;RenderMenuList.h&quot;
 143 #include &quot;RenderTreeAsText.h&quot;
 144 #include &quot;RenderView.h&quot;
</pre>
<hr />
<pre>
 202 #if ENABLE(INPUT_TYPE_COLOR)
 203 #include &quot;ColorChooser.h&quot;
 204 #endif
 205 
 206 #if ENABLE(MOUSE_CURSOR_SCALE)
 207 #include &lt;wtf/dtoa.h&gt;
 208 #endif
 209 
 210 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 211 #include &quot;LegacyCDM.h&quot;
 212 #include &quot;LegacyMockCDM.h&quot;
 213 #endif
 214 
 215 #if ENABLE(ENCRYPTED_MEDIA)
 216 #include &quot;MockCDMFactory.h&quot;
 217 #endif
 218 
 219 #if ENABLE(VIDEO_TRACK)
 220 #include &quot;CaptionUserPreferences.h&quot;
 221 #include &quot;PageGroup.h&quot;
<span class="line-added"> 222 #include &quot;TextTrackCueGeneric.h&quot;</span>
 223 #endif
 224 
 225 #if ENABLE(VIDEO)
 226 #include &quot;HTMLMediaElement.h&quot;
 227 #include &quot;TimeRanges.h&quot;
 228 #endif
 229 
 230 #if ENABLE(WEBGL)
 231 #include &quot;WebGLRenderingContext.h&quot;
 232 #endif
 233 
 234 #if ENABLE(SPEECH_SYNTHESIS)
 235 #include &quot;DOMWindowSpeechSynthesis.h&quot;
 236 #include &quot;PlatformSpeechSynthesizerMock.h&quot;
 237 #include &quot;SpeechSynthesis.h&quot;
 238 #endif
 239 
 240 #if ENABLE(MEDIA_STREAM)
 241 #include &quot;MediaRecorder.h&quot;
 242 #include &quot;MediaRecorderPrivateMock.h&quot;
</pre>
<hr />
<pre>
 256 #include &quot;MockContentFilterSettings.h&quot;
 257 #endif
 258 
 259 #if ENABLE(WEB_AUDIO)
 260 #include &quot;AudioContext.h&quot;
 261 #endif
 262 
 263 #if ENABLE(MEDIA_SESSION)
 264 #include &quot;MediaSession.h&quot;
 265 #include &quot;MediaSessionManager.h&quot;
 266 #endif
 267 
 268 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 269 #include &quot;MediaPlaybackTargetContext.h&quot;
 270 #endif
 271 
 272 #if ENABLE(POINTER_LOCK)
 273 #include &quot;PointerLockController.h&quot;
 274 #endif
 275 
<span class="line-added"> 276 #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added"> 277 #include &quot;IDBRequest.h&quot;</span>
<span class="line-added"> 278 #include &quot;IDBTransaction.h&quot;</span>
<span class="line-added"> 279 #endif</span>
<span class="line-added"> 280 </span>
 281 #if USE(QUICK_LOOK)
 282 #include &quot;MockPreviewLoaderClient.h&quot;
 283 #include &quot;PreviewLoader.h&quot;
 284 #endif
 285 
 286 #if ENABLE(APPLE_PAY)
 287 #include &quot;MockPaymentCoordinator.h&quot;
 288 #include &quot;PaymentCoordinator.h&quot;
 289 #endif
 290 
 291 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 292 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 293 #endif
 294 
 295 #if PLATFORM(MAC)
 296 #include &quot;GraphicsContext3DManager.h&quot;
 297 #endif
 298 
 299 using JSC::CallData;
 300 using JSC::CallType;
</pre>
<hr />
<pre>
 315 using namespace Inspector;
 316 
 317 using namespace HTMLNames;
 318 
 319 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 320 public:
 321     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 322     virtual ~InspectorStubFrontend();
 323 
 324 private:
 325     void attachWindow(DockSide) final { }
 326     void detachWindow() final { }
 327     void closeWindow() final;
 328     void reopen() final { }
 329     void bringToFront() final { }
 330     String localizedStringsURL() final { return String(); }
 331     void inspectedURLChanged(const String&amp;) final { }
 332     void showCertificate(const CertificateInfo&amp;) final { }
 333     void setAttachedWindowHeight(unsigned) final { }
 334     void setAttachedWindowWidth(unsigned) final { }
<span class="line-added"> 335     void setSheetRect(const FloatRect&amp;) final { }</span>
 336 
 337     void sendMessageToFrontend(const String&amp; message) final;
 338     ConnectionType connectionType() const final { return ConnectionType::Local; }
 339 








 340     RefPtr&lt;DOMWindow&gt; m_frontendWindow;

 341 };
 342 
 343 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
<span class="line-modified"> 344     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), makeUnique&lt;InspectorFrontendClientLocal::Settings&gt;())</span>
 345     , m_frontendWindow(frontendWindow.copyRef())

 346 {
 347     ASSERT_ARG(frontendWindow, frontendWindow);
 348 
<span class="line-modified"> 349     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(this);</span>
 350     inspectedPage.inspectorController().connectFrontend(*this);
 351 }
 352 
 353 InspectorStubFrontend::~InspectorStubFrontend()
 354 {
 355     closeWindow();
 356 }
 357 
 358 void InspectorStubFrontend::closeWindow()
 359 {
 360     if (!m_frontendWindow)
 361         return;
 362 
<span class="line-modified"> 363     frontendPage()-&gt;inspectorController().setInspectorFrontendClient(nullptr);</span>
 364     inspectedPage()-&gt;inspectorController().disconnectFrontend(*this);
 365 
 366     m_frontendWindow-&gt;close();
 367     m_frontendWindow = nullptr;
 368 }
 369 
 370 void InspectorStubFrontend::sendMessageToFrontend(const String&amp; message)
 371 {
<span class="line-modified"> 372     dispatchMessageAsync(message);</span>


 373 }
 374 
 375 static bool markerTypeFrom(const String&amp; markerType, DocumentMarker::MarkerType&amp; result)
 376 {
 377     if (equalLettersIgnoringASCIICase(markerType, &quot;spelling&quot;))
 378         result = DocumentMarker::Spelling;
 379     else if (equalLettersIgnoringASCIICase(markerType, &quot;grammar&quot;))
 380         result = DocumentMarker::Grammar;
 381     else if (equalLettersIgnoringASCIICase(markerType, &quot;textmatch&quot;))
 382         result = DocumentMarker::TextMatch;
 383     else if (equalLettersIgnoringASCIICase(markerType, &quot;replacement&quot;))
 384         result = DocumentMarker::Replacement;
 385     else if (equalLettersIgnoringASCIICase(markerType, &quot;correctionindicator&quot;))
 386         result = DocumentMarker::CorrectionIndicator;
 387     else if (equalLettersIgnoringASCIICase(markerType, &quot;rejectedcorrection&quot;))
 388         result = DocumentMarker::RejectedCorrection;
 389     else if (equalLettersIgnoringASCIICase(markerType, &quot;autocorrected&quot;))
 390         result = DocumentMarker::Autocorrected;
 391     else if (equalLettersIgnoringASCIICase(markerType, &quot;spellcheckingexemption&quot;))
 392         result = DocumentMarker::SpellCheckingExemption;
</pre>
<hr />
<pre>
 432 }
 433 
 434 Internals::~Internals()
 435 {
 436 #if ENABLE(MEDIA_STREAM)
 437     if (m_track)
 438         m_track-&gt;source().removeObserver(*this);
 439 #endif
 440 }
 441 
 442 void Internals::resetToConsistentState(Page&amp; page)
 443 {
 444     page.setPageScaleFactor(1, IntPoint(0, 0));
 445     page.setPagination(Pagination());
 446     page.setPaginationLineGridEnabled(false);
 447 
 448     page.setDefersLoading(false);
 449 
 450     page.mainFrame().setTextZoomFactor(1.0f);
 451 
<span class="line-modified"> 452     page.setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);</span>
 453 
 454     FrameView* mainFrameView = page.mainFrame().view();
 455     if (mainFrameView) {
 456         page.setHeaderHeight(0);
 457         page.setFooterHeight(0);
 458         page.setTopContentInset(0);
 459         mainFrameView-&gt;setUseFixedLayout(false);
 460         mainFrameView-&gt;setFixedLayoutSize(IntSize());
<span class="line-added"> 461         mainFrameView-&gt;enableAutoSizeMode(false, { });</span>
 462 #if USE(COORDINATED_GRAPHICS)
 463         mainFrameView-&gt;setFixedVisibleContentRect(IntRect());
 464 #endif
 465         if (auto* backing = mainFrameView-&gt;tiledBacking())
 466             backing-&gt;setTileSizeUpdateDelayDisabledForTesting(false);
 467     }
 468 
 469     WTF::clearDefaultPortForProtocolMapForTesting();
 470     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 471     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 472     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 473 #if ENABLE(VIDEO_TRACK)
 474     page.group().captionPreferences().setTestingMode(true);
 475     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 476     page.group().captionPreferences().setTestingMode(false);
 477 #endif
 478     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 479         page.mainFrame().editor().toggleContinuousSpellChecking();
 480     if (page.mainFrame().editor().isOverwriteModeEnabled())
 481         page.mainFrame().editor().toggleOverwriteModeEnabled();
 482     page.mainFrame().loader().clearTestingOverrides();
 483     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 484 #if ENABLE(VIDEO)
 485     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 486     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 487 #endif
<span class="line-modified"> 488     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(false);</span>
<span class="line-added"> 489 #if ENABLE(ACCESSIBILITY)</span>
 490     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 491     AXObjectCache::disableAccessibility();
 492 #endif
 493 
 494     MockPageOverlayClient::singleton().uninstallAllOverlays();
 495 
 496 #if ENABLE(CONTENT_FILTERING)
 497     MockContentFilterSettings::reset();
 498 #endif
 499 
 500 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 501     page.setMockMediaPlaybackTargetPickerEnabled(true);
 502     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 503 #endif
 504 
 505     page.setShowAllPlugins(false);
 506     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 507 
 508 #if USE(QUICK_LOOK)
 509     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
 510     PreviewLoader::setClientForTesting(nullptr);
 511 #endif
 512 
 513     printContextForTesting() = nullptr;
 514 
 515 #if USE(LIBWEBRTC)
 516     auto&amp; rtcProvider = page.libWebRTCProvider();
 517     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 518     rtcProvider.disableNonLocalhostConnections();
 519     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
<span class="line-added"> 520     page.settings().setWebRTCEncryptionEnabled(true);</span>
 521 #endif
 522 
 523     page.settings().setStorageAccessAPIEnabled(false);
 524     page.setFullscreenAutoHideDuration(0_s);
 525     page.setFullscreenInsets({ });
 526     page.setFullscreenControlsHidden(false);
 527 
 528     MediaEngineConfigurationFactory::disableMock();
<span class="line-added"> 529 </span>
<span class="line-added"> 530 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added"> 531     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(false);</span>
<span class="line-added"> 532 #endif</span>
 533 }
 534 
 535 Internals::Internals(Document&amp; document)
 536     : ContextDestructionObserver(&amp;document)
 537 #if ENABLE(MEDIA_STREAM)
 538     , m_orientationNotifier(0)
 539 #endif
 540 {
 541 #if ENABLE(VIDEO_TRACK)
 542     if (document.page())
 543         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 544 #endif
 545 
 546 #if ENABLE(MEDIA_STREAM)
 547     setMockMediaCaptureDevicesEnabled(true);
 548     setMediaCaptureRequiresSecureConnection(false);
 549 #endif
 550 
 551 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 552     if (document.page())
 553         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 554 #endif
 555 
 556     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 557         setAutomaticSpellingCorrectionEnabled(true);
 558         setAutomaticQuoteSubstitutionEnabled(false);
 559         setAutomaticDashSubstitutionEnabled(false);
 560         setAutomaticLinkDetectionEnabled(false);
 561         setAutomaticTextReplacementEnabled(true);
 562     }
 563 
 564     setConsoleMessageListener(nullptr);
 565 
 566 #if ENABLE(APPLE_PAY)
 567     auto* frame = document.frame();
 568     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 569         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
<span class="line-modified"> 570         frame-&gt;page()-&gt;setPaymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));</span>
 571     }
 572 #endif
 573 }
 574 
 575 Document* Internals::contextDocument() const
 576 {
 577     return downcast&lt;Document&gt;(scriptExecutionContext());
 578 }
 579 
 580 Frame* Internals::frame() const
 581 {
 582     if (!contextDocument())
 583         return nullptr;
 584     return contextDocument()-&gt;frame();
 585 }
 586 
 587 InternalSettings* Internals::settings() const
 588 {
 589     Document* document = contextDocument();
 590     if (!document)
</pre>
<hr />
<pre>
 819 static BitmapImage* bitmapImageFromImageElement(HTMLImageElement&amp; element)
 820 {
 821     auto* image = imageFromImageElement(element);
 822     return image &amp;&amp; is&lt;BitmapImage&gt;(image) ? &amp;downcast&lt;BitmapImage&gt;(*image) : nullptr;
 823 }
 824 
 825 #if USE(CG)
 826 static PDFDocumentImage* pdfDocumentImageFromImageElement(HTMLImageElement&amp; element)
 827 {
 828     auto* image = imageFromImageElement(element);
 829     return image &amp;&amp; is&lt;PDFDocumentImage&gt;(image) ? &amp;downcast&lt;PDFDocumentImage&gt;(*image) : nullptr;
 830 }
 831 #endif
 832 
 833 unsigned Internals::imageFrameIndex(HTMLImageElement&amp; element)
 834 {
 835     auto* bitmapImage = bitmapImageFromImageElement(element);
 836     return bitmapImage ? bitmapImage-&gt;currentFrame() : 0;
 837 }
 838 
<span class="line-added"> 839 unsigned Internals::imageFrameCount(HTMLImageElement&amp; element)</span>
<span class="line-added"> 840 {</span>
<span class="line-added"> 841     auto* bitmapImage = bitmapImageFromImageElement(element);</span>
<span class="line-added"> 842     return bitmapImage ? bitmapImage-&gt;frameCount() : 0;</span>
<span class="line-added"> 843 }</span>
<span class="line-added"> 844 </span>
<span class="line-added"> 845 float Internals::imageFrameDurationAtIndex(HTMLImageElement&amp; element, unsigned index)</span>
<span class="line-added"> 846 {</span>
<span class="line-added"> 847     auto* bitmapImage = bitmapImageFromImageElement(element);</span>
<span class="line-added"> 848     return bitmapImage ? bitmapImage-&gt;frameDurationAtIndex(index).value() : 0;</span>
<span class="line-added"> 849 }</span>
<span class="line-added"> 850 </span>
 851 void Internals::setImageFrameDecodingDuration(HTMLImageElement&amp; element, float duration)
 852 {
 853     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 854         bitmapImage-&gt;setFrameDecodingDurationForTesting(Seconds { duration });
 855 }
 856 
 857 void Internals::resetImageAnimation(HTMLImageElement&amp; element)
 858 {
 859     if (auto* image = imageFromImageElement(element))
 860         image-&gt;resetAnimation();
 861 }
 862 
 863 bool Internals::isImageAnimating(HTMLImageElement&amp; element)
 864 {
 865     auto* image = imageFromImageElement(element);
 866     return image &amp;&amp; (image-&gt;isAnimating() || image-&gt;animationPending());
 867 }
 868 
<span class="line-added"> 869 unsigned Internals::imagePendingDecodePromisesCountForTesting(HTMLImageElement&amp; element)</span>
<span class="line-added"> 870 {</span>
<span class="line-added"> 871     return element.pendingDecodePromisesCountForTesting();</span>
<span class="line-added"> 872 }</span>
<span class="line-added"> 873 </span>
 874 void Internals::setClearDecoderAfterAsyncFrameRequestForTesting(HTMLImageElement&amp; element, bool enabled)
 875 {
 876     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 877         bitmapImage-&gt;setClearDecoderAfterAsyncFrameRequestForTesting(enabled);
 878 }
 879 
 880 unsigned Internals::imageDecodeCount(HTMLImageElement&amp; element)
 881 {
 882     auto* bitmapImage = bitmapImageFromImageElement(element);
 883     return bitmapImage ? bitmapImage-&gt;decodeCountForTesting() : 0;
 884 }
 885 
 886 unsigned Internals::pdfDocumentCachingCount(HTMLImageElement&amp; element)
 887 {
 888 #if USE(CG)
 889     auto* pdfDocumentImage = pdfDocumentImageFromImageElement(element);
 890     return pdfDocumentImage ? pdfDocumentImage-&gt;cachingCountForTesting() : 0;
 891 #else
 892     UNUSED_PARAM(element);
 893     return 0;
</pre>
<hr />
<pre>
1035         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1036             if (Document* document = frame-&gt;document())
1037                 document-&gt;timeline().resumeAnimations();
1038         }
1039     } else {
1040         document-&gt;frame()-&gt;animation().resumeAnimationsForDocument(document);
1041 
1042         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1043             if (Document* document = frame-&gt;document())
1044                 frame-&gt;animation().resumeAnimationsForDocument(document);
1045         }
1046     }
1047 
1048     return { };
1049 }
1050 
1051 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnElement(const String&amp; animationName, double pauseTime, Element&amp; element)
1052 {
1053     if (pauseTime &lt; 0)
1054         return Exception { InvalidAccessError };
<span class="line-modified">1055     return frame()-&gt;animation().pauseAnimationAtTime(element, AtomString(animationName), pauseTime);</span>
1056 }
1057 
1058 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnPseudoElement(const String&amp; animationName, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1059 {
1060     if (pauseTime &lt; 0)
1061         return Exception { InvalidAccessError };
1062 
1063     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1064         return Exception { InvalidAccessError };
1065 
1066     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1067     if (!pseudoElement)
1068         return Exception { InvalidAccessError };
1069 
<span class="line-modified">1070     return frame()-&gt;animation().pauseAnimationAtTime(*pseudoElement, AtomString(animationName), pauseTime);</span>
1071 }
1072 
1073 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnElement(const String&amp; propertyName, double pauseTime, Element&amp; element)
1074 {
1075     if (pauseTime &lt; 0)
1076         return Exception { InvalidAccessError };
1077     return frame()-&gt;animation().pauseTransitionAtTime(element, propertyName, pauseTime);
1078 }
1079 
1080 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnPseudoElement(const String&amp; property, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1081 {
1082     if (pauseTime &lt; 0)
1083         return Exception { InvalidAccessError };
1084 
1085     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1086         return Exception { InvalidAccessError };
1087 
1088     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1089     if (!pseudoElement)
1090         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
1109         return frame()-&gt;document()-&gt;timeline().numberOfAnimationTimelineInvalidationsForTesting();
1110     return 0;
1111 }
1112 
1113 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; Internals::pseudoElement(Element&amp; element, const String&amp; pseudoId)
1114 {
1115     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1116         return Exception { InvalidAccessError };
1117 
1118     return pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1119 }
1120 
1121 ExceptionOr&lt;String&gt; Internals::elementRenderTreeAsText(Element&amp; element)
1122 {
1123     element.document().updateStyleIfNeeded();
1124 
1125     String representation = externalRepresentation(&amp;element);
1126     if (representation.isEmpty())
1127         return Exception { InvalidAccessError };
1128 
<span class="line-modified">1129     return representation;</span>
1130 }
1131 
1132 bool Internals::hasPausedImageAnimations(Element&amp; element)
1133 {
1134     return element.renderer() &amp;&amp; element.renderer()-&gt;hasPausedImageAnimations();
1135 }
1136 
1137 bool Internals::isPaintingFrequently(Element&amp; element)
1138 {
1139     return element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer() &amp;&amp; element.renderer()-&gt;enclosingLayer()-&gt;paintingFrequently();
1140 }
1141 
1142 void Internals::incrementFrequentPaintCounter(Element&amp; element)
1143 {
1144     if (element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer())
1145         element.renderer()-&gt;enclosingLayer()-&gt;simulateFrequentPaint();
1146 }
1147 
1148 Ref&lt;CSSComputedStyleDeclaration&gt; Internals::computedStyleIncludingVisitedInfo(Element&amp; element) const
1149 {
</pre>
<hr />
<pre>
1405     if (mainItem-&gt;target() == uniqueName)
1406         mainItem-&gt;setDocumentState(state);
1407     else if (HistoryItem* subItem = mainItem-&gt;childItemWithTarget(uniqueName))
1408         subItem-&gt;setDocumentState(state);
1409     else
1410         return Exception { InvalidAccessError };
1411     return { };
1412 }
1413 
1414 #if ENABLE(SPEECH_SYNTHESIS)
1415 
1416 void Internals::enableMockSpeechSynthesizer()
1417 {
1418     Document* document = contextDocument();
1419     if (!document || !document-&gt;domWindow())
1420         return;
1421     SpeechSynthesis* synthesis = DOMWindowSpeechSynthesis::speechSynthesis(*document-&gt;domWindow());
1422     if (!synthesis)
1423         return;
1424 
<span class="line-modified">1425     synthesis-&gt;setPlatformSynthesizer(makeUnique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));</span>
1426 }
1427 
1428 #endif
1429 
1430 #if ENABLE(WEB_RTC)
1431 
1432 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1433 {
1434     if (!LibWebRTCProvider::webRTCAvailable())
1435         return;
1436 
1437     connection.emulatePlatformEvent(action);
1438 }
1439 
1440 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1441 {
<span class="line-modified">1442     ASSERT(RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());</span>


1443     if (!LibWebRTCProvider::webRTCAvailable())
1444         return;
1445 
1446 #if USE(LIBWEBRTC)
1447     Document* document = contextDocument();
1448     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1449     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1450 #else
1451     UNUSED_PARAM(testCase);
1452 #endif
1453 }
1454 
1455 void Internals::setICECandidateFiltering(bool enabled)
1456 {
1457     auto* page = contextDocument()-&gt;page();
1458     if (!page)
1459         return;
1460 
1461     auto&amp; rtcController = page-&gt;rtcController();
1462     if (enabled)
</pre>
<hr />
<pre>
1483 }
1484 
1485 void Internals::stopPeerConnection(RTCPeerConnection&amp; connection)
1486 {
1487     ActiveDOMObject&amp; object = connection;
1488     object.stop();
1489 }
1490 
1491 void Internals::clearPeerConnectionFactory()
1492 {
1493 #if USE(LIBWEBRTC)
1494     if (auto* page = contextDocument()-&gt;page())
1495         page-&gt;libWebRTCProvider().clearFactory();
1496 #endif
1497 }
1498 
1499 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1500 {
1501     connection.applyRotationForOutgoingVideoSources();
1502 }
<span class="line-added">1503 </span>
<span class="line-added">1504 void Internals::setEnableWebRTCEncryption(bool value)</span>
<span class="line-added">1505 {</span>
<span class="line-added">1506 #if USE(LIBWEBRTC)</span>
<span class="line-added">1507     if (auto* page = contextDocument()-&gt;page())</span>
<span class="line-added">1508         page-&gt;settings().setWebRTCEncryptionEnabled(value);</span>
<span class="line-added">1509 #endif</span>
<span class="line-added">1510 }</span>
1511 #endif
1512 
1513 #if ENABLE(MEDIA_STREAM)
<span class="line-added">1514 void Internals::setShouldInterruptAudioOnPageVisibilityChange(bool shouldInterrupt)</span>
<span class="line-added">1515 {</span>
<span class="line-added">1516     RuntimeEnabledFeatures::sharedFeatures().setInterruptAudioOnPageVisibilityChangeEnabled(shouldInterrupt);</span>
<span class="line-added">1517 }</span>
1518 
1519 void Internals::setMockMediaCaptureDevicesEnabled(bool enabled)
1520 {
1521     Document* document = contextDocument();
1522     if (auto* page = document-&gt;page())
1523         page-&gt;settings().setMockCaptureDevicesEnabled(enabled);
1524 }
1525 
1526 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1527 {
1528     Document* document = contextDocument();
1529     if (auto* page = document-&gt;page())
1530         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1531 }
1532 
1533 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1534 {
1535     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1536 }
1537 
</pre>
<hr />
<pre>
1563 Ref&lt;DOMRect&gt; Internals::boundingBox(Element&amp; element)
1564 {
1565     element.document().updateLayoutIgnorePendingStylesheets();
1566     auto renderer = element.renderer();
1567     if (!renderer)
1568         return DOMRect::create();
1569     return DOMRect::create(renderer-&gt;absoluteBoundingBoxRectIgnoringTransforms());
1570 }
1571 
1572 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::inspectorHighlightRects()
1573 {
1574     Document* document = contextDocument();
1575     if (!document || !document-&gt;page())
1576         return Exception { InvalidAccessError };
1577 
1578     Highlight highlight;
1579     document-&gt;page()-&gt;inspectorController().getHighlight(highlight, InspectorOverlay::CoordinateSystem::View);
1580     return DOMRectList::create(highlight.quads);
1581 }
1582 









1583 ExceptionOr&lt;unsigned&gt; Internals::markerCountForNode(Node&amp; node, const String&amp; markerType)
1584 {
1585     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1586     if (!markerTypesFrom(markerType, markerTypes))
1587         return Exception { SyntaxError };
1588 
1589     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1590     return node.document().markers().markersFor(node, markerTypes).size();
1591 }
1592 
1593 ExceptionOr&lt;RenderedDocumentMarker*&gt; Internals::markerAt(Node&amp; node, const String&amp; markerType, unsigned index)
1594 {
1595     node.document().updateLayoutIgnorePendingStylesheets();
1596 
1597     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1598     if (!markerTypesFrom(markerType, markerTypes))
1599         return Exception { SyntaxError };
1600 
1601     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1602 
</pre>
<hr />
<pre>
1624         return result.releaseException();
1625     auto marker = result.releaseReturnValue();
1626     if (!marker)
1627         return String();
1628     return String { marker-&gt;description() };
1629 }
1630 
1631 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1632 {
1633     DocumentMarker::MarkerType markerType;
1634     if (!markerTypeFrom(markerTypeString, markerType))
1635         return Exception { SyntaxError };
1636 
1637     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1638     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1639 
1640     StringBuilder rectString;
1641     rectString.appendLiteral(&quot;marker rects: &quot;);
1642     for (const auto&amp; rect : rects) {
1643         rectString.append(&#39;(&#39;);
<span class="line-modified">1644         rectString.appendFixedPrecisionNumber(rect.x());</span>
1645         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1646         rectString.appendFixedPrecisionNumber(rect.y());</span>
1647         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1648         rectString.appendFixedPrecisionNumber(rect.width());</span>
1649         rectString.appendLiteral(&quot;, &quot;);
<span class="line-modified">1650         rectString.appendFixedPrecisionNumber(rect.height());</span>
1651         rectString.appendLiteral(&quot;) &quot;);
1652     }
1653     return rectString.toString();
1654 }
1655 
1656 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1657 {
1658     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1659     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1660 }
1661 
1662 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1663 {
1664     Document* document = contextDocument();
1665     if (!document || !document-&gt;frame())
1666         return Exception { InvalidAccessError };
1667     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1668     return { };
1669 }
1670 
</pre>
<hr />
<pre>
1837 {
1838     if (is&lt;HTMLInputElement&gt;(textField))
1839         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1840 
1841     if (is&lt;HTMLTextAreaElement&gt;(textField))
1842         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1843 
1844     return Exception { InvalidNodeTypeError };
1845 }
1846 
1847 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1848 {
1849     return element.shouldAutocomplete();
1850 }
1851 
1852 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
1853 {
1854     element.setAutoFilled(enabled);
1855 }
1856 
<span class="line-added">1857 void Internals::setAutoFilledAndViewable(HTMLInputElement&amp; element, bool enabled)</span>
<span class="line-added">1858 {</span>
<span class="line-added">1859     element.setAutoFilledAndViewable(enabled);</span>
<span class="line-added">1860 }</span>
<span class="line-added">1861 </span>
1862 static AutoFillButtonType toAutoFillButtonType(Internals::AutoFillButtonType type)
1863 {
1864     switch (type) {
1865     case Internals::AutoFillButtonType::None:
1866         return AutoFillButtonType::None;
1867     case Internals::AutoFillButtonType::Credentials:
1868         return AutoFillButtonType::Credentials;
1869     case Internals::AutoFillButtonType::Contacts:
1870         return AutoFillButtonType::Contacts;
1871     case Internals::AutoFillButtonType::StrongPassword:
1872         return AutoFillButtonType::StrongPassword;
1873     case Internals::AutoFillButtonType::CreditCard:
1874         return AutoFillButtonType::CreditCard;
1875     }
1876     ASSERT_NOT_REACHED();
1877     return AutoFillButtonType::None;
1878 }
1879 
1880 static Internals::AutoFillButtonType toInternalsAutoFillButtonType(AutoFillButtonType type)
1881 {
</pre>
<hr />
<pre>
1946 {
1947     size_t location = 0;
1948     size_t unusedLength = 0;
1949     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, location, unusedLength);
1950     return location;
1951 }
1952 
1953 unsigned Internals::lengthFromRange(Element&amp; scope, const Range&amp; range)
1954 {
1955     size_t unusedLocation = 0;
1956     size_t length = 0;
1957     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, unusedLocation, length);
1958     return length;
1959 }
1960 
1961 String Internals::rangeAsText(const Range&amp; range)
1962 {
1963     return range.text();
1964 }
1965 
<span class="line-added">1966 String Internals::rangeAsTextUsingBackwardsTextIterator(const Range&amp; range)</span>
<span class="line-added">1967 {</span>
<span class="line-added">1968     return plainTextUsingBackwardsTextIteratorForTesting(range);</span>
<span class="line-added">1969 }</span>
<span class="line-added">1970 </span>
1971 Ref&lt;Range&gt; Internals::subrange(Range&amp; range, int rangeLocation, int rangeLength)
1972 {
1973     return TextIterator::subrange(range, rangeLocation, rangeLength);
1974 }
1975 
1976 RefPtr&lt;Range&gt; Internals::rangeOfStringNearLocation(const Range&amp; searchRange, const String&amp; text, unsigned targetOffset)
1977 {
1978     return findClosestPlainText(searchRange, text, { }, targetOffset);
1979 }
1980 
1981 #if !PLATFORM(MAC)
1982 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeForDictionaryLookupAtLocation(int, int)
1983 {
1984     return Exception { InvalidAccessError };
1985 }
1986 #endif
1987 
1988 ExceptionOr&lt;void&gt; Internals::setDelegatesScrolling(bool enabled)
1989 {
1990     Document* document = contextDocument();
</pre>
<hr />
<pre>
2163     if (!code || code.isNull() || code.isUndefined()) {
2164         GetCallerCodeBlockFunctor iter;
2165         exec-&gt;iterate(iter);
2166         CodeBlock* codeBlock = iter.codeBlock();
2167         executable = codeBlock-&gt;ownerExecutable();
2168     } else if (code.isFunction(vm)) {
2169         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(exec));
2170         executable = funcObj-&gt;jsExecutable();
2171     } else
2172         return String();
2173 
2174     unsigned startLine = executable-&gt;firstLine();
2175     unsigned startColumn = executable-&gt;startColumn();
2176     unsigned endLine = executable-&gt;lastLine();
2177     unsigned endColumn = executable-&gt;endColumn();
2178 
2179     StringBuilder result;
2180 
2181     if (executable-&gt;isFunctionExecutable()) {
2182         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
<span class="line-modified">2183         String inferredName = funcExecutable-&gt;ecmaName().string();</span>
2184         result.appendLiteral(&quot;function \&quot;&quot;);
2185         result.append(inferredName);
2186         result.append(&#39;&quot;&#39;);
2187     } else if (executable-&gt;isEvalExecutable())
2188         result.appendLiteral(&quot;eval&quot;);
2189     else if (executable-&gt;isModuleProgramExecutable())
2190         result.appendLiteral(&quot;module&quot;);
2191     else if (executable-&gt;isProgramExecutable())
2192         result.appendLiteral(&quot;program&quot;);
2193     else
2194         ASSERT_NOT_REACHED();
2195 
2196     result.appendLiteral(&quot; { &quot;);
2197     result.appendNumber(startLine);
2198     result.append(&#39;:&#39;);
2199     result.appendNumber(startColumn);
2200     result.appendLiteral(&quot; - &quot;);
2201     result.appendNumber(endLine);
2202     result.append(&#39;:&#39;);
2203     result.appendNumber(endColumn);
</pre>
<hr />
<pre>
2254     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticQuoteSubstitutionEnabled())
2255         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticQuoteSubstitution();
2256 #else
2257     UNUSED_PARAM(enabled);
2258 #endif
2259 }
2260 
2261 void Internals::setAutomaticLinkDetectionEnabled(bool enabled)
2262 {
2263     if (!contextDocument() || !contextDocument()-&gt;frame())
2264         return;
2265 
2266 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2267     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticLinkDetectionEnabled())
2268         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticLinkDetection();
2269 #else
2270     UNUSED_PARAM(enabled);
2271 #endif
2272 }
2273 
<span class="line-added">2274 bool Internals::testProcessIncomingSyncMessagesWhenWaitingForSyncReply()</span>
<span class="line-added">2275 {</span>
<span class="line-added">2276     ASSERT(contextDocument());</span>
<span class="line-added">2277     ASSERT(contextDocument()-&gt;page());</span>
<span class="line-added">2278     return contextDocument()-&gt;page()-&gt;chrome().client().testProcessIncomingSyncMessagesWhenWaitingForSyncReply();</span>
<span class="line-added">2279 }</span>
<span class="line-added">2280 </span>
2281 void Internals::setAutomaticDashSubstitutionEnabled(bool enabled)
2282 {
2283     if (!contextDocument() || !contextDocument()-&gt;frame())
2284         return;
2285 
2286 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2287     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticDashSubstitutionEnabled())
2288         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticDashSubstitution();
2289 #else
2290     UNUSED_PARAM(enabled);
2291 #endif
2292 }
2293 
2294 void Internals::setAutomaticTextReplacementEnabled(bool enabled)
2295 {
2296     if (!contextDocument() || !contextDocument()-&gt;frame())
2297         return;
2298 
2299 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2300     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticTextReplacementEnabled())
</pre>
<hr />
<pre>
2366         {&quot;Backwards&quot;, Backwards},
2367         {&quot;WrapAround&quot;, WrapAround},
2368         {&quot;StartInSelection&quot;, StartInSelection},
2369         {&quot;DoNotRevealSelection&quot;, DoNotRevealSelection},
2370         {&quot;AtWordEnds&quot;, AtWordEnds},
2371         {&quot;DoNotTraverseFlatTree&quot;, DoNotTraverseFlatTree},
2372     };
2373     FindOptions result;
2374     for (auto&amp; option : optionList) {
2375         bool found = false;
2376         for (auto&amp; flag : flagList) {
2377             if (flag.name == option) {
2378                 result.add(flag.value);
2379                 found = true;
2380                 break;
2381             }
2382         }
2383         if (!found)
2384             return Exception { SyntaxError };
2385     }
<span class="line-modified">2386     return result;</span>
2387 }
2388 
2389 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeOfString(const String&amp; text, RefPtr&lt;Range&gt;&amp;&amp; referenceRange, const Vector&lt;String&gt;&amp; findOptions)
2390 {
2391     Document* document = contextDocument();
2392     if (!document || !document-&gt;frame())
2393         return Exception { InvalidAccessError };
2394 
2395     auto parsedOptions = parseFindOptions(findOptions);
2396     if (parsedOptions.hasException())
2397         return parsedOptions.releaseException();
2398 
2399     return document-&gt;frame()-&gt;editor().rangeOfString(text, referenceRange.get(), parsedOptions.releaseReturnValue());
2400 }
2401 
2402 ExceptionOr&lt;unsigned&gt; Internals::countMatchesForText(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions, const String&amp; markMatches)
2403 {
2404     Document* document = contextDocument();
2405     if (!document || !document-&gt;frame())
2406         return Exception { InvalidAccessError };
</pre>
<hr />
<pre>
2409     if (parsedOptions.hasException())
2410         return parsedOptions.releaseException();
2411 
2412     bool mark = markMatches == &quot;mark&quot;;
2413     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2414 }
2415 
2416 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2417 {
2418     Document* document = contextDocument();
2419     if (!document || !document-&gt;page())
2420         return Exception { InvalidAccessError };
2421 
2422     auto parsedOptions = parseFindOptions(findOptions);
2423     if (parsedOptions.hasException())
2424         return parsedOptions.releaseException();
2425 
2426     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2427 }
2428 
<span class="line-added">2429 #if ENABLE(INDEXED_DATABASE)</span>
2430 unsigned Internals::numberOfIDBTransactions() const
2431 {

2432     return IDBTransaction::numberOfIDBTransactions;



2433 }
<span class="line-added">2434 #endif</span>
2435 
2436 unsigned Internals::numberOfLiveNodes() const
2437 {
2438     unsigned nodeCount = 0;
2439     for (auto* document : Document::allDocuments())
2440         nodeCount += document-&gt;referencingNodeCount();
2441     return nodeCount;
2442 }
2443 
2444 unsigned Internals::numberOfLiveDocuments() const
2445 {
2446     return Document::allDocuments().size();
2447 }
2448 
2449 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2450 {
2451     return document.referencingNodeCount();
2452 }
2453 
2454 #if ENABLE(INTERSECTION_OBSERVER)
</pre>
<hr />
<pre>
2475 #else
2476     return false;
2477 #endif
2478 }
2479 
2480 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2481 {
2482 #if ENABLE(SERVICE_WORKER)
2483     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(document.sessionID()).serverConnectionIdentifier(), document.identifier() }.toString();
2484 #else
2485     UNUSED_PARAM(document);
2486     return String();
2487 #endif
2488 }
2489 
2490 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2491 {
2492     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2493     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2494     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
<span class="line-modified">2495     m_inspectorFrontend = makeUnique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));</span>
2496     return frontendWindowProxy;
2497 }
2498 
2499 void Internals::closeDummyInspectorFrontend()
2500 {
2501     m_inspectorFrontend = nullptr;
2502 }
2503 
2504 ExceptionOr&lt;void&gt; Internals::setInspectorIsUnderTest(bool isUnderTest)
2505 {
2506     Page* page = contextDocument()-&gt;frame()-&gt;page();
2507     if (!page)
2508         return Exception { InvalidAccessError };
2509 
2510     page-&gt;inspectorController().setIsUnderTest(isUnderTest);
2511     return { };
2512 }
2513 
2514 bool Internals::hasGrammarMarker(int from, int length)
2515 {
</pre>
<hr />
<pre>
2546         return Exception { InvalidAccessError };
2547 
2548     return document-&gt;isPageBoxVisible(pageNumber);
2549 }
2550 
2551 static LayerTreeFlags toLayerTreeFlags(unsigned short flags)
2552 {
2553     LayerTreeFlags layerTreeFlags = 0;
2554     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2555         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2556     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2557         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2558     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2559         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2560     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2561         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2562     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2563         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2564     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2565         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
<span class="line-added">2566     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CLIPPING)</span>
<span class="line-added">2567         layerTreeFlags |= LayerTreeFlagsIncludeClipping;</span>
2568     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2569         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2570     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2571         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
<span class="line-added">2572     if (flags &amp; Internals::LAYER_TREE_INCLUDES_EVENT_REGION)</span>
<span class="line-added">2573         layerTreeFlags |= LayerTreeFlagsIncludeEventRegion;</span>
2574 
2575     return layerTreeFlags;
2576 }
2577 
2578 // FIXME: Remove the document argument. It is almost always the same as
2579 // contextDocument(), with the exception of a few tests that pass a
2580 // different document, and could just make the call through another Internals
2581 // instance instead.
2582 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2583 {
2584     if (!document.frame())
2585         return Exception { InvalidAccessError };
2586 
2587     document.updateLayoutIgnorePendingStylesheets();
2588     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2589 }
2590 
2591 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2592 {
2593     Document* document = contextDocument();
</pre>
<hr />
<pre>
2995     Document* document = contextDocument();
2996     if (!document || !document-&gt;view())
2997         return Exception { InvalidAccessError };
2998 
2999     document-&gt;view()-&gt;setFixedLayoutSize(IntSize(width, height));
3000     return { };
3001 }
3002 
3003 ExceptionOr&lt;void&gt; Internals::setViewExposedRect(float x, float y, float width, float height)
3004 {
3005     Document* document = contextDocument();
3006     if (!document || !document-&gt;view())
3007         return Exception { InvalidAccessError };
3008 
3009     document-&gt;view()-&gt;setViewExposedRect(FloatRect(x, y, width, height));
3010     return { };
3011 }
3012 
3013 void Internals::setPrinting(int width, int height)
3014 {
<span class="line-modified">3015     printContextForTesting() = makeUnique&lt;PrintContext&gt;(frame());</span>
3016     printContextForTesting()-&gt;begin(width, height);
3017 }
3018 
3019 void Internals::setHeaderHeight(float height)
3020 {
3021     Document* document = contextDocument();
3022     if (!document || !document-&gt;view())
3023         return;
3024 
3025     document-&gt;page()-&gt;setHeaderHeight(height);
3026 }
3027 
3028 void Internals::setFooterHeight(float height)
3029 {
3030     Document* document = contextDocument();
3031     if (!document || !document-&gt;view())
3032         return;
3033 
3034     document-&gt;page()-&gt;setFooterHeight(height);
3035 }
3036 
3037 void Internals::setTopContentInset(float contentInset)
3038 {
3039     Document* document = contextDocument();
3040     if (!document || !document-&gt;page())
3041         return;
3042 
3043     document-&gt;page()-&gt;setTopContentInset(contentInset);
3044 }
3045 
3046 #if ENABLE(FULLSCREEN_API)
3047 
3048 void Internals::webkitWillEnterFullScreenForElement(Element&amp; element)
3049 {
3050     Document* document = contextDocument();
3051     if (!document)
3052         return;
<span class="line-modified">3053     document-&gt;fullscreenManager().willEnterFullscreen(element);</span>
3054 }
3055 
3056 void Internals::webkitDidEnterFullScreenForElement(Element&amp;)
3057 {
3058     Document* document = contextDocument();
3059     if (!document)
3060         return;
<span class="line-modified">3061     document-&gt;fullscreenManager().didEnterFullscreen();</span>
3062 }
3063 
3064 void Internals::webkitWillExitFullScreenForElement(Element&amp;)
3065 {
3066     Document* document = contextDocument();
3067     if (!document)
3068         return;
<span class="line-modified">3069     document-&gt;fullscreenManager().willExitFullscreen();</span>
3070 }
3071 
3072 void Internals::webkitDidExitFullScreenForElement(Element&amp;)
3073 {
3074     Document* document = contextDocument();
3075     if (!document)
3076         return;
<span class="line-modified">3077     document-&gt;fullscreenManager().didExitFullscreen();</span>
3078 }
3079 
3080 bool Internals::isAnimatingFullScreen() const
3081 {
3082     Document* document = contextDocument();
3083     if (!document)
3084         return false;
<span class="line-modified">3085     return document-&gt;fullscreenManager().isAnimatingFullscreen();</span>
3086 }
3087 
3088 #endif
3089 
3090 void Internals::setFullscreenInsets(FullscreenInsets insets)
3091 {
3092     Page* page = contextDocument()-&gt;frame()-&gt;page();
3093     ASSERT(page);
3094 
3095     page-&gt;setFullscreenInsets(FloatBoxExtent(insets.top, insets.right, insets.bottom, insets.left));
3096 }
3097 
3098 void Internals::setFullscreenAutoHideDuration(double duration)
3099 {
3100     Page* page = contextDocument()-&gt;frame()-&gt;page();
3101     ASSERT(page);
3102 
3103     page-&gt;setFullscreenAutoHideDuration(Seconds(duration));
3104 }
3105 
</pre>
<hr />
<pre>
3364 
3365 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3366 {
3367     Document* document = contextDocument();
3368     if (!document || !document-&gt;frame())
3369         return Exception { InvalidAccessError };
3370 
3371 #if !PLATFORM(IOS_FAMILY)
3372     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3373 
3374     StringBuilder result;
3375     result.appendLiteral(&quot;type=&quot;);
3376     result.append(cursorTypeToString(cursor.type()));
3377     result.appendLiteral(&quot; hotSpot=&quot;);
3378     result.appendNumber(cursor.hotSpot().x());
3379     result.append(&#39;,&#39;);
3380     result.appendNumber(cursor.hotSpot().y());
3381     if (cursor.image()) {
3382         FloatSize size = cursor.image()-&gt;size();
3383         result.appendLiteral(&quot; image=&quot;);
<span class="line-modified">3384         result.appendFixedPrecisionNumber(size.width());</span>
3385         result.append(&#39;x&#39;);
<span class="line-modified">3386         result.appendFixedPrecisionNumber(size.height());</span>
3387     }
3388 #if ENABLE(MOUSE_CURSOR_SCALE)
3389     if (cursor.imageScaleFactor() != 1) {
3390         result.appendLiteral(&quot; scale=&quot;);
<span class="line-modified">3391         result.appendFixedPrecisionNumber(cursor.imageScaleFactor(), 8);</span>
3392     }
3393 #endif
3394     return result.toString();
3395 #else
3396     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3397 #endif
3398 }
3399 
3400 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3401 {
3402     auto&amp; bytes = value-&gt;data();
3403     return ArrayBuffer::create(bytes.data(), bytes.size());
3404 }
3405 
3406 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3407 {
3408     Vector&lt;uint8_t&gt; bytes;
3409     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3410     return SerializedScriptValue::adopt(WTFMove(bytes));
3411 }
</pre>
<hr />
<pre>
3422 
3423 void Internals::setUsesMockScrollAnimator(bool enabled)
3424 {
3425     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3426 }
3427 
3428 void Internals::forceReload(bool endToEnd)
3429 {
3430     OptionSet&lt;ReloadOption&gt; reloadOptions;
3431     if (endToEnd)
3432         reloadOptions.add(ReloadOption::FromOrigin);
3433 
3434     frame()-&gt;loader().reload(reloadOptions);
3435 }
3436 
3437 void Internals::reloadExpiredOnly()
3438 {
3439     frame()-&gt;loader().reload(ReloadOption::ExpiredOnly);
3440 }
3441 
<span class="line-modified">3442 void Internals::enableAutoSizeMode(bool enabled, int width, int height)</span>
3443 {
3444     auto* document = contextDocument();
3445     if (!document || !document-&gt;view())
3446         return;
<span class="line-modified">3447     document-&gt;view()-&gt;enableAutoSizeMode(enabled, { width, height });</span>
3448 }
3449 
3450 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
3451 
3452 void Internals::initializeMockCDM()
3453 {
<span class="line-modified">3454     LegacyCDM::registerCDMFactory([] (LegacyCDM* cdm) { return makeUnique&lt;LegacyMockCDM&gt;(cdm); },</span>
3455         LegacyMockCDM::supportsKeySystem, LegacyMockCDM::supportsKeySystemAndMimeType);
3456 }
3457 
3458 #endif
3459 
3460 #if ENABLE(ENCRYPTED_MEDIA)
3461 
3462 Ref&lt;MockCDMFactory&gt; Internals::registerMockCDM()
3463 {
3464     return MockCDMFactory::create();
3465 }
3466 
3467 #endif
3468 
3469 String Internals::markerTextForListItem(Element&amp; element)
3470 {
3471     return WebCore::markerTextForListItem(&amp;element);
3472 }
3473 
3474 String Internals::toolTipFromElement(Element&amp; element) const
</pre>
<hr />
<pre>
3528     if (equalLettersIgnoringASCIICase(characteristic, &quot;legible&quot;))
3529         return element.hasClosedCaptions();
3530 
3531     return Exception { SyntaxError };
3532 }
3533 
3534 void Internals::beginSimulatedHDCPError(HTMLMediaElement&amp; element)
3535 {
3536     if (auto player = element.player())
3537         player-&gt;beginSimulatedHDCPError();
3538 }
3539 
3540 void Internals::endSimulatedHDCPError(HTMLMediaElement&amp; element)
3541 {
3542     if (auto player = element.player())
3543         player-&gt;endSimulatedHDCPError();
3544 }
3545 
3546 bool Internals::elementShouldBufferData(HTMLMediaElement&amp; element)
3547 {
<span class="line-modified">3548     return element.bufferingPolicy() &lt; MediaPlayer::BufferingPolicy::LimitReadAhead;</span>
3549 }
3550 
<span class="line-added">3551 String Internals::elementBufferingPolicy(HTMLMediaElement&amp; element)</span>
<span class="line-added">3552 {</span>
<span class="line-added">3553     switch (element.bufferingPolicy()) {</span>
<span class="line-added">3554     case MediaPlayer::BufferingPolicy::Default:</span>
<span class="line-added">3555         return &quot;Default&quot;;</span>
<span class="line-added">3556     case MediaPlayer::BufferingPolicy::LimitReadAhead:</span>
<span class="line-added">3557         return &quot;LimitReadAhead&quot;;</span>
<span class="line-added">3558     case MediaPlayer::BufferingPolicy::MakeResourcesPurgeable:</span>
<span class="line-added">3559         return &quot;MakeResourcesPurgeable&quot;;</span>
<span class="line-added">3560     case MediaPlayer::BufferingPolicy::PurgeResources:</span>
<span class="line-added">3561         return &quot;PurgeResources&quot;;</span>
<span class="line-added">3562     }</span>
<span class="line-added">3563 </span>
<span class="line-added">3564     ASSERT_NOT_REACHED();</span>
<span class="line-added">3565     return &quot;UNKNOWN&quot;;</span>
<span class="line-added">3566 }</span>
3567 #endif
3568 
3569 bool Internals::isSelectPopupVisible(HTMLSelectElement&amp; element)
3570 {
3571     element.document().updateLayoutIgnorePendingStylesheets();
3572 
3573     auto* renderer = element.renderer();
3574     if (!is&lt;RenderMenuList&gt;(renderer))
3575         return false;
3576 
3577 #if !PLATFORM(IOS_FAMILY)
3578     return downcast&lt;RenderMenuList&gt;(*renderer).popupIsVisible();
3579 #else
3580     return false;
3581 #endif
3582 }
3583 
3584 ExceptionOr&lt;String&gt; Internals::captionsStyleSheetOverride()
3585 {
3586     Document* document = contextDocument();
</pre>
<hr />
<pre>
3630 
3631 #if ENABLE(VIDEO_TRACK)
3632     auto&amp; captionPreferences = document-&gt;page()-&gt;group().captionPreferences();
3633 
3634     if (equalLettersIgnoringASCIICase(mode, &quot;automatic&quot;))
3635         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Automatic);
3636     else if (equalLettersIgnoringASCIICase(mode, &quot;forcedonly&quot;))
3637         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::ForcedOnly);
3638     else if (equalLettersIgnoringASCIICase(mode, &quot;alwayson&quot;))
3639         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::AlwaysOn);
3640     else if (equalLettersIgnoringASCIICase(mode, &quot;manual&quot;))
3641         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Manual);
3642     else
3643         return Exception { SyntaxError };
3644 #else
3645     UNUSED_PARAM(mode);
3646 #endif
3647     return { };
3648 }
3649 
<span class="line-added">3650 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-added">3651 RefPtr&lt;TextTrackCueGeneric&gt; Internals::createGenericCue(double startTime, double endTime, String text)</span>
<span class="line-added">3652 {</span>
<span class="line-added">3653     Document* document = contextDocument();</span>
<span class="line-added">3654     if (!document || !document-&gt;page())</span>
<span class="line-added">3655         return nullptr;</span>
<span class="line-added">3656     return TextTrackCueGeneric::create(*document, MediaTime::createWithDouble(startTime), MediaTime::createWithDouble(endTime), text);</span>
<span class="line-added">3657 }</span>
<span class="line-added">3658 #endif</span>
<span class="line-added">3659 </span>
3660 #if ENABLE(VIDEO)
3661 
3662 Ref&lt;TimeRanges&gt; Internals::createTimeRanges(Float32Array&amp; startTimes, Float32Array&amp; endTimes)
3663 {
3664     ASSERT(startTimes.length() == endTimes.length());
3665     Ref&lt;TimeRanges&gt; ranges = TimeRanges::create();
3666 
3667     unsigned count = std::min(startTimes.length(), endTimes.length());
3668     for (unsigned i = 0; i &lt; count; ++i)
3669         ranges-&gt;add(startTimes.item(i), endTimes.item(i));
3670     return ranges;
3671 }
3672 
3673 double Internals::closestTimeToTimeRanges(double time, TimeRanges&amp; ranges)
3674 {
3675     return ranges.nearest(time);
3676 }
3677 
3678 #endif
3679 
</pre>
<hr />
<pre>
3701     return downcast&lt;HTMLPlugInElement&gt;(element).isReplacementObscured();
3702 }
3703 
3704 ExceptionOr&lt;String&gt; Internals::unavailablePluginReplacementText(Element&amp; element)
3705 {
3706     if (!is&lt;HTMLPlugInElement&gt;(element))
3707         return Exception { InvalidAccessError };
3708 
3709     auto* renderer = element.renderer();
3710     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
3711         return String { };
3712 
3713     return String { downcast&lt;RenderEmbeddedObject&gt;(*renderer).pluginReplacementTextIfUnavailable() };
3714 }
3715 
3716 bool Internals::isPluginSnapshotted(Element&amp; element)
3717 {
3718     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot;
3719 }
3720 
<span class="line-added">3721 bool Internals::pluginIsBelowSizeThreshold(Element&amp; element)</span>
<span class="line-added">3722 {</span>
<span class="line-added">3723     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).isBelowSizeThreshold();</span>
<span class="line-added">3724 }</span>
<span class="line-added">3725 </span>
3726 #if ENABLE(MEDIA_SOURCE)
3727 
3728 void Internals::initializeMockMediaSource()
3729 {
3730 #if USE(AVFOUNDATION)
3731     WebCore::DeprecatedGlobalSettings::setAVFoundationEnabled(false);
3732 #endif
3733 #if USE(GSTREAMER)
3734     WebCore::DeprecatedGlobalSettings::setGStreamerEnabled(false);
3735 #endif
3736     MediaPlayerFactorySupport::callRegisterMediaEngine(MockMediaPlayerMediaSource::registerMediaEngine);
3737 }
3738 
<span class="line-modified">3739 Vector&lt;String&gt; Internals::bufferedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)</span>
3740 {
3741     return buffer.bufferedSamplesForTrackID(trackID);
3742 }
3743 
<span class="line-modified">3744 Vector&lt;String&gt; Internals::enqueuedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)</span>
3745 {
3746     return buffer.enqueuedSamplesForTrackID(trackID);
3747 }
3748 
<span class="line-added">3749 double Internals::minimumUpcomingPresentationTimeForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID)</span>
<span class="line-added">3750 {</span>
<span class="line-added">3751     return buffer.minimumUpcomingPresentationTimeForTrackID(trackID).toDouble();</span>
<span class="line-added">3752 }</span>
<span class="line-added">3753 </span>
3754 void Internals::setShouldGenerateTimestamps(SourceBuffer&amp; buffer, bool flag)
3755 {
3756     buffer.setShouldGenerateTimestamps(flag);
3757 }
3758 
<span class="line-added">3759 void Internals::setMaximumQueueDepthForTrackID(SourceBuffer&amp; buffer, const AtomString&amp; trackID, size_t maxQueueDepth)</span>
<span class="line-added">3760 {</span>
<span class="line-added">3761     buffer.setMaximumQueueDepthForTrackID(trackID, maxQueueDepth);</span>
<span class="line-added">3762 }</span>
<span class="line-added">3763 </span>
3764 #endif
3765 
3766 void Internals::enableMockMediaCapabilities()
3767 {
3768     MediaEngineConfigurationFactory::enableMock();
3769 }
3770 
3771 #if ENABLE(VIDEO)
3772 
3773 ExceptionOr&lt;void&gt; Internals::beginMediaSessionInterruption(const String&amp; interruptionString)
3774 {
3775     PlatformMediaSession::InterruptionType interruption = PlatformMediaSession::SystemInterruption;
3776 
3777     if (equalLettersIgnoringASCIICase(interruptionString, &quot;system&quot;))
3778         interruption = PlatformMediaSession::SystemInterruption;
3779     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;systemsleep&quot;))
3780         interruption = PlatformMediaSession::SystemSleep;
3781     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;enteringbackground&quot;))
3782         interruption = PlatformMediaSession::EnteringBackground;
3783     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;suspendedunderlock&quot;))
</pre>
<hr />
<pre>
3906         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
3907             restrictions |= MediaElementSession::NoRestrictions;
3908         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforload&quot;))
3909             restrictions |= MediaElementSession::RequireUserGestureForLoad;
3910         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforvideoratechange&quot;))
3911             restrictions |= MediaElementSession::RequireUserGestureForVideoRateChange;
3912         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforfullscreen&quot;))
3913             restrictions |= MediaElementSession::RequireUserGestureForFullscreen;
3914         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoloadmedia&quot;))
3915             restrictions |= MediaElementSession::RequirePageConsentToLoadMedia;
3916         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoresumemedia&quot;))
3917             restrictions |= MediaElementSession::RequirePageConsentToResumeMedia;
3918 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3919         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergesturetoshowplaybacktargetpicker&quot;))
3920             restrictions |= MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker;
3921         if (equalLettersIgnoringASCIICase(restrictionString, &quot;wirelessvideoplaybackdisabled&quot;))
3922             restrictions |= MediaElementSession::WirelessVideoPlaybackDisabled;
3923 #endif
3924         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudioratechange&quot;))
3925             restrictions |= MediaElementSession::RequireUserGestureForAudioRateChange;


3926         if (equalLettersIgnoringASCIICase(restrictionString, &quot;autopreloadingnotpermitted&quot;))
3927             restrictions |= MediaElementSession::AutoPreloadingNotPermitted;
3928         if (equalLettersIgnoringASCIICase(restrictionString, &quot;invisibleautoplaynotpermitted&quot;))
3929             restrictions |= MediaElementSession::InvisibleAutoplayNotPermitted;
3930         if (equalLettersIgnoringASCIICase(restrictionString, &quot;overrideusergesturerequirementformaincontent&quot;))
3931             restrictions |= MediaElementSession::OverrideUserGestureRequirementForMainContent;
3932     }
3933     element.mediaSession().addBehaviorRestriction(restrictions);
3934 }
3935 
3936 ExceptionOr&lt;void&gt; Internals::postRemoteControlCommand(const String&amp; commandString, float argument)
3937 {
3938     PlatformMediaSession::RemoteControlCommandType command;
3939     PlatformMediaSession::RemoteCommandArgument parameter { argument };
3940 
3941     if (equalLettersIgnoringASCIICase(commandString, &quot;play&quot;))
3942         command = PlatformMediaSession::PlayCommand;
3943     else if (equalLettersIgnoringASCIICase(commandString, &quot;pause&quot;))
3944         command = PlatformMediaSession::PauseCommand;
3945     else if (equalLettersIgnoringASCIICase(commandString, &quot;stop&quot;))
</pre>
<hr />
<pre>
4127     Document* document = contextDocument();
4128     if (!document || !document-&gt;page())
4129         return Exception { InvalidAccessError };
4130 
4131     document-&gt;updateLayoutIgnorePendingStylesheets();
4132 
4133     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
4134 }
4135 
4136 void Internals::setPageMuted(StringView statesString)
4137 {
4138     Document* document = contextDocument();
4139     if (!document)
4140         return;
4141 
4142     WebCore::MediaProducer::MutedStateFlags state = MediaProducer::NoneMuted;
4143     for (StringView stateString : statesString.split(&#39;,&#39;)) {
4144         if (equalLettersIgnoringASCIICase(stateString, &quot;audio&quot;))
4145             state |= MediaProducer::AudioIsMuted;
4146         if (equalLettersIgnoringASCIICase(stateString, &quot;capturedevices&quot;))
<span class="line-modified">4147             state |= MediaProducer::AudioAndVideoCaptureIsMuted;</span>
<span class="line-added">4148         if (equalLettersIgnoringASCIICase(stateString, &quot;screencapture&quot;))</span>
<span class="line-added">4149             state |= MediaProducer::ScreenCaptureIsMuted;</span>
4150     }
4151 
4152     if (Page* page = document-&gt;page())
4153         page-&gt;setMuted(state);
4154 }
4155 
4156 String Internals::pageMediaState()
4157 {
4158     Document* document = contextDocument();
4159     if (!document || !document-&gt;page())
4160         return emptyString();
4161 
4162     WebCore::MediaProducer::MediaStateFlags state = document-&gt;page()-&gt;mediaState();
4163     StringBuilder string;
4164     if (state &amp; MediaProducer::IsPlayingAudio)
4165         string.append(&quot;IsPlayingAudio,&quot;);
4166     if (state &amp; MediaProducer::IsPlayingVideo)
4167         string.append(&quot;IsPlayingVideo,&quot;);
4168     if (state &amp; MediaProducer::IsPlayingToExternalDevice)
4169         string.append(&quot;IsPlayingToExternalDevice,&quot;);
</pre>
<hr />
<pre>
4218 }
4219 
4220 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4221 {
4222     Document* document = contextDocument();
4223     if (!document || !document-&gt;page())
4224         return Exception { InvalidAccessError };
4225     return document-&gt;page()-&gt;defersLoading();
4226 }
4227 
4228 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4229 {
4230     Document* document = contextDocument();
4231     if (!document)
4232         return nullptr;
4233 
4234     URL url = document-&gt;completeURL(path);
4235     if (!url.isLocalFile())
4236         return nullptr;
4237 
<span class="line-modified">4238     return File::create(document-&gt;sessionID(), url.fileSystemPath());</span>
4239 }
4240 
4241 void Internals::queueMicroTask(int testNumber)
4242 {
4243     Document* document = contextDocument();
4244     if (!document)
4245         return;
4246 
<span class="line-modified">4247     auto microtask = makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *document, [document, testNumber]() {</span>
4248         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4249     });
4250 
4251     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));
4252 }
4253 
4254 #if ENABLE(CONTENT_FILTERING)
4255 
4256 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4257 {
4258     return MockContentFilterSettings::singleton();
4259 }
4260 
4261 #endif
4262 
4263 #if ENABLE(CSS_SCROLL_SNAP)
4264 
4265 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4266 {
4267     bool justStarting = true;
</pre>
<hr />
<pre>
4420     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
4421     globalObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(globalObject, &amp;state, privateName, propertySlot);
4422     value = propertySlot.getValue(&amp;state, privateName);
4423     ASSERT(value.isFunction(vm));
4424 
4425     JSObject* function = value.getObject();
4426     CallData callData;
4427     CallType callType = JSC::getCallData(vm, function, callData);
4428     ASSERT(callType != JSC::CallType::None);
4429     MarkedArgumentBuffer arguments;
4430     arguments.append(buffer);
4431     arguments.append(srcByteOffset);
4432     arguments.append(srcLength);
4433     ASSERT(!arguments.hasOverflowed());
4434 
4435     return JSC::call(&amp;state, function, callType, callData, JSC::jsUndefined(), arguments);
4436 }
4437 
4438 #endif
4439 
<span class="line-modified">4440 String Internals::resourceLoadStatisticsForURL(const DOMURL&amp; url)</span>
4441 {
<span class="line-modified">4442     auto* document = contextDocument();</span>
<span class="line-added">4443     if (!document)</span>
<span class="line-added">4444         return emptyString();</span>
<span class="line-added">4445 </span>
<span class="line-added">4446     return ResourceLoadObserver::shared().statisticsForURL(document-&gt;sessionID(), url.href());</span>
4447 }
4448 
4449 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4450 {
4451     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4452 }
4453 









4454 String Internals::composedTreeAsText(Node&amp; node)
4455 {
4456     if (!is&lt;ContainerNode&gt;(node))
4457         return emptyString();
4458     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4459 }
4460 
4461 bool Internals::isProcessingUserGesture()
4462 {
4463     return UserGestureIndicator::processingUserGesture();
4464 }
4465 
4466 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4467 {
4468     UserGestureIndicator gestureIndicator(ProcessingUserGesture, contextDocument());
4469     callback-&gt;handleEvent();
4470 }
4471 
<span class="line-added">4472 bool Internals::userIsInteracting()</span>
<span class="line-added">4473 {</span>
<span class="line-added">4474     if (auto* document = contextDocument()) {</span>
<span class="line-added">4475         if (auto* page = document-&gt;page())</span>
<span class="line-added">4476             return page-&gt;chrome().client().userIsInteracting();</span>
<span class="line-added">4477     }</span>
<span class="line-added">4478     return false;</span>
<span class="line-added">4479 }</span>
<span class="line-added">4480 </span>
4481 double Internals::lastHandledUserGestureTimestamp()
4482 {
4483     Document* document = contextDocument();
4484     if (!document)
4485         return 0;
4486 
4487     return document-&gt;lastHandledUserGestureTimestamp().secondsSinceEpoch().value();
4488 }
4489 
4490 RefPtr&lt;GCObservation&gt; Internals::observeGC(JSC::JSValue value)
4491 {
4492     if (!value.isObject())
4493         return nullptr;
4494     return GCObservation::create(asObject(value));
4495 }
4496 
4497 void Internals::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
4498 {
4499     Document* document = contextDocument();
4500     if (!document)
4501         return;
4502 
4503     Page* page = document-&gt;page();
4504     if (!page)
4505         return;
4506 
4507     page-&gt;setUserInterfaceLayoutDirection(userInterfaceLayoutDirection == UserInterfaceLayoutDirection::LTR ? WebCore::UserInterfaceLayoutDirection::LTR : WebCore::UserInterfaceLayoutDirection::RTL);
4508 }
4509 
4510 #if !PLATFORM(COCOA)
4511 
4512 bool Internals::userPrefersReducedMotion() const
4513 {
4514     return false;
4515 }
4516 
<span class="line-added">4517 #if ENABLE(VIDEO)</span>
<span class="line-added">4518 double Internals::privatePlayerVolume(const HTMLMediaElement&amp;)</span>
<span class="line-added">4519 {</span>
<span class="line-added">4520     return 0;</span>
<span class="line-added">4521 }</span>
<span class="line-added">4522 #endif</span>
<span class="line-added">4523 </span>
4524 #endif
4525 
4526 void Internals::reportBacktrace()
4527 {
4528     WTFReportBacktrace();
4529 }
4530 
4531 void Internals::setBaseWritingDirection(BaseWritingDirection direction)
4532 {
4533     if (auto* document = contextDocument()) {
4534         if (auto* frame = document-&gt;frame()) {
4535             switch (direction) {
4536             case BaseWritingDirection::Ltr:
4537                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::LeftToRight);
4538                 break;
4539             case BaseWritingDirection::Rtl:
4540                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::RightToLeft);
4541                 break;
4542             case BaseWritingDirection::Natural:
4543                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::Natural);
</pre>
<hr />
<pre>
4624             break;
4625         }
4626     }
4627 
4628     return accessKeyModifierStrings;
4629 }
4630 
4631 void Internals::setQuickLookPassword(const String&amp; password)
4632 {
4633 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4634     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
4635     PreviewLoader::setClientForTesting(&amp;quickLookHandleClient);
4636     quickLookHandleClient.setPassword(password);
4637 #else
4638     UNUSED_PARAM(password);
4639 #endif
4640 }
4641 
4642 void Internals::setAsRunningUserScripts(Document&amp; document)
4643 {
<span class="line-modified">4644     document.setAsRunningUserScripts();</span>
<span class="line-added">4645 }</span>
<span class="line-added">4646 </span>
<span class="line-added">4647 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">4648 void Internals::setApplePayIsActive(Document&amp; document)</span>
<span class="line-added">4649 {</span>
<span class="line-added">4650     document.setApplePayIsActive();</span>
4651 }
<span class="line-added">4652 #endif</span>
4653 
4654 #if ENABLE(WEBGL)
4655 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
4656 {
4657     context.simulateContextChanged();
4658 }
4659 
4660 void Internals::failNextGPUStatusCheck(WebGLRenderingContext&amp; context)
4661 {
4662     context.setFailNextGPUStatusCheck();
4663 }
4664 
4665 bool Internals::hasLowAndHighPowerGPUs()
4666 {
4667 #if PLATFORM(MAC)
4668     return WebCore::hasLowAndHighPowerGPUs();
4669 #else
4670     return false;
4671 #endif
4672 }
</pre>
<hr />
<pre>
4698 
4699     if (!isFocusedAndActive)
4700         state.remove({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4701     else
4702         state.add({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4703 
4704     page.setActivityState(state);
4705 }
4706 
4707 #if ENABLE(WEB_RTC)
4708 void Internals::setH264HardwareEncoderAllowed(bool allowed)
4709 {
4710     auto* document = contextDocument();
4711     if (!document || !document-&gt;page())
4712         return;
4713     document-&gt;page()-&gt;libWebRTCProvider().setH264HardwareEncoderAllowed(allowed);
4714 }
4715 #endif
4716 
4717 #if ENABLE(MEDIA_STREAM)
<span class="line-added">4718 void Internals::setMockAudioTrackChannelNumber(MediaStreamTrack&amp; track, unsigned short channelNumber)</span>
<span class="line-added">4719 {</span>
<span class="line-added">4720     auto&amp; source = track.source();</span>
<span class="line-added">4721     if (!is&lt;MockRealtimeAudioSource&gt;(source))</span>
<span class="line-added">4722         return;</span>
<span class="line-added">4723     downcast&lt;MockRealtimeAudioSource&gt;(source).setChannelCount(channelNumber);</span>
<span class="line-added">4724 }</span>
4725 
4726 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4727 {
4728     auto&amp; source = track.source();
4729     if (!source.isCaptureSource())
4730         return;
4731     m_orientationNotifier.orientationChanged(orientation);
4732     source.monitorOrientation(m_orientationNotifier);
4733 }
4734 
4735 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4736 {
4737     m_track = &amp;track;
4738     m_track-&gt;source().addObserver(*this);
4739 }
4740 
4741 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4742 {
4743     m_nextTrackFramePromise = WTFMove(promise);
4744 }
</pre>
<hr />
<pre>
4778 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4779 {
4780     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4781 }
4782 
4783 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4784 {
4785     track.source().captureFailed();
4786 }
4787 
4788 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4789 {
4790     track.setIdForTesting(WTFMove(id));
4791 }
4792 
4793 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4794 {
4795     track.source().setInterruptedForTesting(interrupted);
4796 }
4797 
<span class="line-added">4798 void Internals::setDisableGetDisplayMediaUserGestureConstraint(bool value)</span>
<span class="line-added">4799 {</span>
<span class="line-added">4800     Document* document = contextDocument();</span>
<span class="line-added">4801     if (!document || !document-&gt;domWindow())</span>
<span class="line-added">4802         return;</span>
<span class="line-added">4803 </span>
<span class="line-added">4804     if (auto* mediaDevices = NavigatorMediaDevices::mediaDevices(document-&gt;domWindow()-&gt;navigator()))</span>
<span class="line-added">4805         mediaDevices-&gt;setDisableGetDisplayMediaUserGestureConstraint(value);</span>
<span class="line-added">4806 }</span>
4807 #endif
4808 
4809 String Internals::audioSessionCategory() const
4810 {
4811 #if USE(AUDIO_SESSION)
4812     switch (AudioSession::sharedSession().category()) {
4813     case AudioSession::AmbientSound:
4814         return &quot;AmbientSound&quot;_s;
4815     case AudioSession::SoloAmbientSound:
4816         return &quot;SoloAmbientSound&quot;_s;
4817     case AudioSession::MediaPlayback:
4818         return &quot;MediaPlayback&quot;_s;
4819     case AudioSession::RecordAudio:
4820         return &quot;RecordAudio&quot;_s;
4821     case AudioSession::PlayAndRecord:
4822         return &quot;PlayAndRecord&quot;_s;
4823     case AudioSession::AudioProcessing:
4824         return &quot;AudioProcessing&quot;_s;
4825     case AudioSession::None:
4826         return &quot;None&quot;_s;
</pre>
<hr />
<pre>
4828 #endif
4829     return emptyString();
4830 }
4831 
4832 double Internals::preferredAudioBufferSize() const
4833 {
4834 #if USE(AUDIO_SESSION)
4835     return AudioSession::sharedSession().preferredBufferSize();
4836 #endif
4837     return 0;
4838 }
4839 
4840 bool Internals::audioSessionActive() const
4841 {
4842 #if USE(AUDIO_SESSION)
4843     return AudioSession::sharedSession().isActive();
4844 #endif
4845     return false;
4846 }
4847 
<span class="line-added">4848 void Internals::storeRegistrationsOnDisk(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)</span>
<span class="line-added">4849 {</span>
<span class="line-added">4850 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">4851     if (!contextDocument())</span>
<span class="line-added">4852         return;</span>
<span class="line-added">4853 </span>
<span class="line-added">4854     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID());</span>
<span class="line-added">4855     connection.storeRegistrationsOnDiskForTesting([promise = WTFMove(promise)]() mutable {</span>
<span class="line-added">4856         promise.resolve();</span>
<span class="line-added">4857     });</span>
<span class="line-added">4858 #else</span>
<span class="line-added">4859     promise.resolve();</span>
<span class="line-added">4860 #endif</span>
<span class="line-added">4861 }</span>
<span class="line-added">4862 </span>
4863 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4864 {
4865     auto* document = contextDocument();
4866     if (!document)
4867         return;
4868 
4869     if (!m_cacheStorageConnection) {
4870         if (auto* page = contextDocument()-&gt;page())
4871             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4872         if (!m_cacheStorageConnection)
4873             return;
4874     }
4875     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
4876         ASSERT_UNUSED(result, !result);
4877         promise.resolve();
4878     });
4879 }
4880 
4881 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
4882 {
4883     auto* document = contextDocument();
4884     if (!document)
4885         return;
4886 
4887     if (!m_cacheStorageConnection) {
4888         if (auto* page = contextDocument()-&gt;page())
4889             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4890         if (!m_cacheStorageConnection)
4891             return;
4892     }
4893     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
4894         promise.resolve(result);
4895     });
4896 }
4897 
<span class="line-added">4898 void Internals::updateQuotaBasedOnSpaceUsage()</span>
<span class="line-added">4899 {</span>
<span class="line-added">4900     auto* document = contextDocument();</span>
<span class="line-added">4901     if (!document)</span>
<span class="line-added">4902         return;</span>
<span class="line-added">4903 </span>
<span class="line-added">4904     if (!m_cacheStorageConnection) {</span>
<span class="line-added">4905         if (auto* page = contextDocument()-&gt;page())</span>
<span class="line-added">4906             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());</span>
<span class="line-added">4907         if (!m_cacheStorageConnection)</span>
<span class="line-added">4908             return;</span>
<span class="line-added">4909     }</span>
<span class="line-added">4910 </span>
<span class="line-added">4911     m_cacheStorageConnection-&gt;updateQuotaBasedOnSpaceUsage(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() });</span>
<span class="line-added">4912 }</span>
<span class="line-added">4913 </span>
4914 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
4915 {
4916     if (!contextDocument())
4917         return;
4918 
4919     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
4920 }
4921 
4922 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
4923 {
4924     response.setBodySizeWithPadding(size);
4925 }
4926 
4927 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
4928 {
4929     return response.bodySizeWithPadding();
4930 }
4931 
4932 #if ENABLE(SERVICE_WORKER)
4933 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
</pre>
<hr />
<pre>
5001 
5002 void Internals::setCaptureExtraNetworkLoadMetricsEnabled(bool value)
5003 {
5004     platformStrategies()-&gt;loaderStrategy()-&gt;setCaptureExtraNetworkLoadMetricsEnabled(value);
5005 }
5006 
5007 String Internals::ongoingLoadsDescriptions() const
5008 {
5009     StringBuilder builder;
5010     builder.append(&#39;[&#39;);
5011     bool isStarting = true;
5012     for (auto&amp; identifier : platformStrategies()-&gt;loaderStrategy()-&gt;ongoingLoads()) {
5013         if (isStarting)
5014             isStarting = false;
5015         else
5016             builder.append(&#39;,&#39;);
5017 
5018         builder.append(&#39;[&#39;);
5019 
5020         for (auto&amp; info : platformStrategies()-&gt;loaderStrategy()-&gt;intermediateLoadInformationFromResourceLoadIdentifier(identifier))
<span class="line-modified">5021             builder.append(&#39;[&#39;, (int)info.type, &quot;,\&quot;&quot;, info.request.url().string(), &quot;\&quot;,\&quot;&quot;, info.request.httpMethod(), &quot;\&quot;,&quot;, info.response.httpStatusCode(), &#39;]&#39;);</span>
5022 
5023         builder.append(&#39;]&#39;);
5024     }
5025     builder.append(&#39;]&#39;);
5026     return builder.toString();
5027 }
5028 
5029 void Internals::reloadWithoutContentExtensions()
5030 {
5031     if (auto* frame = this-&gt;frame())
5032         frame-&gt;loader().reload(ReloadOption::DisableContentBlockers);
5033 }
5034 
5035 void Internals::setUseSystemAppearance(bool value)
5036 {
5037     if (!contextDocument() || !contextDocument()-&gt;page())
5038         return;
5039     contextDocument()-&gt;page()-&gt;setUseSystemAppearance(value);
5040 }
5041 
5042 size_t Internals::pluginCount()
5043 {
5044     if (!contextDocument() || !contextDocument()-&gt;page())
5045         return 0;
5046 
5047     return contextDocument()-&gt;page()-&gt;pluginData().webVisiblePlugins().size();
5048 }
5049 
5050 void Internals::notifyResourceLoadObserver()
5051 {
<span class="line-modified">5052     ResourceLoadObserver::shared().updateCentralStatisticsStore();</span>
5053 }
5054 
5055 unsigned Internals::primaryScreenDisplayID()
5056 {
5057 #if PLATFORM(MAC)
5058     return WebCore::primaryScreenDisplayID();
5059 #else
5060     return 0;
5061 #endif
5062 }
5063 
5064 bool Internals::capsLockIsOn()
5065 {
5066     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
5067 }
5068 
5069 bool Internals::supportsVCPEncoder()
5070 {
5071 #if defined(ENABLE_VCP_ENCODER)
<span class="line-modified">5072     return ENABLE_VCP_ENCODER || ENABLE_VCP_VTB_ENCODER;</span>
5073 #else
5074     return false;
5075 #endif
5076 }
5077 
5078 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
5079 {
5080     return WebCore::parseHEVCCodecParameters(codecString);
5081 }
5082 
5083 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
5084 {
5085     auto* document = contextDocument();
5086     if (!document)
5087         return { };
5088 
5089     auto* page = document-&gt;page();
5090     if (!page)
5091         return { };
5092 
5093     Vector&lt;Cookie&gt; cookies;
5094     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
5095     return WTF::map(cookies, [](auto&amp; cookie) {
5096         return CookieData { cookie };
5097     });
5098 }
5099 
5100 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
5101 {
5102     auto* localFrame = frame();
5103     if (!localFrame)
5104         return;
5105     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
5106 }
5107 
<span class="line-added">5108 void Internals::processWillSuspend()</span>
<span class="line-added">5109 {</span>
<span class="line-added">5110     PlatformMediaSessionManager::sharedManager().processWillSuspend();</span>
<span class="line-added">5111 }</span>
<span class="line-added">5112 </span>
<span class="line-added">5113 void Internals::processDidResume()</span>
<span class="line-added">5114 {</span>
<span class="line-added">5115     PlatformMediaSessionManager::sharedManager().processDidResume();</span>
<span class="line-added">5116 }</span>
<span class="line-added">5117 </span>
<span class="line-added">5118 void Internals::testDictionaryLogging()</span>
<span class="line-added">5119 {</span>
<span class="line-added">5120     auto* document = contextDocument();</span>
<span class="line-added">5121     if (!document)</span>
<span class="line-added">5122         return;</span>
<span class="line-added">5123 </span>
<span class="line-added">5124     auto* page = document-&gt;page();</span>
<span class="line-added">5125     if (!page)</span>
<span class="line-added">5126         return;</span>
<span class="line-added">5127 </span>
<span class="line-added">5128     DiagnosticLoggingClient::ValueDictionary dictionary;</span>
<span class="line-added">5129     dictionary.set(&quot;stringKey&quot;_s, String(&quot;stringValue&quot;));</span>
<span class="line-added">5130     dictionary.set(&quot;uint64Key&quot;_s, std::numeric_limits&lt;uint64_t&gt;::max());</span>
<span class="line-added">5131     dictionary.set(&quot;int64Key&quot;_s, std::numeric_limits&lt;int64_t&gt;::min());</span>
<span class="line-added">5132     dictionary.set(&quot;boolKey&quot;_s, true);</span>
<span class="line-added">5133     dictionary.set(&quot;doubleKey&quot;_s, 2.7182818284590452353602874);</span>
<span class="line-added">5134 </span>
<span class="line-added">5135     page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValueDictionary(&quot;testMessage&quot;_s, &quot;testDescription&quot;_s, dictionary, ShouldSample::No);</span>
<span class="line-added">5136 }</span>
<span class="line-added">5137 </span>
<span class="line-added">5138 void Internals::setXHRMaximumIntervalForUserGestureForwarding(XMLHttpRequest&amp; request, double interval)</span>
<span class="line-added">5139 {</span>
<span class="line-added">5140     request.setMaximumIntervalForUserGestureForwarding(interval);</span>
<span class="line-added">5141 }</span>
<span class="line-added">5142 </span>
<span class="line-added">5143 void Internals::setIsPlayingToAutomotiveHeadUnit(bool isPlaying)</span>
<span class="line-added">5144 {</span>
<span class="line-added">5145     PlatformMediaSessionManager::sharedManager().setIsPlayingToAutomotiveHeadUnit(isPlaying);</span>
<span class="line-added">5146 }</span>
<span class="line-added">5147 </span>
<span class="line-added">5148 Internals::TextIndicatorInfo::TextIndicatorInfo()</span>
<span class="line-added">5149 {</span>
<span class="line-added">5150 }</span>
<span class="line-added">5151 </span>
<span class="line-added">5152 Internals::TextIndicatorInfo::TextIndicatorInfo(const WebCore::TextIndicatorData&amp; data)</span>
<span class="line-added">5153     : textBoundingRectInRootViewCoordinates(DOMRect::create(data.textBoundingRectInRootViewCoordinates))</span>
<span class="line-added">5154     , textRectsInBoundingRectCoordinates(DOMRectList::create(data.textRectsInBoundingRectCoordinates))</span>
<span class="line-added">5155 {</span>
<span class="line-added">5156 }</span>
<span class="line-added">5157 </span>
<span class="line-added">5158 Internals::TextIndicatorInfo::~TextIndicatorInfo() = default;</span>
<span class="line-added">5159 </span>
<span class="line-added">5160 Internals::TextIndicatorInfo Internals::textIndicatorForRange(const Range&amp; range, TextIndicatorOptions options)</span>
<span class="line-added">5161 {</span>
<span class="line-added">5162     auto indicator = TextIndicator::createWithRange(range, options.core(), TextIndicatorPresentationTransition::None);</span>
<span class="line-added">5163     return indicator-&gt;data();</span>
<span class="line-added">5164 }</span>
<span class="line-added">5165 </span>
<span class="line-added">5166 void Internals::addPrefetchLoadEventListener(HTMLLinkElement&amp; link, RefPtr&lt;EventListener&gt;&amp;&amp; listener)</span>
<span class="line-added">5167 {</span>
<span class="line-added">5168     if (RuntimeEnabledFeatures::sharedFeatures().linkPrefetchEnabled() &amp;&amp; equalLettersIgnoringASCIICase(link.rel(), &quot;prefetch&quot;))</span>
<span class="line-added">5169         link.addEventListener(eventNames().loadEvent, listener.releaseNonNull(), false);</span>
<span class="line-added">5170 }</span>
<span class="line-added">5171 </span>
5172 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InternalSettings.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Internals.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>