<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSInjectedScriptHost.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObjectInspectorController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInjectedScriptHost.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/JSInjectedScriptHost.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013, 2015-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSInjectedScriptHost.h&quot;
 28 
 29 #include &quot;ArrayIteratorPrototype.h&quot;
 30 #include &quot;ArrayPrototype.h&quot;
 31 #include &quot;BuiltinNames.h&quot;
 32 #include &quot;Completion.h&quot;
 33 #include &quot;DateInstance.h&quot;

 34 #include &quot;DirectArguments.h&quot;
 35 #include &quot;Error.h&quot;
 36 #include &quot;FunctionPrototype.h&quot;

 37 #include &quot;HeapIterationScope.h&quot;

 38 #include &quot;InjectedScriptHost.h&quot;
 39 #include &quot;IterationKind.h&quot;
 40 #include &quot;IteratorOperations.h&quot;
 41 #include &quot;IteratorPrototype.h&quot;
 42 #include &quot;JSArray.h&quot;
 43 #include &quot;JSBoundFunction.h&quot;
 44 #include &quot;JSCInlines.h&quot;
 45 #include &quot;JSFunction.h&quot;
 46 #include &quot;JSGlobalObjectFunctions.h&quot;
 47 #include &quot;JSInjectedScriptHostPrototype.h&quot;

 48 #include &quot;JSMap.h&quot;
 49 #include &quot;JSPromise.h&quot;
 50 #include &quot;JSPromisePrototype.h&quot;
 51 #include &quot;JSSet.h&quot;
 52 #include &quot;JSStringIterator.h&quot;
 53 #include &quot;JSTypedArrays.h&quot;
 54 #include &quot;JSWeakMap.h&quot;
 55 #include &quot;JSWeakSet.h&quot;
 56 #include &quot;JSWithScope.h&quot;
 57 #include &quot;MapIteratorPrototype.h&quot;
 58 #include &quot;MapPrototype.h&quot;
 59 #include &quot;MarkedSpaceInlines.h&quot;
 60 #include &quot;ObjectConstructor.h&quot;
 61 #include &quot;ObjectPrototype.h&quot;

 62 #include &quot;ProxyObject.h&quot;
 63 #include &quot;RegExpObject.h&quot;
 64 #include &quot;ScopedArguments.h&quot;
 65 #include &quot;SetIteratorPrototype.h&quot;
 66 #include &quot;SetPrototype.h&quot;
 67 #include &quot;SourceCode.h&quot;
 68 #include &quot;TypedArrayInlines.h&quot;








 69 
 70 using namespace JSC;
 71 
 72 namespace Inspector {
 73 
 74 const ClassInfo JSInjectedScriptHost::s_info = { &quot;InjectedScriptHost&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInjectedScriptHost) };
 75 
 76 JSInjectedScriptHost::JSInjectedScriptHost(VM&amp; vm, Structure* structure, Ref&lt;InjectedScriptHost&gt;&amp;&amp; impl)
 77     : JSDestructibleObject(vm, structure)
 78     , m_wrapped(WTFMove(impl))
 79 {
 80 }
 81 
 82 void JSInjectedScriptHost::finishCreation(VM&amp; vm)
 83 {
 84     Base::finishCreation(vm);
 85     ASSERT(inherits(vm, info()));
 86 }
 87 
 88 JSObject* JSInjectedScriptHost::createPrototype(VM&amp; vm, JSGlobalObject* globalObject)
 89 {
 90     return JSInjectedScriptHostPrototype::create(vm, globalObject, JSInjectedScriptHostPrototype::createStructure(vm, globalObject, globalObject-&gt;objectPrototype()));
 91 }
 92 
 93 void JSInjectedScriptHost::destroy(JSC::JSCell* cell)
 94 {
 95     JSInjectedScriptHost* thisObject = static_cast&lt;JSInjectedScriptHost*&gt;(cell);
 96     thisObject-&gt;JSInjectedScriptHost::~JSInjectedScriptHost();
 97 }
 98 
 99 JSValue JSInjectedScriptHost::evaluate(ExecState* exec) const
100 {
101     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
102     return globalObject-&gt;evalFunction();
103 }
104 








105 JSValue JSInjectedScriptHost::evaluateWithScopeExtension(ExecState* exec)
106 {
107     VM&amp; vm = exec-&gt;vm();
108     auto scope = DECLARE_THROW_SCOPE(vm);
109 
110     JSValue scriptValue = exec-&gt;argument(0);
111     if (!scriptValue.isString())
112         return throwTypeError(exec, scope, &quot;InjectedScriptHost.evaluateWithScopeExtension first argument must be a string.&quot;_s);
113 
114     String program = asString(scriptValue)-&gt;value(exec);
115     RETURN_IF_EXCEPTION(scope, JSValue());
116 
117     NakedPtr&lt;Exception&gt; exception;
118     JSObject* scopeExtension = exec-&gt;argument(1).getObject();
119     JSValue result = JSC::evaluateWithScopeExtension(exec, makeSource(program, exec-&gt;callerSourceOrigin()), scopeExtension, exception);
120     if (exception)
121         throwException(exec, scope, exception);
122 
123     return result;
124 }
125 
126 JSValue JSInjectedScriptHost::internalConstructorName(ExecState* exec)
127 {
128     if (exec-&gt;argumentCount() &lt; 1)
129         return jsUndefined();
130 

131     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0).toThis(exec, NotStrictMode));
<span class="line-modified">132     return jsString(exec, JSObject::calculatedClassName(object));</span>
133 }
134 
135 JSValue JSInjectedScriptHost::isHTMLAllCollection(ExecState* exec)
136 {
137     if (exec-&gt;argumentCount() &lt; 1)
138         return jsUndefined();
139 
140     VM&amp; vm = exec-&gt;vm();
141     JSValue value = exec-&gt;uncheckedArgument(0);
142     return jsBoolean(impl().isHTMLAllCollection(vm, value));
143 }
144 















145 JSValue JSInjectedScriptHost::subtype(ExecState* exec)
146 {
147     VM&amp; vm = exec-&gt;vm();
148     if (exec-&gt;argumentCount() &lt; 1)
149         return jsUndefined();
150 
151     JSValue value = exec-&gt;uncheckedArgument(0);
152     if (value.isString())
153         return vm.smallStrings.stringString();
154     if (value.isBoolean())
155         return vm.smallStrings.booleanString();
156     if (value.isNumber())
157         return vm.smallStrings.numberString();
158     if (value.isSymbol())
159         return vm.smallStrings.symbolString();
160 
161     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
162         if (object-&gt;isErrorInstance())
<span class="line-modified">163             return jsNontrivialString(exec, &quot;error&quot;_s);</span>
164 
165         // Consider class constructor functions class objects.
166         JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
167         if (function &amp;&amp; function-&gt;isClassConstructorFunction())
<span class="line-modified">168             return jsNontrivialString(exec, &quot;class&quot;_s);</span>
169 
170         if (object-&gt;inherits&lt;JSArray&gt;(vm))
<span class="line-modified">171             return jsNontrivialString(exec, &quot;array&quot;_s);</span>
172         if (object-&gt;inherits&lt;DirectArguments&gt;(vm) || object-&gt;inherits&lt;ScopedArguments&gt;(vm))
<span class="line-modified">173             return jsNontrivialString(exec, &quot;array&quot;_s);</span>
174 
175         if (object-&gt;inherits&lt;DateInstance&gt;(vm))
<span class="line-modified">176             return jsNontrivialString(exec, &quot;date&quot;_s);</span>
177         if (object-&gt;inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified">178             return jsNontrivialString(exec, &quot;regexp&quot;_s);</span>
179         if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">180             return jsNontrivialString(exec, &quot;proxy&quot;_s);</span>
181 
182         if (object-&gt;inherits&lt;JSMap&gt;(vm))
<span class="line-modified">183             return jsNontrivialString(exec, &quot;map&quot;_s);</span>
184         if (object-&gt;inherits&lt;JSSet&gt;(vm))
<span class="line-modified">185             return jsNontrivialString(exec, &quot;set&quot;_s);</span>
186         if (object-&gt;inherits&lt;JSWeakMap&gt;(vm))
<span class="line-modified">187             return jsNontrivialString(exec, &quot;weakmap&quot;_s);</span>
188         if (object-&gt;inherits&lt;JSWeakSet&gt;(vm))
<span class="line-modified">189             return jsNontrivialString(exec, &quot;weakset&quot;_s);</span>
190 
191         if (object-&gt;inherits&lt;JSStringIterator&gt;(vm))
<span class="line-modified">192             return jsNontrivialString(exec, &quot;iterator&quot;_s);</span>
193 
194         if (object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName())
195             || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())
196             || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName()))
<span class="line-modified">197             return jsNontrivialString(exec, &quot;iterator&quot;_s);</span>
198 
199         if (object-&gt;inherits&lt;JSInt8Array&gt;(vm)
200             || object-&gt;inherits&lt;JSInt16Array&gt;(vm)
201             || object-&gt;inherits&lt;JSInt32Array&gt;(vm)
202             || object-&gt;inherits&lt;JSUint8Array&gt;(vm)
203             || object-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm)
204             || object-&gt;inherits&lt;JSUint16Array&gt;(vm)
205             || object-&gt;inherits&lt;JSUint32Array&gt;(vm)
206             || object-&gt;inherits&lt;JSFloat32Array&gt;(vm)
207             || object-&gt;inherits&lt;JSFloat64Array&gt;(vm))
<span class="line-modified">208             return jsNontrivialString(exec, &quot;array&quot;_s);</span>
209     }
210 
211     return impl().subtype(exec, value);
212 }
213 
214 JSValue JSInjectedScriptHost::functionDetails(ExecState* exec)
215 {
216     if (exec-&gt;argumentCount() &lt; 1)
217         return jsUndefined();
218 
219     VM&amp; vm = exec-&gt;vm();
220     JSValue value = exec-&gt;uncheckedArgument(0);
221     auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
222     if (!function)
223         return jsUndefined();
224 
225     // FIXME: &lt;https://webkit.org/b/87192&gt; Web Inspector: Expose function scope / closure data
226 
227     // FIXME: This should provide better details for JSBoundFunctions.
228 
229     const SourceCode* sourceCode = function-&gt;sourceCode();
230     if (!sourceCode)
231         return jsUndefined();
232 
233     // In the inspector protocol all positions are 0-based while in SourceCode they are 1-based
234     int lineNumber = sourceCode-&gt;firstLine().oneBasedInt();
235     if (lineNumber)
236         lineNumber -= 1;
237     int columnNumber = sourceCode-&gt;startColumn().oneBasedInt();
238     if (columnNumber)
239         columnNumber -= 1;
240 
241     String scriptID = String::number(sourceCode-&gt;provider()-&gt;asID());
242     JSObject* location = constructEmptyObject(exec);
<span class="line-modified">243     location-&gt;putDirect(vm, Identifier::fromString(exec, &quot;scriptId&quot;), jsString(exec, scriptID));</span>
<span class="line-modified">244     location-&gt;putDirect(vm, Identifier::fromString(exec, &quot;lineNumber&quot;), jsNumber(lineNumber));</span>
<span class="line-modified">245     location-&gt;putDirect(vm, Identifier::fromString(exec, &quot;columnNumber&quot;), jsNumber(columnNumber));</span>
246 
247     JSObject* result = constructEmptyObject(exec);
<span class="line-modified">248     result-&gt;putDirect(vm, Identifier::fromString(exec, &quot;location&quot;), location);</span>
249 
250     String name = function-&gt;name(vm);
251     if (!name.isEmpty())
<span class="line-modified">252         result-&gt;putDirect(vm, Identifier::fromString(exec, &quot;name&quot;), jsString(exec, name));</span>
253 
254     String displayName = function-&gt;displayName(vm);
255     if (!displayName.isEmpty())
<span class="line-modified">256         result-&gt;putDirect(vm, Identifier::fromString(exec, &quot;displayName&quot;), jsString(exec, displayName));</span>
257 
258     return result;
259 }
260 
261 static JSObject* constructInternalProperty(ExecState* exec, const String&amp; name, JSValue value)
262 {
263     VM&amp; vm = exec-&gt;vm();
264     JSObject* result = constructEmptyObject(exec);
<span class="line-modified">265     result-&gt;putDirect(vm, Identifier::fromString(exec, &quot;name&quot;), jsString(exec, name));</span>
<span class="line-modified">266     result-&gt;putDirect(vm, Identifier::fromString(exec, &quot;value&quot;), value);</span>
267     return result;
268 }
269 
270 JSValue JSInjectedScriptHost::getInternalProperties(ExecState* exec)
271 {
272     if (exec-&gt;argumentCount() &lt; 1)
273         return jsUndefined();
274 
275     VM&amp; vm = exec-&gt;vm();
276     auto scope = DECLARE_THROW_SCOPE(vm);
277     JSValue value = exec-&gt;uncheckedArgument(0);
278 
279     JSValue internalProperties = impl().getInternalProperties(vm, exec, value);
280     if (internalProperties)
281         return internalProperties;
282 
283     if (JSPromise* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, value)) {
284         unsigned index = 0;
285         JSArray* array = constructEmptyArray(exec, nullptr);
286         RETURN_IF_EXCEPTION(scope, JSValue());
287         switch (promise-&gt;status(vm)) {
288         case JSPromise::Status::Pending:
289             scope.release();
<span class="line-modified">290             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(exec, &quot;pending&quot;_s)));</span>
291             return array;
292         case JSPromise::Status::Fulfilled:
<span class="line-modified">293             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(exec, &quot;resolved&quot;_s)));</span>
294             RETURN_IF_EXCEPTION(scope, JSValue());
295             scope.release();
296             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));
297             return array;
298         case JSPromise::Status::Rejected:
<span class="line-modified">299             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(exec, &quot;rejected&quot;_s)));</span>
300             RETURN_IF_EXCEPTION(scope, JSValue());
301             scope.release();
302             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));
303             return array;
304         }
305         // FIXME: &lt;https://webkit.org/b/141664&gt; Web Inspector: ES6: Improved Support for Promises - Promise Reactions
306         RELEASE_ASSERT_NOT_REACHED();
307     }
308 
309     if (JSBoundFunction* boundFunction = jsDynamicCast&lt;JSBoundFunction*&gt;(vm, value)) {
310         unsigned index = 0;
311         JSArray* array = constructEmptyArray(exec, nullptr);
312         RETURN_IF_EXCEPTION(scope, JSValue());
313         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;targetFunction&quot;, boundFunction-&gt;targetFunction()));
314         RETURN_IF_EXCEPTION(scope, JSValue());
315         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundThis&quot;, boundFunction-&gt;boundThis()));
316         RETURN_IF_EXCEPTION(scope, JSValue());
317         if (boundFunction-&gt;boundArgs()) {
318             scope.release();
319             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundArgs&quot;, boundFunction-&gt;boundArgsCopy(exec)));
</pre>
<hr />
<pre>
351         if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {
352             JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
353             String kind;
354             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()).asInt32())) {
355             case IterateKey:
356                 kind = &quot;key&quot;_s;
357                 break;
358             case IterateValue:
359                 kind = &quot;value&quot;_s;
360                 break;
361             case IterateKeyValue:
362                 kind = &quot;key+value&quot;_s;
363                 break;
364             }
365             unsigned index = 0;
366             JSArray* array = constructEmptyArray(exec, nullptr, 2);
367             RETURN_IF_EXCEPTION(scope, JSValue());
368             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;map&quot;, iteratedValue));
369             RETURN_IF_EXCEPTION(scope, JSValue());
370             scope.release();
<span class="line-modified">371             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(exec, kind)));</span>
372             return array;
373         }
374 
375         if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {
376             JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
377             String kind;
378             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()).asInt32())) {
379             case IterateKey:
380                 kind = &quot;key&quot;_s;
381                 break;
382             case IterateValue:
383                 kind = &quot;value&quot;_s;
384                 break;
385             case IterateKeyValue:
386                 kind = &quot;key+value&quot;_s;
387                 break;
388             }
389             unsigned index = 0;
390             JSArray* array = constructEmptyArray(exec, nullptr, 2);
391             RETURN_IF_EXCEPTION(scope, JSValue());
392             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;set&quot;, iteratedValue));
393             RETURN_IF_EXCEPTION(scope, JSValue());
394             scope.release();
<span class="line-modified">395             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(exec, kind)));</span>
396             return array;
397         }
398     }
399 
400     if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
401         unsigned index = 0;
402         JSArray* array = constructEmptyArray(exec, nullptr, 1);
403         RETURN_IF_EXCEPTION(scope, JSValue());
404         scope.release();
405         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;string&quot;, stringIterator-&gt;iteratedValue(exec)));
406         return array;
407     }
408 
409     return jsUndefined();
410 }
411 
412 JSValue JSInjectedScriptHost::proxyTargetValue(ExecState *exec)
413 {
414     if (exec-&gt;argumentCount() &lt; 1)
415         return jsUndefined();
</pre>
<hr />
<pre>
451     JSValue value = exec-&gt;uncheckedArgument(0);
452     JSWeakMap* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, value);
453     if (!weakMap)
454         return jsUndefined();
455 
456     unsigned numberToFetch = 100;
457 
458     JSValue numberToFetchArg = exec-&gt;argument(1);
459     double fetchDouble = numberToFetchArg.toInteger(exec);
460     if (fetchDouble &gt;= 0)
461         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
462 
463     JSArray* array = constructEmptyArray(exec, nullptr);
464     RETURN_IF_EXCEPTION(scope, JSValue());
465 
466     MarkedArgumentBuffer buffer;
467     weakMap-&gt;takeSnapshot(buffer, numberToFetch);
468 
469     for (unsigned index = 0; index &lt; buffer.size(); index += 2) {
470         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">471         entry-&gt;putDirect(vm, Identifier::fromString(exec, &quot;key&quot;), buffer.at(index));</span>
<span class="line-modified">472         entry-&gt;putDirect(vm, Identifier::fromString(exec, &quot;value&quot;), buffer.at(index + 1));</span>
473         array-&gt;putDirectIndex(exec, index / 2, entry);
474         RETURN_IF_EXCEPTION(scope, JSValue());
475     }
476 
477     return array;
478 }
479 
480 JSValue JSInjectedScriptHost::weakSetSize(ExecState* exec)
481 {
482     if (exec-&gt;argumentCount() &lt; 1)
483         return jsUndefined();
484 
485     VM&amp; vm = exec-&gt;vm();
486     JSValue value = exec-&gt;uncheckedArgument(0);
487     JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
488     if (!weakSet)
489         return jsUndefined();
490 
491     return jsNumber(weakSet-&gt;size());
492 }
</pre>
<hr />
<pre>
501     JSValue value = exec-&gt;uncheckedArgument(0);
502     JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
503     if (!weakSet)
504         return jsUndefined();
505 
506     unsigned numberToFetch = 100;
507 
508     JSValue numberToFetchArg = exec-&gt;argument(1);
509     double fetchDouble = numberToFetchArg.toInteger(exec);
510     if (fetchDouble &gt;= 0)
511         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
512 
513     JSArray* array = constructEmptyArray(exec, nullptr);
514     RETURN_IF_EXCEPTION(scope, JSValue());
515 
516     MarkedArgumentBuffer buffer;
517     weakSet-&gt;takeSnapshot(buffer, numberToFetch);
518 
519     for (unsigned index = 0; index &lt; buffer.size(); ++index) {
520         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">521         entry-&gt;putDirect(vm, Identifier::fromString(exec, &quot;value&quot;), buffer.at(index));</span>
522         array-&gt;putDirectIndex(exec, index, entry);
523         RETURN_IF_EXCEPTION(scope, JSValue());
524     }
525 
526     return array;
527 }
528 
529 static JSObject* cloneArrayIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue nextIndex, JSValue iteratedObject)
530 {
531     ASSERT(iteratorObject-&gt;type() == FinalObjectType);
532     JSObject* clone = constructEmptyObject(exec, ArrayIteratorPrototype::create(vm, globalObject, ArrayIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));
533     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
534     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName()));
535     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName(), nextIndex);
536     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName()));
537     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName()));
538     return clone;
539 }
540 
541 static JSObject* cloneMapIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue mapBucket, JSValue iteratedObject)
</pre>
<hr />
<pre>
600 
601     unsigned numberToFetch = 5;
602     JSValue numberToFetchArg = exec-&gt;argument(1);
603     double fetchDouble = numberToFetchArg.toInteger(exec);
604     RETURN_IF_EXCEPTION(scope, { });
605     if (fetchDouble &gt;= 0)
606         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
607 
608     JSArray* array = constructEmptyArray(exec, nullptr);
609     RETURN_IF_EXCEPTION(scope, { });
610 
611     for (unsigned i = 0; i &lt; numberToFetch; ++i) {
612         JSValue next = iteratorStep(exec, iterationRecord);
613         if (UNLIKELY(scope.exception()) || next.isFalse())
614             break;
615 
616         JSValue nextValue = iteratorValue(exec, next);
617         RETURN_IF_EXCEPTION(scope, { });
618 
619         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">620         entry-&gt;putDirect(vm, Identifier::fromString(exec, &quot;value&quot;), nextValue);</span>
621         array-&gt;putDirectIndex(exec, i, entry);
622         if (UNLIKELY(scope.exception())) {
623             scope.release();
624             iteratorClose(exec, iterationRecord);
625             break;
626         }
627     }
628 
629     return array;
630 }
631 
632 static bool checkForbiddenPrototype(ExecState* exec, JSValue value, JSValue proto)
633 {
634     if (value == proto)
635         return true;
636 
637     // Check that the prototype chain of proto hasn&#39;t been modified to include value.
638     return JSObject::defaultHasInstance(exec, proto, value);
639 }
640 
<span class="line-modified">641 JSValue JSInjectedScriptHost::queryObjects(ExecState* exec)</span>
642 {
643     if (exec-&gt;argumentCount() &lt; 1)
644         return jsUndefined();
645 
646     VM&amp; vm = exec-&gt;vm();
647     auto scope = DECLARE_THROW_SCOPE(vm);
648 
649     JSValue prototypeOrConstructor = exec-&gt;uncheckedArgument(0);
650     if (!prototypeOrConstructor.isObject())
<span class="line-modified">651         return throwTypeError(exec, scope, &quot;queryObjects first argument must be an object.&quot;_s);</span>
652 
653     JSObject* object = asObject(prototypeOrConstructor);
654     if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">655         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with a Proxy.&quot;_s);</span>
656 
657     JSValue prototype = object;
658 
659     PropertySlot prototypeSlot(object, PropertySlot::InternalMethodType::VMInquiry);
660     if (object-&gt;getPropertySlot(exec, vm.propertyNames-&gt;prototype, prototypeSlot)) {
661         RETURN_IF_EXCEPTION(scope, { });
662         if (prototypeSlot.isValue()) {
663             JSValue prototypeValue = prototypeSlot.getValue(exec, vm.propertyNames-&gt;prototype);
664             if (prototypeValue.isObject()) {
665                 prototype = prototypeValue;
666                 object = asObject(prototype);
667             }
668         }
669     }
670 
671     if (object-&gt;inherits&lt;ProxyObject&gt;(vm) || prototype.inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">672         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with a Proxy.&quot;_s);</span>
673 
674     // FIXME: implement a way of distinguishing between internal and user-created objects.
675     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();
676     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;objectPrototype()))
<span class="line-modified">677         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Object.&quot;_s);</span>
678     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;functionPrototype()))
<span class="line-modified">679         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Function.&quot;_s);</span>
680     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;arrayPrototype()))
<span class="line-modified">681         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Array.&quot;_s);</span>
682     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;mapPrototype()))
<span class="line-modified">683         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Map.&quot;_s);</span>
684     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;jsSetPrototype()))
<span class="line-modified">685         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Set.&quot;_s);</span>
686     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;promisePrototype()))
<span class="line-modified">687         return throwTypeError(exec, scope, &quot;queryObjects cannot be called with Promise.&quot;_s);</span>
688 
<span class="line-modified">689     sanitizeStackForVM(&amp;vm);</span>
690     vm.heap.collectNow(Sync, CollectionScope::Full);
691 
692     JSArray* array = constructEmptyArray(exec, nullptr);
693     RETURN_IF_EXCEPTION(scope, { });
694 
695     {
696         HeapIterationScope iterationScope(vm.heap);
697         vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* cell, HeapCell::Kind kind) {
698             if (!isJSCellKind(kind))
699                 return IterationStatus::Continue;
700 
701             JSValue value(static_cast&lt;JSCell*&gt;(cell));
702             if (value.inherits&lt;ProxyObject&gt;(vm))
703                 return IterationStatus::Continue;
704 
705             if (JSObject::defaultHasInstance(exec, value, prototype))
706                 array-&gt;putDirectIndex(exec, array-&gt;length(), value);
707 
708             return IterationStatus::Continue;
709         });
710     }
711 
712     return array;
713 }
714 





































































































































































715 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSInjectedScriptHost.h&quot;
 28 
 29 #include &quot;ArrayIteratorPrototype.h&quot;
 30 #include &quot;ArrayPrototype.h&quot;
 31 #include &quot;BuiltinNames.h&quot;
 32 #include &quot;Completion.h&quot;
 33 #include &quot;DateInstance.h&quot;
<span class="line-added"> 34 #include &quot;DeferGC.h&quot;</span>
 35 #include &quot;DirectArguments.h&quot;
 36 #include &quot;Error.h&quot;
 37 #include &quot;FunctionPrototype.h&quot;
<span class="line-added"> 38 #include &quot;HeapAnalyzer.h&quot;</span>
 39 #include &quot;HeapIterationScope.h&quot;
<span class="line-added"> 40 #include &quot;HeapProfiler.h&quot;</span>
 41 #include &quot;InjectedScriptHost.h&quot;
 42 #include &quot;IterationKind.h&quot;
 43 #include &quot;IteratorOperations.h&quot;
 44 #include &quot;IteratorPrototype.h&quot;
 45 #include &quot;JSArray.h&quot;
 46 #include &quot;JSBoundFunction.h&quot;
 47 #include &quot;JSCInlines.h&quot;
 48 #include &quot;JSFunction.h&quot;
 49 #include &quot;JSGlobalObjectFunctions.h&quot;
 50 #include &quot;JSInjectedScriptHostPrototype.h&quot;
<span class="line-added"> 51 #include &quot;JSLock.h&quot;</span>
 52 #include &quot;JSMap.h&quot;
 53 #include &quot;JSPromise.h&quot;
 54 #include &quot;JSPromisePrototype.h&quot;
 55 #include &quot;JSSet.h&quot;
 56 #include &quot;JSStringIterator.h&quot;
 57 #include &quot;JSTypedArrays.h&quot;
 58 #include &quot;JSWeakMap.h&quot;
 59 #include &quot;JSWeakSet.h&quot;
 60 #include &quot;JSWithScope.h&quot;
 61 #include &quot;MapIteratorPrototype.h&quot;
 62 #include &quot;MapPrototype.h&quot;
 63 #include &quot;MarkedSpaceInlines.h&quot;
 64 #include &quot;ObjectConstructor.h&quot;
 65 #include &quot;ObjectPrototype.h&quot;
<span class="line-added"> 66 #include &quot;PreventCollectionScope.h&quot;</span>
 67 #include &quot;ProxyObject.h&quot;
 68 #include &quot;RegExpObject.h&quot;
 69 #include &quot;ScopedArguments.h&quot;
 70 #include &quot;SetIteratorPrototype.h&quot;
 71 #include &quot;SetPrototype.h&quot;
 72 #include &quot;SourceCode.h&quot;
 73 #include &quot;TypedArrayInlines.h&quot;
<span class="line-added"> 74 #include &lt;wtf/Function.h&gt;</span>
<span class="line-added"> 75 #include &lt;wtf/HashFunctions.h&gt;</span>
<span class="line-added"> 76 #include &lt;wtf/HashMap.h&gt;</span>
<span class="line-added"> 77 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 78 #include &lt;wtf/HashTraits.h&gt;</span>
<span class="line-added"> 79 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added"> 80 #include &lt;wtf/PrintStream.h&gt;</span>
<span class="line-added"> 81 #include &lt;wtf/text/StringConcatenate.h&gt;</span>
 82 
 83 using namespace JSC;
 84 
 85 namespace Inspector {
 86 
 87 const ClassInfo JSInjectedScriptHost::s_info = { &quot;InjectedScriptHost&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSInjectedScriptHost) };
 88 
 89 JSInjectedScriptHost::JSInjectedScriptHost(VM&amp; vm, Structure* structure, Ref&lt;InjectedScriptHost&gt;&amp;&amp; impl)
 90     : JSDestructibleObject(vm, structure)
 91     , m_wrapped(WTFMove(impl))
 92 {
 93 }
 94 
 95 void JSInjectedScriptHost::finishCreation(VM&amp; vm)
 96 {
 97     Base::finishCreation(vm);
 98     ASSERT(inherits(vm, info()));
 99 }
100 
101 JSObject* JSInjectedScriptHost::createPrototype(VM&amp; vm, JSGlobalObject* globalObject)
102 {
103     return JSInjectedScriptHostPrototype::create(vm, globalObject, JSInjectedScriptHostPrototype::createStructure(vm, globalObject, globalObject-&gt;objectPrototype()));
104 }
105 
106 void JSInjectedScriptHost::destroy(JSC::JSCell* cell)
107 {
108     JSInjectedScriptHost* thisObject = static_cast&lt;JSInjectedScriptHost*&gt;(cell);
109     thisObject-&gt;JSInjectedScriptHost::~JSInjectedScriptHost();
110 }
111 
112 JSValue JSInjectedScriptHost::evaluate(ExecState* exec) const
113 {
114     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
115     return globalObject-&gt;evalFunction();
116 }
117 
<span class="line-added">118 JSValue JSInjectedScriptHost::savedResultAlias(ExecState* exec) const</span>
<span class="line-added">119 {</span>
<span class="line-added">120     auto savedResultAlias = impl().savedResultAlias();</span>
<span class="line-added">121     if (!savedResultAlias)</span>
<span class="line-added">122         return jsUndefined();</span>
<span class="line-added">123     return jsString(exec-&gt;vm(), savedResultAlias.value());</span>
<span class="line-added">124 }</span>
<span class="line-added">125 </span>
126 JSValue JSInjectedScriptHost::evaluateWithScopeExtension(ExecState* exec)
127 {
128     VM&amp; vm = exec-&gt;vm();
129     auto scope = DECLARE_THROW_SCOPE(vm);
130 
131     JSValue scriptValue = exec-&gt;argument(0);
132     if (!scriptValue.isString())
133         return throwTypeError(exec, scope, &quot;InjectedScriptHost.evaluateWithScopeExtension first argument must be a string.&quot;_s);
134 
135     String program = asString(scriptValue)-&gt;value(exec);
136     RETURN_IF_EXCEPTION(scope, JSValue());
137 
138     NakedPtr&lt;Exception&gt; exception;
139     JSObject* scopeExtension = exec-&gt;argument(1).getObject();
140     JSValue result = JSC::evaluateWithScopeExtension(exec, makeSource(program, exec-&gt;callerSourceOrigin()), scopeExtension, exception);
141     if (exception)
142         throwException(exec, scope, exception);
143 
144     return result;
145 }
146 
147 JSValue JSInjectedScriptHost::internalConstructorName(ExecState* exec)
148 {
149     if (exec-&gt;argumentCount() &lt; 1)
150         return jsUndefined();
151 
<span class="line-added">152     VM&amp; vm = exec-&gt;vm();</span>
153     JSObject* object = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedArgument(0).toThis(exec, NotStrictMode));
<span class="line-modified">154     return jsString(vm, JSObject::calculatedClassName(object));</span>
155 }
156 
157 JSValue JSInjectedScriptHost::isHTMLAllCollection(ExecState* exec)
158 {
159     if (exec-&gt;argumentCount() &lt; 1)
160         return jsUndefined();
161 
162     VM&amp; vm = exec-&gt;vm();
163     JSValue value = exec-&gt;uncheckedArgument(0);
164     return jsBoolean(impl().isHTMLAllCollection(vm, value));
165 }
166 
<span class="line-added">167 JSValue JSInjectedScriptHost::isPromiseRejectedWithNativeGetterTypeError(ExecState* exec)</span>
<span class="line-added">168 {</span>
<span class="line-added">169     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">170     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">171 </span>
<span class="line-added">172     auto* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, exec-&gt;argument(0));</span>
<span class="line-added">173     if (!promise || promise-&gt;status(vm) != JSPromise::Status::Rejected)</span>
<span class="line-added">174         return throwTypeError(exec, scope, &quot;InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError first argument must be a rejected Promise.&quot;_s);</span>
<span class="line-added">175 </span>
<span class="line-added">176     bool result = false;</span>
<span class="line-added">177     if (auto* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, promise-&gt;result(vm)))</span>
<span class="line-added">178         result = errorInstance-&gt;isNativeGetterTypeError();</span>
<span class="line-added">179     return jsBoolean(result);</span>
<span class="line-added">180 }</span>
<span class="line-added">181 </span>
182 JSValue JSInjectedScriptHost::subtype(ExecState* exec)
183 {
184     VM&amp; vm = exec-&gt;vm();
185     if (exec-&gt;argumentCount() &lt; 1)
186         return jsUndefined();
187 
188     JSValue value = exec-&gt;uncheckedArgument(0);
189     if (value.isString())
190         return vm.smallStrings.stringString();
191     if (value.isBoolean())
192         return vm.smallStrings.booleanString();
193     if (value.isNumber())
194         return vm.smallStrings.numberString();
195     if (value.isSymbol())
196         return vm.smallStrings.symbolString();
197 
198     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
199         if (object-&gt;isErrorInstance())
<span class="line-modified">200             return jsNontrivialString(vm, &quot;error&quot;_s);</span>
201 
202         // Consider class constructor functions class objects.
203         JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
204         if (function &amp;&amp; function-&gt;isClassConstructorFunction())
<span class="line-modified">205             return jsNontrivialString(vm, &quot;class&quot;_s);</span>
206 
207         if (object-&gt;inherits&lt;JSArray&gt;(vm))
<span class="line-modified">208             return jsNontrivialString(vm, &quot;array&quot;_s);</span>
209         if (object-&gt;inherits&lt;DirectArguments&gt;(vm) || object-&gt;inherits&lt;ScopedArguments&gt;(vm))
<span class="line-modified">210             return jsNontrivialString(vm, &quot;array&quot;_s);</span>
211 
212         if (object-&gt;inherits&lt;DateInstance&gt;(vm))
<span class="line-modified">213             return jsNontrivialString(vm, &quot;date&quot;_s);</span>
214         if (object-&gt;inherits&lt;RegExpObject&gt;(vm))
<span class="line-modified">215             return jsNontrivialString(vm, &quot;regexp&quot;_s);</span>
216         if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">217             return jsNontrivialString(vm, &quot;proxy&quot;_s);</span>
218 
219         if (object-&gt;inherits&lt;JSMap&gt;(vm))
<span class="line-modified">220             return jsNontrivialString(vm, &quot;map&quot;_s);</span>
221         if (object-&gt;inherits&lt;JSSet&gt;(vm))
<span class="line-modified">222             return jsNontrivialString(vm, &quot;set&quot;_s);</span>
223         if (object-&gt;inherits&lt;JSWeakMap&gt;(vm))
<span class="line-modified">224             return jsNontrivialString(vm, &quot;weakmap&quot;_s);</span>
225         if (object-&gt;inherits&lt;JSWeakSet&gt;(vm))
<span class="line-modified">226             return jsNontrivialString(vm, &quot;weakset&quot;_s);</span>
227 
228         if (object-&gt;inherits&lt;JSStringIterator&gt;(vm))
<span class="line-modified">229             return jsNontrivialString(vm, &quot;iterator&quot;_s);</span>
230 
231         if (object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName())
232             || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())
233             || object-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName()))
<span class="line-modified">234             return jsNontrivialString(vm, &quot;iterator&quot;_s);</span>
235 
236         if (object-&gt;inherits&lt;JSInt8Array&gt;(vm)
237             || object-&gt;inherits&lt;JSInt16Array&gt;(vm)
238             || object-&gt;inherits&lt;JSInt32Array&gt;(vm)
239             || object-&gt;inherits&lt;JSUint8Array&gt;(vm)
240             || object-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm)
241             || object-&gt;inherits&lt;JSUint16Array&gt;(vm)
242             || object-&gt;inherits&lt;JSUint32Array&gt;(vm)
243             || object-&gt;inherits&lt;JSFloat32Array&gt;(vm)
244             || object-&gt;inherits&lt;JSFloat64Array&gt;(vm))
<span class="line-modified">245             return jsNontrivialString(vm, &quot;array&quot;_s);</span>
246     }
247 
248     return impl().subtype(exec, value);
249 }
250 
251 JSValue JSInjectedScriptHost::functionDetails(ExecState* exec)
252 {
253     if (exec-&gt;argumentCount() &lt; 1)
254         return jsUndefined();
255 
256     VM&amp; vm = exec-&gt;vm();
257     JSValue value = exec-&gt;uncheckedArgument(0);
258     auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, value);
259     if (!function)
260         return jsUndefined();
261 
262     // FIXME: &lt;https://webkit.org/b/87192&gt; Web Inspector: Expose function scope / closure data
263 
264     // FIXME: This should provide better details for JSBoundFunctions.
265 
266     const SourceCode* sourceCode = function-&gt;sourceCode();
267     if (!sourceCode)
268         return jsUndefined();
269 
270     // In the inspector protocol all positions are 0-based while in SourceCode they are 1-based
271     int lineNumber = sourceCode-&gt;firstLine().oneBasedInt();
272     if (lineNumber)
273         lineNumber -= 1;
274     int columnNumber = sourceCode-&gt;startColumn().oneBasedInt();
275     if (columnNumber)
276         columnNumber -= 1;
277 
278     String scriptID = String::number(sourceCode-&gt;provider()-&gt;asID());
279     JSObject* location = constructEmptyObject(exec);
<span class="line-modified">280     location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;scriptId&quot;), jsString(vm, scriptID));</span>
<span class="line-modified">281     location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;lineNumber&quot;), jsNumber(lineNumber));</span>
<span class="line-modified">282     location-&gt;putDirect(vm, Identifier::fromString(vm, &quot;columnNumber&quot;), jsNumber(columnNumber));</span>
283 
284     JSObject* result = constructEmptyObject(exec);
<span class="line-modified">285     result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;location&quot;), location);</span>
286 
287     String name = function-&gt;name(vm);
288     if (!name.isEmpty())
<span class="line-modified">289         result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));</span>
290 
291     String displayName = function-&gt;displayName(vm);
292     if (!displayName.isEmpty())
<span class="line-modified">293         result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;displayName&quot;), jsString(vm, displayName));</span>
294 
295     return result;
296 }
297 
298 static JSObject* constructInternalProperty(ExecState* exec, const String&amp; name, JSValue value)
299 {
300     VM&amp; vm = exec-&gt;vm();
301     JSObject* result = constructEmptyObject(exec);
<span class="line-modified">302     result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;name&quot;), jsString(vm, name));</span>
<span class="line-modified">303     result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), value);</span>
304     return result;
305 }
306 
307 JSValue JSInjectedScriptHost::getInternalProperties(ExecState* exec)
308 {
309     if (exec-&gt;argumentCount() &lt; 1)
310         return jsUndefined();
311 
312     VM&amp; vm = exec-&gt;vm();
313     auto scope = DECLARE_THROW_SCOPE(vm);
314     JSValue value = exec-&gt;uncheckedArgument(0);
315 
316     JSValue internalProperties = impl().getInternalProperties(vm, exec, value);
317     if (internalProperties)
318         return internalProperties;
319 
320     if (JSPromise* promise = jsDynamicCast&lt;JSPromise*&gt;(vm, value)) {
321         unsigned index = 0;
322         JSArray* array = constructEmptyArray(exec, nullptr);
323         RETURN_IF_EXCEPTION(scope, JSValue());
324         switch (promise-&gt;status(vm)) {
325         case JSPromise::Status::Pending:
326             scope.release();
<span class="line-modified">327             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;pending&quot;_s)));</span>
328             return array;
329         case JSPromise::Status::Fulfilled:
<span class="line-modified">330             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;resolved&quot;_s)));</span>
331             RETURN_IF_EXCEPTION(scope, JSValue());
332             scope.release();
333             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));
334             return array;
335         case JSPromise::Status::Rejected:
<span class="line-modified">336             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;status&quot;_s, jsNontrivialString(vm, &quot;rejected&quot;_s)));</span>
337             RETURN_IF_EXCEPTION(scope, JSValue());
338             scope.release();
339             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;result&quot;_s, promise-&gt;result(vm)));
340             return array;
341         }
342         // FIXME: &lt;https://webkit.org/b/141664&gt; Web Inspector: ES6: Improved Support for Promises - Promise Reactions
343         RELEASE_ASSERT_NOT_REACHED();
344     }
345 
346     if (JSBoundFunction* boundFunction = jsDynamicCast&lt;JSBoundFunction*&gt;(vm, value)) {
347         unsigned index = 0;
348         JSArray* array = constructEmptyArray(exec, nullptr);
349         RETURN_IF_EXCEPTION(scope, JSValue());
350         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;targetFunction&quot;, boundFunction-&gt;targetFunction()));
351         RETURN_IF_EXCEPTION(scope, JSValue());
352         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundThis&quot;, boundFunction-&gt;boundThis()));
353         RETURN_IF_EXCEPTION(scope, JSValue());
354         if (boundFunction-&gt;boundArgs()) {
355             scope.release();
356             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;boundArgs&quot;, boundFunction-&gt;boundArgsCopy(exec)));
</pre>
<hr />
<pre>
388         if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapBucketPrivateName())) {
389             JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
390             String kind;
391             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().mapIteratorKindPrivateName()).asInt32())) {
392             case IterateKey:
393                 kind = &quot;key&quot;_s;
394                 break;
395             case IterateValue:
396                 kind = &quot;value&quot;_s;
397                 break;
398             case IterateKeyValue:
399                 kind = &quot;key+value&quot;_s;
400                 break;
401             }
402             unsigned index = 0;
403             JSArray* array = constructEmptyArray(exec, nullptr, 2);
404             RETURN_IF_EXCEPTION(scope, JSValue());
405             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;map&quot;, iteratedValue));
406             RETURN_IF_EXCEPTION(scope, JSValue());
407             scope.release();
<span class="line-modified">408             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(vm, kind)));</span>
409             return array;
410         }
411 
412         if (iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setBucketPrivateName())) {
413             JSValue iteratedValue = iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName());
414             String kind;
415             switch (static_cast&lt;IterationKind&gt;(iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().setIteratorKindPrivateName()).asInt32())) {
416             case IterateKey:
417                 kind = &quot;key&quot;_s;
418                 break;
419             case IterateValue:
420                 kind = &quot;value&quot;_s;
421                 break;
422             case IterateKeyValue:
423                 kind = &quot;key+value&quot;_s;
424                 break;
425             }
426             unsigned index = 0;
427             JSArray* array = constructEmptyArray(exec, nullptr, 2);
428             RETURN_IF_EXCEPTION(scope, JSValue());
429             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;set&quot;, iteratedValue));
430             RETURN_IF_EXCEPTION(scope, JSValue());
431             scope.release();
<span class="line-modified">432             array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;kind&quot;, jsNontrivialString(vm, kind)));</span>
433             return array;
434         }
435     }
436 
437     if (JSStringIterator* stringIterator = jsDynamicCast&lt;JSStringIterator*&gt;(vm, value)) {
438         unsigned index = 0;
439         JSArray* array = constructEmptyArray(exec, nullptr, 1);
440         RETURN_IF_EXCEPTION(scope, JSValue());
441         scope.release();
442         array-&gt;putDirectIndex(exec, index++, constructInternalProperty(exec, &quot;string&quot;, stringIterator-&gt;iteratedValue(exec)));
443         return array;
444     }
445 
446     return jsUndefined();
447 }
448 
449 JSValue JSInjectedScriptHost::proxyTargetValue(ExecState *exec)
450 {
451     if (exec-&gt;argumentCount() &lt; 1)
452         return jsUndefined();
</pre>
<hr />
<pre>
488     JSValue value = exec-&gt;uncheckedArgument(0);
489     JSWeakMap* weakMap = jsDynamicCast&lt;JSWeakMap*&gt;(vm, value);
490     if (!weakMap)
491         return jsUndefined();
492 
493     unsigned numberToFetch = 100;
494 
495     JSValue numberToFetchArg = exec-&gt;argument(1);
496     double fetchDouble = numberToFetchArg.toInteger(exec);
497     if (fetchDouble &gt;= 0)
498         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
499 
500     JSArray* array = constructEmptyArray(exec, nullptr);
501     RETURN_IF_EXCEPTION(scope, JSValue());
502 
503     MarkedArgumentBuffer buffer;
504     weakMap-&gt;takeSnapshot(buffer, numberToFetch);
505 
506     for (unsigned index = 0; index &lt; buffer.size(); index += 2) {
507         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">508         entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;key&quot;), buffer.at(index));</span>
<span class="line-modified">509         entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index + 1));</span>
510         array-&gt;putDirectIndex(exec, index / 2, entry);
511         RETURN_IF_EXCEPTION(scope, JSValue());
512     }
513 
514     return array;
515 }
516 
517 JSValue JSInjectedScriptHost::weakSetSize(ExecState* exec)
518 {
519     if (exec-&gt;argumentCount() &lt; 1)
520         return jsUndefined();
521 
522     VM&amp; vm = exec-&gt;vm();
523     JSValue value = exec-&gt;uncheckedArgument(0);
524     JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
525     if (!weakSet)
526         return jsUndefined();
527 
528     return jsNumber(weakSet-&gt;size());
529 }
</pre>
<hr />
<pre>
538     JSValue value = exec-&gt;uncheckedArgument(0);
539     JSWeakSet* weakSet = jsDynamicCast&lt;JSWeakSet*&gt;(vm, value);
540     if (!weakSet)
541         return jsUndefined();
542 
543     unsigned numberToFetch = 100;
544 
545     JSValue numberToFetchArg = exec-&gt;argument(1);
546     double fetchDouble = numberToFetchArg.toInteger(exec);
547     if (fetchDouble &gt;= 0)
548         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
549 
550     JSArray* array = constructEmptyArray(exec, nullptr);
551     RETURN_IF_EXCEPTION(scope, JSValue());
552 
553     MarkedArgumentBuffer buffer;
554     weakSet-&gt;takeSnapshot(buffer, numberToFetch);
555 
556     for (unsigned index = 0; index &lt; buffer.size(); ++index) {
557         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">558         entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), buffer.at(index));</span>
559         array-&gt;putDirectIndex(exec, index, entry);
560         RETURN_IF_EXCEPTION(scope, JSValue());
561     }
562 
563     return array;
564 }
565 
566 static JSObject* cloneArrayIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue nextIndex, JSValue iteratedObject)
567 {
568     ASSERT(iteratorObject-&gt;type() == FinalObjectType);
569     JSObject* clone = constructEmptyObject(exec, ArrayIteratorPrototype::create(vm, globalObject, ArrayIteratorPrototype::createStructure(vm, globalObject, globalObject-&gt;iteratorPrototype())));
570     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().iteratedObjectPrivateName(), iteratedObject);
571     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorKindPrivateName()));
572     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextIndexPrivateName(), nextIndex);
573     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorNextPrivateName()));
574     clone-&gt;putDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName(), iteratorObject-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().arrayIteratorIsDonePrivateName()));
575     return clone;
576 }
577 
578 static JSObject* cloneMapIteratorObject(ExecState* exec, VM&amp; vm, JSObject* iteratorObject, JSGlobalObject* globalObject, JSValue mapBucket, JSValue iteratedObject)
</pre>
<hr />
<pre>
637 
638     unsigned numberToFetch = 5;
639     JSValue numberToFetchArg = exec-&gt;argument(1);
640     double fetchDouble = numberToFetchArg.toInteger(exec);
641     RETURN_IF_EXCEPTION(scope, { });
642     if (fetchDouble &gt;= 0)
643         numberToFetch = static_cast&lt;unsigned&gt;(fetchDouble);
644 
645     JSArray* array = constructEmptyArray(exec, nullptr);
646     RETURN_IF_EXCEPTION(scope, { });
647 
648     for (unsigned i = 0; i &lt; numberToFetch; ++i) {
649         JSValue next = iteratorStep(exec, iterationRecord);
650         if (UNLIKELY(scope.exception()) || next.isFalse())
651             break;
652 
653         JSValue nextValue = iteratorValue(exec, next);
654         RETURN_IF_EXCEPTION(scope, { });
655 
656         JSObject* entry = constructEmptyObject(exec);
<span class="line-modified">657         entry-&gt;putDirect(vm, Identifier::fromString(vm, &quot;value&quot;), nextValue);</span>
658         array-&gt;putDirectIndex(exec, i, entry);
659         if (UNLIKELY(scope.exception())) {
660             scope.release();
661             iteratorClose(exec, iterationRecord);
662             break;
663         }
664     }
665 
666     return array;
667 }
668 
669 static bool checkForbiddenPrototype(ExecState* exec, JSValue value, JSValue proto)
670 {
671     if (value == proto)
672         return true;
673 
674     // Check that the prototype chain of proto hasn&#39;t been modified to include value.
675     return JSObject::defaultHasInstance(exec, proto, value);
676 }
677 
<span class="line-modified">678 JSValue JSInjectedScriptHost::queryInstances(ExecState* exec)</span>
679 {
680     if (exec-&gt;argumentCount() &lt; 1)
681         return jsUndefined();
682 
683     VM&amp; vm = exec-&gt;vm();
684     auto scope = DECLARE_THROW_SCOPE(vm);
685 
686     JSValue prototypeOrConstructor = exec-&gt;uncheckedArgument(0);
687     if (!prototypeOrConstructor.isObject())
<span class="line-modified">688         return throwTypeError(exec, scope, &quot;queryInstances first argument must be an object.&quot;_s);</span>
689 
690     JSObject* object = asObject(prototypeOrConstructor);
691     if (object-&gt;inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">692         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
693 
694     JSValue prototype = object;
695 
696     PropertySlot prototypeSlot(object, PropertySlot::InternalMethodType::VMInquiry);
697     if (object-&gt;getPropertySlot(exec, vm.propertyNames-&gt;prototype, prototypeSlot)) {
698         RETURN_IF_EXCEPTION(scope, { });
699         if (prototypeSlot.isValue()) {
700             JSValue prototypeValue = prototypeSlot.getValue(exec, vm.propertyNames-&gt;prototype);
701             if (prototypeValue.isObject()) {
702                 prototype = prototypeValue;
703                 object = asObject(prototype);
704             }
705         }
706     }
707 
708     if (object-&gt;inherits&lt;ProxyObject&gt;(vm) || prototype.inherits&lt;ProxyObject&gt;(vm))
<span class="line-modified">709         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with a Proxy.&quot;_s);</span>
710 
711     // FIXME: implement a way of distinguishing between internal and user-created objects.
712     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();
713     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;objectPrototype()))
<span class="line-modified">714         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Object.&quot;_s);</span>
715     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;functionPrototype()))
<span class="line-modified">716         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Function.&quot;_s);</span>
717     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;arrayPrototype()))
<span class="line-modified">718         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Array.&quot;_s);</span>
719     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;mapPrototype()))
<span class="line-modified">720         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Map.&quot;_s);</span>
721     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;jsSetPrototype()))
<span class="line-modified">722         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Set.&quot;_s);</span>
723     if (checkForbiddenPrototype(exec, object, lexicalGlobalObject-&gt;promisePrototype()))
<span class="line-modified">724         return throwTypeError(exec, scope, &quot;queryInstances cannot be called with Promise.&quot;_s);</span>
725 
<span class="line-modified">726     sanitizeStackForVM(vm);</span>
727     vm.heap.collectNow(Sync, CollectionScope::Full);
728 
729     JSArray* array = constructEmptyArray(exec, nullptr);
730     RETURN_IF_EXCEPTION(scope, { });
731 
732     {
733         HeapIterationScope iterationScope(vm.heap);
734         vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* cell, HeapCell::Kind kind) {
735             if (!isJSCellKind(kind))
736                 return IterationStatus::Continue;
737 
738             JSValue value(static_cast&lt;JSCell*&gt;(cell));
739             if (value.inherits&lt;ProxyObject&gt;(vm))
740                 return IterationStatus::Continue;
741 
742             if (JSObject::defaultHasInstance(exec, value, prototype))
743                 array-&gt;putDirectIndex(exec, array-&gt;length(), value);
744 
745             return IterationStatus::Continue;
746         });
747     }
748 
749     return array;
750 }
751 
<span class="line-added">752 class HeapHolderFinder final : public HeapAnalyzer {</span>
<span class="line-added">753     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">754 public:</span>
<span class="line-added">755     HeapHolderFinder(HeapProfiler&amp; profiler, JSCell* target)</span>
<span class="line-added">756         : HeapAnalyzer()</span>
<span class="line-added">757         , m_target(target)</span>
<span class="line-added">758     {</span>
<span class="line-added">759         ASSERT(!profiler.activeHeapAnalyzer());</span>
<span class="line-added">760         profiler.setActiveHeapAnalyzer(this);</span>
<span class="line-added">761         profiler.vm().heap.collectNow(Sync, CollectionScope::Full);</span>
<span class="line-added">762         profiler.setActiveHeapAnalyzer(nullptr);</span>
<span class="line-added">763 </span>
<span class="line-added">764         HashSet&lt;JSCell*&gt; queue;</span>
<span class="line-added">765 </span>
<span class="line-added">766         // Filter `m_holders` based on whether they&#39;re reachable from a non-Debugger root.</span>
<span class="line-added">767         HashSet&lt;JSCell*&gt; visited;</span>
<span class="line-added">768         for (auto* root : m_rootsToInclude)</span>
<span class="line-added">769             queue.add(root);</span>
<span class="line-added">770         while (auto* from = queue.takeAny()) {</span>
<span class="line-added">771             if (m_rootsToIgnore.contains(from))</span>
<span class="line-added">772                 continue;</span>
<span class="line-added">773             if (!visited.add(from).isNewEntry)</span>
<span class="line-added">774                 continue;</span>
<span class="line-added">775             for (auto* to : m_successors.get(from))</span>
<span class="line-added">776                 queue.add(to);</span>
<span class="line-added">777         }</span>
<span class="line-added">778 </span>
<span class="line-added">779         // If a known holder is not an object, also consider all of the holder&#39;s holders.</span>
<span class="line-added">780         for (auto* holder : m_holders)</span>
<span class="line-added">781             queue.add(holder);</span>
<span class="line-added">782         while (auto* holder = queue.takeAny()) {</span>
<span class="line-added">783             if (holder-&gt;isObject())</span>
<span class="line-added">784                 continue;</span>
<span class="line-added">785 </span>
<span class="line-added">786             for (auto* from : m_predecessors.get(holder)) {</span>
<span class="line-added">787                 if (!m_holders.contains(from)) {</span>
<span class="line-added">788                     m_holders.add(from);</span>
<span class="line-added">789                     queue.add(from);</span>
<span class="line-added">790                 }</span>
<span class="line-added">791             }</span>
<span class="line-added">792         }</span>
<span class="line-added">793 </span>
<span class="line-added">794         m_holders.removeIf([&amp;] (auto* holder) {</span>
<span class="line-added">795             return !holder-&gt;isObject() || !visited.contains(holder);</span>
<span class="line-added">796         });</span>
<span class="line-added">797     }</span>
<span class="line-added">798 </span>
<span class="line-added">799     HashSet&lt;JSCell*&gt;&amp; holders() { return m_holders; }</span>
<span class="line-added">800 </span>
<span class="line-added">801     void analyzeEdge(JSCell* from, JSCell* to, SlotVisitor::RootMarkReason reason)</span>
<span class="line-added">802     {</span>
<span class="line-added">803         ASSERT(to);</span>
<span class="line-added">804         ASSERT(to-&gt;vm().heapProfiler()-&gt;activeHeapAnalyzer() == this);</span>
<span class="line-added">805 </span>
<span class="line-added">806         auto locker = holdLock(m_mutex);</span>
<span class="line-added">807 </span>
<span class="line-added">808         if (from &amp;&amp; from != to) {</span>
<span class="line-added">809             m_successors.ensure(from, [] {</span>
<span class="line-added">810                 return HashSet&lt;JSCell*&gt;();</span>
<span class="line-added">811             }).iterator-&gt;value.add(to);</span>
<span class="line-added">812 </span>
<span class="line-added">813             m_predecessors.ensure(to, [] {</span>
<span class="line-added">814                 return HashSet&lt;JSCell*&gt;();</span>
<span class="line-added">815             }).iterator-&gt;value.add(from);</span>
<span class="line-added">816 </span>
<span class="line-added">817             if (to == m_target)</span>
<span class="line-added">818                 m_holders.add(from);</span>
<span class="line-added">819         }</span>
<span class="line-added">820 </span>
<span class="line-added">821         if (reason == SlotVisitor::RootMarkReason::Debugger)</span>
<span class="line-added">822             m_rootsToIgnore.add(to);</span>
<span class="line-added">823         else if (!from || reason != SlotVisitor::RootMarkReason::None)</span>
<span class="line-added">824             m_rootsToInclude.add(to);</span>
<span class="line-added">825     }</span>
<span class="line-added">826     void analyzePropertyNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-added">827     void analyzeVariableNameEdge(JSCell* from, JSCell* to, UniquedStringImpl*) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-added">828     void analyzeIndexEdge(JSCell* from, JSCell* to, uint32_t) { analyzeEdge(from, to, SlotVisitor::RootMarkReason::None); }</span>
<span class="line-added">829 </span>
<span class="line-added">830     void analyzeNode(JSCell*) { }</span>
<span class="line-added">831     void setOpaqueRootReachabilityReasonForCell(JSCell*, const char*) { }</span>
<span class="line-added">832     void setWrappedObjectForCell(JSCell*, void*) { }</span>
<span class="line-added">833     void setLabelForCell(JSCell*, const String&amp;) { }</span>
<span class="line-added">834 </span>
<span class="line-added">835 #ifndef NDEBUG</span>
<span class="line-added">836     void dump(PrintStream&amp; out) const</span>
<span class="line-added">837     {</span>
<span class="line-added">838         Indentation&lt;4&gt; indent;</span>
<span class="line-added">839 </span>
<span class="line-added">840         HashSet&lt;JSCell*&gt; visited;</span>
<span class="line-added">841 </span>
<span class="line-added">842         Function&lt;void(JSCell*)&gt; visit = [&amp;] (auto* from) {</span>
<span class="line-added">843             auto isFirstVisit = visited.add(from).isNewEntry;</span>
<span class="line-added">844 </span>
<span class="line-added">845             out.print(makeString(indent));</span>
<span class="line-added">846 </span>
<span class="line-added">847             out.print(&quot;[ &quot;_s);</span>
<span class="line-added">848             if (from == m_target)</span>
<span class="line-added">849                 out.print(&quot;T &quot;_s);</span>
<span class="line-added">850             if (m_holders.contains(from))</span>
<span class="line-added">851                 out.print(&quot;H &quot;_s);</span>
<span class="line-added">852             if (m_rootsToIgnore.contains(from))</span>
<span class="line-added">853                 out.print(&quot;- &quot;_s);</span>
<span class="line-added">854             else if (m_rootsToInclude.contains(from))</span>
<span class="line-added">855                 out.print(&quot;+ &quot;_s);</span>
<span class="line-added">856             if (!isFirstVisit)</span>
<span class="line-added">857                 out.print(&quot;V &quot;_s);</span>
<span class="line-added">858             out.print(&quot;] &quot;_s);</span>
<span class="line-added">859 </span>
<span class="line-added">860             from-&gt;dump(out);</span>
<span class="line-added">861 </span>
<span class="line-added">862             out.println();</span>
<span class="line-added">863 </span>
<span class="line-added">864             if (isFirstVisit) {</span>
<span class="line-added">865                 IndentationScope&lt;4&gt; scope(indent);</span>
<span class="line-added">866                 for (auto* to : m_successors.get(from))</span>
<span class="line-added">867                     visit(to);</span>
<span class="line-added">868             }</span>
<span class="line-added">869         };</span>
<span class="line-added">870 </span>
<span class="line-added">871         for (auto* from : m_rootsToInclude)</span>
<span class="line-added">872             visit(from);</span>
<span class="line-added">873     }</span>
<span class="line-added">874 #endif</span>
<span class="line-added">875 </span>
<span class="line-added">876 private:</span>
<span class="line-added">877     Lock m_mutex;</span>
<span class="line-added">878     HashMap&lt;JSCell*, HashSet&lt;JSCell*&gt;&gt; m_predecessors;</span>
<span class="line-added">879     HashMap&lt;JSCell*, HashSet&lt;JSCell*&gt;&gt; m_successors;</span>
<span class="line-added">880     HashSet&lt;JSCell*&gt; m_rootsToInclude;</span>
<span class="line-added">881     HashSet&lt;JSCell*&gt; m_rootsToIgnore;</span>
<span class="line-added">882     HashSet&lt;JSCell*&gt; m_holders;</span>
<span class="line-added">883     const JSCell* m_target;</span>
<span class="line-added">884 };</span>
<span class="line-added">885 </span>
<span class="line-added">886 JSValue JSInjectedScriptHost::queryHolders(ExecState* exec)</span>
<span class="line-added">887 {</span>
<span class="line-added">888     if (exec-&gt;argumentCount() &lt; 1)</span>
<span class="line-added">889         return jsUndefined();</span>
<span class="line-added">890 </span>
<span class="line-added">891     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">892     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">893 </span>
<span class="line-added">894     JSValue target = exec-&gt;uncheckedArgument(0);</span>
<span class="line-added">895     if (!target.isObject())</span>
<span class="line-added">896         return throwTypeError(exec, scope, &quot;queryHolders first argument must be an object.&quot;_s);</span>
<span class="line-added">897 </span>
<span class="line-added">898     JSArray* result = constructEmptyArray(exec, nullptr);</span>
<span class="line-added">899     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">900 </span>
<span class="line-added">901     {</span>
<span class="line-added">902         DeferGC deferGC(vm.heap);</span>
<span class="line-added">903         PreventCollectionScope preventCollectionScope(vm.heap);</span>
<span class="line-added">904         sanitizeStackForVM(vm);</span>
<span class="line-added">905 </span>
<span class="line-added">906         HeapHolderFinder holderFinder(vm.ensureHeapProfiler(), target.asCell());</span>
<span class="line-added">907 </span>
<span class="line-added">908         auto holders = copyToVector(holderFinder.holders());</span>
<span class="line-added">909         std::sort(holders.begin(), holders.end());</span>
<span class="line-added">910         for (auto* holder : holders)</span>
<span class="line-added">911             result-&gt;putDirectIndex(exec, result-&gt;length(), holder);</span>
<span class="line-added">912     }</span>
<span class="line-added">913 </span>
<span class="line-added">914     return result;</span>
<span class="line-added">915 }</span>
<span class="line-added">916 </span>
917 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="JSGlobalObjectInspectorController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSInjectedScriptHost.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>