<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Value.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;B3Bank.h&quot;
 31 #include &quot;B3Effects.h&quot;
 32 #include &quot;B3FrequentedBlock.h&quot;
 33 #include &quot;B3Kind.h&quot;
 34 #include &quot;B3Origin.h&quot;
 35 #include &quot;B3SparseCollection.h&quot;
 36 #include &quot;B3Type.h&quot;
 37 #include &quot;B3ValueKey.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &lt;wtf/CommaPrinter.h&gt;
 40 #include &lt;wtf/FastMalloc.h&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 41 #include &lt;wtf/IteratorRange.h&gt;</span>
 42 #include &lt;wtf/StdLibExtras.h&gt;
 43 #include &lt;wtf/TriState.h&gt;
 44 
 45 namespace JSC { namespace B3 {
 46 
 47 class BasicBlock;
 48 class CheckValue;
 49 class InsertionSet;
 50 class PhiChildren;
 51 class Procedure;
 52 
 53 class JS_EXPORT_PRIVATE Value {
 54     WTF_MAKE_FAST_ALLOCATED;
 55 public:
<a name="2" id="anc2"></a>

 56     static const char* const dumpPrefix;
 57 
 58     static bool accepts(Kind) { return true; }
 59 
 60     virtual ~Value();
 61 
 62     unsigned index() const { return m_index; }
 63 
 64     // Note that the kind is immutable, except for replacing values with:
 65     // Identity, Nop, Oops, Jump, and Phi. See below for replaceWithXXX() methods.
 66     Kind kind() const { return m_kind; }
 67 
 68     Opcode opcode() const { return kind().opcode(); }
 69 
 70     // Note that the kind is meant to be immutable. Do this when you know that this is safe. It&#39;s not
 71     // usually safe.
 72     void setKindUnsafely(Kind kind) { m_kind = kind; }
 73     void setOpcodeUnsafely(Opcode opcode) { m_kind.setOpcode(opcode); }
 74 
 75     // It&#39;s good practice to mirror Kind methods here, so you can say value-&gt;isBlah()
 76     // instead of value-&gt;kind().isBlah().
 77     bool isChill() const { return kind().isChill(); }
 78     bool traps() const { return kind().traps(); }
 79 
 80     Origin origin() const { return m_origin; }
 81     void setOrigin(Origin origin) { m_origin = origin; }
 82 
<a name="3" id="anc3"></a>







 83     Type type() const { return m_type; }
 84     void setType(Type type) { m_type = type; }
 85 
 86     // This is useful when lowering. Note that this is only valid for non-void values.
 87     Bank resultBank() const { return bankForType(type()); }
 88     Width resultWidth() const { return widthForType(type()); }
 89 
<a name="4" id="anc4"></a><span class="line-modified"> 90     unsigned numChildren() const</span>
<span class="line-modified"> 91     {</span>
<span class="line-added"> 92         if (m_numChildren == VarArgs)</span>
<span class="line-added"> 93             return childrenVector().size();</span>
<span class="line-added"> 94         return m_numChildren;</span>
<span class="line-added"> 95     }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     Value*&amp; child(unsigned index)</span>
<span class="line-added"> 98     {</span>
<span class="line-added"> 99         ASSERT(index &lt; numChildren());</span>
<span class="line-added">100         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="line-added">101     }</span>
<span class="line-added">102     Value* child(unsigned index) const</span>
<span class="line-added">103     {</span>
<span class="line-added">104         ASSERT(index &lt; numChildren());</span>
<span class="line-added">105         return m_numChildren == VarArgs ? childrenVector()[index] : childrenArray()[index];</span>
<span class="line-added">106     }</span>
<span class="line-added">107 </span>
<span class="line-added">108     Value*&amp; lastChild()</span>
<span class="line-added">109     {</span>
<span class="line-added">110         if (m_numChildren == VarArgs)</span>
<span class="line-added">111             return childrenVector().last();</span>
<span class="line-added">112         ASSERT(m_numChildren &gt;= 1);</span>
<span class="line-added">113         return childrenArray()[m_numChildren - 1];</span>
<span class="line-added">114     }</span>
<span class="line-added">115     Value* lastChild() const</span>
<span class="line-added">116     {</span>
<span class="line-added">117         if (m_numChildren == VarArgs)</span>
<span class="line-added">118             return childrenVector().last();</span>
<span class="line-added">119         ASSERT(m_numChildren &gt;= 1);</span>
<span class="line-added">120         return childrenArray()[m_numChildren - 1];</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     WTF::IteratorRange&lt;Value**&gt; children()</span>
<span class="line-added">124     {</span>
<span class="line-added">125         if (m_numChildren == VarArgs) {</span>
<span class="line-added">126             Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="line-added">127             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="line-added">128         }</span>
<span class="line-added">129         Value** buffer = childrenArray();</span>
<span class="line-added">130         return {buffer, buffer + m_numChildren };</span>
<span class="line-added">131     }</span>
<span class="line-added">132     WTF::IteratorRange&lt;Value* const*&gt; children() const</span>
<span class="line-added">133     {</span>
<span class="line-added">134         if (m_numChildren == VarArgs) {</span>
<span class="line-added">135             const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector();</span>
<span class="line-added">136             return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end());</span>
<span class="line-added">137         }</span>
<span class="line-added">138         Value* const* buffer = childrenArray();</span>
<span class="line-added">139         return {buffer, buffer + m_numChildren };</span>
<span class="line-added">140     }</span>
141 
142     // If you want to replace all uses of this value with a different value, then replace this
143     // value with Identity. Then do a pass of performSubstitution() on all of the values that use
144     // this one. Usually we do all of this in one pass in pre-order, which ensures that the
145     // X-&gt;replaceWithIdentity() calls happen before the performSubstitution() calls on X&#39;s users.
146     void replaceWithIdentity(Value*);
147 
148     // It&#39;s often necessary to kill a value. It&#39;s tempting to replace the value with Nop or to
149     // just remove it. But unless you are sure that the value is Void, you will probably still
150     // have other values that use this one. Sure, you may kill those later, or you might not. This
151     // method lets you kill a value safely. It will replace Void values with Nop and non-Void
152     // values with Identities on bottom constants. For this reason, this takes a callback that is
153     // responsible for creating bottoms. There&#39;s a utility for this, see B3BottomProvider.h. You
154     // can also access that utility using replaceWithBottom(InsertionSet&amp;, size_t).
155     //
156     // You&#39;re guaranteed that bottom is zero.
157     template&lt;typename BottomProvider&gt;
158     void replaceWithBottom(const BottomProvider&amp;);
159 
160     void replaceWithBottom(InsertionSet&amp;, size_t index);
161 
162     // Use this if you want to kill a value and you are sure that the value is Void.
163     void replaceWithNop();
164 
165     // Use this if you want to kill a value and you are sure that nobody is using it anymore.
166     void replaceWithNopIgnoringType();
167 
168     void replaceWithPhi();
169 
170     // These transformations are only valid for terminals.
171     void replaceWithJump(BasicBlock* owner, FrequentedBlock);
172     void replaceWithOops(BasicBlock* owner);
173 
174     // You can use this form if owners are valid. They&#39;re usually not valid.
175     void replaceWithJump(FrequentedBlock);
176     void replaceWithOops();
177 
178     void dump(PrintStream&amp;) const;
179     void deepDump(const Procedure*, PrintStream&amp;) const;
180 
181     virtual void dumpSuccessors(const BasicBlock*, PrintStream&amp;) const;
182 
183     // This is how you cast Values. For example, if you want to do something provided that we have a
184     // ArgumentRegValue, you can do:
185     //
186     // if (ArgumentRegValue* argumentReg = value-&gt;as&lt;ArgumentRegValue&gt;()) {
187     //     things
188     // }
189     //
190     // This will return null if this kind() != ArgumentReg. This works because this returns nullptr
191     // if T::accepts(kind()) returns false.
192     template&lt;typename T&gt;
193     T* as();
194     template&lt;typename T&gt;
195     const T* as() const;
196 
197     // What follows are a bunch of helpers for inspecting and modifying values. Note that we have a
198     // bunch of different idioms for implementing such helpers. You can use virtual methods, and
199     // override from the various Value subclasses. You can put the method inside Value and make it
200     // non-virtual, and the implementation can switch on kind. The method could be inline or not.
201     // If a method is specific to some Value subclass, you could put it in the subclass, or you could
202     // put it on Value anyway. It&#39;s fine to pick whatever feels right, and we shouldn&#39;t restrict
203     // ourselves to any particular idiom.
204 
205     bool isConstant() const;
206     bool isInteger() const;
207 
208     virtual Value* negConstant(Procedure&amp;) const;
209     virtual Value* addConstant(Procedure&amp;, int32_t other) const;
210     virtual Value* addConstant(Procedure&amp;, const Value* other) const;
211     virtual Value* subConstant(Procedure&amp;, const Value* other) const;
212     virtual Value* mulConstant(Procedure&amp;, const Value* other) const;
213     virtual Value* checkAddConstant(Procedure&amp;, const Value* other) const;
214     virtual Value* checkSubConstant(Procedure&amp;, const Value* other) const;
215     virtual Value* checkMulConstant(Procedure&amp;, const Value* other) const;
216     virtual Value* checkNegConstant(Procedure&amp;) const;
217     virtual Value* divConstant(Procedure&amp;, const Value* other) const; // This chooses Div&lt;Chill&gt; semantics for integers.
218     virtual Value* uDivConstant(Procedure&amp;, const Value* other) const;
219     virtual Value* modConstant(Procedure&amp;, const Value* other) const; // This chooses Mod&lt;Chill&gt; semantics.
220     virtual Value* uModConstant(Procedure&amp;, const Value* other) const;
221     virtual Value* bitAndConstant(Procedure&amp;, const Value* other) const;
222     virtual Value* bitOrConstant(Procedure&amp;, const Value* other) const;
223     virtual Value* bitXorConstant(Procedure&amp;, const Value* other) const;
224     virtual Value* shlConstant(Procedure&amp;, const Value* other) const;
225     virtual Value* sShrConstant(Procedure&amp;, const Value* other) const;
226     virtual Value* zShrConstant(Procedure&amp;, const Value* other) const;
227     virtual Value* rotRConstant(Procedure&amp;, const Value* other) const;
228     virtual Value* rotLConstant(Procedure&amp;, const Value* other) const;
229     virtual Value* bitwiseCastConstant(Procedure&amp;) const;
230     virtual Value* iToDConstant(Procedure&amp;) const;
231     virtual Value* iToFConstant(Procedure&amp;) const;
232     virtual Value* doubleToFloatConstant(Procedure&amp;) const;
233     virtual Value* floatToDoubleConstant(Procedure&amp;) const;
234     virtual Value* absConstant(Procedure&amp;) const;
235     virtual Value* ceilConstant(Procedure&amp;) const;
236     virtual Value* floorConstant(Procedure&amp;) const;
237     virtual Value* sqrtConstant(Procedure&amp;) const;
238 
239     virtual TriState equalConstant(const Value* other) const;
240     virtual TriState notEqualConstant(const Value* other) const;
241     virtual TriState lessThanConstant(const Value* other) const;
242     virtual TriState greaterThanConstant(const Value* other) const;
243     virtual TriState lessEqualConstant(const Value* other) const;
244     virtual TriState greaterEqualConstant(const Value* other) const;
245     virtual TriState aboveConstant(const Value* other) const;
246     virtual TriState belowConstant(const Value* other) const;
247     virtual TriState aboveEqualConstant(const Value* other) const;
248     virtual TriState belowEqualConstant(const Value* other) const;
249     virtual TriState equalOrUnorderedConstant(const Value* other) const;
250 
251     // If the value is a comparison then this returns the inverted form of that comparison, if
252     // possible. It can be impossible for double comparisons, where for example LessThan and
253     // GreaterEqual behave differently. If this returns a value, it is a new value, which must be
254     // either inserted into some block or deleted.
255     Value* invertedCompare(Procedure&amp;) const;
256 
257     bool hasInt32() const;
258     int32_t asInt32() const;
259     bool isInt32(int32_t) const;
260 
261     bool hasInt64() const;
262     int64_t asInt64() const;
263     bool isInt64(int64_t) const;
264 
265     bool hasInt() const;
266     int64_t asInt() const;
267     bool isInt(int64_t value) const;
268 
269     bool hasIntPtr() const;
270     intptr_t asIntPtr() const;
271     bool isIntPtr(intptr_t) const;
272 
273     bool hasDouble() const;
274     double asDouble() const;
275     bool isEqualToDouble(double) const; // We say &quot;isEqualToDouble&quot; because &quot;isDouble&quot; would be a bit equality.
276 
277     bool hasFloat() const;
278     float asFloat() const;
279 
280     bool hasNumber() const;
281     template&lt;typename T&gt; bool isRepresentableAs() const;
282     template&lt;typename T&gt; T asNumber() const;
283 
284     // Booleans in B3 are Const32(0) or Const32(1). So this is true if the type is Int32 and the only
285     // possible return values are 0 or 1. It&#39;s OK for this method to conservatively return false.
286     bool returnsBool() const;
287 
288     bool isNegativeZero() const;
289 
290     bool isRounded() const;
291 
292     TriState asTriState() const;
293     bool isLikeZero() const { return asTriState() == FalseTriState; }
294     bool isLikeNonZero() const { return asTriState() == TrueTriState; }
295 
296     Effects effects() const;
297 
298     // This returns a ValueKey that describes that this Value returns when it executes. Returns an
299     // empty ValueKey if this Value is impure. Note that an operation that returns Void could still
300     // have a non-empty ValueKey. This happens for example with Check operations.
301     ValueKey key() const;
302 
303     Value* foldIdentity() const;
304 
305     // Makes sure that none of the children are Identity&#39;s. If a child points to Identity, this will
306     // repoint it at the Identity&#39;s child. For simplicity, this will follow arbitrarily long chains
307     // of Identity&#39;s.
308     bool performSubstitution();
309 
310     // Free values are those whose presence is guaranteed not to hurt code. We consider constants,
311     // Identities, and Nops to be free. Constants are free because we hoist them to an optimal place.
312     // Identities and Nops are free because we remove them.
313     bool isFree() const;
314 
315     // Walk the ancestors of this value (i.e. the graph of things it transitively uses). This
316     // either walks phis or not, depending on whether PhiChildren is null. Your callback gets
317     // called with the signature:
318     //
319     //     (Value*) -&gt; WalkStatus
320     enum WalkStatus {
321         Continue,
322         IgnoreChildren,
323         Stop
324     };
325     template&lt;typename Functor&gt;
326     void walk(const Functor&amp; functor, PhiChildren* = nullptr);
327 
328     // B3 purposefully only represents signed 32-bit offsets because that&#39;s what x86 can encode, and
329     // ARM64 cannot encode anything bigger. The IsLegalOffset type trait is then used on B3 Value
330     // methods to prevent implicit conversions by C++ from invalid offset types: these cause compilation
331     // to fail, instead of causing implementation-defined behavior (which often turns to exploit).
332     // OffsetType isn&#39;t sufficient to determine offset validity! Each Value opcode further has an
333     // isLegalOffset runtime method used to determine value legality at runtime. This is exposed to users
334     // of B3 to force them to reason about the target&#39;s offset.
335     typedef int32_t OffsetType;
336     template&lt;typename Int&gt;
<a name="5" id="anc5"></a><span class="line-modified">337     struct IsLegalOffset {</span>
<span class="line-modified">338         static constexpr bool value = std::is_integral&lt;Int&gt;::value</span>
<span class="line-modified">339             &amp;&amp; std::is_signed&lt;Int&gt;::value</span>
<span class="line-modified">340             &amp;&amp; sizeof(Int) &lt;= sizeof(OffsetType);</span>
<span class="line-modified">341     };</span>

342 
343 protected:
<a name="6" id="anc6"></a><span class="line-modified">344     Value* cloneImpl() const;</span>
<span class="line-added">345 </span>
<span class="line-added">346     void replaceWith(Kind, Type, BasicBlock*);</span>
<span class="line-added">347     void replaceWith(Kind, Type, BasicBlock*, Value*);</span>
348 
349     virtual void dumpChildren(CommaPrinter&amp;, PrintStream&amp;) const;
350     virtual void dumpMeta(CommaPrinter&amp;, PrintStream&amp;) const;
351 
<a name="7" id="anc7"></a><span class="line-added">352     // The specific value of VarArgs does not matter, but the value of the others is assumed to match their meaning.</span>
<span class="line-added">353     enum NumChildren : uint8_t { Zero = 0, One = 1, Two = 2, Three = 3, VarArgs = 4};</span>
<span class="line-added">354 </span>
<span class="line-added">355     char* childrenAlloc() { return bitwise_cast&lt;char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="line-added">356     const char* childrenAlloc() const { return bitwise_cast&lt;const char*&gt;(this) + adjacencyListOffset(); }</span>
<span class="line-added">357     Vector&lt;Value*, 3&gt;&amp; childrenVector()</span>
<span class="line-added">358     {</span>
<span class="line-added">359         ASSERT(m_numChildren == VarArgs);</span>
<span class="line-added">360         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(childrenAlloc());</span>
<span class="line-added">361     }</span>
<span class="line-added">362     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const</span>
<span class="line-added">363     {</span>
<span class="line-added">364         ASSERT(m_numChildren == VarArgs);</span>
<span class="line-added">365         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(childrenAlloc());</span>
<span class="line-added">366     }</span>
<span class="line-added">367     Value** childrenArray()</span>
<span class="line-added">368     {</span>
<span class="line-added">369         ASSERT(m_numChildren != VarArgs);</span>
<span class="line-added">370         return bitwise_cast&lt;Value**&gt;(childrenAlloc());</span>
<span class="line-added">371     }</span>
<span class="line-added">372     Value* const* childrenArray() const</span>
<span class="line-added">373     {</span>
<span class="line-added">374         ASSERT(m_numChildren != VarArgs);</span>
<span class="line-added">375         return bitwise_cast&lt;Value* const*&gt;(childrenAlloc());</span>
<span class="line-added">376     }</span>
<span class="line-added">377 </span>
<span class="line-added">378     template&lt;typename... Arguments&gt;</span>
<span class="line-added">379     static Opcode opcodeFromConstructor(Kind kind, Arguments...) { return kind.opcode(); }</span>
<span class="line-added">380     ALWAYS_INLINE static size_t adjacencyListSpace(Kind kind)</span>
<span class="line-added">381     {</span>
<span class="line-added">382         switch (kind.opcode()) {</span>
<span class="line-added">383         case FramePointer:</span>
<span class="line-added">384         case Nop:</span>
<span class="line-added">385         case Phi:</span>
<span class="line-added">386         case Jump:</span>
<span class="line-added">387         case Oops:</span>
<span class="line-added">388         case EntrySwitch:</span>
<span class="line-added">389         case ArgumentReg:</span>
<span class="line-added">390         case Const32:</span>
<span class="line-added">391         case Const64:</span>
<span class="line-added">392         case ConstFloat:</span>
<span class="line-added">393         case ConstDouble:</span>
<span class="line-added">394         case Fence:</span>
<span class="line-added">395         case SlotBase:</span>
<span class="line-added">396         case Get:</span>
<span class="line-added">397             return 0;</span>
<span class="line-added">398         case Return:</span>
<span class="line-added">399         case Identity:</span>
<span class="line-added">400         case Opaque:</span>
<span class="line-added">401         case Neg:</span>
<span class="line-added">402         case Clz:</span>
<span class="line-added">403         case Abs:</span>
<span class="line-added">404         case Ceil:</span>
<span class="line-added">405         case Floor:</span>
<span class="line-added">406         case Sqrt:</span>
<span class="line-added">407         case SExt8:</span>
<span class="line-added">408         case SExt16:</span>
<span class="line-added">409         case Trunc:</span>
<span class="line-added">410         case SExt32:</span>
<span class="line-added">411         case ZExt32:</span>
<span class="line-added">412         case FloatToDouble:</span>
<span class="line-added">413         case IToD:</span>
<span class="line-added">414         case DoubleToFloat:</span>
<span class="line-added">415         case IToF:</span>
<span class="line-added">416         case BitwiseCast:</span>
<span class="line-added">417         case Branch:</span>
<span class="line-added">418         case Depend:</span>
<span class="line-added">419         case Load8Z:</span>
<span class="line-added">420         case Load8S:</span>
<span class="line-added">421         case Load16Z:</span>
<span class="line-added">422         case Load16S:</span>
<span class="line-added">423         case Load:</span>
<span class="line-added">424         case Switch:</span>
<span class="line-added">425         case Upsilon:</span>
<span class="line-added">426         case Extract:</span>
<span class="line-added">427         case Set:</span>
<span class="line-added">428         case WasmAddress:</span>
<span class="line-added">429         case WasmBoundsCheck:</span>
<span class="line-added">430             return sizeof(Value*);</span>
<span class="line-added">431         case Add:</span>
<span class="line-added">432         case Sub:</span>
<span class="line-added">433         case Mul:</span>
<span class="line-added">434         case Div:</span>
<span class="line-added">435         case UDiv:</span>
<span class="line-added">436         case Mod:</span>
<span class="line-added">437         case UMod:</span>
<span class="line-added">438         case BitAnd:</span>
<span class="line-added">439         case BitOr:</span>
<span class="line-added">440         case BitXor:</span>
<span class="line-added">441         case Shl:</span>
<span class="line-added">442         case SShr:</span>
<span class="line-added">443         case ZShr:</span>
<span class="line-added">444         case RotR:</span>
<span class="line-added">445         case RotL:</span>
<span class="line-added">446         case Equal:</span>
<span class="line-added">447         case NotEqual:</span>
<span class="line-added">448         case LessThan:</span>
<span class="line-added">449         case GreaterThan:</span>
<span class="line-added">450         case LessEqual:</span>
<span class="line-added">451         case GreaterEqual:</span>
<span class="line-added">452         case Above:</span>
<span class="line-added">453         case Below:</span>
<span class="line-added">454         case AboveEqual:</span>
<span class="line-added">455         case BelowEqual:</span>
<span class="line-added">456         case EqualOrUnordered:</span>
<span class="line-added">457         case AtomicXchgAdd:</span>
<span class="line-added">458         case AtomicXchgAnd:</span>
<span class="line-added">459         case AtomicXchgOr:</span>
<span class="line-added">460         case AtomicXchgSub:</span>
<span class="line-added">461         case AtomicXchgXor:</span>
<span class="line-added">462         case AtomicXchg:</span>
<span class="line-added">463         case Store8:</span>
<span class="line-added">464         case Store16:</span>
<span class="line-added">465         case Store:</span>
<span class="line-added">466             return 2 * sizeof(Value*);</span>
<span class="line-added">467         case Select:</span>
<span class="line-added">468         case AtomicWeakCAS:</span>
<span class="line-added">469         case AtomicStrongCAS:</span>
<span class="line-added">470             return 3 * sizeof(Value*);</span>
<span class="line-added">471         case CCall:</span>
<span class="line-added">472         case Check:</span>
<span class="line-added">473         case CheckAdd:</span>
<span class="line-added">474         case CheckSub:</span>
<span class="line-added">475         case CheckMul:</span>
<span class="line-added">476         case Patchpoint:</span>
<span class="line-added">477             return sizeof(Vector&lt;Value*, 3&gt;);</span>
<span class="line-added">478 #ifdef NDEBUG</span>
<span class="line-added">479         default:</span>
<span class="line-added">480             break;</span>
<span class="line-added">481 #endif</span>
<span class="line-added">482         }</span>
<span class="line-added">483         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">484         return 0;</span>
<span class="line-added">485     }</span>
<span class="line-added">486 </span>
487 private:
<a name="8" id="anc8"></a><span class="line-added">488     static char* allocateSpace(Opcode opcode, size_t size)</span>
<span class="line-added">489     {</span>
<span class="line-added">490         size_t adjacencyListSpace = Value::adjacencyListSpace(opcode);</span>
<span class="line-added">491         // We must allocate enough space that replaceWithIdentity can work without buffer overflow.</span>
<span class="line-added">492         size_t allocIdentitySize = sizeof(Value) + sizeof(Value*);</span>
<span class="line-added">493         size_t allocSize = std::max(size + adjacencyListSpace, allocIdentitySize);</span>
<span class="line-added">494         return static_cast&lt;char*&gt;(WTF::fastMalloc(allocSize));</span>
<span class="line-added">495     }</span>
<span class="line-added">496 </span>
<span class="line-added">497 protected:</span>
<span class="line-added">498     template&lt;typename ValueType, typename... Arguments&gt;</span>
<span class="line-added">499     static ValueType* allocate(Arguments... arguments)</span>
<span class="line-added">500     {</span>
<span class="line-added">501         char* alloc = allocateSpace(ValueType::opcodeFromConstructor(arguments...), sizeof(ValueType));</span>
<span class="line-added">502         return new (alloc) ValueType(arguments...);</span>
<span class="line-added">503     }</span>
<span class="line-added">504     template&lt;typename ValueType&gt;</span>
<span class="line-added">505     static ValueType* allocate(const ValueType&amp; valueToClone)</span>
<span class="line-added">506     {</span>
<span class="line-added">507         char* alloc = allocateSpace(valueToClone.opcode(), sizeof(ValueType));</span>
<span class="line-added">508         ValueType* result = new (alloc) ValueType(valueToClone);</span>
<span class="line-added">509         result-&gt;buildAdjacencyList(sizeof(ValueType), valueToClone);</span>
<span class="line-added">510         return result;</span>
<span class="line-added">511     }</span>
<span class="line-added">512 </span>
<span class="line-added">513     // Protected so it will only be called from allocate above, possibly through the subclasses&#39;copy constructors</span>
<span class="line-added">514     Value(const Value&amp;) = default;</span>
<span class="line-added">515 </span>
<span class="line-added">516     Value(Value&amp;&amp;) = delete;</span>
<span class="line-added">517     Value&amp; operator=(const Value&amp;) = delete;</span>
<span class="line-added">518     Value&amp; operator=(Value&amp;&amp;) = delete;</span>
<span class="line-added">519 </span>
<span class="line-added">520     size_t adjacencyListOffset() const;</span>
<span class="line-added">521 </span>
522     friend class Procedure;
523     friend class SparseCollection&lt;Value&gt;;
524 
<a name="9" id="anc9"></a><span class="line-added">525 private:</span>
<span class="line-added">526     template&lt;typename... Arguments&gt;</span>
<span class="line-added">527     void buildAdjacencyList(NumChildren numChildren, Arguments... arguments)</span>
<span class="line-added">528     {</span>
<span class="line-added">529         if (numChildren == VarArgs) {</span>
<span class="line-added">530             new (childrenAlloc()) Vector&lt;Value*, 3&gt; { arguments... };</span>
<span class="line-added">531             return;</span>
<span class="line-added">532         }</span>
<span class="line-added">533         ASSERT(numChildren == sizeof...(arguments));</span>
<span class="line-added">534         new (childrenAlloc()) Value*[sizeof...(arguments)] { arguments... };</span>
<span class="line-added">535     }</span>
<span class="line-added">536     void buildAdjacencyList(size_t offset, const Value&amp; valueToClone)</span>
<span class="line-added">537     {</span>
<span class="line-added">538         switch (valueToClone.m_numChildren) {</span>
<span class="line-added">539         case VarArgs:</span>
<span class="line-added">540             new (bitwise_cast&lt;char*&gt;(this) + offset) Vector&lt;Value*, 3&gt; (valueToClone.childrenVector());</span>
<span class="line-added">541             break;</span>
<span class="line-added">542         case Three:</span>
<span class="line-added">543             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[2] = valueToClone.childrenArray()[2];</span>
<span class="line-added">544             FALLTHROUGH;</span>
<span class="line-added">545         case Two:</span>
<span class="line-added">546             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[1] = valueToClone.childrenArray()[1];</span>
<span class="line-added">547             FALLTHROUGH;</span>
<span class="line-added">548         case One:</span>
<span class="line-added">549             bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + offset)[0] = valueToClone.childrenArray()[0];</span>
<span class="line-added">550             break;</span>
<span class="line-added">551         case Zero:</span>
<span class="line-added">552             break;</span>
<span class="line-added">553         }</span>
<span class="line-added">554     }</span>
<span class="line-added">555 </span>
556     // Checks that this kind is valid for use with B3::Value.
<a name="10" id="anc10"></a><span class="line-modified">557     ALWAYS_INLINE static NumChildren numChildrenForKind(Kind kind, unsigned numArgs)</span>
558     {
559         switch (kind.opcode()) {
560         case FramePointer:
561         case Nop:
562         case Phi:
563         case Jump:
564         case Oops:
565         case EntrySwitch:
566             if (UNLIKELY(numArgs))
567                 badKind(kind, numArgs);
<a name="11" id="anc11"></a><span class="line-modified">568             return Zero;</span>
569         case Return:
570             if (UNLIKELY(numArgs &gt; 1))
571                 badKind(kind, numArgs);
<a name="12" id="anc12"></a><span class="line-modified">572             return numArgs ? One : Zero;</span>
573         case Identity:
574         case Opaque:
575         case Neg:
576         case Clz:
577         case Abs:
578         case Ceil:
579         case Floor:
580         case Sqrt:
581         case SExt8:
582         case SExt16:
583         case Trunc:
584         case SExt32:
585         case ZExt32:
586         case FloatToDouble:
587         case IToD:
588         case DoubleToFloat:
589         case IToF:
590         case BitwiseCast:
591         case Branch:
592         case Depend:
593             if (UNLIKELY(numArgs != 1))
594                 badKind(kind, numArgs);
<a name="13" id="anc13"></a><span class="line-modified">595             return One;</span>
596         case Add:
597         case Sub:
598         case Mul:
599         case Div:
600         case UDiv:
601         case Mod:
602         case UMod:
603         case BitAnd:
604         case BitOr:
605         case BitXor:
606         case Shl:
607         case SShr:
608         case ZShr:
609         case RotR:
610         case RotL:
611         case Equal:
612         case NotEqual:
613         case LessThan:
614         case GreaterThan:
615         case LessEqual:
616         case GreaterEqual:
617         case Above:
618         case Below:
619         case AboveEqual:
620         case BelowEqual:
621         case EqualOrUnordered:
622             if (UNLIKELY(numArgs != 2))
623                 badKind(kind, numArgs);
<a name="14" id="anc14"></a><span class="line-modified">624             return Two;</span>
625         case Select:
626             if (UNLIKELY(numArgs != 3))
627                 badKind(kind, numArgs);
<a name="15" id="anc15"></a><span class="line-modified">628             return Three;</span>
629         default:
630             badKind(kind, numArgs);
631             break;
632         }
<a name="16" id="anc16"></a><span class="line-added">633         return VarArgs;</span>
634     }
635 
636 protected:
637     enum CheckedOpcodeTag { CheckedOpcode };
638 
<a name="17" id="anc17"></a>


639     // Instantiate values via Procedure.
640     // This form requires specifying the type explicitly:
641     template&lt;typename... Arguments&gt;
<a name="18" id="anc18"></a><span class="line-modified">642     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin, Value* firstChild, Arguments... arguments)</span>
643         : m_kind(kind)
644         , m_type(type)
<a name="19" id="anc19"></a><span class="line-added">645         , m_numChildren(numChildren)</span>
646         , m_origin(origin)
<a name="20" id="anc20"></a>
647     {
<a name="21" id="anc21"></a><span class="line-added">648         buildAdjacencyList(numChildren, firstChild, arguments...);</span>
649     }
650     // This form is for specifying the type explicitly when the opcode has no children:
<a name="22" id="anc22"></a><span class="line-modified">651     explicit Value(CheckedOpcodeTag, Kind kind, Type type, NumChildren numChildren, Origin origin)</span>
652         : m_kind(kind)
653         , m_type(type)
<a name="23" id="anc23"></a><span class="line-added">654         , m_numChildren(numChildren)</span>
655         , m_origin(origin)
656     {
<a name="24" id="anc24"></a><span class="line-modified">657         buildAdjacencyList(numChildren);</span>

















658     }
659     // This form is for those opcodes that can infer their type from the opcode alone, and that don&#39;t
660     // take any arguments:
<a name="25" id="anc25"></a><span class="line-modified">661     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin)</span>
662         : m_kind(kind)
663         , m_type(typeFor(kind, nullptr))
<a name="26" id="anc26"></a><span class="line-added">664         , m_numChildren(numChildren)</span>
665         , m_origin(origin)
666     {
<a name="27" id="anc27"></a><span class="line-added">667         buildAdjacencyList(numChildren);</span>
668     }
<a name="28" id="anc28"></a><span class="line-modified">669     // This form is for those opcodes that can infer their type from the opcode and first child:</span>
<span class="line-modified">670     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild)</span>
671         : m_kind(kind)
<a name="29" id="anc29"></a><span class="line-modified">672         , m_type(typeFor(kind, firstChild))</span>
<span class="line-added">673         , m_numChildren(numChildren)</span>
674         , m_origin(origin)
<a name="30" id="anc30"></a>
675     {
<a name="31" id="anc31"></a><span class="line-added">676         buildAdjacencyList(numChildren, firstChild);</span>
677     }
<a name="32" id="anc32"></a><span class="line-modified">678     // This form is for those opcodes that can infer their type from the opcode and first and second child:</span>
<span class="line-added">679     template&lt;typename... Arguments&gt;</span>
<span class="line-added">680     explicit Value(CheckedOpcodeTag, Kind kind, NumChildren numChildren, Origin origin, Value* firstChild, Value* secondChild, Arguments... arguments)</span>
681         : m_kind(kind)
<a name="33" id="anc33"></a><span class="line-modified">682         , m_type(typeFor(kind, firstChild, secondChild))</span>
<span class="line-added">683         , m_numChildren(numChildren)</span>
684         , m_origin(origin)
<a name="34" id="anc34"></a>
685     {
<a name="35" id="anc35"></a><span class="line-added">686         buildAdjacencyList(numChildren, firstChild, secondChild, arguments...);</span>
687     }
688 
689     // This is the constructor you end up actually calling, if you&#39;re instantiating Value
690     // directly.
<a name="36" id="anc36"></a><span class="line-modified">691     explicit Value(Kind kind, Type type, Origin origin)</span>
<span class="line-modified">692         : Value(CheckedOpcode, kind, type, Zero, origin)</span>













693     {
<a name="37" id="anc37"></a><span class="line-modified">694         RELEASE_ASSERT(numChildrenForKind(kind, 0) == Zero);</span>
695     }
<a name="38" id="anc38"></a><span class="line-added">696     // We explicitly convert the extra arguments to Value* (they may be pointers to some subclasses of Value) to limit template explosion</span>
697     template&lt;typename... Arguments&gt;
<a name="39" id="anc39"></a><span class="line-modified">698     explicit Value(Kind kind, Origin origin, Arguments... arguments)</span>
<span class="line-modified">699         : Value(CheckedOpcode, kind, numChildrenForKind(kind, sizeof...(arguments)), origin, static_cast&lt;Value*&gt;(arguments)...)</span>
700     {
<a name="40" id="anc40"></a>
701     }
702     template&lt;typename... Arguments&gt;
<a name="41" id="anc41"></a><span class="line-modified">703     explicit Value(Kind kind, Type type, Origin origin, Value* firstChild, Arguments... arguments)</span>
<span class="line-modified">704         : Value(CheckedOpcode, kind, type, numChildrenForKind(kind, 1 + sizeof...(arguments)), origin, firstChild, static_cast&lt;Value*&gt;(arguments)...)</span>
705     {
<a name="42" id="anc42"></a>
706     }
707 
708 private:
709     friend class CheckValue; // CheckValue::convertToAdd() modifies m_kind.
710 
711     static Type typeFor(Kind, Value* firstChild, Value* secondChild = nullptr);
712 
<a name="43" id="anc43"></a><span class="line-modified">713     // m_index to m_numChildren are arranged to fit in 64 bits.</span>
714 protected:
715     unsigned m_index { UINT_MAX };
716 private:
717     Kind m_kind;
718     Type m_type;
<a name="44" id="anc44"></a><span class="line-modified">719 protected:</span>
<span class="line-added">720     NumChildren m_numChildren;</span>
<span class="line-added">721 private:</span>
722     Origin m_origin;
<a name="45" id="anc45"></a>
723 
724     NO_RETURN_DUE_TO_CRASH static void badKind(Kind, unsigned);
725 
726 public:
727     BasicBlock* owner { nullptr }; // computed by Procedure::resetValueOwners().
728 };
729 
730 class DeepValueDump {
731 public:
732     DeepValueDump(const Procedure* proc, const Value* value)
733         : m_proc(proc)
734         , m_value(value)
735     {
736     }
737 
<a name="46" id="anc46"></a><span class="line-modified">738     void dump(PrintStream&amp; out) const;</span>






739 
740 private:
741     const Procedure* m_proc;
742     const Value* m_value;
743 };
744 
745 inline DeepValueDump deepDump(const Procedure&amp; proc, const Value* value)
746 {
747     return DeepValueDump(&amp;proc, value);
748 }
749 inline DeepValueDump deepDump(const Value* value)
750 {
751     return DeepValueDump(nullptr, value);
752 }
753 
<a name="47" id="anc47"></a><span class="line-added">754 // The following macros are designed for subclasses of B3::Value to use.</span>
<span class="line-added">755 // They are never required for correctness, but can improve the performance of child/lastChild/numChildren/children methods,</span>
<span class="line-added">756 // for users that already know the specific subclass of Value they are manipulating.</span>
<span class="line-added">757 // The first set is to be used when you know something about the number of children of all values of a class, including its subclasses:</span>
<span class="line-added">758 // - B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN: always 0 children (e.g. Const32Value)</span>
<span class="line-added">759 // - B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n): always n children, with n in {1, 2, 3} (e.g. UpsilonValue, with n = 1)</span>
<span class="line-added">760 // - B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN: different numbers of children, but never a variable number at runtime (e.g. MemoryValue, that can have between 1 and 3 children)</span>
<span class="line-added">761 // - B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN: always a varargs (e.g. CCallValue)</span>
<span class="line-added">762 // The second set is only to be used by classes that we know are not further subclassed by anyone adding fields,</span>
<span class="line-added">763 // as they hardcode the offset of the children array/vector (which is equal to the size of the object).</span>
<span class="line-added">764 // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN</span>
<span class="line-added">765 // - B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN</span>
<span class="line-added">766 #define B3_SPECIALIZE_VALUE_FOR_NO_CHILDREN \</span>
<span class="line-added">767     unsigned numChildren() const { return 0; } \</span>
<span class="line-added">768     WTF::IteratorRange&lt;Value**&gt; children() { return {nullptr, nullptr}; } \</span>
<span class="line-added">769     WTF::IteratorRange&lt;Value* const*&gt; children() const { return { nullptr, nullptr}; }</span>
<span class="line-added">770 </span>
<span class="line-added">771 #define B3_SPECIALIZE_VALUE_FOR_FIXED_CHILDREN(n) \</span>
<span class="line-added">772 public: \</span>
<span class="line-added">773     unsigned numChildren() const { return n; } \</span>
<span class="line-added">774     Value*&amp; child(unsigned index) \</span>
<span class="line-added">775     { \</span>
<span class="line-added">776         ASSERT(index &lt;= n); \</span>
<span class="line-added">777         return childrenArray()[index]; \</span>
<span class="line-added">778     } \</span>
<span class="line-added">779     Value* child(unsigned index) const \</span>
<span class="line-added">780     { \</span>
<span class="line-added">781         ASSERT(index &lt;= n); \</span>
<span class="line-added">782         return childrenArray()[index]; \</span>
<span class="line-added">783     } \</span>
<span class="line-added">784     Value*&amp; lastChild() \</span>
<span class="line-added">785     { \</span>
<span class="line-added">786         return childrenArray()[n - 1]; \</span>
<span class="line-added">787     } \</span>
<span class="line-added">788     Value* lastChild() const \</span>
<span class="line-added">789     { \</span>
<span class="line-added">790         return childrenArray()[n - 1]; \</span>
<span class="line-added">791     } \</span>
<span class="line-added">792     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">793     { \</span>
<span class="line-added">794         Value** buffer = childrenArray(); \</span>
<span class="line-added">795         return {buffer, buffer + n }; \</span>
<span class="line-added">796     } \</span>
<span class="line-added">797     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">798     { \</span>
<span class="line-added">799         Value* const* buffer = childrenArray(); \</span>
<span class="line-added">800         return {buffer, buffer + n }; \</span>
<span class="line-added">801     } \</span>
<span class="line-added">802 </span>
<span class="line-added">803 #define B3_SPECIALIZE_VALUE_FOR_NON_VARARGS_CHILDREN \</span>
<span class="line-added">804 public: \</span>
<span class="line-added">805     unsigned numChildren() const { return m_numChildren; } \</span>
<span class="line-added">806     Value*&amp; child(unsigned index) { return childrenArray()[index]; } \</span>
<span class="line-added">807     Value* child(unsigned index) const { return childrenArray()[index]; } \</span>
<span class="line-added">808     Value*&amp; lastChild() { return childrenArray()[numChildren() - 1]; } \</span>
<span class="line-added">809     Value* lastChild() const { return childrenArray()[numChildren() - 1]; } \</span>
<span class="line-added">810     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">811     { \</span>
<span class="line-added">812         Value** buffer = childrenArray(); \</span>
<span class="line-added">813         return {buffer, buffer + numChildren() }; \</span>
<span class="line-added">814     } \</span>
<span class="line-added">815     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">816     { \</span>
<span class="line-added">817         Value* const* buffer = childrenArray(); \</span>
<span class="line-added">818         return {buffer, buffer + numChildren() }; \</span>
<span class="line-added">819     } \</span>
<span class="line-added">820 </span>
<span class="line-added">821 #define B3_SPECIALIZE_VALUE_FOR_VARARGS_CHILDREN \</span>
<span class="line-added">822 public: \</span>
<span class="line-added">823     unsigned numChildren() const { return childrenVector().size(); } \</span>
<span class="line-added">824     Value*&amp; child(unsigned index) { return childrenVector()[index]; } \</span>
<span class="line-added">825     Value* child(unsigned index) const { return childrenVector()[index]; } \</span>
<span class="line-added">826     Value*&amp; lastChild() { return childrenVector().last(); } \</span>
<span class="line-added">827     Value* lastChild() const { return childrenVector().last(); } \</span>
<span class="line-added">828     WTF::IteratorRange&lt;Value**&gt; children() \</span>
<span class="line-added">829     { \</span>
<span class="line-added">830         Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="line-added">831         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="line-added">832     } \</span>
<span class="line-added">833     WTF::IteratorRange&lt;Value* const*&gt; children() const \</span>
<span class="line-added">834     { \</span>
<span class="line-added">835         const Vector&lt;Value*, 3&gt;&amp; vec = childrenVector(); \</span>
<span class="line-added">836         return WTF::makeIteratorRange(&amp;*vec.begin(), &amp;*vec.end()); \</span>
<span class="line-added">837     } \</span>
<span class="line-added">838 </span>
<span class="line-added">839 // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="line-added">840 // Also there is no point in applying this to classes with no children, as they don&#39;t have a children array to access.</span>
<span class="line-added">841 #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_FIXED_CHILDREN \</span>
<span class="line-added">842 private: \</span>
<span class="line-added">843     Value** childrenArray() \</span>
<span class="line-added">844     { \</span>
<span class="line-added">845         return bitwise_cast&lt;Value**&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">846     } \</span>
<span class="line-added">847     Value* const* childrenArray() const \</span>
<span class="line-added">848     { \</span>
<span class="line-added">849         return bitwise_cast&lt;Value* const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">850     }</span>
<span class="line-added">851 </span>
<span class="line-added">852 // Only use this for classes with no subclass that add new fields (as it uses sizeof(*this))</span>
<span class="line-added">853 #define B3_SPECIALIZE_VALUE_FOR_FINAL_SIZE_VARARGS_CHILDREN \</span>
<span class="line-added">854 private: \</span>
<span class="line-added">855     Vector&lt;Value*, 3&gt;&amp; childrenVector() \</span>
<span class="line-added">856     { \</span>
<span class="line-added">857         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt;*&gt;(bitwise_cast&lt;char*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">858     } \</span>
<span class="line-added">859     const Vector&lt;Value*, 3&gt;&amp; childrenVector() const \</span>
<span class="line-added">860     { \</span>
<span class="line-added">861         return *bitwise_cast&lt;Vector&lt;Value*, 3&gt; const*&gt;(bitwise_cast&lt;char const*&gt;(this) + sizeof(*this)); \</span>
<span class="line-added">862     } \</span>
<span class="line-added">863 </span>
864 } } // namespace JSC::B3
865 
866 #endif // ENABLE(B3_JIT)
<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>