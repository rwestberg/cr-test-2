<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2006 Bjoern Graf (bjoern.graf@gmail.com)
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  29 #include &quot;BytecodeCacheError.h&quot;</span>
  30 #include &quot;CatchScope.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;CodeCache.h&quot;
  33 #include &quot;Completion.h&quot;
  34 #include &quot;ConfigFile.h&quot;
  35 #include &quot;Disassembler.h&quot;
  36 #include &quot;Exception.h&quot;
  37 #include &quot;ExceptionHelpers.h&quot;
  38 #include &quot;HeapProfiler.h&quot;
  39 #include &quot;HeapSnapshotBuilder.h&quot;
  40 #include &quot;InitializeThreading.h&quot;
  41 #include &quot;Interpreter.h&quot;
  42 #include &quot;JIT.h&quot;
  43 #include &quot;JSArray.h&quot;
  44 #include &quot;JSArrayBuffer.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSInternalPromise.h&quot;
  49 #include &quot;JSInternalPromiseDeferred.h&quot;
  50 #include &quot;JSLock.h&quot;
  51 #include &quot;JSModuleLoader.h&quot;
  52 #include &quot;JSNativeStdFunction.h&quot;
  53 #include &quot;JSONObject.h&quot;
  54 #include &quot;JSSourceCode.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSTypedArrays.h&quot;
  57 #include &quot;JSWebAssemblyInstance.h&quot;
  58 #include &quot;JSWebAssemblyMemory.h&quot;
  59 #include &quot;LLIntThunks.h&quot;
  60 #include &quot;ObjectConstructor.h&quot;
  61 #include &quot;ParserError.h&quot;
  62 #include &quot;ProfilerDatabase.h&quot;
  63 #include &quot;PromiseDeferredTimer.h&quot;
  64 #include &quot;ProtoCallFrame.h&quot;
  65 #include &quot;ReleaseHeapAccessScope.h&quot;
  66 #include &quot;SamplingProfiler.h&quot;
  67 #include &quot;StackVisitor.h&quot;
  68 #include &quot;StructureInlines.h&quot;
  69 #include &quot;StructureRareDataInlines.h&quot;
  70 #include &quot;SuperSampler.h&quot;
  71 #include &quot;TestRunnerUtils.h&quot;
  72 #include &quot;TypedArrayInlines.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  73 #include &quot;WasmCapabilities.h&quot;</span>
  74 #include &quot;WasmContext.h&quot;
  75 #include &quot;WasmFaultSignalHandler.h&quot;
  76 #include &quot;WasmMemory.h&quot;
  77 #include &lt;locale.h&gt;
  78 #include &lt;math.h&gt;
  79 #include &lt;stdio.h&gt;
  80 #include &lt;stdlib.h&gt;
  81 #include &lt;string.h&gt;
  82 #include &lt;sys/stat.h&gt;
  83 #include &lt;sys/types.h&gt;
  84 #include &lt;thread&gt;
  85 #include &lt;type_traits&gt;
  86 #include &lt;wtf/Box.h&gt;
  87 #include &lt;wtf/CommaPrinter.h&gt;
<a name="4" id="anc4"></a><span class="line-added">  88 #include &lt;wtf/FileSystem.h&gt;</span>
  89 #include &lt;wtf/MainThread.h&gt;
  90 #include &lt;wtf/MemoryPressureHandler.h&gt;
  91 #include &lt;wtf/MonotonicTime.h&gt;
  92 #include &lt;wtf/NeverDestroyed.h&gt;
  93 #include &lt;wtf/Scope.h&gt;
  94 #include &lt;wtf/StringPrintStream.h&gt;
  95 #include &lt;wtf/URL.h&gt;
  96 #include &lt;wtf/WallTime.h&gt;
  97 #include &lt;wtf/text/StringBuilder.h&gt;
  98 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  99 
 100 #if OS(WINDOWS)
 101 #include &lt;direct.h&gt;
 102 #include &lt;fcntl.h&gt;
 103 #include &lt;io.h&gt;
<a name="5" id="anc5"></a>
 104 #else
 105 #include &lt;unistd.h&gt;
 106 #endif
 107 
 108 #if PLATFORM(COCOA)
 109 #include &lt;crt_externs.h&gt;
 110 #endif
 111 
 112 #if HAVE(READLINE)
 113 // readline/history.h has a Function typedef which conflicts with the WTF::Function template from WTF/Forward.h
 114 // We #define it to something else to avoid this conflict.
 115 #define Function ReadlineFunction
 116 #include &lt;readline/history.h&gt;
 117 #include &lt;readline/readline.h&gt;
 118 #undef Function
 119 #endif
 120 
 121 #if HAVE(SYS_TIME_H)
 122 #include &lt;sys/time.h&gt;
 123 #endif
 124 
 125 #if HAVE(SIGNAL_H)
 126 #include &lt;signal.h&gt;
 127 #endif
 128 
 129 #if COMPILER(MSVC)
 130 #include &lt;crtdbg.h&gt;
 131 #include &lt;mmsystem.h&gt;
 132 #include &lt;windows.h&gt;
 133 #endif
 134 
 135 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
 136 #include &lt;fenv.h&gt;
 137 #include &lt;arm/arch.h&gt;
 138 #endif
 139 
<a name="6" id="anc6"></a><span class="line-modified"> 140 #if OS(DARWIN)</span>
<span class="line-modified"> 141 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;</span>
<span class="line-added"> 142 struct MemoryFootprint : ProcessMemoryFootprint {</span>
<span class="line-added"> 143     MemoryFootprint(const ProcessMemoryFootprint&amp; src)</span>
<span class="line-added"> 144         : ProcessMemoryFootprint(src)</span>
<span class="line-added"> 145     {</span>
<span class="line-added"> 146     }</span>
<span class="line-added"> 147 };</span>
 148 #else
 149 struct MemoryFootprint {
 150     uint64_t current;
 151     uint64_t peak;
 152 
 153     static MemoryFootprint now()
 154     {
 155         return { 0L, 0L };
 156     }
 157 
 158     static void resetPeak()
 159     {
 160     }
 161 };
 162 #endif
 163 
 164 #if !defined(PATH_MAX)
 165 #define PATH_MAX 4096
 166 #endif
 167 
 168 using namespace JSC;
 169 
 170 namespace {
 171 
 172 NO_RETURN_WITH_VALUE static void jscExit(int status)
 173 {
 174     waitForAsynchronousDisassembly();
 175 
 176 #if ENABLE(DFG_JIT)
 177     if (DFG::isCrashing()) {
 178         for (;;) {
 179 #if OS(WINDOWS)
 180             Sleep(1000);
 181 #else
 182             pause();
 183 #endif
 184         }
 185     }
 186 #endif // ENABLE(DFG_JIT)
 187     exit(status);
 188 }
 189 
 190 class Masquerader : public JSNonFinalObject {
 191 public:
 192     Masquerader(VM&amp; vm, Structure* structure)
 193         : Base(vm, structure)
 194     {
 195     }
 196 
 197     typedef JSNonFinalObject Base;
 198     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 199 
 200     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 201     {
 202         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 203         Structure* structure = createStructure(vm, globalObject, jsNull());
<a name="7" id="anc7"></a><span class="line-modified"> 204         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);</span>
 205         result-&gt;finishCreation(vm);
 206         return result;
 207     }
 208 
 209     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 210     {
 211         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 212     }
 213 
 214     DECLARE_INFO;
 215 };
 216 
 217 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 218 static unsigned asyncTestPasses { 0 };
 219 static unsigned asyncTestExpectedPasses { 0 };
 220 
 221 }
 222 
 223 template&lt;typename Vector&gt;
 224 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 225 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 226 
 227 class CommandLine;
 228 class GlobalObject;
 229 class Workers;
 230 
 231 template&lt;typename Func&gt;
 232 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
 233 static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);
 234 
 235 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 236 public:
 237     Message(ArrayBufferContents&amp;&amp;, int32_t);
 238     ~Message();
 239 
 240     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 241     int32_t index() const { return m_index; }
 242 
 243 private:
 244     ArrayBufferContents m_contents;
 245     int32_t m_index { 0 };
 246 };
 247 
 248 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 249 public:
 250     Worker(Workers&amp;);
 251     ~Worker();
 252 
 253     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
 254     RefPtr&lt;Message&gt; dequeue();
 255 
 256     static Worker&amp; current();
 257 
 258 private:
 259     static ThreadSpecific&lt;Worker*&gt;&amp; currentWorker();
 260 
 261     Workers&amp; m_workers;
 262     Deque&lt;RefPtr&lt;Message&gt;&gt; m_messages;
 263 };
 264 
 265 class Workers {
 266     WTF_MAKE_FAST_ALLOCATED;
 267     WTF_MAKE_NONCOPYABLE(Workers);
 268 public:
 269     Workers();
 270     ~Workers();
 271 
 272     template&lt;typename Func&gt;
 273     void broadcast(const Func&amp;);
 274 
 275     void report(const String&amp;);
 276     String tryGetReport();
 277     String getReport();
 278 
 279     static Workers&amp; singleton();
 280 
 281 private:
 282     friend class Worker;
 283 
 284     Lock m_lock;
 285     Condition m_condition;
 286     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 287     Deque&lt;String&gt; m_reports;
 288 };
 289 
 290 
 291 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);
 292 
 293 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
 294 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
 295 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
 296 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
 297 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
 298 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
 299 static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);
 300 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);
 301 static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);
 302 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);
 303 static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);
 304 static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);
 305 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);
 306 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);
 307 static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);
 308 static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);
 309 static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);
 310 static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);
 311 static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);
 312 static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);
 313 static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);
 314 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);
 315 static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);
 316 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);
 317 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);
 318 static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);
 319 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);
 320 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);
 321 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);
 322 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);
 323 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);
 324 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);
 325 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);
 326 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);
 327 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);
 328 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);
 329 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);
 330 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);
 331 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);
 332 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);
 333 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);
 334 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
 335 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
 336 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
 337 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
 338 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);
<a name="8" id="anc8"></a><span class="line-added"> 339 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
 340 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
 341 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
 342 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
 343 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
 344 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
 345 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);
 346 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);
 347 #if ENABLE(SAMPLING_PROFILER)
 348 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);
 349 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);
 350 #endif
 351 
 352 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);
 353 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);
 354 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);
 355 
 356 #if ENABLE(WEBASSEMBLY)
 357 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);
 358 #endif
 359 
 360 #if ENABLE(SAMPLING_FLAGS)
 361 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);
 362 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);
 363 #endif
 364 
 365 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);
 366 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);
 367 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);
 368 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);
 369 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);
 370 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);
 371 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);
 372 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);
 373 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);
 374 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);
 375 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);
 376 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);
 377 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);
 378 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);
 379 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);
 380 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);
 381 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);
 382 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
 383 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
 384 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
 385 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
 386 
<a name="9" id="anc9"></a><span class="line-added"> 387 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
<span class="line-added"> 388 </span>
 389 struct Script {
 390     enum class StrictMode {
 391         Strict,
 392         Sloppy
 393     };
 394 
 395     enum class ScriptType {
 396         Script,
 397         Module
 398     };
 399 
 400     enum class CodeSource {
 401         File,
 402         CommandLine
 403     };
 404 
 405     StrictMode strictMode;
 406     CodeSource codeSource;
 407     ScriptType scriptType;
 408     char* argument;
 409 
 410     Script(StrictMode strictMode, CodeSource codeSource, ScriptType scriptType, char *argument)
 411         : strictMode(strictMode)
 412         , codeSource(codeSource)
 413         , scriptType(scriptType)
 414         , argument(argument)
 415     {
 416         if (strictMode == StrictMode::Strict)
 417             ASSERT(codeSource == CodeSource::File);
 418     }
 419 };
 420 
 421 class CommandLine {
 422 public:
 423     CommandLine(int argc, char** argv)
 424     {
 425         parseArguments(argc, argv);
 426     }
 427 
<a name="10" id="anc10"></a><span class="line-added"> 428     Vector&lt;Script&gt; m_scripts;</span>
<span class="line-added"> 429     Vector&lt;String&gt; m_arguments;</span>
<span class="line-added"> 430     String m_profilerOutput;</span>
<span class="line-added"> 431     String m_uncaughtExceptionName;</span>
 432     bool m_interactive { false };
 433     bool m_dump { false };
 434     bool m_module { false };
 435     bool m_exitCode { false };
<a name="11" id="anc11"></a><span class="line-modified"> 436     bool m_destroyVM { false };</span>

 437     bool m_profile { false };
<a name="12" id="anc12"></a>

 438     bool m_treatWatchdogExceptionAsSuccess { false };
 439     bool m_alwaysDumpUncaughtException { false };
 440     bool m_dumpMemoryFootprint { false };
 441     bool m_dumpSamplingProfilerData { false };
 442     bool m_enableRemoteDebugging { false };
 443 
 444     void parseArguments(int, char**);
 445 };
 446 
 447 static const char interactivePrompt[] = &quot;&gt;&gt;&gt; &quot;;
 448 
 449 class StopWatch {
 450 public:
 451     void start();
 452     void stop();
 453     long getElapsedMS(); // call stop() first
 454 
 455 private:
 456     MonotonicTime m_startTime;
 457     MonotonicTime m_stopTime;
 458 };
 459 
 460 void StopWatch::start()
 461 {
 462     m_startTime = MonotonicTime::now();
 463 }
 464 
 465 void StopWatch::stop()
 466 {
 467     m_stopTime = MonotonicTime::now();
 468 }
 469 
 470 long StopWatch::getElapsedMS()
 471 {
 472     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 473 }
 474 
 475 template&lt;typename Vector&gt;
 476 static inline String stringFromUTF(const Vector&amp; utf8)
 477 {
 478     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 479 }
 480 
 481 class GlobalObject : public JSGlobalObject {
 482 private:
 483     GlobalObject(VM&amp;, Structure*);
 484 
 485 public:
 486     typedef JSGlobalObject Base;
 487 
 488     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 489     {
 490         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 491         object-&gt;finishCreation(vm, arguments);
 492         return object;
 493     }
 494 
 495     static const bool needsDestruction = false;
 496 
 497     DECLARE_INFO;
 498     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 499 
 500     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 501     {
 502         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 503     }
 504 
 505     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 506 
 507 protected:
 508     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 509     {
 510         Base::finishCreation(vm);
 511 
 512         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 513         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 514         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 515         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 516         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 517         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 518         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 519         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 520         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
 521         addFunction(vm, &quot;forceGCSlowPaths&quot;, functionForceGCSlowPaths, 0);
 522         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 523         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 524         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 525         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 526         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 527         addFunction(vm, &quot;run&quot;, functionRun, 1);
 528         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 529         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 530         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 531         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 532         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 533         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 534         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 535         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 536         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 537         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 538         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 539         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 540         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 541         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 542         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 543         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
 544         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 545         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 546         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 547         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 548         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 549 #if ENABLE(SAMPLING_FLAGS)
 550         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 551         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 552 #endif
 553 
<a name="13" id="anc13"></a><span class="line-modified"> 554         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 555         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 556         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 557         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 558         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 559         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 560 
 561         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 562         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 563         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
 564 
 565         addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
 566 
 567         addFunction(vm, &quot;dumpTypesForAllVariables&quot;, functionDumpTypesForAllVariables , 0);
 568 
 569         addFunction(vm, &quot;drainMicrotasks&quot;, functionDrainMicrotasks, 0);
<a name="14" id="anc14"></a><span class="line-added"> 570         addFunction(vm, &quot;releaseWeakRefs&quot;, functionReleaseWeakRefs, 0);</span>
 571 
 572         addFunction(vm, &quot;getRandomSeed&quot;, functionGetRandomSeed, 0);
 573         addFunction(vm, &quot;setRandomSeed&quot;, functionSetRandomSeed, 1);
 574         addFunction(vm, &quot;isRope&quot;, functionIsRope, 1);
 575         addFunction(vm, &quot;callerSourceOrigin&quot;, functionCallerSourceOrigin, 0);
 576 
 577         addFunction(vm, &quot;is32BitPlatform&quot;, functionIs32BitPlatform, 0);
 578 
 579         addFunction(vm, &quot;checkModuleSyntax&quot;, functionCheckModuleSyntax, 1);
 580 
 581         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 582         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 583         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 584         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 585         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 586 #if ENABLE(SAMPLING_PROFILER)
 587         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 588         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 589 #endif
 590 
 591         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 592 
 593         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 594         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 595 
 596 #if ENABLE(WEBASSEMBLY)
 597         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 598 #endif
 599 
 600         if (!arguments.isEmpty()) {
 601             JSArray* array = constructEmptyArray(globalExec(), 0);
 602             for (size_t i = 0; i &lt; arguments.size(); ++i)
<a name="15" id="anc15"></a><span class="line-modified"> 603                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
<span class="line-modified"> 604             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
 605         }
 606 
<a name="16" id="anc16"></a><span class="line-modified"> 607         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());</span>
 608 
 609         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 610 
 611         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
<a name="17" id="anc17"></a><span class="line-modified"> 612         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);</span>
<span class="line-modified"> 613         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);</span>
 614 
 615         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
 616         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);
 617         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 618 
<a name="18" id="anc18"></a><span class="line-modified"> 619         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);</span>
 620 
 621         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
<a name="19" id="anc19"></a><span class="line-modified"> 622         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);</span>
 623 
 624         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 625         // thread and some are in the other threads. We just put them in all threads.
 626         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 627         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 628         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 629         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 630         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 631         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 632         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 633         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 634 
 635         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 636 
 637         addFunction(vm, &quot;heapCapacity&quot;, functionHeapCapacity, 0);
 638         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 639 
 640         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 641         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 642         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
<a name="20" id="anc20"></a><span class="line-added"> 643 </span>
<span class="line-added"> 644         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);</span>
 645     }
 646 
 647     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 648     {
<a name="21" id="anc21"></a><span class="line-modified"> 649         Identifier identifier = Identifier::fromString(vm, name);</span>
 650         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 651     }
 652 
 653     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         addFunction(vm, this, name, function, arguments);
 656     }
 657 
 658     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 659     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 660     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
 661     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 662 };
 663 
 664 static bool supportsRichSourceInfo = true;
 665 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 666 {
 667     return supportsRichSourceInfo;
 668 }
 669 
 670 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 671 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 672     &amp;shellSupportsRichSourceInfo,
 673     &amp;shouldInterruptScript,
 674     &amp;javaScriptRuntimeFlags,
 675     nullptr, // queueTaskToEventLoop
 676     &amp;shouldInterruptScriptBeforeTimeout,
 677     &amp;moduleLoaderImportModule,
 678     &amp;moduleLoaderResolve,
 679     &amp;moduleLoaderFetch,
 680     &amp;moduleLoaderCreateImportMetaProperties,
 681     nullptr, // moduleLoaderEvaluate
 682     nullptr, // promiseRejectionTracker
 683     nullptr, // defaultLanguage
 684     nullptr, // compileStreaming
 685     nullptr, // instantinateStreaming
 686 };
 687 
 688 GlobalObject::GlobalObject(VM&amp; vm, Structure* structure)
 689     : JSGlobalObject(vm, structure, &amp;s_globalObjectMethodTable)
 690 {
 691 }
 692 
 693 static UChar pathSeparator()
 694 {
 695 #if OS(WINDOWS)
 696     return &#39;\\&#39;;
 697 #else
 698     return &#39;/&#39;;
 699 #endif
 700 }
 701 
 702 struct DirectoryName {
 703     // In unix, it is &quot;/&quot;. In Windows, it becomes a drive letter like &quot;C:\&quot;
 704     String rootName;
 705 
 706     // If the directory name is &quot;/home/WebKit&quot;, this becomes &quot;home/WebKit&quot;. If the directory name is &quot;/&quot;, this becomes &quot;&quot;.
 707     String queryName;
 708 };
 709 
 710 struct ModuleName {
 711     ModuleName(const String&amp; moduleName);
 712 
 713     bool startsWithRoot() const
 714     {
 715         return !queries.isEmpty() &amp;&amp; queries[0].isEmpty();
 716     }
 717 
 718     Vector&lt;String&gt; queries;
 719 };
 720 
 721 ModuleName::ModuleName(const String&amp; moduleName)
 722 {
 723     // A module name given from code is represented as the UNIX style path. Like, `./A/B.js`.
 724     queries = moduleName.splitAllowingEmptyEntries(&#39;/&#39;);
 725 }
 726 
 727 static Optional&lt;DirectoryName&gt; extractDirectoryName(const String&amp; absolutePathToFile)
 728 {
 729     size_t firstSeparatorPosition = absolutePathToFile.find(pathSeparator());
 730     if (firstSeparatorPosition == notFound)
 731         return WTF::nullopt;
 732     DirectoryName directoryName;
 733     directoryName.rootName = absolutePathToFile.substring(0, firstSeparatorPosition + 1); // Include the separator.
 734     size_t lastSeparatorPosition = absolutePathToFile.reverseFind(pathSeparator());
 735     ASSERT_WITH_MESSAGE(lastSeparatorPosition != notFound, &quot;If the separator is not found, this function already returns when performing the forward search.&quot;);
 736     if (firstSeparatorPosition == lastSeparatorPosition)
 737         directoryName.queryName = StringImpl::empty();
 738     else {
 739         size_t queryStartPosition = firstSeparatorPosition + 1;
 740         size_t queryLength = lastSeparatorPosition - queryStartPosition; // Not include the last separator.
 741         directoryName.queryName = absolutePathToFile.substring(queryStartPosition, queryLength);
 742     }
 743     return directoryName;
 744 }
 745 
 746 static Optional&lt;DirectoryName&gt; currentWorkingDirectory()
 747 {
 748 #if OS(WINDOWS)
 749     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934.aspx
 750     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
 751     // The _MAX_PATH in Windows is 260. If the path of the current working directory is longer than that, _getcwd truncates the result.
 752     // And other I/O functions taking a path name also truncate it. To avoid this situation,
 753     //
 754     // (1). When opening the file in Windows for modules, we always use the abosolute path and add &quot;\\?\&quot; prefix to the path name.
 755     // (2). When retrieving the current working directory, use GetCurrentDirectory instead of _getcwd.
 756     //
 757     // In the path utility functions inside the JSC shell, we does not handle the UNC and UNCW including the network host name.
 758     DWORD bufferLength = ::GetCurrentDirectoryW(0, nullptr);
 759     if (!bufferLength)
 760         return WTF::nullopt;
 761     // In Windows, wchar_t is the UTF-16LE.
 762     // https://msdn.microsoft.com/en-us/library/dd374081.aspx
 763     // https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407.aspx
 764     Vector&lt;wchar_t&gt; buffer(bufferLength);
 765     DWORD lengthNotIncludingNull = ::GetCurrentDirectoryW(bufferLength, buffer.data());
<a name="22" id="anc22"></a><span class="line-modified"> 766     String directoryString(buffer.data(), lengthNotIncludingNull);</span>
 767     // We don&#39;t support network path like \\host\share\&lt;path name&gt;.
 768     if (directoryString.startsWith(&quot;\\\\&quot;))
 769         return WTF::nullopt;
 770 #else
 771     Vector&lt;char&gt; buffer(PATH_MAX);
 772     if (!getcwd(buffer.data(), PATH_MAX))
 773         return WTF::nullopt;
 774     String directoryString = String::fromUTF8(buffer.data());
 775 #endif
 776     if (directoryString.isEmpty())
 777         return WTF::nullopt;
 778 
 779     if (directoryString[directoryString.length() - 1] == pathSeparator())
 780         return extractDirectoryName(directoryString);
 781     // Append the seperator to represents the file name. extractDirectoryName only accepts the absolute file name.
 782     return extractDirectoryName(makeString(directoryString, pathSeparator()));
 783 }
 784 
 785 static String resolvePath(const DirectoryName&amp; directoryName, const ModuleName&amp; moduleName)
 786 {
 787     Vector&lt;String&gt; directoryPieces = directoryName.queryName.split(pathSeparator());
 788 
 789     // Only first &#39;/&#39; is recognized as the path from the root.
 790     if (moduleName.startsWithRoot())
 791         directoryPieces.clear();
 792 
 793     for (const auto&amp; query : moduleName.queries) {
 794         if (query == String(&quot;..&quot;_s)) {
 795             if (!directoryPieces.isEmpty())
 796                 directoryPieces.removeLast();
 797         } else if (!query.isEmpty() &amp;&amp; query != String(&quot;.&quot;_s))
 798             directoryPieces.append(query);
 799     }
 800 
 801     StringBuilder builder;
 802     builder.append(directoryName.rootName);
 803     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 804         builder.append(directoryPieces[i]);
 805         if (i + 1 != directoryPieces.size())
 806             builder.append(pathSeparator());
 807     }
 808     return builder.toString();
 809 }
 810 
 811 static String absolutePath(const String&amp; fileName)
 812 {
 813     auto directoryName = currentWorkingDirectory();
 814     if (!directoryName)
 815         return fileName;
 816     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 817 }
 818 
 819 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)
 820 {
 821     VM&amp; vm = globalObject-&gt;vm();
 822     auto throwScope = DECLARE_THROW_SCOPE(vm);
 823 
 824     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
 825     RETURN_IF_EXCEPTION(throwScope, nullptr);
 826 
 827     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 828     auto reject = [&amp;] (JSValue rejectionReason) {
 829         catchScope.clearException();
 830         auto result = deferred-&gt;reject(exec, rejectionReason);
 831         catchScope.clearException();
 832         return result;
 833     };
 834 
 835     if (sourceOrigin.isNull())
 836         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));
 837 
 838     const auto&amp; referrer = sourceOrigin.string();
 839     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);
 840     if (UNLIKELY(catchScope.exception()))
 841         return reject(catchScope.exception());
 842 
 843     auto directoryName = extractDirectoryName(referrer.impl());
 844     if (!directoryName)
 845         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 846 
<a name="23" id="anc23"></a><span class="line-modified"> 847     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 848     if (UNLIKELY(catchScope.exception()))
 849         return reject(catchScope.exception());
 850     return result;
 851 }
 852 
 853 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 854 {
 855     VM&amp; vm = globalObject-&gt;vm();
 856     auto scope = DECLARE_THROW_SCOPE(vm);
 857 
 858     scope.releaseAssertNoException();
 859     const Identifier key = keyValue.toPropertyKey(exec);
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (key.isSymbol())
 863         return key;
 864 
 865     if (referrerValue.isUndefined()) {
 866         auto directoryName = currentWorkingDirectory();
 867         if (!directoryName) {
 868             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 869             return { };
 870         }
<a name="24" id="anc24"></a><span class="line-modified"> 871         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 872     }
 873 
 874     const Identifier referrer = referrerValue.toPropertyKey(exec);
 875     RETURN_IF_EXCEPTION(scope, { });
 876 
 877     if (referrer.isSymbol()) {
 878         auto directoryName = currentWorkingDirectory();
 879         if (!directoryName) {
 880             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));
 881             return { };
 882         }
<a name="25" id="anc25"></a><span class="line-modified"> 883         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 884     }
 885 
 886     // If the referrer exists, we assume that the referrer is the correct absolute path.
 887     auto directoryName = extractDirectoryName(referrer.impl());
 888     if (!directoryName) {
 889         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));
 890         return { };
 891     }
<a name="26" id="anc26"></a><span class="line-modified"> 892     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));</span>
 893 }
 894 
 895 template&lt;typename Vector&gt;
 896 static void convertShebangToJSComment(Vector&amp; buffer)
 897 {
 898     if (buffer.size() &gt;= 2) {
 899         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 900             buffer[0] = buffer[1] = &#39;/&#39;;
 901     }
 902 }
 903 
 904 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 905 {
 906     if (fseek(file, 0, SEEK_END) == -1)
 907         return nullptr;
 908     long bufferCapacity = ftell(file);
 909     if (bufferCapacity == -1)
 910         return nullptr;
 911     if (fseek(file, 0, SEEK_SET) == -1)
 912         return nullptr;
 913     auto result = Uint8Array::tryCreate(bufferCapacity);
 914     if (!result)
 915         return nullptr;
 916     size_t readSize = fread(result-&gt;data(), 1, bufferCapacity, file);
 917     if (readSize != static_cast&lt;size_t&gt;(bufferCapacity))
 918         return nullptr;
 919     return result;
 920 }
 921 
 922 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName)
 923 {
 924     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 925     if (!f) {
 926         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 927         return nullptr;
 928     }
 929 
 930     RefPtr&lt;Uint8Array&gt; result = fillBufferWithContentsOfFile(f);
 931     fclose(f);
 932 
 933     return result;
 934 }
 935 
 936 template&lt;typename Vector&gt;
 937 static bool fillBufferWithContentsOfFile(FILE* file, Vector&amp; buffer)
 938 {
 939     // We might have injected &quot;use strict&quot;; at the top.
 940     size_t initialSize = buffer.size();
 941     if (fseek(file, 0, SEEK_END) == -1)
 942         return false;
 943     long bufferCapacity = ftell(file);
 944     if (bufferCapacity == -1)
 945         return false;
 946     if (fseek(file, 0, SEEK_SET) == -1)
 947         return false;
 948     buffer.resize(bufferCapacity + initialSize);
 949     size_t readSize = fread(buffer.data() + initialSize, 1, buffer.size(), file);
 950     return readSize == buffer.size() - initialSize;
 951 }
 952 
 953 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 954 {
 955     FILE* f = fopen(fileName.utf8().data(), &quot;rb&quot;);
 956     if (!f) {
 957         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
 958         return false;
 959     }
 960 
 961     bool result = fillBufferWithContentsOfFile(f, buffer);
 962     fclose(f);
 963 
 964     return result;
 965 }
 966 
 967 static bool fetchScriptFromLocalFileSystem(const String&amp; fileName, Vector&lt;char&gt;&amp; buffer)
 968 {
 969     if (!fillBufferWithContentsOfFile(fileName, buffer))
 970         return false;
 971     convertShebangToJSComment(buffer);
 972     return true;
 973 }
 974 
 975 class ShellSourceProvider : public StringSourceProvider {
 976 public:
 977     static Ref&lt;ShellSourceProvider&gt; create(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
 978     {
 979         return adoptRef(*new ShellSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType));
 980     }
 981 
 982     ~ShellSourceProvider()
 983     {
<a name="27" id="anc27"></a><span class="line-modified"> 984         commitCachedBytecode();</span>



 985     }
 986 
<a name="28" id="anc28"></a><span class="line-modified"> 987     RefPtr&lt;CachedBytecode&gt; cachedBytecode() const override</span>
 988     {
<a name="29" id="anc29"></a><span class="line-modified"> 989         if (!m_cachedBytecode)</span>
<span class="line-added"> 990             loadBytecode();</span>
<span class="line-added"> 991         return m_cachedBytecode.copyRef();</span>
<span class="line-added"> 992     }</span>
<span class="line-added"> 993 </span>
<span class="line-added"> 994     void updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp;, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock) const override</span>
<span class="line-added"> 995     {</span>
<span class="line-added"> 996         if (!cacheEnabled() || !m_cachedBytecode)</span>
<span class="line-added"> 997             return;</span>
<span class="line-added"> 998         BytecodeCacheError error;</span>
<span class="line-added"> 999         RefPtr&lt;CachedBytecode&gt; cachedBytecode = encodeFunctionCodeBlock(executable-&gt;vm(), codeBlock, error);</span>
<span class="line-added">1000         if (cachedBytecode &amp;&amp; !error.isValid())</span>
<span class="line-added">1001             m_cachedBytecode-&gt;addFunctionUpdate(executable, kind, *cachedBytecode);</span>
1002     }
1003 
1004     void cacheBytecode(const BytecodeCacheGenerator&amp; generator) const override
1005     {
<a name="30" id="anc30"></a><span class="line-modified">1006         if (!cacheEnabled())</span>
<span class="line-added">1007             return;</span>
<span class="line-added">1008         if (!m_cachedBytecode)</span>
<span class="line-added">1009             m_cachedBytecode = CachedBytecode::create();</span>
<span class="line-added">1010         auto update = generator();</span>
<span class="line-added">1011         if (update)</span>
<span class="line-added">1012             m_cachedBytecode-&gt;addGlobalUpdate(*update);</span>
<span class="line-added">1013     }</span>
<span class="line-added">1014 </span>
<span class="line-added">1015     void commitCachedBytecode() const override</span>
<span class="line-added">1016     {</span>
<span class="line-added">1017         if (!cacheEnabled() || !m_cachedBytecode || !m_cachedBytecode-&gt;hasUpdates())</span>
<span class="line-added">1018             return;</span>
<span class="line-added">1019 </span>
<span class="line-added">1020         auto clearBytecode = makeScopeExit([&amp;] {</span>
<span class="line-added">1021             m_cachedBytecode = nullptr;</span>
<span class="line-added">1022         });</span>
<span class="line-added">1023 </span>
1024         String filename = cachePath();
<a name="31" id="anc31"></a><span class="line-modified">1025         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Write, {FileSystem::FileLockMode::Exclusive, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-added">1026         if (!FileSystem::isHandleValid(fd))</span>
1027             return;
<a name="32" id="anc32"></a><span class="line-modified">1028 </span>
<span class="line-modified">1029         auto closeFD = makeScopeExit([&amp;] {</span>
<span class="line-added">1030             FileSystem::unlockAndCloseFile(fd);</span>
<span class="line-added">1031         });</span>
<span class="line-added">1032 </span>
<span class="line-added">1033         long long fileSize;</span>
<span class="line-added">1034         if (!FileSystem::getFileSize(fd, fileSize))</span>
1035             return;
<a name="33" id="anc33"></a><span class="line-modified">1036 </span>
<span class="line-modified">1037         size_t cacheFileSize;</span>
<span class="line-modified">1038         if (!WTF::convertSafely(fileSize, cacheFileSize) || cacheFileSize != m_cachedBytecode-&gt;size()) {</span>
<span class="line-modified">1039             // The bytecode cache has already been updated</span>
<span class="line-added">1040             return;</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042 </span>
<span class="line-added">1043         if (!FileSystem::truncateFile(fd, m_cachedBytecode-&gt;sizeForUpdate()))</span>
<span class="line-added">1044             return;</span>
<span class="line-added">1045 </span>
<span class="line-added">1046         m_cachedBytecode-&gt;commitUpdates([&amp;] (off_t offset, const void* data, size_t size) {</span>
<span class="line-added">1047             long long result = FileSystem::seekFile(fd, offset, FileSystem::FileSeekOrigin::Beginning);</span>
<span class="line-added">1048             ASSERT_UNUSED(result, result != -1);</span>
<span class="line-added">1049             size_t bytesWritten = static_cast&lt;size_t&gt;(FileSystem::writeToFile(fd, static_cast&lt;const char*&gt;(data), size));</span>
<span class="line-added">1050             ASSERT_UNUSED(bytesWritten, bytesWritten == size);</span>
<span class="line-added">1051         });</span>
1052     }
1053 
1054 private:
1055     String cachePath() const
1056     {
<a name="34" id="anc34"></a><span class="line-modified">1057         if (!cacheEnabled())</span>

1058             return static_cast&lt;const char*&gt;(nullptr);
<a name="35" id="anc35"></a><span class="line-modified">1059         const char* cachePath = Options::diskCachePath();</span>
<span class="line-modified">1060         String filename = FileSystem::encodeForFileName(FileSystem::lastComponentOfPathIgnoringTrailingSlash(sourceOrigin().string()));</span>
<span class="line-modified">1061         return FileSystem::pathByAppendingComponent(cachePath, makeString(source().toString().hash(), &#39;-&#39;, filename, &quot;.bytecode-cache&quot;));</span>
1062     }
1063 
<a name="36" id="anc36"></a><span class="line-modified">1064     void loadBytecode() const</span>
1065     {
<a name="37" id="anc37"></a><span class="line-modified">1066         if (!cacheEnabled())</span>
<span class="line-added">1067             return;</span>
<span class="line-added">1068 </span>
1069         String filename = cachePath();
1070         if (filename.isNull())
1071             return;
1072 
<a name="38" id="anc38"></a><span class="line-modified">1073         auto fd = FileSystem::openAndLockFile(filename, FileSystem::FileOpenMode::Read, {FileSystem::FileLockMode::Shared, FileSystem::FileLockMode::Nonblocking});</span>
<span class="line-modified">1074         if (!FileSystem::isHandleValid(fd))</span>
1075             return;
1076 
1077         auto closeFD = makeScopeExit([&amp;] {
<a name="39" id="anc39"></a><span class="line-modified">1078             FileSystem::unlockAndCloseFile(fd);</span>
1079         });
1080 
<a name="40" id="anc40"></a><span class="line-modified">1081         bool success;</span>
<span class="line-modified">1082         FileSystem::MappedFileData mappedFileData(fd, FileSystem::MappedFileMode::Private, success);</span>



1083 
<a name="41" id="anc41"></a><span class="line-modified">1084         if (!success)</span>

1085             return;
<a name="42" id="anc42"></a><span class="line-modified">1086 </span>
<span class="line-modified">1087         m_cachedBytecode = CachedBytecode::create(WTFMove(mappedFileData));</span>
1088     }
1089 
1090     ShellSourceProvider(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url, const TextPosition&amp; startPosition, SourceProviderSourceType sourceType)
1091         : StringSourceProvider(source, sourceOrigin, WTFMove(url), startPosition, sourceType)
1092     {
<a name="43" id="anc43"></a>
1093     }
1094 
<a name="44" id="anc44"></a><span class="line-modified">1095     static bool cacheEnabled()</span>
<span class="line-added">1096     {</span>
<span class="line-added">1097         static bool enabled = !!Options::diskCachePath();</span>
<span class="line-added">1098         return enabled;</span>
<span class="line-added">1099     }</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     mutable RefPtr&lt;CachedBytecode&gt; m_cachedBytecode;</span>
1102 };
1103 
1104 static inline SourceCode jscSource(const String&amp; source, const SourceOrigin&amp; sourceOrigin, URL&amp;&amp; url = URL(), const TextPosition&amp; startPosition = TextPosition(), SourceProviderSourceType sourceType = SourceProviderSourceType::Program)
1105 {
1106     return SourceCode(ShellSourceProvider::create(source, sourceOrigin, WTFMove(url), startPosition, sourceType), startPosition.m_line.oneBasedInt(), startPosition.m_column.oneBasedInt());
1107 }
1108 
1109 template&lt;typename Vector&gt;
1110 static inline SourceCode jscSource(const Vector&amp; utf8, const SourceOrigin&amp; sourceOrigin, const String&amp; filename)
1111 {
1112     // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
1113     String str = stringFromUTF(utf8);
1114     return jscSource(str, sourceOrigin, URL({ }, filename));
1115 }
1116 
1117 template&lt;typename Vector&gt;
1118 static bool fetchModuleFromLocalFileSystem(const String&amp; fileName, Vector&amp; buffer)
1119 {
1120     // We assume that fileName is always an absolute path.
1121 #if OS(WINDOWS)
1122     // https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx#maxpath
1123     // Use long UNC to pass the long path name to the Windows APIs.
<a name="45" id="anc45"></a><span class="line-modified">1124     auto pathName = makeString(&quot;\\\\?\\&quot;, fileName).wideCharacters();</span>

1125     struct _stat status { };
1126     if (_wstat(pathName.data(), &amp;status))
1127         return false;
1128     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1129         return false;
1130 
1131     FILE* f = _wfopen(pathName.data(), L&quot;rb&quot;);
1132 #else
1133     auto pathName = fileName.utf8();
1134     struct stat status { };
1135     if (stat(pathName.data(), &amp;status))
1136         return false;
1137     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1138         return false;
1139 
1140     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1141 #endif
1142     if (!f) {
1143         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1144         return false;
1145     }
1146 
1147     bool result = fillBufferWithContentsOfFile(f, buffer);
1148     if (result)
1149         convertShebangToJSComment(buffer);
1150     fclose(f);
1151 
1152     return result;
1153 }
1154 
1155 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)
1156 {
1157     VM&amp; vm = globalObject-&gt;vm();
1158     auto throwScope = DECLARE_THROW_SCOPE(vm);
1159     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
1160     RETURN_IF_EXCEPTION(throwScope, nullptr);
1161 
1162     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1163     auto reject = [&amp;] (JSValue rejectionReason) {
1164         catchScope.clearException();
1165         auto result = deferred-&gt;reject(exec, rejectionReason);
1166         catchScope.clearException();
1167         return result;
1168     };
1169 
1170     String moduleKey = key.toWTFString(exec);
1171     if (UNLIKELY(catchScope.exception()))
1172         return reject(catchScope.exception());
1173 
1174     // Here, now we consider moduleKey as the fileName.
1175     Vector&lt;uint8_t&gt; buffer;
1176     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
1177         return reject(createError(exec, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));
1178 
1179 
1180     URL moduleURL = URL({ }, moduleKey);
1181 #if ENABLE(WEBASSEMBLY)
1182     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1183     if (buffer.size() &gt;= 4) {
1184         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1185             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1186             catchScope.releaseAssertNoException();
1187             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1188             catchScope.releaseAssertNoException();
1189             auto result = deferred-&gt;resolve(exec, sourceCode);
1190             catchScope.clearException();
1191             return result;
1192         }
1193     }
1194 #endif
1195 
1196     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1197     catchScope.releaseAssertNoException();
1198     auto result = deferred-&gt;resolve(exec, sourceCode);
1199     catchScope.clearException();
1200     return result;
1201 }
1202 
1203 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
1204 {
1205     VM&amp; vm = exec-&gt;vm();
1206     auto scope = DECLARE_THROW_SCOPE(vm);
1207 
1208     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());
1209     RETURN_IF_EXCEPTION(scope, nullptr);
1210 
<a name="46" id="anc46"></a><span class="line-modified">1211     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);</span>
1212     RETURN_IF_EXCEPTION(scope, nullptr);
1213 
1214     return metaProperties;
1215 }
1216 
1217 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)
1218 {
1219     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1220     if (expectedString)
1221         return expectedString.value();
1222     switch (expectedString.error()) {
1223     case UTF8ConversionError::OutOfMemory:
1224         throwOutOfMemoryError(exec, scope);
1225         break;
1226     case UTF8ConversionError::IllegalSource:
1227         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));
1228         break;
1229     case UTF8ConversionError::SourceExhausted:
1230         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));
1231         break;
1232     default:
1233         RELEASE_ASSERT_NOT_REACHED();
1234     }
1235     return { };
1236 }
1237 
1238 static EncodedJSValue printInternal(ExecState* exec, FILE* out)
1239 {
1240     VM&amp; vm = exec-&gt;vm();
1241     auto scope = DECLARE_THROW_SCOPE(vm);
1242 
1243     if (asyncTestExpectedPasses) {
1244         JSValue value = exec-&gt;argument(0);
1245         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(exec).impl(), &quot;Test262:AsyncTestComplete&quot;)) {
1246             asyncTestPasses++;
1247             return JSValue::encode(jsUndefined());
1248         }
1249     }
1250 
1251     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1252         if (i)
1253             if (EOF == fputc(&#39; &#39;, out))
1254                 goto fail;
1255 
1256         auto viewWithString = exec-&gt;uncheckedArgument(i).toString(exec)-&gt;viewWithUnderlyingString(exec);
1257         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1258         auto string = cStringFromViewWithString(exec, scope, viewWithString);
1259         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1260         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1261             goto fail;
1262     }
1263 
1264     fputc(&#39;\n&#39;, out);
1265 fail:
1266     fflush(out);
1267     return JSValue::encode(jsUndefined());
1268 }
1269 
1270 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }
1271 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }
1272 
1273 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
1274 {
1275     VM&amp; vm = exec-&gt;vm();
1276     auto scope = DECLARE_THROW_SCOPE(vm);
1277     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);
1278     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1279     auto string = cStringFromViewWithString(exec, scope, viewWithString);
1280     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1281     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1282     return JSValue::encode(jsUndefined());
1283 }
1284 
1285 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
1286 {
<a name="47" id="anc47"></a><span class="line-added">1287     VM&amp; vm = exec-&gt;vm();</span>
1288     if (exec-&gt;argumentCount() &lt; 1)
1289         return JSValue::encode(jsUndefined());
<a name="48" id="anc48"></a><span class="line-modified">1290     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
1291 }
1292 
1293 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
1294 {
1295     if (exec-&gt;argumentCount() &lt; 1)
1296         return JSValue::encode(jsUndefined());
1297     VM&amp; vm = exec-&gt;vm();
1298     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));
1299     if (!object)
<a name="49" id="anc49"></a><span class="line-modified">1300         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));</span>
<span class="line-modified">1301     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));</span>
1302 }
1303 
1304 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
1305 {
1306     VM&amp; vm = exec-&gt;vm();
1307     auto scope = DECLARE_THROW_SCOPE(vm);
1308 
1309     if (exec-&gt;argumentCount() &gt;= 1) {
1310         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));
1311         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1312         sleep(seconds);
1313     }
1314 
1315     return JSValue::encode(jsUndefined());
1316 }
1317 
1318 class FunctionJSCStackFunctor {
1319 public:
1320     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1321         : m_trace(trace)
1322     {
1323     }
1324 
1325     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1326     {
1327         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1328         return StackVisitor::Continue;
1329     }
1330 
1331 private:
1332     StringBuilder&amp; m_trace;
1333 };
1334 
1335 EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)
1336 {
1337     StringBuilder trace;
1338     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1339 
1340     FunctionJSCStackFunctor functor(trace);
1341     exec-&gt;iterate(functor);
1342     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1343     return JSValue::encode(jsUndefined());
1344 }
1345 
1346 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)
1347 {
1348     VM&amp; vm = exec-&gt;vm();
1349     JSLockHolder lock(vm);
1350     vm.heap.collectNow(Sync, CollectionScope::Full);
1351     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1352 }
1353 
1354 EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)
1355 {
1356     VM&amp; vm = exec-&gt;vm();
1357     JSLockHolder lock(vm);
1358     vm.heap.collectSync(CollectionScope::Full);
1359     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1360 }
1361 
1362 EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
1363 {
1364     VM&amp; vm = exec-&gt;vm();
1365     JSLockHolder lock(vm);
1366     vm.heap.collectSync(CollectionScope::Eden);
1367     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1368 }
1369 
1370 EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)
1371 {
1372     // It&#39;s best for this to be the first thing called in the
1373     // JS program so the option is set to true before we JIT.
1374     Options::forceGCSlowPaths() = true;
1375     return JSValue::encode(jsUndefined());
1376 }
1377 
1378 EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)
1379 {
1380     VM&amp; vm = exec-&gt;vm();
1381     JSLockHolder lock(vm);
1382     return JSValue::encode(jsNumber(vm.heap.size()));
1383 }
1384 
1385 class JSCMemoryFootprint : public JSDestructibleObject {
1386     using Base = JSDestructibleObject;
1387 public:
1388     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1389         : Base(vm, structure)
1390     { }
1391 
1392     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1393     {
1394         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1395     }
1396 
1397     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
1399         Structure* structure = createStructure(vm, globalObject, jsNull());
<a name="50" id="anc50"></a><span class="line-modified">1400         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);</span>
1401         footprint-&gt;finishCreation(vm);
1402         return footprint;
1403     }
1404 
1405     void finishCreation(VM&amp; vm)
1406     {
1407         Base::finishCreation(vm);
1408 
1409         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
1410             JSCMemoryFootprint::addProperty(vm, name, value);
1411         };
1412 
1413         MemoryFootprint footprint = MemoryFootprint::now();
1414 
1415         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1416         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1417     }
1418 
1419     DECLARE_INFO;
1420 
1421 private:
1422     void addProperty(VM&amp; vm, const char* name, JSValue value)
1423     {
<a name="51" id="anc51"></a><span class="line-modified">1424         Identifier identifier = Identifier::fromString(vm, name);</span>
1425         putDirect(vm, identifier, value);
1426     }
1427 };
1428 
1429 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1430 
1431 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)
1432 {
1433     VM&amp; vm = exec-&gt;vm();
1434     JSLockHolder lock(vm);
1435     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));
1436 }
1437 
1438 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)
1439 {
1440     MemoryFootprint::resetPeak();
1441     return JSValue::encode(jsUndefined());
1442 }
1443 
1444 // This function is not generally very helpful in 64-bit code as the tag and payload
1445 // share a register. But in 32-bit JITed code the tag may not be checked if an
1446 // optimization removes type checking requirements, such as in ===.
1447 EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)
1448 {
1449     JSValue value = exec-&gt;argument(0);
1450     if (!value.isCell())
1451         return JSValue::encode(jsUndefined());
1452     // Need to cast to uint64_t so bitwise_cast will play along.
1453     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1454     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1455     return returnValue;
1456 }
1457 
1458 EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)
1459 {
1460     // We need this function for compatibility with the Mozilla JS tests but for now
1461     // we don&#39;t actually do any version-specific handling
1462     return JSValue::encode(jsUndefined());
1463 }
1464 
1465 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)
1466 {
1467     VM&amp; vm = exec-&gt;vm();
1468     auto scope = DECLARE_THROW_SCOPE(vm);
1469 
1470     String fileName = exec-&gt;argument(0).toWTFString(exec);
1471     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1472     Vector&lt;char&gt; script;
1473     if (!fetchScriptFromLocalFileSystem(fileName, script))
1474         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1475 
1476     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1477 
1478     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1479     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1480     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1481         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1482         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1483     }
<a name="52" id="anc52"></a><span class="line-modified">1484     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>

1485 
1486     NakedPtr&lt;Exception&gt; exception;
1487     StopWatch stopWatch;
1488     stopWatch.start();
1489     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
1490     stopWatch.stop();
1491 
1492     if (exception) {
1493         throwException(globalObject-&gt;globalExec(), scope, exception);
1494         return JSValue::encode(jsUndefined());
1495     }
1496 
1497     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1498 }
1499 
1500 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)
1501 {
1502     VM&amp; vm = exec-&gt;vm();
1503     auto scope = DECLARE_THROW_SCOPE(vm);
1504 
1505     String source = exec-&gt;argument(0).toWTFString(exec);
1506     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1507 
1508     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1509 
1510     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);
1511     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1512     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {
1513         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
<a name="53" id="anc53"></a><span class="line-modified">1516     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>

1517 
1518     NakedPtr&lt;Exception&gt; exception;
<a name="54" id="anc54"></a><span class="line-modified">1519     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1520 
1521     if (exception) {
1522         scope.throwException(globalObject-&gt;globalExec(), exception);
1523         return JSValue::encode(jsUndefined());
1524     }
1525 
1526     return JSValue::encode(globalObject);
1527 }
1528 
1529 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)
1530 {
1531     VM&amp; vm = exec-&gt;vm();
1532     auto scope = DECLARE_THROW_SCOPE(vm);
1533 
1534     String fileName = exec-&gt;argument(0).toWTFString(exec);
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1536     Vector&lt;char&gt; script;
1537     if (!fetchScriptFromLocalFileSystem(fileName, script))
1538         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1539 
1540     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1541 
1542     NakedPtr&lt;Exception&gt; evaluationException;
1543     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
1544     if (evaluationException)
1545         throwException(exec, scope, evaluationException);
1546     return JSValue::encode(result);
1547 }
1548 
1549 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)
1550 {
1551     VM&amp; vm = exec-&gt;vm();
1552     auto scope = DECLARE_THROW_SCOPE(vm);
1553 
1554     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1555     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1556     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1557 
1558     NakedPtr&lt;Exception&gt; evaluationException;
<a name="55" id="anc55"></a><span class="line-modified">1559     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1560     if (evaluationException)
1561         throwException(exec, scope, evaluationException);
1562     return JSValue::encode(result);
1563 }
1564 
1565 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)
1566 {
1567     VM&amp; vm = exec-&gt;vm();
1568     auto scope = DECLARE_THROW_SCOPE(vm);
1569 
1570     String fileName = exec-&gt;argument(0).toWTFString(exec);
1571     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572 
1573     bool isBinary = false;
1574     if (exec-&gt;argumentCount() &gt; 1) {
1575         String type = exec-&gt;argument(1).toWTFString(exec);
1576         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1577         if (type != &quot;binary&quot;)
1578             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);
1579         isBinary = true;
1580     }
1581 
1582     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1583     if (!content)
1584         return throwVMError(exec, scope, &quot;Could not open file.&quot;);
1585 
1586     if (!isBinary)
<a name="56" id="anc56"></a><span class="line-modified">1587         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));</span>
1588 
1589     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);
1590     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1591     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1592 
1593     return JSValue::encode(result);
1594 }
1595 
1596 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
1597 {
1598     VM&amp; vm = exec-&gt;vm();
1599     auto scope = DECLARE_THROW_SCOPE(vm);
1600 
1601     String fileName = exec-&gt;argument(0).toWTFString(exec);
1602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1603     Vector&lt;char&gt; script;
1604     if (!fetchScriptFromLocalFileSystem(fileName, script))
1605         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));
1606 
1607     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
1608 
1609     StopWatch stopWatch;
1610     stopWatch.start();
1611 
1612     JSValue syntaxException;
1613     bool validSyntax = checkSyntax(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);
1614     stopWatch.stop();
1615 
1616     if (!validSyntax)
1617         throwException(exec, scope, syntaxException);
1618     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1619 }
1620 
1621 #if ENABLE(SAMPLING_FLAGS)
1622 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)
1623 {
1624     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1625         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));
1626         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1627             SamplingFlags::setFlag(flag);
1628     }
1629     return JSValue::encode(jsNull());
1630 }
1631 
1632 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)
1633 {
1634     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
1635         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));
1636         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1637             SamplingFlags::clearFlag(flag);
1638     }
1639     return JSValue::encode(jsNull());
1640 }
1641 #endif
1642 
1643 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)
1644 {
1645     return JSValue::encode(jsNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandom().seed()));
1646 }
1647 
1648 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)
1649 {
1650     VM&amp; vm = exec-&gt;vm();
1651     auto scope = DECLARE_THROW_SCOPE(vm);
1652 
1653     unsigned seed = exec-&gt;argument(0).toUInt32(exec);
1654     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1655     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);
1656     return JSValue::encode(jsUndefined());
1657 }
1658 
1659 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)
1660 {
1661     JSValue argument = exec-&gt;argument(0);
1662     if (!argument.isString())
1663         return JSValue::encode(jsBoolean(false));
1664     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1665     return JSValue::encode(jsBoolean(!impl));
1666 }
1667 
1668 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
1669 {
1670     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();
1671     if (sourceOrigin.isNull())
1672         return JSValue::encode(jsNull());
<a name="57" id="anc57"></a><span class="line-modified">1673     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
1674 }
1675 
1676 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
1677 {
1678     Vector&lt;char, 256&gt; line;
1679     int c;
1680     while ((c = getchar()) != EOF) {
1681         // FIXME: Should we also break on \r?
1682         if (c == &#39;\n&#39;)
1683             break;
1684         line.append(c);
1685     }
1686     line.append(&#39;\0&#39;);
<a name="58" id="anc58"></a><span class="line-modified">1687     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
1688 }
1689 
1690 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
1691 {
1692     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1693 }
1694 
1695 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)
1696 {
1697     return JSValue::encode(setNeverInline(exec));
1698 }
1699 
1700 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)
1701 {
1702     return JSValue::encode(setNeverOptimize(exec));
1703 }
1704 
1705 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)
1706 {
1707     if (exec-&gt;argumentCount()) {
1708         FunctionExecutable* executable = getExecutableForFunction(exec-&gt;argument(0));
1709         if (executable)
1710             executable-&gt;setNeverFTLOptimize(true);
1711     }
1712     return JSValue::encode(jsUndefined());
1713 }
1714 
1715 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)
1716 {
1717     return JSValue::encode(setCannotUseOSRExitFuzzing(exec));
1718 }
1719 
1720 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)
1721 {
1722     return JSValue::encode(optimizeNextInvocation(exec));
1723 }
1724 
1725 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)
1726 {
1727     return JSValue::encode(numberOfDFGCompiles(exec));
1728 }
1729 
1730 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1731     : m_contents(WTFMove(contents))
1732     , m_index(index)
1733 {
1734 }
1735 
1736 Message::~Message()
1737 {
1738 }
1739 
1740 Worker::Worker(Workers&amp; workers)
1741     : m_workers(workers)
1742 {
1743     auto locker = holdLock(m_workers.m_lock);
1744     m_workers.m_workers.append(this);
1745 
1746     *currentWorker() = this;
1747 }
1748 
1749 Worker::~Worker()
1750 {
1751     auto locker = holdLock(m_workers.m_lock);
1752     RELEASE_ASSERT(isOnList());
1753     remove();
1754 }
1755 
1756 void Worker::enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt; message)
1757 {
1758     m_messages.append(message);
1759 }
1760 
1761 RefPtr&lt;Message&gt; Worker::dequeue()
1762 {
1763     auto locker = holdLock(m_workers.m_lock);
1764     while (m_messages.isEmpty())
1765         m_workers.m_condition.wait(m_workers.m_lock);
1766     return m_messages.takeFirst();
1767 }
1768 
1769 Worker&amp; Worker::current()
1770 {
1771     return **currentWorker();
1772 }
1773 
1774 ThreadSpecific&lt;Worker*&gt;&amp; Worker::currentWorker()
1775 {
1776     static ThreadSpecific&lt;Worker*&gt;* result;
1777     static std::once_flag flag;
1778     std::call_once(
1779         flag,
1780         [] () {
1781             result = new ThreadSpecific&lt;Worker*&gt;();
1782         });
1783     return *result;
1784 }
1785 
1786 Workers::Workers()
1787 {
1788 }
1789 
1790 Workers::~Workers()
1791 {
1792     UNREACHABLE_FOR_PLATFORM();
1793 }
1794 
1795 template&lt;typename Func&gt;
1796 void Workers::broadcast(const Func&amp; func)
1797 {
1798     auto locker = holdLock(m_lock);
1799     for (Worker* worker = m_workers.begin(); worker != m_workers.end(); worker = worker-&gt;next()) {
1800         if (worker != &amp;Worker::current())
1801             func(locker, *worker);
1802     }
1803     m_condition.notifyAll();
1804 }
1805 
1806 void Workers::report(const String&amp; string)
1807 {
1808     auto locker = holdLock(m_lock);
1809     m_reports.append(string.isolatedCopy());
1810     m_condition.notifyAll();
1811 }
1812 
1813 String Workers::tryGetReport()
1814 {
1815     auto locker = holdLock(m_lock);
1816     if (m_reports.isEmpty())
1817         return String();
1818     return m_reports.takeFirst();
1819 }
1820 
1821 String Workers::getReport()
1822 {
1823     auto locker = holdLock(m_lock);
1824     while (m_reports.isEmpty())
1825         m_condition.wait(m_lock);
1826     return m_reports.takeFirst();
1827 }
1828 
1829 Workers&amp; Workers::singleton()
1830 {
1831     static Workers* result;
1832     static std::once_flag flag;
1833     std::call_once(
1834         flag,
1835         [] {
1836             result = new Workers();
1837         });
1838     return *result;
1839 }
1840 
1841 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
1842 {
1843     VM&amp; vm = exec-&gt;vm();
1844     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
<a name="59" id="anc59"></a><span class="line-modified">1845     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));</span>
1846 }
1847 
1848 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
1849 {
1850     return functionTransferArrayBuffer(exec);
1851 }
1852 
1853 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)
1854 {
1855     VM&amp; vm = exec-&gt;vm();
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
1858     String sourceCode = exec-&gt;argument(0).toWTFString(exec);
1859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1860 
1861     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,
<a name="60" id="anc60"></a><span class="line-modified">1862         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
1863     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1864     if (!globalObject)
1865         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));
1866 
1867     NakedPtr&lt;Exception&gt; evaluationException;
1868     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);
1869     if (evaluationException)
1870         throwException(exec, scope, evaluationException);
1871     return JSValue::encode(result);
1872 }
1873 
1874 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)
1875 {
1876     VM&amp; vm = exec-&gt;vm();
1877     auto scope = DECLARE_THROW_SCOPE(vm);
1878 
1879     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();
1880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1881 
1882     Lock didStartLock;
1883     Condition didStartCondition;
1884     bool didStart = false;
1885 
1886     Thread::create(
1887         &quot;JSC Agent&quot;,
1888         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1889             CommandLine commandLine(0, nullptr);
1890             commandLine.m_interactive = false;
1891             runJSC(
1892                 commandLine, true,
1893                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1894                     // Notify the thread that started us that we have registered a worker.
1895                     {
1896                         auto locker = holdLock(didStartLock);
1897                         didStart = true;
1898                         didStartCondition.notifyOne();
1899                     }
1900 
1901                     NakedPtr&lt;Exception&gt; evaluationException;
1902                     JSValue result;
<a name="61" id="anc61"></a><span class="line-modified">1903                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1904                     if (evaluationException)
1905                         result = evaluationException-&gt;value();
1906                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);
1907                     if (!success)
1908                         exit(1);
1909                 });
1910         })-&gt;detach();
1911 
1912     {
1913         auto locker = holdLock(didStartLock);
1914         while (!didStart)
1915             didStartCondition.wait(didStartLock);
1916     }
1917 
1918     return JSValue::encode(jsUndefined());
1919 }
1920 
1921 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)
1922 {
1923     VM&amp; vm = exec-&gt;vm();
1924     auto scope = DECLARE_THROW_SCOPE(vm);
1925 
1926     JSValue callback = exec-&gt;argument(0);
1927     CallData callData;
1928     CallType callType = getCallData(vm, callback, callData);
1929     if (callType == CallType::None)
1930         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected callback&quot;_s)));
1931 
1932     RefPtr&lt;Message&gt; message;
1933     {
1934         ReleaseHeapAccessScope releaseAccess(vm.heap);
1935         message = Worker::current().dequeue();
1936     }
1937 
1938     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1939     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
1940     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));
1941 
1942     MarkedArgumentBuffer args;
1943     args.append(jsBuffer);
1944     args.append(jsNumber(message-&gt;index()));
1945     if (UNLIKELY(args.hasOverflowed()))
1946         return JSValue::encode(throwOutOfMemoryError(exec, scope));
1947     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));
1948 }
1949 
1950 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)
1951 {
1952     VM&amp; vm = exec-&gt;vm();
1953     auto scope = DECLARE_THROW_SCOPE(vm);
1954 
1955     String report = exec-&gt;argument(0).toWTFString(exec);
1956     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1957 
1958     Workers::singleton().report(report);
1959 
1960     return JSValue::encode(jsUndefined());
1961 }
1962 
1963 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)
1964 {
1965     VM&amp; vm = exec-&gt;vm();
1966     auto scope = DECLARE_THROW_SCOPE(vm);
1967 
1968     if (exec-&gt;argumentCount() &gt;= 1) {
1969         Seconds seconds = Seconds::fromMilliseconds(exec-&gt;argument(0).toNumber(exec));
1970         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1971         sleep(seconds);
1972     }
1973     return JSValue::encode(jsUndefined());
1974 }
1975 
1976 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)
1977 {
1978     VM&amp; vm = exec-&gt;vm();
1979     auto scope = DECLARE_THROW_SCOPE(vm);
1980 
1981     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));
1982     if (!jsBuffer || !jsBuffer-&gt;isShared())
1983         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected SharedArrayBuffer&quot;_s)));
1984 
1985     int32_t index = exec-&gt;argument(1).toInt32(exec);
1986     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1987 
1988     Workers::singleton().broadcast(
1989         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1990             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1991             ArrayBufferContents contents;
1992             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1993             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1994             worker.enqueue(locker, message);
1995         });
1996 
1997     return JSValue::encode(jsUndefined());
1998 }
1999 
2000 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)
2001 {
2002     VM&amp; vm = exec-&gt;vm();
2003 
2004     String string = Workers::singleton().tryGetReport();
2005     if (!string)
2006         return JSValue::encode(jsNull());
2007 
<a name="62" id="anc62"></a><span class="line-modified">2008     return JSValue::encode(jsString(vm, string));</span>
2009 }
2010 
2011 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
2012 {
2013     return JSValue::encode(jsUndefined());
2014 }
2015 
2016 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)
2017 {
2018     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2019 }
2020 
2021 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)
2022 {
2023     VM&amp; vm = exec-&gt;vm();
2024 
2025     String string;
2026     {
2027         ReleaseHeapAccessScope releaseAccess(vm.heap);
2028         string = Workers::singleton().getReport();
2029     }
2030     if (!string)
2031         return JSValue::encode(jsNull());
2032 
<a name="63" id="anc63"></a><span class="line-modified">2033     return JSValue::encode(jsString(vm, string));</span>
2034 }
2035 
2036 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
2037 {
2038     VM&amp; vm = exec-&gt;vm();
2039     return JSValue::encode(jsNumber(vm.heap.capacity()));
2040 }
2041 
2042 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)
2043 {
2044     VM&amp; vm = exec-&gt;vm();
2045     auto scope = DECLARE_THROW_SCOPE(vm);
2046 
2047     double sleepTimeMs = 0;
2048     if (exec-&gt;argumentCount() &gt;= 1) {
2049         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);
2050         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2051     }
2052 
2053     vm.heap.releaseAccess();
2054     if (sleepTimeMs)
2055         sleep(Seconds::fromMilliseconds(sleepTimeMs));
2056     vm.heap.acquireAccess();
2057     return JSValue::encode(jsUndefined());
2058 }
2059 
2060 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)
2061 {
2062     supportsRichSourceInfo = false;
2063     return JSValue::encode(jsUndefined());
2064 }
2065 
2066 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)
2067 {
2068     Vector&lt;void*&gt; ptrs;
2069     for (unsigned i = 0; i &lt; 5000; ++i)
2070         ptrs.append(fastMalloc(1024 * 2));
2071     for (void* ptr : ptrs)
2072         fastFree(ptr);
2073     return JSValue::encode(jsUndefined());
2074 }
2075 
2076 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)
2077 {
2078 #if ENABLE(JIT)
2079     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2080 #else
2081     return JSValue::encode(jsNumber(0));
2082 #endif
2083 }
2084 
2085 template&lt;typename ValueType&gt;
2086 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2087 
2088 template&lt;typename ValueType&gt;
2089 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2090 {
2091     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2092 }
2093 
2094 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
2095 {
2096     VM&amp; vm = exec-&gt;vm();
2097     JSObject* optionsObject = constructEmptyObject(exec);
2098 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
<a name="64" id="anc64"></a><span class="line-modified">2099     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());</span>
2100     JSC_OPTIONS(FOR_EACH_OPTION)
2101 #undef FOR_EACH_OPTION
2102     return JSValue::encode(optionsObject);
2103 }
2104 
2105 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)
2106 {
2107     if (exec-&gt;argumentCount() &lt; 1)
2108         return JSValue::encode(jsUndefined());
2109 
2110     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));
2111     if (!block)
2112         return JSValue::encode(jsNumber(0));
2113 
2114     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2115 }
2116 
2117 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)
2118 {
2119     VM&amp; vm = exec-&gt;vm();
2120     auto scope = DECLARE_THROW_SCOPE(vm);
2121 
2122     if (exec-&gt;argumentCount() &lt; 1)
2123         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Not enough arguments&quot;_s)));
2124 
2125     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));
2126     if (!buffer)
2127         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected an array buffer&quot;_s)));
2128 
2129     ArrayBufferContents dummyContents;
2130     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2131 
2132     return JSValue::encode(jsUndefined());
2133 }
2134 
2135 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)
2136 {
2137     VM&amp; vm = exec-&gt;vm();
2138     vm.setFailNextNewCodeBlock();
2139     return JSValue::encode(jsUndefined());
2140 }
2141 
2142 EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)
2143 {
2144     VM&amp; vm = exec-&gt;vm();
2145     vm.codeCache()-&gt;write(vm);
2146 
2147     jscExit(EXIT_SUCCESS);
2148 
2149 #if COMPILER(MSVC)
2150     // Without this, Visual Studio will complain that this method does not return a value.
2151     return JSValue::encode(jsUndefined());
2152 #endif
2153 }
2154 
2155 EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }
2156 
2157 EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }
2158 EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }
2159 EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)
2160 {
2161     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2162         if (!exec-&gt;argument(i).isInt32())
2163             return JSValue::encode(jsBoolean(false));
2164     }
2165     return JSValue::encode(jsBoolean(true));
2166 }
2167 
2168 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)
2169 {
2170     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2171         JSValue value = exec-&gt;argument(i);
2172         if (!value.isNumber())
2173             return JSValue::encode(jsBoolean(false));
2174         double number = value.asNumber();
2175         if (!std::isnan(number))
2176             return JSValue::encode(jsBoolean(false));
2177         if (isImpureNaN(number))
2178             return JSValue::encode(jsBoolean(false));
2179     }
2180     return JSValue::encode(jsBoolean(true));
2181 }
2182 
2183 EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec-&gt;argument(0)); }
2184 
2185 EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)
2186 {
2187     return JSValue::encode(jsNumber(42));
2188 }
2189 
2190 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)
2191 {
2192     VM&amp; vm = exec-&gt;vm();
2193     return JSValue::encode(Masquerader::create(vm, exec-&gt;lexicalGlobalObject()));
2194 }
2195 
2196 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)
2197 {
2198     JSValue value = exec-&gt;argument(0);
2199     if (value.isObject())
2200         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));
2201     return JSValue::encode(jsBoolean(false));
2202 }
2203 
2204 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)
2205 {
2206     VM&amp; vm = exec-&gt;vm();
2207     vm.dumpTypeProfilerData();
2208     return JSValue::encode(jsUndefined());
2209 }
2210 
2211 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)
2212 {
2213     VM&amp; vm = exec-&gt;vm();
2214     vm.drainMicrotasks();
2215     return JSValue::encode(jsUndefined());
2216 }
2217 
<a name="65" id="anc65"></a><span class="line-added">2218 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
<span class="line-added">2219 {</span>
<span class="line-added">2220     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2221     vm.finalizeSynchronousJSExecution();</span>
<span class="line-added">2222     return JSValue::encode(jsUndefined());</span>
<span class="line-added">2223 }</span>
<span class="line-added">2224 </span>
2225 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
2226 {
2227 #if USE(JSVALUE64)
2228     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2229 #else
2230     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2231 #endif
2232 }
2233 
2234 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
2235 {
2236     VM&amp; vm = exec-&gt;vm();
2237     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2238 }
2239 
2240 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)
2241 {
2242     VM&amp; vm = exec-&gt;vm();
2243     auto scope = DECLARE_THROW_SCOPE(vm);
2244 
2245     String source = exec-&gt;argument(0).toWTFString(exec);
2246     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2247 
2248     StopWatch stopWatch;
2249     stopWatch.start();
2250 
2251     ParserError error;
<a name="66" id="anc66"></a><span class="line-modified">2252     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2253     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2254     stopWatch.stop();
2255 
2256     if (!validSyntax)
<a name="67" id="anc67"></a><span class="line-modified">2257         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2258     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2259 }
2260 
2261 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
2262 {
2263 #if ENABLE(SAMPLING_PROFILER)
2264     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2265 #else
2266     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2267 #endif
2268 }
2269 
2270 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)
2271 {
2272     VM&amp; vm = exec-&gt;vm();
2273     JSLockHolder lock(vm);
2274     auto scope = DECLARE_THROW_SCOPE(vm);
2275 
2276     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2277     snapshotBuilder.buildSnapshot();
2278 
2279     String jsonString = snapshotBuilder.json();
2280     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2281     scope.releaseAssertNoException();
2282     return result;
2283 }
2284 
2285 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)
2286 {
2287     VM&amp; vm = exec-&gt;vm();
2288     JSLockHolder lock(vm);
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290     String jsonString;
2291     {
2292         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2293 
2294         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2295         snapshotBuilder.buildSnapshot();
2296 
2297         jsonString = snapshotBuilder.json();
2298     }
2299     scope.releaseAssertNoException();
<a name="68" id="anc68"></a><span class="line-modified">2300     return JSValue::encode(jsString(vm, jsonString));</span>
2301 }
2302 
2303 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
2304 {
2305     resetSuperSamplerState();
2306     return JSValue::encode(jsUndefined());
2307 }
2308 
2309 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)
2310 {
2311     VM&amp; vm = exec-&gt;vm();
2312     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {
2313         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))
2314             object-&gt;ensureArrayStorage(vm);
2315     }
2316     return JSValue::encode(jsUndefined());
2317 }
2318 
2319 #if ENABLE(SAMPLING_PROFILER)
2320 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)
2321 {
2322     VM&amp; vm = exec-&gt;vm();
2323     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2324     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2325     samplingProfiler.start();
2326     return JSValue::encode(jsUndefined());
2327 }
2328 
2329 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)
2330 {
2331     VM&amp; vm = exec-&gt;vm();
2332     auto scope = DECLARE_THROW_SCOPE(vm);
2333 
2334     if (!vm.samplingProfiler())
2335         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Sampling profiler was never started&quot;_s)));
2336 
2337     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
2338     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
2339     scope.releaseAssertNoException();
2340     return result;
2341 }
2342 #endif // ENABLE(SAMPLING_PROFILER)
2343 
2344 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)
2345 {
2346     return JSValue::encode(jsNumber(JSC::maxArguments));
2347 }
2348 
2349 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)
2350 {
2351     VM&amp; vm = exec-&gt;vm();
2352     auto scope = DECLARE_THROW_SCOPE(vm);
2353 
2354     JSValue numberOfAsyncPasses = exec-&gt;argument(0);
2355     if (!numberOfAsyncPasses.isUInt32())
<a name="69" id="anc69"></a><span class="line-modified">2356         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
2357 
2358     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2359     return encodedJSUndefined();
2360 }
2361 
2362 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)
2363 {
2364     asyncTestPasses++;
2365     return encodedJSUndefined();
2366 }
2367 
2368 #if ENABLE(WEBASSEMBLY)
2369 
2370 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
2371 {
2372     VM&amp; vm = exec-&gt;vm();
2373     auto scope = DECLARE_THROW_SCOPE(vm);
2374 
<a name="70" id="anc70"></a><span class="line-modified">2375     if (!Wasm::isSupported())</span>
2376         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);
2377 
2378     if (JSObject* object = exec-&gt;argument(0).getObject()) {
2379         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
<a name="71" id="anc71"></a><span class="line-modified">2380             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));</span>
2381         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
<a name="72" id="anc72"></a><span class="line-modified">2382             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));</span>
2383     }
2384 
2385     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);
2386 }
2387 
2388 #endif // ENABLE(WEBASSEMBLY)
2389 
<a name="73" id="anc73"></a><span class="line-added">2390 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
<span class="line-added">2391 {</span>
<span class="line-added">2392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">2393     JSObject* object = exec-&gt;argument(0).getObject();</span>
<span class="line-added">2394     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2395 </span>
<span class="line-added">2396     if (!object || !object-&gt;isFunction(vm))</span>
<span class="line-added">2397         return throwVMTypeError(exec, scope);</span>
<span class="line-added">2398 </span>
<span class="line-added">2399     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
<span class="line-added">2400     return JSValue::encode(jsUndefined());</span>
<span class="line-added">2401 }</span>
<span class="line-added">2402 </span>
2403 // Use SEH for Release builds only to get rid of the crash report dialog
2404 // (luckily the same tests fail in Release and Debug builds so far). Need to
2405 // be in a separate main function because the jscmain function requires object
2406 // unwinding.
2407 
2408 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2409 #define TRY       __try {
2410 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2411 #else
2412 #define TRY
2413 #define EXCEPT(x)
2414 #endif
2415 
2416 int jscmain(int argc, char** argv);
2417 
2418 static double s_desiredTimeout;
2419 static double s_timeoutMultiplier = 1.0;
2420 
2421 static void startTimeoutThreadIfNeeded()
2422 {
2423     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2424         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2425             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2426                 &quot; but expected a number. Not using a timeout.\n&quot;);
2427         } else {
2428             Thread::create(&quot;jsc Timeout Thread&quot;, [] () {
2429                 Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);
2430                 sleep(timeoutDuration);
2431                 dataLog(&quot;Timed out after &quot;, timeoutDuration, &quot; seconds!\n&quot;);
2432                 CRASH();
2433             });
2434         }
2435     }
2436 }
2437 
2438 int main(int argc, char** argv)
2439 {
2440 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)
2441     // Enabled IEEE754 denormal support.
2442     fenv_t env;
2443     fegetenv( &amp;env );
2444     env.__fpscr &amp;= ~0x01000000u;
2445     fesetenv( &amp;env );
2446 #endif
2447 
2448 #if OS(WINDOWS)
2449     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2450     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2451     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2452     ::SetErrorMode(0);
2453 
2454     _setmode(_fileno(stdout), _O_BINARY);
2455     _setmode(_fileno(stderr), _O_BINARY);
2456 
2457 #if defined(_DEBUG)
2458     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2459     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2460     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
2461     _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
2462     _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
2463     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
2464 #endif
2465 
2466     timeBeginPeriod(1);
2467 #endif
2468 
2469 #if PLATFORM(GTK)
2470     if (!setlocale(LC_ALL, &quot;&quot;))
2471         WTFLogAlways(&quot;Locale not supported by C library.\n\tUsing the fallback &#39;C&#39; locale.&quot;);
2472 #endif
2473 
2474     // Need to initialize WTF threading before we start any threads. Cannot initialize JSC
2475     // threading yet, since that would do somethings that we&#39;d like to defer until after we
2476     // have a chance to parse options.
2477     WTF::initializeThreading();
2478 
2479 #if PLATFORM(IOS_FAMILY)
2480     Options::crashIfCantAllocateJITMemory() = true;
2481 #endif
2482 
2483     // We can&#39;t use destructors in the following code because it uses Windows
2484     // Structured Exception Handling
2485     int res = 0;
2486     TRY
2487         res = jscmain(argc, argv);
2488     EXCEPT(res = 3)
2489     finalizeStatsAtEndOfTesting();
2490 
2491     jscExit(res);
2492 }
2493 
2494 static void dumpException(GlobalObject* globalObject, JSValue exception)
2495 {
2496     VM&amp; vm = globalObject-&gt;vm();
2497     auto scope = DECLARE_CATCH_SCOPE(vm);
2498 
2499 #define CHECK_EXCEPTION() do { \
2500         if (scope.exception()) { \
2501             scope.clearException(); \
2502             return; \
2503         } \
2504     } while (false)
2505 
2506     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());
2507     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2508     if (expectedCString)
2509         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2510     else
2511         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2512 
<a name="74" id="anc74"></a><span class="line-modified">2513     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);</span>
2514     CHECK_EXCEPTION();
<a name="75" id="anc75"></a><span class="line-modified">2515     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);</span>
2516     CHECK_EXCEPTION();
<a name="76" id="anc76"></a><span class="line-modified">2517     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);</span>
2518     CHECK_EXCEPTION();
<a name="77" id="anc77"></a><span class="line-modified">2519     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);</span>
2520     CHECK_EXCEPTION();
2521 
2522     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);
2523     CHECK_EXCEPTION();
2524     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);
2525     CHECK_EXCEPTION();
2526     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);
2527     CHECK_EXCEPTION();
2528     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);
2529     CHECK_EXCEPTION();
2530 
2531     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;
2532         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
2533         printf(
2534             &quot;at %s:%s\n&quot;,
2535             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),
2536             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2537     }
2538 
2539     if (!stackValue.isUndefinedOrNull()) {
2540         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());
2541         if (stackString.length())
2542             printf(&quot;%s\n&quot;, stackString.utf8().data());
2543     }
2544 
2545 #undef CHECK_EXCEPTION
2546 }
2547 
2548 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2549 {
2550     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2551     auto scope = DECLARE_CATCH_SCOPE(vm);
2552     scope.clearException();
2553     if (!exception) {
2554         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2555         return false;
2556     }
2557 
2558     ExecState* exec = globalObject-&gt;globalExec();
<a name="78" id="anc78"></a><span class="line-modified">2559     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
2560     if (!exceptionClass.isObject() || scope.exception()) {
2561         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2562         return false;
2563     }
2564 
2565     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);
2566     if (scope.exception()) {
2567         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2568         return false;
2569     }
2570     if (isInstanceOfExpectedException) {
2571         if (options.m_alwaysDumpUncaughtException)
2572             dumpException(globalObject, exception);
2573         return true;
2574     }
2575 
2576     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2577     dumpException(globalObject, exception);
2578     return false;
2579 }
2580 
2581 static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)
2582 {
2583     VM&amp; vm = globalObject-&gt;vm();
2584 
2585     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2586         ASSERT(hasException);
2587         return;
2588     }
2589 
2590     if (!options.m_uncaughtExceptionName || !isLastFile) {
2591         success = success &amp;&amp; !hasException;
2592         if (options.m_dump &amp;&amp; !hasException)
2593             printf(&quot;End: %s\n&quot;, value.toWTFString(exec).utf8().data());
2594         if (hasException)
2595             dumpException(globalObject, value);
2596     } else
2597         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2598 }
2599 
2600 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2601 {
2602     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2603     String fileName;
2604     Vector&lt;char&gt; scriptBuffer;
2605 
2606     if (options.m_dump)
2607         JSC::Options::dumpGeneratedBytecodes() = true;
2608 
2609     VM&amp; vm = globalObject-&gt;vm();
2610     auto scope = DECLARE_CATCH_SCOPE(vm);
2611 
2612 #if ENABLE(SAMPLING_FLAGS)
2613     SamplingFlags::start();
2614 #endif
2615 
2616     for (size_t i = 0; i &lt; scripts.size(); i++) {
2617         JSInternalPromise* promise = nullptr;
2618         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2619         if (scripts[i].codeSource == Script::CodeSource::File) {
2620             fileName = scripts[i].argument;
2621             if (scripts[i].strictMode == Script::StrictMode::Strict)
2622                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2623 
2624             if (isModule) {
2625                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), fileName, jsUndefined(), jsUndefined());
2626                 scope.releaseAssertNoException();
2627             } else {
2628                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2629                     success = false; // fail early so we can catch missing files
2630                     return;
2631                 }
2632             }
2633         } else {
2634             size_t commandLineLength = strlen(scripts[i].argument);
2635             scriptBuffer.resize(commandLineLength);
2636             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2637             fileName = &quot;[Command Line]&quot;_s;
2638         }
2639 
2640         bool isLastFile = i == scripts.size() - 1;
2641         if (isModule) {
2642             if (!promise) {
2643                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
2644                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());
2645             }
2646             scope.clearException();
2647 
2648             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {
2649                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, false, exec-&gt;argument(0), options, success);
2650                 return JSValue::encode(jsUndefined());
2651             });
2652 
2653             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {
2654                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, true, exec-&gt;argument(0), options, success);
2655                 return JSValue::encode(jsUndefined());
2656             });
2657 
2658             promise-&gt;then(globalObject-&gt;globalExec(), fulfillHandler, rejectHandler);
2659             scope.releaseAssertNoException();
2660             vm.drainMicrotasks();
2661         } else {
2662             NakedPtr&lt;Exception&gt; evaluationException;
2663             JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
2664             scope.assertNoException();
2665             if (evaluationException)
2666                 returnValue = evaluationException-&gt;value();
2667             checkException(globalObject-&gt;globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);
2668         }
2669 
2670         scriptBuffer.clear();
2671         scope.clearException();
2672     }
2673 
2674 #if ENABLE(REGEXP_TRACING)
2675     vm.dumpRegExpTrace();
2676 #endif
2677 }
2678 
2679 #define RUNNING_FROM_XCODE 0
2680 
2681 static void runInteractive(GlobalObject* globalObject)
2682 {
2683     VM&amp; vm = globalObject-&gt;vm();
2684     auto scope = DECLARE_CATCH_SCOPE(vm);
2685 
2686     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2687     if (!directoryName)
2688         return;
2689     SourceOrigin sourceOrigin(resolvePath(directoryName.value(), ModuleName(&quot;interpreter&quot;)));
2690 
2691     bool shouldQuit = false;
2692     while (!shouldQuit) {
2693 #if HAVE(READLINE) &amp;&amp; !RUNNING_FROM_XCODE
2694         ParserError error;
2695         String source;
2696         do {
2697             error = ParserError();
2698             char* line = readline(source.isEmpty() ? interactivePrompt : &quot;... &quot;);
2699             shouldQuit = !line;
2700             if (!line)
2701                 break;
2702             source = source + String::fromUTF8(line);
2703             source = source + &#39;\n&#39;;
<a name="79" id="anc79"></a><span class="line-modified">2704             checkSyntax(vm, jscSource(source, sourceOrigin), error);</span>
2705             if (!line[0]) {
2706                 free(line);
2707                 break;
2708             }
2709             add_history(line);
2710             free(line);
2711         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2712 
2713         if (error.isValid()) {
2714             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2715             continue;
2716         }
2717 
2718 
2719         NakedPtr&lt;Exception&gt; evaluationException;
<a name="80" id="anc80"></a><span class="line-modified">2720         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2721 #else
2722         printf(&quot;%s&quot;, interactivePrompt);
2723         Vector&lt;char, 256&gt; line;
2724         int c;
2725         while ((c = getchar()) != EOF) {
2726             // FIXME: Should we also break on \r?
2727             if (c == &#39;\n&#39;)
2728                 break;
2729             line.append(c);
2730         }
2731         if (line.isEmpty())
2732             break;
2733 
2734         NakedPtr&lt;Exception&gt; evaluationException;
2735         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
2736 #endif
2737         if (evaluationException)
2738             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());
2739         else
2740             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());
2741 
2742         scope.clearException();
2743         vm.drainMicrotasks();
2744     }
2745     printf(&quot;\n&quot;);
2746 }
2747 
2748 static NO_RETURN void printUsageStatement(bool help = false)
2749 {
2750     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2751     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2752     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2753     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2754     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2755     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2756     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2757 #if HAVE(SIGNAL_H)
2758     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2759 #endif
2760     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
2761     fprintf(stderr, &quot;  -x         Output exit code before terminating\n&quot;);
2762     fprintf(stderr, &quot;\n&quot;);
2763     fprintf(stderr, &quot;  --sample                   Collects and outputs sampling profiler data\n&quot;);
2764     fprintf(stderr, &quot;  --test262-async            Check that some script calls the print function with the string &#39;Test262:AsyncTestComplete&#39;\n&quot;);
2765     fprintf(stderr, &quot;  --strict-file=&lt;file&gt;       Parse the given file as if it were in strict mode (this option may be passed more than once)\n&quot;);
2766     fprintf(stderr, &quot;  --module-file=&lt;file&gt;       Parse and evaluate the given file as module (this option may be passed more than once)\n&quot;);
2767     fprintf(stderr, &quot;  --exception=&lt;name&gt;         Check the last script exits with an uncaught exception with the specified name\n&quot;);
2768     fprintf(stderr, &quot;  --watchdog-exception-ok    Uncaught watchdog exceptions exit with success\n&quot;);
2769     fprintf(stderr, &quot;  --dumpException            Dump uncaught exception text\n&quot;);
2770     fprintf(stderr, &quot;  --footprint                Dump memory footprint after done executing\n&quot;);
2771     fprintf(stderr, &quot;  --options                  Dumps all JSC VM options and exits\n&quot;);
2772     fprintf(stderr, &quot;  --dumpOptions              Dumps all non-default JSC VM options before continuing\n&quot;);
2773     fprintf(stderr, &quot;  --&lt;jsc VM option&gt;=&lt;value&gt;  Sets the specified JSC VM option\n&quot;);
<a name="81" id="anc81"></a><span class="line-added">2774     fprintf(stderr, &quot;  --destroy-vm               Destroy VM before exiting\n&quot;);</span>
2775     fprintf(stderr, &quot;\n&quot;);
2776     fprintf(stderr, &quot;Files with a .mjs extension will always be evaluated as modules.\n&quot;);
2777     fprintf(stderr, &quot;\n&quot;);
2778 
2779     jscExit(help ? EXIT_SUCCESS : EXIT_FAILURE);
2780 }
2781 
2782 static bool isMJSFile(char *filename)
2783 {
2784     filename = strrchr(filename, &#39;.&#39;);
2785 
2786     if (filename)
2787         return !strcmp(filename, &quot;.mjs&quot;);
2788 
2789     return false;
2790 }
2791 
2792 void CommandLine::parseArguments(int argc, char** argv)
2793 {
2794     Options::initialize();
2795 
2796     if (Options::dumpOptions()) {
2797         printf(&quot;Command line:&quot;);
2798 #if PLATFORM(COCOA)
2799         for (char** envp = *_NSGetEnviron(); *envp; envp++) {
2800             const char* env = *envp;
2801             if (!strncmp(&quot;JSC_&quot;, env, 4))
2802                 printf(&quot; %s&quot;, env);
2803         }
2804 #endif // PLATFORM(COCOA)
2805         for (int i = 0; i &lt; argc; ++i)
2806             printf(&quot; %s&quot;, argv[i]);
2807         printf(&quot;\n&quot;);
2808     }
2809 
2810     int i = 1;
2811     JSC::Options::DumpLevel dumpOptionsLevel = JSC::Options::DumpLevel::None;
2812     bool needToExit = false;
2813 
2814     bool hasBadJSCOptions = false;
2815     for (; i &lt; argc; ++i) {
2816         const char* arg = argv[i];
2817         if (!strcmp(arg, &quot;-f&quot;)) {
2818             if (++i == argc)
2819                 printUsageStatement();
2820             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Script, argv[i]));
2821             continue;
2822         }
2823         if (!strcmp(arg, &quot;-e&quot;)) {
2824             if (++i == argc)
2825                 printUsageStatement();
2826             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::CommandLine, Script::ScriptType::Script, argv[i]));
2827             continue;
2828         }
2829         if (!strcmp(arg, &quot;-i&quot;)) {
2830             m_interactive = true;
2831             continue;
2832         }
2833         if (!strcmp(arg, &quot;-d&quot;)) {
2834             m_dump = true;
2835             continue;
2836         }
2837         if (!strcmp(arg, &quot;-p&quot;)) {
2838             if (++i == argc)
2839                 printUsageStatement();
2840             m_profile = true;
2841             m_profilerOutput = argv[i];
2842             continue;
2843         }
2844         if (!strcmp(arg, &quot;-m&quot;)) {
2845             m_module = true;
2846             continue;
2847         }
2848         if (!strcmp(arg, &quot;-s&quot;)) {
2849 #if HAVE(SIGNAL_H)
2850             signal(SIGILL, _exit);
2851             signal(SIGFPE, _exit);
2852             signal(SIGBUS, _exit);
2853             signal(SIGSEGV, _exit);
2854 #endif
2855             continue;
2856         }
2857         if (!strcmp(arg, &quot;-x&quot;)) {
2858             m_exitCode = true;
2859             continue;
2860         }
2861         if (!strcmp(arg, &quot;--&quot;)) {
2862             ++i;
2863             break;
2864         }
2865         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
2866             printUsageStatement(true);
2867 
2868         if (!strcmp(arg, &quot;--options&quot;)) {
2869             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2870             needToExit = true;
2871             continue;
2872         }
2873         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2874             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2875             continue;
2876         }
2877         if (!strcmp(arg, &quot;--sample&quot;)) {
2878             JSC::Options::useSamplingProfiler() = true;
2879             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2880             m_dumpSamplingProfilerData = true;
2881             continue;
2882         }
<a name="82" id="anc82"></a><span class="line-added">2883         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {</span>
<span class="line-added">2884             m_destroyVM = true;</span>
<span class="line-added">2885             continue;</span>
<span class="line-added">2886         }</span>
2887 
2888         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2889         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2890         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2891             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2892             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2893                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2894             continue;
2895         }
2896 
2897         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2898             asyncTestExpectedPasses++;
2899             continue;
2900         }
2901 
2902         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2903             m_enableRemoteDebugging = true;
2904             continue;
2905         }
2906 
2907         static const unsigned strictFileStrLength = strlen(&quot;--strict-file=&quot;);
2908         if (!strncmp(arg, &quot;--strict-file=&quot;, strictFileStrLength)) {
2909             m_scripts.append(Script(Script::StrictMode::Strict, Script::CodeSource::File, Script::ScriptType::Script, argv[i] + strictFileStrLength));
2910             continue;
2911         }
2912 
2913         static const unsigned moduleFileStrLength = strlen(&quot;--module-file=&quot;);
2914         if (!strncmp(arg, &quot;--module-file=&quot;, moduleFileStrLength)) {
2915             m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, Script::ScriptType::Module, argv[i] + moduleFileStrLength));
2916             continue;
2917         }
2918 
2919         if (!strcmp(arg, &quot;--dumpException&quot;)) {
2920             m_alwaysDumpUncaughtException = true;
2921             continue;
2922         }
2923 
2924         if (!strcmp(arg, &quot;--footprint&quot;)) {
2925             m_dumpMemoryFootprint = true;
2926             continue;
2927         }
2928 
2929         static const unsigned exceptionStrLength = strlen(&quot;--exception=&quot;);
2930         if (!strncmp(arg, &quot;--exception=&quot;, exceptionStrLength)) {
2931             m_uncaughtExceptionName = String(arg + exceptionStrLength);
2932             continue;
2933         }
2934 
2935         if (!strcmp(arg, &quot;--watchdog-exception-ok&quot;)) {
2936             m_treatWatchdogExceptionAsSuccess = true;
2937             continue;
2938         }
2939 
2940         // See if the -- option is a JSC VM option.
2941         if (strstr(arg, &quot;--&quot;) == arg) {
2942             if (!JSC::Options::setOption(&amp;arg[2])) {
2943                 hasBadJSCOptions = true;
2944                 dataLog(&quot;ERROR: invalid option: &quot;, arg, &quot;\n&quot;);
2945             }
2946             continue;
2947         }
2948 
2949         // This arg is not recognized by the VM nor by jsc. Pass it on to the
2950         // script.
2951         Script::ScriptType scriptType = isMJSFile(argv[i]) ? Script::ScriptType::Module : Script::ScriptType::Script;
2952         m_scripts.append(Script(Script::StrictMode::Sloppy, Script::CodeSource::File, scriptType, argv[i]));
2953     }
2954 
2955     if (hasBadJSCOptions &amp;&amp; JSC::Options::validateOptions())
2956         CRASH();
2957 
2958     if (m_scripts.isEmpty())
2959         m_interactive = true;
2960 
2961     for (; i &lt; argc; ++i)
2962         m_arguments.append(argv[i]);
2963 
2964     if (dumpOptionsLevel != JSC::Options::DumpLevel::None) {
2965         const char* optionsTitle = (dumpOptionsLevel == JSC::Options::DumpLevel::Overridden)
2966             ? &quot;Modified JSC runtime options:&quot;
2967             : &quot;All JSC runtime options:&quot;;
2968         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2969     }
2970     JSC::Options::ensureOptionsAreCoherent();
2971     if (needToExit)
2972         jscExit(EXIT_SUCCESS);
2973 }
2974 
2975 template&lt;typename Func&gt;
2976 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2977 {
2978     Worker worker(Workers::singleton());
2979 
2980     VM&amp; vm = VM::create(LargeHeap).leakRef();
2981     int result;
2982     bool success = true;
2983     GlobalObject* globalObject = nullptr;
2984     {
2985         JSLockHolder locker(vm);
2986 
2987         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
<a name="83" id="anc83"></a><span class="line-modified">2988             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);</span>
2989 
2990         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2991         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2992         func(vm, globalObject, success);
2993         vm.drainMicrotasks();
2994     }
2995     vm.promiseDeferredTimer-&gt;runRunLoop();
2996     {
2997         JSLockHolder locker(vm);
2998         if (options.m_interactive &amp;&amp; success)
2999             runInteractive(globalObject);
3000     }
3001 
3002     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3003 
3004     if (options.m_exitCode) {
3005         printf(&quot;jsc exiting %d&quot;, result);
3006         if (asyncTestExpectedPasses != asyncTestPasses)
3007             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3008         printf(&quot;\n&quot;);
3009     }
3010 
3011     if (options.m_profile) {
3012         JSLockHolder locker(vm);
3013         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
3014             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
3015     }
3016 
3017 #if ENABLE(JIT)
3018     {
3019         JSLockHolder locker(vm);
3020         if (Options::useExceptionFuzz())
3021             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
3022         bool fireAtEnabled =
3023         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
3024         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
3025             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
3026         if (Options::useOSRExitFuzz()) {
3027             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
3028             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
3029         }
3030 
3031 
3032         auto compileTimeStats = JIT::compileTimeStats();
3033         Vector&lt;CString&gt; compileTimeKeys;
3034         for (auto&amp; entry : compileTimeStats)
3035             compileTimeKeys.append(entry.key);
3036         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
3037         for (const CString&amp; key : compileTimeKeys)
3038             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
3039     }
3040 #endif
3041 
3042     if (Options::gcAtEnd()) {
3043         // We need to hold the API lock to do a GC.
3044         JSLockHolder locker(&amp;vm);
3045         vm.heap.collectNow(Sync, CollectionScope::Full);
3046     }
3047 
3048     if (options.m_dumpSamplingProfilerData) {
3049 #if ENABLE(SAMPLING_PROFILER)
3050         JSLockHolder locker(&amp;vm);
3051         vm.samplingProfiler()-&gt;reportTopFunctions();
3052         vm.samplingProfiler()-&gt;reportTopBytecodes();
3053 #else
3054         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3055 #endif
3056     }
3057 
3058     vm.codeCache()-&gt;write(vm);
3059 
<a name="84" id="anc84"></a><span class="line-modified">3060     if (options.m_destroyVM || isWorker) {</span>
3061         JSLockHolder locker(vm);
3062         // This is needed because we don&#39;t want the worker&#39;s main
3063         // thread to die before its compilation threads finish.
3064         vm.deref();
3065     }
3066 
3067     return result;
3068 }
3069 
3070 int jscmain(int argc, char** argv)
3071 {
3072     // Need to override and enable restricted options before we start parsing options below.
3073     Options::enableRestrictedOptions(true);
3074 
<a name="85" id="anc85"></a><span class="line-added">3075     WTF::initializeMainThread();</span>
<span class="line-added">3076 </span>
3077     // Note that the options parsing can affect VM creation, and thus
3078     // comes first.
3079     CommandLine options(argc, argv);
3080 
3081     processConfigFile(Options::configFile(), &quot;jsc&quot;);
3082 
3083     // Initialize JSC before getting VM.
<a name="86" id="anc86"></a>
3084     JSC::initializeThreading();
3085     startTimeoutThreadIfNeeded();
3086 #if ENABLE(WEBASSEMBLY)
3087     JSC::Wasm::enableFastMemory();
3088 #endif
3089     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();
3090 
3091 #if PLATFORM(COCOA)
3092     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3093     {
3094         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3095         memoryPressureHandler.setDispatchQueue(queue);
3096         dispatch_release(queue);
3097     }
3098     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3099     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3100     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3101         // We set these racily with respect to reading them from the JS execution thread.
3102         *memoryPressureCriticalState = critical;
3103         *memoryPressureSynchronousState = synchronous;
3104     });
3105     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3106     memoryPressureHandler.install();
3107 
3108     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3109         if (*memoryPressureCriticalState == Critical::No)
3110             return;
3111 
3112         *memoryPressureCriticalState = Critical::No;
3113         bool isSynchronous = *memoryPressureSynchronousState == Synchronous::Yes;
3114 
3115         WTF::releaseFastMallocFreeMemory();
3116         vm.deleteAllCode(DeleteAllCodeIfNotCollecting);
3117 
3118         if (!vm.heap.isCurrentThreadBusy()) {
3119             if (isSynchronous) {
3120                 vm.heap.collectNow(Sync, CollectionScope::Full);
3121                 WTF::releaseFastMallocFreeMemory();
3122             } else
3123                 vm.heap.collectNowFullIfNotDoneRecently(Async);
3124         }
3125     };
3126 #endif
3127 
3128     int result = runJSC(
3129         options, false,
3130         [&amp;] (VM&amp; vm, GlobalObject* globalObject, bool&amp; success) {
3131             UNUSED_PARAM(vm);
3132 #if PLATFORM(COCOA)
3133             vm.setOnEachMicrotaskTick(WTFMove(onEachMicrotaskTick));
3134 #endif
3135             runWithOptions(globalObject, options, success);
3136         });
3137 
3138     printSuperSamplerState();
3139 
3140     if (options.m_dumpMemoryFootprint) {
3141         MemoryFootprint footprint = MemoryFootprint::now();
3142 
3143         printf(&quot;Memory Footprint:\n    Current Footprint: %&quot; PRIu64 &quot;\n    Peak Footprint: %&quot; PRIu64 &quot;\n&quot;, footprint.current, footprint.peak);
3144     }
3145 
3146     return result;
3147 }
3148 
3149 #if OS(WINDOWS)
3150 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
3151 {
3152     return main(argc, const_cast&lt;char**&gt;(argv));
3153 }
3154 #endif
<a name="87" id="anc87"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="87" type="hidden" />
</body>
</html>