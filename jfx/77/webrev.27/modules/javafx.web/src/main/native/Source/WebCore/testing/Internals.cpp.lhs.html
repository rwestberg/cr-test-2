<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/testing/Internals.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Internals.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;ActiveDOMCallbackMicrotask.h&quot;
  32 #include &quot;ActivityState.h&quot;
  33 #include &quot;AnimationTimeline.h&quot;
  34 #include &quot;ApplicationCacheStorage.h&quot;
  35 #include &quot;AudioSession.h&quot;
  36 #include &quot;Autofill.h&quot;
  37 #include &quot;BackForwardController.h&quot;
  38 #include &quot;BitmapImage.h&quot;
  39 #include &quot;CSSAnimationController.h&quot;
  40 #include &quot;CSSKeyframesRule.h&quot;
  41 #include &quot;CSSMediaRule.h&quot;
  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSSupportsRule.h&quot;
  44 #include &quot;CacheStorageConnection.h&quot;
  45 #include &quot;CacheStorageProvider.h&quot;
  46 #include &quot;CachedImage.h&quot;
  47 #include &quot;CachedResourceLoader.h&quot;
  48 #include &quot;CertificateInfo.h&quot;
  49 #include &quot;Chrome.h&quot;
<a name="1" id="anc1"></a>
  50 #include &quot;ClientOrigin.h&quot;
  51 #include &quot;ComposedTreeIterator.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;Cursor.h&quot;
<a name="2" id="anc2"></a>
  54 #include &quot;DOMRect.h&quot;
  55 #include &quot;DOMRectList.h&quot;
  56 #include &quot;DOMStringList.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DeprecatedGlobalSettings.h&quot;
<a name="3" id="anc3"></a>
  59 #include &quot;DisabledAdaptations.h&quot;
  60 #include &quot;DisplayList.h&quot;
  61 #include &quot;Document.h&quot;
  62 #include &quot;DocumentLoader.h&quot;
  63 #include &quot;DocumentMarkerController.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;Editor.h&quot;
  66 #include &quot;Element.h&quot;
  67 #include &quot;EventHandler.h&quot;
<a name="4" id="anc4"></a>

  68 #include &quot;ExtendableEvent.h&quot;
  69 #include &quot;ExtensionStyleSheets.h&quot;
  70 #include &quot;FetchResponse.h&quot;
  71 #include &quot;File.h&quot;
  72 #include &quot;FontCache.h&quot;
  73 #include &quot;FormController.h&quot;
  74 #include &quot;Frame.h&quot;
  75 #include &quot;FrameLoader.h&quot;
  76 #include &quot;FrameView.h&quot;
<a name="5" id="anc5"></a>
  77 #include &quot;GCObservation.h&quot;
  78 #include &quot;GridPosition.h&quot;
  79 #include &quot;HEVCUtilities.h&quot;
  80 #include &quot;HTMLAnchorElement.h&quot;
  81 #include &quot;HTMLCanvasElement.h&quot;
  82 #include &quot;HTMLIFrameElement.h&quot;
  83 #include &quot;HTMLImageElement.h&quot;
  84 #include &quot;HTMLInputElement.h&quot;
  85 #include &quot;HTMLLinkElement.h&quot;
  86 #include &quot;HTMLNames.h&quot;
  87 #include &quot;HTMLPictureElement.h&quot;
  88 #include &quot;HTMLPlugInElement.h&quot;
  89 #include &quot;HTMLPreloadScanner.h&quot;
  90 #include &quot;HTMLSelectElement.h&quot;
  91 #include &quot;HTMLTextAreaElement.h&quot;
  92 #include &quot;HTMLVideoElement.h&quot;
  93 #include &quot;HistoryController.h&quot;
  94 #include &quot;HistoryItem.h&quot;
  95 #include &quot;HitTestResult.h&quot;
<a name="6" id="anc6"></a><span class="line-removed">  96 #include &quot;IDBRequest.h&quot;</span>
<span class="line-removed">  97 #include &quot;IDBTransaction.h&quot;</span>
  98 #include &quot;InspectorClient.h&quot;
  99 #include &quot;InspectorController.h&quot;
 100 #include &quot;InspectorFrontendClientLocal.h&quot;
 101 #include &quot;InspectorOverlay.h&quot;
 102 #include &quot;InstrumentingAgents.h&quot;
 103 #include &quot;IntRect.h&quot;
 104 #include &quot;InternalSettings.h&quot;
 105 #include &quot;JSImageData.h&quot;
 106 #include &quot;LibWebRTCProvider.h&quot;
 107 #include &quot;LoaderStrategy.h&quot;
 108 #include &quot;MallocStatistics.h&quot;
<a name="7" id="anc7"></a>
 109 #include &quot;MediaEngineConfigurationFactory.h&quot;
 110 #include &quot;MediaPlayer.h&quot;
 111 #include &quot;MediaProducer.h&quot;
 112 #include &quot;MediaResourceLoader.h&quot;
 113 #include &quot;MediaStreamTrack.h&quot;
 114 #include &quot;MemoryCache.h&quot;
 115 #include &quot;MemoryInfo.h&quot;
 116 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 117 #include &quot;MockPageOverlay.h&quot;
 118 #include &quot;MockPageOverlayClient.h&quot;
<a name="8" id="anc8"></a>
 119 #include &quot;NetworkLoadInformation.h&quot;
 120 #include &quot;Page.h&quot;
 121 #include &quot;PageCache.h&quot;
 122 #include &quot;PageOverlay.h&quot;
 123 #include &quot;PathUtilities.h&quot;
 124 #include &quot;PlatformKeyboardEvent.h&quot;
 125 #include &quot;PlatformMediaSessionManager.h&quot;
 126 #include &quot;PlatformScreen.h&quot;
 127 #include &quot;PlatformStrategies.h&quot;
 128 #include &quot;PluginData.h&quot;
 129 #include &quot;PrintContext.h&quot;
 130 #include &quot;PseudoElement.h&quot;
 131 #include &quot;Range.h&quot;
 132 #include &quot;ReadableStream.h&quot;
 133 #include &quot;RenderEmbeddedObject.h&quot;
 134 #include &quot;RenderLayerBacking.h&quot;
 135 #include &quot;RenderLayerCompositor.h&quot;
 136 #include &quot;RenderMenuList.h&quot;
 137 #include &quot;RenderTreeAsText.h&quot;
 138 #include &quot;RenderView.h&quot;
 139 #include &quot;RenderedDocumentMarker.h&quot;
 140 #include &quot;ResourceLoadObserver.h&quot;
 141 #include &quot;RuntimeEnabledFeatures.h&quot;
 142 #include &quot;SMILTimeContainer.h&quot;
 143 #include &quot;SVGDocumentExtensions.h&quot;
 144 #include &quot;SVGPathStringBuilder.h&quot;
 145 #include &quot;SVGSVGElement.h&quot;
 146 #include &quot;SWClientConnection.h&quot;
 147 #include &quot;SchemeRegistry.h&quot;
 148 #include &quot;ScriptedAnimationController.h&quot;
 149 #include &quot;ScrollingCoordinator.h&quot;
 150 #include &quot;ScrollingMomentumCalculator.h&quot;
 151 #include &quot;SecurityOrigin.h&quot;
 152 #include &quot;SerializedScriptValue.h&quot;
 153 #include &quot;ServiceWorker.h&quot;
 154 #include &quot;ServiceWorkerProvider.h&quot;
 155 #include &quot;ServiceWorkerRegistrationData.h&quot;
 156 #include &quot;Settings.h&quot;
 157 #include &quot;ShadowRoot.h&quot;
 158 #include &quot;SourceBuffer.h&quot;
 159 #include &quot;SpellChecker.h&quot;
 160 #include &quot;StaticNodeList.h&quot;
 161 #include &quot;StringCallback.h&quot;
 162 #include &quot;StyleRule.h&quot;
 163 #include &quot;StyleScope.h&quot;
 164 #include &quot;StyleSheetContents.h&quot;
 165 #include &quot;TextIterator.h&quot;
 166 #include &quot;TreeScope.h&quot;
 167 #include &quot;TypeConversions.h&quot;
 168 #include &quot;UserGestureIndicator.h&quot;
 169 #include &quot;UserMediaController.h&quot;
 170 #include &quot;ViewportArguments.h&quot;
 171 #include &quot;VoidCallback.h&quot;
 172 #include &quot;WebCoreJSClientData.h&quot;
 173 #include &quot;WindowProxy.h&quot;
 174 #include &quot;WorkerThread.h&quot;
 175 #include &quot;WorkletGlobalScope.h&quot;
 176 #include &quot;WritingDirection.h&quot;
 177 #include &quot;XMLHttpRequest.h&quot;
 178 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 179 #include &lt;JavaScriptCore/InspectorAgentBase.h&gt;
 180 #include &lt;JavaScriptCore/InspectorFrontendChannel.h&gt;
 181 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 182 #include &lt;JavaScriptCore/JSCJSValue.h&gt;
 183 #include &lt;wtf/HexNumber.h&gt;
 184 #include &lt;wtf/JSONValues.h&gt;
 185 #include &lt;wtf/Language.h&gt;
 186 #include &lt;wtf/MemoryPressureHandler.h&gt;
 187 #include &lt;wtf/MonotonicTime.h&gt;
 188 #include &lt;wtf/URLHelpers.h&gt;
 189 #include &lt;wtf/text/StringBuilder.h&gt;
 190 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 191 
 192 #if USE(CG)
 193 #include &quot;PDFDocumentImage.h&quot;
 194 #endif
 195 
 196 #if ENABLE(INPUT_TYPE_COLOR)
 197 #include &quot;ColorChooser.h&quot;
 198 #endif
 199 
 200 #if ENABLE(MOUSE_CURSOR_SCALE)
 201 #include &lt;wtf/dtoa.h&gt;
 202 #endif
 203 
 204 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 205 #include &quot;LegacyCDM.h&quot;
 206 #include &quot;LegacyMockCDM.h&quot;
 207 #endif
 208 
 209 #if ENABLE(ENCRYPTED_MEDIA)
 210 #include &quot;MockCDMFactory.h&quot;
 211 #endif
 212 
 213 #if ENABLE(VIDEO_TRACK)
 214 #include &quot;CaptionUserPreferences.h&quot;
 215 #include &quot;PageGroup.h&quot;
<a name="9" id="anc9"></a>
 216 #endif
 217 
 218 #if ENABLE(VIDEO)
 219 #include &quot;HTMLMediaElement.h&quot;
 220 #include &quot;TimeRanges.h&quot;
 221 #endif
 222 
 223 #if ENABLE(WEBGL)
 224 #include &quot;WebGLRenderingContext.h&quot;
 225 #endif
 226 
 227 #if ENABLE(SPEECH_SYNTHESIS)
 228 #include &quot;DOMWindowSpeechSynthesis.h&quot;
 229 #include &quot;PlatformSpeechSynthesizerMock.h&quot;
 230 #include &quot;SpeechSynthesis.h&quot;
 231 #endif
 232 
 233 #if ENABLE(MEDIA_STREAM)
 234 #include &quot;MediaRecorder.h&quot;
 235 #include &quot;MediaRecorderPrivateMock.h&quot;
 236 #include &quot;MediaStream.h&quot;
 237 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 238 #endif
 239 
 240 #if ENABLE(WEB_RTC)
 241 #include &quot;RTCPeerConnection.h&quot;
 242 #endif
 243 
 244 #if ENABLE(MEDIA_SOURCE)
 245 #include &quot;MockMediaPlayerMediaSource.h&quot;
 246 #endif
 247 
 248 #if ENABLE(CONTENT_FILTERING)
 249 #include &quot;MockContentFilterSettings.h&quot;
 250 #endif
 251 
 252 #if ENABLE(WEB_AUDIO)
 253 #include &quot;AudioContext.h&quot;
 254 #endif
 255 
 256 #if ENABLE(MEDIA_SESSION)
 257 #include &quot;MediaSession.h&quot;
 258 #include &quot;MediaSessionManager.h&quot;
 259 #endif
 260 
 261 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 262 #include &quot;MediaPlaybackTargetContext.h&quot;
 263 #endif
 264 
 265 #if ENABLE(POINTER_LOCK)
 266 #include &quot;PointerLockController.h&quot;
 267 #endif
 268 
<a name="10" id="anc10"></a>




 269 #if USE(QUICK_LOOK)
 270 #include &quot;MockPreviewLoaderClient.h&quot;
 271 #include &quot;PreviewLoader.h&quot;
 272 #endif
 273 
 274 #if ENABLE(APPLE_PAY)
 275 #include &quot;MockPaymentCoordinator.h&quot;
 276 #include &quot;PaymentCoordinator.h&quot;
 277 #endif
 278 
 279 #if PLATFORM(MAC) &amp;&amp; USE(LIBWEBRTC)
 280 #include &lt;webrtc/sdk/WebKit/VideoProcessingSoftLink.h&gt;
 281 #endif
 282 
 283 #if PLATFORM(MAC)
 284 #include &quot;GraphicsContext3DManager.h&quot;
 285 #endif
 286 
 287 using JSC::CallData;
 288 using JSC::CallType;
 289 using JSC::CodeBlock;
 290 using JSC::FunctionExecutable;
 291 using JSC::Identifier;
 292 using JSC::JSFunction;
 293 using JSC::JSGlobalObject;
 294 using JSC::JSObject;
 295 using JSC::JSValue;
 296 using JSC::MarkedArgumentBuffer;
 297 using JSC::PropertySlot;
 298 using JSC::ScriptExecutable;
 299 using JSC::StackVisitor;
 300 
 301 
 302 namespace WebCore {
 303 using namespace Inspector;
 304 
 305 using namespace HTMLNames;
 306 
 307 class InspectorStubFrontend final : public InspectorFrontendClientLocal, public FrontendChannel {
 308 public:
 309     InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow);
 310     virtual ~InspectorStubFrontend();
 311 
 312 private:
 313     void attachWindow(DockSide) final { }
 314     void detachWindow() final { }
 315     void closeWindow() final;
 316     void reopen() final { }
 317     void bringToFront() final { }
 318     String localizedStringsURL() final { return String(); }
 319     void inspectedURLChanged(const String&amp;) final { }
 320     void showCertificate(const CertificateInfo&amp;) final { }
 321     void setAttachedWindowHeight(unsigned) final { }
 322     void setAttachedWindowWidth(unsigned) final { }
<a name="11" id="anc11"></a>
 323 
 324     void sendMessageToFrontend(const String&amp; message) final;
 325     ConnectionType connectionType() const final { return ConnectionType::Local; }
 326 
<a name="12" id="anc12"></a><span class="line-removed"> 327     Page* frontendPage() const</span>
<span class="line-removed"> 328     {</span>
<span class="line-removed"> 329         if (!m_frontendWindow || !m_frontendWindow-&gt;document())</span>
<span class="line-removed"> 330             return nullptr;</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332         return m_frontendWindow-&gt;document()-&gt;page();</span>
<span class="line-removed"> 333     }</span>
<span class="line-removed"> 334 </span>
 335     RefPtr&lt;DOMWindow&gt; m_frontendWindow;
<a name="13" id="anc13"></a><span class="line-removed"> 336     InspectorController&amp; m_frontendController;</span>
 337 };
 338 
 339 InspectorStubFrontend::InspectorStubFrontend(Page&amp; inspectedPage, RefPtr&lt;DOMWindow&gt;&amp;&amp; frontendWindow)
<a name="14" id="anc14"></a><span class="line-modified"> 340     : InspectorFrontendClientLocal(&amp;inspectedPage.inspectorController(), frontendWindow-&gt;document()-&gt;page(), std::make_unique&lt;InspectorFrontendClientLocal::Settings&gt;())</span>
 341     , m_frontendWindow(frontendWindow.copyRef())
<a name="15" id="anc15"></a><span class="line-removed"> 342     , m_frontendController(frontendPage()-&gt;inspectorController())</span>
 343 {
 344     ASSERT_ARG(frontendWindow, frontendWindow);
 345 
<a name="16" id="anc16"></a><span class="line-modified"> 346     m_frontendController.setInspectorFrontendClient(this);</span>
 347     inspectedPage.inspectorController().connectFrontend(*this);
 348 }
 349 
 350 InspectorStubFrontend::~InspectorStubFrontend()
 351 {
 352     closeWindow();
 353 }
 354 
 355 void InspectorStubFrontend::closeWindow()
 356 {
 357     if (!m_frontendWindow)
 358         return;
 359 
<a name="17" id="anc17"></a><span class="line-modified"> 360     m_frontendController.setInspectorFrontendClient(nullptr);</span>
 361     inspectedPage()-&gt;inspectorController().disconnectFrontend(*this);
 362 
 363     m_frontendWindow-&gt;close();
 364     m_frontendWindow = nullptr;
 365 }
 366 
 367 void InspectorStubFrontend::sendMessageToFrontend(const String&amp; message)
 368 {
<a name="18" id="anc18"></a><span class="line-modified"> 369     ASSERT_ARG(message, !message.isEmpty());</span>
<span class="line-removed"> 370 </span>
<span class="line-removed"> 371     InspectorClient::doDispatchMessageOnFrontendPage(frontendPage(), message);</span>
 372 }
 373 
 374 static bool markerTypeFrom(const String&amp; markerType, DocumentMarker::MarkerType&amp; result)
 375 {
 376     if (equalLettersIgnoringASCIICase(markerType, &quot;spelling&quot;))
 377         result = DocumentMarker::Spelling;
 378     else if (equalLettersIgnoringASCIICase(markerType, &quot;grammar&quot;))
 379         result = DocumentMarker::Grammar;
 380     else if (equalLettersIgnoringASCIICase(markerType, &quot;textmatch&quot;))
 381         result = DocumentMarker::TextMatch;
 382     else if (equalLettersIgnoringASCIICase(markerType, &quot;replacement&quot;))
 383         result = DocumentMarker::Replacement;
 384     else if (equalLettersIgnoringASCIICase(markerType, &quot;correctionindicator&quot;))
 385         result = DocumentMarker::CorrectionIndicator;
 386     else if (equalLettersIgnoringASCIICase(markerType, &quot;rejectedcorrection&quot;))
 387         result = DocumentMarker::RejectedCorrection;
 388     else if (equalLettersIgnoringASCIICase(markerType, &quot;autocorrected&quot;))
 389         result = DocumentMarker::Autocorrected;
 390     else if (equalLettersIgnoringASCIICase(markerType, &quot;spellcheckingexemption&quot;))
 391         result = DocumentMarker::SpellCheckingExemption;
 392     else if (equalLettersIgnoringASCIICase(markerType, &quot;deletedautocorrection&quot;))
 393         result = DocumentMarker::DeletedAutocorrection;
 394     else if (equalLettersIgnoringASCIICase(markerType, &quot;dictationalternatives&quot;))
 395         result = DocumentMarker::DictationAlternatives;
 396 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 397     else if (equalLettersIgnoringASCIICase(markerType, &quot;telephonenumber&quot;))
 398         result = DocumentMarker::TelephoneNumber;
 399 #endif
 400     else
 401         return false;
 402 
 403     return true;
 404 }
 405 
 406 static bool markerTypesFrom(const String&amp; markerType, OptionSet&lt;DocumentMarker::MarkerType&gt;&amp; result)
 407 {
 408     DocumentMarker::MarkerType singularResult;
 409 
 410     if (markerType.isEmpty() || equalLettersIgnoringASCIICase(markerType, &quot;all&quot;))
 411         result = DocumentMarker::allMarkers();
 412     else if (markerTypeFrom(markerType, singularResult))
 413         result = singularResult;
 414     else
 415         return false;
 416 
 417     return true;
 418 }
 419 
 420 static std::unique_ptr&lt;PrintContext&gt;&amp; printContextForTesting()
 421 {
 422     static NeverDestroyed&lt;std::unique_ptr&lt;PrintContext&gt;&gt; context;
 423     return context;
 424 }
 425 
 426 const char* Internals::internalsId = &quot;internals&quot;;
 427 
 428 Ref&lt;Internals&gt; Internals::create(Document&amp; document)
 429 {
 430     return adoptRef(*new Internals(document));
 431 }
 432 
 433 Internals::~Internals()
 434 {
 435 #if ENABLE(MEDIA_STREAM)
 436     if (m_track)
 437         m_track-&gt;source().removeObserver(*this);
 438 #endif
 439 }
 440 
 441 void Internals::resetToConsistentState(Page&amp; page)
 442 {
 443     page.setPageScaleFactor(1, IntPoint(0, 0));
 444     page.setPagination(Pagination());
 445     page.setPaginationLineGridEnabled(false);
 446 
 447     page.setDefersLoading(false);
 448 
 449     page.mainFrame().setTextZoomFactor(1.0f);
 450 
<a name="19" id="anc19"></a><span class="line-modified"> 451     page.setCompositingPolicyOverride(WTF::nullopt);</span>
 452 
 453     FrameView* mainFrameView = page.mainFrame().view();
 454     if (mainFrameView) {
 455         page.setHeaderHeight(0);
 456         page.setFooterHeight(0);
 457         page.setTopContentInset(0);
 458         mainFrameView-&gt;setUseFixedLayout(false);
 459         mainFrameView-&gt;setFixedLayoutSize(IntSize());
<a name="20" id="anc20"></a>
 460 #if USE(COORDINATED_GRAPHICS)
 461         mainFrameView-&gt;setFixedVisibleContentRect(IntRect());
 462 #endif
 463         if (auto* backing = mainFrameView-&gt;tiledBacking())
 464             backing-&gt;setTileSizeUpdateDelayDisabledForTesting(false);
 465     }
 466 
 467     WTF::clearDefaultPortForProtocolMapForTesting();
 468     overrideUserPreferredLanguages(Vector&lt;String&gt;());
 469     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(false);
 470     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(false);
 471 #if ENABLE(VIDEO_TRACK)
 472     page.group().captionPreferences().setTestingMode(true);
 473     page.group().captionPreferences().setCaptionsStyleSheetOverride(emptyString());
 474     page.group().captionPreferences().setTestingMode(false);
 475 #endif
 476     if (!page.mainFrame().editor().isContinuousSpellCheckingEnabled())
 477         page.mainFrame().editor().toggleContinuousSpellChecking();
 478     if (page.mainFrame().editor().isOverwriteModeEnabled())
 479         page.mainFrame().editor().toggleOverwriteModeEnabled();
 480     page.mainFrame().loader().clearTestingOverrides();
 481     page.applicationCacheStorage().setDefaultOriginQuota(ApplicationCacheStorage::noQuota());
 482 #if ENABLE(VIDEO)
 483     PlatformMediaSessionManager::sharedManager().resetRestrictions();
 484     PlatformMediaSessionManager::sharedManager().setWillIgnoreSystemInterruptions(true);
 485 #endif
<a name="21" id="anc21"></a><span class="line-modified"> 486 #if HAVE(ACCESSIBILITY)</span>

 487     AXObjectCache::setEnhancedUserInterfaceAccessibility(false);
 488     AXObjectCache::disableAccessibility();
 489 #endif
 490 
 491     MockPageOverlayClient::singleton().uninstallAllOverlays();
 492 
 493 #if ENABLE(CONTENT_FILTERING)
 494     MockContentFilterSettings::reset();
 495 #endif
 496 
 497 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 498     page.setMockMediaPlaybackTargetPickerEnabled(true);
 499     page.setMockMediaPlaybackTargetPickerState(emptyString(), MediaPlaybackTargetContext::Unknown);
 500 #endif
 501 
 502     page.setShowAllPlugins(false);
 503     page.setLowPowerModeEnabledOverrideForTesting(WTF::nullopt);
 504 
 505 #if USE(QUICK_LOOK)
 506     MockPreviewLoaderClient::singleton().setPassword(&quot;&quot;);
 507     PreviewLoader::setClientForTesting(nullptr);
 508 #endif
 509 
 510     printContextForTesting() = nullptr;
 511 
 512 #if USE(LIBWEBRTC)
 513     auto&amp; rtcProvider = page.libWebRTCProvider();
 514     WebCore::useRealRTCPeerConnectionFactory(rtcProvider);
 515     rtcProvider.disableNonLocalhostConnections();
 516     RuntimeEnabledFeatures::sharedFeatures().setWebRTCVP8CodecEnabled(true);
<a name="22" id="anc22"></a>
 517 #endif
 518 
 519     page.settings().setStorageAccessAPIEnabled(false);
 520     page.setFullscreenAutoHideDuration(0_s);
 521     page.setFullscreenInsets({ });
 522     page.setFullscreenControlsHidden(false);
 523 
 524     MediaEngineConfigurationFactory::disableMock();
<a name="23" id="anc23"></a>



 525 }
 526 
 527 Internals::Internals(Document&amp; document)
 528     : ContextDestructionObserver(&amp;document)
 529 #if ENABLE(MEDIA_STREAM)
 530     , m_orientationNotifier(0)
 531 #endif
 532 {
 533 #if ENABLE(VIDEO_TRACK)
 534     if (document.page())
 535         document.page()-&gt;group().captionPreferences().setTestingMode(true);
 536 #endif
 537 
 538 #if ENABLE(MEDIA_STREAM)
 539     setMockMediaCaptureDevicesEnabled(true);
 540     setMediaCaptureRequiresSecureConnection(false);
 541 #endif
 542 
 543 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 544     if (document.page())
 545         document.page()-&gt;setMockMediaPlaybackTargetPickerEnabled(true);
 546 #endif
 547 
 548     if (contextDocument() &amp;&amp; contextDocument()-&gt;frame()) {
 549         setAutomaticSpellingCorrectionEnabled(true);
 550         setAutomaticQuoteSubstitutionEnabled(false);
 551         setAutomaticDashSubstitutionEnabled(false);
 552         setAutomaticLinkDetectionEnabled(false);
 553         setAutomaticTextReplacementEnabled(true);
 554     }
 555 
 556     setConsoleMessageListener(nullptr);
 557 
 558 #if ENABLE(APPLE_PAY)
 559     auto* frame = document.frame();
 560     if (frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;isMainFrame()) {
 561         auto mockPaymentCoordinator = new MockPaymentCoordinator(*frame-&gt;page());
<a name="24" id="anc24"></a><span class="line-modified"> 562         frame-&gt;page()-&gt;setPaymentCoordinator(std::make_unique&lt;PaymentCoordinator&gt;(*mockPaymentCoordinator));</span>
 563     }
 564 #endif
 565 }
 566 
 567 Document* Internals::contextDocument() const
 568 {
 569     return downcast&lt;Document&gt;(scriptExecutionContext());
 570 }
 571 
 572 Frame* Internals::frame() const
 573 {
 574     if (!contextDocument())
 575         return nullptr;
 576     return contextDocument()-&gt;frame();
 577 }
 578 
 579 InternalSettings* Internals::settings() const
 580 {
 581     Document* document = contextDocument();
 582     if (!document)
 583         return nullptr;
 584     Page* page = document-&gt;page();
 585     if (!page)
 586         return nullptr;
 587     return InternalSettings::from(page);
 588 }
 589 
 590 unsigned Internals::workerThreadCount() const
 591 {
 592     return WorkerThread::workerThreadCount();
 593 }
 594 
 595 ExceptionOr&lt;bool&gt; Internals::areSVGAnimationsPaused() const
 596 {
 597     auto* document = contextDocument();
 598     if (!document)
 599         return Exception { InvalidAccessError, &quot;No context document&quot;_s };
 600 
 601     if (!document-&gt;svgExtensions())
 602         return Exception { NotFoundError, &quot;No SVG animations&quot;_s };
 603 
 604     return document-&gt;accessSVGExtensions().areAnimationsPaused();
 605 }
 606 
 607 ExceptionOr&lt;double&gt; Internals::svgAnimationsInterval(SVGSVGElement&amp; element) const
 608 {
 609     auto* document = contextDocument();
 610     if (!document)
 611         return 0;
 612 
 613     if (!document-&gt;svgExtensions())
 614         return 0;
 615 
 616     if (document-&gt;accessSVGExtensions().areAnimationsPaused())
 617         return 0;
 618 
 619     return element.timeContainer().animationFrameDelay().value();
 620 }
 621 
 622 String Internals::address(Node&amp; node)
 623 {
 624     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;node)));
 625 }
 626 
 627 bool Internals::nodeNeedsStyleRecalc(Node&amp; node)
 628 {
 629     return node.needsStyleRecalc();
 630 }
 631 
 632 static String styleValidityToToString(Style::Validity validity)
 633 {
 634     switch (validity) {
 635     case Style::Validity::Valid:
 636         return &quot;NoStyleChange&quot;;
 637     case Style::Validity::ElementInvalid:
 638         return &quot;InlineStyleChange&quot;;
 639     case Style::Validity::SubtreeInvalid:
 640         return &quot;FullStyleChange&quot;;
 641     case Style::Validity::SubtreeAndRenderersInvalid:
 642         return &quot;ReconstructRenderTree&quot;;
 643     }
 644     ASSERT_NOT_REACHED();
 645     return &quot;&quot;;
 646 }
 647 
 648 String Internals::styleChangeType(Node&amp; node)
 649 {
 650     node.document().styleScope().flushPendingUpdate();
 651 
 652     return styleValidityToToString(node.styleValidity());
 653 }
 654 
 655 String Internals::description(JSC::JSValue value)
 656 {
 657     return toString(value);
 658 }
 659 
 660 bool Internals::isPreloaded(const String&amp; url)
 661 {
 662     Document* document = contextDocument();
 663     return document-&gt;cachedResourceLoader().isPreloaded(url);
 664 }
 665 
 666 bool Internals::isLoadingFromMemoryCache(const String&amp; url)
 667 {
 668     if (!contextDocument() || !contextDocument()-&gt;page())
 669         return false;
 670 
 671     ResourceRequest request(contextDocument()-&gt;completeURL(url));
 672     request.setDomainForCachePartition(contextDocument()-&gt;domainForCachePartition());
 673 
 674     CachedResource* resource = MemoryCache::singleton().resourceForRequest(request, contextDocument()-&gt;page()-&gt;sessionID());
 675     return resource &amp;&amp; resource-&gt;status() == CachedResource::Cached;
 676 }
 677 
 678 static String responseSourceToString(const ResourceResponse&amp; response)
 679 {
 680     if (response.isNull())
 681         return &quot;Null response&quot;;
 682     switch (response.source()) {
 683     case ResourceResponse::Source::Unknown:
 684         return &quot;Unknown&quot;;
 685     case ResourceResponse::Source::Network:
 686         return &quot;Network&quot;;
 687     case ResourceResponse::Source::ServiceWorker:
 688         return &quot;Service worker&quot;;
 689     case ResourceResponse::Source::DiskCache:
 690         return &quot;Disk cache&quot;;
 691     case ResourceResponse::Source::DiskCacheAfterValidation:
 692         return &quot;Disk cache after validation&quot;;
 693     case ResourceResponse::Source::MemoryCache:
 694         return &quot;Memory cache&quot;;
 695     case ResourceResponse::Source::MemoryCacheAfterValidation:
 696         return &quot;Memory cache after validation&quot;;
 697     case ResourceResponse::Source::ApplicationCache:
 698         return &quot;Application cache&quot;;
 699     }
 700     ASSERT_NOT_REACHED();
 701     return &quot;Error&quot;;
 702 }
 703 
 704 String Internals::xhrResponseSource(XMLHttpRequest&amp; request)
 705 {
 706     return responseSourceToString(request.resourceResponse());
 707 }
 708 
 709 String Internals::fetchResponseSource(FetchResponse&amp; response)
 710 {
 711     return responseSourceToString(response.resourceResponse());
 712 }
 713 
 714 bool Internals::isSharingStyleSheetContents(HTMLLinkElement&amp; a, HTMLLinkElement&amp; b)
 715 {
 716     if (!a.sheet() || !b.sheet())
 717         return false;
 718     return &amp;a.sheet()-&gt;contents() == &amp;b.sheet()-&gt;contents();
 719 }
 720 
 721 bool Internals::isStyleSheetLoadingSubresources(HTMLLinkElement&amp; link)
 722 {
 723     return link.sheet() &amp;&amp; link.sheet()-&gt;contents().isLoadingSubresources();
 724 }
 725 
 726 static ResourceRequestCachePolicy toResourceRequestCachePolicy(Internals::CachePolicy policy)
 727 {
 728     switch (policy) {
 729     case Internals::CachePolicy::UseProtocolCachePolicy:
 730         return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 731     case Internals::CachePolicy::ReloadIgnoringCacheData:
 732         return ResourceRequestCachePolicy::ReloadIgnoringCacheData;
 733     case Internals::CachePolicy::ReturnCacheDataElseLoad:
 734         return ResourceRequestCachePolicy::ReturnCacheDataElseLoad;
 735     case Internals::CachePolicy::ReturnCacheDataDontLoad:
 736         return ResourceRequestCachePolicy::ReturnCacheDataDontLoad;
 737     }
 738     ASSERT_NOT_REACHED();
 739     return ResourceRequestCachePolicy::UseProtocolCachePolicy;
 740 }
 741 
 742 void Internals::setOverrideCachePolicy(CachePolicy policy)
 743 {
 744     frame()-&gt;loader().setOverrideCachePolicyForTesting(toResourceRequestCachePolicy(policy));
 745 }
 746 
 747 ExceptionOr&lt;void&gt; Internals::setCanShowModalDialogOverride(bool allow)
 748 {
 749     if (!contextDocument() || !contextDocument()-&gt;domWindow())
 750         return Exception { InvalidAccessError };
 751 
 752     contextDocument()-&gt;domWindow()-&gt;setCanShowModalDialogOverride(allow);
 753     return { };
 754 }
 755 
 756 static ResourceLoadPriority toResourceLoadPriority(Internals::ResourceLoadPriority priority)
 757 {
 758     switch (priority) {
 759     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryLow:
 760         return ResourceLoadPriority::VeryLow;
 761     case Internals::ResourceLoadPriority::ResourceLoadPriorityLow:
 762         return ResourceLoadPriority::Low;
 763     case Internals::ResourceLoadPriority::ResourceLoadPriorityMedium:
 764         return ResourceLoadPriority::Medium;
 765     case Internals::ResourceLoadPriority::ResourceLoadPriorityHigh:
 766         return ResourceLoadPriority::High;
 767     case Internals::ResourceLoadPriority::ResourceLoadPriorityVeryHigh:
 768         return ResourceLoadPriority::VeryHigh;
 769     }
 770     ASSERT_NOT_REACHED();
 771     return ResourceLoadPriority::Low;
 772 }
 773 
 774 void Internals::setOverrideResourceLoadPriority(ResourceLoadPriority priority)
 775 {
 776     frame()-&gt;loader().setOverrideResourceLoadPriorityForTesting(toResourceLoadPriority(priority));
 777 }
 778 
 779 void Internals::setStrictRawResourceValidationPolicyDisabled(bool disabled)
 780 {
 781     frame()-&gt;loader().setStrictRawResourceValidationPolicyDisabledForTesting(disabled);
 782 }
 783 
 784 void Internals::clearMemoryCache()
 785 {
 786     MemoryCache::singleton().evictResources();
 787 }
 788 
 789 void Internals::pruneMemoryCacheToSize(unsigned size)
 790 {
 791     MemoryCache::singleton().pruneDeadResourcesToSize(size);
 792     MemoryCache::singleton().pruneLiveResourcesToSize(size, true);
 793 }
 794 
 795 void Internals::destroyDecodedDataForAllImages()
 796 {
 797     MemoryCache::singleton().destroyDecodedDataForAllImages();
 798 }
 799 
 800 unsigned Internals::memoryCacheSize() const
 801 {
 802     return MemoryCache::singleton().size();
 803 }
 804 
 805 static Image* imageFromImageElement(HTMLImageElement&amp; element)
 806 {
 807     auto* cachedImage = element.cachedImage();
 808     return cachedImage ? cachedImage-&gt;image() : nullptr;
 809 }
 810 
 811 static BitmapImage* bitmapImageFromImageElement(HTMLImageElement&amp; element)
 812 {
 813     auto* image = imageFromImageElement(element);
 814     return image &amp;&amp; is&lt;BitmapImage&gt;(image) ? &amp;downcast&lt;BitmapImage&gt;(*image) : nullptr;
 815 }
 816 
 817 #if USE(CG)
 818 static PDFDocumentImage* pdfDocumentImageFromImageElement(HTMLImageElement&amp; element)
 819 {
 820     auto* image = imageFromImageElement(element);
 821     return image &amp;&amp; is&lt;PDFDocumentImage&gt;(image) ? &amp;downcast&lt;PDFDocumentImage&gt;(*image) : nullptr;
 822 }
 823 #endif
 824 
 825 unsigned Internals::imageFrameIndex(HTMLImageElement&amp; element)
 826 {
 827     auto* bitmapImage = bitmapImageFromImageElement(element);
 828     return bitmapImage ? bitmapImage-&gt;currentFrame() : 0;
 829 }
 830 
<a name="25" id="anc25"></a>











 831 void Internals::setImageFrameDecodingDuration(HTMLImageElement&amp; element, float duration)
 832 {
 833     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 834         bitmapImage-&gt;setFrameDecodingDurationForTesting(Seconds { duration });
 835 }
 836 
 837 void Internals::resetImageAnimation(HTMLImageElement&amp; element)
 838 {
 839     if (auto* image = imageFromImageElement(element))
 840         image-&gt;resetAnimation();
 841 }
 842 
 843 bool Internals::isImageAnimating(HTMLImageElement&amp; element)
 844 {
 845     auto* image = imageFromImageElement(element);
 846     return image &amp;&amp; (image-&gt;isAnimating() || image-&gt;animationPending());
 847 }
 848 
<a name="26" id="anc26"></a>




 849 void Internals::setClearDecoderAfterAsyncFrameRequestForTesting(HTMLImageElement&amp; element, bool enabled)
 850 {
 851     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 852         bitmapImage-&gt;setClearDecoderAfterAsyncFrameRequestForTesting(enabled);
 853 }
 854 
 855 unsigned Internals::imageDecodeCount(HTMLImageElement&amp; element)
 856 {
 857     auto* bitmapImage = bitmapImageFromImageElement(element);
 858     return bitmapImage ? bitmapImage-&gt;decodeCountForTesting() : 0;
 859 }
 860 
 861 unsigned Internals::pdfDocumentCachingCount(HTMLImageElement&amp; element)
 862 {
 863 #if USE(CG)
 864     auto* pdfDocumentImage = pdfDocumentImageFromImageElement(element);
 865     return pdfDocumentImage ? pdfDocumentImage-&gt;cachingCountForTesting() : 0;
 866 #else
 867     UNUSED_PARAM(element);
 868     return 0;
 869 #endif
 870 }
 871 
 872 void Internals::setLargeImageAsyncDecodingEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 873 {
 874     if (auto* bitmapImage = bitmapImageFromImageElement(element))
 875         bitmapImage-&gt;setLargeImageAsyncDecodingEnabledForTesting(enabled);
 876 }
 877 
 878 void Internals::setForceUpdateImageDataEnabledForTesting(HTMLImageElement&amp; element, bool enabled)
 879 {
 880     if (auto* cachedImage = element.cachedImage())
 881         cachedImage-&gt;setForceUpdateImageDataEnabledForTesting(enabled);
 882 }
 883 
 884 void Internals::setGridMaxTracksLimit(unsigned maxTrackLimit)
 885 {
 886     GridPosition::setMaxPositionForTesting(maxTrackLimit);
 887 }
 888 
 889 void Internals::clearPageCache()
 890 {
 891     PageCache::singleton().pruneToSizeNow(0, PruningReason::None);
 892 }
 893 
 894 unsigned Internals::pageCacheSize() const
 895 {
 896     return PageCache::singleton().pageCount();
 897 }
 898 
 899 void Internals::disableTileSizeUpdateDelay()
 900 {
 901     Document* document = contextDocument();
 902     if (!document || !document-&gt;frame())
 903         return;
 904 
 905     auto* view = document-&gt;frame()-&gt;view();
 906     if (!view)
 907         return;
 908 
 909     if (auto* backing = view-&gt;tiledBacking())
 910         backing-&gt;setTileSizeUpdateDelayDisabledForTesting(true);
 911 }
 912 
 913 void Internals::setSpeculativeTilingDelayDisabledForTesting(bool disabled)
 914 {
 915     Document* document = contextDocument();
 916     if (!document || !document-&gt;frame())
 917         return;
 918 
 919     if (auto* frameView = document-&gt;frame()-&gt;view())
 920         frameView-&gt;setSpeculativeTilingDelayDisabledForTesting(disabled);
 921 }
 922 
 923 
 924 Node* Internals::treeScopeRootNode(Node&amp; node)
 925 {
 926     return &amp;node.treeScope().rootNode();
 927 }
 928 
 929 Node* Internals::parentTreeScope(Node&amp; node)
 930 {
 931     const TreeScope* parentTreeScope = node.treeScope().parentTreeScope();
 932     return parentTreeScope ? &amp;parentTreeScope-&gt;rootNode() : nullptr;
 933 }
 934 
 935 ExceptionOr&lt;unsigned&gt; Internals::lastSpatialNavigationCandidateCount() const
 936 {
 937     if (!contextDocument() || !contextDocument()-&gt;page())
 938         return Exception { InvalidAccessError };
 939 
 940     return contextDocument()-&gt;page()-&gt;lastSpatialNavigationCandidateCount();
 941 }
 942 
 943 unsigned Internals::numberOfActiveAnimations() const
 944 {
 945     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
 946         return frame()-&gt;document()-&gt;timeline().numberOfActiveAnimationsForTesting();
 947     return frame()-&gt;animation().numberOfActiveAnimations(frame()-&gt;document());
 948 }
 949 
 950 ExceptionOr&lt;bool&gt; Internals::animationsAreSuspended() const
 951 {
 952     Document* document = contextDocument();
 953     if (!document || !document-&gt;frame())
 954         return Exception { InvalidAccessError };
 955 
 956     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
 957         return document-&gt;timeline().animationsAreSuspended();
 958     return document-&gt;frame()-&gt;animation().animationsAreSuspendedForDocument(document);
 959 }
 960 
 961 double Internals::animationsInterval() const
 962 {
 963     Document* document = contextDocument();
 964     if (!document)
 965         return INFINITY;
 966 
 967     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 968         if (auto timeline = document-&gt;existingTimeline())
 969             return timeline-&gt;animationInterval().seconds();
 970         return INFINITY;
 971     }
 972 
 973     if (!document-&gt;frame())
 974         return INFINITY;
 975     return document-&gt;frame()-&gt;animation().animationInterval().value();
 976 }
 977 
 978 ExceptionOr&lt;void&gt; Internals::suspendAnimations() const
 979 {
 980     Document* document = contextDocument();
 981     if (!document || !document-&gt;frame())
 982         return Exception { InvalidAccessError };
 983 
 984     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 985         document-&gt;timeline().suspendAnimations();
 986         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 987             if (Document* document = frame-&gt;document())
 988                 document-&gt;timeline().suspendAnimations();
 989         }
 990     } else {
 991         document-&gt;frame()-&gt;animation().suspendAnimationsForDocument(document);
 992 
 993         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 994             if (Document* document = frame-&gt;document())
 995                 frame-&gt;animation().suspendAnimationsForDocument(document);
 996         }
 997     }
 998 
 999     return { };
1000 }
1001 
1002 ExceptionOr&lt;void&gt; Internals::resumeAnimations() const
1003 {
1004     Document* document = contextDocument();
1005     if (!document || !document-&gt;frame())
1006         return Exception { InvalidAccessError };
1007 
1008     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1009         document-&gt;timeline().resumeAnimations();
1010         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1011             if (Document* document = frame-&gt;document())
1012                 document-&gt;timeline().resumeAnimations();
1013         }
1014     } else {
1015         document-&gt;frame()-&gt;animation().resumeAnimationsForDocument(document);
1016 
1017         for (Frame* frame = document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
1018             if (Document* document = frame-&gt;document())
1019                 frame-&gt;animation().resumeAnimationsForDocument(document);
1020         }
1021     }
1022 
1023     return { };
1024 }
1025 
1026 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnElement(const String&amp; animationName, double pauseTime, Element&amp; element)
1027 {
1028     if (pauseTime &lt; 0)
1029         return Exception { InvalidAccessError };
<a name="27" id="anc27"></a><span class="line-modified">1030     return frame()-&gt;animation().pauseAnimationAtTime(element, AtomicString(animationName), pauseTime);</span>
1031 }
1032 
1033 ExceptionOr&lt;bool&gt; Internals::pauseAnimationAtTimeOnPseudoElement(const String&amp; animationName, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1034 {
1035     if (pauseTime &lt; 0)
1036         return Exception { InvalidAccessError };
1037 
1038     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1039         return Exception { InvalidAccessError };
1040 
1041     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1042     if (!pseudoElement)
1043         return Exception { InvalidAccessError };
1044 
<a name="28" id="anc28"></a><span class="line-modified">1045     return frame()-&gt;animation().pauseAnimationAtTime(*pseudoElement, AtomicString(animationName), pauseTime);</span>
1046 }
1047 
1048 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnElement(const String&amp; propertyName, double pauseTime, Element&amp; element)
1049 {
1050     if (pauseTime &lt; 0)
1051         return Exception { InvalidAccessError };
1052     return frame()-&gt;animation().pauseTransitionAtTime(element, propertyName, pauseTime);
1053 }
1054 
1055 ExceptionOr&lt;bool&gt; Internals::pauseTransitionAtTimeOnPseudoElement(const String&amp; property, double pauseTime, Element&amp; element, const String&amp; pseudoId)
1056 {
1057     if (pauseTime &lt; 0)
1058         return Exception { InvalidAccessError };
1059 
1060     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1061         return Exception { InvalidAccessError };
1062 
1063     PseudoElement* pseudoElement = pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1064     if (!pseudoElement)
1065         return Exception { InvalidAccessError };
1066 
1067     return frame()-&gt;animation().pauseTransitionAtTime(*pseudoElement, property, pauseTime);
1068 }
1069 
1070 Vector&lt;Internals::AcceleratedAnimation&gt; Internals::acceleratedAnimationsForElement(Element&amp; element)
1071 {
1072     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1073         return { };
1074 
1075     Vector&lt;Internals::AcceleratedAnimation&gt; animations;
1076     for (const auto&amp; animationAsPair : element.document().timeline().acceleratedAnimationsForElement(element))
1077         animations.append({ animationAsPair.first, animationAsPair.second });
1078     return animations;
1079 }
1080 
1081 unsigned Internals::numberOfAnimationTimelineInvalidations() const
1082 {
1083     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
1084         return frame()-&gt;document()-&gt;timeline().numberOfAnimationTimelineInvalidationsForTesting();
1085     return 0;
1086 }
1087 
1088 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; Internals::pseudoElement(Element&amp; element, const String&amp; pseudoId)
1089 {
1090     if (pseudoId != &quot;before&quot; &amp;&amp; pseudoId != &quot;after&quot;)
1091         return Exception { InvalidAccessError };
1092 
1093     return pseudoId == &quot;before&quot; ? element.beforePseudoElement() : element.afterPseudoElement();
1094 }
1095 
1096 ExceptionOr&lt;String&gt; Internals::elementRenderTreeAsText(Element&amp; element)
1097 {
1098     element.document().updateStyleIfNeeded();
1099 
1100     String representation = externalRepresentation(&amp;element);
1101     if (representation.isEmpty())
1102         return Exception { InvalidAccessError };
1103 
<a name="29" id="anc29"></a><span class="line-modified">1104     return WTFMove(representation);</span>
1105 }
1106 
1107 bool Internals::hasPausedImageAnimations(Element&amp; element)
1108 {
1109     return element.renderer() &amp;&amp; element.renderer()-&gt;hasPausedImageAnimations();
1110 }
1111 
1112 bool Internals::isPaintingFrequently(Element&amp; element)
1113 {
1114     return element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer() &amp;&amp; element.renderer()-&gt;enclosingLayer()-&gt;paintingFrequently();
1115 }
1116 
1117 void Internals::incrementFrequentPaintCounter(Element&amp; element)
1118 {
1119     if (element.renderer() &amp;&amp; element.renderer()-&gt;enclosingLayer())
1120         element.renderer()-&gt;enclosingLayer()-&gt;simulateFrequentPaint();
1121 }
1122 
1123 Ref&lt;CSSComputedStyleDeclaration&gt; Internals::computedStyleIncludingVisitedInfo(Element&amp; element) const
1124 {
1125     bool allowVisitedStyle = true;
1126     return CSSComputedStyleDeclaration::create(element, allowVisitedStyle);
1127 }
1128 
1129 Node* Internals::ensureUserAgentShadowRoot(Element&amp; host)
1130 {
1131     return &amp;host.ensureUserAgentShadowRoot();
1132 }
1133 
1134 Node* Internals::shadowRoot(Element&amp; host)
1135 {
1136     return host.shadowRoot();
1137 }
1138 
1139 ExceptionOr&lt;String&gt; Internals::shadowRootType(const Node&amp; root) const
1140 {
1141     if (!is&lt;ShadowRoot&gt;(root))
1142         return Exception { InvalidAccessError };
1143 
1144     switch (downcast&lt;ShadowRoot&gt;(root).mode()) {
1145     case ShadowRootMode::UserAgent:
1146         return &quot;UserAgentShadowRoot&quot;_str;
1147     case ShadowRootMode::Closed:
1148         return &quot;ClosedShadowRoot&quot;_str;
1149     case ShadowRootMode::Open:
1150         return &quot;OpenShadowRoot&quot;_str;
1151     default:
1152         ASSERT_NOT_REACHED();
1153         return &quot;Unknown&quot;_str;
1154     }
1155 }
1156 
1157 String Internals::shadowPseudoId(Element&amp; element)
1158 {
1159     return element.shadowPseudoId().string();
1160 }
1161 
1162 void Internals::setShadowPseudoId(Element&amp; element, const String&amp; id)
1163 {
1164     return element.setPseudo(id);
1165 }
1166 
1167 static unsigned deferredStyleRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1168 {
1169     unsigned count = 0;
1170     for (auto rule : childRules) {
1171         if (is&lt;StyleRule&gt;(rule)) {
1172             auto* cssRule = downcast&lt;StyleRule&gt;(rule.get());
1173             if (!cssRule-&gt;propertiesWithoutDeferredParsing())
1174                 count++;
1175             continue;
1176         }
1177 
1178         StyleRuleGroup* groupRule = nullptr;
1179         if (is&lt;StyleRuleMedia&gt;(rule))
1180             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1181         else if (is&lt;StyleRuleSupports&gt;(rule))
1182             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1183         if (!groupRule)
1184             continue;
1185 
1186         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1187         if (!groupChildRules)
1188             continue;
1189 
1190         count += deferredStyleRulesCountForList(*groupChildRules);
1191     }
1192 
1193     return count;
1194 }
1195 
1196 unsigned Internals::deferredStyleRulesCount(StyleSheet&amp; styleSheet)
1197 {
1198     return deferredStyleRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1199 }
1200 
1201 static unsigned deferredGroupRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1202 {
1203     unsigned count = 0;
1204     for (auto rule : childRules) {
1205         StyleRuleGroup* groupRule = nullptr;
1206         if (is&lt;StyleRuleMedia&gt;(rule))
1207             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1208         else if (is&lt;StyleRuleSupports&gt;(rule))
1209             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1210         if (!groupRule)
1211             continue;
1212 
1213         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1214         if (!groupChildRules)
1215             count++;
1216         else
1217             count += deferredGroupRulesCountForList(*groupChildRules);
1218     }
1219     return count;
1220 }
1221 
1222 unsigned Internals::deferredGroupRulesCount(StyleSheet&amp; styleSheet)
1223 {
1224     return deferredGroupRulesCountForList(downcast&lt;CSSStyleSheet&gt;(styleSheet).contents().childRules());
1225 }
1226 
1227 static unsigned deferredKeyframesRulesCountForList(const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
1228 {
1229     unsigned count = 0;
1230     for (auto rule : childRules) {
1231         if (is&lt;StyleRuleKeyframes&gt;(rule)) {
1232             auto* cssRule = downcast&lt;StyleRuleKeyframes&gt;(rule.get());
1233             if (!cssRule-&gt;keyframesWithoutDeferredParsing())
1234                 count++;
1235             continue;
1236         }
1237 
1238         StyleRuleGroup* groupRule = nullptr;
1239         if (is&lt;StyleRuleMedia&gt;(rule))
1240             groupRule = downcast&lt;StyleRuleMedia&gt;(rule.get());
1241         else if (is&lt;StyleRuleSupports&gt;(rule))
1242             groupRule = downcast&lt;StyleRuleSupports&gt;(rule.get());
1243         if (!groupRule)
1244             continue;
1245 
1246         auto* groupChildRules = groupRule-&gt;childRulesWithoutDeferredParsing();
1247         if (!groupChildRules)
1248             continue;
1249 
1250         count += deferredKeyframesRulesCountForList(*groupChildRules);
1251     }
1252 
1253     return count;
1254 }
1255 
1256 unsigned Internals::deferredKeyframesRulesCount(StyleSheet&amp; styleSheet)
1257 {
1258     StyleSheetContents&amp; contents = downcast&lt;CSSStyleSheet&gt;(styleSheet).contents();
1259     return deferredKeyframesRulesCountForList(contents.childRules());
1260 }
1261 
1262 ExceptionOr&lt;bool&gt; Internals::isTimerThrottled(int timeoutId)
1263 {
1264     auto* timer = scriptExecutionContext()-&gt;findTimeout(timeoutId);
1265     if (!timer)
1266         return Exception { NotFoundError };
1267 
1268     if (timer-&gt;intervalClampedToMinimum() &gt; timer-&gt;m_originalInterval)
1269         return true;
1270 
1271     return !!timer-&gt;alignedFireTime(MonotonicTime { });
1272 }
1273 
1274 bool Internals::isRequestAnimationFrameThrottled() const
1275 {
1276     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1277     if (!scriptedAnimationController)
1278         return false;
1279     return scriptedAnimationController-&gt;isThrottled();
1280 }
1281 
1282 double Internals::requestAnimationFrameInterval() const
1283 {
1284     auto* scriptedAnimationController = contextDocument()-&gt;scriptedAnimationController();
1285     if (!scriptedAnimationController)
1286         return INFINITY;
1287     return scriptedAnimationController-&gt;interval().value();
1288 }
1289 
1290 bool Internals::scriptedAnimationsAreSuspended() const
1291 {
1292     Document* document = contextDocument();
1293     if (!document || !document-&gt;page())
1294         return true;
1295 
1296     return document-&gt;page()-&gt;scriptedAnimationsSuspended();
1297 }
1298 
1299 bool Internals::areTimersThrottled() const
1300 {
1301     return contextDocument()-&gt;isTimerThrottlingEnabled();
1302 }
1303 
1304 void Internals::setEventThrottlingBehaviorOverride(Optional&lt;EventThrottlingBehavior&gt; value)
1305 {
1306     Document* document = contextDocument();
1307     if (!document || !document-&gt;page())
1308         return;
1309 
1310     if (!value) {
1311         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WTF::nullopt);
1312         return;
1313     }
1314 
1315     switch (value.value()) {
1316     case Internals::EventThrottlingBehavior::Responsive:
1317         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Responsive);
1318         break;
1319     case Internals::EventThrottlingBehavior::Unresponsive:
1320         document-&gt;page()-&gt;setEventThrottlingBehaviorOverride(WebCore::EventThrottlingBehavior::Unresponsive);
1321         break;
1322     }
1323 }
1324 
1325 Optional&lt;Internals::EventThrottlingBehavior&gt; Internals::eventThrottlingBehaviorOverride() const
1326 {
1327     Document* document = contextDocument();
1328     if (!document || !document-&gt;page())
1329         return WTF::nullopt;
1330 
1331     auto behavior = document-&gt;page()-&gt;eventThrottlingBehaviorOverride();
1332     if (!behavior)
1333         return WTF::nullopt;
1334 
1335     switch (behavior.value()) {
1336     case WebCore::EventThrottlingBehavior::Responsive:
1337         return Internals::EventThrottlingBehavior::Responsive;
1338     case WebCore::EventThrottlingBehavior::Unresponsive:
1339         return Internals::EventThrottlingBehavior::Unresponsive;
1340     }
1341 
1342     return WTF::nullopt;
1343 }
1344 
1345 String Internals::visiblePlaceholder(Element&amp; element)
1346 {
1347     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
1348         const HTMLTextFormControlElement&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(element);
1349         if (!textFormControlElement.isPlaceholderVisible())
1350             return String();
1351         if (HTMLElement* placeholderElement = textFormControlElement.placeholderElement())
1352             return placeholderElement-&gt;textContent();
1353     }
1354 
1355     return String();
1356 }
1357 
1358 void Internals::selectColorInColorChooser(HTMLInputElement&amp; element, const String&amp; colorValue)
1359 {
1360     element.selectColor(colorValue);
1361 }
1362 
1363 ExceptionOr&lt;Vector&lt;String&gt;&gt; Internals::formControlStateOfPreviousHistoryItem()
1364 {
1365     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1366     if (!mainItem)
1367         return Exception { InvalidAccessError };
1368     String uniqueName = frame()-&gt;tree().uniqueName();
1369     if (mainItem-&gt;target() != uniqueName &amp;&amp; !mainItem-&gt;childItemWithTarget(uniqueName))
1370         return Exception { InvalidAccessError };
1371     return Vector&lt;String&gt; { mainItem-&gt;target() == uniqueName ? mainItem-&gt;documentState() : mainItem-&gt;childItemWithTarget(uniqueName)-&gt;documentState() };
1372 }
1373 
1374 ExceptionOr&lt;void&gt; Internals::setFormControlStateOfPreviousHistoryItem(const Vector&lt;String&gt;&amp; state)
1375 {
1376     HistoryItem* mainItem = frame()-&gt;loader().history().previousItem();
1377     if (!mainItem)
1378         return Exception { InvalidAccessError };
1379     String uniqueName = frame()-&gt;tree().uniqueName();
1380     if (mainItem-&gt;target() == uniqueName)
1381         mainItem-&gt;setDocumentState(state);
1382     else if (HistoryItem* subItem = mainItem-&gt;childItemWithTarget(uniqueName))
1383         subItem-&gt;setDocumentState(state);
1384     else
1385         return Exception { InvalidAccessError };
1386     return { };
1387 }
1388 
1389 #if ENABLE(SPEECH_SYNTHESIS)
1390 
1391 void Internals::enableMockSpeechSynthesizer()
1392 {
1393     Document* document = contextDocument();
1394     if (!document || !document-&gt;domWindow())
1395         return;
1396     SpeechSynthesis* synthesis = DOMWindowSpeechSynthesis::speechSynthesis(*document-&gt;domWindow());
1397     if (!synthesis)
1398         return;
1399 
<a name="30" id="anc30"></a><span class="line-modified">1400     synthesis-&gt;setPlatformSynthesizer(std::make_unique&lt;PlatformSpeechSynthesizerMock&gt;(synthesis));</span>
1401 }
1402 
1403 #endif
1404 
1405 #if ENABLE(WEB_RTC)
1406 
1407 void Internals::emulateRTCPeerConnectionPlatformEvent(RTCPeerConnection&amp; connection, const String&amp; action)
1408 {
1409     if (!LibWebRTCProvider::webRTCAvailable())
1410         return;
1411 
1412     connection.emulatePlatformEvent(action);
1413 }
1414 
1415 void Internals::useMockRTCPeerConnectionFactory(const String&amp; testCase)
1416 {
<a name="31" id="anc31"></a><span class="line-modified">1417     // FIXME: We should upgrade mocks to support unified plan APIs, until then use plan B in tests using mock.</span>
<span class="line-removed">1418 </span>
<span class="line-removed">1419     ASSERT(!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());</span>
1420     if (!LibWebRTCProvider::webRTCAvailable())
1421         return;
1422 
1423 #if USE(LIBWEBRTC)
1424     Document* document = contextDocument();
1425     LibWebRTCProvider* provider = (document &amp;&amp; document-&gt;page()) ? &amp;document-&gt;page()-&gt;libWebRTCProvider() : nullptr;
1426     WebCore::useMockRTCPeerConnectionFactory(provider, testCase);
1427 #else
1428     UNUSED_PARAM(testCase);
1429 #endif
1430 }
1431 
1432 void Internals::setICECandidateFiltering(bool enabled)
1433 {
1434     auto* page = contextDocument()-&gt;page();
1435     if (!page)
1436         return;
1437 
1438     auto&amp; rtcController = page-&gt;rtcController();
1439     if (enabled)
1440         rtcController.enableICECandidateFiltering();
1441     else
1442         rtcController.disableICECandidateFilteringForAllOrigins();
1443 }
1444 
1445 void Internals::setEnumeratingAllNetworkInterfacesEnabled(bool enabled)
1446 {
1447 #if USE(LIBWEBRTC)
1448     Document* document = contextDocument();
1449     auto* page = document-&gt;page();
1450     if (!page)
1451         return;
1452     auto&amp; rtcProvider = page-&gt;libWebRTCProvider();
1453     if (enabled)
1454         rtcProvider.enableEnumeratingAllNetworkInterfaces();
1455     else
1456         rtcProvider.disableEnumeratingAllNetworkInterfaces();
1457 #else
1458     UNUSED_PARAM(enabled);
1459 #endif
1460 }
1461 
1462 void Internals::stopPeerConnection(RTCPeerConnection&amp; connection)
1463 {
1464     ActiveDOMObject&amp; object = connection;
1465     object.stop();
1466 }
1467 
1468 void Internals::clearPeerConnectionFactory()
1469 {
1470 #if USE(LIBWEBRTC)
1471     if (auto* page = contextDocument()-&gt;page())
1472         page-&gt;libWebRTCProvider().clearFactory();
1473 #endif
1474 }
1475 
1476 void Internals::applyRotationForOutgoingVideoSources(RTCPeerConnection&amp; connection)
1477 {
1478     connection.applyRotationForOutgoingVideoSources();
1479 }
<a name="32" id="anc32"></a>







1480 #endif
1481 
1482 #if ENABLE(MEDIA_STREAM)
<a name="33" id="anc33"></a>



1483 
1484 void Internals::setMockMediaCaptureDevicesEnabled(bool enabled)
1485 {
1486     Document* document = contextDocument();
1487     if (auto* page = document-&gt;page())
1488         page-&gt;settings().setMockCaptureDevicesEnabled(enabled);
1489 }
1490 
1491 void Internals::setMediaCaptureRequiresSecureConnection(bool enabled)
1492 {
1493     Document* document = contextDocument();
1494     if (auto* page = document-&gt;page())
1495         page-&gt;settings().setMediaCaptureRequiresSecureConnection(enabled);
1496 }
1497 
1498 static std::unique_ptr&lt;MediaRecorderPrivate&gt; createRecorderMockSource()
1499 {
1500     return std::unique_ptr&lt;MediaRecorderPrivateMock&gt;(new MediaRecorderPrivateMock);
1501 }
1502 
1503 void Internals::setCustomPrivateRecorderCreator()
1504 {
1505     WebCore::MediaRecorder::setCustomPrivateRecorderCreator(createRecorderMockSource);
1506 }
1507 
1508 #endif
1509 
1510 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::absoluteCaretBounds()
1511 {
1512     Document* document = contextDocument();
1513     if (!document || !document-&gt;frame())
1514         return Exception { InvalidAccessError };
1515 
1516     return DOMRect::create(document-&gt;frame()-&gt;selection().absoluteCaretBounds());
1517 }
1518 
1519 ExceptionOr&lt;bool&gt; Internals::isCaretBlinkingSuspended()
1520 {
1521     Document* document = contextDocument();
1522     if (!document || !document-&gt;frame())
1523         return Exception { InvalidAccessError };
1524 
1525     return document-&gt;frame()-&gt;selection().isCaretBlinkingSuspended();
1526 }
1527 
1528 Ref&lt;DOMRect&gt; Internals::boundingBox(Element&amp; element)
1529 {
1530     element.document().updateLayoutIgnorePendingStylesheets();
1531     auto renderer = element.renderer();
1532     if (!renderer)
1533         return DOMRect::create();
1534     return DOMRect::create(renderer-&gt;absoluteBoundingBoxRectIgnoringTransforms());
1535 }
1536 
1537 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::inspectorHighlightRects()
1538 {
1539     Document* document = contextDocument();
1540     if (!document || !document-&gt;page())
1541         return Exception { InvalidAccessError };
1542 
1543     Highlight highlight;
1544     document-&gt;page()-&gt;inspectorController().getHighlight(highlight, InspectorOverlay::CoordinateSystem::View);
1545     return DOMRectList::create(highlight.quads);
1546 }
1547 
<a name="34" id="anc34"></a><span class="line-removed">1548 ExceptionOr&lt;String&gt; Internals::inspectorHighlightObject()</span>
<span class="line-removed">1549 {</span>
<span class="line-removed">1550     Document* document = contextDocument();</span>
<span class="line-removed">1551     if (!document || !document-&gt;page())</span>
<span class="line-removed">1552         return Exception { InvalidAccessError };</span>
<span class="line-removed">1553 </span>
<span class="line-removed">1554     return document-&gt;page()-&gt;inspectorController().buildObjectForHighlightedNodes()-&gt;toJSONString();</span>
<span class="line-removed">1555 }</span>
<span class="line-removed">1556 </span>
1557 ExceptionOr&lt;unsigned&gt; Internals::markerCountForNode(Node&amp; node, const String&amp; markerType)
1558 {
1559     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1560     if (!markerTypesFrom(markerType, markerTypes))
1561         return Exception { SyntaxError };
1562 
1563     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1564     return node.document().markers().markersFor(node, markerTypes).size();
1565 }
1566 
1567 ExceptionOr&lt;RenderedDocumentMarker*&gt; Internals::markerAt(Node&amp; node, const String&amp; markerType, unsigned index)
1568 {
1569     node.document().updateLayoutIgnorePendingStylesheets();
1570 
1571     OptionSet&lt;DocumentMarker::MarkerType&gt; markerTypes;
1572     if (!markerTypesFrom(markerType, markerTypes))
1573         return Exception { SyntaxError };
1574 
1575     node.document().frame()-&gt;editor().updateEditorUINowIfScheduled();
1576 
1577     Vector&lt;RenderedDocumentMarker*&gt; markers = node.document().markers().markersFor(node, markerTypes);
1578     if (markers.size() &lt;= index)
1579         return nullptr;
1580     return markers[index];
1581 }
1582 
1583 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::markerRangeForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1584 {
1585     auto result = markerAt(node, markerType, index);
1586     if (result.hasException())
1587         return result.releaseException();
1588     auto marker = result.releaseReturnValue();
1589     if (!marker)
1590         return nullptr;
1591     return RefPtr&lt;Range&gt; { Range::create(node.document(), &amp;node, marker-&gt;startOffset(), &amp;node, marker-&gt;endOffset()) };
1592 }
1593 
1594 ExceptionOr&lt;String&gt; Internals::markerDescriptionForNode(Node&amp; node, const String&amp; markerType, unsigned index)
1595 {
1596     auto result = markerAt(node, markerType, index);
1597     if (result.hasException())
1598         return result.releaseException();
1599     auto marker = result.releaseReturnValue();
1600     if (!marker)
1601         return String();
1602     return String { marker-&gt;description() };
1603 }
1604 
1605 ExceptionOr&lt;String&gt; Internals::dumpMarkerRects(const String&amp; markerTypeString)
1606 {
1607     DocumentMarker::MarkerType markerType;
1608     if (!markerTypeFrom(markerTypeString, markerType))
1609         return Exception { SyntaxError };
1610 
1611     contextDocument()-&gt;markers().updateRectsForInvalidatedMarkersOfType(markerType);
1612     auto rects = contextDocument()-&gt;markers().renderedRectsForMarkers(markerType);
1613 
1614     StringBuilder rectString;
1615     rectString.appendLiteral(&quot;marker rects: &quot;);
1616     for (const auto&amp; rect : rects) {
1617         rectString.append(&#39;(&#39;);
<a name="35" id="anc35"></a><span class="line-modified">1618         rectString.appendNumber(rect.x());</span>
1619         rectString.appendLiteral(&quot;, &quot;);
<a name="36" id="anc36"></a><span class="line-modified">1620         rectString.appendNumber(rect.y());</span>
1621         rectString.appendLiteral(&quot;, &quot;);
<a name="37" id="anc37"></a><span class="line-modified">1622         rectString.appendNumber(rect.width());</span>
1623         rectString.appendLiteral(&quot;, &quot;);
<a name="38" id="anc38"></a><span class="line-modified">1624         rectString.appendNumber(rect.height());</span>
1625         rectString.appendLiteral(&quot;) &quot;);
1626     }
1627     return rectString.toString();
1628 }
1629 
1630 void Internals::addTextMatchMarker(const Range&amp; range, bool isActive)
1631 {
1632     range.ownerDocument().updateLayoutIgnorePendingStylesheets();
1633     range.ownerDocument().markers().addTextMatchMarker(range, isActive);
1634 }
1635 
1636 ExceptionOr&lt;void&gt; Internals::setMarkedTextMatchesAreHighlighted(bool flag)
1637 {
1638     Document* document = contextDocument();
1639     if (!document || !document-&gt;frame())
1640         return Exception { InvalidAccessError };
1641     document-&gt;frame()-&gt;editor().setMarkedTextMatchesAreHighlighted(flag);
1642     return { };
1643 }
1644 
1645 void Internals::invalidateFontCache()
1646 {
1647     FontCache::singleton().invalidate();
1648 }
1649 
1650 void Internals::setFontSmoothingEnabled(bool enabled)
1651 {
1652     FontCascade::setShouldUseSmoothing(enabled);
1653 }
1654 
1655 ExceptionOr&lt;void&gt; Internals::setLowPowerModeEnabled(bool isEnabled)
1656 {
1657     auto* document = contextDocument();
1658     if (!document)
1659         return Exception { InvalidAccessError };
1660     auto* page = document-&gt;page();
1661     if (!page)
1662         return Exception { InvalidAccessError };
1663 
1664     page-&gt;setLowPowerModeEnabledOverrideForTesting(isEnabled);
1665     return { };
1666 }
1667 
1668 ExceptionOr&lt;void&gt; Internals::setScrollViewPosition(int x, int y)
1669 {
1670     Document* document = contextDocument();
1671     if (!document || !document-&gt;view())
1672         return Exception { InvalidAccessError };
1673 
1674     auto&amp; frameView = *document-&gt;view();
1675     bool constrainsScrollingToContentEdgeOldValue = frameView.constrainsScrollingToContentEdge();
1676     bool scrollbarsSuppressedOldValue = frameView.scrollbarsSuppressed();
1677 
1678     frameView.setConstrainsScrollingToContentEdge(false);
1679     frameView.setScrollbarsSuppressed(false);
1680     frameView.setScrollOffsetFromInternals({ x, y });
1681     frameView.setScrollbarsSuppressed(scrollbarsSuppressedOldValue);
1682     frameView.setConstrainsScrollingToContentEdge(constrainsScrollingToContentEdgeOldValue);
1683 
1684     return { };
1685 }
1686 
1687 ExceptionOr&lt;void&gt; Internals::unconstrainedScrollTo(Element&amp; element, double x, double y)
1688 {
1689     Document* document = contextDocument();
1690     if (!document || !document-&gt;view())
1691         return Exception { InvalidAccessError };
1692 
1693     element.scrollTo({ x, y }, ScrollClamping::Unclamped);
1694     return { };
1695 }
1696 
1697 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::layoutViewportRect()
1698 {
1699     Document* document = contextDocument();
1700     if (!document || !document-&gt;frame())
1701         return Exception { InvalidAccessError };
1702 
1703     document-&gt;updateLayoutIgnorePendingStylesheets();
1704 
1705     auto&amp; frameView = *document-&gt;view();
1706     return DOMRect::create(frameView.layoutViewportRect());
1707 }
1708 
1709 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::visualViewportRect()
1710 {
1711     Document* document = contextDocument();
1712     if (!document || !document-&gt;frame())
1713         return Exception { InvalidAccessError };
1714 
1715     document-&gt;updateLayoutIgnorePendingStylesheets();
1716 
1717     auto&amp; frameView = *document-&gt;view();
1718     return DOMRect::create(frameView.visualViewportRect());
1719 }
1720 
1721 ExceptionOr&lt;void&gt; Internals::setViewIsTransparent(bool transparent)
1722 {
1723     Document* document = contextDocument();
1724     if (!document || !document-&gt;view())
1725         return Exception { InvalidAccessError };
1726     Optional&lt;Color&gt; backgroundColor;
1727     if (transparent)
1728         backgroundColor = Color(Color::transparent);
1729     document-&gt;view()-&gt;updateBackgroundRecursively(backgroundColor);
1730     return { };
1731 }
1732 
1733 ExceptionOr&lt;String&gt; Internals::viewBaseBackgroundColor()
1734 {
1735     Document* document = contextDocument();
1736     if (!document || !document-&gt;view())
1737         return Exception { InvalidAccessError };
1738     return document-&gt;view()-&gt;baseBackgroundColor().cssText();
1739 }
1740 
1741 ExceptionOr&lt;void&gt; Internals::setViewBaseBackgroundColor(const String&amp; colorValue)
1742 {
1743     Document* document = contextDocument();
1744     if (!document || !document-&gt;view())
1745         return Exception { InvalidAccessError };
1746 
1747     if (colorValue == &quot;transparent&quot;) {
1748         document-&gt;view()-&gt;setBaseBackgroundColor(Color::transparent);
1749         return { };
1750     }
1751     if (colorValue == &quot;white&quot;) {
1752         document-&gt;view()-&gt;setBaseBackgroundColor(Color::white);
1753         return { };
1754     }
1755     return Exception { SyntaxError };
1756 }
1757 
1758 ExceptionOr&lt;void&gt; Internals::setPagination(const String&amp; mode, int gap, int pageLength)
1759 {
1760     Document* document = contextDocument();
1761     if (!document || !document-&gt;page())
1762         return Exception { InvalidAccessError };
1763 
1764     Pagination pagination;
1765     if (mode == &quot;Unpaginated&quot;)
1766         pagination.mode = Pagination::Unpaginated;
1767     else if (mode == &quot;LeftToRightPaginated&quot;)
1768         pagination.mode = Pagination::LeftToRightPaginated;
1769     else if (mode == &quot;RightToLeftPaginated&quot;)
1770         pagination.mode = Pagination::RightToLeftPaginated;
1771     else if (mode == &quot;TopToBottomPaginated&quot;)
1772         pagination.mode = Pagination::TopToBottomPaginated;
1773     else if (mode == &quot;BottomToTopPaginated&quot;)
1774         pagination.mode = Pagination::BottomToTopPaginated;
1775     else
1776         return Exception { SyntaxError };
1777 
1778     pagination.gap = gap;
1779     pagination.pageLength = pageLength;
1780     document-&gt;page()-&gt;setPagination(pagination);
1781 
1782     return { };
1783 }
1784 
1785 ExceptionOr&lt;void&gt; Internals::setPaginationLineGridEnabled(bool enabled)
1786 {
1787     Document* document = contextDocument();
1788     if (!document || !document-&gt;page())
1789         return Exception { InvalidAccessError };
1790     document-&gt;page()-&gt;setPaginationLineGridEnabled(enabled);
1791     return { };
1792 }
1793 
1794 ExceptionOr&lt;String&gt; Internals::configurationForViewport(float devicePixelRatio, int deviceWidth, int deviceHeight, int availableWidth, int availableHeight)
1795 {
1796     Document* document = contextDocument();
1797     if (!document || !document-&gt;page())
1798         return Exception { InvalidAccessError };
1799 
1800     const int defaultLayoutWidthForNonMobilePages = 980;
1801 
1802     ViewportArguments arguments = document-&gt;page()-&gt;viewportArguments();
1803     ViewportAttributes attributes = computeViewportAttributes(arguments, defaultLayoutWidthForNonMobilePages, deviceWidth, deviceHeight, devicePixelRatio, IntSize(availableWidth, availableHeight));
1804     restrictMinimumScaleFactorToViewportSize(attributes, IntSize(availableWidth, availableHeight), devicePixelRatio);
1805     restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);
1806 
1807     return makeString(&quot;viewport size &quot;, FormattedNumber::fixedPrecision(attributes.layoutSize.width()), &#39;x&#39;, FormattedNumber::fixedPrecision(attributes.layoutSize.height()), &quot; scale &quot;, FormattedNumber::fixedPrecision(attributes.initialScale), &quot; with limits [&quot;, FormattedNumber::fixedPrecision(attributes.minimumScale), &quot;, &quot;, FormattedNumber::fixedPrecision(attributes.maximumScale), &quot;] and userScalable &quot;, (attributes.userScalable ? &quot;true&quot; : &quot;false&quot;));
1808 }
1809 
1810 ExceptionOr&lt;bool&gt; Internals::wasLastChangeUserEdit(Element&amp; textField)
1811 {
1812     if (is&lt;HTMLInputElement&gt;(textField))
1813         return downcast&lt;HTMLInputElement&gt;(textField).lastChangeWasUserEdit();
1814 
1815     if (is&lt;HTMLTextAreaElement&gt;(textField))
1816         return downcast&lt;HTMLTextAreaElement&gt;(textField).lastChangeWasUserEdit();
1817 
1818     return Exception { InvalidNodeTypeError };
1819 }
1820 
1821 bool Internals::elementShouldAutoComplete(HTMLInputElement&amp; element)
1822 {
1823     return element.shouldAutocomplete();
1824 }
1825 
1826 void Internals::setAutofilled(HTMLInputElement&amp; element, bool enabled)
1827 {
1828     element.setAutoFilled(enabled);
1829 }
1830 
<a name="39" id="anc39"></a>




1831 static AutoFillButtonType toAutoFillButtonType(Internals::AutoFillButtonType type)
1832 {
1833     switch (type) {
1834     case Internals::AutoFillButtonType::None:
1835         return AutoFillButtonType::None;
1836     case Internals::AutoFillButtonType::Credentials:
1837         return AutoFillButtonType::Credentials;
1838     case Internals::AutoFillButtonType::Contacts:
1839         return AutoFillButtonType::Contacts;
1840     case Internals::AutoFillButtonType::StrongPassword:
1841         return AutoFillButtonType::StrongPassword;
1842     case Internals::AutoFillButtonType::CreditCard:
1843         return AutoFillButtonType::CreditCard;
1844     }
1845     ASSERT_NOT_REACHED();
1846     return AutoFillButtonType::None;
1847 }
1848 
1849 static Internals::AutoFillButtonType toInternalsAutoFillButtonType(AutoFillButtonType type)
1850 {
1851     switch (type) {
1852     case AutoFillButtonType::None:
1853         return Internals::AutoFillButtonType::None;
1854     case AutoFillButtonType::Credentials:
1855         return Internals::AutoFillButtonType::Credentials;
1856     case AutoFillButtonType::Contacts:
1857         return Internals::AutoFillButtonType::Contacts;
1858     case AutoFillButtonType::StrongPassword:
1859         return Internals::AutoFillButtonType::StrongPassword;
1860     case AutoFillButtonType::CreditCard:
1861         return Internals::AutoFillButtonType::CreditCard;
1862     }
1863     ASSERT_NOT_REACHED();
1864     return Internals::AutoFillButtonType::None;
1865 }
1866 
1867 void Internals::setShowAutoFillButton(HTMLInputElement&amp; element, AutoFillButtonType type)
1868 {
1869     element.setShowAutoFillButton(toAutoFillButtonType(type));
1870 }
1871 
1872 auto Internals::autoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1873 {
1874     return toInternalsAutoFillButtonType(element.autoFillButtonType());
1875 }
1876 
1877 auto Internals::lastAutoFillButtonType(const HTMLInputElement&amp; element) -&gt; AutoFillButtonType
1878 {
1879     return toInternalsAutoFillButtonType(element.lastAutoFillButtonType());
1880 }
1881 
1882 ExceptionOr&lt;void&gt; Internals::scrollElementToRect(Element&amp; element, int x, int y, int w, int h)
1883 {
1884     FrameView* frameView = element.document().view();
1885     if (!frameView)
1886         return Exception { InvalidAccessError };
1887     frameView-&gt;scrollElementToRect(element, { x, y, w, h });
1888     return { };
1889 }
1890 
1891 ExceptionOr&lt;String&gt; Internals::autofillFieldName(Element&amp; element)
1892 {
1893     if (!is&lt;HTMLFormControlElement&gt;(element))
1894         return Exception { InvalidNodeTypeError };
1895 
1896     return String { downcast&lt;HTMLFormControlElement&gt;(element).autofillData().fieldName };
1897 }
1898 
1899 ExceptionOr&lt;void&gt; Internals::invalidateControlTints()
1900 {
1901     Document* document = contextDocument();
1902     if (!document || !document-&gt;view())
1903         return Exception { InvalidAccessError };
1904 
1905     document-&gt;view()-&gt;invalidateControlTints();
1906     return { };
1907 }
1908 
1909 RefPtr&lt;Range&gt; Internals::rangeFromLocationAndLength(Element&amp; scope, int rangeLocation, int rangeLength)
1910 {
1911     return TextIterator::rangeFromLocationAndLength(&amp;scope, rangeLocation, rangeLength);
1912 }
1913 
1914 unsigned Internals::locationFromRange(Element&amp; scope, const Range&amp; range)
1915 {
1916     size_t location = 0;
1917     size_t unusedLength = 0;
1918     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, location, unusedLength);
1919     return location;
1920 }
1921 
1922 unsigned Internals::lengthFromRange(Element&amp; scope, const Range&amp; range)
1923 {
1924     size_t unusedLocation = 0;
1925     size_t length = 0;
1926     TextIterator::getLocationAndLengthFromRange(&amp;scope, &amp;range, unusedLocation, length);
1927     return length;
1928 }
1929 
1930 String Internals::rangeAsText(const Range&amp; range)
1931 {
1932     return range.text();
1933 }
1934 
<a name="40" id="anc40"></a>




1935 Ref&lt;Range&gt; Internals::subrange(Range&amp; range, int rangeLocation, int rangeLength)
1936 {
1937     return TextIterator::subrange(range, rangeLocation, rangeLength);
1938 }
1939 
1940 RefPtr&lt;Range&gt; Internals::rangeOfStringNearLocation(const Range&amp; searchRange, const String&amp; text, unsigned targetOffset)
1941 {
1942     return findClosestPlainText(searchRange, text, { }, targetOffset);
1943 }
1944 
1945 #if !PLATFORM(MAC)
1946 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeForDictionaryLookupAtLocation(int, int)
1947 {
1948     return Exception { InvalidAccessError };
1949 }
1950 #endif
1951 
1952 ExceptionOr&lt;void&gt; Internals::setDelegatesScrolling(bool enabled)
1953 {
1954     Document* document = contextDocument();
1955     // Delegate scrolling is valid only on mainframe&#39;s view.
1956     if (!document || !document-&gt;view() || !document-&gt;page() || &amp;document-&gt;page()-&gt;mainFrame() != document-&gt;frame())
1957         return Exception { InvalidAccessError };
1958 
1959     document-&gt;view()-&gt;setDelegatesScrolling(enabled);
1960     return { };
1961 }
1962 
1963 ExceptionOr&lt;int&gt; Internals::lastSpellCheckRequestSequence()
1964 {
1965     Document* document = contextDocument();
1966     if (!document || !document-&gt;frame())
1967         return Exception { InvalidAccessError };
1968 
1969     return document-&gt;frame()-&gt;editor().spellChecker().lastRequestSequence();
1970 }
1971 
1972 ExceptionOr&lt;int&gt; Internals::lastSpellCheckProcessedSequence()
1973 {
1974     Document* document = contextDocument();
1975     if (!document || !document-&gt;frame())
1976         return Exception { InvalidAccessError };
1977 
1978     return document-&gt;frame()-&gt;editor().spellChecker().lastProcessedSequence();
1979 }
1980 
1981 Vector&lt;String&gt; Internals::userPreferredLanguages() const
1982 {
1983     return WTF::userPreferredLanguages();
1984 }
1985 
1986 void Internals::setUserPreferredLanguages(const Vector&lt;String&gt;&amp; languages)
1987 {
1988     overrideUserPreferredLanguages(languages);
1989 }
1990 
1991 Vector&lt;String&gt; Internals::userPreferredAudioCharacteristics() const
1992 {
1993     Document* document = contextDocument();
1994     if (!document || !document-&gt;page())
1995         return Vector&lt;String&gt;();
1996 #if ENABLE(VIDEO_TRACK)
1997     return document-&gt;page()-&gt;group().captionPreferences().preferredAudioCharacteristics();
1998 #else
1999     return Vector&lt;String&gt;();
2000 #endif
2001 }
2002 
2003 void Internals::setUserPreferredAudioCharacteristic(const String&amp; characteristic)
2004 {
2005     Document* document = contextDocument();
2006     if (!document || !document-&gt;page())
2007         return;
2008 #if ENABLE(VIDEO_TRACK)
2009     document-&gt;page()-&gt;group().captionPreferences().setPreferredAudioCharacteristic(characteristic);
2010 #else
2011     UNUSED_PARAM(characteristic);
2012 #endif
2013 }
2014 
2015 ExceptionOr&lt;unsigned&gt; Internals::wheelEventHandlerCount()
2016 {
2017     Document* document = contextDocument();
2018     if (!document)
2019         return Exception { InvalidAccessError };
2020 
2021     return document-&gt;wheelEventHandlerCount();
2022 }
2023 
2024 ExceptionOr&lt;unsigned&gt; Internals::touchEventHandlerCount()
2025 {
2026     Document* document = contextDocument();
2027     if (!document)
2028         return Exception { InvalidAccessError };
2029 
2030     return document-&gt;touchEventHandlerCount();
2031 }
2032 
2033 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::touchEventRectsForEvent(const String&amp; eventName)
2034 {
2035     Document* document = contextDocument();
2036     if (!document || !document-&gt;page())
2037         return Exception { InvalidAccessError };
2038 
2039     return document-&gt;page()-&gt;touchEventRectsForEvent(eventName);
2040 }
2041 
2042 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::passiveTouchEventListenerRects()
2043 {
2044     Document* document = contextDocument();
2045     if (!document || !document-&gt;page())
2046         return Exception { InvalidAccessError };
2047 
2048     return document-&gt;page()-&gt;passiveTouchEventListenerRects();
2049 }
2050 
2051 // FIXME: Remove the document argument. It is almost always the same as
2052 // contextDocument(), with the exception of a few tests that pass a
2053 // different document, and could just make the call through another Internals
2054 // instance instead.
2055 ExceptionOr&lt;RefPtr&lt;NodeList&gt;&gt; Internals::nodesFromRect(Document&amp; document, int centerX, int centerY, unsigned topPadding, unsigned rightPadding, unsigned bottomPadding, unsigned leftPadding, bool ignoreClipping, bool allowUserAgentShadowContent, bool allowChildFrameContent) const
2056 {
2057     if (!document.frame() || !document.frame()-&gt;view())
2058         return Exception { InvalidAccessError };
2059 
2060     Frame* frame = document.frame();
2061     FrameView* frameView = document.view();
2062     RenderView* renderView = document.renderView();
2063     if (!renderView)
2064         return nullptr;
2065 
2066     document.updateLayoutIgnorePendingStylesheets();
2067 
2068     float zoomFactor = frame-&gt;pageZoomFactor();
2069     LayoutPoint point(centerX * zoomFactor + frameView-&gt;scrollX(), centerY * zoomFactor + frameView-&gt;scrollY());
2070 
2071     HitTestRequest::HitTestRequestType hitType = HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::CollectMultipleElements;
2072     if (ignoreClipping)
2073         hitType |= HitTestRequest::IgnoreClipping;
2074     if (!allowUserAgentShadowContent)
2075         hitType |= HitTestRequest::DisallowUserAgentShadowContent;
2076     if (allowChildFrameContent)
2077         hitType |= HitTestRequest::AllowChildFrameContent;
2078 
2079     HitTestRequest request(hitType);
2080 
2081     // When ignoreClipping is false, this method returns null for coordinates outside of the viewport.
2082     if (!request.ignoreClipping() &amp;&amp; !frameView-&gt;visibleContentRect().intersects(HitTestLocation::rectForPoint(point, topPadding, rightPadding, bottomPadding, leftPadding)))
2083         return nullptr;
2084 
2085     HitTestResult result(point, topPadding, rightPadding, bottomPadding, leftPadding);
2086     document.hitTest(request, result);
2087     const HitTestResult::NodeSet&amp; nodeSet = result.listBasedTestResult();
2088     Vector&lt;Ref&lt;Node&gt;&gt; matches;
2089     matches.reserveInitialCapacity(nodeSet.size());
2090     for (auto&amp; node : nodeSet)
2091         matches.uncheckedAppend(*node);
2092 
2093     return RefPtr&lt;NodeList&gt; { StaticNodeList::create(WTFMove(matches)) };
2094 }
2095 
2096 class GetCallerCodeBlockFunctor {
2097 public:
2098     GetCallerCodeBlockFunctor()
2099         : m_iterations(0)
2100         , m_codeBlock(0)
2101     {
2102     }
2103 
2104     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
2105     {
2106         ++m_iterations;
2107         if (m_iterations &lt; 2)
2108             return StackVisitor::Continue;
2109 
2110         m_codeBlock = visitor-&gt;codeBlock();
2111         return StackVisitor::Done;
2112     }
2113 
2114     CodeBlock* codeBlock() const { return m_codeBlock; }
2115 
2116 private:
2117     mutable int m_iterations;
2118     mutable CodeBlock* m_codeBlock;
2119 };
2120 
2121 String Internals::parserMetaData(JSC::JSValue code)
2122 {
2123     JSC::VM&amp; vm = contextDocument()-&gt;vm();
2124     JSC::ExecState* exec = vm.topCallFrame;
2125     ScriptExecutable* executable;
2126 
2127     if (!code || code.isNull() || code.isUndefined()) {
2128         GetCallerCodeBlockFunctor iter;
2129         exec-&gt;iterate(iter);
2130         CodeBlock* codeBlock = iter.codeBlock();
2131         executable = codeBlock-&gt;ownerExecutable();
2132     } else if (code.isFunction(vm)) {
2133         JSFunction* funcObj = JSC::jsCast&lt;JSFunction*&gt;(code.toObject(exec));
2134         executable = funcObj-&gt;jsExecutable();
2135     } else
2136         return String();
2137 
2138     unsigned startLine = executable-&gt;firstLine();
2139     unsigned startColumn = executable-&gt;startColumn();
2140     unsigned endLine = executable-&gt;lastLine();
2141     unsigned endColumn = executable-&gt;endColumn();
2142 
2143     StringBuilder result;
2144 
2145     if (executable-&gt;isFunctionExecutable()) {
2146         FunctionExecutable* funcExecutable = reinterpret_cast&lt;FunctionExecutable*&gt;(executable);
<a name="41" id="anc41"></a><span class="line-modified">2147         String inferredName = funcExecutable-&gt;inferredName().string();</span>
2148         result.appendLiteral(&quot;function \&quot;&quot;);
2149         result.append(inferredName);
2150         result.append(&#39;&quot;&#39;);
2151     } else if (executable-&gt;isEvalExecutable())
2152         result.appendLiteral(&quot;eval&quot;);
2153     else if (executable-&gt;isModuleProgramExecutable())
2154         result.appendLiteral(&quot;module&quot;);
2155     else if (executable-&gt;isProgramExecutable())
2156         result.appendLiteral(&quot;program&quot;);
2157     else
2158         ASSERT_NOT_REACHED();
2159 
2160     result.appendLiteral(&quot; { &quot;);
2161     result.appendNumber(startLine);
2162     result.append(&#39;:&#39;);
2163     result.appendNumber(startColumn);
2164     result.appendLiteral(&quot; - &quot;);
2165     result.appendNumber(endLine);
2166     result.append(&#39;:&#39;);
2167     result.appendNumber(endColumn);
2168     result.appendLiteral(&quot; }&quot;);
2169 
2170     return result.toString();
2171 }
2172 
2173 void Internals::updateEditorUINowIfScheduled()
2174 {
2175     if (Document* document = contextDocument()) {
2176         if (Frame* frame = document-&gt;frame())
2177             frame-&gt;editor().updateEditorUINowIfScheduled();
2178     }
2179 }
2180 
2181 bool Internals::hasSpellingMarker(int from, int length)
2182 {
2183     Document* document = contextDocument();
2184     if (!document || !document-&gt;frame())
2185         return false;
2186 
2187     updateEditorUINowIfScheduled();
2188 
2189     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Spelling, from, length);
2190 }
2191 
2192 bool Internals::hasAutocorrectedMarker(int from, int length)
2193 {
2194     Document* document = contextDocument();
2195     if (!document || !document-&gt;frame())
2196         return false;
2197 
2198     updateEditorUINowIfScheduled();
2199 
2200     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Autocorrected, from, length);
2201 }
2202 
2203 void Internals::setContinuousSpellCheckingEnabled(bool enabled)
2204 {
2205     if (!contextDocument() || !contextDocument()-&gt;frame())
2206         return;
2207 
2208     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isContinuousSpellCheckingEnabled())
2209         contextDocument()-&gt;frame()-&gt;editor().toggleContinuousSpellChecking();
2210 }
2211 
2212 void Internals::setAutomaticQuoteSubstitutionEnabled(bool enabled)
2213 {
2214     if (!contextDocument() || !contextDocument()-&gt;frame())
2215         return;
2216 
2217 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2218     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticQuoteSubstitutionEnabled())
2219         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticQuoteSubstitution();
2220 #else
2221     UNUSED_PARAM(enabled);
2222 #endif
2223 }
2224 
2225 void Internals::setAutomaticLinkDetectionEnabled(bool enabled)
2226 {
2227     if (!contextDocument() || !contextDocument()-&gt;frame())
2228         return;
2229 
2230 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2231     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticLinkDetectionEnabled())
2232         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticLinkDetection();
2233 #else
2234     UNUSED_PARAM(enabled);
2235 #endif
2236 }
2237 
<a name="42" id="anc42"></a>






2238 void Internals::setAutomaticDashSubstitutionEnabled(bool enabled)
2239 {
2240     if (!contextDocument() || !contextDocument()-&gt;frame())
2241         return;
2242 
2243 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2244     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticDashSubstitutionEnabled())
2245         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticDashSubstitution();
2246 #else
2247     UNUSED_PARAM(enabled);
2248 #endif
2249 }
2250 
2251 void Internals::setAutomaticTextReplacementEnabled(bool enabled)
2252 {
2253     if (!contextDocument() || !contextDocument()-&gt;frame())
2254         return;
2255 
2256 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2257     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticTextReplacementEnabled())
2258         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticTextReplacement();
2259 #else
2260     UNUSED_PARAM(enabled);
2261 #endif
2262 }
2263 
2264 void Internals::setAutomaticSpellingCorrectionEnabled(bool enabled)
2265 {
2266     if (!contextDocument() || !contextDocument()-&gt;frame())
2267         return;
2268 
2269 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
2270     if (enabled != contextDocument()-&gt;frame()-&gt;editor().isAutomaticSpellingCorrectionEnabled())
2271         contextDocument()-&gt;frame()-&gt;editor().toggleAutomaticSpellingCorrection();
2272 #else
2273     UNUSED_PARAM(enabled);
2274 #endif
2275 }
2276 
2277 void Internals::handleAcceptedCandidate(const String&amp; candidate, unsigned location, unsigned length)
2278 {
2279     if (!contextDocument() || !contextDocument()-&gt;frame())
2280         return;
2281 
2282     TextCheckingResult result;
2283     result.type = TextCheckingType::None;
2284     result.location = location;
2285     result.length = length;
2286     result.replacement = candidate;
2287     contextDocument()-&gt;frame()-&gt;editor().handleAcceptedCandidate(result);
2288 }
2289 
2290 void Internals::changeSelectionListType()
2291 {
2292     if (auto frame = makeRefPtr(this-&gt;frame()))
2293         frame-&gt;editor().changeSelectionListType();
2294 }
2295 
2296 bool Internals::isOverwriteModeEnabled()
2297 {
2298     Document* document = contextDocument();
2299     if (!document || !document-&gt;frame())
2300         return false;
2301 
2302     return document-&gt;frame()-&gt;editor().isOverwriteModeEnabled();
2303 }
2304 
2305 void Internals::toggleOverwriteModeEnabled()
2306 {
2307     Document* document = contextDocument();
2308     if (!document || !document-&gt;frame())
2309         return;
2310 
2311     document-&gt;frame()-&gt;editor().toggleOverwriteModeEnabled();
2312 }
2313 
2314 static ExceptionOr&lt;FindOptions&gt; parseFindOptions(const Vector&lt;String&gt;&amp; optionList)
2315 {
2316     const struct {
2317         const char* name;
2318         FindOptionFlag value;
2319     } flagList[] = {
2320         {&quot;CaseInsensitive&quot;, CaseInsensitive},
2321         {&quot;AtWordStarts&quot;, AtWordStarts},
2322         {&quot;TreatMedialCapitalAsWordStart&quot;, TreatMedialCapitalAsWordStart},
2323         {&quot;Backwards&quot;, Backwards},
2324         {&quot;WrapAround&quot;, WrapAround},
2325         {&quot;StartInSelection&quot;, StartInSelection},
2326         {&quot;DoNotRevealSelection&quot;, DoNotRevealSelection},
2327         {&quot;AtWordEnds&quot;, AtWordEnds},
2328         {&quot;DoNotTraverseFlatTree&quot;, DoNotTraverseFlatTree},
2329     };
2330     FindOptions result;
2331     for (auto&amp; option : optionList) {
2332         bool found = false;
2333         for (auto&amp; flag : flagList) {
2334             if (flag.name == option) {
2335                 result.add(flag.value);
2336                 found = true;
2337                 break;
2338             }
2339         }
2340         if (!found)
2341             return Exception { SyntaxError };
2342     }
<a name="43" id="anc43"></a><span class="line-modified">2343     return WTFMove(result);</span>
2344 }
2345 
2346 ExceptionOr&lt;RefPtr&lt;Range&gt;&gt; Internals::rangeOfString(const String&amp; text, RefPtr&lt;Range&gt;&amp;&amp; referenceRange, const Vector&lt;String&gt;&amp; findOptions)
2347 {
2348     Document* document = contextDocument();
2349     if (!document || !document-&gt;frame())
2350         return Exception { InvalidAccessError };
2351 
2352     auto parsedOptions = parseFindOptions(findOptions);
2353     if (parsedOptions.hasException())
2354         return parsedOptions.releaseException();
2355 
2356     return document-&gt;frame()-&gt;editor().rangeOfString(text, referenceRange.get(), parsedOptions.releaseReturnValue());
2357 }
2358 
2359 ExceptionOr&lt;unsigned&gt; Internals::countMatchesForText(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions, const String&amp; markMatches)
2360 {
2361     Document* document = contextDocument();
2362     if (!document || !document-&gt;frame())
2363         return Exception { InvalidAccessError };
2364 
2365     auto parsedOptions = parseFindOptions(findOptions);
2366     if (parsedOptions.hasException())
2367         return parsedOptions.releaseException();
2368 
2369     bool mark = markMatches == &quot;mark&quot;;
2370     return document-&gt;frame()-&gt;editor().countMatchesForText(text, nullptr, parsedOptions.releaseReturnValue(), 1000, mark, nullptr);
2371 }
2372 
2373 ExceptionOr&lt;unsigned&gt; Internals::countFindMatches(const String&amp; text, const Vector&lt;String&gt;&amp; findOptions)
2374 {
2375     Document* document = contextDocument();
2376     if (!document || !document-&gt;page())
2377         return Exception { InvalidAccessError };
2378 
2379     auto parsedOptions = parseFindOptions(findOptions);
2380     if (parsedOptions.hasException())
2381         return parsedOptions.releaseException();
2382 
2383     return document-&gt;page()-&gt;countFindMatches(text, parsedOptions.releaseReturnValue(), 1000);
2384 }
2385 
<a name="44" id="anc44"></a>
2386 unsigned Internals::numberOfIDBTransactions() const
2387 {
<a name="45" id="anc45"></a><span class="line-removed">2388 #if ENABLE(INDEXED_DATABASE)</span>
2389     return IDBTransaction::numberOfIDBTransactions;
<a name="46" id="anc46"></a><span class="line-removed">2390 #else</span>
<span class="line-removed">2391     return 0;</span>
<span class="line-removed">2392 #endif</span>
2393 }
<a name="47" id="anc47"></a>
2394 
2395 unsigned Internals::numberOfLiveNodes() const
2396 {
2397     unsigned nodeCount = 0;
2398     for (auto* document : Document::allDocuments())
2399         nodeCount += document-&gt;referencingNodeCount();
2400     return nodeCount;
2401 }
2402 
2403 unsigned Internals::numberOfLiveDocuments() const
2404 {
2405     return Document::allDocuments().size();
2406 }
2407 
2408 unsigned Internals::referencingNodeCount(const Document&amp; document) const
2409 {
2410     return document.referencingNodeCount();
2411 }
2412 
2413 #if ENABLE(INTERSECTION_OBSERVER)
2414 unsigned Internals::numberOfIntersectionObservers(const Document&amp; document) const
2415 {
2416     return document.numberOfIntersectionObservers();
2417 }
2418 #endif
2419 
2420 uint64_t Internals::documentIdentifier(const Document&amp; document) const
2421 {
2422     return document.identifier().toUInt64();
2423 }
2424 
2425 bool Internals::isDocumentAlive(uint64_t documentIdentifier) const
2426 {
2427     return Document::allDocumentsMap().contains(makeObjectIdentifier&lt;DocumentIdentifierType&gt;(documentIdentifier));
2428 }
2429 
2430 bool Internals::isAnyWorkletGlobalScopeAlive() const
2431 {
2432 #if ENABLE(CSS_PAINTING_API)
2433     return !WorkletGlobalScope::allWorkletGlobalScopesSet().isEmpty();
2434 #else
2435     return false;
2436 #endif
2437 }
2438 
2439 String Internals::serviceWorkerClientIdentifier(const Document&amp; document) const
2440 {
2441 #if ENABLE(SERVICE_WORKER)
2442     return ServiceWorkerClientIdentifier { ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(document.sessionID()).serverConnectionIdentifier(), document.identifier() }.toString();
2443 #else
2444     UNUSED_PARAM(document);
2445     return String();
2446 #endif
2447 }
2448 
2449 RefPtr&lt;WindowProxy&gt; Internals::openDummyInspectorFrontend(const String&amp; url)
2450 {
2451     auto* inspectedPage = contextDocument()-&gt;frame()-&gt;page();
2452     auto* window = inspectedPage-&gt;mainFrame().document()-&gt;domWindow();
2453     auto frontendWindowProxy = window-&gt;open(*window, *window, url, &quot;&quot;, &quot;&quot;).releaseReturnValue();
<a name="48" id="anc48"></a><span class="line-modified">2454     m_inspectorFrontend = std::make_unique&lt;InspectorStubFrontend&gt;(*inspectedPage, downcast&lt;DOMWindow&gt;(frontendWindowProxy-&gt;window()));</span>
2455     return frontendWindowProxy;
2456 }
2457 
2458 void Internals::closeDummyInspectorFrontend()
2459 {
2460     m_inspectorFrontend = nullptr;
2461 }
2462 
2463 ExceptionOr&lt;void&gt; Internals::setInspectorIsUnderTest(bool isUnderTest)
2464 {
2465     Page* page = contextDocument()-&gt;frame()-&gt;page();
2466     if (!page)
2467         return Exception { InvalidAccessError };
2468 
2469     page-&gt;inspectorController().setIsUnderTest(isUnderTest);
2470     return { };
2471 }
2472 
2473 bool Internals::hasGrammarMarker(int from, int length)
2474 {
2475     Document* document = contextDocument();
2476     if (!document || !document-&gt;frame())
2477         return false;
2478 
2479     return document-&gt;frame()-&gt;editor().selectionStartHasMarkerFor(DocumentMarker::Grammar, from, length);
2480 }
2481 
2482 unsigned Internals::numberOfScrollableAreas()
2483 {
2484     Document* document = contextDocument();
2485     if (!document || !document-&gt;frame())
2486         return 0;
2487 
2488     unsigned count = 0;
2489     Frame* frame = document-&gt;frame();
2490     if (frame-&gt;view()-&gt;scrollableAreas())
2491         count += frame-&gt;view()-&gt;scrollableAreas()-&gt;size();
2492 
2493     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
2494         if (child-&gt;view() &amp;&amp; child-&gt;view()-&gt;scrollableAreas())
2495             count += child-&gt;view()-&gt;scrollableAreas()-&gt;size();
2496     }
2497 
2498     return count;
2499 }
2500 
2501 ExceptionOr&lt;bool&gt; Internals::isPageBoxVisible(int pageNumber)
2502 {
2503     Document* document = contextDocument();
2504     if (!document)
2505         return Exception { InvalidAccessError };
2506 
2507     return document-&gt;isPageBoxVisible(pageNumber);
2508 }
2509 
2510 static LayerTreeFlags toLayerTreeFlags(unsigned short flags)
2511 {
2512     LayerTreeFlags layerTreeFlags = 0;
2513     if (flags &amp; Internals::LAYER_TREE_INCLUDES_VISIBLE_RECTS)
2514         layerTreeFlags |= LayerTreeFlagsIncludeVisibleRects;
2515     if (flags &amp; Internals::LAYER_TREE_INCLUDES_TILE_CACHES)
2516         layerTreeFlags |= LayerTreeFlagsIncludeTileCaches;
2517     if (flags &amp; Internals::LAYER_TREE_INCLUDES_REPAINT_RECTS)
2518         layerTreeFlags |= LayerTreeFlagsIncludeRepaintRects;
2519     if (flags &amp; Internals::LAYER_TREE_INCLUDES_PAINTING_PHASES)
2520         layerTreeFlags |= LayerTreeFlagsIncludePaintingPhases;
2521     if (flags &amp; Internals::LAYER_TREE_INCLUDES_CONTENT_LAYERS)
2522         layerTreeFlags |= LayerTreeFlagsIncludeContentLayers;
2523     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ACCELERATES_DRAWING)
2524         layerTreeFlags |= LayerTreeFlagsIncludeAcceleratesDrawing;
<a name="49" id="anc49"></a>

2525     if (flags &amp; Internals::LAYER_TREE_INCLUDES_BACKING_STORE_ATTACHED)
2526         layerTreeFlags |= LayerTreeFlagsIncludeBackingStoreAttached;
2527     if (flags &amp; Internals::LAYER_TREE_INCLUDES_ROOT_LAYER_PROPERTIES)
2528         layerTreeFlags |= LayerTreeFlagsIncludeRootLayerProperties;
<a name="50" id="anc50"></a>

2529 
2530     return layerTreeFlags;
2531 }
2532 
2533 // FIXME: Remove the document argument. It is almost always the same as
2534 // contextDocument(), with the exception of a few tests that pass a
2535 // different document, and could just make the call through another Internals
2536 // instance instead.
2537 ExceptionOr&lt;String&gt; Internals::layerTreeAsText(Document&amp; document, unsigned short flags) const
2538 {
2539     if (!document.frame())
2540         return Exception { InvalidAccessError };
2541 
2542     document.updateLayoutIgnorePendingStylesheets();
2543     return document.frame()-&gt;layerTreeAsText(toLayerTreeFlags(flags));
2544 }
2545 
2546 ExceptionOr&lt;uint64_t&gt; Internals::layerIDForElement(Element&amp; element)
2547 {
2548     Document* document = contextDocument();
2549     if (!document || !document-&gt;frame())
2550         return Exception { InvalidAccessError };
2551 
2552     element.document().updateLayoutIgnorePendingStylesheets();
2553 
2554     if (!element.renderer() || !element.renderer()-&gt;hasLayer())
2555         return Exception { NotFoundError };
2556 
2557     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*element.renderer());
2558     if (!layerModelObject.layer()-&gt;isComposited())
2559         return Exception { NotFoundError };
2560 
2561     auto* backing = layerModelObject.layer()-&gt;backing();
2562     return backing-&gt;graphicsLayer()-&gt;primaryLayerID();
2563 }
2564 
2565 ExceptionOr&lt;String&gt; Internals::repaintRectsAsText() const
2566 {
2567     Document* document = contextDocument();
2568     if (!document || !document-&gt;frame())
2569         return Exception { InvalidAccessError };
2570 
2571     return document-&gt;frame()-&gt;trackedRepaintRectsAsText();
2572 }
2573 
2574 ExceptionOr&lt;String&gt; Internals::scrollbarOverlayStyle(Node* node) const
2575 {
2576     if (!node)
2577         node = contextDocument();
2578 
2579     if (!node)
2580         return Exception { InvalidAccessError };
2581 
2582     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2583 
2584     ScrollableArea* scrollableArea = nullptr;
2585     if (is&lt;Document&gt;(*node)) {
2586         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2587         if (!frameView)
2588             return Exception { InvalidAccessError };
2589 
2590         scrollableArea = frameView;
2591     } else if (is&lt;Element&gt;(*node)) {
2592         auto&amp; element = *downcast&lt;Element&gt;(node);
2593         if (!element.renderBox())
2594             return Exception { InvalidAccessError };
2595 
2596         scrollableArea = element.renderBox()-&gt;layer();
2597     } else
2598         return Exception { InvalidNodeTypeError };
2599 
2600     if (!scrollableArea)
2601         return Exception { InvalidNodeTypeError };
2602 
2603     switch (scrollableArea-&gt;scrollbarOverlayStyle()) {
2604     case ScrollbarOverlayStyleDefault:
2605         return &quot;default&quot;_str;
2606     case ScrollbarOverlayStyleDark:
2607         return &quot;dark&quot;_str;
2608     case ScrollbarOverlayStyleLight:
2609         return &quot;light&quot;_str;
2610     }
2611 
2612     ASSERT_NOT_REACHED();
2613     return &quot;unknown&quot;_str;
2614 }
2615 
2616 ExceptionOr&lt;bool&gt; Internals::scrollbarUsingDarkAppearance(Node* node) const
2617 {
2618     if (!node)
2619         node = contextDocument();
2620 
2621     if (!node)
2622         return Exception { InvalidAccessError };
2623 
2624     node-&gt;document().updateLayoutIgnorePendingStylesheets();
2625 
2626     ScrollableArea* scrollableArea = nullptr;
2627     if (is&lt;Document&gt;(*node)) {
2628         auto* frameView = downcast&lt;Document&gt;(node)-&gt;view();
2629         if (!frameView)
2630             return Exception { InvalidAccessError };
2631 
2632         scrollableArea = frameView;
2633     } else if (is&lt;Element&gt;(*node)) {
2634         auto&amp; element = *downcast&lt;Element&gt;(node);
2635         if (!element.renderBox())
2636             return Exception { InvalidAccessError };
2637 
2638         scrollableArea = element.renderBox()-&gt;layer();
2639     } else
2640         return Exception { InvalidNodeTypeError };
2641 
2642     if (!scrollableArea)
2643         return Exception { InvalidNodeTypeError };
2644 
2645     return scrollableArea-&gt;useDarkAppearance();
2646 }
2647 
2648 ExceptionOr&lt;String&gt; Internals::scrollingStateTreeAsText() const
2649 {
2650     Document* document = contextDocument();
2651     if (!document || !document-&gt;frame())
2652         return Exception { InvalidAccessError };
2653 
2654     document-&gt;updateLayoutIgnorePendingStylesheets();
2655 
2656     Page* page = document-&gt;page();
2657     if (!page)
2658         return String();
2659 
2660     return page-&gt;scrollingStateTreeAsText();
2661 }
2662 
2663 ExceptionOr&lt;String&gt; Internals::mainThreadScrollingReasons() const
2664 {
2665     Document* document = contextDocument();
2666     if (!document || !document-&gt;frame())
2667         return Exception { InvalidAccessError };
2668 
2669     Page* page = document-&gt;page();
2670     if (!page)
2671         return String();
2672 
2673     return page-&gt;synchronousScrollingReasonsAsText();
2674 }
2675 
2676 ExceptionOr&lt;Ref&lt;DOMRectList&gt;&gt; Internals::nonFastScrollableRects() const
2677 {
2678     Document* document = contextDocument();
2679     if (!document || !document-&gt;frame())
2680         return Exception { InvalidAccessError };
2681 
2682     Page* page = document-&gt;page();
2683     if (!page)
2684         return DOMRectList::create();
2685 
2686     return page-&gt;nonFastScrollableRects();
2687 }
2688 
2689 ExceptionOr&lt;void&gt; Internals::setElementUsesDisplayListDrawing(Element&amp; element, bool usesDisplayListDrawing)
2690 {
2691     Document* document = contextDocument();
2692     if (!document || !document-&gt;renderView())
2693         return Exception { InvalidAccessError };
2694 
2695     element.document().updateLayoutIgnorePendingStylesheets();
2696 
2697     if (!element.renderer())
2698         return Exception { InvalidAccessError };
2699 
2700     if (is&lt;HTMLCanvasElement&gt;(element)) {
2701         downcast&lt;HTMLCanvasElement&gt;(element).setUsesDisplayListDrawing(usesDisplayListDrawing);
2702         return { };
2703     }
2704 
2705     if (!element.renderer()-&gt;hasLayer())
2706         return Exception { InvalidAccessError };
2707 
2708     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2709     if (!layer-&gt;isComposited())
2710         return Exception { InvalidAccessError };
2711 
2712     layer-&gt;backing()-&gt;setUsesDisplayListDrawing(usesDisplayListDrawing);
2713     return { };
2714 }
2715 
2716 ExceptionOr&lt;void&gt; Internals::setElementTracksDisplayListReplay(Element&amp; element, bool isTrackingReplay)
2717 {
2718     Document* document = contextDocument();
2719     if (!document || !document-&gt;renderView())
2720         return Exception { InvalidAccessError };
2721 
2722     element.document().updateLayoutIgnorePendingStylesheets();
2723 
2724     if (!element.renderer())
2725         return Exception { InvalidAccessError };
2726 
2727     if (is&lt;HTMLCanvasElement&gt;(element)) {
2728         downcast&lt;HTMLCanvasElement&gt;(element).setTracksDisplayListReplay(isTrackingReplay);
2729         return { };
2730     }
2731 
2732     if (!element.renderer()-&gt;hasLayer())
2733         return Exception { InvalidAccessError };
2734 
2735     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2736     if (!layer-&gt;isComposited())
2737         return Exception { InvalidAccessError };
2738 
2739     layer-&gt;backing()-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
2740     return { };
2741 }
2742 
2743 ExceptionOr&lt;String&gt; Internals::displayListForElement(Element&amp; element, unsigned short flags)
2744 {
2745     Document* document = contextDocument();
2746     if (!document || !document-&gt;renderView())
2747         return Exception { InvalidAccessError };
2748 
2749     element.document().updateLayoutIgnorePendingStylesheets();
2750 
2751     if (!element.renderer())
2752         return Exception { InvalidAccessError };
2753 
2754     DisplayList::AsTextFlags displayListFlags = 0;
2755     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2756         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2757 
2758     if (is&lt;HTMLCanvasElement&gt;(element))
2759         return downcast&lt;HTMLCanvasElement&gt;(element).displayListAsText(displayListFlags);
2760 
2761     if (!element.renderer()-&gt;hasLayer())
2762         return Exception { InvalidAccessError };
2763 
2764     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2765     if (!layer-&gt;isComposited())
2766         return Exception { InvalidAccessError };
2767 
2768     return layer-&gt;backing()-&gt;displayListAsText(displayListFlags);
2769 }
2770 
2771 ExceptionOr&lt;String&gt; Internals::replayDisplayListForElement(Element&amp; element, unsigned short flags)
2772 {
2773     Document* document = contextDocument();
2774     if (!document || !document-&gt;renderView())
2775         return Exception { InvalidAccessError };
2776 
2777     element.document().updateLayoutIgnorePendingStylesheets();
2778 
2779     if (!element.renderer())
2780         return Exception { InvalidAccessError };
2781 
2782     DisplayList::AsTextFlags displayListFlags = 0;
2783     if (flags &amp; DISPLAY_LIST_INCLUDES_PLATFORM_OPERATIONS)
2784         displayListFlags |= DisplayList::AsTextFlag::IncludesPlatformOperations;
2785 
2786     if (is&lt;HTMLCanvasElement&gt;(element))
2787         return downcast&lt;HTMLCanvasElement&gt;(element).replayDisplayListAsText(displayListFlags);
2788 
2789     if (!element.renderer()-&gt;hasLayer())
2790         return Exception { InvalidAccessError };
2791 
2792     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(element.renderer())-&gt;layer();
2793     if (!layer-&gt;isComposited())
2794         return Exception { InvalidAccessError };
2795 
2796     return layer-&gt;backing()-&gt;replayDisplayListAsText(displayListFlags);
2797 }
2798 
2799 ExceptionOr&lt;void&gt; Internals::garbageCollectDocumentResources() const
2800 {
2801     Document* document = contextDocument();
2802     if (!document)
2803         return Exception { InvalidAccessError };
2804     document-&gt;cachedResourceLoader().garbageCollectDocumentResources();
2805     return { };
2806 }
2807 
2808 bool Internals::isUnderMemoryPressure()
2809 {
2810     return MemoryPressureHandler::singleton().isUnderMemoryPressure();
2811 }
2812 
2813 void Internals::beginSimulatedMemoryPressure()
2814 {
2815     MemoryPressureHandler::singleton().beginSimulatedMemoryPressure();
2816 }
2817 
2818 void Internals::endSimulatedMemoryPressure()
2819 {
2820     MemoryPressureHandler::singleton().endSimulatedMemoryPressure();
2821 }
2822 
2823 ExceptionOr&lt;void&gt; Internals::insertAuthorCSS(const String&amp; css) const
2824 {
2825     Document* document = contextDocument();
2826     if (!document)
2827         return Exception { InvalidAccessError };
2828 
2829     auto parsedSheet = StyleSheetContents::create(*document);
2830     parsedSheet.get().setIsUserStyleSheet(false);
2831     parsedSheet.get().parseString(css);
2832     document-&gt;extensionStyleSheets().addAuthorStyleSheetForTesting(WTFMove(parsedSheet));
2833     return { };
2834 }
2835 
2836 ExceptionOr&lt;void&gt; Internals::insertUserCSS(const String&amp; css) const
2837 {
2838     Document* document = contextDocument();
2839     if (!document)
2840         return Exception { InvalidAccessError };
2841 
2842     auto parsedSheet = StyleSheetContents::create(*document);
2843     parsedSheet.get().setIsUserStyleSheet(true);
2844     parsedSheet.get().parseString(css);
2845     document-&gt;extensionStyleSheets().addUserStyleSheet(WTFMove(parsedSheet));
2846     return { };
2847 }
2848 
2849 String Internals::counterValue(Element&amp; element)
2850 {
2851     return counterValueForElement(&amp;element);
2852 }
2853 
2854 int Internals::pageNumber(Element&amp; element, float pageWidth, float pageHeight)
2855 {
2856     return PrintContext::pageNumberForElement(&amp;element, { pageWidth, pageHeight });
2857 }
2858 
2859 Vector&lt;String&gt; Internals::shortcutIconURLs() const
2860 {
2861     if (!frame())
2862         return { };
2863 
2864     auto* documentLoader = frame()-&gt;loader().documentLoader();
2865     if (!documentLoader)
2866         return { };
2867 
2868     Vector&lt;String&gt; result;
2869     for (auto&amp; linkIcon : documentLoader-&gt;linkIcons())
2870         result.append(linkIcon.url.string());
2871 
2872     return result;
2873 }
2874 
2875 int Internals::numberOfPages(float pageWidth, float pageHeight)
2876 {
2877     if (!frame())
2878         return -1;
2879 
2880     return PrintContext::numberOfPages(*frame(), FloatSize(pageWidth, pageHeight));
2881 }
2882 
2883 ExceptionOr&lt;String&gt; Internals::pageProperty(const String&amp; propertyName, int pageNumber) const
2884 {
2885     if (!frame())
2886         return Exception { InvalidAccessError };
2887 
2888     return PrintContext::pageProperty(frame(), propertyName.utf8().data(), pageNumber);
2889 }
2890 
2891 ExceptionOr&lt;String&gt; Internals::pageSizeAndMarginsInPixels(int pageNumber, int width, int height, int marginTop, int marginRight, int marginBottom, int marginLeft) const
2892 {
2893     if (!frame())
2894         return Exception { InvalidAccessError };
2895 
2896     return PrintContext::pageSizeAndMarginsInPixels(frame(), pageNumber, width, height, marginTop, marginRight, marginBottom, marginLeft);
2897 }
2898 
2899 ExceptionOr&lt;float&gt; Internals::pageScaleFactor() const
2900 {
2901     Document* document = contextDocument();
2902     if (!document || !document-&gt;page())
2903         return Exception { InvalidAccessError };
2904 
2905     return document-&gt;page()-&gt;pageScaleFactor();
2906 }
2907 
2908 ExceptionOr&lt;void&gt; Internals::setPageScaleFactor(float scaleFactor, int x, int y)
2909 {
2910     Document* document = contextDocument();
2911     if (!document || !document-&gt;page())
2912         return Exception { InvalidAccessError };
2913 
2914     document-&gt;page()-&gt;setPageScaleFactor(scaleFactor, IntPoint(x, y));
2915     return { };
2916 }
2917 
2918 ExceptionOr&lt;void&gt; Internals::setPageZoomFactor(float zoomFactor)
2919 {
2920     Document* document = contextDocument();
2921     if (!document || !document-&gt;frame())
2922         return Exception { InvalidAccessError };
2923 
2924     document-&gt;frame()-&gt;setPageZoomFactor(zoomFactor);
2925     return { };
2926 }
2927 
2928 ExceptionOr&lt;void&gt; Internals::setTextZoomFactor(float zoomFactor)
2929 {
2930     Document* document = contextDocument();
2931     if (!document || !document-&gt;frame())
2932         return Exception { InvalidAccessError };
2933 
2934     document-&gt;frame()-&gt;setTextZoomFactor(zoomFactor);
2935     return { };
2936 }
2937 
2938 ExceptionOr&lt;void&gt; Internals::setUseFixedLayout(bool useFixedLayout)
2939 {
2940     Document* document = contextDocument();
2941     if (!document || !document-&gt;view())
2942         return Exception { InvalidAccessError };
2943 
2944     document-&gt;view()-&gt;setUseFixedLayout(useFixedLayout);
2945     return { };
2946 }
2947 
2948 ExceptionOr&lt;void&gt; Internals::setFixedLayoutSize(int width, int height)
2949 {
2950     Document* document = contextDocument();
2951     if (!document || !document-&gt;view())
2952         return Exception { InvalidAccessError };
2953 
2954     document-&gt;view()-&gt;setFixedLayoutSize(IntSize(width, height));
2955     return { };
2956 }
2957 
2958 ExceptionOr&lt;void&gt; Internals::setViewExposedRect(float x, float y, float width, float height)
2959 {
2960     Document* document = contextDocument();
2961     if (!document || !document-&gt;view())
2962         return Exception { InvalidAccessError };
2963 
2964     document-&gt;view()-&gt;setViewExposedRect(FloatRect(x, y, width, height));
2965     return { };
2966 }
2967 
2968 void Internals::setPrinting(int width, int height)
2969 {
<a name="51" id="anc51"></a><span class="line-modified">2970     printContextForTesting() = std::make_unique&lt;PrintContext&gt;(frame());</span>
2971     printContextForTesting()-&gt;begin(width, height);
2972 }
2973 
2974 void Internals::setHeaderHeight(float height)
2975 {
2976     Document* document = contextDocument();
2977     if (!document || !document-&gt;view())
2978         return;
2979 
2980     document-&gt;page()-&gt;setHeaderHeight(height);
2981 }
2982 
2983 void Internals::setFooterHeight(float height)
2984 {
2985     Document* document = contextDocument();
2986     if (!document || !document-&gt;view())
2987         return;
2988 
2989     document-&gt;page()-&gt;setFooterHeight(height);
2990 }
2991 
2992 void Internals::setTopContentInset(float contentInset)
2993 {
2994     Document* document = contextDocument();
2995     if (!document || !document-&gt;page())
2996         return;
2997 
2998     document-&gt;page()-&gt;setTopContentInset(contentInset);
2999 }
3000 
3001 #if ENABLE(FULLSCREEN_API)
3002 
3003 void Internals::webkitWillEnterFullScreenForElement(Element&amp; element)
3004 {
3005     Document* document = contextDocument();
3006     if (!document)
3007         return;
<a name="52" id="anc52"></a><span class="line-modified">3008     document-&gt;webkitWillEnterFullScreen(element);</span>
3009 }
3010 
3011 void Internals::webkitDidEnterFullScreenForElement(Element&amp;)
3012 {
3013     Document* document = contextDocument();
3014     if (!document)
3015         return;
<a name="53" id="anc53"></a><span class="line-modified">3016     document-&gt;webkitDidEnterFullScreen();</span>
3017 }
3018 
3019 void Internals::webkitWillExitFullScreenForElement(Element&amp;)
3020 {
3021     Document* document = contextDocument();
3022     if (!document)
3023         return;
<a name="54" id="anc54"></a><span class="line-modified">3024     document-&gt;webkitWillExitFullScreen();</span>
3025 }
3026 
3027 void Internals::webkitDidExitFullScreenForElement(Element&amp;)
3028 {
3029     Document* document = contextDocument();
3030     if (!document)
3031         return;
<a name="55" id="anc55"></a><span class="line-modified">3032     document-&gt;webkitDidExitFullScreen();</span>
3033 }
3034 
3035 bool Internals::isAnimatingFullScreen() const
3036 {
3037     Document* document = contextDocument();
3038     if (!document)
3039         return false;
<a name="56" id="anc56"></a><span class="line-modified">3040     return document-&gt;isAnimatingFullScreen();</span>
3041 }
3042 
3043 #endif
3044 
3045 void Internals::setFullscreenInsets(FullscreenInsets insets)
3046 {
3047     Page* page = contextDocument()-&gt;frame()-&gt;page();
3048     ASSERT(page);
3049 
3050     page-&gt;setFullscreenInsets(FloatBoxExtent(insets.top, insets.right, insets.bottom, insets.left));
3051 }
3052 
3053 void Internals::setFullscreenAutoHideDuration(double duration)
3054 {
3055     Page* page = contextDocument()-&gt;frame()-&gt;page();
3056     ASSERT(page);
3057 
3058     page-&gt;setFullscreenAutoHideDuration(Seconds(duration));
3059 }
3060 
3061 void Internals::setFullscreenControlsHidden(bool hidden)
3062 {
3063     Page* page = contextDocument()-&gt;frame()-&gt;page();
3064     ASSERT(page);
3065 
3066     page-&gt;setFullscreenControlsHidden(hidden);
3067 }
3068 
3069 void Internals::setApplicationCacheOriginQuota(unsigned long long quota)
3070 {
3071     Document* document = contextDocument();
3072     if (!document || !document-&gt;page())
3073         return;
3074     document-&gt;page()-&gt;applicationCacheStorage().storeUpdatedQuotaForOrigin(&amp;document-&gt;securityOrigin(), quota);
3075 }
3076 
3077 void Internals::registerURLSchemeAsBypassingContentSecurityPolicy(const String&amp; scheme)
3078 {
3079     SchemeRegistry::registerURLSchemeAsBypassingContentSecurityPolicy(scheme);
3080 }
3081 
3082 void Internals::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(const String&amp; scheme)
3083 {
3084     SchemeRegistry::removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(scheme);
3085 }
3086 
3087 void Internals::registerDefaultPortForProtocol(unsigned short port, const String&amp; protocol)
3088 {
3089     registerDefaultPortForProtocolForTesting(port, protocol);
3090 }
3091 
3092 Ref&lt;MallocStatistics&gt; Internals::mallocStatistics() const
3093 {
3094     return MallocStatistics::create();
3095 }
3096 
3097 Ref&lt;TypeConversions&gt; Internals::typeConversions() const
3098 {
3099     return TypeConversions::create();
3100 }
3101 
3102 Ref&lt;MemoryInfo&gt; Internals::memoryInfo() const
3103 {
3104     return MemoryInfo::create();
3105 }
3106 
3107 Vector&lt;String&gt; Internals::getReferencedFilePaths() const
3108 {
3109     frame()-&gt;loader().history().saveDocumentAndScrollState();
3110     return FormController::referencedFilePaths(frame()-&gt;loader().history().currentItem()-&gt;documentState());
3111 }
3112 
3113 ExceptionOr&lt;void&gt; Internals::startTrackingRepaints()
3114 {
3115     Document* document = contextDocument();
3116     if (!document || !document-&gt;view())
3117         return Exception { InvalidAccessError };
3118 
3119     document-&gt;view()-&gt;setTracksRepaints(true);
3120     return { };
3121 }
3122 
3123 ExceptionOr&lt;void&gt; Internals::stopTrackingRepaints()
3124 {
3125     Document* document = contextDocument();
3126     if (!document || !document-&gt;view())
3127         return Exception { InvalidAccessError };
3128 
3129     document-&gt;view()-&gt;setTracksRepaints(false);
3130     return { };
3131 }
3132 
3133 ExceptionOr&lt;void&gt; Internals::startTrackingLayerFlushes()
3134 {
3135     Document* document = contextDocument();
3136     if (!document || !document-&gt;renderView())
3137         return Exception { InvalidAccessError };
3138 
3139     document-&gt;renderView()-&gt;compositor().startTrackingLayerFlushes();
3140     return { };
3141 }
3142 
3143 ExceptionOr&lt;unsigned&gt; Internals::layerFlushCount()
3144 {
3145     Document* document = contextDocument();
3146     if (!document || !document-&gt;renderView())
3147         return Exception { InvalidAccessError };
3148 
3149     return document-&gt;renderView()-&gt;compositor().layerFlushCount();
3150 }
3151 
3152 ExceptionOr&lt;void&gt; Internals::startTrackingStyleRecalcs()
3153 {
3154     Document* document = contextDocument();
3155     if (!document)
3156         return Exception { InvalidAccessError };
3157 
3158     document-&gt;startTrackingStyleRecalcs();
3159     return { };
3160 }
3161 
3162 ExceptionOr&lt;unsigned&gt; Internals::styleRecalcCount()
3163 {
3164     Document* document = contextDocument();
3165     if (!document)
3166         return Exception { InvalidAccessError };
3167 
3168     return document-&gt;styleRecalcCount();
3169 }
3170 
3171 unsigned Internals::lastStyleUpdateSize() const
3172 {
3173     Document* document = contextDocument();
3174     if (!document)
3175         return 0;
3176     return document-&gt;lastStyleUpdateSizeForTesting();
3177 }
3178 
3179 ExceptionOr&lt;void&gt; Internals::startTrackingCompositingUpdates()
3180 {
3181     Document* document = contextDocument();
3182     if (!document || !document-&gt;renderView())
3183         return Exception { InvalidAccessError };
3184 
3185     document-&gt;renderView()-&gt;compositor().startTrackingCompositingUpdates();
3186     return { };
3187 }
3188 
3189 ExceptionOr&lt;unsigned&gt; Internals::compositingUpdateCount()
3190 {
3191     Document* document = contextDocument();
3192     if (!document || !document-&gt;renderView())
3193         return Exception { InvalidAccessError };
3194 
3195     return document-&gt;renderView()-&gt;compositor().compositingUpdateCount();
3196 }
3197 
3198 ExceptionOr&lt;void&gt; Internals::setCompositingPolicyOverride(Optional&lt;CompositingPolicy&gt; policyOverride)
3199 {
3200     Document* document = contextDocument();
3201     if (!document)
3202         return Exception { InvalidAccessError };
3203 
3204     if (!policyOverride) {
3205         document-&gt;page()-&gt;setCompositingPolicyOverride(WTF::nullopt);
3206         return { };
3207     }
3208 
3209     switch (policyOverride.value()) {
3210     case Internals::CompositingPolicy::Normal:
3211         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Normal);
3212         break;
3213     case Internals::CompositingPolicy::Conservative:
3214         document-&gt;page()-&gt;setCompositingPolicyOverride(WebCore::CompositingPolicy::Conservative);
3215         break;
3216     }
3217 
3218     return { };
3219 }
3220 
3221 ExceptionOr&lt;Optional&lt;Internals::CompositingPolicy&gt;&gt; Internals::compositingPolicyOverride() const
3222 {
3223     Document* document = contextDocument();
3224     if (!document)
3225         return Exception { InvalidAccessError };
3226 
3227     auto policyOverride = document-&gt;page()-&gt;compositingPolicyOverride();
3228     if (!policyOverride)
3229         return { WTF::nullopt };
3230 
3231     switch (policyOverride.value()) {
3232     case WebCore::CompositingPolicy::Normal:
3233         return { Internals::CompositingPolicy::Normal };
3234     case WebCore::CompositingPolicy::Conservative:
3235         return { Internals::CompositingPolicy::Conservative };
3236     }
3237 
3238     return { Internals::CompositingPolicy::Normal };
3239 }
3240 
3241 ExceptionOr&lt;void&gt; Internals::updateLayoutIgnorePendingStylesheetsAndRunPostLayoutTasks(Node* node)
3242 {
3243     Document* document;
3244     if (!node)
3245         document = contextDocument();
3246     else if (is&lt;Document&gt;(*node))
3247         document = downcast&lt;Document&gt;(node);
3248     else if (is&lt;HTMLIFrameElement&gt;(*node))
3249         document = downcast&lt;HTMLIFrameElement&gt;(*node).contentDocument();
3250     else
3251         return Exception { TypeError };
3252 
3253     document-&gt;updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
3254     return { };
3255 }
3256 
3257 unsigned Internals::layoutCount() const
3258 {
3259     Document* document = contextDocument();
3260     if (!document || !document-&gt;view())
3261         return 0;
3262     return document-&gt;view()-&gt;layoutContext().layoutCount();
3263 }
3264 
3265 #if !PLATFORM(IOS_FAMILY)
3266 static const char* cursorTypeToString(Cursor::Type cursorType)
3267 {
3268     switch (cursorType) {
3269     case Cursor::Pointer: return &quot;Pointer&quot;;
3270     case Cursor::Cross: return &quot;Cross&quot;;
3271     case Cursor::Hand: return &quot;Hand&quot;;
3272     case Cursor::IBeam: return &quot;IBeam&quot;;
3273     case Cursor::Wait: return &quot;Wait&quot;;
3274     case Cursor::Help: return &quot;Help&quot;;
3275     case Cursor::EastResize: return &quot;EastResize&quot;;
3276     case Cursor::NorthResize: return &quot;NorthResize&quot;;
3277     case Cursor::NorthEastResize: return &quot;NorthEastResize&quot;;
3278     case Cursor::NorthWestResize: return &quot;NorthWestResize&quot;;
3279     case Cursor::SouthResize: return &quot;SouthResize&quot;;
3280     case Cursor::SouthEastResize: return &quot;SouthEastResize&quot;;
3281     case Cursor::SouthWestResize: return &quot;SouthWestResize&quot;;
3282     case Cursor::WestResize: return &quot;WestResize&quot;;
3283     case Cursor::NorthSouthResize: return &quot;NorthSouthResize&quot;;
3284     case Cursor::EastWestResize: return &quot;EastWestResize&quot;;
3285     case Cursor::NorthEastSouthWestResize: return &quot;NorthEastSouthWestResize&quot;;
3286     case Cursor::NorthWestSouthEastResize: return &quot;NorthWestSouthEastResize&quot;;
3287     case Cursor::ColumnResize: return &quot;ColumnResize&quot;;
3288     case Cursor::RowResize: return &quot;RowResize&quot;;
3289     case Cursor::MiddlePanning: return &quot;MiddlePanning&quot;;
3290     case Cursor::EastPanning: return &quot;EastPanning&quot;;
3291     case Cursor::NorthPanning: return &quot;NorthPanning&quot;;
3292     case Cursor::NorthEastPanning: return &quot;NorthEastPanning&quot;;
3293     case Cursor::NorthWestPanning: return &quot;NorthWestPanning&quot;;
3294     case Cursor::SouthPanning: return &quot;SouthPanning&quot;;
3295     case Cursor::SouthEastPanning: return &quot;SouthEastPanning&quot;;
3296     case Cursor::SouthWestPanning: return &quot;SouthWestPanning&quot;;
3297     case Cursor::WestPanning: return &quot;WestPanning&quot;;
3298     case Cursor::Move: return &quot;Move&quot;;
3299     case Cursor::VerticalText: return &quot;VerticalText&quot;;
3300     case Cursor::Cell: return &quot;Cell&quot;;
3301     case Cursor::ContextMenu: return &quot;ContextMenu&quot;;
3302     case Cursor::Alias: return &quot;Alias&quot;;
3303     case Cursor::Progress: return &quot;Progress&quot;;
3304     case Cursor::NoDrop: return &quot;NoDrop&quot;;
3305     case Cursor::Copy: return &quot;Copy&quot;;
3306     case Cursor::None: return &quot;None&quot;;
3307     case Cursor::NotAllowed: return &quot;NotAllowed&quot;;
3308     case Cursor::ZoomIn: return &quot;ZoomIn&quot;;
3309     case Cursor::ZoomOut: return &quot;ZoomOut&quot;;
3310     case Cursor::Grab: return &quot;Grab&quot;;
3311     case Cursor::Grabbing: return &quot;Grabbing&quot;;
3312     case Cursor::Custom: return &quot;Custom&quot;;
3313     }
3314 
3315     ASSERT_NOT_REACHED();
3316     return &quot;UNKNOWN&quot;;
3317 }
3318 #endif
3319 
3320 ExceptionOr&lt;String&gt; Internals::getCurrentCursorInfo()
3321 {
3322     Document* document = contextDocument();
3323     if (!document || !document-&gt;frame())
3324         return Exception { InvalidAccessError };
3325 
3326 #if !PLATFORM(IOS_FAMILY)
3327     Cursor cursor = document-&gt;frame()-&gt;eventHandler().currentMouseCursor();
3328 
3329     StringBuilder result;
3330     result.appendLiteral(&quot;type=&quot;);
3331     result.append(cursorTypeToString(cursor.type()));
3332     result.appendLiteral(&quot; hotSpot=&quot;);
3333     result.appendNumber(cursor.hotSpot().x());
3334     result.append(&#39;,&#39;);
3335     result.appendNumber(cursor.hotSpot().y());
3336     if (cursor.image()) {
3337         FloatSize size = cursor.image()-&gt;size();
3338         result.appendLiteral(&quot; image=&quot;);
<a name="57" id="anc57"></a><span class="line-modified">3339         result.appendNumber(size.width());</span>
3340         result.append(&#39;x&#39;);
<a name="58" id="anc58"></a><span class="line-modified">3341         result.appendNumber(size.height());</span>
3342     }
3343 #if ENABLE(MOUSE_CURSOR_SCALE)
3344     if (cursor.imageScaleFactor() != 1) {
3345         result.appendLiteral(&quot; scale=&quot;);
<a name="59" id="anc59"></a><span class="line-modified">3346         result.appendNumber(cursor.imageScaleFactor(), 8);</span>
3347     }
3348 #endif
3349     return result.toString();
3350 #else
3351     return &quot;FAIL: Cursor details not available on this platform.&quot;_str;
3352 #endif
3353 }
3354 
3355 Ref&lt;ArrayBuffer&gt; Internals::serializeObject(const RefPtr&lt;SerializedScriptValue&gt;&amp; value) const
3356 {
3357     auto&amp; bytes = value-&gt;data();
3358     return ArrayBuffer::create(bytes.data(), bytes.size());
3359 }
3360 
3361 Ref&lt;SerializedScriptValue&gt; Internals::deserializeBuffer(ArrayBuffer&amp; buffer) const
3362 {
3363     Vector&lt;uint8_t&gt; bytes;
3364     bytes.append(static_cast&lt;const uint8_t*&gt;(buffer.data()), buffer.byteLength());
3365     return SerializedScriptValue::adopt(WTFMove(bytes));
3366 }
3367 
3368 bool Internals::isFromCurrentWorld(JSC::JSValue value) const
3369 {
3370     return isWorldCompatible(*contextDocument()-&gt;vm().topCallFrame, value);
3371 }
3372 
3373 void Internals::setUsesOverlayScrollbars(bool enabled)
3374 {
3375     WebCore::DeprecatedGlobalSettings::setUsesOverlayScrollbars(enabled);
3376 }
3377 
3378 void Internals::setUsesMockScrollAnimator(bool enabled)
3379 {
3380     WebCore::DeprecatedGlobalSettings::setUsesMockScrollAnimator(enabled);
3381 }
3382 
3383 void Internals::forceReload(bool endToEnd)
3384 {
3385     OptionSet&lt;ReloadOption&gt; reloadOptions;
3386     if (endToEnd)
3387         reloadOptions.add(ReloadOption::FromOrigin);
3388 
3389     frame()-&gt;loader().reload(reloadOptions);
3390 }
3391 
3392 void Internals::reloadExpiredOnly()
3393 {
3394     frame()-&gt;loader().reload(ReloadOption::ExpiredOnly);
3395 }
3396 
<a name="60" id="anc60"></a><span class="line-modified">3397 void Internals::enableAutoSizeMode(bool enabled, int minimumWidth, int minimumHeight, int maximumWidth, int maximumHeight)</span>
3398 {
3399     auto* document = contextDocument();
3400     if (!document || !document-&gt;view())
3401         return;
<a name="61" id="anc61"></a><span class="line-modified">3402     document-&gt;view()-&gt;enableAutoSizeMode(enabled, IntSize(minimumWidth, minimumHeight), IntSize(maximumWidth, maximumHeight));</span>
3403 }
3404 
3405 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
3406 
3407 void Internals::initializeMockCDM()
3408 {
<a name="62" id="anc62"></a><span class="line-modified">3409     LegacyCDM::registerCDMFactory([] (LegacyCDM* cdm) { return std::make_unique&lt;LegacyMockCDM&gt;(cdm); },</span>
3410         LegacyMockCDM::supportsKeySystem, LegacyMockCDM::supportsKeySystemAndMimeType);
3411 }
3412 
3413 #endif
3414 
3415 #if ENABLE(ENCRYPTED_MEDIA)
3416 
3417 Ref&lt;MockCDMFactory&gt; Internals::registerMockCDM()
3418 {
3419     return MockCDMFactory::create();
3420 }
3421 
3422 #endif
3423 
3424 String Internals::markerTextForListItem(Element&amp; element)
3425 {
3426     return WebCore::markerTextForListItem(&amp;element);
3427 }
3428 
3429 String Internals::toolTipFromElement(Element&amp; element) const
3430 {
3431     HitTestResult result;
3432     result.setInnerNode(&amp;element);
3433     TextDirection direction;
3434     return result.title(direction);
3435 }
3436 
3437 String Internals::getImageSourceURL(Element&amp; element)
3438 {
3439     return element.imageSourceURL();
3440 }
3441 
3442 #if ENABLE(VIDEO)
3443 
3444 Vector&lt;String&gt; Internals::mediaResponseSources(HTMLMediaElement&amp; media)
3445 {
3446     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3447     if (!resourceLoader)
3448         return { };
3449     Vector&lt;String&gt; result;
3450     auto responses = resourceLoader-&gt;responsesForTesting();
3451     for (auto&amp; response : responses)
3452         result.append(responseSourceToString(response));
3453     return result;
3454 }
3455 
3456 Vector&lt;String&gt; Internals::mediaResponseContentRanges(HTMLMediaElement&amp; media)
3457 {
3458     auto* resourceLoader = media.lastMediaResourceLoaderForTesting();
3459     if (!resourceLoader)
3460         return { };
3461     Vector&lt;String&gt; result;
3462     auto responses = resourceLoader-&gt;responsesForTesting();
3463     for (auto&amp; response : responses)
3464         result.append(response.httpHeaderField(HTTPHeaderName::ContentRange));
3465     return result;
3466 }
3467 
3468 void Internals::simulateAudioInterruption(HTMLMediaElement&amp; element)
3469 {
3470 #if USE(GSTREAMER)
3471     element.player()-&gt;simulateAudioInterruption();
3472 #else
3473     UNUSED_PARAM(element);
3474 #endif
3475 }
3476 
3477 ExceptionOr&lt;bool&gt; Internals::mediaElementHasCharacteristic(HTMLMediaElement&amp; element, const String&amp; characteristic)
3478 {
3479     if (equalLettersIgnoringASCIICase(characteristic, &quot;audible&quot;))
3480         return element.hasAudio();
3481     if (equalLettersIgnoringASCIICase(characteristic, &quot;visual&quot;))
3482         return element.hasVideo();
3483     if (equalLettersIgnoringASCIICase(characteristic, &quot;legible&quot;))
3484         return element.hasClosedCaptions();
3485 
3486     return Exception { SyntaxError };
3487 }
3488 
3489 void Internals::beginSimulatedHDCPError(HTMLMediaElement&amp; element)
3490 {
3491     if (auto player = element.player())
3492         player-&gt;beginSimulatedHDCPError();
3493 }
3494 
3495 void Internals::endSimulatedHDCPError(HTMLMediaElement&amp; element)
3496 {
3497     if (auto player = element.player())
3498         player-&gt;endSimulatedHDCPError();
3499 }
3500 
3501 bool Internals::elementShouldBufferData(HTMLMediaElement&amp; element)
3502 {
<a name="63" id="anc63"></a><span class="line-modified">3503     return element.shouldBufferData();</span>
3504 }
3505 
<a name="64" id="anc64"></a>















3506 #endif
3507 
3508 bool Internals::isSelectPopupVisible(HTMLSelectElement&amp; element)
3509 {
3510     element.document().updateLayoutIgnorePendingStylesheets();
3511 
3512     auto* renderer = element.renderer();
3513     if (!is&lt;RenderMenuList&gt;(renderer))
3514         return false;
3515 
3516 #if !PLATFORM(IOS_FAMILY)
3517     return downcast&lt;RenderMenuList&gt;(*renderer).popupIsVisible();
3518 #else
3519     return false;
3520 #endif
3521 }
3522 
3523 ExceptionOr&lt;String&gt; Internals::captionsStyleSheetOverride()
3524 {
3525     Document* document = contextDocument();
3526     if (!document || !document-&gt;page())
3527         return Exception { InvalidAccessError };
3528 
3529 #if ENABLE(VIDEO_TRACK)
3530     return document-&gt;page()-&gt;group().captionPreferences().captionsStyleSheetOverride();
3531 #else
3532     return String { emptyString() };
3533 #endif
3534 }
3535 
3536 ExceptionOr&lt;void&gt; Internals::setCaptionsStyleSheetOverride(const String&amp; override)
3537 {
3538     Document* document = contextDocument();
3539     if (!document || !document-&gt;page())
3540         return Exception { InvalidAccessError };
3541 
3542 #if ENABLE(VIDEO_TRACK)
3543     document-&gt;page()-&gt;group().captionPreferences().setCaptionsStyleSheetOverride(override);
3544 #else
3545     UNUSED_PARAM(override);
3546 #endif
3547     return { };
3548 }
3549 
3550 ExceptionOr&lt;void&gt; Internals::setPrimaryAudioTrackLanguageOverride(const String&amp; language)
3551 {
3552     Document* document = contextDocument();
3553     if (!document || !document-&gt;page())
3554         return Exception { InvalidAccessError };
3555 
3556 #if ENABLE(VIDEO_TRACK)
3557     document-&gt;page()-&gt;group().captionPreferences().setPrimaryAudioTrackLanguageOverride(language);
3558 #else
3559     UNUSED_PARAM(language);
3560 #endif
3561     return { };
3562 }
3563 
3564 ExceptionOr&lt;void&gt; Internals::setCaptionDisplayMode(const String&amp; mode)
3565 {
3566     Document* document = contextDocument();
3567     if (!document || !document-&gt;page())
3568         return Exception { InvalidAccessError };
3569 
3570 #if ENABLE(VIDEO_TRACK)
3571     auto&amp; captionPreferences = document-&gt;page()-&gt;group().captionPreferences();
3572 
3573     if (equalLettersIgnoringASCIICase(mode, &quot;automatic&quot;))
3574         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Automatic);
3575     else if (equalLettersIgnoringASCIICase(mode, &quot;forcedonly&quot;))
3576         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::ForcedOnly);
3577     else if (equalLettersIgnoringASCIICase(mode, &quot;alwayson&quot;))
3578         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::AlwaysOn);
3579     else if (equalLettersIgnoringASCIICase(mode, &quot;manual&quot;))
3580         captionPreferences.setCaptionDisplayMode(CaptionUserPreferences::Manual);
3581     else
3582         return Exception { SyntaxError };
3583 #else
3584     UNUSED_PARAM(mode);
3585 #endif
3586     return { };
3587 }
3588 
<a name="65" id="anc65"></a>









3589 #if ENABLE(VIDEO)
3590 
3591 Ref&lt;TimeRanges&gt; Internals::createTimeRanges(Float32Array&amp; startTimes, Float32Array&amp; endTimes)
3592 {
3593     ASSERT(startTimes.length() == endTimes.length());
3594     Ref&lt;TimeRanges&gt; ranges = TimeRanges::create();
3595 
3596     unsigned count = std::min(startTimes.length(), endTimes.length());
3597     for (unsigned i = 0; i &lt; count; ++i)
3598         ranges-&gt;add(startTimes.item(i), endTimes.item(i));
3599     return ranges;
3600 }
3601 
3602 double Internals::closestTimeToTimeRanges(double time, TimeRanges&amp; ranges)
3603 {
3604     return ranges.nearest(time);
3605 }
3606 
3607 #endif
3608 
3609 ExceptionOr&lt;Ref&lt;DOMRect&gt;&gt; Internals::selectionBounds()
3610 {
3611     Document* document = contextDocument();
3612     if (!document || !document-&gt;frame())
3613         return Exception { InvalidAccessError };
3614 
3615     return DOMRect::create(document-&gt;frame()-&gt;selection().selectionBounds());
3616 }
3617 
3618 void Internals::setSelectionWithoutValidation(Ref&lt;Node&gt; baseNode, unsigned baseOffset, RefPtr&lt;Node&gt; extentNode, unsigned extentOffset)
3619 {
3620     contextDocument()-&gt;frame()-&gt;selection().moveTo(
3621         VisiblePosition { createLegacyEditingPosition(baseNode.ptr(), baseOffset) },
3622         VisiblePosition { createLegacyEditingPosition(extentNode.get(), extentOffset) });
3623 }
3624 
3625 ExceptionOr&lt;bool&gt; Internals::isPluginUnavailabilityIndicatorObscured(Element&amp; element)
3626 {
3627     if (!is&lt;HTMLPlugInElement&gt;(element))
3628         return Exception { InvalidAccessError };
3629 
3630     return downcast&lt;HTMLPlugInElement&gt;(element).isReplacementObscured();
3631 }
3632 
3633 ExceptionOr&lt;String&gt; Internals::unavailablePluginReplacementText(Element&amp; element)
3634 {
3635     if (!is&lt;HTMLPlugInElement&gt;(element))
3636         return Exception { InvalidAccessError };
3637 
3638     auto* renderer = element.renderer();
3639     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
3640         return String { };
3641 
3642     return String { downcast&lt;RenderEmbeddedObject&gt;(*renderer).pluginReplacementTextIfUnavailable() };
3643 }
3644 
3645 bool Internals::isPluginSnapshotted(Element&amp; element)
3646 {
3647     return is&lt;HTMLPlugInElement&gt;(element) &amp;&amp; downcast&lt;HTMLPlugInElement&gt;(element).displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot;
3648 }
3649 
<a name="66" id="anc66"></a>




3650 #if ENABLE(MEDIA_SOURCE)
3651 
3652 void Internals::initializeMockMediaSource()
3653 {
3654 #if USE(AVFOUNDATION)
3655     WebCore::DeprecatedGlobalSettings::setAVFoundationEnabled(false);
3656 #endif
3657 #if USE(GSTREAMER)
3658     WebCore::DeprecatedGlobalSettings::setGStreamerEnabled(false);
3659 #endif
3660     MediaPlayerFactorySupport::callRegisterMediaEngine(MockMediaPlayerMediaSource::registerMediaEngine);
3661 }
3662 
<a name="67" id="anc67"></a><span class="line-modified">3663 Vector&lt;String&gt; Internals::bufferedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomicString&amp; trackID)</span>
3664 {
3665     return buffer.bufferedSamplesForTrackID(trackID);
3666 }
3667 
<a name="68" id="anc68"></a><span class="line-modified">3668 Vector&lt;String&gt; Internals::enqueuedSamplesForTrackID(SourceBuffer&amp; buffer, const AtomicString&amp; trackID)</span>
3669 {
3670     return buffer.enqueuedSamplesForTrackID(trackID);
3671 }
3672 
<a name="69" id="anc69"></a>




3673 void Internals::setShouldGenerateTimestamps(SourceBuffer&amp; buffer, bool flag)
3674 {
3675     buffer.setShouldGenerateTimestamps(flag);
3676 }
3677 
<a name="70" id="anc70"></a>




3678 #endif
3679 
3680 void Internals::enableMockMediaCapabilities()
3681 {
3682     MediaEngineConfigurationFactory::enableMock();
3683 }
3684 
3685 #if ENABLE(VIDEO)
3686 
3687 ExceptionOr&lt;void&gt; Internals::beginMediaSessionInterruption(const String&amp; interruptionString)
3688 {
3689     PlatformMediaSession::InterruptionType interruption = PlatformMediaSession::SystemInterruption;
3690 
3691     if (equalLettersIgnoringASCIICase(interruptionString, &quot;system&quot;))
3692         interruption = PlatformMediaSession::SystemInterruption;
3693     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;systemsleep&quot;))
3694         interruption = PlatformMediaSession::SystemSleep;
3695     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;enteringbackground&quot;))
3696         interruption = PlatformMediaSession::EnteringBackground;
3697     else if (equalLettersIgnoringASCIICase(interruptionString, &quot;suspendedunderlock&quot;))
3698         interruption = PlatformMediaSession::SuspendedUnderLock;
3699     else
3700         return Exception { InvalidAccessError };
3701 
3702     PlatformMediaSessionManager::sharedManager().beginInterruption(interruption);
3703     return { };
3704 }
3705 
3706 void Internals::endMediaSessionInterruption(const String&amp; flagsString)
3707 {
3708     PlatformMediaSession::EndInterruptionFlags flags = PlatformMediaSession::NoFlags;
3709 
3710     if (equalLettersIgnoringASCIICase(flagsString, &quot;mayresumeplaying&quot;))
3711         flags = PlatformMediaSession::MayResumePlaying;
3712 
3713     PlatformMediaSessionManager::sharedManager().endInterruption(flags);
3714 }
3715 
3716 void Internals::applicationWillBecomeInactive()
3717 {
3718     PlatformMediaSessionManager::sharedManager().applicationWillBecomeInactive();
3719 }
3720 
3721 void Internals::applicationDidBecomeActive()
3722 {
3723     PlatformMediaSessionManager::sharedManager().applicationDidBecomeActive();
3724 }
3725 
3726 void Internals::applicationWillEnterForeground(bool suspendedUnderLock) const
3727 {
3728     PlatformMediaSessionManager::sharedManager().applicationWillEnterForeground(suspendedUnderLock);
3729 }
3730 
3731 void Internals::applicationDidEnterBackground(bool suspendedUnderLock) const
3732 {
3733     PlatformMediaSessionManager::sharedManager().applicationDidEnterBackground(suspendedUnderLock);
3734 }
3735 
3736 static PlatformMediaSession::MediaType mediaTypeFromString(const String&amp; mediaTypeString)
3737 {
3738     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;video&quot;))
3739         return PlatformMediaSession::Video;
3740     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;audio&quot;))
3741         return PlatformMediaSession::Audio;
3742     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;videoaudio&quot;))
3743         return PlatformMediaSession::VideoAudio;
3744     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;webaudio&quot;))
3745         return PlatformMediaSession::WebAudio;
3746     if (equalLettersIgnoringASCIICase(mediaTypeString, &quot;mediastreamcapturingaudio&quot;))
3747         return PlatformMediaSession::MediaStreamCapturingAudio;
3748 
3749     return PlatformMediaSession::None;
3750 }
3751 
3752 ExceptionOr&lt;void&gt; Internals::setMediaSessionRestrictions(const String&amp; mediaTypeString, StringView restrictionsString)
3753 {
3754     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3755     if (mediaType == PlatformMediaSession::None)
3756         return Exception { InvalidAccessError };
3757 
3758     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3759     PlatformMediaSessionManager::sharedManager().removeRestriction(mediaType, restrictions);
3760 
3761     restrictions = PlatformMediaSessionManager::NoRestrictions;
3762 
3763     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3764         if (equalLettersIgnoringASCIICase(restrictionString, &quot;concurrentplaybacknotpermitted&quot;))
3765             restrictions |= PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted;
3766         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundprocessplaybackrestricted&quot;))
3767             restrictions |= PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted;
3768         if (equalLettersIgnoringASCIICase(restrictionString, &quot;backgroundtabplaybackrestricted&quot;))
3769             restrictions |= PlatformMediaSessionManager::BackgroundTabPlaybackRestricted;
3770         if (equalLettersIgnoringASCIICase(restrictionString, &quot;interruptedplaybacknotpermitted&quot;))
3771             restrictions |= PlatformMediaSessionManager::InterruptedPlaybackNotPermitted;
3772         if (equalLettersIgnoringASCIICase(restrictionString, &quot;inactiveprocessplaybackrestricted&quot;))
3773             restrictions |= PlatformMediaSessionManager::InactiveProcessPlaybackRestricted;
3774         if (equalLettersIgnoringASCIICase(restrictionString, &quot;suspendedunderlockplaybackrestricted&quot;))
3775             restrictions |= PlatformMediaSessionManager::SuspendedUnderLockPlaybackRestricted;
3776     }
3777     PlatformMediaSessionManager::sharedManager().addRestriction(mediaType, restrictions);
3778     return { };
3779 }
3780 
3781 ExceptionOr&lt;String&gt; Internals::mediaSessionRestrictions(const String&amp; mediaTypeString) const
3782 {
3783     PlatformMediaSession::MediaType mediaType = mediaTypeFromString(mediaTypeString);
3784     if (mediaType == PlatformMediaSession::None)
3785         return Exception { InvalidAccessError };
3786 
3787     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType);
3788     if (restrictions == PlatformMediaSessionManager::NoRestrictions)
3789         return String();
3790 
3791     StringBuilder builder;
3792     if (restrictions &amp; PlatformMediaSessionManager::ConcurrentPlaybackNotPermitted)
3793         builder.append(&quot;concurrentplaybacknotpermitted&quot;);
3794     if (restrictions &amp; PlatformMediaSessionManager::BackgroundProcessPlaybackRestricted) {
3795         if (!builder.isEmpty())
3796             builder.append(&#39;,&#39;);
3797         builder.append(&quot;backgroundprocessplaybackrestricted&quot;);
3798     }
3799     if (restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) {
3800         if (!builder.isEmpty())
3801             builder.append(&#39;,&#39;);
3802         builder.append(&quot;backgroundtabplaybackrestricted&quot;);
3803     }
3804     if (restrictions &amp; PlatformMediaSessionManager::InterruptedPlaybackNotPermitted) {
3805         if (!builder.isEmpty())
3806             builder.append(&#39;,&#39;);
3807         builder.append(&quot;interruptedplaybacknotpermitted&quot;);
3808     }
3809     return builder.toString();
3810 }
3811 
3812 void Internals::setMediaElementRestrictions(HTMLMediaElement&amp; element, StringView restrictionsString)
3813 {
3814     MediaElementSession::BehaviorRestrictions restrictions = element.mediaSession().behaviorRestrictions();
3815     element.mediaSession().removeBehaviorRestriction(restrictions);
3816 
3817     restrictions = MediaElementSession::NoRestrictions;
3818 
3819     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3820         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
3821             restrictions |= MediaElementSession::NoRestrictions;
3822         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforload&quot;))
3823             restrictions |= MediaElementSession::RequireUserGestureForLoad;
3824         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforvideoratechange&quot;))
3825             restrictions |= MediaElementSession::RequireUserGestureForVideoRateChange;
3826         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforfullscreen&quot;))
3827             restrictions |= MediaElementSession::RequireUserGestureForFullscreen;
3828         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoloadmedia&quot;))
3829             restrictions |= MediaElementSession::RequirePageConsentToLoadMedia;
3830         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsenttoresumemedia&quot;))
3831             restrictions |= MediaElementSession::RequirePageConsentToResumeMedia;
3832 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3833         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergesturetoshowplaybacktargetpicker&quot;))
3834             restrictions |= MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker;
3835         if (equalLettersIgnoringASCIICase(restrictionString, &quot;wirelessvideoplaybackdisabled&quot;))
3836             restrictions |= MediaElementSession::WirelessVideoPlaybackDisabled;
3837 #endif
3838         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudioratechange&quot;))
3839             restrictions |= MediaElementSession::RequireUserGestureForAudioRateChange;
<a name="71" id="anc71"></a><span class="line-removed">3840         if (equalLettersIgnoringASCIICase(restrictionString, &quot;metadatapreloadingnotpermitted&quot;))</span>
<span class="line-removed">3841             restrictions |= MediaElementSession::MetadataPreloadingNotPermitted;</span>
3842         if (equalLettersIgnoringASCIICase(restrictionString, &quot;autopreloadingnotpermitted&quot;))
3843             restrictions |= MediaElementSession::AutoPreloadingNotPermitted;
3844         if (equalLettersIgnoringASCIICase(restrictionString, &quot;invisibleautoplaynotpermitted&quot;))
3845             restrictions |= MediaElementSession::InvisibleAutoplayNotPermitted;
3846         if (equalLettersIgnoringASCIICase(restrictionString, &quot;overrideusergesturerequirementformaincontent&quot;))
3847             restrictions |= MediaElementSession::OverrideUserGestureRequirementForMainContent;
3848     }
3849     element.mediaSession().addBehaviorRestriction(restrictions);
3850 }
3851 
3852 ExceptionOr&lt;void&gt; Internals::postRemoteControlCommand(const String&amp; commandString, float argument)
3853 {
3854     PlatformMediaSession::RemoteControlCommandType command;
3855     PlatformMediaSession::RemoteCommandArgument parameter { argument };
3856 
3857     if (equalLettersIgnoringASCIICase(commandString, &quot;play&quot;))
3858         command = PlatformMediaSession::PlayCommand;
3859     else if (equalLettersIgnoringASCIICase(commandString, &quot;pause&quot;))
3860         command = PlatformMediaSession::PauseCommand;
3861     else if (equalLettersIgnoringASCIICase(commandString, &quot;stop&quot;))
3862         command = PlatformMediaSession::StopCommand;
3863     else if (equalLettersIgnoringASCIICase(commandString, &quot;toggleplaypause&quot;))
3864         command = PlatformMediaSession::TogglePlayPauseCommand;
3865     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingbackward&quot;))
3866         command = PlatformMediaSession::BeginSeekingBackwardCommand;
3867     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingbackward&quot;))
3868         command = PlatformMediaSession::EndSeekingBackwardCommand;
3869     else if (equalLettersIgnoringASCIICase(commandString, &quot;beginseekingforward&quot;))
3870         command = PlatformMediaSession::BeginSeekingForwardCommand;
3871     else if (equalLettersIgnoringASCIICase(commandString, &quot;endseekingforward&quot;))
3872         command = PlatformMediaSession::EndSeekingForwardCommand;
3873     else if (equalLettersIgnoringASCIICase(commandString, &quot;seektoplaybackposition&quot;))
3874         command = PlatformMediaSession::SeekToPlaybackPositionCommand;
3875     else
3876         return Exception { InvalidAccessError };
3877 
3878     PlatformMediaSessionManager::sharedManager().didReceiveRemoteControlCommand(command, &amp;parameter);
3879     return { };
3880 }
3881 
3882 bool Internals::elementIsBlockingDisplaySleep(HTMLMediaElement&amp; element) const
3883 {
3884     return element.isDisablingSleep();
3885 }
3886 
3887 #endif // ENABLE(VIDEO)
3888 
3889 #if ENABLE(MEDIA_SESSION)
3890 
3891 void Internals::sendMediaSessionStartOfInterruptionNotification(MediaSessionInterruptingCategory category)
3892 {
3893     MediaSessionManager::singleton().didReceiveStartOfInterruptionNotification(category);
3894 }
3895 
3896 void Internals::sendMediaSessionEndOfInterruptionNotification(MediaSessionInterruptingCategory category)
3897 {
3898     MediaSessionManager::singleton().didReceiveEndOfInterruptionNotification(category);
3899 }
3900 
3901 String Internals::mediaSessionCurrentState(MediaSession* session) const
3902 {
3903     switch (session-&gt;currentState()) {
3904     case MediaSession::State::Active:
3905         return &quot;active&quot;;
3906     case MediaSession::State::Interrupted:
3907         return &quot;interrupted&quot;;
3908     case MediaSession::State::Idle:
3909         return &quot;idle&quot;;
3910     }
3911 }
3912 
3913 double Internals::mediaElementPlayerVolume(HTMLMediaElement* element) const
3914 {
3915     ASSERT_ARG(element, element);
3916     return element-&gt;playerVolume();
3917 }
3918 
3919 void Internals::sendMediaControlEvent(MediaControlEvent event)
3920 {
3921     // FIXME: No good reason to use a single function with an argument instead of three functions.
3922     switch (event) {
3923     case MediControlEvent::PlayPause:
3924         MediaSessionManager::singleton().togglePlayback();
3925         break;
3926     case MediControlEvent::NextTrack:
3927         MediaSessionManager::singleton().skipToNextTrack();
3928         break;
3929     case MediControlEvent::PreviousTrack:
3930         MediaSessionManager::singleton().skipToPreviousTrack();
3931         break;
3932     }
3933 }
3934 
3935 #endif // ENABLE(MEDIA_SESSION)
3936 
3937 #if ENABLE(WEB_AUDIO)
3938 
3939 void Internals::setAudioContextRestrictions(AudioContext&amp; context, StringView restrictionsString)
3940 {
3941     AudioContext::BehaviorRestrictions restrictions = context.behaviorRestrictions();
3942     context.removeBehaviorRestriction(restrictions);
3943 
3944     restrictions = AudioContext::NoRestrictions;
3945 
3946     for (StringView restrictionString : restrictionsString.split(&#39;,&#39;)) {
3947         if (equalLettersIgnoringASCIICase(restrictionString, &quot;norestrictions&quot;))
3948             restrictions |= AudioContext::NoRestrictions;
3949         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requireusergestureforaudiostart&quot;))
3950             restrictions |= AudioContext::RequireUserGestureForAudioStartRestriction;
3951         if (equalLettersIgnoringASCIICase(restrictionString, &quot;requirepageconsentforaudiostart&quot;))
3952             restrictions |= AudioContext::RequirePageConsentForAudioStartRestriction;
3953     }
3954     context.addBehaviorRestriction(restrictions);
3955 }
3956 
3957 #endif
3958 
3959 void Internals::simulateSystemSleep() const
3960 {
3961 #if ENABLE(VIDEO)
3962     PlatformMediaSessionManager::sharedManager().systemWillSleep();
3963 #endif
3964 }
3965 
3966 void Internals::simulateSystemWake() const
3967 {
3968 #if ENABLE(VIDEO)
3969     PlatformMediaSessionManager::sharedManager().systemDidWake();
3970 #endif
3971 }
3972 
3973 ExceptionOr&lt;Internals::NowPlayingState&gt; Internals::nowPlayingState() const
3974 {
3975 #if ENABLE(VIDEO)
3976     return { { PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingTitle(),
3977         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingDuration(),
3978         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingElapsedTime(),
3979         PlatformMediaSessionManager::sharedManager().lastUpdatedNowPlayingInfoUniqueIdentifier(),
3980         PlatformMediaSessionManager::sharedManager().hasActiveNowPlayingSession(),
3981         PlatformMediaSessionManager::sharedManager().registeredAsNowPlayingApplication()
3982     } };
3983 #else
3984     return Exception { InvalidAccessError };
3985 #endif
3986 }
3987 
3988 #if ENABLE(VIDEO)
3989 RefPtr&lt;HTMLMediaElement&gt; Internals::bestMediaElementForShowingPlaybackControlsManager(Internals::PlaybackControlsPurpose purpose)
3990 {
3991     return HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(purpose);
3992 }
3993 
3994 Internals::MediaSessionState Internals::mediaSessionState(HTMLMediaElement&amp; element)
3995 {
3996     return element.mediaSession().state();
3997 }
3998 #endif
3999 
4000 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
4001 
4002 void Internals::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
4003 {
4004     Page* page = contextDocument()-&gt;frame()-&gt;page();
4005     ASSERT(page);
4006 
4007     page-&gt;setMockMediaPlaybackTargetPickerEnabled(enabled);
4008 }
4009 
4010 ExceptionOr&lt;void&gt; Internals::setMockMediaPlaybackTargetPickerState(const String&amp; deviceName, const String&amp; deviceState)
4011 {
4012     Page* page = contextDocument()-&gt;frame()-&gt;page();
4013     ASSERT(page);
4014 
4015     MediaPlaybackTargetContext::State state = MediaPlaybackTargetContext::Unknown;
4016 
4017     if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceavailable&quot;))
4018         state = MediaPlaybackTargetContext::OutputDeviceAvailable;
4019     else if (equalLettersIgnoringASCIICase(deviceState, &quot;deviceunavailable&quot;))
4020         state = MediaPlaybackTargetContext::OutputDeviceUnavailable;
4021     else if (equalLettersIgnoringASCIICase(deviceState, &quot;unknown&quot;))
4022         state = MediaPlaybackTargetContext::Unknown;
4023     else
4024         return Exception { InvalidAccessError };
4025 
4026     page-&gt;setMockMediaPlaybackTargetPickerState(deviceName, state);
4027     return { };
4028 }
4029 
4030 #endif
4031 
4032 ExceptionOr&lt;Ref&lt;MockPageOverlay&gt;&gt; Internals::installMockPageOverlay(PageOverlayType type)
4033 {
4034     Document* document = contextDocument();
4035     if (!document || !document-&gt;page())
4036         return Exception { InvalidAccessError };
4037 
4038     return MockPageOverlayClient::singleton().installOverlay(*document-&gt;page(), type == PageOverlayType::View ? PageOverlay::OverlayType::View : PageOverlay::OverlayType::Document);
4039 }
4040 
4041 ExceptionOr&lt;String&gt; Internals::pageOverlayLayerTreeAsText(unsigned short flags) const
4042 {
4043     Document* document = contextDocument();
4044     if (!document || !document-&gt;page())
4045         return Exception { InvalidAccessError };
4046 
4047     document-&gt;updateLayoutIgnorePendingStylesheets();
4048 
4049     return MockPageOverlayClient::singleton().layerTreeAsText(*document-&gt;page(), toLayerTreeFlags(flags));
4050 }
4051 
4052 void Internals::setPageMuted(StringView statesString)
4053 {
4054     Document* document = contextDocument();
4055     if (!document)
4056         return;
4057 
4058     WebCore::MediaProducer::MutedStateFlags state = MediaProducer::NoneMuted;
4059     for (StringView stateString : statesString.split(&#39;,&#39;)) {
4060         if (equalLettersIgnoringASCIICase(stateString, &quot;audio&quot;))
4061             state |= MediaProducer::AudioIsMuted;
4062         if (equalLettersIgnoringASCIICase(stateString, &quot;capturedevices&quot;))
<a name="72" id="anc72"></a><span class="line-modified">4063             state |= MediaProducer::CaptureDevicesAreMuted;</span>


4064     }
4065 
4066     if (Page* page = document-&gt;page())
4067         page-&gt;setMuted(state);
4068 }
4069 
4070 String Internals::pageMediaState()
4071 {
4072     Document* document = contextDocument();
4073     if (!document || !document-&gt;page())
4074         return emptyString();
4075 
4076     WebCore::MediaProducer::MediaStateFlags state = document-&gt;page()-&gt;mediaState();
4077     StringBuilder string;
4078     if (state &amp; MediaProducer::IsPlayingAudio)
4079         string.append(&quot;IsPlayingAudio,&quot;);
4080     if (state &amp; MediaProducer::IsPlayingVideo)
4081         string.append(&quot;IsPlayingVideo,&quot;);
4082     if (state &amp; MediaProducer::IsPlayingToExternalDevice)
4083         string.append(&quot;IsPlayingToExternalDevice,&quot;);
4084     if (state &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
4085         string.append(&quot;RequiresPlaybackTargetMonitoring,&quot;);
4086     if (state &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
4087         string.append(&quot;ExternalDeviceAutoPlayCandidate,&quot;);
4088     if (state &amp; MediaProducer::DidPlayToEnd)
4089         string.append(&quot;DidPlayToEnd,&quot;);
4090     if (state &amp; MediaProducer::IsSourceElementPlaying)
4091         string.append(&quot;IsSourceElementPlaying,&quot;);
4092 
4093     if (state &amp; MediaProducer::IsNextTrackControlEnabled)
4094         string.append(&quot;IsNextTrackControlEnabled,&quot;);
4095     if (state &amp; MediaProducer::IsPreviousTrackControlEnabled)
4096         string.append(&quot;IsPreviousTrackControlEnabled,&quot;);
4097 
4098     if (state &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
4099         string.append(&quot;HasPlaybackTargetAvailabilityListener,&quot;);
4100     if (state &amp; MediaProducer::HasAudioOrVideo)
4101         string.append(&quot;HasAudioOrVideo,&quot;);
4102     if (state &amp; MediaProducer::HasActiveAudioCaptureDevice)
4103         string.append(&quot;HasActiveAudioCaptureDevice,&quot;);
4104     if (state &amp; MediaProducer::HasActiveVideoCaptureDevice)
4105         string.append(&quot;HasActiveVideoCaptureDevice,&quot;);
4106     if (state &amp; MediaProducer::HasMutedAudioCaptureDevice)
4107         string.append(&quot;HasMutedAudioCaptureDevice,&quot;);
4108     if (state &amp; MediaProducer::HasMutedVideoCaptureDevice)
4109         string.append(&quot;HasMutedVideoCaptureDevice,&quot;);
4110     if (state &amp; MediaProducer::HasUserInteractedWithMediaElement)
4111         string.append(&quot;HasUserInteractedWithMediaElement,&quot;);
4112     if (state &amp; MediaProducer::HasActiveDisplayCaptureDevice)
4113         string.append(&quot;HasActiveDisplayCaptureDevice,&quot;);
4114     if (state &amp; MediaProducer::HasMutedDisplayCaptureDevice)
4115         string.append(&quot;HasMutedDisplayCaptureDevice,&quot;);
4116 
4117     if (string.isEmpty())
4118         string.append(&quot;IsNotPlaying&quot;);
4119     else
4120         string.resize(string.length() - 1);
4121 
4122     return string.toString();
4123 }
4124 
4125 void Internals::setPageDefersLoading(bool defersLoading)
4126 {
4127     Document* document = contextDocument();
4128     if (!document)
4129         return;
4130     if (Page* page = document-&gt;page())
4131         page-&gt;setDefersLoading(defersLoading);
4132 }
4133 
4134 ExceptionOr&lt;bool&gt; Internals::pageDefersLoading()
4135 {
4136     Document* document = contextDocument();
4137     if (!document || !document-&gt;page())
4138         return Exception { InvalidAccessError };
4139     return document-&gt;page()-&gt;defersLoading();
4140 }
4141 
4142 RefPtr&lt;File&gt; Internals::createFile(const String&amp; path)
4143 {
4144     Document* document = contextDocument();
4145     if (!document)
4146         return nullptr;
4147 
4148     URL url = document-&gt;completeURL(path);
4149     if (!url.isLocalFile())
4150         return nullptr;
4151 
<a name="73" id="anc73"></a><span class="line-modified">4152     return File::create(url.fileSystemPath());</span>
4153 }
4154 
4155 void Internals::queueMicroTask(int testNumber)
4156 {
4157     Document* document = contextDocument();
4158     if (!document)
4159         return;
4160 
<a name="74" id="anc74"></a><span class="line-modified">4161     auto microtask = std::make_unique&lt;ActiveDOMCallbackMicrotask&gt;(MicrotaskQueue::mainThreadQueue(), *document, [document, testNumber]() {</span>
4162         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Debug, makeString(&quot;MicroTask #&quot;, testNumber, &quot; has run.&quot;));
4163     });
4164 
4165     MicrotaskQueue::mainThreadQueue().append(WTFMove(microtask));
4166 }
4167 
4168 #if ENABLE(CONTENT_FILTERING)
4169 
4170 MockContentFilterSettings&amp; Internals::mockContentFilterSettings()
4171 {
4172     return MockContentFilterSettings::singleton();
4173 }
4174 
4175 #endif
4176 
4177 #if ENABLE(CSS_SCROLL_SNAP)
4178 
4179 static void appendOffsets(StringBuilder&amp; builder, const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
4180 {
4181     bool justStarting = true;
4182 
4183     builder.appendLiteral(&quot;{ &quot;);
4184     for (auto&amp; coordinate : snapOffsets) {
4185         if (!justStarting)
4186             builder.appendLiteral(&quot;, &quot;);
4187         else
4188             justStarting = false;
4189 
4190         builder.appendNumber(coordinate.toUnsigned());
4191     }
4192     builder.appendLiteral(&quot; }&quot;);
4193 }
4194 
4195 void Internals::setPlatformMomentumScrollingPredictionEnabled(bool enabled)
4196 {
4197     ScrollingMomentumCalculator::setPlatformMomentumScrollingPredictionEnabled(enabled);
4198 }
4199 
4200 ExceptionOr&lt;String&gt; Internals::scrollSnapOffsets(Element&amp; element)
4201 {
4202     element.document().updateLayoutIgnorePendingStylesheets();
4203 
4204     if (!element.renderBox())
4205         return String();
4206 
4207     RenderBox&amp; box = *element.renderBox();
4208     ScrollableArea* scrollableArea;
4209 
4210     if (box.isBody()) {
4211         FrameView* frameView = box.frame().mainFrame().view();
4212         if (!frameView || !frameView-&gt;isScrollable())
4213             return Exception { InvalidAccessError };
4214         scrollableArea = frameView;
4215 
4216     } else {
4217         if (!box.canBeScrolledAndHasScrollableArea())
4218             return Exception { InvalidAccessError };
4219         scrollableArea = box.layer();
4220     }
4221 
4222     if (!scrollableArea)
4223         return String();
4224 
4225     StringBuilder result;
4226 
4227     if (auto* offsets = scrollableArea-&gt;horizontalSnapOffsets()) {
4228         if (offsets-&gt;size()) {
4229             result.appendLiteral(&quot;horizontal = &quot;);
4230             appendOffsets(result, *offsets);
4231         }
4232     }
4233 
4234     if (auto* offsets = scrollableArea-&gt;verticalSnapOffsets()) {
4235         if (offsets-&gt;size()) {
4236             if (result.length())
4237                 result.appendLiteral(&quot;, &quot;);
4238 
4239             result.appendLiteral(&quot;vertical = &quot;);
4240             appendOffsets(result, *offsets);
4241         }
4242     }
4243 
4244     return result.toString();
4245 }
4246 
4247 #endif
4248 
4249 bool Internals::testPreloaderSettingViewport()
4250 {
4251     return testPreloadScannerViewportSupport(contextDocument());
4252 }
4253 
4254 ExceptionOr&lt;String&gt; Internals::pathStringWithShrinkWrappedRects(const Vector&lt;double&gt;&amp; rectComponents, double radius)
4255 {
4256     if (rectComponents.size() % 4)
4257         return Exception { InvalidAccessError };
4258 
4259     Vector&lt;FloatRect&gt; rects;
4260     for (unsigned i = 0; i &lt; rectComponents.size(); i += 4)
4261         rects.append(FloatRect(rectComponents[i], rectComponents[i + 1], rectComponents[i + 2], rectComponents[i + 3]));
4262 
4263     SVGPathStringBuilder builder;
4264     PathUtilities::pathWithShrinkWrappedRects(rects, radius).apply([&amp;builder](const PathElement&amp; element) {
4265         switch (element.type) {
4266         case PathElementMoveToPoint:
4267             builder.moveTo(element.points[0], false, AbsoluteCoordinates);
4268             return;
4269         case PathElementAddLineToPoint:
4270             builder.lineTo(element.points[0], AbsoluteCoordinates);
4271             return;
4272         case PathElementAddQuadCurveToPoint:
4273             builder.curveToQuadratic(element.points[0], element.points[1], AbsoluteCoordinates);
4274             return;
4275         case PathElementAddCurveToPoint:
4276             builder.curveToCubic(element.points[0], element.points[1], element.points[2], AbsoluteCoordinates);
4277             return;
4278         case PathElementCloseSubpath:
4279             builder.closePath();
4280             return;
4281         }
4282         ASSERT_NOT_REACHED();
4283     });
4284     return builder.result();
4285 }
4286 
4287 
4288 String Internals::getCurrentMediaControlsStatusForElement(HTMLMediaElement&amp; mediaElement)
4289 {
4290 #if !ENABLE(MEDIA_CONTROLS_SCRIPT)
4291     UNUSED_PARAM(mediaElement);
4292     return String();
4293 #else
4294     return mediaElement.getCurrentMediaControlsStatus();
4295 #endif
4296 }
4297 
4298 #if !PLATFORM(COCOA)
4299 
4300 String Internals::userVisibleString(const DOMURL&amp; url)
4301 {
4302     return WTF::URLHelpers::userVisibleURL(url.href().string().utf8());
4303 }
4304 
4305 #endif
4306 
4307 void Internals::setShowAllPlugins(bool show)
4308 {
4309     Document* document = contextDocument();
4310     if (!document)
4311         return;
4312 
4313     Page* page = document-&gt;page();
4314     if (!page)
4315         return;
4316 
4317     page-&gt;setShowAllPlugins(show);
4318 }
4319 
4320 #if ENABLE(STREAMS_API)
4321 
4322 bool Internals::isReadableStreamDisturbed(JSC::ExecState&amp; state, JSValue stream)
4323 {
4324     return ReadableStream::isDisturbed(state, stream);
4325 }
4326 
4327 JSValue Internals::cloneArrayBuffer(JSC::ExecState&amp; state, JSValue buffer, JSValue srcByteOffset, JSValue srcLength)
4328 {
4329     JSC::VM&amp; vm = state.vm();
4330     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(&amp;state);
4331     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
4332     const Identifier&amp; privateName = clientData-&gt;builtinNames().cloneArrayBufferPrivateName();
4333     JSValue value;
4334     PropertySlot propertySlot(value, PropertySlot::InternalMethodType::Get);
4335     globalObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(globalObject, &amp;state, privateName, propertySlot);
4336     value = propertySlot.getValue(&amp;state, privateName);
4337     ASSERT(value.isFunction(vm));
4338 
4339     JSObject* function = value.getObject();
4340     CallData callData;
4341     CallType callType = JSC::getCallData(vm, function, callData);
4342     ASSERT(callType != JSC::CallType::None);
4343     MarkedArgumentBuffer arguments;
4344     arguments.append(buffer);
4345     arguments.append(srcByteOffset);
4346     arguments.append(srcLength);
4347     ASSERT(!arguments.hasOverflowed());
4348 
4349     return JSC::call(&amp;state, function, callType, callData, JSC::jsUndefined(), arguments);
4350 }
4351 
4352 #endif
4353 
<a name="75" id="anc75"></a><span class="line-modified">4354 String Internals::resourceLoadStatisticsForOrigin(const String&amp; origin)</span>
4355 {
<a name="76" id="anc76"></a><span class="line-modified">4356     return ResourceLoadObserver::shared().statisticsForOrigin(origin);</span>




4357 }
4358 
4359 void Internals::setResourceLoadStatisticsEnabled(bool enable)
4360 {
4361     DeprecatedGlobalSettings::setResourceLoadStatisticsEnabled(enable);
4362 }
4363 
<a name="77" id="anc77"></a><span class="line-removed">4364 void Internals::setUserGrantsStorageAccess(bool value)</span>
<span class="line-removed">4365 {</span>
<span class="line-removed">4366     Document* document = contextDocument();</span>
<span class="line-removed">4367     if (!document)</span>
<span class="line-removed">4368         return;</span>
<span class="line-removed">4369 </span>
<span class="line-removed">4370     document-&gt;setUserGrantsStorageAccessOverride(value);</span>
<span class="line-removed">4371 }</span>
<span class="line-removed">4372 </span>
4373 String Internals::composedTreeAsText(Node&amp; node)
4374 {
4375     if (!is&lt;ContainerNode&gt;(node))
4376         return emptyString();
4377     return WebCore::composedTreeAsText(downcast&lt;ContainerNode&gt;(node));
4378 }
4379 
4380 bool Internals::isProcessingUserGesture()
4381 {
4382     return UserGestureIndicator::processingUserGesture();
4383 }
4384 
4385 void Internals::withUserGesture(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4386 {
4387     UserGestureIndicator gestureIndicator(ProcessingUserGesture, contextDocument());
4388     callback-&gt;handleEvent();
4389 }
4390 
<a name="78" id="anc78"></a>








4391 double Internals::lastHandledUserGestureTimestamp()
4392 {
4393     Document* document = contextDocument();
4394     if (!document)
4395         return 0;
4396 
4397     return document-&gt;lastHandledUserGestureTimestamp().secondsSinceEpoch().value();
4398 }
4399 
4400 RefPtr&lt;GCObservation&gt; Internals::observeGC(JSC::JSValue value)
4401 {
4402     if (!value.isObject())
4403         return nullptr;
4404     return GCObservation::create(asObject(value));
4405 }
4406 
4407 void Internals::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
4408 {
4409     Document* document = contextDocument();
4410     if (!document)
4411         return;
4412 
4413     Page* page = document-&gt;page();
4414     if (!page)
4415         return;
4416 
4417     page-&gt;setUserInterfaceLayoutDirection(userInterfaceLayoutDirection == UserInterfaceLayoutDirection::LTR ? WebCore::UserInterfaceLayoutDirection::LTR : WebCore::UserInterfaceLayoutDirection::RTL);
4418 }
4419 
4420 #if !PLATFORM(COCOA)
4421 
4422 bool Internals::userPrefersReducedMotion() const
4423 {
4424     return false;
4425 }
4426 
<a name="79" id="anc79"></a>






4427 #endif
4428 
4429 void Internals::reportBacktrace()
4430 {
4431     WTFReportBacktrace();
4432 }
4433 
4434 void Internals::setBaseWritingDirection(BaseWritingDirection direction)
4435 {
4436     if (auto* document = contextDocument()) {
4437         if (auto* frame = document-&gt;frame()) {
4438             switch (direction) {
4439             case BaseWritingDirection::Ltr:
4440                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::LeftToRight);
4441                 break;
4442             case BaseWritingDirection::Rtl:
4443                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::RightToLeft);
4444                 break;
4445             case BaseWritingDirection::Natural:
4446                 frame-&gt;editor().setBaseWritingDirection(WritingDirection::Natural);
4447                 break;
4448             }
4449         }
4450     }
4451 }
4452 
4453 #if ENABLE(POINTER_LOCK)
4454 bool Internals::pageHasPendingPointerLock() const
4455 {
4456     Document* document = contextDocument();
4457     if (!document)
4458         return false;
4459 
4460     Page* page = document-&gt;page();
4461     if (!page)
4462         return false;
4463 
4464     return page-&gt;pointerLockController().lockPending();
4465 }
4466 
4467 bool Internals::pageHasPointerLock() const
4468 {
4469     Document* document = contextDocument();
4470     if (!document)
4471         return false;
4472 
4473     Page* page = document-&gt;page();
4474     if (!page)
4475         return false;
4476 
4477     auto&amp; controller = page-&gt;pointerLockController();
4478     return controller.element() &amp;&amp; !controller.lockPending();
4479 }
4480 #endif
4481 
4482 void Internals::markContextAsInsecure()
4483 {
4484     auto* document = contextDocument();
4485     if (!document)
4486         return;
4487 
4488     document-&gt;securityOrigin().setIsPotentiallyTrustworthy(false);
4489 }
4490 
4491 void Internals::postTask(RefPtr&lt;VoidCallback&gt;&amp;&amp; callback)
4492 {
4493     auto* document = contextDocument();
4494     if (!document) {
4495         callback-&gt;handleEvent();
4496         return;
4497     }
4498 
4499     document-&gt;postTask([callback = WTFMove(callback)](ScriptExecutionContext&amp;) {
4500         callback-&gt;handleEvent();
4501     });
4502 }
4503 
4504 Vector&lt;String&gt; Internals::accessKeyModifiers() const
4505 {
4506     Vector&lt;String&gt; accessKeyModifierStrings;
4507 
4508     for (auto modifier : EventHandler::accessKeyModifiers()) {
4509         switch (modifier) {
4510         case PlatformEvent::Modifier::AltKey:
4511             accessKeyModifierStrings.append(&quot;altKey&quot;_s);
4512             break;
4513         case PlatformEvent::Modifier::ControlKey:
4514             accessKeyModifierStrings.append(&quot;ctrlKey&quot;_s);
4515             break;
4516         case PlatformEvent::Modifier::MetaKey:
4517             accessKeyModifierStrings.append(&quot;metaKey&quot;_s);
4518             break;
4519         case PlatformEvent::Modifier::ShiftKey:
4520             accessKeyModifierStrings.append(&quot;shiftKey&quot;_s);
4521             break;
4522         case PlatformEvent::Modifier::CapsLockKey:
4523             accessKeyModifierStrings.append(&quot;capsLockKey&quot;_s);
4524             break;
4525         case PlatformEvent::Modifier::AltGraphKey:
4526             ASSERT_NOT_REACHED(); // AltGraph is only for DOM API.
4527             break;
4528         }
4529     }
4530 
4531     return accessKeyModifierStrings;
4532 }
4533 
4534 void Internals::setQuickLookPassword(const String&amp; password)
4535 {
4536 #if PLATFORM(IOS_FAMILY) &amp;&amp; USE(QUICK_LOOK)
4537     auto&amp; quickLookHandleClient = MockPreviewLoaderClient::singleton();
4538     PreviewLoader::setClientForTesting(&amp;quickLookHandleClient);
4539     quickLookHandleClient.setPassword(password);
4540 #else
4541     UNUSED_PARAM(password);
4542 #endif
4543 }
4544 
4545 void Internals::setAsRunningUserScripts(Document&amp; document)
4546 {
<a name="80" id="anc80"></a><span class="line-modified">4547     document.topDocument().setAsRunningUserScripts();</span>






4548 }
<a name="81" id="anc81"></a>
4549 
4550 #if ENABLE(WEBGL)
4551 void Internals::simulateWebGLContextChanged(WebGLRenderingContext&amp; context)
4552 {
4553     context.simulateContextChanged();
4554 }
4555 
4556 void Internals::failNextGPUStatusCheck(WebGLRenderingContext&amp; context)
4557 {
4558     context.setFailNextGPUStatusCheck();
4559 }
4560 
4561 bool Internals::hasLowAndHighPowerGPUs()
4562 {
4563 #if PLATFORM(MAC)
4564     return WebCore::hasLowAndHighPowerGPUs();
4565 #else
4566     return false;
4567 #endif
4568 }
4569 #endif
4570 
4571 void Internals::setPageVisibility(bool isVisible)
4572 {
4573     auto* document = contextDocument();
4574     if (!document || !document-&gt;page())
4575         return;
4576     auto&amp; page = *document-&gt;page();
4577     auto state = page.activityState();
4578 
4579     if (!isVisible)
4580         state.remove(ActivityState::IsVisible);
4581     else
4582         state.add(ActivityState::IsVisible);
4583 
4584     page.setActivityState(state);
4585 }
4586 
4587 void Internals::setPageIsFocusedAndActive(bool isFocusedAndActive)
4588 {
4589     auto* document = contextDocument();
4590     if (!document || !document-&gt;page())
4591         return;
4592     auto&amp; page = *document-&gt;page();
4593     auto state = page.activityState();
4594 
4595     if (!isFocusedAndActive)
4596         state.remove({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4597     else
4598         state.add({ ActivityState::IsFocused, ActivityState::WindowIsActive });
4599 
4600     page.setActivityState(state);
4601 }
4602 
4603 #if ENABLE(WEB_RTC)
4604 void Internals::setH264HardwareEncoderAllowed(bool allowed)
4605 {
4606     auto* document = contextDocument();
4607     if (!document || !document-&gt;page())
4608         return;
4609     document-&gt;page()-&gt;libWebRTCProvider().setH264HardwareEncoderAllowed(allowed);
4610 }
4611 #endif
4612 
4613 #if ENABLE(MEDIA_STREAM)
<a name="82" id="anc82"></a>






4614 
4615 void Internals::setCameraMediaStreamTrackOrientation(MediaStreamTrack&amp; track, int orientation)
4616 {
4617     auto&amp; source = track.source();
4618     if (!source.isCaptureSource())
4619         return;
4620     m_orientationNotifier.orientationChanged(orientation);
4621     source.monitorOrientation(m_orientationNotifier);
4622 }
4623 
4624 void Internals::observeMediaStreamTrack(MediaStreamTrack&amp; track)
4625 {
4626     m_track = &amp;track;
4627     m_track-&gt;source().addObserver(*this);
4628 }
4629 
4630 void Internals::grabNextMediaStreamTrackFrame(TrackFramePromise&amp;&amp; promise)
4631 {
4632     m_nextTrackFramePromise = WTFMove(promise);
4633 }
4634 
4635 void Internals::videoSampleAvailable(MediaSample&amp; sample)
4636 {
4637     m_trackVideoSampleCount++;
4638     if (!m_nextTrackFramePromise)
4639         return;
4640 
4641     auto&amp; videoSettings = m_track-&gt;source().settings();
4642     if (!videoSettings.width() || !videoSettings.height())
4643         return;
4644 
4645     auto rgba = sample.getRGBAImageData();
4646     if (!rgba)
4647         return;
4648 
4649     auto imageData = ImageData::create(rgba.releaseNonNull(), videoSettings.width(), videoSettings.height());
4650     if (!imageData.hasException())
4651         m_nextTrackFramePromise-&gt;resolve(imageData.releaseReturnValue().releaseNonNull());
4652     else
4653         m_nextTrackFramePromise-&gt;reject(imageData.exception().code());
4654     m_nextTrackFramePromise = WTF::nullopt;
4655 }
4656 
4657 void Internals::delayMediaStreamTrackSamples(MediaStreamTrack&amp; track, float delay)
4658 {
4659     track.source().delaySamples(Seconds { delay });
4660 }
4661 
4662 void Internals::setMediaStreamTrackMuted(MediaStreamTrack&amp; track, bool muted)
4663 {
4664     track.source().setMuted(muted);
4665 }
4666 
4667 void Internals::removeMediaStreamTrack(MediaStream&amp; stream, MediaStreamTrack&amp; track)
4668 {
4669     stream.internalRemoveTrack(track.id(), MediaStream::StreamModifier::Platform);
4670 }
4671 
4672 void Internals::simulateMediaStreamTrackCaptureSourceFailure(MediaStreamTrack&amp; track)
4673 {
4674     track.source().captureFailed();
4675 }
4676 
4677 void Internals::setMediaStreamTrackIdentifier(MediaStreamTrack&amp; track, String&amp;&amp; id)
4678 {
4679     track.setIdForTesting(WTFMove(id));
4680 }
4681 
4682 void Internals::setMediaStreamSourceInterrupted(MediaStreamTrack&amp; track, bool interrupted)
4683 {
4684     track.source().setInterruptedForTesting(interrupted);
4685 }
4686 
<a name="83" id="anc83"></a>








4687 #endif
4688 
4689 String Internals::audioSessionCategory() const
4690 {
4691 #if USE(AUDIO_SESSION)
4692     switch (AudioSession::sharedSession().category()) {
4693     case AudioSession::AmbientSound:
4694         return &quot;AmbientSound&quot;_s;
4695     case AudioSession::SoloAmbientSound:
4696         return &quot;SoloAmbientSound&quot;_s;
4697     case AudioSession::MediaPlayback:
4698         return &quot;MediaPlayback&quot;_s;
4699     case AudioSession::RecordAudio:
4700         return &quot;RecordAudio&quot;_s;
4701     case AudioSession::PlayAndRecord:
4702         return &quot;PlayAndRecord&quot;_s;
4703     case AudioSession::AudioProcessing:
4704         return &quot;AudioProcessing&quot;_s;
4705     case AudioSession::None:
4706         return &quot;None&quot;_s;
4707     }
4708 #endif
4709     return emptyString();
4710 }
4711 
4712 double Internals::preferredAudioBufferSize() const
4713 {
4714 #if USE(AUDIO_SESSION)
4715     return AudioSession::sharedSession().preferredBufferSize();
4716 #endif
4717     return 0;
4718 }
4719 
4720 bool Internals::audioSessionActive() const
4721 {
4722 #if USE(AUDIO_SESSION)
4723     return AudioSession::sharedSession().isActive();
4724 #endif
4725     return false;
4726 }
4727 
<a name="84" id="anc84"></a>














4728 void Internals::clearCacheStorageMemoryRepresentation(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
4729 {
4730     auto* document = contextDocument();
4731     if (!document)
4732         return;
4733 
4734     if (!m_cacheStorageConnection) {
4735         if (auto* page = contextDocument()-&gt;page())
4736             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4737         if (!m_cacheStorageConnection)
4738             return;
4739     }
4740     m_cacheStorageConnection-&gt;clearMemoryRepresentation(ClientOrigin { document-&gt;topOrigin().data(), document-&gt;securityOrigin().data() }, [promise = WTFMove(promise)] (auto &amp;&amp; result) mutable {
4741         ASSERT_UNUSED(result, !result);
4742         promise.resolve();
4743     });
4744 }
4745 
4746 void Internals::cacheStorageEngineRepresentation(DOMPromiseDeferred&lt;IDLDOMString&gt;&amp;&amp; promise)
4747 {
4748     auto* document = contextDocument();
4749     if (!document)
4750         return;
4751 
4752     if (!m_cacheStorageConnection) {
4753         if (auto* page = contextDocument()-&gt;page())
4754             m_cacheStorageConnection = page-&gt;cacheStorageProvider().createCacheStorageConnection(page-&gt;sessionID());
4755         if (!m_cacheStorageConnection)
4756             return;
4757     }
4758     m_cacheStorageConnection-&gt;engineRepresentation([promise = WTFMove(promise)](const String&amp; result) mutable {
4759         promise.resolve(result);
4760     });
4761 }
4762 
<a name="85" id="anc85"></a>















4763 void Internals::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
4764 {
4765     if (!contextDocument())
4766         return;
4767 
4768     contextDocument()-&gt;setConsoleMessageListener(WTFMove(listener));
4769 }
4770 
4771 void Internals::setResponseSizeWithPadding(FetchResponse&amp; response, uint64_t size)
4772 {
4773     response.setBodySizeWithPadding(size);
4774 }
4775 
4776 uint64_t Internals::responseSizeWithPadding(FetchResponse&amp; response) const
4777 {
4778     return response.bodySizeWithPadding();
4779 }
4780 
4781 #if ENABLE(SERVICE_WORKER)
4782 void Internals::hasServiceWorkerRegistration(const String&amp; clientURL, HasRegistrationPromise&amp;&amp; promise)
4783 {
4784     if (!contextDocument())
4785         return;
4786 
4787     URL parsedURL = contextDocument()-&gt;completeURL(clientURL);
4788 
4789     return ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).matchRegistration(SecurityOriginData { contextDocument()-&gt;topOrigin().data() }, parsedURL, [promise = WTFMove(promise)] (auto&amp;&amp; result) mutable {
4790         promise.resolve(!!result);
4791     });
4792 }
4793 
4794 void Internals::terminateServiceWorker(ServiceWorker&amp; worker)
4795 {
4796     if (!contextDocument())
4797         return;
4798 
4799     ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(contextDocument()-&gt;sessionID()).syncTerminateWorker(worker.identifier());
4800 }
4801 
4802 bool Internals::hasServiceWorkerConnection()
4803 {
4804     if (!contextDocument())
4805         return false;
4806 
4807     return ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(contextDocument()-&gt;sessionID());
4808 }
4809 #endif
4810 
4811 #if ENABLE(APPLE_PAY)
4812 MockPaymentCoordinator&amp; Internals::mockPaymentCoordinator(Document&amp; document)
4813 {
4814     return downcast&lt;MockPaymentCoordinator&gt;(document.frame()-&gt;page()-&gt;paymentCoordinator().client());
4815 }
4816 #endif
4817 
4818 bool Internals::isSystemPreviewLink(Element&amp; element) const
4819 {
4820 #if USE(SYSTEM_PREVIEW)
4821     return is&lt;HTMLAnchorElement&gt;(element) &amp;&amp; downcast&lt;HTMLAnchorElement&gt;(element).isSystemPreviewLink();
4822 #else
4823     UNUSED_PARAM(element);
4824     return false;
4825 #endif
4826 }
4827 
4828 bool Internals::isSystemPreviewImage(Element&amp; element) const
4829 {
4830 #if USE(SYSTEM_PREVIEW)
4831     if (is&lt;HTMLImageElement&gt;(element))
4832         return downcast&lt;HTMLImageElement&gt;(element).isSystemPreviewImage();
4833     if (is&lt;HTMLPictureElement&gt;(element))
4834         return downcast&lt;HTMLPictureElement&gt;(element).isSystemPreviewImage();
4835     return false;
4836 #else
4837     UNUSED_PARAM(element);
4838     return false;
4839 #endif
4840 }
4841 
4842 bool Internals::usingAppleInternalSDK() const
4843 {
4844 #if USE(APPLE_INTERNAL_SDK)
4845     return true;
4846 #else
4847     return false;
4848 #endif
4849 }
4850 
4851 void Internals::setCaptureExtraNetworkLoadMetricsEnabled(bool value)
4852 {
4853     platformStrategies()-&gt;loaderStrategy()-&gt;setCaptureExtraNetworkLoadMetricsEnabled(value);
4854 }
4855 
4856 String Internals::ongoingLoadsDescriptions() const
4857 {
4858     StringBuilder builder;
4859     builder.append(&#39;[&#39;);
4860     bool isStarting = true;
4861     for (auto&amp; identifier : platformStrategies()-&gt;loaderStrategy()-&gt;ongoingLoads()) {
4862         if (isStarting)
4863             isStarting = false;
4864         else
4865             builder.append(&#39;,&#39;);
4866 
4867         builder.append(&#39;[&#39;);
4868 
4869         for (auto&amp; info : platformStrategies()-&gt;loaderStrategy()-&gt;intermediateLoadInformationFromResourceLoadIdentifier(identifier))
<a name="86" id="anc86"></a><span class="line-modified">4870             builder.append(makeString(&quot;[&quot;, (int)info.type, &quot;,\&quot;&quot;, info.request.url().string(), &quot;\&quot;,\&quot;&quot;, info.request.httpMethod(), &quot;\&quot;,&quot;, info.response.httpStatusCode(), &quot;]&quot;));</span>
4871 
4872         builder.append(&#39;]&#39;);
4873     }
4874     builder.append(&#39;]&#39;);
4875     return builder.toString();
4876 }
4877 
4878 void Internals::reloadWithoutContentExtensions()
4879 {
4880     if (auto* frame = this-&gt;frame())
4881         frame-&gt;loader().reload(ReloadOption::DisableContentBlockers);
4882 }
4883 
4884 void Internals::setUseSystemAppearance(bool value)
4885 {
4886     if (!contextDocument() || !contextDocument()-&gt;page())
4887         return;
4888     contextDocument()-&gt;page()-&gt;setUseSystemAppearance(value);
4889 }
4890 
4891 size_t Internals::pluginCount()
4892 {
4893     if (!contextDocument() || !contextDocument()-&gt;page())
4894         return 0;
4895 
4896     return contextDocument()-&gt;page()-&gt;pluginData().webVisiblePlugins().size();
4897 }
4898 
4899 void Internals::notifyResourceLoadObserver()
4900 {
<a name="87" id="anc87"></a><span class="line-modified">4901     ResourceLoadObserver::shared().notifyObserver();</span>
4902 }
4903 
4904 unsigned Internals::primaryScreenDisplayID()
4905 {
4906 #if PLATFORM(MAC)
4907     return WebCore::primaryScreenDisplayID();
4908 #else
4909     return 0;
4910 #endif
4911 }
4912 
4913 bool Internals::capsLockIsOn()
4914 {
4915     return WebCore::PlatformKeyboardEvent::currentCapsLockState();
4916 }
4917 
4918 bool Internals::supportsVCPEncoder()
4919 {
4920 #if defined(ENABLE_VCP_ENCODER)
<a name="88" id="anc88"></a><span class="line-modified">4921     return ENABLE_VCP_ENCODER;</span>
4922 #else
4923     return false;
4924 #endif
4925 }
4926 
4927 Optional&lt;HEVCParameterSet&gt; Internals::parseHEVCCodecParameters(const String&amp; codecString)
4928 {
4929     return WebCore::parseHEVCCodecParameters(codecString);
4930 }
4931 
4932 auto Internals::getCookies() const -&gt; Vector&lt;CookieData&gt;
4933 {
4934     auto* document = contextDocument();
4935     if (!document)
4936         return { };
4937 
4938     auto* page = document-&gt;page();
4939     if (!page)
4940         return { };
4941 
4942     Vector&lt;Cookie&gt; cookies;
4943     page-&gt;cookieJar().getRawCookies(*document, document-&gt;cookieURL(), cookies);
4944     return WTF::map(cookies, [](auto&amp; cookie) {
4945         return CookieData { cookie };
4946     });
4947 }
4948 
4949 void Internals::setAlwaysAllowLocalWebarchive(bool alwaysAllowLocalWebarchive)
4950 {
4951     auto* localFrame = frame();
4952     if (!localFrame)
4953         return;
4954     localFrame-&gt;loader().setAlwaysAllowLocalWebarchive(alwaysAllowLocalWebarchive);
4955 }
4956 
<a name="89" id="anc89"></a>































































4957 } // namespace WebCore
<a name="90" id="anc90"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="90" type="hidden" />
</body>
</html>