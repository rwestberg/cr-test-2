<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSAsyncGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42  * license that can be found in the LICENSE file [3].
  43  *
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
<span class="line-modified">  62 const ClassInfo JSBigInt::s_info =</span>
<span class="line-removed">  63     { &quot;JSBigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };</span>
  64 
  65 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, unsigned length)
  66     : Base(vm, structure)
  67     , m_length(length)
  68 { }
  69 
  70 void JSBigInt::initialize(InitializationType initType)
  71 {
  72     if (initType == InitializationType::WithZero)
  73         memset(dataStorage(), 0, length() * sizeof(Digit));
  74 }
  75 
  76 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  77 {
  78     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  79 }
  80 
  81 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  82 {
  83     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
</pre>
<hr />
<pre>
 209 }
 210 
 211 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)
 212 {
 213     if (s.is8Bit())
 214         return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 215     return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 216 }
 217 
 218 JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)
 219 {
 220     return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);
 221 }
 222 
 223 String JSBigInt::toString(ExecState* exec, unsigned radix)
 224 {
 225     if (this-&gt;isZero())
 226         return exec-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);
 227 
 228     if (hasOneBitSet(radix))
<span class="line-modified"> 229         return toStringBasePowerOfTwo(exec, this, radix);</span>
 230 
<span class="line-modified"> 231     return toStringGeneric(exec, this, radix);</span>











 232 }
 233 
 234 // Multiplies {this} with {factor} and adds {summand} to the result.
 235 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 236 {
 237     internalMultiplyAdd(this, factor, summand, length(), this);
 238 }
 239 

























































































 240 JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)
 241 {
 242     VM&amp; vm = exec-&gt;vm();
 243     auto scope = DECLARE_THROW_SCOPE(vm);
 244 
 245     if (x-&gt;isZero())
 246         return x;
 247     if (y-&gt;isZero())
 248         return y;
 249 
 250     unsigned resultLength = x-&gt;length() + y-&gt;length();
 251     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);
 252     RETURN_IF_EXCEPTION(scope, nullptr);
 253     result-&gt;initialize(InitializationType::WithZero);
 254 
 255     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 256         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 257 
 258     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 259     return result-&gt;rightTrim(vm);
</pre>
<hr />
<pre>
 508     if (y-&gt;isZero() || x-&gt;isZero())
 509         return x;
 510 
 511     if (y-&gt;sign())
 512         return rightShiftByAbsolute(exec, x, y);
 513 
 514     return leftShiftByAbsolute(exec, x, y);
 515 }
 516 
 517 JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
 518 {
 519     if (y-&gt;isZero() || x-&gt;isZero())
 520         return x;
 521 
 522     if (y-&gt;sign())
 523         return leftShiftByAbsolute(exec, x, y);
 524 
 525     return rightShiftByAbsolute(exec, x, y);
 526 }
 527 










 528 #if USE(JSVALUE32_64)
 529 #define HAVE_TWO_DIGIT 1
 530 typedef uint64_t TwoDigit;
 531 #elif HAVE(INT128_T)
 532 #define HAVE_TWO_DIGIT 1
 533 typedef __uint128_t TwoDigit;
 534 #else
 535 #define HAVE_TWO_DIGIT 0
 536 #endif
 537 
 538 // {carry} must point to an initialized Digit and will either be incremented
 539 // by one or left alone.
 540 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 541 {
 542     Digit result = a + b;
 543     carry += static_cast&lt;bool&gt;(result &lt; a);
 544     return result;
 545 }
 546 
 547 // {borrow} must point to an initialized Digit and will either be incremented
</pre>
<hr />
<pre>
 620         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 621         // Inputs: put {high} into rdx, {low} into rax, and {divisor} into
 622         // any register or stack slot.
 623         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 624     remainder = rem;
 625     return quotient;
 626 #elif CPU(X86) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 627     Digit quotient;
 628     Digit rem;
 629     __asm__(&quot;divl  %[divisor]&quot;
 630         // Outputs: {quotient} will be in eax, {rem} in edx.
 631         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 632         // Inputs: put {high} into edx, {low} into eax, and {divisor} into
 633         // any register or stack slot.
 634         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 635     remainder = rem;
 636     return quotient;
 637 #else
 638     static constexpr Digit halfDigitBase = 1ull &lt;&lt; halfDigitBits;
 639     // Adapted from Warren, Hacker&#39;s Delight, p. 152.
<span class="line-modified"> 640 #if USE(JSVALUE64)</span>
<span class="line-removed"> 641     unsigned s = clz64(divisor);</span>
<span class="line-removed"> 642 #else</span>
<span class="line-removed"> 643     unsigned s = clz32(divisor);</span>
<span class="line-removed"> 644 #endif</span>
 645     // If {s} is digitBits here, it causes an undefined behavior.
 646     // But {s} is never digitBits since {divisor} is never zero here.
 647     ASSERT(s != digitBits);
 648     divisor &lt;&lt;= s;
 649 
 650     Digit vn1 = divisor &gt;&gt; halfDigitBits;
 651     Digit vn0 = divisor &amp; halfDigitMask;
 652 
 653     // {sZeroMask} which is 0 if s == 0 and all 1-bits otherwise.
 654     // {s} can be 0. If {s} is 0, performing &quot;low &gt;&gt; (digitBits - s)&quot; must not be done since it causes an undefined behavior
 655     // since `&gt;&gt; digitBits` is undefied in C++. Quoted from C++ spec, &quot;The type of the result is that of the promoted left operand.
 656     // The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted
 657     // left operand&quot;. We mask the right operand of the shift by {shiftMask} (`digitBits - 1`), which makes `digitBits - 0` zero.
 658     // This shifting produces a value which covers 0 &lt; {s} &lt;= (digitBits - 1) cases. {s} == digitBits never happen as we asserted.
 659     // Since {sZeroMask} clears the value in the case of {s} == 0, {s} == 0 case is also covered.
 660     STATIC_ASSERT(sizeof(CPURegister) == sizeof(Digit));
 661     Digit sZeroMask = static_cast&lt;Digit&gt;((-static_cast&lt;CPURegister&gt;(s)) &gt;&gt; (digitBits - 1));
 662     static constexpr unsigned shiftMask = digitBits - 1;
 663     Digit un32 = (high &lt;&lt; s) | ((low &gt;&gt; ((digitBits - s) &amp; shiftMask)) &amp; sZeroMask);
 664 
</pre>
<hr />
<pre>
 957     // come up with more descriptive names for them.
 958     unsigned n = divisor-&gt;length();
 959     unsigned m = dividend-&gt;length() - n;
 960 
 961     // The quotient to be computed.
 962     JSBigInt* q = nullptr;
 963     if (quotient != nullptr)
 964         q = createWithLengthUnchecked(exec-&gt;vm(), m + 1);
 965 
 966     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
 967     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
 968     JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);
 969     RETURN_IF_EXCEPTION(scope, void());
 970 
 971     // D1.
 972     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
 973     // to prevent the digit-wise divisions (see digit_div call below) from
 974     // overflowing (they take a two digits wide input, and return a one digit
 975     // result).
 976     Digit lastDigit = divisor-&gt;digit(n - 1);
<span class="line-modified"> 977     unsigned shift = sizeof(lastDigit) == 8 ? clz64(lastDigit) : clz32(lastDigit);</span>
 978 
 979     if (shift &gt; 0) {
 980         divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);
 981         RETURN_IF_EXCEPTION(scope, void());
 982     }
 983 
 984     // Holds the (continuously updated) remaining part of the dividend, which
 985     // eventually becomes the remainder.
 986     JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);
 987     RETURN_IF_EXCEPTION(scope, void());
 988 
 989     // D2.
 990     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
 991     // {vn1} is the divisor&#39;s most significant digit.
 992     Digit vn1 = divisor-&gt;digit(n - 1);
 993     for (int j = m; j &gt;= 0; j--) {
 994         // D3.
 995         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
 996         // {qhat} is the current quotient digit.
 997         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
</pre>
<hr />
<pre>
1032             c = u-&gt;absoluteInplaceAdd(divisor, j);
1033             u-&gt;setDigit(j + n, u-&gt;digit(j + n) + c);
1034             qhat--;
1035         }
1036 
1037         if (quotient != nullptr)
1038             q-&gt;setDigit(j, qhat);
1039     }
1040 
1041     if (quotient != nullptr) {
1042         // Caller will right-trim.
1043         *quotient = q;
1044     }
1045 
1046     if (remainder != nullptr) {
1047         u-&gt;inplaceRightShift(shift);
1048         *remainder = u;
1049     }
1050 }
1051 
<span class="line-modified">1052 // Returns whether (factor1 * factor2) &gt; (high &lt;&lt; kDigitBits) + low.</span>
1053 inline bool JSBigInt::productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low)
1054 {
1055     Digit resultHigh;
1056     Digit resultLow = digitMul(factor1, factor2, resultHigh);
1057     return resultHigh &gt; high || (resultHigh == high &amp;&amp; resultLow &gt; low);
1058 }
1059 
1060 // Adds {summand} onto {this}, starting with {summand}&#39;s 0th digit
1061 // at {this}&#39;s {startIndex}&#39;th digit. Returns the &quot;carry&quot; (0 or 1).
1062 JSBigInt::Digit JSBigInt::absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex)
1063 {
1064     Digit carry = 0;
1065     unsigned n = summand-&gt;length();
1066     ASSERT(length() &gt;= startIndex + n);
1067     for (unsigned i = 0; i &lt; n; i++) {
1068         Digit newCarry = 0;
1069         Digit sum = digitAdd(digit(startIndex + i), summand-&gt;digit(i), newCarry);
1070         sum = digitAdd(sum, carry, newCarry);
1071         setDigit(startIndex + i, sum);
1072         carry = newCarry;
</pre>
<hr />
<pre>
1418 
1419 // Lookup table for the maximum number of bits required per character of a
1420 // base-N string representation of a number. To increase accuracy, the array
1421 // value is the actual value multiplied by 32. To generate this table:
1422 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1423 constexpr uint8_t maxBitsPerCharTable[] = {
1424     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
1425     102, 107, 111, 115, 119, 122, 126, 128,     // 9..16
1426     131, 134, 136, 139, 141, 143, 145, 147,     // 17..24
1427     149, 151, 153, 154, 156, 158, 159, 160,     // 25..32
1428     162, 163, 165, 166,                         // 33..36
1429 };
1430 
1431 static constexpr unsigned bitsPerCharTableShift = 5;
1432 static constexpr size_t bitsPerCharTableMultiplier = 1u &lt;&lt; bitsPerCharTableShift;
1433 
1434 // Compute (an overapproximation of) the length of the resulting string:
1435 // Divide bit length of the BigInt by bits representable per character.
1436 uint64_t JSBigInt::calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign)
1437 {
<span class="line-modified">1438     unsigned leadingZeros;</span>
<span class="line-removed">1439     if (sizeof(lastDigit) == 8)</span>
<span class="line-removed">1440         leadingZeros = clz64(lastDigit);</span>
<span class="line-removed">1441     else</span>
<span class="line-removed">1442         leadingZeros = clz32(lastDigit);</span>
1443 
1444     size_t bitLength = length * digitBits - leadingZeros;
1445 
1446     // Maximum number of bits we can represent with one character. We&#39;ll use this
1447     // to find an appropriate chunk size below.
1448     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1449 
1450     // For estimating result length, we have to be pessimistic and work with
1451     // the minimum number of bits one character can represent.
1452     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1453 
1454     // Perform the following computation with uint64_t to avoid overflows.
1455     uint64_t maximumCharactersRequired = bitLength;
1456     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1457 
1458     // Round up.
1459     maximumCharactersRequired += minBitsPerChar - 1;
1460     maximumCharactersRequired /= minBitsPerChar;
1461     maximumCharactersRequired += sign;
1462 
1463     return maximumCharactersRequired;
1464 }
1465 
<span class="line-modified">1466 String JSBigInt::toStringBasePowerOfTwo(ExecState* exec, JSBigInt* x, unsigned radix)</span>
1467 {
1468     ASSERT(hasOneBitSet(radix));
1469     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1470     ASSERT(!x-&gt;isZero());
<span class="line-removed">1471     VM&amp; vm = exec-&gt;vm();</span>
1472 
1473     const unsigned length = x-&gt;length();
1474     const bool sign = x-&gt;sign();
<span class="line-modified">1475     const unsigned bitsPerChar = ctz32(radix);</span>
1476     const unsigned charMask = radix - 1;
1477     // Compute the length of the resulting string: divide the bit length of the
1478     // BigInt by the number of bits representable per character (rounding up).
1479     const Digit msd = x-&gt;digit(length - 1);
1480 
<span class="line-modified">1481 #if USE(JSVALUE64)</span>
<span class="line-removed">1482     const unsigned msdLeadingZeros = clz64(msd);</span>
<span class="line-removed">1483 #else</span>
<span class="line-removed">1484     const unsigned msdLeadingZeros = clz32(msd);</span>
<span class="line-removed">1485 #endif</span>
1486 
1487     const size_t bitLength = length * digitBits - msdLeadingZeros;
1488     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1489 
1490     if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">1491         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified">1492         throwOutOfMemoryError(exec, scope);</span>


1493         return String();
1494     }
1495 
1496     Vector&lt;LChar&gt; resultString(charsRequired);
1497     Digit digit = 0;
1498     // Keeps track of how many unprocessed bits there are in {digit}.
1499     unsigned availableBits = 0;
1500     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1501     for (unsigned i = 0; i &lt; length - 1; i++) {
1502         Digit newDigit = x-&gt;digit(i);
1503         // Take any leftover bits from the last iteration into account.
1504         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1505         resultString[pos--] = radixDigits[current];
1506         int consumedBits = bitsPerChar - availableBits;
1507         digit = newDigit &gt;&gt; consumedBits;
1508         availableBits = digitBits - consumedBits;
1509         while (availableBits &gt;= bitsPerChar) {
1510             resultString[pos--] = radixDigits[digit &amp; charMask];
1511             digit &gt;&gt;= bitsPerChar;
1512             availableBits -= bitsPerChar;
1513         }
1514     }
1515     // Take any leftover bits from the last iteration into account.
1516     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1517     resultString[pos--] = radixDigits[current];
1518     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1519     while (digit) {
1520         resultString[pos--] = radixDigits[digit &amp; charMask];
1521         digit &gt;&gt;= bitsPerChar;
1522     }
1523 
1524     if (sign)
1525         resultString[pos--] = &#39;-&#39;;
1526 
1527     ASSERT(pos == -1);
1528     return StringImpl::adopt(WTFMove(resultString));
1529 }
1530 
<span class="line-modified">1531 String JSBigInt::toStringGeneric(ExecState* exec, JSBigInt* x, unsigned radix)</span>
1532 {
1533     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1534     // https://bugs.webkit.org/show_bug.cgi?id=18067
1535     Vector&lt;LChar&gt; resultString;
1536 
<span class="line-removed">1537     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1538 </span>
1539     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1540     ASSERT(!x-&gt;isZero());
1541 
1542     unsigned length = x-&gt;length();
1543     bool sign = x-&gt;sign();
1544 
1545     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1546     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1547 
1548     if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">1549         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified">1550         throwOutOfMemoryError(exec, scope);</span>


1551         return String();
1552     }
1553 
1554     Digit lastDigit;
1555     if (length == 1)
1556         lastDigit = x-&gt;digit(0);
1557     else {
1558         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1559         Digit chunkDivisor = digitPow(radix, chunkChars);
1560 
1561         // By construction of chunkChars, there can&#39;t have been overflow.
1562         ASSERT(chunkDivisor);
1563         unsigned nonZeroDigit = length - 1;
1564         ASSERT(x-&gt;digit(nonZeroDigit));
1565 
1566         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1567         // Not to be confused with &quot;remainder&quot;!
1568         JSBigInt* rest = nullptr;
1569 
1570         // In the first round, divide the input, allocating a new BigInt for
</pre>
<hr />
<pre>
1849         ASSERT(!xSign);
1850         return x-&gt;isZero() ? ComparisonResult::Equal : ComparisonResult::GreaterThan;
1851     }
1852 
1853     if (x-&gt;isZero())
1854         return ComparisonResult::LessThan;
1855 
1856     uint64_t mantissa = doubleBits &amp; 0x000FFFFFFFFFFFFF;
1857 
1858     // Non-finite doubles are handled above.
1859     ASSERT(rawExponent != 0x7FF);
1860     int exponent = rawExponent - 0x3FF;
1861     if (exponent &lt; 0) {
1862         // The absolute value of the double is less than 1. Only 0n has an
1863         // absolute value smaller than that, but we&#39;ve already covered that case.
1864         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1865     }
1866 
1867     int xLength = x-&gt;length();
1868     Digit xMSD = x-&gt;digit(xLength - 1);
<span class="line-modified">1869     int msdLeadingZeros = sizeof(xMSD) == 8  ? clz64(xMSD) : clz32(xMSD);</span>
1870 
1871     int xBitLength = xLength * digitBits - msdLeadingZeros;
1872     int yBitLength = exponent + 1;
1873     if (xBitLength &lt; yBitLength)
1874         return xSign? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
1875 
1876     if (xBitLength &gt; yBitLength)
1877         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1878 
1879     // At this point, we know that signs and bit lengths (i.e. position of
1880     // the most significant bit in exponent-free representation) are identical.
1881     // {x} is not zero, {y} is finite and not denormal.
1882     // Now we virtually convert the double to an integer by shifting its
1883     // mantissa according to its exponent, so it will align with the BigInt {x},
1884     // and then we compare them bit for bit until we find a difference or the
1885     // least significant bit.
1886     //                    &lt;----- 52 ------&gt; &lt;-- virtual trailing zeroes --&gt;
1887     // y / mantissa:     1yyyyyyyyyyyyyyyyy 0000000000000000000000000000000
1888     // x / digits:    0001xxxx xxxxxxxx xxxxxxxx ...
1889     //                    &lt;--&gt;          &lt;------&gt;
</pre>
</td>
<td>
<hr />
<pre>
  42  * license that can be found in the LICENSE file [3].
  43  *
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
<span class="line-modified">  62 const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };</span>

  63 
  64 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, unsigned length)
  65     : Base(vm, structure)
  66     , m_length(length)
  67 { }
  68 
  69 void JSBigInt::initialize(InitializationType initType)
  70 {
  71     if (initType == InitializationType::WithZero)
  72         memset(dataStorage(), 0, length() * sizeof(Digit));
  73 }
  74 
  75 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  76 {
  77     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  78 }
  79 
  80 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  81 {
  82     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
</pre>
<hr />
<pre>
 208 }
 209 
 210 JSBigInt* JSBigInt::parseInt(ExecState* exec, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)
 211 {
 212     if (s.is8Bit())
 213         return parseInt(exec, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 214     return parseInt(exec, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);
 215 }
 216 
 217 JSBigInt* JSBigInt::stringToBigInt(ExecState* exec, StringView s)
 218 {
 219     return parseInt(exec, s, ErrorParseMode::IgnoreExceptions);
 220 }
 221 
 222 String JSBigInt::toString(ExecState* exec, unsigned radix)
 223 {
 224     if (this-&gt;isZero())
 225         return exec-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);
 226 
 227     if (hasOneBitSet(radix))
<span class="line-modified"> 228         return toStringBasePowerOfTwo(exec-&gt;vm(), exec, this, radix);</span>
 229 
<span class="line-modified"> 230     return toStringGeneric(exec-&gt;vm(), exec, this, radix);</span>
<span class="line-added"> 231 }</span>
<span class="line-added"> 232 </span>
<span class="line-added"> 233 String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)</span>
<span class="line-added"> 234 {</span>
<span class="line-added"> 235     if (bigInt-&gt;isZero())</span>
<span class="line-added"> 236         return vm.smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
<span class="line-added"> 237 </span>
<span class="line-added"> 238     if (hasOneBitSet(radix))</span>
<span class="line-added"> 239         return toStringBasePowerOfTwo(vm, nullptr, bigInt, radix);</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241     return toStringGeneric(vm, nullptr, bigInt, radix);</span>
 242 }
 243 
 244 // Multiplies {this} with {factor} and adds {summand} to the result.
 245 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 246 {
 247     internalMultiplyAdd(this, factor, summand, length(), this);
 248 }
 249 
<span class="line-added"> 250 JSBigInt* JSBigInt::exponentiate(ExecState* exec, JSBigInt* base, JSBigInt* exponent)</span>
<span class="line-added"> 251 {</span>
<span class="line-added"> 252     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 253     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 254 </span>
<span class="line-added"> 255     if (exponent-&gt;sign()) {</span>
<span class="line-added"> 256         throwRangeError(exec, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
<span class="line-added"> 257         return nullptr;</span>
<span class="line-added"> 258     }</span>
<span class="line-added"> 259 </span>
<span class="line-added"> 260     // 2. If base is 0n and exponent is 0n, return 1n.</span>
<span class="line-added"> 261     if (exponent-&gt;isZero())</span>
<span class="line-added"> 262         return JSBigInt::createFrom(vm, 1);</span>
<span class="line-added"> 263 </span>
<span class="line-added"> 264     // 3. Return a BigInt representing the mathematical value of base raised</span>
<span class="line-added"> 265     //    to the power exponent.</span>
<span class="line-added"> 266     if (base-&gt;isZero())</span>
<span class="line-added"> 267         return base;</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 1) {</span>
<span class="line-added"> 270         // (-1) ** even_number == 1.</span>
<span class="line-added"> 271         if (base-&gt;sign() &amp;&amp; !(exponent-&gt;digit(0) &amp; 1))</span>
<span class="line-added"> 272             return JSBigInt::unaryMinus(vm, base);</span>
<span class="line-added"> 273 </span>
<span class="line-added"> 274         // (-1) ** odd_number == -1; 1 ** anything == 1.</span>
<span class="line-added"> 275         return base;</span>
<span class="line-added"> 276     }</span>
<span class="line-added"> 277 </span>
<span class="line-added"> 278     // For all bases &gt;= 2, very large exponents would lead to unrepresentable</span>
<span class="line-added"> 279     // results.</span>
<span class="line-added"> 280     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);</span>
<span class="line-added"> 281     if (exponent-&gt;length() &gt; 1) {</span>
<span class="line-added"> 282         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
<span class="line-added"> 283         return nullptr;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286     Digit expValue = exponent-&gt;digit(0);</span>
<span class="line-added"> 287     if (expValue == 1)</span>
<span class="line-added"> 288         return base;</span>
<span class="line-added"> 289     if (expValue &gt;= maxLengthBits) {</span>
<span class="line-added"> 290         throwRangeError(exec, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
<span class="line-added"> 291         return nullptr;</span>
<span class="line-added"> 292     }</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294     static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);</span>
<span class="line-added"> 295     int n = static_cast&lt;int&gt;(expValue);</span>
<span class="line-added"> 296     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {</span>
<span class="line-added"> 297         // Fast path for 2^n.</span>
<span class="line-added"> 298         int neededDigits = 1 + (n / digitBits);</span>
<span class="line-added"> 299         JSBigInt* result = JSBigInt::tryCreateWithLength(exec, neededDigits);</span>
<span class="line-added"> 300         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302         result-&gt;initialize(InitializationType::WithZero);</span>
<span class="line-added"> 303         // All bits are zero. Now set the n-th bit.</span>
<span class="line-added"> 304         Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);</span>
<span class="line-added"> 305         result-&gt;setDigit(neededDigits - 1, msd);</span>
<span class="line-added"> 306         // Result is negative for odd powers of -2n.</span>
<span class="line-added"> 307         if (base-&gt;sign())</span>
<span class="line-added"> 308             result-&gt;setSign(static_cast&lt;bool&gt;(n &amp; 1));</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310         return result;</span>
<span class="line-added"> 311     }</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313     JSBigInt* result = nullptr;</span>
<span class="line-added"> 314     JSBigInt* runningSquare = base;</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316     // This implicitly sets the result&#39;s sign correctly.</span>
<span class="line-added"> 317     if (n &amp; 1)</span>
<span class="line-added"> 318         result = base;</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320     n &gt;&gt;= 1;</span>
<span class="line-added"> 321     for (; n; n &gt;&gt;= 1) {</span>
<span class="line-added"> 322         JSBigInt* maybeResult = JSBigInt::multiply(exec, runningSquare, runningSquare);</span>
<span class="line-added"> 323         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 324         runningSquare = maybeResult;</span>
<span class="line-added"> 325         if (n &amp; 1) {</span>
<span class="line-added"> 326             if (!result)</span>
<span class="line-added"> 327                 result = runningSquare;</span>
<span class="line-added"> 328             else {</span>
<span class="line-added"> 329                 maybeResult = JSBigInt::multiply(exec, result, runningSquare);</span>
<span class="line-added"> 330                 RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 331                 result = maybeResult;</span>
<span class="line-added"> 332             }</span>
<span class="line-added"> 333         }</span>
<span class="line-added"> 334     }</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336     return result;</span>
<span class="line-added"> 337 }</span>
<span class="line-added"> 338 </span>
 339 JSBigInt* JSBigInt::multiply(ExecState* exec, JSBigInt* x, JSBigInt* y)
 340 {
 341     VM&amp; vm = exec-&gt;vm();
 342     auto scope = DECLARE_THROW_SCOPE(vm);
 343 
 344     if (x-&gt;isZero())
 345         return x;
 346     if (y-&gt;isZero())
 347         return y;
 348 
 349     unsigned resultLength = x-&gt;length() + y-&gt;length();
 350     JSBigInt* result = JSBigInt::tryCreateWithLength(exec, resultLength);
 351     RETURN_IF_EXCEPTION(scope, nullptr);
 352     result-&gt;initialize(InitializationType::WithZero);
 353 
 354     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 355         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 356 
 357     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 358     return result-&gt;rightTrim(vm);
</pre>
<hr />
<pre>
 607     if (y-&gt;isZero() || x-&gt;isZero())
 608         return x;
 609 
 610     if (y-&gt;sign())
 611         return rightShiftByAbsolute(exec, x, y);
 612 
 613     return leftShiftByAbsolute(exec, x, y);
 614 }
 615 
 616 JSBigInt* JSBigInt::signedRightShift(ExecState* exec, JSBigInt* x, JSBigInt* y)
 617 {
 618     if (y-&gt;isZero() || x-&gt;isZero())
 619         return x;
 620 
 621     if (y-&gt;sign())
 622         return leftShiftByAbsolute(exec, x, y);
 623 
 624     return rightShiftByAbsolute(exec, x, y);
 625 }
 626 
<span class="line-added"> 627 JSBigInt* JSBigInt::bitwiseNot(ExecState* exec, JSBigInt* x)</span>
<span class="line-added"> 628 {</span>
<span class="line-added"> 629     if (x-&gt;sign()) {</span>
<span class="line-added"> 630         // ~(-x) == ~(~(x-1)) == x-1</span>
<span class="line-added"> 631         return absoluteSubOne(exec, x, x-&gt;length());</span>
<span class="line-added"> 632     }</span>
<span class="line-added"> 633     // ~x == -x-1 == -(x+1)</span>
<span class="line-added"> 634     return absoluteAddOne(exec, x, SignOption::Signed);</span>
<span class="line-added"> 635 }</span>
<span class="line-added"> 636 </span>
 637 #if USE(JSVALUE32_64)
 638 #define HAVE_TWO_DIGIT 1
 639 typedef uint64_t TwoDigit;
 640 #elif HAVE(INT128_T)
 641 #define HAVE_TWO_DIGIT 1
 642 typedef __uint128_t TwoDigit;
 643 #else
 644 #define HAVE_TWO_DIGIT 0
 645 #endif
 646 
 647 // {carry} must point to an initialized Digit and will either be incremented
 648 // by one or left alone.
 649 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 650 {
 651     Digit result = a + b;
 652     carry += static_cast&lt;bool&gt;(result &lt; a);
 653     return result;
 654 }
 655 
 656 // {borrow} must point to an initialized Digit and will either be incremented
</pre>
<hr />
<pre>
 729         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 730         // Inputs: put {high} into rdx, {low} into rax, and {divisor} into
 731         // any register or stack slot.
 732         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 733     remainder = rem;
 734     return quotient;
 735 #elif CPU(X86) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 736     Digit quotient;
 737     Digit rem;
 738     __asm__(&quot;divl  %[divisor]&quot;
 739         // Outputs: {quotient} will be in eax, {rem} in edx.
 740         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 741         // Inputs: put {high} into edx, {low} into eax, and {divisor} into
 742         // any register or stack slot.
 743         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 744     remainder = rem;
 745     return quotient;
 746 #else
 747     static constexpr Digit halfDigitBase = 1ull &lt;&lt; halfDigitBits;
 748     // Adapted from Warren, Hacker&#39;s Delight, p. 152.
<span class="line-modified"> 749     unsigned s = clz(divisor);</span>




 750     // If {s} is digitBits here, it causes an undefined behavior.
 751     // But {s} is never digitBits since {divisor} is never zero here.
 752     ASSERT(s != digitBits);
 753     divisor &lt;&lt;= s;
 754 
 755     Digit vn1 = divisor &gt;&gt; halfDigitBits;
 756     Digit vn0 = divisor &amp; halfDigitMask;
 757 
 758     // {sZeroMask} which is 0 if s == 0 and all 1-bits otherwise.
 759     // {s} can be 0. If {s} is 0, performing &quot;low &gt;&gt; (digitBits - s)&quot; must not be done since it causes an undefined behavior
 760     // since `&gt;&gt; digitBits` is undefied in C++. Quoted from C++ spec, &quot;The type of the result is that of the promoted left operand.
 761     // The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted
 762     // left operand&quot;. We mask the right operand of the shift by {shiftMask} (`digitBits - 1`), which makes `digitBits - 0` zero.
 763     // This shifting produces a value which covers 0 &lt; {s} &lt;= (digitBits - 1) cases. {s} == digitBits never happen as we asserted.
 764     // Since {sZeroMask} clears the value in the case of {s} == 0, {s} == 0 case is also covered.
 765     STATIC_ASSERT(sizeof(CPURegister) == sizeof(Digit));
 766     Digit sZeroMask = static_cast&lt;Digit&gt;((-static_cast&lt;CPURegister&gt;(s)) &gt;&gt; (digitBits - 1));
 767     static constexpr unsigned shiftMask = digitBits - 1;
 768     Digit un32 = (high &lt;&lt; s) | ((low &gt;&gt; ((digitBits - s) &amp; shiftMask)) &amp; sZeroMask);
 769 
</pre>
<hr />
<pre>
1062     // come up with more descriptive names for them.
1063     unsigned n = divisor-&gt;length();
1064     unsigned m = dividend-&gt;length() - n;
1065 
1066     // The quotient to be computed.
1067     JSBigInt* q = nullptr;
1068     if (quotient != nullptr)
1069         q = createWithLengthUnchecked(exec-&gt;vm(), m + 1);
1070 
1071     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
1072     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
1073     JSBigInt* qhatv = tryCreateWithLength(exec, n + 1);
1074     RETURN_IF_EXCEPTION(scope, void());
1075 
1076     // D1.
1077     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
1078     // to prevent the digit-wise divisions (see digit_div call below) from
1079     // overflowing (they take a two digits wide input, and return a one digit
1080     // result).
1081     Digit lastDigit = divisor-&gt;digit(n - 1);
<span class="line-modified">1082     unsigned shift = clz(lastDigit);</span>
1083 
1084     if (shift &gt; 0) {
1085         divisor = absoluteLeftShiftAlwaysCopy(exec, divisor, shift, LeftShiftMode::SameSizeResult);
1086         RETURN_IF_EXCEPTION(scope, void());
1087     }
1088 
1089     // Holds the (continuously updated) remaining part of the dividend, which
1090     // eventually becomes the remainder.
1091     JSBigInt* u = absoluteLeftShiftAlwaysCopy(exec, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);
1092     RETURN_IF_EXCEPTION(scope, void());
1093 
1094     // D2.
1095     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
1096     // {vn1} is the divisor&#39;s most significant digit.
1097     Digit vn1 = divisor-&gt;digit(n - 1);
1098     for (int j = m; j &gt;= 0; j--) {
1099         // D3.
1100         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
1101         // {qhat} is the current quotient digit.
1102         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
</pre>
<hr />
<pre>
1137             c = u-&gt;absoluteInplaceAdd(divisor, j);
1138             u-&gt;setDigit(j + n, u-&gt;digit(j + n) + c);
1139             qhat--;
1140         }
1141 
1142         if (quotient != nullptr)
1143             q-&gt;setDigit(j, qhat);
1144     }
1145 
1146     if (quotient != nullptr) {
1147         // Caller will right-trim.
1148         *quotient = q;
1149     }
1150 
1151     if (remainder != nullptr) {
1152         u-&gt;inplaceRightShift(shift);
1153         *remainder = u;
1154     }
1155 }
1156 
<span class="line-modified">1157 // Returns whether (factor1 * factor2) &gt; (high &lt;&lt; digitBits) + low.</span>
1158 inline bool JSBigInt::productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low)
1159 {
1160     Digit resultHigh;
1161     Digit resultLow = digitMul(factor1, factor2, resultHigh);
1162     return resultHigh &gt; high || (resultHigh == high &amp;&amp; resultLow &gt; low);
1163 }
1164 
1165 // Adds {summand} onto {this}, starting with {summand}&#39;s 0th digit
1166 // at {this}&#39;s {startIndex}&#39;th digit. Returns the &quot;carry&quot; (0 or 1).
1167 JSBigInt::Digit JSBigInt::absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex)
1168 {
1169     Digit carry = 0;
1170     unsigned n = summand-&gt;length();
1171     ASSERT(length() &gt;= startIndex + n);
1172     for (unsigned i = 0; i &lt; n; i++) {
1173         Digit newCarry = 0;
1174         Digit sum = digitAdd(digit(startIndex + i), summand-&gt;digit(i), newCarry);
1175         sum = digitAdd(sum, carry, newCarry);
1176         setDigit(startIndex + i, sum);
1177         carry = newCarry;
</pre>
<hr />
<pre>
1523 
1524 // Lookup table for the maximum number of bits required per character of a
1525 // base-N string representation of a number. To increase accuracy, the array
1526 // value is the actual value multiplied by 32. To generate this table:
1527 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1528 constexpr uint8_t maxBitsPerCharTable[] = {
1529     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
1530     102, 107, 111, 115, 119, 122, 126, 128,     // 9..16
1531     131, 134, 136, 139, 141, 143, 145, 147,     // 17..24
1532     149, 151, 153, 154, 156, 158, 159, 160,     // 25..32
1533     162, 163, 165, 166,                         // 33..36
1534 };
1535 
1536 static constexpr unsigned bitsPerCharTableShift = 5;
1537 static constexpr size_t bitsPerCharTableMultiplier = 1u &lt;&lt; bitsPerCharTableShift;
1538 
1539 // Compute (an overapproximation of) the length of the resulting string:
1540 // Divide bit length of the BigInt by bits representable per character.
1541 uint64_t JSBigInt::calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign)
1542 {
<span class="line-modified">1543     unsigned leadingZeros = clz(lastDigit);</span>




1544 
1545     size_t bitLength = length * digitBits - leadingZeros;
1546 
1547     // Maximum number of bits we can represent with one character. We&#39;ll use this
1548     // to find an appropriate chunk size below.
1549     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1550 
1551     // For estimating result length, we have to be pessimistic and work with
1552     // the minimum number of bits one character can represent.
1553     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1554 
1555     // Perform the following computation with uint64_t to avoid overflows.
1556     uint64_t maximumCharactersRequired = bitLength;
1557     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1558 
1559     // Round up.
1560     maximumCharactersRequired += minBitsPerChar - 1;
1561     maximumCharactersRequired /= minBitsPerChar;
1562     maximumCharactersRequired += sign;
1563 
1564     return maximumCharactersRequired;
1565 }
1566 
<span class="line-modified">1567 String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
1568 {
1569     ASSERT(hasOneBitSet(radix));
1570     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1571     ASSERT(!x-&gt;isZero());

1572 
1573     const unsigned length = x-&gt;length();
1574     const bool sign = x-&gt;sign();
<span class="line-modified">1575     const unsigned bitsPerChar = ctz(radix);</span>
1576     const unsigned charMask = radix - 1;
1577     // Compute the length of the resulting string: divide the bit length of the
1578     // BigInt by the number of bits representable per character (rounding up).
1579     const Digit msd = x-&gt;digit(length - 1);
1580 
<span class="line-modified">1581     const unsigned msdLeadingZeros = clz(msd);</span>




1582 
1583     const size_t bitLength = length * digitBits - msdLeadingZeros;
1584     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1585 
1586     if (charsRequired &gt; JSString::MaxLength) {
<span class="line-modified">1587         if (exec) {</span>
<span class="line-modified">1588             auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">1589             throwOutOfMemoryError(exec, scope);</span>
<span class="line-added">1590         }</span>
1591         return String();
1592     }
1593 
1594     Vector&lt;LChar&gt; resultString(charsRequired);
1595     Digit digit = 0;
1596     // Keeps track of how many unprocessed bits there are in {digit}.
1597     unsigned availableBits = 0;
1598     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1599     for (unsigned i = 0; i &lt; length - 1; i++) {
1600         Digit newDigit = x-&gt;digit(i);
1601         // Take any leftover bits from the last iteration into account.
1602         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1603         resultString[pos--] = radixDigits[current];
1604         int consumedBits = bitsPerChar - availableBits;
1605         digit = newDigit &gt;&gt; consumedBits;
1606         availableBits = digitBits - consumedBits;
1607         while (availableBits &gt;= bitsPerChar) {
1608             resultString[pos--] = radixDigits[digit &amp; charMask];
1609             digit &gt;&gt;= bitsPerChar;
1610             availableBits -= bitsPerChar;
1611         }
1612     }
1613     // Take any leftover bits from the last iteration into account.
1614     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1615     resultString[pos--] = radixDigits[current];
1616     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1617     while (digit) {
1618         resultString[pos--] = radixDigits[digit &amp; charMask];
1619         digit &gt;&gt;= bitsPerChar;
1620     }
1621 
1622     if (sign)
1623         resultString[pos--] = &#39;-&#39;;
1624 
1625     ASSERT(pos == -1);
1626     return StringImpl::adopt(WTFMove(resultString));
1627 }
1628 
<span class="line-modified">1629 String JSBigInt::toStringGeneric(VM&amp; vm, ExecState* exec, JSBigInt* x, unsigned radix)</span>
1630 {
1631     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1632     // https://bugs.webkit.org/show_bug.cgi?id=18067
1633     Vector&lt;LChar&gt; resultString;
1634 


1635     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1636     ASSERT(!x-&gt;isZero());
1637 
1638     unsigned length = x-&gt;length();
1639     bool sign = x-&gt;sign();
1640 
1641     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1642     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1643 
1644     if (maximumCharactersRequired &gt; JSString::MaxLength) {
<span class="line-modified">1645         if (exec) {</span>
<span class="line-modified">1646             auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">1647             throwOutOfMemoryError(exec, scope);</span>
<span class="line-added">1648         }</span>
1649         return String();
1650     }
1651 
1652     Digit lastDigit;
1653     if (length == 1)
1654         lastDigit = x-&gt;digit(0);
1655     else {
1656         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1657         Digit chunkDivisor = digitPow(radix, chunkChars);
1658 
1659         // By construction of chunkChars, there can&#39;t have been overflow.
1660         ASSERT(chunkDivisor);
1661         unsigned nonZeroDigit = length - 1;
1662         ASSERT(x-&gt;digit(nonZeroDigit));
1663 
1664         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1665         // Not to be confused with &quot;remainder&quot;!
1666         JSBigInt* rest = nullptr;
1667 
1668         // In the first round, divide the input, allocating a new BigInt for
</pre>
<hr />
<pre>
1947         ASSERT(!xSign);
1948         return x-&gt;isZero() ? ComparisonResult::Equal : ComparisonResult::GreaterThan;
1949     }
1950 
1951     if (x-&gt;isZero())
1952         return ComparisonResult::LessThan;
1953 
1954     uint64_t mantissa = doubleBits &amp; 0x000FFFFFFFFFFFFF;
1955 
1956     // Non-finite doubles are handled above.
1957     ASSERT(rawExponent != 0x7FF);
1958     int exponent = rawExponent - 0x3FF;
1959     if (exponent &lt; 0) {
1960         // The absolute value of the double is less than 1. Only 0n has an
1961         // absolute value smaller than that, but we&#39;ve already covered that case.
1962         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1963     }
1964 
1965     int xLength = x-&gt;length();
1966     Digit xMSD = x-&gt;digit(xLength - 1);
<span class="line-modified">1967     int msdLeadingZeros = clz(xMSD);</span>
1968 
1969     int xBitLength = xLength * digitBits - msdLeadingZeros;
1970     int yBitLength = exponent + 1;
1971     if (xBitLength &lt; yBitLength)
1972         return xSign? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
1973 
1974     if (xBitLength &gt; yBitLength)
1975         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1976 
1977     // At this point, we know that signs and bit lengths (i.e. position of
1978     // the most significant bit in exponent-free representation) are identical.
1979     // {x} is not zero, {y} is finite and not denormal.
1980     // Now we virtually convert the double to an integer by shifting its
1981     // mantissa according to its exponent, so it will align with the BigInt {x},
1982     // and then we compare them bit for bit until we find a difference or the
1983     // least significant bit.
1984     //                    &lt;----- 52 ------&gt; &lt;-- virtual trailing zeroes --&gt;
1985     // y / mantissa:     1yyyyyyyyyyyyyyyyy 0000000000000000000000000000000
1986     // x / digits:    0001xxxx xxxxxxxx xxxxxxxx ...
1987     //                    &lt;--&gt;          &lt;------&gt;
</pre>
</td>
</tr>
</table>
<center><a href="JSAsyncGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBigInt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>