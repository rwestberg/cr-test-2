<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorDebuggerAgent.h&quot;
  32 
  33 #include &quot;AsyncStackTrace.h&quot;
  34 #include &quot;ContentSearchUtilities.h&quot;
  35 #include &quot;InjectedScript.h&quot;
  36 #include &quot;InjectedScriptManager.h&quot;
  37 #include &quot;InspectorFrontendRouter.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;RegularExpression.h&quot;
  40 #include &quot;ScriptCallStack.h&quot;
  41 #include &quot;ScriptCallStackFactory.h&quot;
  42 #include &quot;ScriptDebugServer.h&quot;
  43 #include &quot;ScriptObject.h&quot;
  44 #include &lt;wtf/JSONValues.h&gt;
  45 #include &lt;wtf/NeverDestroyed.h&gt;
  46 #include &lt;wtf/Stopwatch.h&gt;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace Inspector {
  51 
  52 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  53 
  54 // Objects created and retained by evaluating breakpoint actions are put into object groups
  55 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  56 // have several object groups, and objects from several backend breakpoint action instances may
  57 // create objects in the same group.
  58 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  59 {
  60     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  61 }
  62 
  63 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  64     : InspectorAgentBase(&quot;Debugger&quot;_s)
  65     , m_injectedScriptManager(context.injectedScriptManager)
  66     , m_frontendDispatcher(std::make_unique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))
  67     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  68     , m_scriptDebugServer(context.environment.scriptDebugServer())
  69     , m_continueToLocationBreakpointID(JSC::noBreakpointID)
  70 {
  71     // FIXME: make breakReason optional so that there was no need to init it with &quot;other&quot;.
  72     clearBreakDetails();
  73 }
  74 
  75 InspectorDebuggerAgent::~InspectorDebuggerAgent()
  76 {
  77 }
  78 
  79 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  80 {
  81 }
  82 
  83 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  84 {
  85     bool skipRecompile = reason == DisconnectReason::InspectedTargetDestroyed;
  86     disable(skipRecompile);
  87 }
  88 
  89 void InspectorDebuggerAgent::enable()
  90 {
  91     if (m_enabled)
  92         return;
  93 
  94     m_scriptDebugServer.addListener(this);
  95 
  96     if (m_listener)
  97         m_listener-&gt;debuggerWasEnabled();
  98 
  99     m_enabled = true;
 100 }
 101 
 102 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
 103 {
 104     if (!m_enabled)
 105         return;
 106 
 107     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 108     clearInspectorBreakpointState();
 109 
 110     if (!isBeingDestroyed)
 111         m_scriptDebugServer.deactivateBreakpoints();
 112 
 113     ASSERT(m_javaScriptBreakpoints.isEmpty());
 114 
 115     if (m_listener)
 116         m_listener-&gt;debuggerWasDisabled();
 117 
 118     clearAsyncStackTraceData();
 119 
 120     m_pauseOnAssertionFailures = false;
 121 
 122     m_enabled = false;
 123 }
 124 
 125 void InspectorDebuggerAgent::enable(ErrorString&amp;)
 126 {
 127     enable();
 128 }
 129 
 130 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 131 {
 132     disable(false);
 133 }
 134 
 135 bool InspectorDebuggerAgent::breakpointsActive() const
 136 {
 137     return m_scriptDebugServer.breakpointsActive();
 138 }
 139 
 140 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 141 {
 142     if (m_asyncStackTraceDepth == depth)
 143         return;
 144 
 145     if (depth &lt; 0) {
 146         errorString = &quot;depth must be a positive number.&quot;_s;
 147         return;
 148     }
 149 
 150     m_asyncStackTraceDepth = depth;
 151 
 152     if (!m_asyncStackTraceDepth)
 153         clearAsyncStackTraceData();
 154 }
 155 
 156 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 157 {
 158     if (active)
 159         m_scriptDebugServer.activateBreakpoints();
 160     else
 161         m_scriptDebugServer.deactivateBreakpoints();
 162 }
 163 
 164 bool InspectorDebuggerAgent::isPaused() const
 165 {
 166     return m_scriptDebugServer.isPaused();
 167 }
 168 
 169 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 170 {
 171     m_scriptDebugServer.setSuppressAllPauses(suppress);
 172 }
 173 
 174 static RefPtr&lt;JSON::Object&gt; buildAssertPauseReason(const String&amp; message)
 175 {
 176     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
 177     if (!message.isNull())
 178         reason-&gt;setMessage(message);
 179     return reason-&gt;openAccessors();
 180 }
 181 
 182 static RefPtr&lt;JSON::Object&gt; buildCSPViolationPauseReason(const String&amp; directiveText)
 183 {
 184     auto reason = Protocol::Debugger::CSPViolationPauseReason::create()
 185         .setDirective(directiveText)
 186         .release();
 187     return reason-&gt;openAccessors();
 188 }
 189 
 190 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildBreakpointPauseReason(JSC::BreakpointID debuggerBreakpointIdentifier)
 191 {
 192     ASSERT(debuggerBreakpointIdentifier != JSC::noBreakpointID);
 193     auto it = m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.find(debuggerBreakpointIdentifier);
 194     if (it == m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.end())
 195         return nullptr;
 196 
 197     auto reason = Protocol::Debugger::BreakpointPauseReason::create()
 198         .setBreakpointId(it-&gt;value)
 199         .release();
 200     return reason-&gt;openAccessors();
 201 }
 202 
 203 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildExceptionPauseReason(JSC::JSValue exception, const InjectedScript&amp; injectedScript)
 204 {
 205     ASSERT(exception);
 206     if (!exception)
 207         return nullptr;
 208 
 209     ASSERT(!injectedScript.hasNoValue());
 210     if (injectedScript.hasNoValue())
 211         return nullptr;
 212 
 213     return injectedScript.wrapObject(exception, InspectorDebuggerAgent::backtraceObjectGroup)-&gt;openAccessors();
 214 }
 215 
 216 void InspectorDebuggerAgent::handleConsoleAssert(const String&amp; message)
 217 {
 218     if (!m_scriptDebugServer.breakpointsActive())
 219         return;
 220 
 221     if (m_pauseOnAssertionFailures)
 222         breakProgram(DebuggerFrontendDispatcher::Reason::Assert, buildAssertPauseReason(message));
 223 }
 224 
 225 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 226 {
 227     return std::make_pair(static_cast&lt;unsigned&gt;(asyncCallType), callbackId);
 228 }
 229 
 230 void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::ExecState* exec, AsyncCallType asyncCallType, int callbackId, bool singleShot)
 231 {
 232     if (!m_asyncStackTraceDepth)
 233         return;
 234 
 235     if (!m_scriptDebugServer.breakpointsActive())
 236         return;
 237 
 238     Ref&lt;ScriptCallStack&gt; callStack = createScriptCallStack(exec, m_asyncStackTraceDepth);
 239     ASSERT(callStack-&gt;size());
 240     if (!callStack-&gt;size())
 241         return;
 242 
 243     RefPtr&lt;AsyncStackTrace&gt; parentStackTrace;
 244     if (m_currentAsyncCallIdentifier) {
 245         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
 246         ASSERT(it != m_pendingAsyncCalls.end());
 247         parentStackTrace = it-&gt;value;
 248     }
 249 
 250     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 251     auto asyncStackTrace = AsyncStackTrace::create(WTFMove(callStack), singleShot, WTFMove(parentStackTrace));
 252 
 253     m_pendingAsyncCalls.set(identifier, WTFMove(asyncStackTrace));
 254 }
 255 
 256 void InspectorDebuggerAgent::didCancelAsyncCall(AsyncCallType asyncCallType, int callbackId)
 257 {
 258     if (!m_asyncStackTraceDepth)
 259         return;
 260 
 261     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 262     auto it = m_pendingAsyncCalls.find(identifier);
 263     if (it == m_pendingAsyncCalls.end())
 264         return;
 265 
 266     auto&amp; asyncStackTrace = it-&gt;value;
 267     asyncStackTrace-&gt;didCancelAsyncCall();
 268 
 269     if (m_currentAsyncCallIdentifier &amp;&amp; m_currentAsyncCallIdentifier.value() == identifier)
 270         return;
 271 
 272     m_pendingAsyncCalls.remove(identifier);
 273 }
 274 
 275 void InspectorDebuggerAgent::willDispatchAsyncCall(AsyncCallType asyncCallType, int callbackId)
 276 {
 277     if (!m_asyncStackTraceDepth)
 278         return;
 279 
 280     if (m_currentAsyncCallIdentifier)
 281         return;
 282 
 283     // A call can be scheduled before the Inspector is opened, or while async stack
 284     // traces are disabled. If no call data exists, do nothing.
 285     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 286     auto it = m_pendingAsyncCalls.find(identifier);
 287     if (it == m_pendingAsyncCalls.end())
 288         return;
 289 
 290     auto&amp; asyncStackTrace = it-&gt;value;
 291     asyncStackTrace-&gt;willDispatchAsyncCall(m_asyncStackTraceDepth);
 292 
 293     m_currentAsyncCallIdentifier = identifier;
 294 }
 295 
 296 void InspectorDebuggerAgent::didDispatchAsyncCall()
 297 {
 298     if (!m_asyncStackTraceDepth)
 299         return;
 300 
 301     if (!m_currentAsyncCallIdentifier)
 302         return;
 303 
 304     auto identifier = m_currentAsyncCallIdentifier.value();
 305     auto it = m_pendingAsyncCalls.find(identifier);
 306     ASSERT(it != m_pendingAsyncCalls.end());
 307 
 308     auto&amp; asyncStackTrace = it-&gt;value;
 309     asyncStackTrace-&gt;didDispatchAsyncCall();
 310 
 311     m_currentAsyncCallIdentifier = WTF::nullopt;
 312 
 313     if (!asyncStackTrace-&gt;isPending())
 314         m_pendingAsyncCalls.remove(identifier);
 315 }
 316 
 317 static Ref&lt;JSON::Object&gt; buildObjectForBreakpointCookie(const String&amp; url, int lineNumber, int columnNumber, const String&amp; condition, RefPtr&lt;JSON::Array&gt;&amp; actions, bool isRegex, bool autoContinue, unsigned ignoreCount)
 318 {
 319     Ref&lt;JSON::Object&gt; breakpointObject = JSON::Object::create();
 320     breakpointObject-&gt;setString(&quot;url&quot;_s, url);
 321     breakpointObject-&gt;setInteger(&quot;lineNumber&quot;_s, lineNumber);
 322     breakpointObject-&gt;setInteger(&quot;columnNumber&quot;_s, columnNumber);
 323     breakpointObject-&gt;setString(&quot;condition&quot;_s, condition);
 324     breakpointObject-&gt;setBoolean(&quot;isRegex&quot;_s, isRegex);
 325     breakpointObject-&gt;setBoolean(&quot;autoContinue&quot;_s, autoContinue);
 326     breakpointObject-&gt;setInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 327 
 328     if (actions)
 329         breakpointObject-&gt;setArray(&quot;actions&quot;_s, actions);
 330 
 331     return breakpointObject;
 332 }
 333 
 334 static bool matches(const String&amp; url, const String&amp; pattern, bool isRegex)
 335 {
 336     if (isRegex) {
 337         JSC::Yarr::RegularExpression regex(pattern);
 338         return regex.match(url) != -1;
 339     }
 340     return url == pattern;
 341 }
 342 
 343 static bool breakpointActionTypeForString(const String&amp; typeString, ScriptBreakpointActionType* output)
 344 {
 345     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Log)) {
 346         *output = ScriptBreakpointActionTypeLog;
 347         return true;
 348     }
 349     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Evaluate)) {
 350         *output = ScriptBreakpointActionTypeEvaluate;
 351         return true;
 352     }
 353     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Sound)) {
 354         *output = ScriptBreakpointActionTypeSound;
 355         return true;
 356     }
 357     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Probe)) {
 358         *output = ScriptBreakpointActionTypeProbe;
 359         return true;
 360     }
 361 
 362     return false;
 363 }
 364 
 365 bool InspectorDebuggerAgent::breakpointActionsFromProtocol(ErrorString&amp; errorString, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result)
 366 {
 367     if (!actions)
 368         return true;
 369 
 370     unsigned actionsLength = actions-&gt;length();
 371     if (!actionsLength)
 372         return true;
 373 
 374     result-&gt;reserveCapacity(actionsLength);
 375     for (unsigned i = 0; i &lt; actionsLength; ++i) {
 376         RefPtr&lt;JSON::Value&gt; value = actions-&gt;get(i);
 377         RefPtr&lt;JSON::Object&gt; object;
 378         if (!value-&gt;asObject(object)) {
 379             errorString = &quot;BreakpointAction of incorrect type, expected object&quot;_s;
 380             return false;
 381         }
 382 
 383         String typeString;
 384         if (!object-&gt;getString(&quot;type&quot;_s, typeString)) {
 385             errorString = &quot;BreakpointAction had type missing&quot;_s;
 386             return false;
 387         }
 388 
 389         ScriptBreakpointActionType type;
 390         if (!breakpointActionTypeForString(typeString, &amp;type)) {
 391             errorString = &quot;BreakpointAction had unknown type&quot;_s;
 392             return false;
 393         }
 394 
 395         // Specifying an identifier is optional. They are used to correlate probe samples
 396         // in the frontend across multiple backend probe actions and segregate object groups.
 397         int identifier = 0;
 398         object-&gt;getInteger(&quot;id&quot;_s, identifier);
 399 
 400         String data;
 401         object-&gt;getString(&quot;data&quot;_s, data);
 402 
 403         result-&gt;append(ScriptBreakpointAction(type, identifier, data));
 404     }
 405 
 406     return true;
 407 }
 408 
 409 static RefPtr&lt;Protocol::Debugger::Location&gt; buildDebuggerLocation(const JSC::Breakpoint&amp; breakpoint)
 410 {
 411     ASSERT(breakpoint.resolved);
 412 
 413     auto location = Protocol::Debugger::Location::create()
 414         .setScriptId(String::number(breakpoint.sourceID))
 415         .setLineNumber(breakpoint.line)
 416         .release();
 417     location-&gt;setColumnNumber(breakpoint.column);
 418 
 419     return WTFMove(location);
 420 }
 421 
 422 static bool parseLocation(ErrorString&amp; errorString, const JSON::Object&amp; location, JSC::SourceID&amp; sourceID, unsigned&amp; lineNumber, unsigned&amp; columnNumber)
 423 {
 424     String scriptIDStr;
 425     if (!location.getString(&quot;scriptId&quot;_s, scriptIDStr) || !location.getInteger(&quot;lineNumber&quot;_s, lineNumber)) {
 426         sourceID = JSC::noSourceID;
 427         errorString = &quot;scriptId and lineNumber are required.&quot;_s;
 428         return false;
 429     }
 430 
 431     sourceID = scriptIDStr.toIntPtr();
 432     columnNumber = 0;
 433     location.getInteger(&quot;columnNumber&quot;_s, columnNumber);
 434     return true;
 435 }
 436 
 437 void InspectorDebuggerAgent::setBreakpointByUrl(ErrorString&amp; errorString, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations)
 438 {
 439     locations = JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;::create();
 440     if (!optionalURL == !optionalURLRegex) {
 441         errorString = &quot;Either url or urlRegex must be specified.&quot;_s;
 442         return;
 443     }
 444 
 445     String url = optionalURL ? *optionalURL : *optionalURLRegex;
 446     int columnNumber = optionalColumnNumber ? *optionalColumnNumber : 0;
 447     bool isRegex = optionalURLRegex;
 448 
 449     String breakpointIdentifier = makeString(isRegex ? &quot;/&quot; : &quot;&quot;, url, isRegex ? &quot;/:&quot; : &quot;:&quot;, lineNumber, &#39;:&#39;, columnNumber);
 450     if (m_javaScriptBreakpoints.contains(breakpointIdentifier)) {
 451         errorString = &quot;Breakpoint at specified location already exists.&quot;_s;
 452         return;
 453     }
 454 
 455     String condition = emptyString();
 456     bool autoContinue = false;
 457     unsigned ignoreCount = 0;
 458     RefPtr&lt;JSON::Array&gt; actions;
 459     if (options) {
 460         options-&gt;getString(&quot;condition&quot;_s, condition);
 461         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 462         options-&gt;getArray(&quot;actions&quot;_s, actions);
 463         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 464     }
 465 
 466     BreakpointActions breakpointActions;
 467     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 468         return;
 469 
 470     m_javaScriptBreakpoints.set(breakpointIdentifier, buildObjectForBreakpointCookie(url, lineNumber, columnNumber, condition, actions, isRegex, autoContinue, ignoreCount));
 471 
 472     for (auto&amp; entry : m_scripts) {
 473         Script&amp; script = entry.value;
 474         String scriptURLForBreakpoints = !script.sourceURL.isEmpty() ? script.sourceURL : script.url;
 475         if (!matches(scriptURLForBreakpoints, url, isRegex))
 476             continue;
 477 
 478         JSC::SourceID sourceID = entry.key;
 479         JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 480         resolveBreakpoint(script, breakpoint);
 481         if (!breakpoint.resolved)
 482             continue;
 483 
 484         bool existing;
 485         setBreakpoint(breakpoint, existing);
 486         if (existing)
 487             continue;
 488 
 489         ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 490         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 491 
 492         locations-&gt;addItem(buildDebuggerLocation(breakpoint));
 493     }
 494 
 495     *outBreakpointIdentifier = breakpointIdentifier;
 496 }
 497 
 498 void InspectorDebuggerAgent::setBreakpoint(ErrorString&amp; errorString, const JSON::Object&amp; location, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;Protocol::Debugger::Location&gt;&amp; actualLocation)
 499 {
 500     JSC::SourceID sourceID;
 501     unsigned lineNumber;
 502     unsigned columnNumber;
 503     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 504         return;
 505 
 506     String condition = emptyString();
 507     bool autoContinue = false;
 508     unsigned ignoreCount = 0;
 509     RefPtr&lt;JSON::Array&gt; actions;
 510     if (options) {
 511         options-&gt;getString(&quot;condition&quot;_s, condition);
 512         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 513         options-&gt;getArray(&quot;actions&quot;_s, actions);
 514         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 515     }
 516 
 517     BreakpointActions breakpointActions;
 518     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 519         return;
 520 
 521     auto scriptIterator = m_scripts.find(sourceID);
 522     if (scriptIterator == m_scripts.end()) {
 523         errorString = makeString(&quot;No script for id: &quot;_s, sourceID);
 524         return;
 525     }
 526 
 527     Script&amp; script = scriptIterator-&gt;value;
 528     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 529     resolveBreakpoint(script, breakpoint);
 530     if (!breakpoint.resolved) {
 531         errorString = &quot;Could not resolve breakpoint&quot;_s;
 532         return;
 533     }
 534 
 535     bool existing;
 536     setBreakpoint(breakpoint, existing);
 537     if (existing) {
 538         errorString = &quot;Breakpoint at specified location already exists&quot;_s;
 539         return;
 540     }
 541 
 542     String breakpointIdentifier = makeString(sourceID, &#39;:&#39;, breakpoint.line, &#39;:&#39;, breakpoint.column);
 543     ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 544     didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 545 
 546     actualLocation = buildDebuggerLocation(breakpoint);
 547     *outBreakpointIdentifier = breakpointIdentifier;
 548 }
 549 
 550 void InspectorDebuggerAgent::didSetBreakpoint(const JSC::Breakpoint&amp; breakpoint, const String&amp; breakpointIdentifier, const ScriptBreakpoint&amp; scriptBreakpoint)
 551 {
 552     JSC::BreakpointID id = breakpoint.id;
 553     m_scriptDebugServer.setBreakpointActions(id, scriptBreakpoint);
 554 
 555     auto debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.find(breakpointIdentifier);
 556     if (debugServerBreakpointIDsIterator == m_breakpointIdentifierToDebugServerBreakpointIDs.end())
 557         debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.set(breakpointIdentifier, Vector&lt;JSC::BreakpointID&gt;()).iterator;
 558     debugServerBreakpointIDsIterator-&gt;value.append(id);
 559 
 560     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.set(id, breakpointIdentifier);
 561 }
 562 
 563 void InspectorDebuggerAgent::resolveBreakpoint(const Script&amp; script, JSC::Breakpoint&amp; breakpoint)
 564 {
 565     if (breakpoint.line &lt; static_cast&lt;unsigned&gt;(script.startLine) || static_cast&lt;unsigned&gt;(script.endLine) &lt; breakpoint.line)
 566         return;
 567 
 568     m_scriptDebugServer.resolveBreakpoint(breakpoint, script.sourceProvider.get());
 569 }
 570 
 571 void InspectorDebuggerAgent::setBreakpoint(JSC::Breakpoint&amp; breakpoint, bool&amp; existing)
 572 {
 573     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 574     m_scriptDebugServer.setBreakpoint(breakpoint, existing);
 575 }
 576 
 577 void InspectorDebuggerAgent::removeBreakpoint(ErrorString&amp;, const String&amp; breakpointIdentifier)
 578 {
 579     m_javaScriptBreakpoints.remove(breakpointIdentifier);
 580 
 581     for (JSC::BreakpointID breakpointID : m_breakpointIdentifierToDebugServerBreakpointIDs.take(breakpointIdentifier)) {
 582         m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.remove(breakpointID);
 583 
 584         const BreakpointActions&amp; breakpointActions = m_scriptDebugServer.getActionsForBreakpoint(breakpointID);
 585         for (auto&amp; action : breakpointActions)
 586             m_injectedScriptManager.releaseObjectGroup(objectGroupForBreakpointAction(action));
 587 
 588         JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 589         m_scriptDebugServer.removeBreakpointActions(breakpointID);
 590         m_scriptDebugServer.removeBreakpoint(breakpointID);
 591     }
 592 }
 593 
 594 void InspectorDebuggerAgent::continueUntilNextRunLoop(ErrorString&amp; errorString)
 595 {
 596     if (!assertPaused(errorString))
 597         return;
 598 
 599     resume(errorString);
 600 
 601     m_enablePauseWhenIdle = true;
 602 
 603     registerIdleHandler();
 604 }
 605 
 606 void InspectorDebuggerAgent::continueToLocation(ErrorString&amp; errorString, const JSON::Object&amp; location)
 607 {
 608     if (!assertPaused(errorString))
 609         return;
 610 
 611     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
 612         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
 613         m_continueToLocationBreakpointID = JSC::noBreakpointID;
 614     }
 615 
 616     JSC::SourceID sourceID;
 617     unsigned lineNumber;
 618     unsigned columnNumber;
 619     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 620         return;
 621 
 622     auto scriptIterator = m_scripts.find(sourceID);
 623     if (scriptIterator == m_scripts.end()) {
 624         m_scriptDebugServer.continueProgram();
 625         m_frontendDispatcher-&gt;resumed();
 626         errorString = makeString(&quot;No script for id: &quot;_s, sourceID);
 627         return;
 628     }
 629 
 630     String condition;
 631     bool autoContinue = false;
 632     unsigned ignoreCount = 0;
 633     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 634     Script&amp; script = scriptIterator-&gt;value;
 635     resolveBreakpoint(script, breakpoint);
 636     if (!breakpoint.resolved) {
 637         m_scriptDebugServer.continueProgram();
 638         m_frontendDispatcher-&gt;resumed();
 639         errorString = &quot;Could not resolve breakpoint&quot;_s;
 640         return;
 641     }
 642 
 643     bool existing;
 644     setBreakpoint(breakpoint, existing);
 645     if (existing) {
 646         // There is an existing breakpoint at this location. Instead of
 647         // acting like a series of steps, just resume and we will either
 648         // hit this new breakpoint or not.
 649         m_scriptDebugServer.continueProgram();
 650         m_frontendDispatcher-&gt;resumed();
 651         return;
 652     }
 653 
 654     m_continueToLocationBreakpointID = breakpoint.id;
 655 
 656     // Treat this as a series of steps until reaching the new breakpoint.
 657     // So don&#39;t issue a resumed event unless we exit the VM without pausing.
 658     willStepAndMayBecomeIdle();
 659     m_scriptDebugServer.continueProgram();
 660 }
 661 
 662 void InspectorDebuggerAgent::searchInContent(ErrorString&amp; error, const String&amp; scriptIDStr, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
 663 {
 664     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 665     auto it = m_scripts.find(sourceID);
 666     if (it == m_scripts.end()) {
 667         error = makeString(&quot;No script for id: &quot;_s, scriptIDStr);
 668         return;
 669     }
 670 
 671     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
 672     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
 673     results = ContentSearchUtilities::searchInTextByLines(it-&gt;value.source, query, caseSensitive, isRegex);
 674 }
 675 
 676 void InspectorDebuggerAgent::getScriptSource(ErrorString&amp; error, const String&amp; scriptIDStr, String* scriptSource)
 677 {
 678     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 679     ScriptsMap::iterator it = m_scripts.find(sourceID);
 680     if (it != m_scripts.end())
 681         *scriptSource = it-&gt;value.source;
 682     else
 683         error = makeString(&quot;No script for id: &quot;_s, scriptIDStr);
 684 }
 685 
 686 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 687 {
 688     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 689     if (injectedScript.hasNoValue()) {
 690         errorString = &quot;Function object id is obsolete&quot;_s;
 691         return;
 692     }
 693 
 694     injectedScript.getFunctionDetails(errorString, functionId, details);
 695 }
 696 
 697 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
 698 {
 699     if (m_javaScriptPauseScheduled)
 700         return;
 701 
 702     m_javaScriptPauseScheduled = true;
 703 
 704     m_breakReason = breakReason;
 705     m_breakAuxData = WTFMove(data);
 706 
 707     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 708     m_scriptDebugServer.setPauseOnNextStatement(true);
 709 }
 710 
 711 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 712 {
 713     if (!m_javaScriptPauseScheduled)
 714         return;
 715 
 716     m_javaScriptPauseScheduled = false;
 717 
 718     clearBreakDetails();
 719     m_scriptDebugServer.setPauseOnNextStatement(false);
 720     m_enablePauseWhenIdle = false;
 721 }
 722 
 723 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 724 {
 725     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 726 }
 727 
 728 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 729 {
 730     if (!m_pausedScriptState &amp;&amp; !m_javaScriptPauseScheduled) {
 731         errorString = &quot;Was not paused or waiting to pause&quot;_s;
 732         return;
 733     }
 734 
 735     cancelPauseOnNextStatement();
 736     m_scriptDebugServer.continueProgram();
 737     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 738 }
 739 
 740 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 741 {
 742     if (!assertPaused(errorString))
 743         return;
 744 
 745     willStepAndMayBecomeIdle();
 746     m_scriptDebugServer.stepOverStatement();
 747 }
 748 
 749 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 750 {
 751     if (!assertPaused(errorString))
 752         return;
 753 
 754     willStepAndMayBecomeIdle();
 755     m_scriptDebugServer.stepIntoStatement();
 756 }
 757 
 758 void InspectorDebuggerAgent::stepOut(ErrorString&amp; errorString)
 759 {
 760     if (!assertPaused(errorString))
 761         return;
 762 
 763     willStepAndMayBecomeIdle();
 764     m_scriptDebugServer.stepOutOfFunction();
 765 }
 766 
 767 void InspectorDebuggerAgent::registerIdleHandler()
 768 {
 769     if (!m_registeredIdleCallback) {
 770         m_registeredIdleCallback = true;
 771         JSC::VM&amp; vm = m_scriptDebugServer.vm();
 772         vm.whenIdle([this]() {
 773             didBecomeIdle();
 774         });
 775     }
 776 }
 777 
 778 void InspectorDebuggerAgent::willStepAndMayBecomeIdle()
 779 {
 780     // When stepping the backend must eventually trigger a &quot;paused&quot; or &quot;resumed&quot; event.
 781     // If the step causes us to exit the VM, then we should issue &quot;resumed&quot;.
 782     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenIdle;
 783 
 784     registerIdleHandler();
 785 }
 786 
 787 void InspectorDebuggerAgent::didBecomeIdle()
 788 {
 789     m_registeredIdleCallback = false;
 790 
 791     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenIdle) {
 792         cancelPauseOnNextStatement();
 793         m_scriptDebugServer.continueProgram();
 794         m_frontendDispatcher-&gt;resumed();
 795     }
 796 
 797     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 798 
 799     if (m_enablePauseWhenIdle) {
 800         ErrorString ignored;
 801         pause(ignored);
 802     }
 803 }
 804 
 805 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 806 {
 807     JSC::Debugger::PauseOnExceptionsState pauseState;
 808     if (stringPauseState == &quot;none&quot;)
 809         pauseState = JSC::Debugger::DontPauseOnExceptions;
 810     else if (stringPauseState == &quot;all&quot;)
 811         pauseState = JSC::Debugger::PauseOnAllExceptions;
 812     else if (stringPauseState == &quot;uncaught&quot;)
 813         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 814     else {
 815         errorString = makeString(&quot;Unknown pause on exceptions mode: &quot;_s, stringPauseState);
 816         return;
 817     }
 818 
 819     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 820     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 821         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 822 }
 823 
 824 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
 825 {
 826     m_pauseOnAssertionFailures = enabled;
 827 }
 828 
 829 void InspectorDebuggerAgent::evaluateOnCallFrame(ErrorString&amp; errorString, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
 830 {
 831     if (!m_currentCallStack) {
 832         errorString = &quot;Not paused&quot;_s;
 833         return;
 834     }
 835 
 836     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(callFrameId);
 837     if (injectedScript.hasNoValue()) {
 838         errorString = &quot;Could not find InjectedScript for callFrameId&quot;_s;
 839         return;
 840     }
 841 
 842     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 843     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 844     if (pauseAndMute) {
 845         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 846             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 847         muteConsole();
 848     }
 849 
 850     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 851         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 852         result, wasThrown, savedResultIndex);
 853 
 854     if (pauseAndMute) {
 855         unmuteConsole();
 856         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 857     }
 858 }
 859 
 860 void InspectorDebuggerAgent::setOverlayMessage(ErrorString&amp;, const String*)
 861 {
 862 }
 863 
 864 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 865 {
 866     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 867         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 868 }
 869 
 870 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 871 {
 872     ASSERT(!injectedScript.hasNoValue());
 873     if (injectedScript.hasNoValue())
 874         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 875 
 876     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 877 }
 878 
 879 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 880 {
 881     return script.sourceMappingURL;
 882 }
 883 
 884 void InspectorDebuggerAgent::setPauseForInternalScripts(ErrorString&amp;, bool shouldPause)
 885 {
 886     if (shouldPause == m_pauseForInternalScripts)
 887         return;
 888 
 889     m_pauseForInternalScripts = shouldPause;
 890 
 891     if (m_pauseForInternalScripts)
 892         m_scriptDebugServer.clearBlacklist();
 893 }
 894 
 895 static bool isWebKitInjectedScript(const String&amp; sourceURL)
 896 {
 897     return sourceURL.startsWith(&quot;__InjectedScript_&quot;) &amp;&amp; sourceURL.endsWith(&quot;.js&quot;);
 898 }
 899 
 900 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script&amp; script)
 901 {
 902     String scriptIDStr = String::number(sourceID);
 903     bool hasSourceURL = !script.sourceURL.isEmpty();
 904     String sourceURL = script.sourceURL;
 905     String sourceMappingURL = sourceMapURLForScript(script);
 906 
 907     const bool isModule = script.sourceProvider-&gt;sourceType() == JSC::SourceProviderSourceType::Module;
 908     const bool* isContentScript = script.isContentScript ? &amp;script.isContentScript : nullptr;
 909     String* sourceURLParam = hasSourceURL ? &amp;sourceURL : nullptr;
 910     String* sourceMapURLParam = sourceMappingURL.isEmpty() ? nullptr : &amp;sourceMappingURL;
 911 
 912     m_frontendDispatcher-&gt;scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &amp;isModule : nullptr);
 913 
 914     m_scripts.set(sourceID, script);
 915 
 916     if (hasSourceURL &amp;&amp; isWebKitInjectedScript(sourceURL) &amp;&amp; !m_pauseForInternalScripts)
 917         m_scriptDebugServer.addToBlacklist(sourceID);
 918 
 919     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
 920     if (scriptURLForBreakpoints.isEmpty())
 921         return;
 922 
 923     for (auto&amp; entry : m_javaScriptBreakpoints) {
 924         RefPtr&lt;JSON::Object&gt; breakpointObject = entry.value;
 925 
 926         bool isRegex;
 927         String url;
 928         breakpointObject-&gt;getBoolean(&quot;isRegex&quot;_s, isRegex);
 929         breakpointObject-&gt;getString(&quot;url&quot;_s, url);
 930         if (!matches(scriptURLForBreakpoints, url, isRegex))
 931             continue;
 932 
 933         ScriptBreakpoint scriptBreakpoint;
 934         breakpointObject-&gt;getInteger(&quot;lineNumber&quot;_s, scriptBreakpoint.lineNumber);
 935         breakpointObject-&gt;getInteger(&quot;columnNumber&quot;_s, scriptBreakpoint.columnNumber);
 936         breakpointObject-&gt;getString(&quot;condition&quot;_s, scriptBreakpoint.condition);
 937         breakpointObject-&gt;getBoolean(&quot;autoContinue&quot;_s, scriptBreakpoint.autoContinue);
 938         breakpointObject-&gt;getInteger(&quot;ignoreCount&quot;_s, scriptBreakpoint.ignoreCount);
 939         ErrorString errorString;
 940         RefPtr&lt;JSON::Array&gt; actions;
 941         breakpointObject-&gt;getArray(&quot;actions&quot;_s, actions);
 942         if (!breakpointActionsFromProtocol(errorString, actions, &amp;scriptBreakpoint.actions)) {
 943             ASSERT_NOT_REACHED();
 944             continue;
 945         }
 946 
 947         JSC::Breakpoint breakpoint(sourceID, scriptBreakpoint.lineNumber, scriptBreakpoint.columnNumber, scriptBreakpoint.condition, scriptBreakpoint.autoContinue, scriptBreakpoint.ignoreCount);
 948         resolveBreakpoint(script, breakpoint);
 949         if (!breakpoint.resolved)
 950             continue;
 951 
 952         bool existing;
 953         setBreakpoint(breakpoint, existing);
 954         if (existing)
 955             continue;
 956 
 957         String breakpointIdentifier = entry.key;
 958         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 959 
 960         m_frontendDispatcher-&gt;breakpointResolved(breakpointIdentifier, buildDebuggerLocation(breakpoint));
 961     }
 962 }
 963 
 964 void InspectorDebuggerAgent::failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage)
 965 {
 966     m_frontendDispatcher-&gt;scriptFailedToParse(url, data, firstLine, errorLine, errorMessage);
 967 }
 968 
 969 void InspectorDebuggerAgent::didPause(JSC::ExecState&amp; scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
 970 {
 971     ASSERT(!m_pausedScriptState);
 972     m_pausedScriptState = &amp;scriptState;
 973     m_currentCallStack = { scriptState.vm(), callFrames };
 974 
 975     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
 976 
 977     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
 978     if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {
 979         switch (m_scriptDebugServer.reasonForPause()) {
 980         case JSC::Debugger::PausedForBreakpoint: {
 981             JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
 982             if (debuggerBreakpointId != m_continueToLocationBreakpointID) {
 983                 m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;
 984                 m_breakAuxData = buildBreakpointPauseReason(debuggerBreakpointId);
 985             }
 986             break;
 987         }
 988         case JSC::Debugger::PausedForDebuggerStatement:
 989             m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;
 990             m_breakAuxData = nullptr;
 991             break;
 992         case JSC::Debugger::PausedForException:
 993             m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;
 994             m_breakAuxData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);
 995             break;
 996         case JSC::Debugger::PausedAtStatement:
 997         case JSC::Debugger::PausedAtExpression:
 998         case JSC::Debugger::PausedBeforeReturn:
 999         case JSC::Debugger::PausedAtEndOfProgram:
1000             // Pause was just stepping. Nothing to report.
1001             break;
1002         case JSC::Debugger::NotPaused:
1003             ASSERT_NOT_REACHED();
1004             break;
1005         }
1006     }
1007 
1008     // Set $exception to the exception or caught value.
1009     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1010         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1011         m_hasExceptionValue = true;
1012     }
1013 
1014     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1015     m_enablePauseWhenIdle = false;
1016 
1017     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1018     if (m_currentAsyncCallIdentifier) {
1019         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1020         if (it != m_pendingAsyncCalls.end())
1021             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1022     }
1023 
1024     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_breakReason, m_breakAuxData, asyncStackTrace);
1025 
1026     m_javaScriptPauseScheduled = false;
1027 
1028     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1029         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1030         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1031     }
1032 
1033     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1034     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1035         stopwatch-&gt;stop();
1036         m_didPauseStopwatch = true;
1037     }
1038 }
1039 
1040 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1041 {
1042     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1043 }
1044 
1045 void InspectorDebuggerAgent::breakpointActionProbe(JSC::ExecState&amp; scriptState, const ScriptBreakpointAction&amp; action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)
1046 {
1047     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);
1048     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
1049     auto result = Protocol::Debugger::ProbeSample::create()
1050         .setProbeId(action.identifier)
1051         .setBatchId(batchId)
1052         .setSampleId(sampleId)
1053         .setTimestamp(m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;elapsedTime().seconds())
1054         .setPayload(WTFMove(payload))
1055         .release();
1056     m_frontendDispatcher-&gt;didSampleProbe(WTFMove(result));
1057 }
1058 
1059 void InspectorDebuggerAgent::didContinue()
1060 {
1061     if (m_didPauseStopwatch) {
1062         m_didPauseStopwatch = false;
1063         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1064     }
1065 
1066     m_pausedScriptState = nullptr;
1067     m_currentCallStack = { };
1068     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
1069     clearBreakDetails();
1070     clearExceptionValue();
1071 
1072     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1073         m_frontendDispatcher-&gt;resumed();
1074 }
1075 
1076 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)
1077 {
1078     m_breakReason = breakReason;
1079     m_breakAuxData = WTFMove(data);
1080     m_scriptDebugServer.breakProgram();
1081 }
1082 
1083 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1084 {
1085     ErrorString dummyError;
1086     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
1087         removeBreakpoint(dummyError, identifier);
1088 
1089     m_javaScriptBreakpoints.clear();
1090 
1091     clearDebuggerBreakpointState();
1092 }
1093 
1094 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1095 {
1096     {
1097         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1098         m_scriptDebugServer.clearBreakpointActions();
1099         m_scriptDebugServer.clearBreakpoints();
1100         m_scriptDebugServer.clearBlacklist();
1101     }
1102 
1103     m_pausedScriptState = nullptr;
1104     m_currentCallStack = { };
1105     m_scripts.clear();
1106     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1107     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
1108     m_continueToLocationBreakpointID = JSC::noBreakpointID;
1109     clearBreakDetails();
1110     m_javaScriptPauseScheduled = false;
1111     m_hasExceptionValue = false;
1112 
1113     if (isPaused()) {
1114         m_scriptDebugServer.continueProgram();
1115         m_frontendDispatcher-&gt;resumed();
1116     }
1117 }
1118 
1119 void InspectorDebuggerAgent::didClearGlobalObject()
1120 {
1121     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1122     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1123     clearDebuggerBreakpointState();
1124 
1125     clearAsyncStackTraceData();
1126 
1127     m_frontendDispatcher-&gt;globalObjectCleared();
1128 }
1129 
1130 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1131 {
1132     if (!m_pausedScriptState) {
1133         errorString = &quot;Can only perform operation while paused.&quot;_s;
1134         return false;
1135     }
1136 
1137     return true;
1138 }
1139 
1140 void InspectorDebuggerAgent::clearBreakDetails()
1141 {
1142     m_breakReason = DebuggerFrontendDispatcher::Reason::Other;
1143     m_breakAuxData = nullptr;
1144 }
1145 
1146 void InspectorDebuggerAgent::clearExceptionValue()
1147 {
1148     if (m_hasExceptionValue) {
1149         m_injectedScriptManager.clearExceptionValue();
1150         m_hasExceptionValue = false;
1151     }
1152 }
1153 
1154 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1155 {
1156     m_pendingAsyncCalls.clear();
1157     m_currentAsyncCallIdentifier = WTF::nullopt;
1158 
1159     didClearAsyncStackTraceData();
1160 }
1161 
1162 } // namespace Inspector
    </pre>
  </body>
</html>