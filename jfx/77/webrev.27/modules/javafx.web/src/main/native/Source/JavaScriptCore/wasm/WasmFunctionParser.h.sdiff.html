<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmFormat.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmIndexOrName.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;WasmParser.h&quot;
 31 #include &quot;WasmSignatureInlines.h&quot;
 32 #include &lt;wtf/DataLog.h&gt;
 33 
 34 namespace JSC { namespace Wasm {
 35 
 36 enum class BlockType {
 37     If,
 38     Block,
 39     Loop,
 40     TopLevel
 41 };
 42 
 43 template&lt;typename Context&gt;
 44 class FunctionParser : public Parser&lt;void&gt; {
 45 public:
<span class="line-modified"> 46     typedef typename Context::ExpressionType ExpressionType;</span>
<span class="line-modified"> 47     typedef typename Context::ControlType ControlType;</span>
<span class="line-modified"> 48     typedef typename Context::ExpressionList ExpressionList;</span>

 49 
 50     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);
 51 
 52     Result WARN_UNUSED_RETURN parse();
 53 
 54     struct ControlEntry {
<span class="line-modified"> 55         ExpressionList enclosedExpressionStack;</span>
 56         ControlType controlData;
 57     };
 58 
 59     OpType currentOpcode() const { return m_currentOpcode; }
 60     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
 61 
 62 private:
 63     static const bool verbose = false;
 64 
 65     PartialResult WARN_UNUSED_RETURN parseBody();
 66     PartialResult WARN_UNUSED_RETURN parseExpression();
 67     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
 68     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
 69 
 70 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
 71         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
 72         result = m_expressionStack.takeLast();                                              \
 73         m_toKillAfterExpression.append(result);                                             \
 74     } while (0)
 75 
 76     template&lt;OpType&gt;
 77     PartialResult WARN_UNUSED_RETURN unaryCase();
 78 
 79     template&lt;OpType&gt;
 80     PartialResult WARN_UNUSED_RETURN binaryCase();
 81 
 82 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
 83 
 84     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
 85 
 86     Context&amp; m_context;
<span class="line-modified"> 87     ExpressionList m_expressionStack;</span>
 88     Vector&lt;ControlEntry&gt; m_controlStack;
 89     const Signature&amp; m_signature;
 90     const ModuleInformation&amp; m_info;
 91 
 92     OpType m_currentOpcode;
 93     size_t m_currentOpcodeStartingOffset { 0 };
 94 
 95     Vector&lt;ExpressionType, 8&gt; m_toKillAfterExpression;
 96 
 97     unsigned m_unreachableBlocks { 0 };

 98 };
 99 
100 template&lt;typename Context&gt;
101 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
102     : Parser(functionStart, functionLength)
103     , m_context(context)

104     , m_signature(signature)
105     , m_info(info)
106 {
107     if (verbose)
<span class="line-modified">108         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength);</span>
109     m_context.setParser(this);
110 }
111 
112 template&lt;typename Context&gt;
113 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
114 {
<span class="line-modified">115     uint32_t localCount;</span>
116 
117     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
<span class="line-modified">118     WASM_PARSER_FAIL_IF(!parseVarUInt32(localCount), &quot;can&#39;t get local count&quot;);</span>
<span class="line-removed">119     WASM_PARSER_FAIL_IF(localCount &gt; maxFunctionLocals, &quot;Function section&#39;s local count is too big &quot;, localCount, &quot; maximum &quot;, maxFunctionLocals);</span>
120 
<span class="line-modified">121     for (uint32_t i = 0; i &lt; localCount; ++i) {</span>

122         uint32_t numberOfLocals;
123         Type typeOfLocal;
124 
125         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
<span class="line-modified">126         WASM_PARSER_FAIL_IF(numberOfLocals &gt; maxFunctionLocals, &quot;Function section&#39;s &quot;, i, &quot;th local group count is too big &quot;, numberOfLocals, &quot; maximum &quot;, maxFunctionLocals);</span>

127         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
128         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
129     }
130 
131     WASM_FAIL_IF_HELPER_FAILS(parseBody());
132 
133     return { };
134 }
135 
136 template&lt;typename Context&gt;
137 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
138 {
<span class="line-modified">139     m_controlStack.append({ ExpressionList(), m_context.addTopLevel(m_signature.returnType()) });</span>
140     uint8_t op;
141     while (m_controlStack.size()) {
142         ASSERT(m_toKillAfterExpression.isEmpty());
143 
144         m_currentOpcodeStartingOffset = m_offset;
145         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
146         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
147 
148         m_currentOpcode = static_cast&lt;OpType&gt;(op);
149 
150         if (verbose) {
151             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
152             m_context.dump(m_controlStack, &amp;m_expressionStack);
153         }
154 
155         if (m_unreachableBlocks)
156             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
157         else {
158             WASM_FAIL_IF_HELPER_FAILS(parseExpression());
159             while (m_toKillAfterExpression.size())
</pre>
<hr />
<pre>
264         int32_t constant;
265         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
266         m_expressionStack.append(m_context.addConstant(I32, constant));
267         return { };
268     }
269 
270     case F64Const: {
271         uint64_t constant;
272         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
273         m_expressionStack.append(m_context.addConstant(F64, constant));
274         return { };
275     }
276 
277     case I64Const: {
278         int64_t constant;
279         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
280         m_expressionStack.append(m_context.addConstant(I64, constant));
281         return { };
282     }
283 





















































































284     case GetLocal: {
285         uint32_t index;
286         ExpressionType result;
287         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
288         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
289         m_expressionStack.append(result);
290         return { };
291     }
292 
293     case SetLocal: {
294         uint32_t index;
295         ExpressionType value;
296         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
297         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
298         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
299         return { };
300     }
301 
302     case TeeLocal: {
303         uint32_t index;
</pre>
<hr />
<pre>
321         ExpressionType value;
322         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
323         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
324         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
325         return { };
326     }
327 
328     case Call: {
329         uint32_t functionIndex;
330         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
331         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
332 
333         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
334         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
335         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
336 
337         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
338         Vector&lt;ExpressionType&gt; args;
339         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
340         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)
<span class="line-modified">341             args.uncheckedAppend(m_expressionStack[i]);</span>
342         m_expressionStack.shrink(firstArgumentIndex);
343 
344         ExpressionType result = Context::emptyExpression();
345         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, result));
346 
347         if (result != Context::emptyExpression())
348             m_expressionStack.append(result);
349 
350         return { };
351     }
352 
353     case CallIndirect: {
354         uint32_t signatureIndex;
<span class="line-modified">355         uint8_t reserved;</span>
<span class="line-modified">356         WASM_PARSER_FAIL_IF(!m_info.tableInformation, &quot;call_indirect is only valid when a table is defined or imported&quot;);</span>
357         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
<span class="line-modified">358         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t get call_indirect&#39;s reserved byte&quot;);</span>
<span class="line-modified">359         WASM_PARSER_FAIL_IF(reserved, &quot;call_indirect&#39;s &#39;reserved&#39; varuint1 must be 0x0&quot;);</span>
360         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());

361 
362         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
363         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
364         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
365 
366         Vector&lt;ExpressionType&gt; args;
367         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
368         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
369         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)
<span class="line-modified">370             args.uncheckedAppend(m_expressionStack[i]);</span>
371         m_expressionStack.shrink(firstArgumentIndex);
372 
373         ExpressionType result = Context::emptyExpression();
<span class="line-modified">374         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(calleeSignature, args, result));</span>
375 
376         if (result != Context::emptyExpression())
377             m_expressionStack.append(result);
378 
379         return { };
380     }
381 
382     case Block: {
383         Type inlineSignature;
384         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get block&#39;s inline signature&quot;);
385         m_controlStack.append({ WTFMove(m_expressionStack), m_context.addBlock(inlineSignature) });
<span class="line-modified">386         m_expressionStack = ExpressionList();</span>
387         return { };
388     }
389 
390     case Loop: {
391         Type inlineSignature;
392         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get loop&#39;s inline signature&quot;);
<span class="line-modified">393         m_controlStack.append({ WTFMove(m_expressionStack), m_context.addLoop(inlineSignature) });</span>
<span class="line-modified">394         m_expressionStack = ExpressionList();</span>


395         return { };
396     }
397 
398     case If: {
399         Type inlineSignature;
400         ExpressionType condition;
401         ControlType control;
402         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get if&#39;s inline signature&quot;);
403         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
404         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, control));
405         m_controlStack.append({ WTFMove(m_expressionStack), control });
<span class="line-modified">406         m_expressionStack = ExpressionList();</span>
407         return { };
408     }
409 
410     case Else: {
411         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
412         WASM_TRY_ADD_TO_CONTEXT(addElse(m_controlStack.last().controlData, m_expressionStack));
413         m_expressionStack.shrink(0);
414         return { };
415     }
416 
417     case Br:
418     case BrIf: {
419         uint32_t target;
420         ExpressionType condition = Context::emptyExpression();
421         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
422         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
423         if (m_currentOpcode == BrIf)
424             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
425         else
426             m_unreachableBlocks = 1;
</pre>
<hr />
<pre>
569         Type unused;
570         WASM_PARSER_FAIL_IF(!parseResultType(unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
571         return { };
572     }
573 
574     case BrTable: {
575         uint32_t numberOfTargets;
576         uint32_t unused;
577         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
578         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
579 
580         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
581             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
582 
583         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
584         return { };
585     }
586 
587     case CallIndirect: {
588         uint32_t unused;
<span class="line-modified">589         uint8_t unused2;</span>
590         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
<span class="line-modified">591         WASM_PARSER_FAIL_IF(!parseVarUInt1(unused2), &quot;can&#39;t get call_indirect&#39;s reserved byte in unreachable context&quot;);</span>
592         return { };
593     }
594 
595     case F32Const: {
596         uint32_t unused;
597         WASM_PARSER_FAIL_IF(!parseUInt32(unused), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
598         return { };
599     }
600 
601     case F64Const: {
602         uint64_t constant;
603         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
604         return { };
605     }
606 
607     // two immediate cases
608     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)
609     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {
610         uint32_t unused;
611         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get first immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
</pre>
<hr />
<pre>
622     case Br:
623     case BrIf:
624     case Call: {
625         uint32_t unused;
626         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
627         return { };
628     }
629 
630     case I32Const: {
631         int32_t unused;
632         WASM_PARSER_FAIL_IF(!parseVarInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
633         return { };
634     }
635 
636     case I64Const: {
637         int64_t unused;
638         WASM_PARSER_FAIL_IF(!parseVarInt64(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
639         return { };
640     }
641 




















642     case GrowMemory:
643     case CurrentMemory: {
644         uint8_t reserved;
645         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory/current_memory&quot;);
646         return { };
647     }
648 
649     // no immediate cases
650     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
651     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
652     case Unreachable:
653     case Nop:
654     case Return:
655     case Select:
656     case Drop: {
657         return { };
658     }
659     }
660 #undef CREATE_CASE
661     RELEASE_ASSERT_NOT_REACHED();
</pre>
</td>
<td>
<hr />
<pre>
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;WasmParser.h&quot;
 31 #include &quot;WasmSignatureInlines.h&quot;
 32 #include &lt;wtf/DataLog.h&gt;
 33 
 34 namespace JSC { namespace Wasm {
 35 
 36 enum class BlockType {
 37     If,
 38     Block,
 39     Loop,
 40     TopLevel
 41 };
 42 
 43 template&lt;typename Context&gt;
 44 class FunctionParser : public Parser&lt;void&gt; {
 45 public:
<span class="line-modified"> 46     using ExpressionType = typename Context::ExpressionType;</span>
<span class="line-modified"> 47     using ControlType = typename Context::ControlType;</span>
<span class="line-modified"> 48     using ExpressionList = typename Context::ExpressionList;</span>
<span class="line-added"> 49     using Stack = typename Context::Stack;</span>
 50 
 51     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);
 52 
 53     Result WARN_UNUSED_RETURN parse();
 54 
 55     struct ControlEntry {
<span class="line-modified"> 56         Stack enclosedExpressionStack;</span>
 57         ControlType controlData;
 58     };
 59 
 60     OpType currentOpcode() const { return m_currentOpcode; }
 61     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
 62 
 63 private:
 64     static const bool verbose = false;
 65 
 66     PartialResult WARN_UNUSED_RETURN parseBody();
 67     PartialResult WARN_UNUSED_RETURN parseExpression();
 68     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
 69     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
 70 
 71 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
 72         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
 73         result = m_expressionStack.takeLast();                                              \
 74         m_toKillAfterExpression.append(result);                                             \
 75     } while (0)
 76 
 77     template&lt;OpType&gt;
 78     PartialResult WARN_UNUSED_RETURN unaryCase();
 79 
 80     template&lt;OpType&gt;
 81     PartialResult WARN_UNUSED_RETURN binaryCase();
 82 
 83 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
 84 
 85     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
 86 
 87     Context&amp; m_context;
<span class="line-modified"> 88     Stack m_expressionStack;</span>
 89     Vector&lt;ControlEntry&gt; m_controlStack;
 90     const Signature&amp; m_signature;
 91     const ModuleInformation&amp; m_info;
 92 
 93     OpType m_currentOpcode;
 94     size_t m_currentOpcodeStartingOffset { 0 };
 95 
 96     Vector&lt;ExpressionType, 8&gt; m_toKillAfterExpression;
 97 
 98     unsigned m_unreachableBlocks { 0 };
<span class="line-added"> 99     unsigned m_loopIndex { 0 };</span>
100 };
101 
102 template&lt;typename Context&gt;
103 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
104     : Parser(functionStart, functionLength)
105     , m_context(context)
<span class="line-added">106     , m_expressionStack(context.createStack())</span>
107     , m_signature(signature)
108     , m_info(info)
109 {
110     if (verbose)
<span class="line-modified">111         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);</span>
112     m_context.setParser(this);
113 }
114 
115 template&lt;typename Context&gt;
116 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
117 {
<span class="line-modified">118     uint32_t localGroupsCount;</span>
119 
120     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
<span class="line-modified">121     WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);</span>

122 
<span class="line-modified">123     uint64_t totalNumberOfLocals = m_signature.argumentCount();</span>
<span class="line-added">124     for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {</span>
125         uint32_t numberOfLocals;
126         Type typeOfLocal;
127 
128         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
<span class="line-modified">129         totalNumberOfLocals += numberOfLocals;</span>
<span class="line-added">130         WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);</span>
131         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
132         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
133     }
134 
135     WASM_FAIL_IF_HELPER_FAILS(parseBody());
136 
137     return { };
138 }
139 
140 template&lt;typename Context&gt;
141 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
142 {
<span class="line-modified">143     m_controlStack.append({ m_context.createStack(), m_context.addTopLevel(m_signature.returnType()) });</span>
144     uint8_t op;
145     while (m_controlStack.size()) {
146         ASSERT(m_toKillAfterExpression.isEmpty());
147 
148         m_currentOpcodeStartingOffset = m_offset;
149         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
150         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
151 
152         m_currentOpcode = static_cast&lt;OpType&gt;(op);
153 
154         if (verbose) {
155             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
156             m_context.dump(m_controlStack, &amp;m_expressionStack);
157         }
158 
159         if (m_unreachableBlocks)
160             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
161         else {
162             WASM_FAIL_IF_HELPER_FAILS(parseExpression());
163             while (m_toKillAfterExpression.size())
</pre>
<hr />
<pre>
268         int32_t constant;
269         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
270         m_expressionStack.append(m_context.addConstant(I32, constant));
271         return { };
272     }
273 
274     case F64Const: {
275         uint64_t constant;
276         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
277         m_expressionStack.append(m_context.addConstant(F64, constant));
278         return { };
279     }
280 
281     case I64Const: {
282         int64_t constant;
283         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
284         m_expressionStack.append(m_context.addConstant(I64, constant));
285         return { };
286     }
287 
<span class="line-added">288     case TableGet: {</span>
<span class="line-added">289         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">290         unsigned tableIndex;</span>
<span class="line-added">291         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);</span>
<span class="line-added">292         ExpressionType result, index;</span>
<span class="line-added">293         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);</span>
<span class="line-added">294         WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));</span>
<span class="line-added">295         m_expressionStack.append(result);</span>
<span class="line-added">296         return { };</span>
<span class="line-added">297     }</span>
<span class="line-added">298 </span>
<span class="line-added">299     case TableSet: {</span>
<span class="line-added">300         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">301         unsigned tableIndex;</span>
<span class="line-added">302         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);</span>
<span class="line-added">303         ExpressionType val, index;</span>
<span class="line-added">304         WASM_TRY_POP_EXPRESSION_STACK_INTO(val, &quot;table.set&quot;);</span>
<span class="line-added">305         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);</span>
<span class="line-added">306         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, val));</span>
<span class="line-added">307         return { };</span>
<span class="line-added">308     }</span>
<span class="line-added">309 </span>
<span class="line-added">310     case ExtTable: {</span>
<span class="line-added">311         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">312         uint8_t extOp;</span>
<span class="line-added">313         WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);</span>
<span class="line-added">314         unsigned tableIndex;</span>
<span class="line-added">315         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);</span>
<span class="line-added">316 </span>
<span class="line-added">317         switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {</span>
<span class="line-added">318         case ExtTableOpType::TableSize: {</span>
<span class="line-added">319             ExpressionType result;</span>
<span class="line-added">320             WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));</span>
<span class="line-added">321             m_expressionStack.append(result);</span>
<span class="line-added">322             break;</span>
<span class="line-added">323         }</span>
<span class="line-added">324         case ExtTableOpType::TableGrow: {</span>
<span class="line-added">325             ExpressionType fill, delta, result;</span>
<span class="line-added">326             WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);</span>
<span class="line-added">327             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);</span>
<span class="line-added">328             WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));</span>
<span class="line-added">329             m_expressionStack.append(result);</span>
<span class="line-added">330             break;</span>
<span class="line-added">331         }</span>
<span class="line-added">332         case ExtTableOpType::TableFill: {</span>
<span class="line-added">333             ExpressionType offset, fill, count;</span>
<span class="line-added">334             WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);</span>
<span class="line-added">335             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);</span>
<span class="line-added">336             WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);</span>
<span class="line-added">337             WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));</span>
<span class="line-added">338             break;</span>
<span class="line-added">339         }</span>
<span class="line-added">340         default:</span>
<span class="line-added">341             WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);</span>
<span class="line-added">342             break;</span>
<span class="line-added">343         }</span>
<span class="line-added">344         return { };</span>
<span class="line-added">345     }</span>
<span class="line-added">346 </span>
<span class="line-added">347     case RefNull: {</span>
<span class="line-added">348         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">349         m_expressionStack.append(m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
<span class="line-added">350         return { };</span>
<span class="line-added">351     }</span>
<span class="line-added">352 </span>
<span class="line-added">353     case RefIsNull: {</span>
<span class="line-added">354         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">355         ExpressionType result, value;</span>
<span class="line-added">356         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);</span>
<span class="line-added">357         WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));</span>
<span class="line-added">358         m_expressionStack.append(result);</span>
<span class="line-added">359         return { };</span>
<span class="line-added">360     }</span>
<span class="line-added">361 </span>
<span class="line-added">362     case RefFunc: {</span>
<span class="line-added">363         uint32_t index;</span>
<span class="line-added">364         ExpressionType result;</span>
<span class="line-added">365         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">366         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);</span>
<span class="line-added">367 </span>
<span class="line-added">368         WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));</span>
<span class="line-added">369         m_expressionStack.append(result);</span>
<span class="line-added">370         return { };</span>
<span class="line-added">371     }</span>
<span class="line-added">372 </span>
373     case GetLocal: {
374         uint32_t index;
375         ExpressionType result;
376         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
377         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
378         m_expressionStack.append(result);
379         return { };
380     }
381 
382     case SetLocal: {
383         uint32_t index;
384         ExpressionType value;
385         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
386         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
387         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
388         return { };
389     }
390 
391     case TeeLocal: {
392         uint32_t index;
</pre>
<hr />
<pre>
410         ExpressionType value;
411         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
412         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
413         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
414         return { };
415     }
416 
417     case Call: {
418         uint32_t functionIndex;
419         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
420         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
421 
422         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
423         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
424         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
425 
426         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
427         Vector&lt;ExpressionType&gt; args;
428         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
429         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)
<span class="line-modified">430             args.uncheckedAppend(m_expressionStack.at(i));</span>
431         m_expressionStack.shrink(firstArgumentIndex);
432 
433         ExpressionType result = Context::emptyExpression();
434         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, result));
435 
436         if (result != Context::emptyExpression())
437             m_expressionStack.append(result);
438 
439         return { };
440     }
441 
442     case CallIndirect: {
443         uint32_t signatureIndex;
<span class="line-modified">444         uint32_t tableIndex;</span>
<span class="line-modified">445         WASM_PARSER_FAIL_IF(!m_info.tableCount(), &quot;call_indirect is only valid when a table is defined or imported&quot;);</span>
446         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
<span class="line-modified">447         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get call_indirect&#39;s table index&quot;);</span>
<span class="line-modified">448         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;call_indirect&#39;s table index &quot;, tableIndex, &quot; invalid, limit is &quot;, m_info.tableCount());</span>
449         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());
<span class="line-added">450         WASM_PARSER_FAIL_IF(m_info.tables[tableIndex].type() != TableElementType::Funcref, &quot;call_indirect is only valid when a table has type funcref&quot;);</span>
451 
452         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
453         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
454         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
455 
456         Vector&lt;ExpressionType&gt; args;
457         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
458         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
459         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)
<span class="line-modified">460             args.uncheckedAppend(m_expressionStack.at(i));</span>
461         m_expressionStack.shrink(firstArgumentIndex);
462 
463         ExpressionType result = Context::emptyExpression();
<span class="line-modified">464         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, result));</span>
465 
466         if (result != Context::emptyExpression())
467             m_expressionStack.append(result);
468 
469         return { };
470     }
471 
472     case Block: {
473         Type inlineSignature;
474         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get block&#39;s inline signature&quot;);
475         m_controlStack.append({ WTFMove(m_expressionStack), m_context.addBlock(inlineSignature) });
<span class="line-modified">476         m_expressionStack = m_context.createStack();</span>
477         return { };
478     }
479 
480     case Loop: {
481         Type inlineSignature;
482         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get loop&#39;s inline signature&quot;);
<span class="line-modified">483         auto expressionStack = WTFMove(m_expressionStack);</span>
<span class="line-modified">484         auto loop = m_context.addLoop(inlineSignature, expressionStack, m_loopIndex++);</span>
<span class="line-added">485         m_controlStack.append({ expressionStack, loop });</span>
<span class="line-added">486         m_expressionStack = m_context.createStack();</span>
487         return { };
488     }
489 
490     case If: {
491         Type inlineSignature;
492         ExpressionType condition;
493         ControlType control;
494         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get if&#39;s inline signature&quot;);
495         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
496         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, control));
497         m_controlStack.append({ WTFMove(m_expressionStack), control });
<span class="line-modified">498         m_expressionStack = m_context.createStack();</span>
499         return { };
500     }
501 
502     case Else: {
503         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
504         WASM_TRY_ADD_TO_CONTEXT(addElse(m_controlStack.last().controlData, m_expressionStack));
505         m_expressionStack.shrink(0);
506         return { };
507     }
508 
509     case Br:
510     case BrIf: {
511         uint32_t target;
512         ExpressionType condition = Context::emptyExpression();
513         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
514         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
515         if (m_currentOpcode == BrIf)
516             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
517         else
518             m_unreachableBlocks = 1;
</pre>
<hr />
<pre>
661         Type unused;
662         WASM_PARSER_FAIL_IF(!parseResultType(unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
663         return { };
664     }
665 
666     case BrTable: {
667         uint32_t numberOfTargets;
668         uint32_t unused;
669         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
670         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
671 
672         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
673             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
674 
675         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
676         return { };
677     }
678 
679     case CallIndirect: {
680         uint32_t unused;
<span class="line-modified">681         uint32_t unused2;</span>
682         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
<span class="line-modified">683         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused2), &quot;can&#39;t get call_indirect&#39;s reserved byte in unreachable context&quot;);</span>
684         return { };
685     }
686 
687     case F32Const: {
688         uint32_t unused;
689         WASM_PARSER_FAIL_IF(!parseUInt32(unused), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
690         return { };
691     }
692 
693     case F64Const: {
694         uint64_t constant;
695         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
696         return { };
697     }
698 
699     // two immediate cases
700     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)
701     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {
702         uint32_t unused;
703         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get first immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
</pre>
<hr />
<pre>
714     case Br:
715     case BrIf:
716     case Call: {
717         uint32_t unused;
718         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
719         return { };
720     }
721 
722     case I32Const: {
723         int32_t unused;
724         WASM_PARSER_FAIL_IF(!parseVarInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
725         return { };
726     }
727 
728     case I64Const: {
729         int64_t unused;
730         WASM_PARSER_FAIL_IF(!parseVarInt64(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
731         return { };
732     }
733 
<span class="line-added">734     case ExtTable:</span>
<span class="line-added">735     case TableGet:</span>
<span class="line-added">736     case TableSet: {</span>
<span class="line-added">737         unsigned tableIndex;</span>
<span class="line-added">738         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);</span>
<span class="line-added">739         FALLTHROUGH;</span>
<span class="line-added">740     }</span>
<span class="line-added">741     case RefIsNull:</span>
<span class="line-added">742     case RefNull: {</span>
<span class="line-added">743         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">744         return { };</span>
<span class="line-added">745     }</span>
<span class="line-added">746 </span>
<span class="line-added">747     case RefFunc: {</span>
<span class="line-added">748         uint32_t unused;</span>
<span class="line-added">749         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
<span class="line-added">750         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);</span>
<span class="line-added">751         return { };</span>
<span class="line-added">752     }</span>
<span class="line-added">753 </span>
754     case GrowMemory:
755     case CurrentMemory: {
756         uint8_t reserved;
757         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory/current_memory&quot;);
758         return { };
759     }
760 
761     // no immediate cases
762     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
763     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
764     case Unreachable:
765     case Nop:
766     case Return:
767     case Select:
768     case Drop: {
769         return { };
770     }
771     }
772 #undef CREATE_CASE
773     RELEASE_ASSERT_NOT_REACHED();
</pre>
</td>
</tr>
</table>
<center><a href="WasmFormat.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmIndexOrName.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>