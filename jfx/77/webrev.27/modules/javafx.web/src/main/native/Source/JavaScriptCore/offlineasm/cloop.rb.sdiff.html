<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="backends.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 # Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 require &quot;config&quot;
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 
  28 # The CLoop llint backend is initially based on the ARMv7 backend, and
  29 # then further enhanced with a few instructions from the x86 backend to
  30 # support building for X64 targets.  Hence, the shape of the generated
  31 # code and the usage convention of registers will look a lot like the
  32 # ARMv7 backend&#39;s.
  33 
  34 def cloopMapType(type)
  35     case type
<span class="line-modified">  36     when :int;            &quot;.i()&quot;</span>
<span class="line-modified">  37     when :uint;           &quot;.u()&quot;</span>
  38     when :int32;          &quot;.i32()&quot;
  39     when :uint32;         &quot;.u32()&quot;
  40     when :int64;          &quot;.i64()&quot;
  41     when :uint64;         &quot;.u64()&quot;
  42     when :int8;           &quot;.i8()&quot;
  43     when :uint8;          &quot;.u8()&quot;
  44     when :int8Ptr;        &quot;.i8p()&quot;
  45     when :voidPtr;        &quot;.vp()&quot;
  46     when :nativeFunc;     &quot;.nativeFunc()&quot;
  47     when :double;         &quot;.d()&quot;
  48     when :bitsAsDouble;   &quot;.bitsAsDouble()&quot;
  49     when :bitsAsInt64;    &quot;.bitsAsInt64()&quot;
  50     when :opcode;         &quot;.opcode()&quot;
  51     else;
  52         raise &quot;Unsupported type&quot;
  53     end
  54 end
  55 
  56 
  57 class SpecialRegister &lt; NoChildren
<span class="line-modified">  58     def clLValue(type=:int)</span>
  59         clDump
  60     end
  61     def clDump
  62         @name
  63     end
<span class="line-modified">  64     def clValue(type=:int)</span>
  65         @name + cloopMapType(type)
  66     end
  67 end
  68 
  69 C_LOOP_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
  70 
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
</pre>
<hr />
<pre>
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
  91             &quot;tagTypeNumber&quot;
  92         when &quot;csr2&quot;
  93             &quot;tagMask&quot;
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
<span class="line-modified"> 106     def clLValue(type=:int)</span>
 107         clDump
 108     end
<span class="line-modified"> 109     def clValue(type=:int)</span>
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
 114 class FPRegisterID
 115     def clDump
 116         case name
 117         when &quot;ft0&quot;, &quot;fr&quot;
 118             &quot;d0&quot;
 119         when &quot;ft1&quot;
 120             &quot;d1&quot;
 121         when &quot;ft2&quot;
 122             &quot;d2&quot;
 123         when &quot;ft3&quot;
 124             &quot;d3&quot;
 125         when &quot;ft4&quot;
 126             &quot;d4&quot;
 127         when &quot;ft5&quot;
 128             &quot;d5&quot;
 129         else
 130             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 131         end
 132     end
<span class="line-modified"> 133     def clLValue(type=:int)</span>
 134         clDump
 135     end
<span class="line-modified"> 136     def clValue(type=:int)</span>
 137         clDump + cloopMapType(type)
 138     end
 139 end
 140 
 141 class Immediate
 142     def clDump
 143         &quot;#{value}&quot;
 144     end
<span class="line-modified"> 145     def clLValue(type=:int)</span>
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
<span class="line-modified"> 148     def clValue(type=:int)</span>
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
 163         when :int32;   &quot;int32_t(#{valueStr})&quot;
 164         when :int64;   &quot;int64_t(#{valueStr})&quot;
<span class="line-modified"> 165         when :int;     &quot;intptr_t(#{valueStr})&quot;</span>
 166         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 167         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 168         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
<span class="line-modified"> 169         when :uint;    &quot;uintptr_t(#{valueStr})&quot;</span>
 170         else
 171             raise &quot;Not implemented immediate of type: #{type}&quot; 
 172         end
 173     end
 174 end
 175 
 176 class Address
 177     def clDump
 178         &quot;[#{base.clDump}, #{offset.value}]&quot;
 179     end
<span class="line-modified"> 180     def clLValue(type=:int)</span>
 181         clValue(type)
 182     end
<span class="line-modified"> 183     def clValue(type=:int)</span>
 184         case type
 185         when :int8;         int8MemRef
 186         when :int32;        int32MemRef
 187         when :int64;        int64MemRef
<span class="line-modified"> 188         when :int;          intMemRef</span>
 189         when :uint8;        uint8MemRef
 190         when :uint32;       uint32MemRef
 191         when :uint64;       uint64MemRef
<span class="line-modified"> 192         when :uint;         uintMemRef</span>
 193         when :opcode;       opcodeMemRef
 194         when :nativeFunc;   nativeFuncMemRef
 195         else
 196             raise &quot;Unexpected Address type: #{type}&quot;
 197         end
 198     end
 199     def pointerExpr
 200         if  offset.value == 0
 201             &quot;#{base.clValue(:int8Ptr)}&quot;
 202         elsif offset.value &gt; 0
 203             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 204         else
 205             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
 206         end
 207     end
 208     def int8MemRef
 209         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 210     end
 211     def int16MemRef
 212         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 213     end
 214     def int32MemRef
 215         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 216     end
 217     def int64MemRef
 218         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 219     end
<span class="line-modified"> 220     def intMemRef</span>
 221         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 222     end
 223     def uint8MemRef
 224         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 225     end
 226     def uint16MemRef
 227         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 228     end
 229     def uint32MemRef
 230         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 231     end
 232     def uint64MemRef
 233         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 234     end
<span class="line-modified"> 235     def uintMemRef</span>
 236         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 237     end
 238     def nativeFuncMemRef
 239         &quot;*CAST&lt;NativeFunction*&gt;(#{pointerExpr})&quot;
 240     end
 241     def opcodeMemRef
 242         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 243     end
 244     def dblMemRef
 245         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 246     end
 247 end
 248 
 249 class BaseIndex
 250     def clDump
 251         &quot;[#{base.clDump}, #{offset.clDump}, #{index.clDump} &lt;&lt; #{scaleShift}]&quot;
 252     end
<span class="line-modified"> 253     def clLValue(type=:int)</span>
 254         clValue(type)
 255     end
<span class="line-modified"> 256     def clValue(type=:int)</span>
 257         case type
 258         when :int8;       int8MemRef
 259         when :int32;      int32MemRef
 260         when :int64;      int64MemRef
<span class="line-modified"> 261         when :int;        intMemRef</span>
 262         when :uint8;      uint8MemRef
 263         when :uint32;     uint32MemRef
 264         when :uint64;     uint64MemRef
<span class="line-modified"> 265         when :uint;       uintMemRef</span>
 266         when :opcode;     opcodeMemRef
 267         else
 268             raise &quot;Unexpected BaseIndex type: #{type}&quot;
 269         end
 270     end
 271     def pointerExpr
 272         if offset.value == 0
 273             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift})&quot;
 274         else
 275             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift}) + #{offset.clValue}&quot;
 276         end
 277     end
 278     def int8MemRef
 279         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 280     end
 281     def int16MemRef
 282         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 283     end
 284     def int32MemRef
 285         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 286     end
 287     def int64MemRef
 288         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 289     end
<span class="line-modified"> 290     def intMemRef</span>
 291         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 292     end
 293     def uint8MemRef
 294         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 295     end
 296     def uint16MemRef
 297         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 298     end
 299     def uint32MemRef
 300         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 301     end
 302     def uint64MemRef
 303         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 304     end
<span class="line-modified"> 305     def uintMemRef</span>
 306         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 307     end
 308     def opcodeMemRef
 309         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 310     end
 311     def dblMemRef
 312         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 313     end
 314 end
 315 
 316 class AbsoluteAddress
 317     def clDump
 318         &quot;#{codeOriginString}&quot;
 319     end
<span class="line-modified"> 320     def clLValue(type=:int)</span>
 321         clValue(type)
 322     end
 323     def clValue
 324         clDump
 325     end
 326 end
 327 
 328 class LabelReference
<span class="line-modified"> 329     def intMemRef</span>
 330         &quot;*CAST&lt;intptr_t*&gt;(&amp;#{cLabel})&quot;
 331     end
 332     def cloopEmitLea(destination, type)
 333         $asm.putc &quot;#{destination.clLValue(:voidPtr)} = CAST&lt;void*&gt;(&amp;#{cLabel});&quot;
 334     end
 335 end
 336 
 337 
 338 #
 339 # Lea support.
 340 #
 341 
 342 class Address
 343     def cloopEmitLea(destination, type)
 344         if destination == base
 345             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} += #{offset.clValue(type)};&quot;
 346         else
 347             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + #{offset.clValue(type)};&quot;
 348         end
 349     end
</pre>
<hr />
<pre>
 368         myList.each {
 369             | node |
 370             unless node.is_a? Instruction or
 371                     node.is_a? Label or
 372                     node.is_a? LocalLabel or
 373                     node.is_a? Skip
 374                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 375             end
 376         }
 377         
 378         return myList
 379     end
 380 end
 381 
 382 def clOperands(operands)
 383     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 384 end
 385 
 386 
 387 def cloopEmitOperation(operands, type, operator)
<span class="line-modified"> 388     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || \</span>
 389         type == :int64 || type == :uint64 || type == :double
 390     if operands.size == 3
 391         op1 = operands[0]
 392         op2 = operands[1]
 393         dst = operands[2]
 394     else
 395         raise unless operands.size == 2
 396         op1 = operands[1]
 397         op2 = operands[0]
 398         dst = operands[1]
 399     end
 400     raise unless not dst.is_a? Immediate
 401     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 402         truncationHeader = &quot;(uint32_t)(&quot;
 403         truncationFooter = &quot;)&quot;
 404     else
 405         truncationHeader = &quot;&quot;
 406         truncationFooter = &quot;&quot;
 407     end
 408     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 409 end
 410 
 411 def cloopEmitShiftOperation(operands, type, operator)
<span class="line-modified"> 412     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 413     if operands.size == 3
 414         op1 = operands[0]
 415         op2 = operands[1]
 416         dst = operands[2]
 417     else
 418         op1 = operands[1]
 419         op2 = operands[0]
 420         dst = operands[1]
 421     end
 422     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 423         truncationHeader = &quot;(uint32_t)(&quot;
 424         truncationFooter = &quot;)&quot;
 425     else
 426         truncationHeader = &quot;&quot;
 427         truncationFooter = &quot;&quot;
 428     end
<span class="line-modified"> 429     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operands[1].clValue(type)} #{operator} (#{operands[0].clValue(:int)} &amp; 0x1f)#{truncationFooter};&quot;</span>



 430 end
 431 
 432 def cloopEmitUnaryOperation(operands, type, operator)
<span class="line-modified"> 433     raise unless type == :int || type == :uint || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 434     raise unless operands.size == 1
 435     raise unless not operands[0].is_a? Immediate
 436     op = operands[0]
 437     dst = operands[0]
 438     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 439         truncationHeader = &quot;(uint32_t)(&quot;
 440         truncationFooter = &quot;)&quot;
 441     else
 442         truncationHeader = &quot;&quot;
 443         truncationFooter = &quot;&quot;
 444     end
 445     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operator}#{op.clValue(type)}#{truncationFooter};&quot;
 446 end
 447 
 448 def cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, condition)
 449     $asm.putc &quot;if (std::isnan(#{operands[0].clValue(:double)}) || std::isnan(#{operands[1].clValue(:double)})&quot;
 450     $asm.putc &quot;    || (#{operands[0].clValue(:double)} #{condition} #{operands[1].clValue(:double)}))&quot;
 451     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 452 end
 453 
</pre>
<hr />
<pre>
 484 end
 485 
 486 # conditionTest should contain a string that provides a comparator and a RHS
 487 # value e.g. &quot;&lt; 0&quot;.
 488 def cloopEmitTestAndBranchIf(operands, type, conditionTest, branchTarget)
 489     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 490     $asm.putc &quot;if (#{conditionExpr})&quot;
 491     $asm.putc &quot;    goto #{branchTarget};&quot;
 492 end
 493 
 494 def cloopEmitTestSet(operands, type, conditionTest)
 495     # The result is a boolean condition.  Hence, the result type is always an
 496     # int.  The passed in type is only used for the values being tested in
 497     # the condition test.
 498     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 499     $asm.putc &quot;#{operands[-1].clLValue} = (#{conditionExpr});&quot;
 500 end
 501 
 502 def cloopEmitOpAndBranch(operands, operator, type, conditionTest)
 503     case type
<span class="line-modified"> 504     when :int;   tempType = &quot;intptr_t&quot;</span>
 505     when :int32; tempType = &quot;int32_t&quot;
 506     when :int64; tempType = &quot;int64_t&quot;
 507     else
 508         raise &quot;Unimplemented type&quot;
 509     end
 510 
 511     $asm.putc &quot;{&quot;
 512     $asm.putc &quot;    #{tempType} temp = #{operands[1].clValue(type)} #{operator} #{operands[0].clValue(type)};&quot;
 513     $asm.putc &quot;    #{operands[1].clLValue(type)} = temp;&quot;
 514     $asm.putc &quot;    if (temp #{conditionTest})&quot;
 515     $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 516     $asm.putc &quot;}&quot;
 517 end
 518 
 519 def cloopEmitOpAndBranchIfOverflow(operands, operator, type)
 520     case type
 521     when :int32
 522         tempType = &quot;int32_t&quot;
 523         truncationHeader = &quot;(uint32_t)(&quot;
 524         truncationFooter = &quot;)&quot;
</pre>
<hr />
<pre>
 550     $asm.putc &quot;{&quot;
 551     $asm.putc &quot;    cloopStack.setCurrentStackPointer(sp.vp());&quot;
 552     $asm.putc &quot;    SlowPathReturnType result = #{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 553     $asm.putc &quot;    decodeResult(result, t0, t1);&quot;
 554     $asm.putc &quot;}&quot;
 555 end
 556 
 557 def cloopEmitCallSlowPathVoid(operands)
 558     $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
 559     $asm.putc &quot;#{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 560 end
 561 
 562 class Instruction
 563     def lowerC_LOOP
 564         case opcode
 565         when &quot;addi&quot;
 566             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 567         when &quot;addq&quot;
 568             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 569         when &quot;addp&quot;
<span class="line-modified"> 570             cloopEmitOperation(operands, :int, &quot;+&quot;)</span>
 571 
 572         when &quot;andi&quot;
 573             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 574         when &quot;andq&quot;
 575             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 576         when &quot;andp&quot;
<span class="line-modified"> 577             cloopEmitOperation(operands, :int, &quot;&amp;&quot;)</span>
 578 
 579         when &quot;ori&quot;
 580             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 581         when &quot;orq&quot;
 582             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 583         when &quot;orp&quot;
<span class="line-modified"> 584             cloopEmitOperation(operands, :int, &quot;|&quot;)</span>
 585 
 586         when &quot;xori&quot;
 587             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 588         when &quot;xorq&quot;
 589             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 590         when &quot;xorp&quot;
<span class="line-modified"> 591             cloopEmitOperation(operands, :int, &quot;^&quot;)</span>
 592 
 593         when &quot;lshifti&quot;
 594             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 595         when &quot;lshiftq&quot;
 596             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 597         when &quot;lshiftp&quot;
<span class="line-modified"> 598             cloopEmitShiftOperation(operands, :int, &quot;&lt;&lt;&quot;)</span>
 599 
 600         when &quot;rshifti&quot;
 601             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 602         when &quot;rshiftq&quot;
 603             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 604         when &quot;rshiftp&quot;
<span class="line-modified"> 605             cloopEmitShiftOperation(operands, :int, &quot;&gt;&gt;&quot;)</span>
 606 
 607         when &quot;urshifti&quot;
 608             cloopEmitShiftOperation(operands, :uint32, &quot;&gt;&gt;&quot;)
 609         when &quot;urshiftq&quot;
 610             cloopEmitShiftOperation(operands, :uint64, &quot;&gt;&gt;&quot;)
 611         when &quot;urshiftp&quot;
<span class="line-modified"> 612             cloopEmitShiftOperation(operands, :uint, &quot;&gt;&gt;&quot;)</span>
 613 
 614         when &quot;muli&quot;
 615             cloopEmitOperation(operands, :int32, &quot;*&quot;)
 616         when &quot;mulq&quot;
 617             cloopEmitOperation(operands, :int64, &quot;*&quot;)
 618         when &quot;mulp&quot;
<span class="line-modified"> 619             cloopEmitOperation(operands, :int, &quot;*&quot;)</span>
 620 
 621         when &quot;subi&quot;
 622             cloopEmitOperation(operands, :int32, &quot;-&quot;)
 623         when &quot;subq&quot;
 624             cloopEmitOperation(operands, :int64, &quot;-&quot;)
 625         when &quot;subp&quot;
<span class="line-modified"> 626             cloopEmitOperation(operands, :int, &quot;-&quot;)</span>
 627 
 628         when &quot;negi&quot;
 629             cloopEmitUnaryOperation(operands, :int32, &quot;-&quot;)
 630         when &quot;negq&quot;
 631             cloopEmitUnaryOperation(operands, :int64, &quot;-&quot;)
 632         when &quot;negp&quot;
<span class="line-modified"> 633             cloopEmitUnaryOperation(operands, :int, &quot;-&quot;)</span>
 634 
 635         when &quot;noti&quot;
 636             cloopEmitUnaryOperation(operands, :int32, &quot;~&quot;)
 637 
 638         when &quot;loadi&quot;
 639             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = #{operands[0].uint32MemRef};&quot;
 640             # There&#39;s no need to call clearHighWord() here because the above will
 641             # automatically take care of 0 extension.
 642         when &quot;loadis&quot;
 643             $asm.putc &quot;#{operands[1].clLValue(:int32)} = #{operands[0].int32MemRef};&quot;
 644         when &quot;loadq&quot;
 645             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].int64MemRef};&quot;
 646         when &quot;loadp&quot;
<span class="line-modified"> 647             $asm.putc &quot;#{operands[1].clLValue} = #{operands[0].intMemRef};&quot;</span>
 648         when &quot;storei&quot;
 649             $asm.putc &quot;#{operands[1].int32MemRef} = #{operands[0].clValue(:int32)};&quot;
 650         when &quot;storeq&quot;
 651             $asm.putc &quot;#{operands[1].int64MemRef} = #{operands[0].clValue(:int64)};&quot;
 652         when &quot;storep&quot;
<span class="line-modified"> 653             $asm.putc &quot;#{operands[1].intMemRef} = #{operands[0].clValue(:int)};&quot;</span>
 654         when &quot;loadb&quot;
<span class="line-modified"> 655             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].uint8MemRef};&quot;</span>
<span class="line-modified"> 656         when &quot;loadbs&quot;</span>
<span class="line-modified"> 657             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(#{operands[0].int8MemRef});&quot;</span>
<span class="line-modified"> 658         when &quot;loadbsp&quot;</span>
<span class="line-modified"> 659             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].int8MemRef};&quot;</span>
 660         when &quot;storeb&quot;
 661             $asm.putc &quot;#{operands[1].uint8MemRef} = #{operands[0].clValue(:int8)};&quot;
 662         when &quot;loadh&quot;
<span class="line-modified"> 663             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].uint16MemRef};&quot;</span>
<span class="line-modified"> 664         when &quot;loadhs&quot;</span>
<span class="line-modified"> 665             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(#{operands[0].int16MemRef});&quot;</span>


 666         when &quot;storeh&quot;
 667             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 668         when &quot;loadd&quot;
 669             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 670         when &quot;stored&quot;
 671             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 672 
 673         when &quot;addd&quot;
 674             cloopEmitOperation(operands, :double, &quot;+&quot;)
 675         when &quot;divd&quot;
 676             cloopEmitOperation(operands, :double, &quot;/&quot;)
 677         when &quot;subd&quot;
 678             cloopEmitOperation(operands, :double, &quot;-&quot;)
 679         when &quot;muld&quot;
 680             cloopEmitOperation(operands, :double, &quot;*&quot;)
 681 
 682         # Convert an int value to its double equivalent, and store it in a double register.
 683         when &quot;ci2d&quot;
 684             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;
 685 
</pre>
<hr />
<pre>
 693             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 694         when &quot;bdlt&quot;
 695             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 696         when &quot;bdlteq&quot;
 697             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 698 
 699         when &quot;bdequn&quot;
 700             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 701         when &quot;bdnequn&quot;
 702             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 703         when &quot;bdgtun&quot;
 704             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
 705         when &quot;bdgtequn&quot;
 706             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;=&quot;)
 707         when &quot;bdltun&quot;
 708             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;&quot;)
 709         when &quot;bdltequn&quot;
 710             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;=&quot;)
 711 
 712         when &quot;td2i&quot;
<span class="line-modified"> 713             $asm.putc &quot;#{operands[1].clLValue(:int)} = (uint32_t)(intptr_t)#{operands[0].clValue(:double)}; // td2i&quot;</span>
 714 
 715         when &quot;bcd2i&quot;  # operands: srcDbl dstInt slowPath
 716             $asm.putc &quot;{ // bcd2i&quot;
 717             $asm.putc &quot;    double d = #{operands[0].clValue(:double)};&quot;
 718             $asm.putc &quot;    const int32_t asInt32 = int32_t(d);&quot;
 719             $asm.putc &quot;    if (asInt32 != d || (!asInt32 &amp;&amp; std::signbit(d))) // true for -0.0&quot;
 720             $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 721             $asm.putc &quot;    #{operands[1].clLValue} = (uint32_t)asInt32;&quot;
 722             $asm.putc &quot;}&quot;
 723 
 724         when &quot;move&quot;
<span class="line-modified"> 725             $asm.putc &quot;#{operands[1].clLValue(:int)} = #{operands[0].clValue(:int)};&quot;</span>
 726         when &quot;sxi2q&quot;
 727             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:int32)};&quot;
 728         when &quot;zxi2q&quot;
 729             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = #{operands[0].clValue(:uint32)};&quot;
 730         when &quot;nop&quot;
 731             $asm.putc &quot;// nop&quot;
 732         when &quot;bbeq&quot;
 733             cloopEmitCompareAndBranch(operands, :int8, &quot;==&quot;)
 734         when &quot;bieq&quot;
 735             cloopEmitCompareAndBranch(operands, :int32, &quot;==&quot;)
 736         when &quot;bqeq&quot;
 737             cloopEmitCompareAndBranch(operands, :int64, &quot;==&quot;)
 738         when &quot;bpeq&quot;
<span class="line-modified"> 739             cloopEmitCompareAndBranch(operands, :int, &quot;==&quot;)</span>
 740 
 741         when &quot;bbneq&quot;
 742             cloopEmitCompareAndBranch(operands, :int8, &quot;!=&quot;)
 743         when &quot;bineq&quot;
 744             cloopEmitCompareAndBranch(operands, :int32, &quot;!=&quot;)
 745         when &quot;bqneq&quot;
 746             cloopEmitCompareAndBranch(operands, :int64, &quot;!=&quot;)
 747         when &quot;bpneq&quot;
<span class="line-modified"> 748             cloopEmitCompareAndBranch(operands, :int, &quot;!=&quot;)</span>
 749 
 750         when &quot;bba&quot;
 751             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;&quot;)
 752         when &quot;bia&quot;
 753             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;&quot;)
 754         when &quot;bqa&quot;
 755             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;&quot;)
 756         when &quot;bpa&quot;
<span class="line-modified"> 757             cloopEmitCompareAndBranch(operands, :uint, &quot;&gt;&quot;)</span>
 758 
 759         when &quot;bbaeq&quot;
 760             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;=&quot;)
 761         when &quot;biaeq&quot;
 762             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;=&quot;)
 763         when &quot;bqaeq&quot;
 764             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;=&quot;)
 765         when &quot;bpaeq&quot;
<span class="line-modified"> 766             cloopEmitCompareAndBranch(operands, :uint, &quot;&gt;=&quot;)</span>
 767 
 768         when &quot;bbb&quot;
 769             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;&quot;)
 770         when &quot;bib&quot;
 771             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;&quot;)
 772         when &quot;bqb&quot;
 773             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;&quot;)
 774         when &quot;bpb&quot;
<span class="line-modified"> 775             cloopEmitCompareAndBranch(operands, :uint, &quot;&lt;&quot;)</span>
 776 
 777         when &quot;bbbeq&quot;
 778             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;=&quot;)
 779         when &quot;bibeq&quot;
 780             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;=&quot;)
 781         when &quot;bqbeq&quot;
 782             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;=&quot;)
 783         when &quot;bpbeq&quot;
<span class="line-modified"> 784             cloopEmitCompareAndBranch(operands, :uint, &quot;&lt;=&quot;)</span>
 785 
 786         when &quot;bbgt&quot;
 787             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;&quot;)
 788         when &quot;bigt&quot;
 789             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;&quot;)
 790         when &quot;bqgt&quot;
 791             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;&quot;)
 792         when &quot;bpgt&quot;
<span class="line-modified"> 793             cloopEmitCompareAndBranch(operands, :int, &quot;&gt;&quot;)</span>
 794 
 795         when &quot;bbgteq&quot;
 796             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;=&quot;)
 797         when &quot;bigteq&quot;
 798             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;=&quot;)
 799         when &quot;bqgteq&quot;
 800             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;=&quot;)
 801         when &quot;bpgteq&quot;
<span class="line-modified"> 802             cloopEmitCompareAndBranch(operands, :int, &quot;&gt;=&quot;)</span>
 803 
 804         when &quot;bblt&quot;
 805             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;&quot;)
 806         when &quot;bilt&quot;
 807             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;&quot;)
 808         when &quot;bqlt&quot;
 809             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;&quot;)
 810         when &quot;bplt&quot;
<span class="line-modified"> 811             cloopEmitCompareAndBranch(operands, :int, &quot;&lt;&quot;)</span>
 812 
 813         when &quot;bblteq&quot;
 814             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;=&quot;)
 815         when &quot;bilteq&quot;
 816             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;=&quot;)
 817         when &quot;bqlteq&quot;
 818             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;=&quot;)
 819         when &quot;bplteq&quot;
<span class="line-modified"> 820             cloopEmitCompareAndBranch(operands, :int, &quot;&lt;=&quot;)</span>
 821 
 822         when &quot;btbz&quot;
 823             cloopEmitTestAndBranchIf(operands, :int8, &quot;== 0&quot;, operands[-1].cLabel)
 824         when &quot;btiz&quot;
 825             cloopEmitTestAndBranchIf(operands, :int32, &quot;== 0&quot;, operands[-1].cLabel)
 826         when &quot;btqz&quot;
 827             cloopEmitTestAndBranchIf(operands, :int64, &quot;== 0&quot;, operands[-1].cLabel)
 828         when &quot;btpz&quot;
<span class="line-modified"> 829             cloopEmitTestAndBranchIf(operands, :int, &quot;== 0&quot;, operands[-1].cLabel)</span>
 830 
 831         when &quot;btbnz&quot;
 832             cloopEmitTestAndBranchIf(operands, :int8, &quot;!= 0&quot;, operands[-1].cLabel)
 833         when &quot;btinz&quot;
 834             cloopEmitTestAndBranchIf(operands, :int32, &quot;!= 0&quot;, operands[-1].cLabel)
 835         when &quot;btqnz&quot;
 836             cloopEmitTestAndBranchIf(operands, :int64, &quot;!= 0&quot;, operands[-1].cLabel)
 837         when &quot;btpnz&quot;
<span class="line-modified"> 838             cloopEmitTestAndBranchIf(operands, :int, &quot;!= 0&quot;, operands[-1].cLabel)</span>
 839 
 840         when &quot;btbs&quot;
 841             cloopEmitTestAndBranchIf(operands, :int8, &quot;&lt; 0&quot;, operands[-1].cLabel)
 842         when &quot;btis&quot;
 843             cloopEmitTestAndBranchIf(operands, :int32, &quot;&lt; 0&quot;, operands[-1].cLabel)
 844         when &quot;btqs&quot;
 845             cloopEmitTestAndBranchIf(operands, :int64, &quot;&lt; 0&quot;, operands[-1].cLabel)
 846         when &quot;btps&quot;
<span class="line-modified"> 847             cloopEmitTestAndBranchIf(operands, :int, &quot;&lt; 0&quot;, operands[-1].cLabel)</span>
 848 
 849         # For jmp, we do not want to assume that we have COMPUTED_GOTO support.
 850         # Fortunately, the only times we should ever encounter indirect jmps is
 851         # when the jmp target is a CLoop opcode (by design).
 852         #
 853         # Hence, we check if the jmp target is a known label reference. If so,
 854         # we can emit a goto directly. If it is not a known target, then we set
 855         # the target in the opcode, and dispatch to it via whatever dispatch
 856         # mechanism is in used.
 857         when &quot;jmp&quot;
 858             if operands[0].is_a? LocalLabelReference or operands[0].is_a? LabelReference
 859                 # Handles jumps local or global labels.
 860                 $asm.putc &quot;goto #{operands[0].cLabel};&quot;
 861             else
 862                 # Handles jumps to some computed target.
 863                 # NOTE: must be an opcode handler or a llint glue helper.
 864                 $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
 865                 $asm.putc &quot;DISPATCH_OPCODE();&quot;
 866             end
 867 
 868         when &quot;call&quot;
 869             $asm.putc &quot;CRASH(); // generic call instruction not supported by design!&quot;
 870         when &quot;break&quot;
 871             $asm.putc &quot;CRASH(); // break instruction not implemented.&quot;
 872         when &quot;ret&quot;
 873             $asm.putc &quot;opcode = lr.opcode();&quot;
 874             $asm.putc &quot;DISPATCH_OPCODE();&quot;
 875 
 876         when &quot;cbeq&quot;
 877             cloopEmitCompareAndSet(operands, :uint8, &quot;==&quot;)
 878         when &quot;cieq&quot;
 879             cloopEmitCompareAndSet(operands, :uint32, &quot;==&quot;)
 880         when &quot;cqeq&quot;
 881             cloopEmitCompareAndSet(operands, :uint64, &quot;==&quot;)
 882         when &quot;cpeq&quot;
<span class="line-modified"> 883             cloopEmitCompareAndSet(operands, :uint, &quot;==&quot;)</span>
 884 
 885         when &quot;cbneq&quot;
 886             cloopEmitCompareAndSet(operands, :uint8, &quot;!=&quot;)
 887         when &quot;cineq&quot;
 888             cloopEmitCompareAndSet(operands, :uint32, &quot;!=&quot;)
 889         when &quot;cqneq&quot;
 890             cloopEmitCompareAndSet(operands, :uint64, &quot;!=&quot;)
 891         when &quot;cpneq&quot;
<span class="line-modified"> 892             cloopEmitCompareAndSet(operands, :uint, &quot;!=&quot;)</span>
 893 
 894         when &quot;cba&quot;
 895             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;&quot;)
 896         when &quot;cia&quot;
 897             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;&quot;)
 898         when &quot;cqa&quot;
 899             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;&quot;)
 900         when &quot;cpa&quot;
<span class="line-modified"> 901             cloopEmitCompareAndSet(operands, :uint, &quot;&gt;&quot;)</span>
 902 
 903         when &quot;cbaeq&quot;
 904             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;=&quot;)
 905         when &quot;ciaeq&quot;
 906             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;=&quot;)
 907         when &quot;cqaeq&quot;
 908             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;=&quot;)
 909         when &quot;cpaeq&quot;
<span class="line-modified"> 910             cloopEmitCompareAndSet(operands, :uint, &quot;&gt;=&quot;)</span>
 911 
 912         when &quot;cbb&quot;
 913             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;&quot;)
 914         when &quot;cib&quot;
 915             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;&quot;)
 916         when &quot;cqb&quot;
 917             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;&quot;)
 918         when &quot;cpb&quot;
<span class="line-modified"> 919             cloopEmitCompareAndSet(operands, :uint, &quot;&lt;&quot;)</span>
 920 
 921         when &quot;cbbeq&quot;
 922             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;=&quot;)
 923         when &quot;cibeq&quot;
 924             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;=&quot;)
 925         when &quot;cqbeq&quot;
 926             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;=&quot;)
 927         when &quot;cpbeq&quot;
<span class="line-modified"> 928             cloopEmitCompareAndSet(operands, :uint, &quot;&lt;=&quot;)</span>
 929 
 930         when &quot;cbgt&quot;
 931             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;&quot;)
 932         when &quot;cigt&quot;
 933             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;&quot;)
 934         when &quot;cqgt&quot;
 935             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;&quot;)
 936         when &quot;cpgt&quot;
<span class="line-modified"> 937             cloopEmitCompareAndSet(operands, :int, &quot;&gt;&quot;)</span>
 938 
 939         when &quot;cbgteq&quot;
 940             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;=&quot;)
 941         when &quot;cigteq&quot;
 942             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;=&quot;)
 943         when &quot;cqgteq&quot;
 944             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;=&quot;)
 945         when &quot;cpgteq&quot;
<span class="line-modified"> 946             cloopEmitCompareAndSet(operands, :int, &quot;&gt;=&quot;)</span>
 947 
 948         when &quot;cblt&quot;
 949             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;&quot;)
 950         when &quot;cilt&quot;
 951             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;&quot;)
 952         when &quot;cqlt&quot;
 953             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;&quot;)
 954         when &quot;cplt&quot;
<span class="line-modified"> 955             cloopEmitCompareAndSet(operands, :int, &quot;&lt;&quot;)</span>
 956 
 957         when &quot;cblteq&quot;
 958             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;=&quot;)
 959         when &quot;cilteq&quot;
 960             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;=&quot;)
 961         when &quot;cqlteq&quot;
 962             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;=&quot;)
 963         when &quot;cplteq&quot;
<span class="line-modified"> 964             cloopEmitCompareAndSet(operands, :int, &quot;&lt;=&quot;)</span>
 965 
 966         when &quot;tbs&quot;
 967             cloopEmitTestSet(operands, :int8, &quot;&lt; 0&quot;)
 968         when &quot;tis&quot;
 969             cloopEmitTestSet(operands, :int32, &quot;&lt; 0&quot;)
 970         when &quot;tqs&quot;
 971             cloopEmitTestSet(operands, :int64, &quot;&lt; 0&quot;)
 972         when &quot;tps&quot;
<span class="line-modified"> 973             cloopEmitTestSet(operands, :int, &quot;&lt; 0&quot;)</span>
 974 
 975         when &quot;tbz&quot;
 976             cloopEmitTestSet(operands, :int8, &quot;== 0&quot;)
 977         when &quot;tiz&quot;
 978             cloopEmitTestSet(operands, :int32, &quot;== 0&quot;)
 979         when &quot;tqz&quot;
 980             cloopEmitTestSet(operands, :int64, &quot;== 0&quot;)
 981         when &quot;tpz&quot;
<span class="line-modified"> 982             cloopEmitTestSet(operands, :int, &quot;== 0&quot;)</span>
 983 
 984         when &quot;tbnz&quot;
 985             cloopEmitTestSet(operands, :int8, &quot;!= 0&quot;)
 986         when &quot;tinz&quot;
 987             cloopEmitTestSet(operands, :int32, &quot;!= 0&quot;)
 988         when &quot;tqnz&quot;
 989             cloopEmitTestSet(operands, :int64, &quot;!= 0&quot;)
 990         when &quot;tpnz&quot;
<span class="line-modified"> 991             cloopEmitTestSet(operands, :int, &quot;!= 0&quot;)</span>
 992 
 993         # 64-bit instruction: cdqi (based on X64)
 994         # Sign extends the lower 32 bits of t0, but put the sign extension into
 995         # the lower 32 bits of t1. Leave the upper 32 bits of t0 and t1 unchanged.
 996         when &quot;cdqi&quot;
 997             $asm.putc &quot;{ // cdqi&quot;
 998             $asm.putc &quot;    int64_t temp = t0.i32(); // sign extend the low 32bit&quot;
 999             $asm.putc &quot;    t0 = (uint32_t)temp; // low word&quot;
1000             $asm.putc &quot;    t1 = (uint32_t)(temp &gt;&gt; 32); // high word&quot;
1001             $asm.putc &quot;}&quot;
1002 
1003         # 64-bit instruction: idivi op1 (based on X64)
1004         # Divide a 64-bit integer numerator by the specified denominator.
1005         # The numerator is specified in t0 and t1 as follows:
1006         #     1. low 32 bits of the numerator is in the low 32 bits of t0.
1007         #     2. high 32 bits of the numerator is in the low 32 bits of t1.
1008         #
1009         # The resultant quotient is a signed 32-bit int, and is to be stored
1010         # in the lower 32 bits of t0.
1011         # The resultant remainder is a signed 32-bit int, and is to be stored
1012         # in the lower 32 bits of t1.
1013         when &quot;idivi&quot;
1014             # Divide t1,t0 (EDX,EAX) by the specified arg, and store the remainder in t1,
1015             # and quotient in t0:
1016             $asm.putc &quot;{ // idivi&quot;
1017             $asm.putc &quot;    int64_t dividend = (int64_t(t1.u32()) &lt;&lt; 32) | t0.u32();&quot;
<span class="line-modified">1018             $asm.putc &quot;    int64_t divisor = #{operands[0].clValue(:int)};&quot;</span>
1019             $asm.putc &quot;    t1 = (uint32_t)(dividend % divisor); // remainder&quot;
1020             $asm.putc &quot;    t0 = (uint32_t)(dividend / divisor); // quotient&quot;
1021             $asm.putc &quot;}&quot;
1022 
1023         # 32-bit instruction: fii2d int32LoOp int32HiOp dblOp (based on ARMv7)
1024         # Decode 2 32-bit ints (low and high) into a 64-bit double.
1025         when &quot;fii2d&quot;
1026             $asm.putc &quot;#{operands[2].clLValue(:double)} = ints2Double(#{operands[0].clValue(:uint32)}, #{operands[1].clValue(:uint32)}); // fii2d&quot;
1027 
1028         # 32-bit instruction: f2dii dblOp int32LoOp int32HiOp (based on ARMv7)
1029         # Encode a 64-bit double into 2 32-bit ints (low and high).
1030         when &quot;fd2ii&quot;
1031             $asm.putc &quot;double2Ints(#{operands[0].clValue(:double)}, #{operands[1].clDump}, #{operands[2].clDump}); // fd2ii&quot;
1032 
1033         # 64-bit instruction: fq2d int64Op dblOp (based on X64)
1034         # Copy a bit-encoded double in a 64-bit int register to a double register.
1035         when &quot;fq2d&quot;
1036             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].clValue(:bitsAsDouble)}; // fq2d&quot;
1037 
1038         # 64-bit instruction: fd2q dblOp int64Op (based on X64 instruction set)
1039         # Copy a double as a bit-encoded double into a 64-bit int register.
1040         when &quot;fd2q&quot;
1041             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:bitsAsInt64)}; // fd2q&quot;
1042 
1043         when &quot;leai&quot;
1044             operands[0].cloopEmitLea(operands[1], :int32)
1045         when &quot;leap&quot;
<span class="line-modified">1046             operands[0].cloopEmitLea(operands[1], :int)</span>
1047 
1048         when &quot;baddio&quot;
1049             cloopEmitOpAndBranchIfOverflow(operands, &quot;+&quot;, :int32)
1050         when &quot;bsubio&quot;
1051             cloopEmitOpAndBranchIfOverflow(operands, &quot;-&quot;, :int32)
1052         when &quot;bmulio&quot;
1053             cloopEmitOpAndBranchIfOverflow(operands, &quot;*&quot;, :int32)
1054 
1055         when &quot;baddis&quot;
1056             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;&lt; 0&quot;)
1057         when &quot;baddiz&quot;
1058             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;== 0&quot;)
1059         when &quot;baddinz&quot;
1060             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;!= 0&quot;)
1061 
1062         when &quot;baddqs&quot;
1063             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;&lt; 0&quot;)
1064         when &quot;baddqz&quot;
1065             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;== 0&quot;)
1066         when &quot;baddqnz&quot;
1067             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;!= 0&quot;)
1068 
1069         when &quot;baddps&quot;
<span class="line-modified">1070             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;&lt; 0&quot;)</span>
1071         when &quot;baddpz&quot;
<span class="line-modified">1072             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;== 0&quot;)</span>
1073         when &quot;baddpnz&quot;
<span class="line-modified">1074             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int, &quot;!= 0&quot;)</span>
1075 
1076         when &quot;bsubis&quot;
1077             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;&lt; 0&quot;)
1078         when &quot;bsubiz&quot;
1079             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;== 0&quot;)
1080         when &quot;bsubinz&quot;
1081             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;!= 0&quot;)
1082 
1083         when &quot;borris&quot;
1084             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;&lt; 0&quot;)
1085         when &quot;borriz&quot;
1086             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;== 0&quot;)
1087         when &quot;borrinz&quot;
1088             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;!= 0&quot;)
1089             
1090         when &quot;memfence&quot;
1091 
1092         when &quot;push&quot;
1093             operands.each {
1094                 | op |
</pre>
<hr />
<pre>
1136         # We can&#39;t do generic function calls with an arbitrary set of args, but
1137         # fortunately we don&#39;t have to here. All slow path function calls always
1138         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1139         when &quot;cloopCallSlowPath&quot;
1140             cloopEmitCallSlowPath(operands)
1141 
1142         when &quot;cloopCallSlowPathVoid&quot;
1143             cloopEmitCallSlowPathVoid(operands)
1144 
1145         # For debugging only. This is used to insert instrumentation into the
1146         # generated LLIntAssembly.h during llint development only. Do not use
1147         # for production code.
1148         when &quot;cloopDo&quot;
1149             $asm.putc &quot;#{annotation}&quot;
1150 
1151         else
1152             lowerDefault
1153         end
1154     end
1155 




1156     def recordMetaDataC_LOOP
1157         $asm.codeOrigin codeOriginString if $enableCodeOriginComments
1158         $asm.annotation annotation if $enableInstrAnnotations &amp;&amp; (opcode != &quot;cloopDo&quot;)
1159         $asm.debugAnnotation codeOrigin.debugDirective if $enableDebugAnnotations
1160     end
1161 end
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 # Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 require &quot;config&quot;
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 
  28 # The CLoop llint backend is initially based on the ARMv7 backend, and
  29 # then further enhanced with a few instructions from the x86 backend to
  30 # support building for X64 targets.  Hence, the shape of the generated
  31 # code and the usage convention of registers will look a lot like the
  32 # ARMv7 backend&#39;s.
  33 
  34 def cloopMapType(type)
  35     case type
<span class="line-modified">  36     when :intptr;         &quot;.i()&quot;</span>
<span class="line-modified">  37     when :uintptr;        &quot;.u()&quot;</span>
  38     when :int32;          &quot;.i32()&quot;
  39     when :uint32;         &quot;.u32()&quot;
  40     when :int64;          &quot;.i64()&quot;
  41     when :uint64;         &quot;.u64()&quot;
  42     when :int8;           &quot;.i8()&quot;
  43     when :uint8;          &quot;.u8()&quot;
  44     when :int8Ptr;        &quot;.i8p()&quot;
  45     when :voidPtr;        &quot;.vp()&quot;
  46     when :nativeFunc;     &quot;.nativeFunc()&quot;
  47     when :double;         &quot;.d()&quot;
  48     when :bitsAsDouble;   &quot;.bitsAsDouble()&quot;
  49     when :bitsAsInt64;    &quot;.bitsAsInt64()&quot;
  50     when :opcode;         &quot;.opcode()&quot;
  51     else;
  52         raise &quot;Unsupported type&quot;
  53     end
  54 end
  55 
  56 
  57 class SpecialRegister &lt; NoChildren
<span class="line-modified">  58     def clLValue(type=:intptr)</span>
  59         clDump
  60     end
  61     def clDump
  62         @name
  63     end
<span class="line-modified">  64     def clValue(type=:intptr)</span>
  65         @name + cloopMapType(type)
  66     end
  67 end
  68 
  69 C_LOOP_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
  70 
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
</pre>
<hr />
<pre>
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
  91             &quot;tagTypeNumber&quot;
  92         when &quot;csr2&quot;
  93             &quot;tagMask&quot;
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
<span class="line-modified"> 106     def clLValue(type=:intptr)</span>
 107         clDump
 108     end
<span class="line-modified"> 109     def clValue(type=:intptr)</span>
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
 114 class FPRegisterID
 115     def clDump
 116         case name
 117         when &quot;ft0&quot;, &quot;fr&quot;
 118             &quot;d0&quot;
 119         when &quot;ft1&quot;
 120             &quot;d1&quot;
 121         when &quot;ft2&quot;
 122             &quot;d2&quot;
 123         when &quot;ft3&quot;
 124             &quot;d3&quot;
 125         when &quot;ft4&quot;
 126             &quot;d4&quot;
 127         when &quot;ft5&quot;
 128             &quot;d5&quot;
 129         else
 130             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 131         end
 132     end
<span class="line-modified"> 133     def clLValue(type=:intptr)</span>
 134         clDump
 135     end
<span class="line-modified"> 136     def clValue(type=:intptr)</span>
 137         clDump + cloopMapType(type)
 138     end
 139 end
 140 
 141 class Immediate
 142     def clDump
 143         &quot;#{value}&quot;
 144     end
<span class="line-modified"> 145     def clLValue(type=:intptr)</span>
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
<span class="line-modified"> 148     def clValue(type=:intptr)</span>
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
 163         when :int32;   &quot;int32_t(#{valueStr})&quot;
 164         when :int64;   &quot;int64_t(#{valueStr})&quot;
<span class="line-modified"> 165         when :intptr;  &quot;intptr_t(#{valueStr})&quot;</span>
 166         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 167         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 168         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
<span class="line-modified"> 169         when :uintptr; &quot;uintptr_t(#{valueStr})&quot;</span>
 170         else
 171             raise &quot;Not implemented immediate of type: #{type}&quot; 
 172         end
 173     end
 174 end
 175 
 176 class Address
 177     def clDump
 178         &quot;[#{base.clDump}, #{offset.value}]&quot;
 179     end
<span class="line-modified"> 180     def clLValue(type=:intptr)</span>
 181         clValue(type)
 182     end
<span class="line-modified"> 183     def clValue(type=:intptr)</span>
 184         case type
 185         when :int8;         int8MemRef
 186         when :int32;        int32MemRef
 187         when :int64;        int64MemRef
<span class="line-modified"> 188         when :intptr;       intptrMemRef</span>
 189         when :uint8;        uint8MemRef
 190         when :uint32;       uint32MemRef
 191         when :uint64;       uint64MemRef
<span class="line-modified"> 192         when :uintptr;      uintptrMemRef</span>
 193         when :opcode;       opcodeMemRef
 194         when :nativeFunc;   nativeFuncMemRef
 195         else
 196             raise &quot;Unexpected Address type: #{type}&quot;
 197         end
 198     end
 199     def pointerExpr
 200         if  offset.value == 0
 201             &quot;#{base.clValue(:int8Ptr)}&quot;
 202         elsif offset.value &gt; 0
 203             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 204         else
 205             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
 206         end
 207     end
 208     def int8MemRef
 209         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 210     end
 211     def int16MemRef
 212         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 213     end
 214     def int32MemRef
 215         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 216     end
 217     def int64MemRef
 218         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 219     end
<span class="line-modified"> 220     def intptrMemRef</span>
 221         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 222     end
 223     def uint8MemRef
 224         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 225     end
 226     def uint16MemRef
 227         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 228     end
 229     def uint32MemRef
 230         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 231     end
 232     def uint64MemRef
 233         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 234     end
<span class="line-modified"> 235     def uintptrMemRef</span>
 236         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 237     end
 238     def nativeFuncMemRef
 239         &quot;*CAST&lt;NativeFunction*&gt;(#{pointerExpr})&quot;
 240     end
 241     def opcodeMemRef
 242         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 243     end
 244     def dblMemRef
 245         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 246     end
 247 end
 248 
 249 class BaseIndex
 250     def clDump
 251         &quot;[#{base.clDump}, #{offset.clDump}, #{index.clDump} &lt;&lt; #{scaleShift}]&quot;
 252     end
<span class="line-modified"> 253     def clLValue(type=:intptr)</span>
 254         clValue(type)
 255     end
<span class="line-modified"> 256     def clValue(type=:intptr)</span>
 257         case type
 258         when :int8;       int8MemRef
 259         when :int32;      int32MemRef
 260         when :int64;      int64MemRef
<span class="line-modified"> 261         when :intptr;     intptrMemRef</span>
 262         when :uint8;      uint8MemRef
 263         when :uint32;     uint32MemRef
 264         when :uint64;     uint64MemRef
<span class="line-modified"> 265         when :uintptr;    uintptrMemRef</span>
 266         when :opcode;     opcodeMemRef
 267         else
 268             raise &quot;Unexpected BaseIndex type: #{type}&quot;
 269         end
 270     end
 271     def pointerExpr
 272         if offset.value == 0
 273             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift})&quot;
 274         else
 275             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift}) + #{offset.clValue}&quot;
 276         end
 277     end
 278     def int8MemRef
 279         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 280     end
 281     def int16MemRef
 282         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 283     end
 284     def int32MemRef
 285         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 286     end
 287     def int64MemRef
 288         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 289     end
<span class="line-modified"> 290     def intptrMemRef</span>
 291         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 292     end
 293     def uint8MemRef
 294         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 295     end
 296     def uint16MemRef
 297         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 298     end
 299     def uint32MemRef
 300         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 301     end
 302     def uint64MemRef
 303         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 304     end
<span class="line-modified"> 305     def uintptrMemRef</span>
 306         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 307     end
 308     def opcodeMemRef
 309         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 310     end
 311     def dblMemRef
 312         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 313     end
 314 end
 315 
 316 class AbsoluteAddress
 317     def clDump
 318         &quot;#{codeOriginString}&quot;
 319     end
<span class="line-modified"> 320     def clLValue(type=:intptr)</span>
 321         clValue(type)
 322     end
 323     def clValue
 324         clDump
 325     end
 326 end
 327 
 328 class LabelReference
<span class="line-modified"> 329     def intptrMemRef</span>
 330         &quot;*CAST&lt;intptr_t*&gt;(&amp;#{cLabel})&quot;
 331     end
 332     def cloopEmitLea(destination, type)
 333         $asm.putc &quot;#{destination.clLValue(:voidPtr)} = CAST&lt;void*&gt;(&amp;#{cLabel});&quot;
 334     end
 335 end
 336 
 337 
 338 #
 339 # Lea support.
 340 #
 341 
 342 class Address
 343     def cloopEmitLea(destination, type)
 344         if destination == base
 345             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} += #{offset.clValue(type)};&quot;
 346         else
 347             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + #{offset.clValue(type)};&quot;
 348         end
 349     end
</pre>
<hr />
<pre>
 368         myList.each {
 369             | node |
 370             unless node.is_a? Instruction or
 371                     node.is_a? Label or
 372                     node.is_a? LocalLabel or
 373                     node.is_a? Skip
 374                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 375             end
 376         }
 377         
 378         return myList
 379     end
 380 end
 381 
 382 def clOperands(operands)
 383     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 384 end
 385 
 386 
 387 def cloopEmitOperation(operands, type, operator)
<span class="line-modified"> 388     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \</span>
 389         type == :int64 || type == :uint64 || type == :double
 390     if operands.size == 3
 391         op1 = operands[0]
 392         op2 = operands[1]
 393         dst = operands[2]
 394     else
 395         raise unless operands.size == 2
 396         op1 = operands[1]
 397         op2 = operands[0]
 398         dst = operands[1]
 399     end
 400     raise unless not dst.is_a? Immediate
 401     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 402         truncationHeader = &quot;(uint32_t)(&quot;
 403         truncationFooter = &quot;)&quot;
 404     else
 405         truncationHeader = &quot;&quot;
 406         truncationFooter = &quot;&quot;
 407     end
 408     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 409 end
 410 
 411 def cloopEmitShiftOperation(operands, type, operator)
<span class="line-modified"> 412     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 413     if operands.size == 3
 414         op1 = operands[0]
 415         op2 = operands[1]
 416         dst = operands[2]
 417     else
 418         op1 = operands[1]
 419         op2 = operands[0]
 420         dst = operands[1]
 421     end
 422     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 423         truncationHeader = &quot;(uint32_t)(&quot;
 424         truncationFooter = &quot;)&quot;
 425     else
 426         truncationHeader = &quot;&quot;
 427         truncationFooter = &quot;&quot;
 428     end
<span class="line-modified"> 429     shiftMask = &quot;((sizeof(uintptr_t) == 8) ? 0x3f : 0x1f)&quot; if type == :intptr || type == :uintptr</span>
<span class="line-added"> 430     shiftMask = &quot;0x3f&quot; if type == :int64 || type == :uint64</span>
<span class="line-added"> 431     shiftMask = &quot;0x1f&quot; if type == :int32 || type == :uint32</span>
<span class="line-added"> 432     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operands[1].clValue(type)} #{operator} (#{operands[0].clValue(:intptr)} &amp; #{shiftMask})#{truncationFooter};&quot;</span>
 433 end
 434 
 435 def cloopEmitUnaryOperation(operands, type, operator)
<span class="line-modified"> 436     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 437     raise unless operands.size == 1
 438     raise unless not operands[0].is_a? Immediate
 439     op = operands[0]
 440     dst = operands[0]
 441     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 442         truncationHeader = &quot;(uint32_t)(&quot;
 443         truncationFooter = &quot;)&quot;
 444     else
 445         truncationHeader = &quot;&quot;
 446         truncationFooter = &quot;&quot;
 447     end
 448     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operator}#{op.clValue(type)}#{truncationFooter};&quot;
 449 end
 450 
 451 def cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, condition)
 452     $asm.putc &quot;if (std::isnan(#{operands[0].clValue(:double)}) || std::isnan(#{operands[1].clValue(:double)})&quot;
 453     $asm.putc &quot;    || (#{operands[0].clValue(:double)} #{condition} #{operands[1].clValue(:double)}))&quot;
 454     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 455 end
 456 
</pre>
<hr />
<pre>
 487 end
 488 
 489 # conditionTest should contain a string that provides a comparator and a RHS
 490 # value e.g. &quot;&lt; 0&quot;.
 491 def cloopEmitTestAndBranchIf(operands, type, conditionTest, branchTarget)
 492     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 493     $asm.putc &quot;if (#{conditionExpr})&quot;
 494     $asm.putc &quot;    goto #{branchTarget};&quot;
 495 end
 496 
 497 def cloopEmitTestSet(operands, type, conditionTest)
 498     # The result is a boolean condition.  Hence, the result type is always an
 499     # int.  The passed in type is only used for the values being tested in
 500     # the condition test.
 501     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 502     $asm.putc &quot;#{operands[-1].clLValue} = (#{conditionExpr});&quot;
 503 end
 504 
 505 def cloopEmitOpAndBranch(operands, operator, type, conditionTest)
 506     case type
<span class="line-modified"> 507     when :intptr; tempType = &quot;intptr_t&quot;</span>
 508     when :int32; tempType = &quot;int32_t&quot;
 509     when :int64; tempType = &quot;int64_t&quot;
 510     else
 511         raise &quot;Unimplemented type&quot;
 512     end
 513 
 514     $asm.putc &quot;{&quot;
 515     $asm.putc &quot;    #{tempType} temp = #{operands[1].clValue(type)} #{operator} #{operands[0].clValue(type)};&quot;
 516     $asm.putc &quot;    #{operands[1].clLValue(type)} = temp;&quot;
 517     $asm.putc &quot;    if (temp #{conditionTest})&quot;
 518     $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 519     $asm.putc &quot;}&quot;
 520 end
 521 
 522 def cloopEmitOpAndBranchIfOverflow(operands, operator, type)
 523     case type
 524     when :int32
 525         tempType = &quot;int32_t&quot;
 526         truncationHeader = &quot;(uint32_t)(&quot;
 527         truncationFooter = &quot;)&quot;
</pre>
<hr />
<pre>
 553     $asm.putc &quot;{&quot;
 554     $asm.putc &quot;    cloopStack.setCurrentStackPointer(sp.vp());&quot;
 555     $asm.putc &quot;    SlowPathReturnType result = #{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 556     $asm.putc &quot;    decodeResult(result, t0, t1);&quot;
 557     $asm.putc &quot;}&quot;
 558 end
 559 
 560 def cloopEmitCallSlowPathVoid(operands)
 561     $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
 562     $asm.putc &quot;#{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 563 end
 564 
 565 class Instruction
 566     def lowerC_LOOP
 567         case opcode
 568         when &quot;addi&quot;
 569             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 570         when &quot;addq&quot;
 571             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 572         when &quot;addp&quot;
<span class="line-modified"> 573             cloopEmitOperation(operands, :intptr, &quot;+&quot;)</span>
 574 
 575         when &quot;andi&quot;
 576             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 577         when &quot;andq&quot;
 578             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 579         when &quot;andp&quot;
<span class="line-modified"> 580             cloopEmitOperation(operands, :intptr, &quot;&amp;&quot;)</span>
 581 
 582         when &quot;ori&quot;
 583             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 584         when &quot;orq&quot;
 585             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 586         when &quot;orp&quot;
<span class="line-modified"> 587             cloopEmitOperation(operands, :intptr, &quot;|&quot;)</span>
 588 
 589         when &quot;xori&quot;
 590             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 591         when &quot;xorq&quot;
 592             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 593         when &quot;xorp&quot;
<span class="line-modified"> 594             cloopEmitOperation(operands, :intptr, &quot;^&quot;)</span>
 595 
 596         when &quot;lshifti&quot;
 597             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 598         when &quot;lshiftq&quot;
 599             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 600         when &quot;lshiftp&quot;
<span class="line-modified"> 601             cloopEmitShiftOperation(operands, :intptr, &quot;&lt;&lt;&quot;)</span>
 602 
 603         when &quot;rshifti&quot;
 604             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 605         when &quot;rshiftq&quot;
 606             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 607         when &quot;rshiftp&quot;
<span class="line-modified"> 608             cloopEmitShiftOperation(operands, :intptr, &quot;&gt;&gt;&quot;)</span>
 609 
 610         when &quot;urshifti&quot;
 611             cloopEmitShiftOperation(operands, :uint32, &quot;&gt;&gt;&quot;)
 612         when &quot;urshiftq&quot;
 613             cloopEmitShiftOperation(operands, :uint64, &quot;&gt;&gt;&quot;)
 614         when &quot;urshiftp&quot;
<span class="line-modified"> 615             cloopEmitShiftOperation(operands, :uintptr, &quot;&gt;&gt;&quot;)</span>
 616 
 617         when &quot;muli&quot;
 618             cloopEmitOperation(operands, :int32, &quot;*&quot;)
 619         when &quot;mulq&quot;
 620             cloopEmitOperation(operands, :int64, &quot;*&quot;)
 621         when &quot;mulp&quot;
<span class="line-modified"> 622             cloopEmitOperation(operands, :intptr, &quot;*&quot;)</span>
 623 
 624         when &quot;subi&quot;
 625             cloopEmitOperation(operands, :int32, &quot;-&quot;)
 626         when &quot;subq&quot;
 627             cloopEmitOperation(operands, :int64, &quot;-&quot;)
 628         when &quot;subp&quot;
<span class="line-modified"> 629             cloopEmitOperation(operands, :intptr, &quot;-&quot;)</span>
 630 
 631         when &quot;negi&quot;
 632             cloopEmitUnaryOperation(operands, :int32, &quot;-&quot;)
 633         when &quot;negq&quot;
 634             cloopEmitUnaryOperation(operands, :int64, &quot;-&quot;)
 635         when &quot;negp&quot;
<span class="line-modified"> 636             cloopEmitUnaryOperation(operands, :intptr, &quot;-&quot;)</span>
 637 
 638         when &quot;noti&quot;
 639             cloopEmitUnaryOperation(operands, :int32, &quot;~&quot;)
 640 
 641         when &quot;loadi&quot;
 642             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = #{operands[0].uint32MemRef};&quot;
 643             # There&#39;s no need to call clearHighWord() here because the above will
 644             # automatically take care of 0 extension.
 645         when &quot;loadis&quot;
 646             $asm.putc &quot;#{operands[1].clLValue(:int32)} = #{operands[0].int32MemRef};&quot;
 647         when &quot;loadq&quot;
 648             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].int64MemRef};&quot;
 649         when &quot;loadp&quot;
<span class="line-modified"> 650             $asm.putc &quot;#{operands[1].clLValue} = #{operands[0].intptrMemRef};&quot;</span>
 651         when &quot;storei&quot;
 652             $asm.putc &quot;#{operands[1].int32MemRef} = #{operands[0].clValue(:int32)};&quot;
 653         when &quot;storeq&quot;
 654             $asm.putc &quot;#{operands[1].int64MemRef} = #{operands[0].clValue(:int64)};&quot;
 655         when &quot;storep&quot;
<span class="line-modified"> 656             $asm.putc &quot;#{operands[1].intptrMemRef} = #{operands[0].clValue(:intptr)};&quot;</span>
 657         when &quot;loadb&quot;
<span class="line-modified"> 658             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint8MemRef};&quot;</span>
<span class="line-modified"> 659         when &quot;loadbsi&quot;</span>
<span class="line-modified"> 660             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int8MemRef});&quot;</span>
<span class="line-modified"> 661         when &quot;loadbsq&quot;</span>
<span class="line-modified"> 662             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int8MemRef};&quot;</span>
 663         when &quot;storeb&quot;
 664             $asm.putc &quot;#{operands[1].uint8MemRef} = #{operands[0].clValue(:int8)};&quot;
 665         when &quot;loadh&quot;
<span class="line-modified"> 666             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint16MemRef};&quot;</span>
<span class="line-modified"> 667         when &quot;loadhsi&quot;</span>
<span class="line-modified"> 668             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int16MemRef});&quot;</span>
<span class="line-added"> 669         when &quot;loadhsq&quot;</span>
<span class="line-added"> 670             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int16MemRef};&quot;</span>
 671         when &quot;storeh&quot;
 672             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 673         when &quot;loadd&quot;
 674             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 675         when &quot;stored&quot;
 676             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 677 
 678         when &quot;addd&quot;
 679             cloopEmitOperation(operands, :double, &quot;+&quot;)
 680         when &quot;divd&quot;
 681             cloopEmitOperation(operands, :double, &quot;/&quot;)
 682         when &quot;subd&quot;
 683             cloopEmitOperation(operands, :double, &quot;-&quot;)
 684         when &quot;muld&quot;
 685             cloopEmitOperation(operands, :double, &quot;*&quot;)
 686 
 687         # Convert an int value to its double equivalent, and store it in a double register.
 688         when &quot;ci2d&quot;
 689             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;
 690 
</pre>
<hr />
<pre>
 698             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 699         when &quot;bdlt&quot;
 700             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 701         when &quot;bdlteq&quot;
 702             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 703 
 704         when &quot;bdequn&quot;
 705             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 706         when &quot;bdnequn&quot;
 707             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 708         when &quot;bdgtun&quot;
 709             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
 710         when &quot;bdgtequn&quot;
 711             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;=&quot;)
 712         when &quot;bdltun&quot;
 713             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;&quot;)
 714         when &quot;bdltequn&quot;
 715             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;=&quot;)
 716 
 717         when &quot;td2i&quot;
<span class="line-modified"> 718             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = (uint32_t)(intptr_t)#{operands[0].clValue(:double)}; // td2i&quot;</span>
 719 
 720         when &quot;bcd2i&quot;  # operands: srcDbl dstInt slowPath
 721             $asm.putc &quot;{ // bcd2i&quot;
 722             $asm.putc &quot;    double d = #{operands[0].clValue(:double)};&quot;
 723             $asm.putc &quot;    const int32_t asInt32 = int32_t(d);&quot;
 724             $asm.putc &quot;    if (asInt32 != d || (!asInt32 &amp;&amp; std::signbit(d))) // true for -0.0&quot;
 725             $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 726             $asm.putc &quot;    #{operands[1].clLValue} = (uint32_t)asInt32;&quot;
 727             $asm.putc &quot;}&quot;
 728 
 729         when &quot;move&quot;
<span class="line-modified"> 730             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].clValue(:intptr)};&quot;</span>
 731         when &quot;sxi2q&quot;
 732             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:int32)};&quot;
 733         when &quot;zxi2q&quot;
 734             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = #{operands[0].clValue(:uint32)};&quot;
 735         when &quot;nop&quot;
 736             $asm.putc &quot;// nop&quot;
 737         when &quot;bbeq&quot;
 738             cloopEmitCompareAndBranch(operands, :int8, &quot;==&quot;)
 739         when &quot;bieq&quot;
 740             cloopEmitCompareAndBranch(operands, :int32, &quot;==&quot;)
 741         when &quot;bqeq&quot;
 742             cloopEmitCompareAndBranch(operands, :int64, &quot;==&quot;)
 743         when &quot;bpeq&quot;
<span class="line-modified"> 744             cloopEmitCompareAndBranch(operands, :intptr, &quot;==&quot;)</span>
 745 
 746         when &quot;bbneq&quot;
 747             cloopEmitCompareAndBranch(operands, :int8, &quot;!=&quot;)
 748         when &quot;bineq&quot;
 749             cloopEmitCompareAndBranch(operands, :int32, &quot;!=&quot;)
 750         when &quot;bqneq&quot;
 751             cloopEmitCompareAndBranch(operands, :int64, &quot;!=&quot;)
 752         when &quot;bpneq&quot;
<span class="line-modified"> 753             cloopEmitCompareAndBranch(operands, :intptr, &quot;!=&quot;)</span>
 754 
 755         when &quot;bba&quot;
 756             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;&quot;)
 757         when &quot;bia&quot;
 758             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;&quot;)
 759         when &quot;bqa&quot;
 760             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;&quot;)
 761         when &quot;bpa&quot;
<span class="line-modified"> 762             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;&quot;)</span>
 763 
 764         when &quot;bbaeq&quot;
 765             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;=&quot;)
 766         when &quot;biaeq&quot;
 767             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;=&quot;)
 768         when &quot;bqaeq&quot;
 769             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;=&quot;)
 770         when &quot;bpaeq&quot;
<span class="line-modified"> 771             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;=&quot;)</span>
 772 
 773         when &quot;bbb&quot;
 774             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;&quot;)
 775         when &quot;bib&quot;
 776             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;&quot;)
 777         when &quot;bqb&quot;
 778             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;&quot;)
 779         when &quot;bpb&quot;
<span class="line-modified"> 780             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;&quot;)</span>
 781 
 782         when &quot;bbbeq&quot;
 783             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;=&quot;)
 784         when &quot;bibeq&quot;
 785             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;=&quot;)
 786         when &quot;bqbeq&quot;
 787             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;=&quot;)
 788         when &quot;bpbeq&quot;
<span class="line-modified"> 789             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;=&quot;)</span>
 790 
 791         when &quot;bbgt&quot;
 792             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;&quot;)
 793         when &quot;bigt&quot;
 794             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;&quot;)
 795         when &quot;bqgt&quot;
 796             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;&quot;)
 797         when &quot;bpgt&quot;
<span class="line-modified"> 798             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;&quot;)</span>
 799 
 800         when &quot;bbgteq&quot;
 801             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;=&quot;)
 802         when &quot;bigteq&quot;
 803             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;=&quot;)
 804         when &quot;bqgteq&quot;
 805             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;=&quot;)
 806         when &quot;bpgteq&quot;
<span class="line-modified"> 807             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;=&quot;)</span>
 808 
 809         when &quot;bblt&quot;
 810             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;&quot;)
 811         when &quot;bilt&quot;
 812             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;&quot;)
 813         when &quot;bqlt&quot;
 814             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;&quot;)
 815         when &quot;bplt&quot;
<span class="line-modified"> 816             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;&quot;)</span>
 817 
 818         when &quot;bblteq&quot;
 819             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;=&quot;)
 820         when &quot;bilteq&quot;
 821             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;=&quot;)
 822         when &quot;bqlteq&quot;
 823             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;=&quot;)
 824         when &quot;bplteq&quot;
<span class="line-modified"> 825             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;=&quot;)</span>
 826 
 827         when &quot;btbz&quot;
 828             cloopEmitTestAndBranchIf(operands, :int8, &quot;== 0&quot;, operands[-1].cLabel)
 829         when &quot;btiz&quot;
 830             cloopEmitTestAndBranchIf(operands, :int32, &quot;== 0&quot;, operands[-1].cLabel)
 831         when &quot;btqz&quot;
 832             cloopEmitTestAndBranchIf(operands, :int64, &quot;== 0&quot;, operands[-1].cLabel)
 833         when &quot;btpz&quot;
<span class="line-modified"> 834             cloopEmitTestAndBranchIf(operands, :intptr, &quot;== 0&quot;, operands[-1].cLabel)</span>
 835 
 836         when &quot;btbnz&quot;
 837             cloopEmitTestAndBranchIf(operands, :int8, &quot;!= 0&quot;, operands[-1].cLabel)
 838         when &quot;btinz&quot;
 839             cloopEmitTestAndBranchIf(operands, :int32, &quot;!= 0&quot;, operands[-1].cLabel)
 840         when &quot;btqnz&quot;
 841             cloopEmitTestAndBranchIf(operands, :int64, &quot;!= 0&quot;, operands[-1].cLabel)
 842         when &quot;btpnz&quot;
<span class="line-modified"> 843             cloopEmitTestAndBranchIf(operands, :intptr, &quot;!= 0&quot;, operands[-1].cLabel)</span>
 844 
 845         when &quot;btbs&quot;
 846             cloopEmitTestAndBranchIf(operands, :int8, &quot;&lt; 0&quot;, operands[-1].cLabel)
 847         when &quot;btis&quot;
 848             cloopEmitTestAndBranchIf(operands, :int32, &quot;&lt; 0&quot;, operands[-1].cLabel)
 849         when &quot;btqs&quot;
 850             cloopEmitTestAndBranchIf(operands, :int64, &quot;&lt; 0&quot;, operands[-1].cLabel)
 851         when &quot;btps&quot;
<span class="line-modified"> 852             cloopEmitTestAndBranchIf(operands, :intptr, &quot;&lt; 0&quot;, operands[-1].cLabel)</span>
 853 
 854         # For jmp, we do not want to assume that we have COMPUTED_GOTO support.
 855         # Fortunately, the only times we should ever encounter indirect jmps is
 856         # when the jmp target is a CLoop opcode (by design).
 857         #
 858         # Hence, we check if the jmp target is a known label reference. If so,
 859         # we can emit a goto directly. If it is not a known target, then we set
 860         # the target in the opcode, and dispatch to it via whatever dispatch
 861         # mechanism is in used.
 862         when &quot;jmp&quot;
 863             if operands[0].is_a? LocalLabelReference or operands[0].is_a? LabelReference
 864                 # Handles jumps local or global labels.
 865                 $asm.putc &quot;goto #{operands[0].cLabel};&quot;
 866             else
 867                 # Handles jumps to some computed target.
 868                 # NOTE: must be an opcode handler or a llint glue helper.
 869                 $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
 870                 $asm.putc &quot;DISPATCH_OPCODE();&quot;
 871             end
 872 
 873         when &quot;call&quot;
 874             $asm.putc &quot;CRASH(); // generic call instruction not supported by design!&quot;
 875         when &quot;break&quot;
 876             $asm.putc &quot;CRASH(); // break instruction not implemented.&quot;
 877         when &quot;ret&quot;
 878             $asm.putc &quot;opcode = lr.opcode();&quot;
 879             $asm.putc &quot;DISPATCH_OPCODE();&quot;
 880 
 881         when &quot;cbeq&quot;
 882             cloopEmitCompareAndSet(operands, :uint8, &quot;==&quot;)
 883         when &quot;cieq&quot;
 884             cloopEmitCompareAndSet(operands, :uint32, &quot;==&quot;)
 885         when &quot;cqeq&quot;
 886             cloopEmitCompareAndSet(operands, :uint64, &quot;==&quot;)
 887         when &quot;cpeq&quot;
<span class="line-modified"> 888             cloopEmitCompareAndSet(operands, :uintptr, &quot;==&quot;)</span>
 889 
 890         when &quot;cbneq&quot;
 891             cloopEmitCompareAndSet(operands, :uint8, &quot;!=&quot;)
 892         when &quot;cineq&quot;
 893             cloopEmitCompareAndSet(operands, :uint32, &quot;!=&quot;)
 894         when &quot;cqneq&quot;
 895             cloopEmitCompareAndSet(operands, :uint64, &quot;!=&quot;)
 896         when &quot;cpneq&quot;
<span class="line-modified"> 897             cloopEmitCompareAndSet(operands, :uintptr, &quot;!=&quot;)</span>
 898 
 899         when &quot;cba&quot;
 900             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;&quot;)
 901         when &quot;cia&quot;
 902             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;&quot;)
 903         when &quot;cqa&quot;
 904             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;&quot;)
 905         when &quot;cpa&quot;
<span class="line-modified"> 906             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;&quot;)</span>
 907 
 908         when &quot;cbaeq&quot;
 909             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;=&quot;)
 910         when &quot;ciaeq&quot;
 911             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;=&quot;)
 912         when &quot;cqaeq&quot;
 913             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;=&quot;)
 914         when &quot;cpaeq&quot;
<span class="line-modified"> 915             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;=&quot;)</span>
 916 
 917         when &quot;cbb&quot;
 918             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;&quot;)
 919         when &quot;cib&quot;
 920             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;&quot;)
 921         when &quot;cqb&quot;
 922             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;&quot;)
 923         when &quot;cpb&quot;
<span class="line-modified"> 924             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;&quot;)</span>
 925 
 926         when &quot;cbbeq&quot;
 927             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;=&quot;)
 928         when &quot;cibeq&quot;
 929             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;=&quot;)
 930         when &quot;cqbeq&quot;
 931             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;=&quot;)
 932         when &quot;cpbeq&quot;
<span class="line-modified"> 933             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;=&quot;)</span>
 934 
 935         when &quot;cbgt&quot;
 936             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;&quot;)
 937         when &quot;cigt&quot;
 938             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;&quot;)
 939         when &quot;cqgt&quot;
 940             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;&quot;)
 941         when &quot;cpgt&quot;
<span class="line-modified"> 942             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;&quot;)</span>
 943 
 944         when &quot;cbgteq&quot;
 945             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;=&quot;)
 946         when &quot;cigteq&quot;
 947             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;=&quot;)
 948         when &quot;cqgteq&quot;
 949             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;=&quot;)
 950         when &quot;cpgteq&quot;
<span class="line-modified"> 951             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;=&quot;)</span>
 952 
 953         when &quot;cblt&quot;
 954             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;&quot;)
 955         when &quot;cilt&quot;
 956             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;&quot;)
 957         when &quot;cqlt&quot;
 958             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;&quot;)
 959         when &quot;cplt&quot;
<span class="line-modified"> 960             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;&quot;)</span>
 961 
 962         when &quot;cblteq&quot;
 963             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;=&quot;)
 964         when &quot;cilteq&quot;
 965             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;=&quot;)
 966         when &quot;cqlteq&quot;
 967             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;=&quot;)
 968         when &quot;cplteq&quot;
<span class="line-modified"> 969             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;=&quot;)</span>
 970 
 971         when &quot;tbs&quot;
 972             cloopEmitTestSet(operands, :int8, &quot;&lt; 0&quot;)
 973         when &quot;tis&quot;
 974             cloopEmitTestSet(operands, :int32, &quot;&lt; 0&quot;)
 975         when &quot;tqs&quot;
 976             cloopEmitTestSet(operands, :int64, &quot;&lt; 0&quot;)
 977         when &quot;tps&quot;
<span class="line-modified"> 978             cloopEmitTestSet(operands, :intptr, &quot;&lt; 0&quot;)</span>
 979 
 980         when &quot;tbz&quot;
 981             cloopEmitTestSet(operands, :int8, &quot;== 0&quot;)
 982         when &quot;tiz&quot;
 983             cloopEmitTestSet(operands, :int32, &quot;== 0&quot;)
 984         when &quot;tqz&quot;
 985             cloopEmitTestSet(operands, :int64, &quot;== 0&quot;)
 986         when &quot;tpz&quot;
<span class="line-modified"> 987             cloopEmitTestSet(operands, :intptr, &quot;== 0&quot;)</span>
 988 
 989         when &quot;tbnz&quot;
 990             cloopEmitTestSet(operands, :int8, &quot;!= 0&quot;)
 991         when &quot;tinz&quot;
 992             cloopEmitTestSet(operands, :int32, &quot;!= 0&quot;)
 993         when &quot;tqnz&quot;
 994             cloopEmitTestSet(operands, :int64, &quot;!= 0&quot;)
 995         when &quot;tpnz&quot;
<span class="line-modified"> 996             cloopEmitTestSet(operands, :intptr, &quot;!= 0&quot;)</span>
 997 
 998         # 64-bit instruction: cdqi (based on X64)
 999         # Sign extends the lower 32 bits of t0, but put the sign extension into
1000         # the lower 32 bits of t1. Leave the upper 32 bits of t0 and t1 unchanged.
1001         when &quot;cdqi&quot;
1002             $asm.putc &quot;{ // cdqi&quot;
1003             $asm.putc &quot;    int64_t temp = t0.i32(); // sign extend the low 32bit&quot;
1004             $asm.putc &quot;    t0 = (uint32_t)temp; // low word&quot;
1005             $asm.putc &quot;    t1 = (uint32_t)(temp &gt;&gt; 32); // high word&quot;
1006             $asm.putc &quot;}&quot;
1007 
1008         # 64-bit instruction: idivi op1 (based on X64)
1009         # Divide a 64-bit integer numerator by the specified denominator.
1010         # The numerator is specified in t0 and t1 as follows:
1011         #     1. low 32 bits of the numerator is in the low 32 bits of t0.
1012         #     2. high 32 bits of the numerator is in the low 32 bits of t1.
1013         #
1014         # The resultant quotient is a signed 32-bit int, and is to be stored
1015         # in the lower 32 bits of t0.
1016         # The resultant remainder is a signed 32-bit int, and is to be stored
1017         # in the lower 32 bits of t1.
1018         when &quot;idivi&quot;
1019             # Divide t1,t0 (EDX,EAX) by the specified arg, and store the remainder in t1,
1020             # and quotient in t0:
1021             $asm.putc &quot;{ // idivi&quot;
1022             $asm.putc &quot;    int64_t dividend = (int64_t(t1.u32()) &lt;&lt; 32) | t0.u32();&quot;
<span class="line-modified">1023             $asm.putc &quot;    int64_t divisor = #{operands[0].clValue(:intptr)};&quot;</span>
1024             $asm.putc &quot;    t1 = (uint32_t)(dividend % divisor); // remainder&quot;
1025             $asm.putc &quot;    t0 = (uint32_t)(dividend / divisor); // quotient&quot;
1026             $asm.putc &quot;}&quot;
1027 
1028         # 32-bit instruction: fii2d int32LoOp int32HiOp dblOp (based on ARMv7)
1029         # Decode 2 32-bit ints (low and high) into a 64-bit double.
1030         when &quot;fii2d&quot;
1031             $asm.putc &quot;#{operands[2].clLValue(:double)} = ints2Double(#{operands[0].clValue(:uint32)}, #{operands[1].clValue(:uint32)}); // fii2d&quot;
1032 
1033         # 32-bit instruction: f2dii dblOp int32LoOp int32HiOp (based on ARMv7)
1034         # Encode a 64-bit double into 2 32-bit ints (low and high).
1035         when &quot;fd2ii&quot;
1036             $asm.putc &quot;double2Ints(#{operands[0].clValue(:double)}, #{operands[1].clDump}, #{operands[2].clDump}); // fd2ii&quot;
1037 
1038         # 64-bit instruction: fq2d int64Op dblOp (based on X64)
1039         # Copy a bit-encoded double in a 64-bit int register to a double register.
1040         when &quot;fq2d&quot;
1041             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].clValue(:bitsAsDouble)}; // fq2d&quot;
1042 
1043         # 64-bit instruction: fd2q dblOp int64Op (based on X64 instruction set)
1044         # Copy a double as a bit-encoded double into a 64-bit int register.
1045         when &quot;fd2q&quot;
1046             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:bitsAsInt64)}; // fd2q&quot;
1047 
1048         when &quot;leai&quot;
1049             operands[0].cloopEmitLea(operands[1], :int32)
1050         when &quot;leap&quot;
<span class="line-modified">1051             operands[0].cloopEmitLea(operands[1], :intptr)</span>
1052 
1053         when &quot;baddio&quot;
1054             cloopEmitOpAndBranchIfOverflow(operands, &quot;+&quot;, :int32)
1055         when &quot;bsubio&quot;
1056             cloopEmitOpAndBranchIfOverflow(operands, &quot;-&quot;, :int32)
1057         when &quot;bmulio&quot;
1058             cloopEmitOpAndBranchIfOverflow(operands, &quot;*&quot;, :int32)
1059 
1060         when &quot;baddis&quot;
1061             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;&lt; 0&quot;)
1062         when &quot;baddiz&quot;
1063             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;== 0&quot;)
1064         when &quot;baddinz&quot;
1065             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;!= 0&quot;)
1066 
1067         when &quot;baddqs&quot;
1068             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;&lt; 0&quot;)
1069         when &quot;baddqz&quot;
1070             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;== 0&quot;)
1071         when &quot;baddqnz&quot;
1072             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;!= 0&quot;)
1073 
1074         when &quot;baddps&quot;
<span class="line-modified">1075             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;&lt; 0&quot;)</span>
1076         when &quot;baddpz&quot;
<span class="line-modified">1077             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;== 0&quot;)</span>
1078         when &quot;baddpnz&quot;
<span class="line-modified">1079             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;!= 0&quot;)</span>
1080 
1081         when &quot;bsubis&quot;
1082             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;&lt; 0&quot;)
1083         when &quot;bsubiz&quot;
1084             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;== 0&quot;)
1085         when &quot;bsubinz&quot;
1086             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;!= 0&quot;)
1087 
1088         when &quot;borris&quot;
1089             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;&lt; 0&quot;)
1090         when &quot;borriz&quot;
1091             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;== 0&quot;)
1092         when &quot;borrinz&quot;
1093             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;!= 0&quot;)
1094             
1095         when &quot;memfence&quot;
1096 
1097         when &quot;push&quot;
1098             operands.each {
1099                 | op |
</pre>
<hr />
<pre>
1141         # We can&#39;t do generic function calls with an arbitrary set of args, but
1142         # fortunately we don&#39;t have to here. All slow path function calls always
1143         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1144         when &quot;cloopCallSlowPath&quot;
1145             cloopEmitCallSlowPath(operands)
1146 
1147         when &quot;cloopCallSlowPathVoid&quot;
1148             cloopEmitCallSlowPathVoid(operands)
1149 
1150         # For debugging only. This is used to insert instrumentation into the
1151         # generated LLIntAssembly.h during llint development only. Do not use
1152         # for production code.
1153         when &quot;cloopDo&quot;
1154             $asm.putc &quot;#{annotation}&quot;
1155 
1156         else
1157             lowerDefault
1158         end
1159     end
1160 
<span class="line-added">1161     def lowerC_LOOP_WIN</span>
<span class="line-added">1162         lowerC_LOOP</span>
<span class="line-added">1163     end</span>
<span class="line-added">1164 </span>
1165     def recordMetaDataC_LOOP
1166         $asm.codeOrigin codeOriginString if $enableCodeOriginComments
1167         $asm.annotation annotation if $enableInstrAnnotations &amp;&amp; (opcode != &quot;cloopDo&quot;)
1168         $asm.debugAnnotation codeOrigin.debugDirective if $enableDebugAnnotations
1169     end
1170 end
</pre>
</td>
</tr>
</table>
<center><a href="backends.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>