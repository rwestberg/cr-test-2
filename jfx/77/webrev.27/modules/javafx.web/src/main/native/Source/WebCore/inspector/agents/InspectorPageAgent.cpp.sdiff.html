<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorPageAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorNetworkAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorPageAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorPageAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorPageAgent.h&quot;
 34 
 35 #include &quot;CachedResource.h&quot;
 36 #include &quot;CachedResourceLoader.h&quot;
 37 #include &quot;Cookie.h&quot;
 38 #include &quot;CookieJar.h&quot;

 39 #include &quot;Document.h&quot;
 40 #include &quot;DocumentLoader.h&quot;
 41 #include &quot;Frame.h&quot;
 42 #include &quot;FrameLoadRequest.h&quot;
 43 #include &quot;FrameLoader.h&quot;
 44 #include &quot;FrameSnapshotting.h&quot;
 45 #include &quot;FrameView.h&quot;
 46 #include &quot;HTMLFrameOwnerElement.h&quot;
 47 #include &quot;HTMLNames.h&quot;
 48 #include &quot;ImageBuffer.h&quot;
 49 #include &quot;InspectorClient.h&quot;
 50 #include &quot;InspectorDOMAgent.h&quot;
 51 #include &quot;InspectorNetworkAgent.h&quot;
 52 #include &quot;InspectorOverlay.h&quot;
 53 #include &quot;InstrumentingAgents.h&quot;
 54 #include &quot;MIMETypeRegistry.h&quot;
 55 #include &quot;MemoryCache.h&quot;
 56 #include &quot;Page.h&quot;
 57 #include &quot;RenderObject.h&quot;
 58 #include &quot;RenderTheme.h&quot;
</pre>
<hr />
<pre>
 75 #endif
 76 
 77 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
 78 #include &quot;LegacyWebArchive.h&quot;
 79 #endif
 80 
 81 
 82 namespace WebCore {
 83 
 84 using namespace Inspector;
 85 
 86 // Keep this in sync with Page.Setting
 87 #define FOR_EACH_INSPECTOR_OVERRIDE_SETTING(macro) \
 88     macro(AuthorAndUserStylesEnabled) \
 89     macro(ICECandidateFilteringEnabled) \
 90     macro(ImagesEnabled) \
 91     macro(MediaCaptureRequiresSecureConnection) \
 92     macro(MockCaptureDevicesEnabled) \
 93     macro(NeedsSiteSpecificQuirks) \
 94     macro(ScriptEnabled) \

 95     macro(WebSecurityEnabled)
 96 
 97 static bool decodeBuffer(const char* buffer, unsigned size, const String&amp; textEncodingName, String* result)
 98 {
 99     if (buffer) {
100         TextEncoding encoding(textEncodingName);
101         if (!encoding.isValid())
102             encoding = WindowsLatin1Encoding();
103         *result = encoding.decode(buffer, size);
104         return true;
105     }
106     return false;
107 }
108 
109 bool InspectorPageAgent::mainResourceContent(Frame* frame, bool withBase64Encode, String* result)
110 {
111     RefPtr&lt;SharedBuffer&gt; buffer = frame-&gt;loader().documentLoader()-&gt;mainResourceData();
112     if (!buffer)
113         return false;
114     return InspectorPageAgent::dataContent(buffer-&gt;data(), buffer-&gt;size(), frame-&gt;document()-&gt;encoding(), withBase64Encode, result);
115 }
116 
117 bool InspectorPageAgent::sharedBufferContent(RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, const String&amp; textEncodingName, bool withBase64Encode, String* result)
118 {
119     return dataContent(buffer ? buffer-&gt;data() : nullptr, buffer ? buffer-&gt;size() : 0, textEncodingName, withBase64Encode, result);
120 }
121 
122 bool InspectorPageAgent::dataContent(const char* data, unsigned size, const String&amp; textEncodingName, bool withBase64Encode, String* result)
123 {
124     if (withBase64Encode) {
125         *result = base64Encode(data, size);
126         return true;
127     }
128 
129     return decodeBuffer(data, size, textEncodingName, result);
130 }
131 































132 void InspectorPageAgent::resourceContent(ErrorString&amp; errorString, Frame* frame, const URL&amp; url, String* result, bool* base64Encoded)
133 {
134     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
135     if (!loader)
136         return;
137 
138     RefPtr&lt;SharedBuffer&gt; buffer;
139     bool success = false;
140     if (equalIgnoringFragmentIdentifier(url, loader-&gt;url())) {
141         *base64Encoded = false;
142         success = mainResourceContent(frame, *base64Encoded, result);
143     }
144 
145     if (!success) {
146         if (auto* resource = cachedResource(frame, url))
147             success = InspectorNetworkAgent::cachedResourceContent(*resource, result, base64Encoded);
148     }
149 
150     if (!success)
<span class="line-modified">151         errorString = &quot;No resource with given URL found&quot;_s;</span>
152 }
153 
154 String InspectorPageAgent::sourceMapURLForResource(CachedResource* cachedResource)
155 {
156     if (!cachedResource)
157         return String();
158 
159     // Scripts are handled in a separate path.
160     if (cachedResource-&gt;type() != CachedResource::Type::CSSStyleSheet)
161         return String();
162 
163     String sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::SourceMap);
164     if (!sourceMapHeader.isEmpty())
165         return sourceMapHeader;
166 
167     sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::XSourceMap);
168     if (!sourceMapHeader.isEmpty())
169         return sourceMapHeader;
170 
171     String content;
</pre>
<hr />
<pre>
183 
184     CachedResource* cachedResource = frame-&gt;document()-&gt;cachedResourceLoader().cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(url));
185     if (!cachedResource) {
186         ResourceRequest request(url);
187         request.setDomainForCachePartition(frame-&gt;document()-&gt;domainForCachePartition());
188         cachedResource = MemoryCache::singleton().resourceForRequest(request, frame-&gt;page()-&gt;sessionID());
189     }
190 
191     return cachedResource;
192 }
193 
194 Inspector::Protocol::Page::ResourceType InspectorPageAgent::resourceTypeJSON(InspectorPageAgent::ResourceType resourceType)
195 {
196     switch (resourceType) {
197     case DocumentResource:
198         return Inspector::Protocol::Page::ResourceType::Document;
199     case ImageResource:
200         return Inspector::Protocol::Page::ResourceType::Image;
201     case FontResource:
202         return Inspector::Protocol::Page::ResourceType::Font;
<span class="line-modified">203     case StylesheetResource:</span>
<span class="line-modified">204         return Inspector::Protocol::Page::ResourceType::Stylesheet;</span>
205     case ScriptResource:
206         return Inspector::Protocol::Page::ResourceType::Script;
207     case XHRResource:
208         return Inspector::Protocol::Page::ResourceType::XHR;
209     case FetchResource:
210         return Inspector::Protocol::Page::ResourceType::Fetch;
211     case PingResource:
212         return Inspector::Protocol::Page::ResourceType::Ping;
213     case BeaconResource:
214         return Inspector::Protocol::Page::ResourceType::Beacon;
215     case WebSocketResource:
216         return Inspector::Protocol::Page::ResourceType::WebSocket;
217     case OtherResource:
218         return Inspector::Protocol::Page::ResourceType::Other;
219 #if ENABLE(APPLICATION_MANIFEST)
220     case ApplicationManifestResource:
221         break;
222 #endif
223     }
224     return Inspector::Protocol::Page::ResourceType::Other;
225 }
226 
227 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(CachedResource::Type type)
228 {
229     switch (type) {
230     case CachedResource::Type::ImageResource:
231         return InspectorPageAgent::ImageResource;
232 #if ENABLE(SVG_FONTS)
233     case CachedResource::Type::SVGFontResource:
234 #endif
235     case CachedResource::Type::FontResource:
236         return InspectorPageAgent::FontResource;
237 #if ENABLE(XSLT)
238     case CachedResource::Type::XSLStyleSheet:
239 #endif
240     case CachedResource::Type::CSSStyleSheet:
<span class="line-modified">241         return InspectorPageAgent::StylesheetResource;</span>
242     case CachedResource::Type::Script:
243         return InspectorPageAgent::ScriptResource;
244     case CachedResource::Type::MainResource:
245         return InspectorPageAgent::DocumentResource;
246     case CachedResource::Type::Beacon:
247         return InspectorPageAgent::BeaconResource;
248 #if ENABLE(APPLICATION_MANIFEST)
249     case CachedResource::Type::ApplicationManifest:
250         return InspectorPageAgent::ApplicationManifestResource;
251 #endif


252     case CachedResource::Type::MediaResource:
253     case CachedResource::Type::Icon:
254     case CachedResource::Type::RawResource:
255     default:
256         return InspectorPageAgent::OtherResource;
257     }
258 }
259 
260 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(const CachedResource&amp; cachedResource)
261 {
262     if (cachedResource.type() == CachedResource::Type::RawResource) {
263         switch (cachedResource.resourceRequest().requester()) {
264         case ResourceRequest::Requester::Fetch:
265             return InspectorPageAgent::FetchResource;
266         case ResourceRequest::Requester::Main:
267             return InspectorPageAgent::DocumentResource;
268         default:
269             return InspectorPageAgent::XHRResource;
270         }
271     }
272 
273     return inspectorResourceType(cachedResource.type());
274 }
275 
276 Inspector::Protocol::Page::ResourceType InspectorPageAgent::cachedResourceTypeJSON(const CachedResource&amp; cachedResource)
277 {
278     return resourceTypeJSON(inspectorResourceType(cachedResource));
279 }
280 


















281 InspectorPageAgent::InspectorPageAgent(PageAgentContext&amp; context, InspectorClient* client, InspectorOverlay* overlay)
282     : InspectorAgentBase(&quot;Page&quot;_s, context)
<span class="line-modified">283     , m_frontendDispatcher(std::make_unique&lt;Inspector::PageFrontendDispatcher&gt;(context.frontendRouter))</span>
284     , m_backendDispatcher(Inspector::PageBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified">285     , m_page(context.inspectedPage)</span>
286     , m_client(client)
287     , m_overlay(overlay)
288 {
289 }
290 


291 void InspectorPageAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
292 {
293 }
294 
295 void InspectorPageAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
296 {
297     ErrorString unused;
298     disable(unused);
299 }
300 
<span class="line-modified">301 double InspectorPageAgent::timestamp()</span>
302 {
<span class="line-modified">303     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();</span>
<span class="line-modified">304 }</span>


305 
<span class="line-removed">306 void InspectorPageAgent::enable(ErrorString&amp;)</span>
<span class="line-removed">307 {</span>
<span class="line-removed">308     m_enabled = true;</span>
309     m_instrumentingAgents.setInspectorPageAgent(this);
310 
311     auto stopwatch = m_environment.executionStopwatch();
312     stopwatch-&gt;reset();
313     stopwatch-&gt;start();
314 
315 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">316     defaultAppearanceDidChange(m_page.defaultUseDarkAppearance());</span>
317 #endif
318 }
319 
320 void InspectorPageAgent::disable(ErrorString&amp;)
321 {
<span class="line-removed">322     m_enabled = false;</span>
323     m_instrumentingAgents.setInspectorPageAgent(nullptr);
324 
325     ErrorString unused;
326     setShowPaintRects(unused, false);

327     overrideUserAgent(unused, nullptr);
328     setEmulatedMedia(unused, emptyString());
329     setForcedAppearance(unused, emptyString());
330 
331 #define DISABLE_INSPECTOR_OVERRIDE_SETTING(name) \
<span class="line-modified">332     m_page.settings().set##name##InspectorOverride(WTF::nullopt);</span>
333 
334     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(DISABLE_INSPECTOR_OVERRIDE_SETTING)
335 
336 #undef DISABLE_INSPECTOR_OVERRIDE_SETTING







337 }
338 
339 void InspectorPageAgent::reload(ErrorString&amp;, const bool* optionalReloadFromOrigin, const bool* optionalRevalidateAllResources)
340 {
341     bool reloadFromOrigin = optionalReloadFromOrigin &amp;&amp; *optionalReloadFromOrigin;
342     bool revalidateAllResources = optionalRevalidateAllResources &amp;&amp; *optionalRevalidateAllResources;
343 
344     OptionSet&lt;ReloadOption&gt; reloadOptions;
345     if (reloadFromOrigin)
346         reloadOptions.add(ReloadOption::FromOrigin);
347     if (!revalidateAllResources)
348         reloadOptions.add(ReloadOption::ExpiredOnly);
349 
<span class="line-modified">350     m_page.mainFrame().loader().reload(reloadOptions);</span>
351 }
352 
353 void InspectorPageAgent::navigate(ErrorString&amp;, const String&amp; url)
354 {
355     UserGestureIndicator indicator { ProcessingUserGesture };
<span class="line-modified">356     Frame&amp; frame = m_page.mainFrame();</span>
357 
358     ResourceRequest resourceRequest { frame.document()-&gt;completeURL(url) };
359     FrameLoadRequest frameLoadRequest { *frame.document(), frame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
360     frame.loader().changeLocation(WTFMove(frameLoadRequest));
361 }
362 
363 void InspectorPageAgent::overrideUserAgent(ErrorString&amp;, const String* value)
364 {
365     m_userAgentOverride = value ? *value : String();
366 }
367 







368 void InspectorPageAgent::overrideSetting(ErrorString&amp; errorString, const String&amp; settingString, const bool* value)
369 {
370     if (settingString.isEmpty()) {
<span class="line-modified">371         errorString = &quot;Preference is empty&quot;_s;</span>
372         return;
373     }
374 
375     auto setting = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Page::Setting&gt;(settingString);
376     if (!setting) {
<span class="line-modified">377         errorString = makeString(&quot;Unknown setting: &quot;_s, settingString);</span>
378         return;
379     }
380 

381     switch (setting.value()) {
382 #define CASE_INSPECTOR_OVERRIDE_SETTING(name) \
<span class="line-modified">383     case Inspector::Protocol::Page::Setting::name: { \</span>
<span class="line-modified">384         if (value) \</span>
<span class="line-modified">385             m_page.settings().set##name##InspectorOverride(*value); \</span>
<span class="line-removed">386         else \</span>
<span class="line-removed">387             m_page.settings().set##name##InspectorOverride(WTF::nullopt); \</span>
<span class="line-removed">388         return; \</span>
<span class="line-removed">389     } \</span>
390 
391     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(CASE_INSPECTOR_OVERRIDE_SETTING)
392 
393 #undef CASE_INSPECTOR_OVERRIDE_SETTING
394     }
395 
<span class="line-modified">396     ASSERT_NOT_REACHED();</span>


397 }
398 
399 static Inspector::Protocol::Page::CookieSameSitePolicy cookieSameSitePolicyJSON(Cookie::SameSitePolicy policy)
400 {
401     switch (policy) {
402     case Cookie::SameSitePolicy::None:
403         return Inspector::Protocol::Page::CookieSameSitePolicy::None;
404     case Cookie::SameSitePolicy::Lax:
405         return Inspector::Protocol::Page::CookieSameSitePolicy::Lax;
406     case Cookie::SameSitePolicy::Strict:
407         return Inspector::Protocol::Page::CookieSameSitePolicy::Strict;
408     }
409     ASSERT_NOT_REACHED();
410     return Inspector::Protocol::Page::CookieSameSitePolicy::None;
411 }
412 
413 static Ref&lt;Inspector::Protocol::Page::Cookie&gt; buildObjectForCookie(const Cookie&amp; cookie)
414 {
415     return Inspector::Protocol::Page::Cookie::create()
416         .setName(cookie.name)
</pre>
<hr />
<pre>
419         .setPath(cookie.path)
420         .setExpires(cookie.expires)
421         .setSize((cookie.name.length() + cookie.value.length()))
422         .setHttpOnly(cookie.httpOnly)
423         .setSecure(cookie.secure)
424         .setSession(cookie.session)
425         .setSameSite(cookieSameSitePolicyJSON(cookie.sameSite))
426         .release();
427 }
428 
429 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt; buildArrayForCookies(ListHashSet&lt;Cookie&gt;&amp; cookiesList)
430 {
431     auto cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
432 
433     for (const auto&amp; cookie : cookiesList)
434         cookies-&gt;addItem(buildObjectForCookie(cookie));
435 
436     return cookies;
437 }
438 
<span class="line-removed">439 static Vector&lt;CachedResource*&gt; cachedResourcesForFrame(Frame* frame)</span>
<span class="line-removed">440 {</span>
<span class="line-removed">441     Vector&lt;CachedResource*&gt; result;</span>
<span class="line-removed">442 </span>
<span class="line-removed">443     for (auto&amp; cachedResourceHandle : frame-&gt;document()-&gt;cachedResourceLoader().allCachedResources().values()) {</span>
<span class="line-removed">444         auto* cachedResource = cachedResourceHandle.get();</span>
<span class="line-removed">445         if (cachedResource-&gt;resourceRequest().hiddenFromInspector())</span>
<span class="line-removed">446             continue;</span>
<span class="line-removed">447 </span>
<span class="line-removed">448         switch (cachedResource-&gt;type()) {</span>
<span class="line-removed">449         case CachedResource::Type::ImageResource:</span>
<span class="line-removed">450             // Skip images that were not auto loaded (images disabled in the user agent).</span>
<span class="line-removed">451 #if ENABLE(SVG_FONTS)</span>
<span class="line-removed">452         case CachedResource::Type::SVGFontResource:</span>
<span class="line-removed">453 #endif</span>
<span class="line-removed">454         case CachedResource::Type::FontResource:</span>
<span class="line-removed">455             // Skip fonts that were referenced in CSS but never used/downloaded.</span>
<span class="line-removed">456             if (cachedResource-&gt;stillNeedsLoad())</span>
<span class="line-removed">457                 continue;</span>
<span class="line-removed">458             break;</span>
<span class="line-removed">459         default:</span>
<span class="line-removed">460             // All other CachedResource types download immediately.</span>
<span class="line-removed">461             break;</span>
<span class="line-removed">462         }</span>
<span class="line-removed">463 </span>
<span class="line-removed">464         result.append(cachedResource);</span>
<span class="line-removed">465     }</span>
<span class="line-removed">466 </span>
<span class="line-removed">467     return result;</span>
<span class="line-removed">468 }</span>
<span class="line-removed">469 </span>
470 static Vector&lt;URL&gt; allResourcesURLsForFrame(Frame* frame)
471 {
472     Vector&lt;URL&gt; result;
473 
474     result.append(frame-&gt;loader().documentLoader()-&gt;url());
475 
<span class="line-modified">476     for (auto* cachedResource : cachedResourcesForFrame(frame))</span>
477         result.append(cachedResource-&gt;url());
478 
479     return result;
480 }
481 
482 void InspectorPageAgent::getCookies(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt;&amp; cookies)
483 {
484     // If we can get raw cookies.
485     ListHashSet&lt;Cookie&gt; rawCookiesList;
486 
487     // If we can&#39;t get raw cookies - fall back to String representation
488     StringBuilder stringCookiesList;
489 
490     // Return value to getRawCookies should be the same for every call because
491     // the return value is platform/network backend specific, and the call will
492     // always return the same true/false value.
493     bool rawCookiesImplemented = false;
494 
<span class="line-modified">495     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
496         Document* document = frame-&gt;document();
497         if (!document || !document-&gt;page())
498             continue;
499 
500         for (auto&amp; url : allResourcesURLsForFrame(frame)) {
501             Vector&lt;Cookie&gt; docCookiesList;
502             rawCookiesImplemented = document-&gt;page()-&gt;cookieJar().getRawCookies(*document, URL({ }, url), docCookiesList);
503 
504             if (!rawCookiesImplemented) {
505                 // FIXME: We need duplication checking for the String representation of cookies.
506                 // Exceptions are thrown by cookie() in sandboxed frames. That won&#39;t happen here
507                 // because &quot;document&quot; is the document of the main frame of the page.
508                 stringCookiesList.append(document-&gt;cookie().releaseReturnValue());
509             } else {
510                 for (auto&amp; cookie : docCookiesList)
511                     rawCookiesList.add(cookie);
512             }
513         }
514     }
515 
516     // FIXME: Do not return empty string/empty array. Make returns optional instead. https://bugs.webkit.org/show_bug.cgi?id=80855
517     if (rawCookiesImplemented)
518         cookies = buildArrayForCookies(rawCookiesList);
519     else
520         cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
521 }
522 
523 void InspectorPageAgent::deleteCookie(ErrorString&amp;, const String&amp; cookieName, const String&amp; url)
524 {
525     URL parsedURL({ }, url);
<span class="line-modified">526     for (Frame* frame = &amp;m_page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
527         if (auto* document = frame-&gt;document()) {
528             if (auto* page = document-&gt;page())
529                 page-&gt;cookieJar().deleteCookie(*document, parsedURL, cookieName);
530         }
531     }
532 }
533 
534 void InspectorPageAgent::getResourceTree(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&amp; object)
535 {
<span class="line-modified">536     object = buildObjectForFrameTree(&amp;m_page.mainFrame());</span>
537 }
538 
539 void InspectorPageAgent::getResourceContent(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, String* content, bool* base64Encoded)
540 {
541     Frame* frame = assertFrame(errorString, frameId);
542     if (!frame)
543         return;
544 
545     resourceContent(errorString, frame, URL({ }, url), content, base64Encoded);
546 }
547 
548 void InspectorPageAgent::searchInResource(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* optionalRequestId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
549 {
550     results = JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;::create();
551 
552     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
553     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
554 
555     if (optionalRequestId) {
556         if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent()) {
</pre>
<hr />
<pre>
589     results = ContentSearchUtilities::searchInTextByLines(content, query, caseSensitive, isRegex);
590 }
591 
592 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; frameId, const String&amp; url, int matchesCount)
593 {
594     return Inspector::Protocol::Page::SearchResult::create()
595         .setUrl(url)
596         .setFrameId(frameId)
597         .setMatchesCount(matchesCount)
598         .release();
599 }
600 
601 void InspectorPageAgent::searchInResources(ErrorString&amp;, const String&amp; text, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
602 {
603     result = JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;::create();
604 
605     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
606     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
607     JSC::Yarr::RegularExpression regex = ContentSearchUtilities::createSearchRegex(text, caseSensitive, isRegex);
608 
<span class="line-modified">609     for (Frame* frame = &amp;m_page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
610         for (auto* cachedResource : cachedResourcesForFrame(frame)) {
611             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*cachedResource)) {
612                 int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, *textContent);
613                 if (matchesCount)
614                     result-&gt;addItem(buildObjectForSearchResult(frameId(frame), cachedResource-&gt;url(), matchesCount));
615             }
616         }
617     }
618 
619     if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent())
620         networkAgent-&gt;searchOtherRequests(regex, result);
621 }
622 
623 void InspectorPageAgent::setShowRulers(ErrorString&amp;, bool showRulers)
624 {
625     m_overlay-&gt;setShowRulers(showRulers);
626 }
627 
628 void InspectorPageAgent::setShowPaintRects(ErrorString&amp;, bool show)
629 {
630     m_showPaintRects = show;
631     m_client-&gt;setShowPaintRects(show);
632 
633     if (m_client-&gt;overridesShowPaintRects())
634         return;
635 
<span class="line-modified">636     m_overlay-&gt;setShowingPaintRects(show);</span>
637 }
638 
639 void InspectorPageAgent::domContentEventFired()
640 {
641     m_isFirstLayoutAfterOnLoad = true;
642     m_frontendDispatcher-&gt;domContentEventFired(timestamp());
643 }
644 
645 void InspectorPageAgent::loadEventFired()
646 {
647     m_frontendDispatcher-&gt;loadEventFired(timestamp());
648 }
649 
650 void InspectorPageAgent::frameNavigated(Frame&amp; frame)
651 {
652     m_frontendDispatcher-&gt;frameNavigated(buildObjectForFrame(&amp;frame));
653 }
654 
655 void InspectorPageAgent::frameDetached(Frame&amp; frame)
656 {
657     auto identifier = m_frameToIdentifier.take(&amp;frame);
658     if (identifier.isNull())
659         return;
660     m_frontendDispatcher-&gt;frameDetached(identifier);
661     m_identifierToFrame.remove(identifier);
662 }
663 
<span class="line-removed">664 Frame&amp; InspectorPageAgent::mainFrame()</span>
<span class="line-removed">665 {</span>
<span class="line-removed">666     return m_page.mainFrame();</span>
<span class="line-removed">667 }</span>
<span class="line-removed">668 </span>
669 Frame* InspectorPageAgent::frameForId(const String&amp; frameId)
670 {
671     return frameId.isEmpty() ? nullptr : m_identifierToFrame.get(frameId);
672 }
673 
674 String InspectorPageAgent::frameId(Frame* frame)
675 {
676     if (!frame)
677         return emptyString();
678     return m_frameToIdentifier.ensure(frame, [this, frame] {
679         auto identifier = IdentifiersFactory::createIdentifier();
680         m_identifierToFrame.set(identifier, frame);
681         return identifier;
682     }).iterator-&gt;value;
683 }
684 
<span class="line-removed">685 bool InspectorPageAgent::hasIdForFrame(Frame* frame) const</span>
<span class="line-removed">686 {</span>
<span class="line-removed">687     return frame &amp;&amp; m_frameToIdentifier.contains(frame);</span>
<span class="line-removed">688 }</span>
<span class="line-removed">689 </span>
690 String InspectorPageAgent::loaderId(DocumentLoader* loader)
691 {
692     if (!loader)
693         return emptyString();
694     return m_loaderToIdentifier.ensure(loader, [] {
695         return IdentifiersFactory::createIdentifier();
696     }).iterator-&gt;value;
697 }
698 
<span class="line-removed">699 Frame* InspectorPageAgent::findFrameWithSecurityOrigin(const String&amp; originRawString)</span>
<span class="line-removed">700 {</span>
<span class="line-removed">701     for (Frame* frame = &amp;m_page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-removed">702         if (frame-&gt;document()-&gt;securityOrigin().toRawString() == originRawString)</span>
<span class="line-removed">703             return frame;</span>
<span class="line-removed">704     }</span>
<span class="line-removed">705     return nullptr;</span>
<span class="line-removed">706 }</span>
<span class="line-removed">707 </span>
708 Frame* InspectorPageAgent::assertFrame(ErrorString&amp; errorString, const String&amp; frameId)
709 {
710     Frame* frame = frameForId(frameId);
711     if (!frame)
<span class="line-modified">712         errorString = &quot;No frame for given id found&quot;_s;</span>
713     return frame;
714 }
715 
<span class="line-removed">716 DocumentLoader* InspectorPageAgent::assertDocumentLoader(ErrorString&amp; errorString, Frame* frame)</span>
<span class="line-removed">717 {</span>
<span class="line-removed">718     FrameLoader&amp; frameLoader = frame-&gt;loader();</span>
<span class="line-removed">719     DocumentLoader* documentLoader = frameLoader.documentLoader();</span>
<span class="line-removed">720     if (!documentLoader)</span>
<span class="line-removed">721         errorString = &quot;No documentLoader for given frame found&quot;_s;</span>
<span class="line-removed">722     return documentLoader;</span>
<span class="line-removed">723 }</span>
<span class="line-removed">724 </span>
725 void InspectorPageAgent::loaderDetachedFromFrame(DocumentLoader&amp; loader)
726 {
727     m_loaderToIdentifier.remove(&amp;loader);
728 }
729 
730 void InspectorPageAgent::frameStartedLoading(Frame&amp; frame)
731 {
732     m_frontendDispatcher-&gt;frameStartedLoading(frameId(&amp;frame));
733 }
734 
735 void InspectorPageAgent::frameStoppedLoading(Frame&amp; frame)
736 {
737     m_frontendDispatcher-&gt;frameStoppedLoading(frameId(&amp;frame));
738 }
739 
740 void InspectorPageAgent::frameScheduledNavigation(Frame&amp; frame, Seconds delay)
741 {
742     m_frontendDispatcher-&gt;frameScheduledNavigation(frameId(&amp;frame), delay.value());
743 }
744 
745 void InspectorPageAgent::frameClearedScheduledNavigation(Frame&amp; frame)
746 {
747     m_frontendDispatcher-&gt;frameClearedScheduledNavigation(frameId(&amp;frame));
748 }
749 
750 void InspectorPageAgent::defaultAppearanceDidChange(bool useDarkAppearance)
751 {
752     m_frontendDispatcher-&gt;defaultAppearanceDidChange(useDarkAppearance ? Inspector::Protocol::Page::Appearance::Dark : Inspector::Protocol::Page::Appearance::Light);
753 }
754 
755 void InspectorPageAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; rect)
756 {
<span class="line-modified">757     if (!m_enabled || !m_showPaintRects)</span>
758         return;
759 
760     LayoutRect absoluteRect = LayoutRect(renderer.localToAbsoluteQuad(FloatRect(rect)).boundingBox());
761     FrameView* view = renderer.document().view();
762 
763     LayoutRect rootRect = absoluteRect;
764     if (!view-&gt;frame().isMainFrame()) {
765         IntRect rootViewRect = view-&gt;contentsToRootView(snappedIntRect(absoluteRect));
766         rootRect = view-&gt;frame().mainFrame().view()-&gt;rootViewToContents(rootViewRect);
767     }
768 
769     if (m_client-&gt;overridesShowPaintRects()) {
770         m_client-&gt;showPaintRect(rootRect);
771         return;
772     }
773 
774     m_overlay-&gt;showPaintRect(rootRect);
775 }
776 
777 void InspectorPageAgent::didLayout()
778 {
779     bool isFirstLayout = m_isFirstLayoutAfterOnLoad;
780     if (isFirstLayout)
781         m_isFirstLayoutAfterOnLoad = false;
782 
<span class="line-removed">783     if (!m_enabled)</span>
<span class="line-removed">784         return;</span>
<span class="line-removed">785 </span>
786     m_overlay-&gt;update();
787 }
788 
789 void InspectorPageAgent::didScroll()
790 {
<span class="line-modified">791     if (m_enabled)</span>
<span class="line-removed">792         m_overlay-&gt;update();</span>
793 }
794 
795 void InspectorPageAgent::didRecalculateStyle()
796 {
<span class="line-modified">797     if (m_enabled)</span>
<span class="line-removed">798         m_overlay-&gt;update();</span>
799 }
800 
801 Ref&lt;Inspector::Protocol::Page::Frame&gt; InspectorPageAgent::buildObjectForFrame(Frame* frame)
802 {
803     ASSERT_ARG(frame, frame);
804 
805     auto frameObject = Inspector::Protocol::Page::Frame::create()
806         .setId(frameId(frame))
807         .setLoaderId(loaderId(frame-&gt;loader().documentLoader()))
808         .setUrl(frame-&gt;document()-&gt;url().string())
809         .setMimeType(frame-&gt;loader().documentLoader()-&gt;responseMIMEType())
810         .setSecurityOrigin(frame-&gt;document()-&gt;securityOrigin().toRawString())
811         .release();
812     if (frame-&gt;tree().parent())
813         frameObject-&gt;setParentId(frameId(frame-&gt;tree().parent()));
814     if (frame-&gt;ownerElement()) {
815         String name = frame-&gt;ownerElement()-&gt;getNameAttribute();
816         if (name.isEmpty())
817             name = frame-&gt;ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::idAttr);
818         frameObject-&gt;setName(name);
</pre>
<hr />
<pre>
852     }
853 
854     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&gt; childrenArray;
855     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
856         if (!childrenArray) {
857             childrenArray = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;::create();
858             result-&gt;setChildFrames(childrenArray);
859         }
860         childrenArray-&gt;addItem(buildObjectForFrameTree(child));
861     }
862     return result;
863 }
864 
865 void InspectorPageAgent::setEmulatedMedia(ErrorString&amp;, const String&amp; media)
866 {
867     if (media == m_emulatedMedia)
868         return;
869 
870     m_emulatedMedia = media;
871 
<span class="line-modified">872     m_page.updateStyleAfterChangeInEnvironment();</span>
873 
<span class="line-modified">874     if (auto* document = m_page.mainFrame().document())</span>
875         document-&gt;updateLayout();
876 }
877 
878 void InspectorPageAgent::setForcedAppearance(ErrorString&amp;, const String&amp; appearance)
879 {
880     if (appearance == m_forcedAppearance)
881         return;
882 
883     m_forcedAppearance = appearance;
884 
885     if (appearance == &quot;Light&quot;_s)
<span class="line-modified">886         m_page.setUseDarkAppearanceOverride(false);</span>
887     else if (appearance == &quot;Dark&quot;_s)
<span class="line-modified">888         m_page.setUseDarkAppearanceOverride(true);</span>
889     else
<span class="line-modified">890         m_page.setUseDarkAppearanceOverride(WTF::nullopt);</span>
891 }
892 
893 void InspectorPageAgent::applyUserAgentOverride(String&amp; userAgent)
894 {
895     if (!m_userAgentOverride.isEmpty())
896         userAgent = m_userAgentOverride;
897 }
898 
899 void InspectorPageAgent::applyEmulatedMedia(String&amp; media)
900 {
901     if (!m_emulatedMedia.isEmpty())
902         media = m_emulatedMedia;
903 }
904 
905 void InspectorPageAgent::getCompositingBordersVisible(ErrorString&amp;, bool* outParam)
906 {
<span class="line-modified">907     *outParam = m_page.settings().showDebugBorders() || m_page.settings().showRepaintCounter();</span>
908 }
909 
910 void InspectorPageAgent::setCompositingBordersVisible(ErrorString&amp;, bool visible)
911 {
<span class="line-modified">912     m_page.settings().setShowDebugBorders(visible);</span>
<span class="line-modified">913     m_page.settings().setShowRepaintCounter(visible);</span>
914 }
915 
916 void InspectorPageAgent::snapshotNode(ErrorString&amp; errorString, int nodeId, String* outDataURL)
917 {
<span class="line-removed">918     Frame&amp; frame = mainFrame();</span>
<span class="line-removed">919 </span>
920     InspectorDOMAgent* domAgent = m_instrumentingAgents.inspectorDOMAgent();
921     ASSERT(domAgent);
922     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
923     if (!node)
924         return;
925 
<span class="line-modified">926     std::unique_ptr&lt;ImageBuffer&gt; snapshot = WebCore::snapshotNode(frame, *node);</span>
927     if (!snapshot) {
928         errorString = &quot;Could not capture snapshot&quot;_s;
929         return;
930     }
931 
932     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
933 }
934 
935 void InspectorPageAgent::snapshotRect(ErrorString&amp; errorString, int x, int y, int width, int height, const String&amp; coordinateSystem, String* outDataURL)
936 {
<span class="line-removed">937     Frame&amp; frame = mainFrame();</span>
<span class="line-removed">938 </span>
939     SnapshotOptions options = SnapshotOptionsNone;
940     if (coordinateSystem == &quot;Viewport&quot;)
941         options |= SnapshotOptionsInViewCoordinates;
942 
943     IntRect rectangle(x, y, width, height);
<span class="line-modified">944     std::unique_ptr&lt;ImageBuffer&gt; snapshot = snapshotFrameRect(frame, rectangle, options);</span>
945 
946     if (!snapshot) {
947         errorString = &quot;Could not capture snapshot&quot;_s;
948         return;
949     }
950 
951     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
952 }
953 
954 void InspectorPageAgent::archive(ErrorString&amp; errorString, String* data)
955 {
956 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
<span class="line-modified">957     Frame&amp; frame = mainFrame();</span>
<span class="line-removed">958     auto archive = LegacyWebArchive::create(frame);</span>
959     if (!archive) {
960         errorString = &quot;Could not create web archive for main frame&quot;_s;
961         return;
962     }
963 
964     RetainPtr&lt;CFDataRef&gt; buffer = archive-&gt;rawDataRepresentation();
965     *data = base64Encode(CFDataGetBytePtr(buffer.get()), CFDataGetLength(buffer.get()));
966 #else
967     UNUSED_PARAM(data);
<span class="line-modified">968     errorString = &quot;No support for creating archives&quot;_s;</span>
969 #endif
970 }
971 
972 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorPageAgent.h&quot;
 34 
 35 #include &quot;CachedResource.h&quot;
 36 #include &quot;CachedResourceLoader.h&quot;
 37 #include &quot;Cookie.h&quot;
 38 #include &quot;CookieJar.h&quot;
<span class="line-added"> 39 #include &quot;CustomHeaderFields.h&quot;</span>
 40 #include &quot;Document.h&quot;
 41 #include &quot;DocumentLoader.h&quot;
 42 #include &quot;Frame.h&quot;
 43 #include &quot;FrameLoadRequest.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;FrameSnapshotting.h&quot;
 46 #include &quot;FrameView.h&quot;
 47 #include &quot;HTMLFrameOwnerElement.h&quot;
 48 #include &quot;HTMLNames.h&quot;
 49 #include &quot;ImageBuffer.h&quot;
 50 #include &quot;InspectorClient.h&quot;
 51 #include &quot;InspectorDOMAgent.h&quot;
 52 #include &quot;InspectorNetworkAgent.h&quot;
 53 #include &quot;InspectorOverlay.h&quot;
 54 #include &quot;InstrumentingAgents.h&quot;
 55 #include &quot;MIMETypeRegistry.h&quot;
 56 #include &quot;MemoryCache.h&quot;
 57 #include &quot;Page.h&quot;
 58 #include &quot;RenderObject.h&quot;
 59 #include &quot;RenderTheme.h&quot;
</pre>
<hr />
<pre>
 76 #endif
 77 
 78 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
 79 #include &quot;LegacyWebArchive.h&quot;
 80 #endif
 81 
 82 
 83 namespace WebCore {
 84 
 85 using namespace Inspector;
 86 
 87 // Keep this in sync with Page.Setting
 88 #define FOR_EACH_INSPECTOR_OVERRIDE_SETTING(macro) \
 89     macro(AuthorAndUserStylesEnabled) \
 90     macro(ICECandidateFilteringEnabled) \
 91     macro(ImagesEnabled) \
 92     macro(MediaCaptureRequiresSecureConnection) \
 93     macro(MockCaptureDevicesEnabled) \
 94     macro(NeedsSiteSpecificQuirks) \
 95     macro(ScriptEnabled) \
<span class="line-added"> 96     macro(WebRTCEncryptionEnabled) \</span>
 97     macro(WebSecurityEnabled)
 98 
 99 static bool decodeBuffer(const char* buffer, unsigned size, const String&amp; textEncodingName, String* result)
100 {
101     if (buffer) {
102         TextEncoding encoding(textEncodingName);
103         if (!encoding.isValid())
104             encoding = WindowsLatin1Encoding();
105         *result = encoding.decode(buffer, size);
106         return true;
107     }
108     return false;
109 }
110 
111 bool InspectorPageAgent::mainResourceContent(Frame* frame, bool withBase64Encode, String* result)
112 {
113     RefPtr&lt;SharedBuffer&gt; buffer = frame-&gt;loader().documentLoader()-&gt;mainResourceData();
114     if (!buffer)
115         return false;
116     return InspectorPageAgent::dataContent(buffer-&gt;data(), buffer-&gt;size(), frame-&gt;document()-&gt;encoding(), withBase64Encode, result);
117 }
118 
119 bool InspectorPageAgent::sharedBufferContent(RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, const String&amp; textEncodingName, bool withBase64Encode, String* result)
120 {
121     return dataContent(buffer ? buffer-&gt;data() : nullptr, buffer ? buffer-&gt;size() : 0, textEncodingName, withBase64Encode, result);
122 }
123 
124 bool InspectorPageAgent::dataContent(const char* data, unsigned size, const String&amp; textEncodingName, bool withBase64Encode, String* result)
125 {
126     if (withBase64Encode) {
127         *result = base64Encode(data, size);
128         return true;
129     }
130 
131     return decodeBuffer(data, size, textEncodingName, result);
132 }
133 
<span class="line-added">134 Vector&lt;CachedResource*&gt; InspectorPageAgent::cachedResourcesForFrame(Frame* frame)</span>
<span class="line-added">135 {</span>
<span class="line-added">136     Vector&lt;CachedResource*&gt; result;</span>
<span class="line-added">137 </span>
<span class="line-added">138     for (auto&amp; cachedResourceHandle : frame-&gt;document()-&gt;cachedResourceLoader().allCachedResources().values()) {</span>
<span class="line-added">139         auto* cachedResource = cachedResourceHandle.get();</span>
<span class="line-added">140         if (cachedResource-&gt;resourceRequest().hiddenFromInspector())</span>
<span class="line-added">141             continue;</span>
<span class="line-added">142 </span>
<span class="line-added">143         switch (cachedResource-&gt;type()) {</span>
<span class="line-added">144         case CachedResource::Type::ImageResource:</span>
<span class="line-added">145             // Skip images that were not auto loaded (images disabled in the user agent).</span>
<span class="line-added">146 #if ENABLE(SVG_FONTS)</span>
<span class="line-added">147         case CachedResource::Type::SVGFontResource:</span>
<span class="line-added">148 #endif</span>
<span class="line-added">149         case CachedResource::Type::FontResource:</span>
<span class="line-added">150             // Skip fonts that were referenced in CSS but never used/downloaded.</span>
<span class="line-added">151             if (cachedResource-&gt;stillNeedsLoad())</span>
<span class="line-added">152                 continue;</span>
<span class="line-added">153             break;</span>
<span class="line-added">154         default:</span>
<span class="line-added">155             // All other CachedResource types download immediately.</span>
<span class="line-added">156             break;</span>
<span class="line-added">157         }</span>
<span class="line-added">158 </span>
<span class="line-added">159         result.append(cachedResource);</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     return result;</span>
<span class="line-added">163 }</span>
<span class="line-added">164 </span>
165 void InspectorPageAgent::resourceContent(ErrorString&amp; errorString, Frame* frame, const URL&amp; url, String* result, bool* base64Encoded)
166 {
167     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
168     if (!loader)
169         return;
170 
171     RefPtr&lt;SharedBuffer&gt; buffer;
172     bool success = false;
173     if (equalIgnoringFragmentIdentifier(url, loader-&gt;url())) {
174         *base64Encoded = false;
175         success = mainResourceContent(frame, *base64Encoded, result);
176     }
177 
178     if (!success) {
179         if (auto* resource = cachedResource(frame, url))
180             success = InspectorNetworkAgent::cachedResourceContent(*resource, result, base64Encoded);
181     }
182 
183     if (!success)
<span class="line-modified">184         errorString = &quot;Missing resource for given url&quot;_s;</span>
185 }
186 
187 String InspectorPageAgent::sourceMapURLForResource(CachedResource* cachedResource)
188 {
189     if (!cachedResource)
190         return String();
191 
192     // Scripts are handled in a separate path.
193     if (cachedResource-&gt;type() != CachedResource::Type::CSSStyleSheet)
194         return String();
195 
196     String sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::SourceMap);
197     if (!sourceMapHeader.isEmpty())
198         return sourceMapHeader;
199 
200     sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::XSourceMap);
201     if (!sourceMapHeader.isEmpty())
202         return sourceMapHeader;
203 
204     String content;
</pre>
<hr />
<pre>
216 
217     CachedResource* cachedResource = frame-&gt;document()-&gt;cachedResourceLoader().cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(url));
218     if (!cachedResource) {
219         ResourceRequest request(url);
220         request.setDomainForCachePartition(frame-&gt;document()-&gt;domainForCachePartition());
221         cachedResource = MemoryCache::singleton().resourceForRequest(request, frame-&gt;page()-&gt;sessionID());
222     }
223 
224     return cachedResource;
225 }
226 
227 Inspector::Protocol::Page::ResourceType InspectorPageAgent::resourceTypeJSON(InspectorPageAgent::ResourceType resourceType)
228 {
229     switch (resourceType) {
230     case DocumentResource:
231         return Inspector::Protocol::Page::ResourceType::Document;
232     case ImageResource:
233         return Inspector::Protocol::Page::ResourceType::Image;
234     case FontResource:
235         return Inspector::Protocol::Page::ResourceType::Font;
<span class="line-modified">236     case StyleSheetResource:</span>
<span class="line-modified">237         return Inspector::Protocol::Page::ResourceType::StyleSheet;</span>
238     case ScriptResource:
239         return Inspector::Protocol::Page::ResourceType::Script;
240     case XHRResource:
241         return Inspector::Protocol::Page::ResourceType::XHR;
242     case FetchResource:
243         return Inspector::Protocol::Page::ResourceType::Fetch;
244     case PingResource:
245         return Inspector::Protocol::Page::ResourceType::Ping;
246     case BeaconResource:
247         return Inspector::Protocol::Page::ResourceType::Beacon;
248     case WebSocketResource:
249         return Inspector::Protocol::Page::ResourceType::WebSocket;
250     case OtherResource:
251         return Inspector::Protocol::Page::ResourceType::Other;
252 #if ENABLE(APPLICATION_MANIFEST)
253     case ApplicationManifestResource:
254         break;
255 #endif
256     }
257     return Inspector::Protocol::Page::ResourceType::Other;
258 }
259 
260 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(CachedResource::Type type)
261 {
262     switch (type) {
263     case CachedResource::Type::ImageResource:
264         return InspectorPageAgent::ImageResource;
265 #if ENABLE(SVG_FONTS)
266     case CachedResource::Type::SVGFontResource:
267 #endif
268     case CachedResource::Type::FontResource:
269         return InspectorPageAgent::FontResource;
270 #if ENABLE(XSLT)
271     case CachedResource::Type::XSLStyleSheet:
272 #endif
273     case CachedResource::Type::CSSStyleSheet:
<span class="line-modified">274         return InspectorPageAgent::StyleSheetResource;</span>
275     case CachedResource::Type::Script:
276         return InspectorPageAgent::ScriptResource;
277     case CachedResource::Type::MainResource:
278         return InspectorPageAgent::DocumentResource;
279     case CachedResource::Type::Beacon:
280         return InspectorPageAgent::BeaconResource;
281 #if ENABLE(APPLICATION_MANIFEST)
282     case CachedResource::Type::ApplicationManifest:
283         return InspectorPageAgent::ApplicationManifestResource;
284 #endif
<span class="line-added">285     case CachedResource::Type::Ping:</span>
<span class="line-added">286         return InspectorPageAgent::PingResource;</span>
287     case CachedResource::Type::MediaResource:
288     case CachedResource::Type::Icon:
289     case CachedResource::Type::RawResource:
290     default:
291         return InspectorPageAgent::OtherResource;
292     }
293 }
294 
295 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(const CachedResource&amp; cachedResource)
296 {
297     if (cachedResource.type() == CachedResource::Type::RawResource) {
298         switch (cachedResource.resourceRequest().requester()) {
299         case ResourceRequest::Requester::Fetch:
300             return InspectorPageAgent::FetchResource;
301         case ResourceRequest::Requester::Main:
302             return InspectorPageAgent::DocumentResource;
303         default:
304             return InspectorPageAgent::XHRResource;
305         }
306     }
307 
308     return inspectorResourceType(cachedResource.type());
309 }
310 
311 Inspector::Protocol::Page::ResourceType InspectorPageAgent::cachedResourceTypeJSON(const CachedResource&amp; cachedResource)
312 {
313     return resourceTypeJSON(inspectorResourceType(cachedResource));
314 }
315 
<span class="line-added">316 Frame* InspectorPageAgent::findFrameWithSecurityOrigin(Page&amp; page, const String&amp; originRawString)</span>
<span class="line-added">317 {</span>
<span class="line-added">318     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">319         if (frame-&gt;document()-&gt;securityOrigin().toRawString() == originRawString)</span>
<span class="line-added">320             return frame;</span>
<span class="line-added">321     }</span>
<span class="line-added">322     return nullptr;</span>
<span class="line-added">323 }</span>
<span class="line-added">324 </span>
<span class="line-added">325 DocumentLoader* InspectorPageAgent::assertDocumentLoader(ErrorString&amp; errorString, Frame* frame)</span>
<span class="line-added">326 {</span>
<span class="line-added">327     FrameLoader&amp; frameLoader = frame-&gt;loader();</span>
<span class="line-added">328     DocumentLoader* documentLoader = frameLoader.documentLoader();</span>
<span class="line-added">329     if (!documentLoader)</span>
<span class="line-added">330         errorString = &quot;Missing document loader for given frame&quot;_s;</span>
<span class="line-added">331     return documentLoader;</span>
<span class="line-added">332 }</span>
<span class="line-added">333 </span>
334 InspectorPageAgent::InspectorPageAgent(PageAgentContext&amp; context, InspectorClient* client, InspectorOverlay* overlay)
335     : InspectorAgentBase(&quot;Page&quot;_s, context)
<span class="line-modified">336     , m_frontendDispatcher(makeUnique&lt;Inspector::PageFrontendDispatcher&gt;(context.frontendRouter))</span>
337     , m_backendDispatcher(Inspector::PageBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified">338     , m_inspectedPage(context.inspectedPage)</span>
339     , m_client(client)
340     , m_overlay(overlay)
341 {
342 }
343 
<span class="line-added">344 InspectorPageAgent::~InspectorPageAgent() = default;</span>
<span class="line-added">345 </span>
346 void InspectorPageAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
347 {
348 }
349 
350 void InspectorPageAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
351 {
352     ErrorString unused;
353     disable(unused);
354 }
355 
<span class="line-modified">356 void InspectorPageAgent::enable(ErrorString&amp; errorString)</span>
357 {
<span class="line-modified">358     if (m_instrumentingAgents.inspectorPageAgent() == this) {</span>
<span class="line-modified">359         errorString = &quot;Page domain already enabled&quot;_s;</span>
<span class="line-added">360         return;</span>
<span class="line-added">361     }</span>
362 



363     m_instrumentingAgents.setInspectorPageAgent(this);
364 
365     auto stopwatch = m_environment.executionStopwatch();
366     stopwatch-&gt;reset();
367     stopwatch-&gt;start();
368 
369 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">370     defaultAppearanceDidChange(m_inspectedPage.defaultUseDarkAppearance());</span>
371 #endif
372 }
373 
374 void InspectorPageAgent::disable(ErrorString&amp;)
375 {

376     m_instrumentingAgents.setInspectorPageAgent(nullptr);
377 
378     ErrorString unused;
379     setShowPaintRects(unused, false);
<span class="line-added">380     setShowRulers(unused, false);</span>
381     overrideUserAgent(unused, nullptr);
382     setEmulatedMedia(unused, emptyString());
383     setForcedAppearance(unused, emptyString());
384 
385 #define DISABLE_INSPECTOR_OVERRIDE_SETTING(name) \
<span class="line-modified">386     m_inspectedPage.settings().set##name##InspectorOverride(WTF::nullopt);</span>
387 
388     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(DISABLE_INSPECTOR_OVERRIDE_SETTING)
389 
390 #undef DISABLE_INSPECTOR_OVERRIDE_SETTING
<span class="line-added">391 </span>
<span class="line-added">392     m_client-&gt;setMockCaptureDevicesEnabledOverride(WTF::nullopt);</span>
<span class="line-added">393 }</span>
<span class="line-added">394 </span>
<span class="line-added">395 double InspectorPageAgent::timestamp()</span>
<span class="line-added">396 {</span>
<span class="line-added">397     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();</span>
398 }
399 
400 void InspectorPageAgent::reload(ErrorString&amp;, const bool* optionalReloadFromOrigin, const bool* optionalRevalidateAllResources)
401 {
402     bool reloadFromOrigin = optionalReloadFromOrigin &amp;&amp; *optionalReloadFromOrigin;
403     bool revalidateAllResources = optionalRevalidateAllResources &amp;&amp; *optionalRevalidateAllResources;
404 
405     OptionSet&lt;ReloadOption&gt; reloadOptions;
406     if (reloadFromOrigin)
407         reloadOptions.add(ReloadOption::FromOrigin);
408     if (!revalidateAllResources)
409         reloadOptions.add(ReloadOption::ExpiredOnly);
410 
<span class="line-modified">411     m_inspectedPage.mainFrame().loader().reload(reloadOptions);</span>
412 }
413 
414 void InspectorPageAgent::navigate(ErrorString&amp;, const String&amp; url)
415 {
416     UserGestureIndicator indicator { ProcessingUserGesture };
<span class="line-modified">417     Frame&amp; frame = m_inspectedPage.mainFrame();</span>
418 
419     ResourceRequest resourceRequest { frame.document()-&gt;completeURL(url) };
420     FrameLoadRequest frameLoadRequest { *frame.document(), frame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
421     frame.loader().changeLocation(WTFMove(frameLoadRequest));
422 }
423 
424 void InspectorPageAgent::overrideUserAgent(ErrorString&amp;, const String* value)
425 {
426     m_userAgentOverride = value ? *value : String();
427 }
428 
<span class="line-added">429 static inline Optional&lt;bool&gt; asOptionalBool(const bool* value)</span>
<span class="line-added">430 {</span>
<span class="line-added">431     if (!value)</span>
<span class="line-added">432         return WTF::nullopt;</span>
<span class="line-added">433     return *value;</span>
<span class="line-added">434 }</span>
<span class="line-added">435 </span>
436 void InspectorPageAgent::overrideSetting(ErrorString&amp; errorString, const String&amp; settingString, const bool* value)
437 {
438     if (settingString.isEmpty()) {
<span class="line-modified">439         errorString = &quot;settingString is empty&quot;_s;</span>
440         return;
441     }
442 
443     auto setting = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Page::Setting&gt;(settingString);
444     if (!setting) {
<span class="line-modified">445         errorString = makeString(&quot;Unknown settingString: &quot;_s, settingString);</span>
446         return;
447     }
448 
<span class="line-added">449     auto overrideValue = asOptionalBool(value);</span>
450     switch (setting.value()) {
451 #define CASE_INSPECTOR_OVERRIDE_SETTING(name) \
<span class="line-modified">452     case Inspector::Protocol::Page::Setting::name:                              \</span>
<span class="line-modified">453         m_inspectedPage.settings().set##name##InspectorOverride(overrideValue); \</span>
<span class="line-modified">454         break;                                                                  \</span>




455 
456     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(CASE_INSPECTOR_OVERRIDE_SETTING)
457 
458 #undef CASE_INSPECTOR_OVERRIDE_SETTING
459     }
460 
<span class="line-modified">461     // Update the UIProcess / client for particular overrides.</span>
<span class="line-added">462     if (setting.value() == Inspector::Protocol::Page::Setting::MockCaptureDevicesEnabled)</span>
<span class="line-added">463         m_client-&gt;setMockCaptureDevicesEnabledOverride(overrideValue);</span>
464 }
465 
466 static Inspector::Protocol::Page::CookieSameSitePolicy cookieSameSitePolicyJSON(Cookie::SameSitePolicy policy)
467 {
468     switch (policy) {
469     case Cookie::SameSitePolicy::None:
470         return Inspector::Protocol::Page::CookieSameSitePolicy::None;
471     case Cookie::SameSitePolicy::Lax:
472         return Inspector::Protocol::Page::CookieSameSitePolicy::Lax;
473     case Cookie::SameSitePolicy::Strict:
474         return Inspector::Protocol::Page::CookieSameSitePolicy::Strict;
475     }
476     ASSERT_NOT_REACHED();
477     return Inspector::Protocol::Page::CookieSameSitePolicy::None;
478 }
479 
480 static Ref&lt;Inspector::Protocol::Page::Cookie&gt; buildObjectForCookie(const Cookie&amp; cookie)
481 {
482     return Inspector::Protocol::Page::Cookie::create()
483         .setName(cookie.name)
</pre>
<hr />
<pre>
486         .setPath(cookie.path)
487         .setExpires(cookie.expires)
488         .setSize((cookie.name.length() + cookie.value.length()))
489         .setHttpOnly(cookie.httpOnly)
490         .setSecure(cookie.secure)
491         .setSession(cookie.session)
492         .setSameSite(cookieSameSitePolicyJSON(cookie.sameSite))
493         .release();
494 }
495 
496 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt; buildArrayForCookies(ListHashSet&lt;Cookie&gt;&amp; cookiesList)
497 {
498     auto cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
499 
500     for (const auto&amp; cookie : cookiesList)
501         cookies-&gt;addItem(buildObjectForCookie(cookie));
502 
503     return cookies;
504 }
505 































506 static Vector&lt;URL&gt; allResourcesURLsForFrame(Frame* frame)
507 {
508     Vector&lt;URL&gt; result;
509 
510     result.append(frame-&gt;loader().documentLoader()-&gt;url());
511 
<span class="line-modified">512     for (auto* cachedResource : InspectorPageAgent::cachedResourcesForFrame(frame))</span>
513         result.append(cachedResource-&gt;url());
514 
515     return result;
516 }
517 
518 void InspectorPageAgent::getCookies(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt;&amp; cookies)
519 {
520     // If we can get raw cookies.
521     ListHashSet&lt;Cookie&gt; rawCookiesList;
522 
523     // If we can&#39;t get raw cookies - fall back to String representation
524     StringBuilder stringCookiesList;
525 
526     // Return value to getRawCookies should be the same for every call because
527     // the return value is platform/network backend specific, and the call will
528     // always return the same true/false value.
529     bool rawCookiesImplemented = false;
530 
<span class="line-modified">531     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
532         Document* document = frame-&gt;document();
533         if (!document || !document-&gt;page())
534             continue;
535 
536         for (auto&amp; url : allResourcesURLsForFrame(frame)) {
537             Vector&lt;Cookie&gt; docCookiesList;
538             rawCookiesImplemented = document-&gt;page()-&gt;cookieJar().getRawCookies(*document, URL({ }, url), docCookiesList);
539 
540             if (!rawCookiesImplemented) {
541                 // FIXME: We need duplication checking for the String representation of cookies.
542                 // Exceptions are thrown by cookie() in sandboxed frames. That won&#39;t happen here
543                 // because &quot;document&quot; is the document of the main frame of the page.
544                 stringCookiesList.append(document-&gt;cookie().releaseReturnValue());
545             } else {
546                 for (auto&amp; cookie : docCookiesList)
547                     rawCookiesList.add(cookie);
548             }
549         }
550     }
551 
552     // FIXME: Do not return empty string/empty array. Make returns optional instead. https://bugs.webkit.org/show_bug.cgi?id=80855
553     if (rawCookiesImplemented)
554         cookies = buildArrayForCookies(rawCookiesList);
555     else
556         cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
557 }
558 
559 void InspectorPageAgent::deleteCookie(ErrorString&amp;, const String&amp; cookieName, const String&amp; url)
560 {
561     URL parsedURL({ }, url);
<span class="line-modified">562     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
563         if (auto* document = frame-&gt;document()) {
564             if (auto* page = document-&gt;page())
565                 page-&gt;cookieJar().deleteCookie(*document, parsedURL, cookieName);
566         }
567     }
568 }
569 
570 void InspectorPageAgent::getResourceTree(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&amp; object)
571 {
<span class="line-modified">572     object = buildObjectForFrameTree(&amp;m_inspectedPage.mainFrame());</span>
573 }
574 
575 void InspectorPageAgent::getResourceContent(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, String* content, bool* base64Encoded)
576 {
577     Frame* frame = assertFrame(errorString, frameId);
578     if (!frame)
579         return;
580 
581     resourceContent(errorString, frame, URL({ }, url), content, base64Encoded);
582 }
583 
584 void InspectorPageAgent::searchInResource(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* optionalRequestId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
585 {
586     results = JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;::create();
587 
588     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
589     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
590 
591     if (optionalRequestId) {
592         if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent()) {
</pre>
<hr />
<pre>
625     results = ContentSearchUtilities::searchInTextByLines(content, query, caseSensitive, isRegex);
626 }
627 
628 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; frameId, const String&amp; url, int matchesCount)
629 {
630     return Inspector::Protocol::Page::SearchResult::create()
631         .setUrl(url)
632         .setFrameId(frameId)
633         .setMatchesCount(matchesCount)
634         .release();
635 }
636 
637 void InspectorPageAgent::searchInResources(ErrorString&amp;, const String&amp; text, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
638 {
639     result = JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;::create();
640 
641     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
642     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
643     JSC::Yarr::RegularExpression regex = ContentSearchUtilities::createSearchRegex(text, caseSensitive, isRegex);
644 
<span class="line-modified">645     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {</span>
646         for (auto* cachedResource : cachedResourcesForFrame(frame)) {
647             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*cachedResource)) {
648                 int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, *textContent);
649                 if (matchesCount)
650                     result-&gt;addItem(buildObjectForSearchResult(frameId(frame), cachedResource-&gt;url(), matchesCount));
651             }
652         }
653     }
654 
655     if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent())
656         networkAgent-&gt;searchOtherRequests(regex, result);
657 }
658 
659 void InspectorPageAgent::setShowRulers(ErrorString&amp;, bool showRulers)
660 {
661     m_overlay-&gt;setShowRulers(showRulers);
662 }
663 
664 void InspectorPageAgent::setShowPaintRects(ErrorString&amp;, bool show)
665 {
666     m_showPaintRects = show;
667     m_client-&gt;setShowPaintRects(show);
668 
669     if (m_client-&gt;overridesShowPaintRects())
670         return;
671 
<span class="line-modified">672     m_overlay-&gt;setShowPaintRects(show);</span>
673 }
674 
675 void InspectorPageAgent::domContentEventFired()
676 {
677     m_isFirstLayoutAfterOnLoad = true;
678     m_frontendDispatcher-&gt;domContentEventFired(timestamp());
679 }
680 
681 void InspectorPageAgent::loadEventFired()
682 {
683     m_frontendDispatcher-&gt;loadEventFired(timestamp());
684 }
685 
686 void InspectorPageAgent::frameNavigated(Frame&amp; frame)
687 {
688     m_frontendDispatcher-&gt;frameNavigated(buildObjectForFrame(&amp;frame));
689 }
690 
691 void InspectorPageAgent::frameDetached(Frame&amp; frame)
692 {
693     auto identifier = m_frameToIdentifier.take(&amp;frame);
694     if (identifier.isNull())
695         return;
696     m_frontendDispatcher-&gt;frameDetached(identifier);
697     m_identifierToFrame.remove(identifier);
698 }
699 





700 Frame* InspectorPageAgent::frameForId(const String&amp; frameId)
701 {
702     return frameId.isEmpty() ? nullptr : m_identifierToFrame.get(frameId);
703 }
704 
705 String InspectorPageAgent::frameId(Frame* frame)
706 {
707     if (!frame)
708         return emptyString();
709     return m_frameToIdentifier.ensure(frame, [this, frame] {
710         auto identifier = IdentifiersFactory::createIdentifier();
711         m_identifierToFrame.set(identifier, frame);
712         return identifier;
713     }).iterator-&gt;value;
714 }
715 





716 String InspectorPageAgent::loaderId(DocumentLoader* loader)
717 {
718     if (!loader)
719         return emptyString();
720     return m_loaderToIdentifier.ensure(loader, [] {
721         return IdentifiersFactory::createIdentifier();
722     }).iterator-&gt;value;
723 }
724 









725 Frame* InspectorPageAgent::assertFrame(ErrorString&amp; errorString, const String&amp; frameId)
726 {
727     Frame* frame = frameForId(frameId);
728     if (!frame)
<span class="line-modified">729         errorString = &quot;Missing frame for given frameId&quot;_s;</span>
730     return frame;
731 }
732 









733 void InspectorPageAgent::loaderDetachedFromFrame(DocumentLoader&amp; loader)
734 {
735     m_loaderToIdentifier.remove(&amp;loader);
736 }
737 
738 void InspectorPageAgent::frameStartedLoading(Frame&amp; frame)
739 {
740     m_frontendDispatcher-&gt;frameStartedLoading(frameId(&amp;frame));
741 }
742 
743 void InspectorPageAgent::frameStoppedLoading(Frame&amp; frame)
744 {
745     m_frontendDispatcher-&gt;frameStoppedLoading(frameId(&amp;frame));
746 }
747 
748 void InspectorPageAgent::frameScheduledNavigation(Frame&amp; frame, Seconds delay)
749 {
750     m_frontendDispatcher-&gt;frameScheduledNavigation(frameId(&amp;frame), delay.value());
751 }
752 
753 void InspectorPageAgent::frameClearedScheduledNavigation(Frame&amp; frame)
754 {
755     m_frontendDispatcher-&gt;frameClearedScheduledNavigation(frameId(&amp;frame));
756 }
757 
758 void InspectorPageAgent::defaultAppearanceDidChange(bool useDarkAppearance)
759 {
760     m_frontendDispatcher-&gt;defaultAppearanceDidChange(useDarkAppearance ? Inspector::Protocol::Page::Appearance::Dark : Inspector::Protocol::Page::Appearance::Light);
761 }
762 
763 void InspectorPageAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; rect)
764 {
<span class="line-modified">765     if (!m_showPaintRects)</span>
766         return;
767 
768     LayoutRect absoluteRect = LayoutRect(renderer.localToAbsoluteQuad(FloatRect(rect)).boundingBox());
769     FrameView* view = renderer.document().view();
770 
771     LayoutRect rootRect = absoluteRect;
772     if (!view-&gt;frame().isMainFrame()) {
773         IntRect rootViewRect = view-&gt;contentsToRootView(snappedIntRect(absoluteRect));
774         rootRect = view-&gt;frame().mainFrame().view()-&gt;rootViewToContents(rootViewRect);
775     }
776 
777     if (m_client-&gt;overridesShowPaintRects()) {
778         m_client-&gt;showPaintRect(rootRect);
779         return;
780     }
781 
782     m_overlay-&gt;showPaintRect(rootRect);
783 }
784 
785 void InspectorPageAgent::didLayout()
786 {
787     bool isFirstLayout = m_isFirstLayoutAfterOnLoad;
788     if (isFirstLayout)
789         m_isFirstLayoutAfterOnLoad = false;
790 



791     m_overlay-&gt;update();
792 }
793 
794 void InspectorPageAgent::didScroll()
795 {
<span class="line-modified">796     m_overlay-&gt;update();</span>

797 }
798 
799 void InspectorPageAgent::didRecalculateStyle()
800 {
<span class="line-modified">801     m_overlay-&gt;update();</span>

802 }
803 
804 Ref&lt;Inspector::Protocol::Page::Frame&gt; InspectorPageAgent::buildObjectForFrame(Frame* frame)
805 {
806     ASSERT_ARG(frame, frame);
807 
808     auto frameObject = Inspector::Protocol::Page::Frame::create()
809         .setId(frameId(frame))
810         .setLoaderId(loaderId(frame-&gt;loader().documentLoader()))
811         .setUrl(frame-&gt;document()-&gt;url().string())
812         .setMimeType(frame-&gt;loader().documentLoader()-&gt;responseMIMEType())
813         .setSecurityOrigin(frame-&gt;document()-&gt;securityOrigin().toRawString())
814         .release();
815     if (frame-&gt;tree().parent())
816         frameObject-&gt;setParentId(frameId(frame-&gt;tree().parent()));
817     if (frame-&gt;ownerElement()) {
818         String name = frame-&gt;ownerElement()-&gt;getNameAttribute();
819         if (name.isEmpty())
820             name = frame-&gt;ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::idAttr);
821         frameObject-&gt;setName(name);
</pre>
<hr />
<pre>
855     }
856 
857     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&gt; childrenArray;
858     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
859         if (!childrenArray) {
860             childrenArray = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;::create();
861             result-&gt;setChildFrames(childrenArray);
862         }
863         childrenArray-&gt;addItem(buildObjectForFrameTree(child));
864     }
865     return result;
866 }
867 
868 void InspectorPageAgent::setEmulatedMedia(ErrorString&amp;, const String&amp; media)
869 {
870     if (media == m_emulatedMedia)
871         return;
872 
873     m_emulatedMedia = media;
874 
<span class="line-modified">875     m_inspectedPage.updateStyleAfterChangeInEnvironment();</span>
876 
<span class="line-modified">877     if (auto* document = m_inspectedPage.mainFrame().document())</span>
878         document-&gt;updateLayout();
879 }
880 
881 void InspectorPageAgent::setForcedAppearance(ErrorString&amp;, const String&amp; appearance)
882 {
883     if (appearance == m_forcedAppearance)
884         return;
885 
886     m_forcedAppearance = appearance;
887 
888     if (appearance == &quot;Light&quot;_s)
<span class="line-modified">889         m_inspectedPage.setUseDarkAppearanceOverride(false);</span>
890     else if (appearance == &quot;Dark&quot;_s)
<span class="line-modified">891         m_inspectedPage.setUseDarkAppearanceOverride(true);</span>
892     else
<span class="line-modified">893         m_inspectedPage.setUseDarkAppearanceOverride(WTF::nullopt);</span>
894 }
895 
896 void InspectorPageAgent::applyUserAgentOverride(String&amp; userAgent)
897 {
898     if (!m_userAgentOverride.isEmpty())
899         userAgent = m_userAgentOverride;
900 }
901 
902 void InspectorPageAgent::applyEmulatedMedia(String&amp; media)
903 {
904     if (!m_emulatedMedia.isEmpty())
905         media = m_emulatedMedia;
906 }
907 
908 void InspectorPageAgent::getCompositingBordersVisible(ErrorString&amp;, bool* outParam)
909 {
<span class="line-modified">910     *outParam = m_inspectedPage.settings().showDebugBorders() || m_inspectedPage.settings().showRepaintCounter();</span>
911 }
912 
913 void InspectorPageAgent::setCompositingBordersVisible(ErrorString&amp;, bool visible)
914 {
<span class="line-modified">915     m_inspectedPage.settings().setShowDebugBorders(visible);</span>
<span class="line-modified">916     m_inspectedPage.settings().setShowRepaintCounter(visible);</span>
917 }
918 
919 void InspectorPageAgent::snapshotNode(ErrorString&amp; errorString, int nodeId, String* outDataURL)
920 {


921     InspectorDOMAgent* domAgent = m_instrumentingAgents.inspectorDOMAgent();
922     ASSERT(domAgent);
923     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
924     if (!node)
925         return;
926 
<span class="line-modified">927     std::unique_ptr&lt;ImageBuffer&gt; snapshot = WebCore::snapshotNode(m_inspectedPage.mainFrame(), *node);</span>
928     if (!snapshot) {
929         errorString = &quot;Could not capture snapshot&quot;_s;
930         return;
931     }
932 
933     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
934 }
935 
936 void InspectorPageAgent::snapshotRect(ErrorString&amp; errorString, int x, int y, int width, int height, const String&amp; coordinateSystem, String* outDataURL)
937 {


938     SnapshotOptions options = SnapshotOptionsNone;
939     if (coordinateSystem == &quot;Viewport&quot;)
940         options |= SnapshotOptionsInViewCoordinates;
941 
942     IntRect rectangle(x, y, width, height);
<span class="line-modified">943     std::unique_ptr&lt;ImageBuffer&gt; snapshot = snapshotFrameRect(m_inspectedPage.mainFrame(), rectangle, options);</span>
944 
945     if (!snapshot) {
946         errorString = &quot;Could not capture snapshot&quot;_s;
947         return;
948     }
949 
950     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
951 }
952 
953 void InspectorPageAgent::archive(ErrorString&amp; errorString, String* data)
954 {
955 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
<span class="line-modified">956     auto archive = LegacyWebArchive::create(m_inspectedPage.mainFrame());</span>

957     if (!archive) {
958         errorString = &quot;Could not create web archive for main frame&quot;_s;
959         return;
960     }
961 
962     RetainPtr&lt;CFDataRef&gt; buffer = archive-&gt;rawDataRepresentation();
963     *data = base64Encode(CFDataGetBytePtr(buffer.get()), CFDataGetLength(buffer.get()));
964 #else
965     UNUSED_PARAM(data);
<span class="line-modified">966     errorString = &quot;Not supported&quot;_s;</span>
967 #endif
968 }
969 
970 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorNetworkAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorPageAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>