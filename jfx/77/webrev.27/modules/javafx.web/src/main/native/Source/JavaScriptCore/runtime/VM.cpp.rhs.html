<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
<a name="2" id="anc2"></a><span class="line-modified">  33 #include &quot;ArrayBufferNeuteringWatchpointSet.h&quot;</span>
  34 #include &quot;BuiltinExecutables.h&quot;
  35 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  36 #include &quot;CodeBlock.h&quot;
  37 #include &quot;CodeCache.h&quot;
  38 #include &quot;CommonIdentifiers.h&quot;
  39 #include &quot;CommonSlowPaths.h&quot;
  40 #include &quot;CustomGetterSetter.h&quot;
  41 #include &quot;DFGWorklist.h&quot;
  42 #include &quot;DirectEvalExecutable.h&quot;
  43 #include &quot;Disassembler.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  44 #include &quot;DoublePredictionFuzzerAgent.h&quot;</span>
  45 #include &quot;Error.h&quot;
  46 #include &quot;ErrorConstructor.h&quot;
  47 #include &quot;ErrorInstance.h&quot;
  48 #include &quot;EvalCodeBlock.h&quot;
  49 #include &quot;Exception.h&quot;
  50 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  51 #include &quot;FTLThunks.h&quot;
  52 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;
  53 #include &quot;FunctionCodeBlock.h&quot;
  54 #include &quot;FunctionConstructor.h&quot;
  55 #include &quot;FunctionExecutable.h&quot;
  56 #include &quot;GCActivityCallback.h&quot;
  57 #include &quot;GetterSetter.h&quot;
  58 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  59 #include &quot;HasOwnPropertyCache.h&quot;
  60 #include &quot;Heap.h&quot;
  61 #include &quot;HeapIterationScope.h&quot;
  62 #include &quot;HeapProfiler.h&quot;
  63 #include &quot;HostCallReturnValue.h&quot;
  64 #include &quot;Identifier.h&quot;
  65 #include &quot;IncrementalSweeper.h&quot;
  66 #include &quot;IndirectEvalExecutable.h&quot;
<a name="4" id="anc4"></a>
  67 #include &quot;Interpreter.h&quot;
  68 #include &quot;IntlCollatorConstructor.h&quot;
  69 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  70 #include &quot;IntlNumberFormatConstructor.h&quot;
  71 #include &quot;IntlPluralRulesConstructor.h&quot;
  72 #include &quot;JITCode.h&quot;
  73 #include &quot;JITWorklist.h&quot;
  74 #include &quot;JSAPIValueWrapper.h&quot;
  75 #include &quot;JSArray.h&quot;
  76 #include &quot;JSArrayBufferConstructor.h&quot;
  77 #include &quot;JSAsyncFunction.h&quot;
  78 #include &quot;JSBigInt.h&quot;
  79 #include &quot;JSBoundFunction.h&quot;
  80 #include &quot;JSCInlines.h&quot;
  81 #include &quot;JSCallbackFunction.h&quot;
  82 #include &quot;JSCustomGetterSetterFunction.h&quot;
  83 #include &quot;JSDestructibleObjectHeapCellType.h&quot;
  84 #include &quot;JSFixedArray.h&quot;
  85 #include &quot;JSFunction.h&quot;
  86 #include &quot;JSGlobalObjectFunctions.h&quot;
  87 #include &quot;JSImmutableButterfly.h&quot;
  88 #include &quot;JSInternalPromiseDeferred.h&quot;
  89 #include &quot;JSLock.h&quot;
  90 #include &quot;JSMap.h&quot;
  91 #include &quot;JSMapIterator.h&quot;
  92 #include &quot;JSPromiseDeferred.h&quot;
  93 #include &quot;JSPropertyNameEnumerator.h&quot;
<a name="5" id="anc5"></a>
  94 #include &quot;JSScriptFetchParameters.h&quot;
  95 #include &quot;JSScriptFetcher.h&quot;
  96 #include &quot;JSSet.h&quot;
  97 #include &quot;JSSetIterator.h&quot;
  98 #include &quot;JSSourceCode.h&quot;
  99 #include &quot;JSStringHeapCellType.h&quot;
 100 #include &quot;JSTemplateObjectDescriptor.h&quot;
 101 #include &quot;JSWeakMap.h&quot;
<a name="6" id="anc6"></a><span class="line-added"> 102 #include &quot;JSWeakObjectRef.h&quot;</span>
 103 #include &quot;JSWeakSet.h&quot;
 104 #include &quot;JSWebAssembly.h&quot;
 105 #include &quot;JSWebAssemblyCodeBlock.h&quot;
 106 #include &quot;JSWebAssemblyCodeBlockHeapCellType.h&quot;
 107 #include &quot;JSWithScope.h&quot;
 108 #include &quot;LLIntData.h&quot;
 109 #include &quot;Lexer.h&quot;
 110 #include &quot;Lookup.h&quot;
 111 #include &quot;MinimumReservedZoneSize.h&quot;
 112 #include &quot;ModuleProgramCodeBlock.h&quot;
 113 #include &quot;ModuleProgramExecutable.h&quot;
 114 #include &quot;NativeErrorConstructor.h&quot;
 115 #include &quot;NativeExecutable.h&quot;
 116 #include &quot;NativeStdFunctionCell.h&quot;
 117 #include &quot;Nodes.h&quot;
 118 #include &quot;ObjCCallbackFunction.h&quot;
 119 #include &quot;Parser.h&quot;
 120 #include &quot;ProfilerDatabase.h&quot;
 121 #include &quot;ProgramCodeBlock.h&quot;
 122 #include &quot;ProgramExecutable.h&quot;
 123 #include &quot;PromiseDeferredTimer.h&quot;
 124 #include &quot;PropertyMapHashTable.h&quot;
 125 #include &quot;ProxyRevoke.h&quot;
<a name="7" id="anc7"></a><span class="line-added"> 126 #include &quot;RandomizingFuzzerAgent.h&quot;</span>
 127 #include &quot;RegExpCache.h&quot;
 128 #include &quot;RegExpObject.h&quot;
 129 #include &quot;RegisterAtOffsetList.h&quot;
 130 #include &quot;RuntimeType.h&quot;
 131 #include &quot;SamplingProfiler.h&quot;
 132 #include &quot;ShadowChicken.h&quot;
 133 #include &quot;SimpleTypedArrayController.h&quot;
 134 #include &quot;SourceProviderCache.h&quot;
 135 #include &quot;StackVisitor.h&quot;
 136 #include &quot;StrictEvalActivation.h&quot;
 137 #include &quot;StrongInlines.h&quot;
 138 #include &quot;StructureInlines.h&quot;
 139 #include &quot;TestRunnerUtils.h&quot;
 140 #include &quot;ThunkGenerators.h&quot;
 141 #include &quot;TypeProfiler.h&quot;
 142 #include &quot;TypeProfilerLog.h&quot;
 143 #include &quot;UnlinkedCodeBlock.h&quot;
 144 #include &quot;VMEntryScope.h&quot;
 145 #include &quot;VMInlines.h&quot;
 146 #include &quot;VMInspector.h&quot;
 147 #include &quot;VariableEnvironment.h&quot;
 148 #include &quot;WasmWorklist.h&quot;
 149 #include &quot;Watchdog.h&quot;
 150 #include &quot;WeakGCMapInlines.h&quot;
 151 #include &quot;WebAssemblyFunction.h&quot;
<a name="8" id="anc8"></a><span class="line-added"> 152 #include &quot;WebAssemblyFunctionHeapCellType.h&quot;</span>
 153 #include &quot;WebAssemblyWrapperFunction.h&quot;
 154 #include &lt;wtf/ProcessID.h&gt;
 155 #include &lt;wtf/ReadWriteLock.h&gt;
 156 #include &lt;wtf/SimpleStats.h&gt;
 157 #include &lt;wtf/StringPrintStream.h&gt;
 158 #include &lt;wtf/Threading.h&gt;
<a name="9" id="anc9"></a><span class="line-modified"> 159 #include &lt;wtf/text/AtomStringTable.h&gt;</span>
 160 #include &lt;wtf/text/SymbolRegistry.h&gt;
 161 
 162 #if ENABLE(C_LOOP)
 163 #include &quot;CLoopStack.h&quot;
 164 #include &quot;CLoopStackInlines.h&quot;
 165 #endif
 166 
 167 #if ENABLE(DFG_JIT)
 168 #include &quot;ConservativeRoots.h&quot;
 169 #endif
 170 
 171 #if ENABLE(REGEXP_TRACING)
 172 #include &quot;RegExp.h&quot;
 173 #endif
 174 
 175 namespace JSC {
 176 
 177 #if ENABLE(JIT)
 178 #if !ASSERT_DISABLED
 179 bool VM::s_canUseJITIsSet = false;
 180 #endif
 181 bool VM::s_canUseJIT = false;
 182 #endif
 183 
 184 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 185 
 186 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 187 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 188 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 189 
 190 #if ENABLE(ASSEMBLER)
<a name="10" id="anc10"></a><span class="line-modified"> 191 static bool enableAssembler()</span>
 192 {
<a name="11" id="anc11"></a><span class="line-modified"> 193     if (!Options::useJIT())</span>
 194         return false;
 195 
<a name="12" id="anc12"></a><span class="line-modified"> 196     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);</span>
<span class="line-added"> 197     if (canUseJITString &amp;&amp; !atoi(canUseJITString))</span>
<span class="line-added"> 198         return false;</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200     ExecutableAllocator::initializeUnderlyingAllocator();</span>
<span class="line-added"> 201     if (!ExecutableAllocator::singleton().isValid()) {</span>
 202         if (Options::crashIfCantAllocateJITMemory())
 203             CRASH();
 204         return false;
 205     }
 206 
<a name="13" id="anc13"></a><span class="line-modified"> 207     return true;</span>

 208 }
 209 #endif // ENABLE(!ASSEMBLER)
 210 
 211 bool VM::canUseAssembler()
 212 {
 213 #if ENABLE(ASSEMBLER)
 214     static std::once_flag onceKey;
 215     static bool enabled = false;
 216     std::call_once(onceKey, [] {
<a name="14" id="anc14"></a><span class="line-modified"> 217         enabled = enableAssembler();</span>
 218     });
 219     return enabled;
 220 #else
 221     return false; // interpreter only
 222 #endif
 223 }
 224 
 225 void VM::computeCanUseJIT()
 226 {
 227 #if ENABLE(JIT)
 228 #if !ASSERT_DISABLED
 229     RELEASE_ASSERT(!s_canUseJITIsSet);
 230     s_canUseJITIsSet = true;
 231 #endif
 232     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 233 #endif
 234 }
 235 
<a name="15" id="anc15"></a>


















 236 inline unsigned VM::nextID()
 237 {
 238     for (;;) {
 239         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 240         unsigned newID = currentNumberOfIDs + 1;
 241         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 242             return newID;
 243     }
 244 }
 245 
<a name="16" id="anc16"></a><span class="line-added"> 246 static bool vmCreationShouldCrash = false;</span>
 247 
 248 VM::VM(VMType vmType, HeapType heapType)
 249     : m_id(nextID())
 250     , m_apiLock(adoptRef(new JSLock(this)))
 251 #if USE(CF)
 252     , m_runLoop(CFRunLoopGetCurrent())
 253 #endif // USE(CF)
<a name="17" id="anc17"></a><span class="line-modified"> 254     , heap(*this, heapType)</span>
<span class="line-modified"> 255     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())</span>
<span class="line-modified"> 256     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))</span>
<span class="line-modified"> 257     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))</span>
<span class="line-modified"> 258     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))</span>
<span class="line-modified"> 259     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))</span>
<span class="line-modified"> 260     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 261     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))</span>
<span class="line-modified"> 262     , stringHeapCellType(makeUnique&lt;JSStringHeapCellType&gt;())</span>
<span class="line-modified"> 263     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())</span>

 264 #if ENABLE(WEBASSEMBLY)
<a name="18" id="anc18"></a><span class="line-modified"> 265     , webAssemblyCodeBlockHeapCellType(makeUnique&lt;JSWebAssemblyCodeBlockHeapCellType&gt;())</span>
<span class="line-added"> 266     , webAssemblyFunctionHeapCellType(makeUnique&lt;WebAssemblyFunctionHeapCellType&gt;())</span>
 267 #endif
<a name="19" id="anc19"></a><span class="line-modified"> 268     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762</span>
<span class="line-modified"> 269     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946</span>
<span class="line-modified"> 270     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300</span>
<span class="line-modified"> 271     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79</span>
<span class="line-modified"> 272     , jsValueGigacageCellSpace(&quot;JSValue Gigacage JSCell&quot;, heap, cellHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x2f5b102b</span>
<span class="line-modified"> 273     , destructibleCellSpace(&quot;Destructible JSCell&quot;, heap, destructibleCellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbfff3d73</span>
<span class="line-modified"> 274     , stringSpace(&quot;JSString&quot;, heap, stringHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x90cf758f</span>
<span class="line-modified"> 275     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9</span>
<span class="line-modified"> 276     , eagerlySweptDestructibleObjectSpace(&quot;Eagerly Swept JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x6ebf28e2</span>
<span class="line-modified"> 277     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20</span>
<span class="line-modified"> 278     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72</span>
<span class="line-modified"> 279     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, destructibleObjectHeapCellType.get(), InternalFunction) // Hash:0xf845c464</span>
<span class="line-modified"> 280     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95</span>
<span class="line-modified"> 281     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12</span>
<span class="line-modified"> 282     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d</span>
<span class="line-modified"> 283     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca</span>
<span class="line-modified"> 284     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd</span>
 285     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 286     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
<a name="20" id="anc20"></a><span class="line-modified"> 287     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9</span>
<span class="line-modified"> 288     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3</span>
<span class="line-modified"> 289     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7</span>
<span class="line-modified"> 290     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9</span>
 291     , vmType(vmType)
 292     , clientData(0)
 293     , topEntryFrame(nullptr)
 294     , topCallFrame(CallFrame::noCaller())
<a name="21" id="anc21"></a><span class="line-modified"> 295     , promiseDeferredTimer(PromiseDeferredTimer::create(*this))</span>
<span class="line-modified"> 296     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)</span>
 297     , propertyNames(nullptr)
 298     , emptyList(new ArgList)
<a name="22" id="anc22"></a><span class="line-modified"> 299     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())</span>
 300     , customGetterSetterFunctionMap(*this)
 301     , stringCache(*this)
 302     , symbolImplToSymbolMap(*this)
 303     , structureCache(*this)
 304     , interpreter(0)
 305     , entryScope(0)
 306     , m_regExpCache(new RegExpCache(this))
 307     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 308 #if ENABLE(REGEXP_TRACING)
 309     , m_rtTraceList(new RTTraceList())
 310 #endif
 311 #if ENABLE(GC_VALIDATION)
 312     , m_initializingObjectClass(0)
 313 #endif
 314     , m_stackPointerAtVMEntry(0)
<a name="23" id="anc23"></a><span class="line-modified"> 315     , m_codeCache(makeUnique&lt;CodeCache&gt;())</span>
<span class="line-modified"> 316     , m_builtinExecutables(makeUnique&lt;BuiltinExecutables&gt;(*this))</span>
 317     , m_typeProfilerEnabledCount(0)
 318     , m_primitiveGigacageEnabled(IsWatched)
 319     , m_controlFlowProfilerEnabledCount(0)
 320 {
<a name="24" id="anc24"></a><span class="line-added"> 321     if (UNLIKELY(vmCreationShouldCrash))</span>
<span class="line-added"> 322         CRASH_WITH_INFO(0x4242424220202020, 0xbadbeef0badbeef, 0x1234123412341234, 0x1337133713371337);</span>
<span class="line-added"> 323 </span>
 324     interpreter = new Interpreter(*this);
 325     StackBounds stack = Thread::current().stack();
 326     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 327     setLastStackTop(stack.origin());
 328 
 329     JSRunLoopTimer::Manager::shared().registerVM(*this);
 330 
 331     // Need to be careful to keep everything consistent here
 332     JSLockHolder lock(this);
<a name="25" id="anc25"></a><span class="line-modified"> 333     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);</span>
 334     structureStructure.set(*this, Structure::createStructure(*this));
 335     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 336     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 337 
 338     smallStrings.initializeCommonStrings(*this);
 339 
<a name="26" id="anc26"></a><span class="line-modified"> 340     propertyNames = new CommonIdentifiers(*this);</span>
 341     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 342     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
 343     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 344     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 345     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 346     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 347     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 348     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 349     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 350     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 351 #if ENABLE(WEBASSEMBLY)
 352     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 353 #endif
 354     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 355     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 356     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 357     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));
 358     fixedArrayStructure.set(*this, JSFixedArray::createStructure(*this, 0, jsNull()));
 359 
 360     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 361     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 362     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 363 
 364     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 365     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 366     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 367     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 368     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 369     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
<a name="27" id="anc27"></a><span class="line-modified"> 370     arrayBufferNeuteringWatchpointStructure.set(*this, ArrayBufferNeuteringWatchpointSet::createStructure(*this));</span>
 371     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 372     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 373     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 374     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 375     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 376     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
<a name="28" id="anc28"></a>

 377     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 378     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
 379     promiseDeferredStructure.set(*this, JSPromiseDeferred::createStructure(*this, 0, jsNull()));
 380     internalPromiseDeferredStructure.set(*this, JSInternalPromiseDeferred::createStructure(*this, 0, jsNull()));
 381     nativeStdFunctionCellStructure.set(*this, NativeStdFunctionCell::createStructure(*this, 0, jsNull()));
 382     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 383     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 384     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 385     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 386     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 387     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
<a name="29" id="anc29"></a>

 388     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 389     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 390 
 391     // Eagerly initialize constant cells since the concurrent compiler can access them.
 392     if (canUseJIT()) {
 393         sentinelMapBucket();
 394         sentinelSetBucket();
 395     }
 396 
<a name="30" id="anc30"></a><span class="line-modified"> 397     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);</span>








 398 
 399 #if !ENABLE(C_LOOP)
 400     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 401 #endif
 402 
 403     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 404 
 405     heap.notifyIsSafeToCollect();
 406 
 407     LLInt::Data::performAssertions(*this);
 408 
 409     if (UNLIKELY(Options::useProfiler())) {
<a name="31" id="anc31"></a><span class="line-modified"> 410         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);</span>
 411 
 412         StringPrintStream pathOut;
 413         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 414         if (profilerPath)
 415             pathOut.print(profilerPath, &quot;/&quot;);
 416         pathOut.print(&quot;JSCProfile-&quot;, getCurrentProcessID(), &quot;-&quot;, m_perBytecodeProfiler-&gt;databaseID(), &quot;.json&quot;);
 417         m_perBytecodeProfiler-&gt;registerToSaveAtExit(pathOut.toCString().data());
 418     }
 419 
 420     callFrameForCatch = nullptr;
 421 
 422     // Initialize this last, as a free way of asserting that VM initialization itself
 423     // won&#39;t use this.
 424     m_typedArrayController = adoptRef(new SimpleTypedArrayController());
 425 
<a name="32" id="anc32"></a><span class="line-modified"> 426     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);</span>
 427 
 428     if (Options::useTypeProfiler())
 429         enableTypeProfiler();
 430     if (Options::useControlFlowProfiler())
 431         enableControlFlowProfiler();
 432 #if ENABLE(SAMPLING_PROFILER)
 433     if (Options::useSamplingProfiler()) {
 434         setShouldBuildPCToCodeOriginMapping();
 435         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 436         stopwatch-&gt;start();
 437         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 438         if (Options::samplingProfilerPath())
 439             m_samplingProfiler-&gt;registerForReportAtExit();
 440         m_samplingProfiler-&gt;start();
 441     }
 442 #endif // ENABLE(SAMPLING_PROFILER)
 443 
<a name="33" id="anc33"></a><span class="line-added"> 444     if (Options::useRandomizingFuzzerAgent())</span>
<span class="line-added"> 445         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 446     else if (Options::useDoublePredictionFuzzerAgent())</span>
<span class="line-added"> 447         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));</span>
<span class="line-added"> 448 </span>
 449     if (Options::alwaysGeneratePCToCodeOriginMap())
 450         setShouldBuildPCToCodeOriginMapping();
 451 
 452     if (Options::watchdog()) {
 453         Watchdog&amp; watchdog = ensureWatchdog();
 454         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 455     }
 456 
 457 #if ENABLE(JIT)
 458     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 459     if (canUseJIT()) {
<a name="34" id="anc34"></a><span class="line-added"> 460         jitStubs = makeUnique&lt;JITThunks&gt;();</span>
<span class="line-added"> 461 #if ENABLE(FTL_JIT)</span>
<span class="line-added"> 462         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();</span>
<span class="line-added"> 463 #endif // ENABLE(FTL_JIT)</span>
 464         getCTIInternalFunctionTrampolineFor(CodeForCall);
 465         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 466     }
 467 #endif
 468 
<a name="35" id="anc35"></a>


 469     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 470         ensureShadowChicken();
 471 
 472     VMInspector::instance().add(this);
 473 }
 474 
 475 static ReadWriteLock s_destructionLock;
 476 
 477 void waitForVMDestruction()
 478 {
 479     auto locker = holdLock(s_destructionLock.write());
 480 }
 481 
 482 VM::~VM()
 483 {
 484     auto destructionLocker = holdLock(s_destructionLock.read());
 485 
 486     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 487     promiseDeferredTimer-&gt;stopRunningTasks();
 488 #if ENABLE(WEBASSEMBLY)
 489     if (Wasm::Worklist* worklist = Wasm::existingWorklistOrNull())
 490         worklist-&gt;stopAllPlansForContext(wasmContext);
 491 #endif
 492     if (UNLIKELY(m_watchdog))
 493         m_watchdog-&gt;willDestroyVM(this);
 494     m_traps.willDestroyVM();
 495     VMInspector::instance().remove(this);
 496 
 497     // Never GC, ever again.
 498     heap.incrementDeferralDepth();
 499 
 500 #if ENABLE(SAMPLING_PROFILER)
 501     if (m_samplingProfiler) {
 502         m_samplingProfiler-&gt;reportDataToOptionFile();
 503         m_samplingProfiler-&gt;shutdown();
 504     }
 505 #endif // ENABLE(SAMPLING_PROFILER)
 506 
 507 #if ENABLE(JIT)
 508     if (JITWorklist* worklist = JITWorklist::existingGlobalWorklistOrNull())
 509         worklist-&gt;completeAllForVM(*this);
 510 #endif // ENABLE(JIT)
 511 
 512 #if ENABLE(DFG_JIT)
 513     // Make sure concurrent compilations are done, but don&#39;t install them, since there is
 514     // no point to doing so.
 515     for (unsigned i = DFG::numberOfWorklists(); i--;) {
 516         if (DFG::Worklist* worklist = DFG::existingWorklistForIndexOrNull(i)) {
 517             worklist-&gt;removeNonCompilingPlansForVM(*this);
 518             worklist-&gt;waitUntilAllPlansForVMAreReady(*this);
 519             worklist-&gt;removeAllReadyPlansForVM(*this);
 520         }
 521     }
 522 #endif // ENABLE(DFG_JIT)
 523 
 524     waitForAsynchronousDisassembly();
 525 
 526     // Clear this first to ensure that nobody tries to remove themselves from it.
 527     m_perBytecodeProfiler = nullptr;
 528 
 529     ASSERT(currentThreadIsHoldingAPILock());
 530     m_apiLock-&gt;willDestroyVM(this);
 531     smallStrings.setIsInitialized(false);
 532     heap.lastChanceToFinalize();
 533 
 534     JSRunLoopTimer::Manager::shared().unregisterVM(*this);
 535 
 536     delete interpreter;
 537 #ifndef NDEBUG
 538     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 539 #endif
 540 
 541     delete emptyList;
 542 
 543     delete propertyNames;
 544     if (vmType != Default)
<a name="36" id="anc36"></a><span class="line-modified"> 545         delete m_atomStringTable;</span>
 546 
 547     delete clientData;
 548     delete m_regExpCache;
 549 
 550 #if ENABLE(REGEXP_TRACING)
 551     delete m_rtTraceList;
 552 #endif
 553 
 554 #if ENABLE(DFG_JIT)
 555     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
 556         fastFree(m_scratchBuffers[i]);
 557 #endif
 558 }
 559 
 560 void VM::primitiveGigacageDisabledCallback(void* argument)
 561 {
 562     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 563 }
 564 
 565 void VM::primitiveGigacageDisabled()
 566 {
 567     if (m_apiLock-&gt;currentThreadIsHoldingLock()) {
 568         m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled&quot;);
 569         return;
 570     }
 571 
 572     // This is totally racy, and that&#39;s OK. The point is, it&#39;s up to the user to ensure that they pass the
 573     // uncaged buffer in a nicely synchronized manner.
 574     m_needToFirePrimitiveGigacageEnabled = true;
 575 }
 576 
 577 void VM::setLastStackTop(void* lastStackTop)
 578 {
 579     m_lastStackTop = lastStackTop;
 580 }
 581 
 582 Ref&lt;VM&gt; VM::createContextGroup(HeapType heapType)
 583 {
 584     return adoptRef(*new VM(APIContextGroup, heapType));
 585 }
 586 
 587 Ref&lt;VM&gt; VM::create(HeapType heapType)
 588 {
 589     return adoptRef(*new VM(Default, heapType));
 590 }
 591 
 592 bool VM::sharedInstanceExists()
 593 {
 594     return sharedInstanceInternal();
 595 }
 596 
 597 VM&amp; VM::sharedInstance()
 598 {
 599     GlobalJSLock globalLock;
 600     VM*&amp; instance = sharedInstanceInternal();
 601     if (!instance)
 602         instance = adoptRef(new VM(APIShared, SmallHeap)).leakRef();
 603     return *instance;
 604 }
 605 
 606 VM*&amp; VM::sharedInstanceInternal()
 607 {
 608     static VM* sharedInstance;
 609     return sharedInstance;
 610 }
 611 
 612 Watchdog&amp; VM::ensureWatchdog()
 613 {
 614     if (!m_watchdog)
 615         m_watchdog = adoptRef(new Watchdog(this));
 616     return *m_watchdog;
 617 }
 618 
 619 HeapProfiler&amp; VM::ensureHeapProfiler()
 620 {
 621     if (!m_heapProfiler)
<a name="37" id="anc37"></a><span class="line-modified"> 622         m_heapProfiler = makeUnique&lt;HeapProfiler&gt;(*this);</span>
 623     return *m_heapProfiler;
 624 }
 625 
 626 #if ENABLE(SAMPLING_PROFILER)
 627 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 628 {
 629     if (!m_samplingProfiler)
 630         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 631     return *m_samplingProfiler;
 632 }
 633 #endif // ENABLE(SAMPLING_PROFILER)
 634 
 635 #if ENABLE(JIT)
 636 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 637 {
 638     switch (intrinsic) {
 639     case CharCodeAtIntrinsic:
 640         return charCodeAtThunkGenerator;
 641     case CharAtIntrinsic:
 642         return charAtThunkGenerator;
 643     case Clz32Intrinsic:
 644         return clz32ThunkGenerator;
 645     case FromCharCodeIntrinsic:
 646         return fromCharCodeThunkGenerator;
 647     case SqrtIntrinsic:
 648         return sqrtThunkGenerator;
 649     case AbsIntrinsic:
 650         return absThunkGenerator;
 651     case FloorIntrinsic:
 652         return floorThunkGenerator;
 653     case CeilIntrinsic:
 654         return ceilThunkGenerator;
 655     case TruncIntrinsic:
 656         return truncThunkGenerator;
 657     case RoundIntrinsic:
 658         return roundThunkGenerator;
 659     case ExpIntrinsic:
 660         return expThunkGenerator;
 661     case LogIntrinsic:
 662         return logThunkGenerator;
 663     case IMulIntrinsic:
 664         return imulThunkGenerator;
 665     case RandomIntrinsic:
 666         return randomThunkGenerator;
 667     case BoundThisNoArgsFunctionCallIntrinsic:
 668         return boundThisNoArgsFunctionCallGenerator;
 669     default:
 670         return nullptr;
 671     }
 672 }
 673 
 674 #endif // ENABLE(JIT)
 675 
 676 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 677 {
 678     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 679 }
 680 
 681 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 682 {
 683     static NativeJITCode* result;
 684     static std::once_flag onceKey;
 685     std::call_once(onceKey, [&amp;] {
<a name="38" id="anc38"></a><span class="line-modified"> 686         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
 687     });
 688     return makeRef(*result);
 689 }
 690 
 691 static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
 692 {
 693     static NativeJITCode* result;
 694     static std::once_flag onceKey;
 695     std::call_once(onceKey, [&amp;] {
<a name="39" id="anc39"></a><span class="line-modified"> 696         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);</span>
 697     });
 698     return makeRef(*result);
 699 }
 700 
 701 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 702 {
 703 #if ENABLE(JIT)
 704     if (canUseJIT()) {
 705         return jitStubs-&gt;hostFunctionStub(
<a name="40" id="anc40"></a><span class="line-modified"> 706             *this, function, constructor,</span>
 707             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 708             intrinsic, signature, name);
 709     }
 710 #endif // ENABLE(JIT)
 711     UNUSED_PARAM(intrinsic);
 712     UNUSED_PARAM(signature);
 713     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 714 }
 715 
 716 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 717 {
 718 #if ENABLE(JIT)
 719     if (canUseJIT()) {
 720         if (kind == CodeForCall)
<a name="41" id="anc41"></a><span class="line-modified"> 721             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
<span class="line-modified"> 722         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();</span>
 723     }
 724 #endif
 725     if (kind == CodeForCall)
 726         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 727     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 728 }
 729 
 730 VM::ClientData::~ClientData()
 731 {
 732 }
 733 
 734 void VM::resetDateCache()
 735 {
<a name="42" id="anc42"></a><span class="line-added"> 736     utcTimeOffsetCache.reset();</span>
 737     localTimeOffsetCache.reset();
 738     cachedDateString = String();
 739     cachedDateStringValue = std::numeric_limits&lt;double&gt;::quiet_NaN();
 740     dateInstanceCache.reset();
 741 }
 742 
 743 void VM::whenIdle(Function&lt;void()&gt;&amp;&amp; callback)
 744 {
 745     if (!entryScope) {
 746         callback();
 747         return;
 748     }
 749 
 750     entryScope-&gt;addDidPopListener(WTFMove(callback));
 751 }
 752 
 753 void VM::deleteAllLinkedCode(DeleteAllCodeEffort effort)
 754 {
 755     whenIdle([=] () {
 756         heap.deleteAllCodeBlocks(effort);
 757     });
 758 }
 759 
 760 void VM::deleteAllCode(DeleteAllCodeEffort effort)
 761 {
 762     whenIdle([=] () {
 763         m_codeCache-&gt;clear();
 764         m_regExpCache-&gt;deleteAllCode();
 765         heap.deleteAllCodeBlocks(effort);
 766         heap.deleteAllUnlinkedCodeBlocks(effort);
 767         heap.reportAbandonedObjectGraph();
 768     });
 769 }
 770 
 771 void VM::shrinkFootprintWhenIdle()
 772 {
 773     whenIdle([=] () {
<a name="43" id="anc43"></a><span class="line-modified"> 774         sanitizeStackForVM(*this);</span>
 775         deleteAllCode(DeleteAllCodeIfNotCollecting);
 776         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 777         // FIXME: Consider stopping various automatic threads here.
 778         // https://bugs.webkit.org/show_bug.cgi?id=185447
 779         WTF::releaseFastMallocFreeMemory();
 780     });
 781 }
 782 
 783 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 784 {
 785     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 786     if (addResult.isNewEntry)
 787         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 788     return addResult.iterator-&gt;value.get();
 789 }
 790 
 791 void VM::clearSourceProviderCaches()
 792 {
 793     sourceProviderCacheMap.clear();
 794 }
 795 
<a name="44" id="anc44"></a><span class="line-modified"> 796 Exception* VM::throwException(ExecState* exec, Exception* exception)</span>
 797 {
 798     ASSERT(exec == topCallFrame || exec-&gt;isGlobalExec() || exec == exec-&gt;lexicalGlobalObject()-&gt;callFrameAtDebuggerEntry());
 799     CallFrame* throwOriginFrame = exec-&gt;isGlobalExec() ? exec : topJSCallFrame();
 800 
 801     if (Options::breakOnThrow()) {
 802         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 803         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 804         CRASH();
 805     }
 806 
 807     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, throwOriginFrame, exception);
 808 
 809     setException(exception);
 810 
 811 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 812     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 813     m_throwingThread = &amp;Thread::current();
 814 #endif
<a name="45" id="anc45"></a><span class="line-added"> 815     return exception;</span>
 816 }
 817 
<a name="46" id="anc46"></a><span class="line-modified"> 818 Exception* VM::throwException(ExecState* exec, JSValue thrownValue)</span>
 819 {
 820     VM&amp; vm = *this;
 821     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 822     if (!exception)
 823         exception = Exception::create(*this, thrownValue);
 824 
<a name="47" id="anc47"></a><span class="line-modified"> 825     return throwException(exec, exception);</span>

 826 }
 827 
<a name="48" id="anc48"></a><span class="line-modified"> 828 Exception* VM::throwException(ExecState* exec, JSObject* error)</span>
 829 {
<a name="49" id="anc49"></a><span class="line-modified"> 830     return throwException(exec, JSValue(error));</span>
 831 }
 832 
 833 void VM::setStackPointerAtVMEntry(void* sp)
 834 {
 835     m_stackPointerAtVMEntry = sp;
 836     updateStackLimits();
 837 }
 838 
 839 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 840 {
 841     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 842     m_currentSoftReservedZoneSize = softReservedZoneSize;
 843 #if ENABLE(C_LOOP)
 844     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 845 #endif
 846 
 847     updateStackLimits();
 848 
 849     return oldSoftReservedZoneSize;
 850 }
 851 
 852 #if OS(WINDOWS)
 853 // On Windows the reserved stack space consists of committed memory, a guard page, and uncommitted memory,
 854 // where the guard page is a barrier between committed and uncommitted memory.
 855 // When data from the guard page is read or written, the guard page is moved, and memory is committed.
 856 // This is how the system grows the stack.
 857 // When using the C stack on Windows we need to precommit the needed stack space.
 858 // Otherwise we might crash later if we access uncommitted stack memory.
 859 // This can happen if we allocate stack space larger than the page guard size (4K).
 860 // The system does not get the chance to move the guard page, and commit more memory,
 861 // and we crash if uncommitted memory is accessed.
 862 // The MSVC compiler fixes this by inserting a call to the _chkstk() function,
 863 // when needed, see http://support.microsoft.com/kb/100775.
 864 // By touching every page up to the stack limit with a dummy operation,
 865 // we force the system to move the guard page, and commit memory.
 866 
 867 static void preCommitStackMemory(void* stackLimit)
 868 {
 869     const int pageSize = 4096;
 870     for (volatile char* p = reinterpret_cast&lt;char*&gt;(&amp;stackLimit); p &gt; stackLimit; p -= pageSize) {
 871         char ch = *p;
 872         *p = ch;
 873     }
 874 }
 875 #endif
 876 
 877 inline void VM::updateStackLimits()
 878 {
 879 #if OS(WINDOWS)
 880     void* lastSoftStackLimit = m_softStackLimit;
 881 #endif
 882 
 883     const StackBounds&amp; stack = Thread::current().stack();
 884     size_t reservedZoneSize = Options::reservedZoneSize();
 885     // We should have already ensured that Options::reservedZoneSize() &gt;= minimumReserveZoneSize at
 886     // options initialization time, and the option value should not have been changed thereafter.
 887     // We don&#39;t have the ability to assert here that it hasn&#39;t changed, but we can at least assert
 888     // that the value is sane.
 889     RELEASE_ASSERT(reservedZoneSize &gt;= minimumReservedZoneSize);
 890 
 891     if (m_stackPointerAtVMEntry) {
 892         ASSERT(stack.isGrowingDownward());
 893         char* startOfStack = reinterpret_cast&lt;char*&gt;(m_stackPointerAtVMEntry);
 894         m_softStackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), m_currentSoftReservedZoneSize);
 895         m_stackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), reservedZoneSize);
 896     } else {
 897         m_softStackLimit = stack.recursionLimit(m_currentSoftReservedZoneSize);
 898         m_stackLimit = stack.recursionLimit(reservedZoneSize);
 899     }
 900 
 901 #if OS(WINDOWS)
 902     // We only need to precommit stack memory dictated by the VM::m_softStackLimit limit.
 903     // This is because VM::m_softStackLimit applies to stack usage by LLINT asm or JIT
 904     // generated code which can allocate stack space that the C++ compiler does not know
 905     // about. As such, we have to precommit that stack memory manually.
 906     //
 907     // In contrast, we do not need to worry about VM::m_stackLimit because that limit is
 908     // used exclusively by C++ code, and the C++ compiler will automatically commit the
 909     // needed stack pages.
 910     if (lastSoftStackLimit != m_softStackLimit)
 911         preCommitStackMemory(m_softStackLimit);
 912 #endif
 913 }
 914 
 915 #if ENABLE(DFG_JIT)
 916 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
 917 {
 918     auto lock = holdLock(m_scratchBufferLock);
 919     for (auto* scratchBuffer : m_scratchBuffers) {
 920         if (scratchBuffer-&gt;activeLength()) {
 921             void* bufferStart = scratchBuffer-&gt;dataBuffer();
 922             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
 923         }
 924     }
 925 }
 926 #endif
 927 
<a name="50" id="anc50"></a><span class="line-modified"> 928 void logSanitizeStack(VM&amp; vm)</span>
 929 {
<a name="51" id="anc51"></a><span class="line-modified"> 930     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {</span>
 931         int dummy;
 932         auto&amp; stackBounds = Thread::current().stack();
 933         dataLog(
<a name="52" id="anc52"></a><span class="line-modified"> 934             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),</span>
 935             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
<a name="53" id="anc53"></a><span class="line-modified"> 936             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,</span>
<span class="line-modified"> 937             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);</span>
 938     }
 939 }
 940 
 941 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 942 char* VM::acquireRegExpPatternContexBuffer()
 943 {
 944     m_regExpPatternContextLock.lock();
 945     ASSERT(m_regExpPatternContextLock.isLocked());
 946     if (!m_regExpPatternContexBuffer)
 947         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
 948     return m_regExpPatternContexBuffer.get();
 949 }
 950 
 951 void VM::releaseRegExpPatternContexBuffer()
 952 {
 953     ASSERT(m_regExpPatternContextLock.isLocked());
 954 
 955     m_regExpPatternContextLock.unlock();
 956 }
 957 #endif
 958 
 959 #if ENABLE(REGEXP_TRACING)
 960 void VM::addRegExpToTrace(RegExp* regExp)
 961 {
 962     gcProtect(regExp);
 963     m_rtTraceList-&gt;add(regExp);
 964 }
 965 
 966 void VM::dumpRegExpTrace()
 967 {
 968     // The first RegExp object is ignored.  It is create by the RegExpPrototype ctor and not used.
 969     RTTraceList::iterator iter = ++m_rtTraceList-&gt;begin();
 970 
 971     if (iter != m_rtTraceList-&gt;end()) {
 972         dataLogF(&quot;\nRegExp Tracing\n&quot;);
 973         dataLogF(&quot;Regular Expression                              8 Bit          16 Bit        match()    Matches    Average\n&quot;);
 974         dataLogF(&quot; &lt;Match only / Match&gt;                         JIT Addr      JIT Address       calls      found   String len\n&quot;);
 975         dataLogF(&quot;----------------------------------------+----------------+----------------+----------+----------+-----------\n&quot;);
 976 
 977         unsigned reCount = 0;
 978 
 979         for (; iter != m_rtTraceList-&gt;end(); ++iter, ++reCount) {
 980             (*iter)-&gt;printTraceData();
 981             gcUnprotect(*iter);
 982         }
 983 
 984         dataLogF(&quot;%d Regular Expressions\n&quot;, reCount);
 985     }
 986 
 987     m_rtTraceList-&gt;clear();
 988 }
 989 #else
 990 void VM::dumpRegExpTrace()
 991 {
 992 }
 993 #endif
 994 
 995 WatchpointSet* VM::ensureWatchpointSetForImpureProperty(const Identifier&amp; propertyName)
 996 {
 997     auto result = m_impurePropertyWatchpointSets.add(propertyName.string(), nullptr);
 998     if (result.isNewEntry)
 999         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
1000     return result.iterator-&gt;value.get();
1001 }
1002 
1003 void VM::registerWatchpointForImpureProperty(const Identifier&amp; propertyName, Watchpoint* watchpoint)
1004 {
1005     ensureWatchpointSetForImpureProperty(propertyName)-&gt;add(watchpoint);
1006 }
1007 
1008 void VM::addImpureProperty(const String&amp; propertyName)
1009 {
1010     if (RefPtr&lt;WatchpointSet&gt; watchpointSet = m_impurePropertyWatchpointSets.take(propertyName))
1011         watchpointSet-&gt;fireAll(*this, &quot;Impure property added&quot;);
1012 }
1013 
1014 template&lt;typename Func&gt;
1015 static bool enableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doEnableWork)
1016 {
1017     bool needsToRecompile = false;
1018     if (!counter) {
1019         doEnableWork();
1020         needsToRecompile = true;
1021     }
1022     counter++;
1023 
1024     return needsToRecompile;
1025 }
1026 
1027 template&lt;typename Func&gt;
1028 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
1029 {
1030     RELEASE_ASSERT(counter &gt; 0);
1031     bool needsToRecompile = false;
1032     counter--;
1033     if (!counter) {
1034         doDisableWork();
1035         needsToRecompile = true;
1036     }
1037 
1038     return needsToRecompile;
1039 }
1040 
1041 bool VM::enableTypeProfiler()
1042 {
1043     auto enableTypeProfiler = [this] () {
<a name="54" id="anc54"></a><span class="line-modified">1044         this-&gt;m_typeProfiler = makeUnique&lt;TypeProfiler&gt;();</span>
<span class="line-modified">1045         this-&gt;m_typeProfilerLog = makeUnique&lt;TypeProfilerLog&gt;(*this);</span>
1046     };
1047 
1048     return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
1049 }
1050 
1051 bool VM::disableTypeProfiler()
1052 {
1053     auto disableTypeProfiler = [this] () {
1054         this-&gt;m_typeProfiler.reset(nullptr);
1055         this-&gt;m_typeProfilerLog.reset(nullptr);
1056     };
1057 
1058     return disableProfilerWithRespectToCount(m_typeProfilerEnabledCount, disableTypeProfiler);
1059 }
1060 
1061 bool VM::enableControlFlowProfiler()
1062 {
1063     auto enableControlFlowProfiler = [this] () {
<a name="55" id="anc55"></a><span class="line-modified">1064         this-&gt;m_controlFlowProfiler = makeUnique&lt;ControlFlowProfiler&gt;();</span>
1065     };
1066 
1067     return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
1068 }
1069 
1070 bool VM::disableControlFlowProfiler()
1071 {
1072     auto disableControlFlowProfiler = [this] () {
1073         this-&gt;m_controlFlowProfiler.reset(nullptr);
1074     };
1075 
1076     return disableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, disableControlFlowProfiler);
1077 }
1078 
1079 void VM::dumpTypeProfilerData()
1080 {
1081     if (!typeProfiler())
1082         return;
1083 
1084     typeProfilerLog()-&gt;processLogEntries(*this, &quot;VM Dump Types&quot;_s);
1085     typeProfiler()-&gt;dumpTypeProfilerData(*this);
1086 }
1087 
1088 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1089 {
<a name="56" id="anc56"></a><span class="line-modified">1090     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));</span>
1091 }
1092 
<a name="57" id="anc57"></a><span class="line-modified">1093 void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)</span>
1094 {
<a name="58" id="anc58"></a><span class="line-modified">1095     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();</span>
<span class="line-modified">1096     if (!callback)</span>
<span class="line-modified">1097         return;</span>
<span class="line-modified">1098 </span>
<span class="line-added">1099     auto scope = DECLARE_CATCH_SCOPE(*this);</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     CallData callData;</span>
<span class="line-added">1102     CallType callType = getCallData(*this, callback, callData);</span>
<span class="line-added">1103     ASSERT(callType != CallType::None);</span>
<span class="line-added">1104 </span>
<span class="line-added">1105     MarkedArgumentBuffer args;</span>
<span class="line-added">1106     args.append(promise.get());</span>
<span class="line-added">1107     args.append(promise-&gt;result(*this));</span>
<span class="line-added">1108     call(promise-&gt;globalObject()-&gt;globalExec(), callback, callType, callData, jsNull(), args);</span>
<span class="line-added">1109     scope.clearException();</span>
<span class="line-added">1110 }</span>
<span class="line-added">1111 </span>
<span class="line-added">1112 void VM::didExhaustMicrotaskQueue()</span>
<span class="line-added">1113 {</span>
<span class="line-added">1114     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);</span>
<span class="line-added">1115     for (auto&amp; promise : unhandledRejections) {</span>
<span class="line-added">1116         if (promise-&gt;isHandled(*this))</span>
<span class="line-added">1117             continue;</span>
<span class="line-added">1118 </span>
<span class="line-added">1119         callPromiseRejectionCallback(promise);</span>
1120     }
1121 }
1122 
<a name="59" id="anc59"></a><span class="line-added">1123 void VM::promiseRejected(JSPromise* promise)</span>
<span class="line-added">1124 {</span>
<span class="line-added">1125     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);</span>
<span class="line-added">1126 }</span>
<span class="line-added">1127 </span>
<span class="line-added">1128 void VM::drainMicrotasks()</span>
<span class="line-added">1129 {</span>
<span class="line-added">1130     do {</span>
<span class="line-added">1131         while (!m_microtaskQueue.isEmpty()) {</span>
<span class="line-added">1132             m_microtaskQueue.takeFirst()-&gt;run();</span>
<span class="line-added">1133             if (m_onEachMicrotaskTick)</span>
<span class="line-added">1134                 m_onEachMicrotaskTick(*this);</span>
<span class="line-added">1135         }</span>
<span class="line-added">1136         didExhaustMicrotaskQueue();</span>
<span class="line-added">1137     } while (!m_microtaskQueue.isEmpty());</span>
<span class="line-added">1138     finalizeSynchronousJSExecution();</span>
<span class="line-added">1139 }</span>
<span class="line-added">1140 </span>
1141 void QueuedTask::run()
1142 {
1143     m_microtask-&gt;run(m_globalObject-&gt;globalExec());
1144 }
1145 
<a name="60" id="anc60"></a><span class="line-modified">1146 void sanitizeStackForVM(VM&amp; vm)</span>
1147 {
1148     logSanitizeStack(vm);
<a name="61" id="anc61"></a><span class="line-modified">1149     if (vm.topCallFrame) {</span>
1150         auto&amp; stackBounds = Thread::current().stack();
<a name="62" id="anc62"></a><span class="line-modified">1151         ASSERT(vm.currentThreadIsHoldingAPILock());</span>
<span class="line-modified">1152         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));</span>
1153     }
1154 #if ENABLE(C_LOOP)
<a name="63" id="anc63"></a><span class="line-modified">1155     vm.interpreter-&gt;cloopStack().sanitizeStack();</span>
1156 #else
<a name="64" id="anc64"></a><span class="line-modified">1157     sanitizeStackForVMImpl(&amp;vm);</span>
1158 #endif
1159 }
1160 
1161 size_t VM::committedStackByteCount()
1162 {
1163 #if !ENABLE(C_LOOP)
1164     // When using the C stack, we don&#39;t know how many stack pages are actually
1165     // committed. So, we use the current stack usage as an estimate.
1166     ASSERT(Thread::current().stack().isGrowingDownward());
1167     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1168     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1169     return high - current;
1170 #else
1171     return CLoopStack::committedByteCount();
1172 #endif
1173 }
1174 
1175 #if ENABLE(C_LOOP)
1176 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1177 {
1178     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1179 }
1180 
1181 bool VM::isSafeToRecurseSoftCLoop() const
1182 {
1183     return interpreter-&gt;cloopStack().isSafeToRecurse();
1184 }
<a name="65" id="anc65"></a><span class="line-added">1185 </span>
<span class="line-added">1186 void* VM::currentCLoopStackPointer() const</span>
<span class="line-added">1187 {</span>
<span class="line-added">1188     return interpreter-&gt;cloopStack().currentStackPointer();</span>
<span class="line-added">1189 }</span>
1190 #endif // ENABLE(C_LOOP)
1191 
1192 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1193 void VM::verifyExceptionCheckNeedIsSatisfied(unsigned recursionDepth, ExceptionEventLocation&amp; location)
1194 {
1195     if (!Options::validateExceptionChecks())
1196         return;
1197 
1198     if (UNLIKELY(m_needExceptionCheck)) {
1199         auto throwDepth = m_simulatedThrowPointRecursionDepth;
1200         auto&amp; throwLocation = m_simulatedThrowPointLocation;
1201 
1202         dataLog(
1203             &quot;ERROR: Unchecked JS exception:\n&quot;
1204             &quot;    This scope can throw a JS exception: &quot;, throwLocation, &quot;\n&quot;
1205             &quot;        (ExceptionScope::m_recursionDepth was &quot;, throwDepth, &quot;)\n&quot;
1206             &quot;    But the exception was unchecked as of this scope: &quot;, location, &quot;\n&quot;
1207             &quot;        (ExceptionScope::m_recursionDepth was &quot;, recursionDepth, &quot;)\n&quot;
1208             &quot;\n&quot;);
1209 
1210         StringPrintStream out;
1211         std::unique_ptr&lt;StackTrace&gt; currentTrace = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
1212 
1213         if (Options::dumpSimulatedThrows()) {
1214             out.println(&quot;The simulated exception was thrown at:&quot;);
1215             m_nativeStackTraceOfLastSimulatedThrow-&gt;dump(out, &quot;    &quot;);
1216             out.println();
1217         }
1218         out.println(&quot;Unchecked exception detected at:&quot;);
1219         currentTrace-&gt;dump(out, &quot;    &quot;);
1220         out.println();
1221 
1222         dataLog(out.toCString());
1223         RELEASE_ASSERT(!m_needExceptionCheck);
1224     }
1225 }
1226 #endif
1227 
1228 #if USE(CF)
1229 void VM::setRunLoop(CFRunLoopRef runLoop)
1230 {
1231     ASSERT(runLoop);
1232     m_runLoop = runLoop;
1233     JSRunLoopTimer::Manager::shared().didChangeRunLoop(*this, runLoop);
1234 }
1235 #endif // USE(CF)
1236 
1237 ScratchBuffer* VM::scratchBufferForSize(size_t size)
1238 {
1239     if (!size)
1240         return nullptr;
1241 
1242     auto locker = holdLock(m_scratchBufferLock);
1243 
1244     if (size &gt; m_sizeOfLastScratchBuffer) {
1245         // Protect against a N^2 memory usage pathology by ensuring
1246         // that at worst, we get a geometric series, meaning that the
1247         // total memory usage is somewhere around
1248         // max(scratch buffer size) * 4.
1249         m_sizeOfLastScratchBuffer = size * 2;
1250 
1251         ScratchBuffer* newBuffer = ScratchBuffer::create(m_sizeOfLastScratchBuffer);
1252         RELEASE_ASSERT(newBuffer);
1253         m_scratchBuffers.append(newBuffer);
1254     }
1255 
1256     ScratchBuffer* result = m_scratchBuffers.last();
1257     return result;
1258 }
1259 
1260 void VM::clearScratchBuffers()
1261 {
1262     auto lock = holdLock(m_scratchBufferLock);
1263     for (auto* scratchBuffer : m_scratchBuffers)
1264         scratchBuffer-&gt;setActiveLength(0);
1265 }
1266 
1267 void VM::ensureShadowChicken()
1268 {
1269     if (m_shadowChicken)
1270         return;
<a name="66" id="anc66"></a><span class="line-modified">1271     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();</span>
1272 }
1273 
1274 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1275     IsoSubspace* VM::name##Slow() \
1276     { \
1277         ASSERT(!m_##name); \
<a name="67" id="anc67"></a><span class="line-modified">1278         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1279         WTF::storeStoreFence(); \
1280         m_##name = WTFMove(space); \
1281         return m_##name.get(); \
1282     }
1283 
1284 
<a name="68" id="anc68"></a><span class="line-modified">1285 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41</span>
<span class="line-modified">1286 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, destructibleObjectHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc</span>
<span class="line-modified">1287 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000</span>
<span class="line-modified">1288 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, destructibleObjectHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a</span>
<span class="line-modified">1289 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, cellHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4</span>
<span class="line-modified">1290 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, destructibleObjectHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939</span>
<span class="line-modified">1291 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, destructibleObjectHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3</span>
<span class="line-modified">1292 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, destructibleObjectHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30</span>
<span class="line-added">1293 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f</span>
1294 #if JSC_OBJC_API_ENABLED
<a name="69" id="anc69"></a><span class="line-modified">1295 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, destructibleObjectHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8</span>
1296 #endif
1297 #if ENABLE(WEBASSEMBLY)
<a name="70" id="anc70"></a><span class="line-modified">1298 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd</span>
<span class="line-modified">1299 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db</span>
<span class="line-modified">1300 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01</span>
1301 #endif
1302 
1303 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1304 
1305 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1306     IsoSubspace* VM::name##Slow() \
1307     { \
1308         ASSERT(!m_##name); \
<a name="71" id="anc71"></a><span class="line-modified">1309         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \</span>
1310         WTF::storeStoreFence(); \
1311         m_##name = WTFMove(space); \
1312         return &amp;m_##name-&gt;space; \
1313     }
1314 
<a name="72" id="anc72"></a><span class="line-modified">1315 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d</span>
<span class="line-modified">1316 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c</span>

1317 
1318 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1319 
<a name="73" id="anc73"></a><span class="line-added">1320 Structure* VM::setIteratorStructureSlow()</span>
<span class="line-added">1321 {</span>
<span class="line-added">1322     ASSERT(!m_setIteratorStructure);</span>
<span class="line-added">1323     m_setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">1324     return m_setIteratorStructure.get();</span>
<span class="line-added">1325 }</span>
<span class="line-added">1326 </span>
<span class="line-added">1327 Structure* VM::mapIteratorStructureSlow()</span>
<span class="line-added">1328 {</span>
<span class="line-added">1329     ASSERT(!m_mapIteratorStructure);</span>
<span class="line-added">1330     m_mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));</span>
<span class="line-added">1331     return m_mapIteratorStructure.get();</span>
<span class="line-added">1332 }</span>
1333 
1334 JSCell* VM::sentinelSetBucketSlow()
1335 {
1336     ASSERT(!m_sentinelSetBucket);
1337     auto* sentinel = JSSet::BucketType::createSentinel(*this);
1338     m_sentinelSetBucket.set(*this, sentinel);
1339     return sentinel;
1340 }
1341 
1342 JSCell* VM::sentinelMapBucketSlow()
1343 {
1344     ASSERT(!m_sentinelMapBucket);
1345     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1346     m_sentinelMapBucket.set(*this, sentinel);
1347     return sentinel;
1348 }
1349 
<a name="74" id="anc74"></a><span class="line-added">1350 JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()</span>
<span class="line-added">1351 {</span>
<span class="line-added">1352     ASSERT(!m_emptyPropertyNameEnumerator);</span>
<span class="line-added">1353     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
<span class="line-added">1354     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));</span>
<span class="line-added">1355     m_emptyPropertyNameEnumerator.set(*this, enumerator);</span>
<span class="line-added">1356     return enumerator;</span>
<span class="line-added">1357 }</span>
<span class="line-added">1358 </span>
1359 JSGlobalObject* VM::vmEntryGlobalObject(const CallFrame* callFrame) const
1360 {
1361     if (callFrame &amp;&amp; callFrame-&gt;isGlobalExec()) {
1362         ASSERT(callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;isObject());
1363         ASSERT(callFrame == callFrame-&gt;lexicalGlobalObject()-&gt;globalExec());
1364         return callFrame-&gt;lexicalGlobalObject();
1365     }
1366     ASSERT(entryScope);
1367     return entryScope-&gt;globalObject();
1368 }
1369 
<a name="75" id="anc75"></a><span class="line-added">1370 void VM::setCrashOnVMCreation(bool shouldCrash)</span>
<span class="line-added">1371 {</span>
<span class="line-added">1372     vmCreationShouldCrash = shouldCrash;</span>
<span class="line-added">1373 }</span>
<span class="line-added">1374 </span>
1375 } // namespace JSC
<a name="76" id="anc76"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="76" type="hidden" />
</body>
</html>