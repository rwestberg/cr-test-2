<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Structure.h&quot;
  28 
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DumpContext.h&quot;
  32 #include &quot;JSCInlines.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSPropertyNameEnumerator.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;PropertyMapHashTable.h&quot;
  37 #include &quot;PropertyNameArray.h&quot;
  38 #include &quot;StructureChain.h&quot;
  39 #include &quot;StructureRareDataInlines.h&quot;
  40 #include &quot;WeakGCMapInlines.h&quot;
  41 #include &lt;wtf/CommaPrinter.h&gt;
  42 #include &lt;wtf/NeverDestroyed.h&gt;
  43 #include &lt;wtf/ProcessID.h&gt;
  44 #include &lt;wtf/RefPtr.h&gt;
  45 #include &lt;wtf/Threading.h&gt;
  46 
  47 #define DUMP_STRUCTURE_ID_STATISTICS 0
  48 
  49 namespace JSC {
  50 
  51 #if DUMP_STRUCTURE_ID_STATISTICS
  52 static HashSet&lt;Structure*&gt;&amp; liveStructureSet = *(new HashSet&lt;Structure*&gt;);
  53 #endif
  54 
  55 class SingleSlotTransitionWeakOwner final : public WeakHandleOwner {
  56     void finalize(Handle&lt;Unknown&gt;, void* context) override
  57     {
  58         StructureTransitionTable* table = reinterpret_cast&lt;StructureTransitionTable*&gt;(context);
  59         ASSERT(table-&gt;isUsingSingleSlot());
  60         WeakSet::deallocate(table-&gt;weakImpl());
  61         table-&gt;m_data = StructureTransitionTable::UsingSingleSlotFlag;
  62     }
  63 };
  64 
  65 static SingleSlotTransitionWeakOwner&amp; singleSlotTransitionWeakOwner()
  66 {
  67     static NeverDestroyed&lt;SingleSlotTransitionWeakOwner&gt; owner;
  68     return owner;
  69 }
  70 
  71 inline Structure* StructureTransitionTable::singleTransition() const
  72 {
  73     ASSERT(isUsingSingleSlot());
  74     if (WeakImpl* impl = this-&gt;weakImpl()) {
  75         if (impl-&gt;state() == WeakImpl::Live)
  76             return jsCast&lt;Structure*&gt;(impl-&gt;jsValue().asCell());
  77     }
  78     return nullptr;
  79 }
  80 
  81 inline void StructureTransitionTable::setSingleTransition(Structure* structure)
  82 {
  83     ASSERT(isUsingSingleSlot());
  84     if (WeakImpl* impl = this-&gt;weakImpl())
  85         WeakSet::deallocate(impl);
  86     WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
  87     m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  88 }
  89 
  90 bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes) const
  91 {
  92     if (isUsingSingleSlot()) {
  93         Structure* transition = singleTransition();
  94         return transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes;
  95     }
  96     return map()-&gt;get(std::make_pair(rep, attributes));
  97 }
  98 
  99 inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes) const
 100 {
 101     if (isUsingSingleSlot()) {
 102         Structure* transition = singleTransition();
 103         return (transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes) ? transition : 0;
 104     }
 105     return map()-&gt;get(std::make_pair(rep, attributes));
 106 }
 107 
 108 void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
 109 {
 110     if (isUsingSingleSlot()) {
 111         Structure* existingTransition = singleTransition();
 112 
 113         // This handles the first transition being added.
 114         if (!existingTransition) {
 115             setSingleTransition(structure);
 116             return;
 117         }
 118 
 119         // This handles the second transition being added
 120         // (or the first transition being despecified!)
 121         setMap(new TransitionMap(vm));
 122         add(vm, existingTransition);
 123     }
 124 
 125     // Add the structure to the map.
 126 
 127     // Newer versions of the STL have an std::make_pair function that takes rvalue references.
 128     // When either of the parameters are bitfields, the C++ compiler will try to bind them as lvalues, which is invalid. To work around this, use unary &quot;+&quot; to make the parameter an rvalue.
 129     // See https://bugs.webkit.org/show_bug.cgi?id=59261 for more details
 130     map()-&gt;set(std::make_pair(structure-&gt;m_nameInPrevious.get(), +structure-&gt;attributesInPrevious()), structure);
 131 }
 132 
 133 void Structure::dumpStatistics()
 134 {
 135 #if DUMP_STRUCTURE_ID_STATISTICS
 136     unsigned numberLeaf = 0;
 137     unsigned numberUsingSingleSlot = 0;
 138     unsigned numberSingletons = 0;
 139     unsigned numberWithPropertyMaps = 0;
 140     unsigned totalPropertyMapsSize = 0;
 141 
 142     HashSet&lt;Structure*&gt;::const_iterator end = liveStructureSet.end();
 143     for (HashSet&lt;Structure*&gt;::const_iterator it = liveStructureSet.begin(); it != end; ++it) {
 144         Structure* structure = *it;
 145 
 146         switch (structure-&gt;m_transitionTable.size()) {
 147             case 0:
 148                 ++numberLeaf;
 149                 if (!structure-&gt;previousID())
 150                     ++numberSingletons;
 151                 break;
 152 
 153             case 1:
 154                 ++numberUsingSingleSlot;
 155                 break;
 156         }
 157 
 158         if (PropertyTable* table = structure-&gt;propertyTableOrNull()) {
 159             ++numberWithPropertyMaps;
 160             totalPropertyMapsSize += table-&gt;sizeInMemory();
 161         }
 162     }
 163 
 164     dataLogF(&quot;Number of live Structures: %d\n&quot;, liveStructureSet.size());
 165     dataLogF(&quot;Number of Structures using the single item optimization for transition map: %d\n&quot;, numberUsingSingleSlot);
 166     dataLogF(&quot;Number of Structures that are leaf nodes: %d\n&quot;, numberLeaf);
 167     dataLogF(&quot;Number of Structures that singletons: %d\n&quot;, numberSingletons);
 168     dataLogF(&quot;Number of Structures with PropertyMaps: %d\n&quot;, numberWithPropertyMaps);
 169 
 170     dataLogF(&quot;Size of a single Structures: %d\n&quot;, static_cast&lt;unsigned&gt;(sizeof(Structure)));
 171     dataLogF(&quot;Size of sum of all property maps: %d\n&quot;, totalPropertyMapsSize);
 172     dataLogF(&quot;Size of average of all property maps: %f\n&quot;, static_cast&lt;double&gt;(totalPropertyMapsSize) / static_cast&lt;double&gt;(liveStructureSet.size()));
 173 #else
 174     dataLogF(&quot;Dumping Structure statistics is not enabled.\n&quot;);
 175 #endif
 176 }
 177 
 178 Structure::Structure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 179     : JSCell(vm, vm.structureStructure.get())
 180     , m_blob(vm.heap.structureIDTable().allocateID(this), indexingType, typeInfo)
 181     , m_outOfLineTypeFlags(typeInfo.outOfLineTypeFlags())
 182     , m_inlineCapacity(inlineCapacity)
 183     , m_bitField(0)
 184     , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
 185     , m_prototype(vm, this, prototype)
 186     , m_classInfo(classInfo)
 187     , m_transitionWatchpointSet(IsWatched)
 188     , m_offset(invalidOffset)
 189     , m_propertyHash(0)
 190 {
 191     setDictionaryKind(NoneDictionaryKind);
 192     setIsPinnedPropertyTable(false);
 193     setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 194     setHasCustomGetterSetterProperties(false);
 195     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 196     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 197     setIsQuickPropertyAccessAllowedForEnumeration(true);
 198     setAttributesInPrevious(0);
 199     setDidPreventExtensions(false);
 200     setDidTransition(false);
 201     setStaticPropertiesReified(false);
 202     setTransitionWatchpointIsLikelyToBeFired(false);
 203     setHasBeenDictionary(false);
 204     setIsAddingPropertyForTransition(false);
 205 
 206     ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
 207     ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
 208     ASSERT(!hasRareData());
 209     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 210     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 211     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 212 }
 213 
 214 const ClassInfo Structure::s_info = { &quot;Structure&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(Structure) };
 215 
 216 Structure::Structure(VM&amp; vm)
 217     : JSCell(CreatingEarlyCell)
 218     , m_inlineCapacity(0)
 219     , m_bitField(0)
 220     , m_prototype(vm, this, jsNull())
 221     , m_classInfo(info())
 222     , m_transitionWatchpointSet(IsWatched)
 223     , m_offset(invalidOffset)
 224     , m_propertyHash(0)
 225 {
 226     setDictionaryKind(NoneDictionaryKind);
 227     setIsPinnedPropertyTable(false);
 228     setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 229     setHasCustomGetterSetterProperties(false);
 230     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 231     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 232     setIsQuickPropertyAccessAllowedForEnumeration(true);
 233     setAttributesInPrevious(0);
 234     setDidPreventExtensions(false);
 235     setDidTransition(false);
 236     setStaticPropertiesReified(false);
 237     setTransitionWatchpointIsLikelyToBeFired(false);
 238     setHasBeenDictionary(false);
 239     setIsAddingPropertyForTransition(false);
 240 
 241     TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
 242     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
 243     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 244 
 245     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 246     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 247     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 248 }
 249 
 250 Structure::Structure(VM&amp; vm, Structure* previous, DeferredStructureTransitionWatchpointFire* deferred)
 251     : JSCell(vm, vm.structureStructure.get())
 252     , m_inlineCapacity(previous-&gt;m_inlineCapacity)
 253     , m_bitField(0)
 254     , m_prototype(vm, this, previous-&gt;m_prototype.get())
 255     , m_classInfo(previous-&gt;m_classInfo)
 256     , m_transitionWatchpointSet(IsWatched)
 257     , m_offset(invalidOffset)
 258     , m_propertyHash(previous-&gt;m_propertyHash)
 259 {
 260     setDictionaryKind(previous-&gt;dictionaryKind());
 261     setIsPinnedPropertyTable(false);
 262     setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
 263     setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
 264     setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
 265     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
 266     setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
 267     setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
 268     setAttributesInPrevious(0);
 269     setDidPreventExtensions(previous-&gt;didPreventExtensions());
 270     setDidTransition(true);
 271     setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
 272     setHasBeenDictionary(previous-&gt;hasBeenDictionary());
 273     setIsAddingPropertyForTransition(false);
 274 
 275     TypeInfo typeInfo = previous-&gt;typeInfo();
 276     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
 277     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 278 
 279     ASSERT(!previous-&gt;typeInfo().structureIsImmortal());
 280     setPreviousID(vm, previous);
 281 
 282     previous-&gt;didTransitionFromThisStructure(deferred);
 283 
 284     // Copy this bit now, in case previous was being watched.
 285     setTransitionWatchpointIsLikelyToBeFired(previous-&gt;transitionWatchpointIsLikelyToBeFired());
 286 
 287     if (previous-&gt;m_globalObject)
 288         m_globalObject.set(vm, this, previous-&gt;m_globalObject.get());
 289     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 290     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 291     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 292 }
 293 
 294 Structure::~Structure()
 295 {
 296     if (typeInfo().structureIsImmortal())
 297         return;
 298     Heap::heap(this)-&gt;structureIDTable().deallocateID(this, m_blob.structureID());
 299 }
 300 
 301 void Structure::destroy(JSCell* cell)
 302 {
 303     static_cast&lt;Structure*&gt;(cell)-&gt;Structure::~Structure();
 304 }
 305 
 306 Structure* Structure::create(PolyProtoTag, VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 307 {
 308     Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 309 
 310     unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
 311     result-&gt;addPropertyWithoutTransition(
 312         vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
 313         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {
 314             RELEASE_ASSERT(Structure::outOfLineCapacity(newLastOffset) == oldOutOfLineCapacity);
 315             RELEASE_ASSERT(offset == knownPolyProtoOffset);
 316             RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
 317             result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
 318             result-&gt;setLastOffset(newLastOffset);
 319         });
 320 
 321     return result;
 322 }
 323 
 324 bool Structure::isValidPrototype(JSValue prototype)
 325 {
 326     return prototype.isNull() || (prototype.isObject() &amp;&amp; prototype.getObject()-&gt;mayBePrototype());
 327 }
 328 
 329 void Structure::findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp; structure, PropertyTable*&amp; table)
 330 {
 331     ASSERT(structures.isEmpty());
 332     table = 0;
 333 
 334     for (structure = this; structure; structure = structure-&gt;previousID()) {
 335         structure-&gt;m_lock.lock();
 336 
 337         table = structure-&gt;propertyTableOrNull();
 338         if (table) {
 339             // Leave the structure locked, so that the caller can do things to it atomically
 340             // before it loses its property table.
 341             return;
 342         }
 343 
 344         structures.append(structure);
 345         structure-&gt;m_lock.unlock();
 346     }
 347 
 348     ASSERT(!structure);
 349     ASSERT(!table);
 350 }
 351 
 352 PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
 353 {
 354     ASSERT(structure(vm)-&gt;classInfo() == info());
 355     ASSERT(!isAddingPropertyForTransition());
 356 
 357     DeferGC deferGC(vm.heap);
 358 
 359     Vector&lt;Structure*, 8&gt; structures;
 360     Structure* structure;
 361     PropertyTable* table;
 362 
 363     findStructuresAndMapForMaterialization(structures, structure, table);
 364 
 365     unsigned capacity = numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);
 366     if (table) {
 367         table = table-&gt;copy(vm, capacity);
 368         structure-&gt;m_lock.unlock();
 369     } else
 370         table = PropertyTable::create(vm, capacity);
 371 
 372     // Must hold the lock on this structure, since we will be modifying this structure&#39;s
 373     // property map. We don&#39;t want getConcurrently() to see the property map in a half-baked
 374     // state.
 375     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 376     if (setPropertyTable)
 377         this-&gt;setPropertyTable(vm, table);
 378 
 379     for (size_t i = structures.size(); i--;) {
 380         structure = structures[i];
 381         if (!structure-&gt;m_nameInPrevious)
 382             continue;
 383         PropertyMapEntry entry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious());
 384         table-&gt;add(entry, m_offset, PropertyTable::PropertyOffsetMustNotChange);
 385     }
 386 
 387     checkOffsetConsistency(
 388         table,
 389         [&amp;] () {
 390             dataLog(&quot;Detected in materializePropertyTable.\n&quot;);
 391             dataLog(&quot;Found structure = &quot;, RawPointer(structure), &quot;\n&quot;);
 392             dataLog(&quot;structures = &quot;);
 393             CommaPrinter comma;
 394             for (Structure* structure : structures)
 395                 dataLog(comma, RawPointer(structure));
 396             dataLog(&quot;\n&quot;);
 397         });
 398 
 399     return table;
 400 }
 401 
 402 Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 403 {
 404     ASSERT(!structure-&gt;isDictionary());
 405     ASSERT(structure-&gt;isObject());
 406 
 407     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes)) {
 408         validateOffset(existingTransition-&gt;m_offset, existingTransition-&gt;inlineCapacity());
 409         offset = existingTransition-&gt;m_offset;
 410         return existingTransition;
 411     }
 412 
 413     return 0;
 414 }
 415 
 416 Structure* Structure::addPropertyTransitionToExistingStructure(Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 417 {
 418     ASSERT(!isCompilationThread());
 419     return addPropertyTransitionToExistingStructureImpl(structure, propertyName.uid(), attributes, offset);
 420 }
 421 
 422 Structure* Structure::addPropertyTransitionToExistingStructureConcurrently(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 423 {
 424     ConcurrentJSLocker locker(structure-&gt;m_lock);
 425     return addPropertyTransitionToExistingStructureImpl(structure, uid, attributes, offset);
 426 }
 427 
 428 bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
 429 {
 430     ASSERT(base-&gt;structure(vm) == this);
 431 
 432     if (this-&gt;mayInterceptIndexedAccesses())
 433         return true;
 434 
 435     JSValue prototype = this-&gt;storedPrototype(base);
 436     if (!prototype.isObject())
 437         return false;
 438     JSObject* object = asObject(prototype);
 439 
 440     while (true) {
 441         Structure&amp; structure = *object-&gt;structure(vm);
 442         if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())
 443             return true;
 444         prototype = structure.storedPrototype(object);
 445         if (!prototype.isObject())
 446             return false;
 447         object = asObject(prototype);
 448     }
 449 
 450     RELEASE_ASSERT_NOT_REACHED();
 451     return false;
 452 }
 453 
 454 Structure* Structure::addPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 455 {
 456     Structure* newStructure = addPropertyTransitionToExistingStructure(
 457         structure, propertyName, attributes, offset);
 458     if (newStructure)
 459         return newStructure;
 460 
 461     return addNewPropertyTransition(
 462         vm, structure, propertyName, attributes, offset, PutPropertySlot::UnknownContext);
 463 }
 464 
 465 Structure* Structure::addNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset, PutPropertySlot::Context context, DeferredStructureTransitionWatchpointFire* deferred)
 466 {
 467     ASSERT(!structure-&gt;isDictionary());
 468     ASSERT(structure-&gt;isObject());
 469     ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, offset));
 470 
 471     int maxTransitionLength;
 472     if (context == PutPropertySlot::PutById)
 473         maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
 474     else
 475         maxTransitionLength = s_maxTransitionLength;
 476     if (structure-&gt;transitionCount() &gt; maxTransitionLength) {
 477         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
 478         Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
 479         ASSERT(structure != transition);
 480         offset = transition-&gt;add(vm, propertyName, attributes);
 481         return transition;
 482     }
 483 
 484     Structure* transition = create(vm, structure, deferred);
 485 
 486     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
 487 
 488     // While we are adding the property, rematerializing the property table is super weird: we already
 489     // have a m_nameInPrevious and attributesInPrevious but the m_offset is still wrong. If the
 490     // materialization algorithm runs, it&#39;ll build a property table that already has the property but
 491     // at a bogus offset. Rather than try to teach the materialization code how to create a table under
 492     // those conditions, we just tell the GC not to blow the table away during this period of time.
 493     // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
 494     // which case the GC will not blow the table away, or we do it after the GC already ran in which
 495     // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
 496     // isAddingPropertyForTransition before we set it to true, and then blow the table away after.
 497     {
 498         ConcurrentJSLocker locker(transition-&gt;m_lock);
 499         transition-&gt;setIsAddingPropertyForTransition(true);
 500     }
 501 
 502     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
 503     transition-&gt;m_nameInPrevious = propertyName.uid();
 504     transition-&gt;setAttributesInPrevious(attributes);
 505     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
 506     transition-&gt;m_offset = structure-&gt;m_offset;
 507 
 508     offset = transition-&gt;add(vm, propertyName, attributes);
 509 
 510     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
 511     // table away if it wants. We can now rebuild it fine.
 512     WTF::storeStoreFence();
 513     transition-&gt;setIsAddingPropertyForTransition(false);
 514 
 515     checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());
 516     {
 517         ConcurrentJSLocker locker(structure-&gt;m_lock);
 518         DeferGC deferGC(vm.heap);
 519         structure-&gt;m_transitionTable.add(vm, transition);
 520     }
 521     transition-&gt;checkOffsetConsistency();
 522     structure-&gt;checkOffsetConsistency();
 523     return transition;
 524 }
 525 
 526 Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset)
 527 {
 528     // NOTE: There are some good reasons why this goes directly to uncacheable dictionary rather than
 529     // caching the removal. We can fix all of these things, but we must remember to do so, if we ever try
 530     // to optimize this case.
 531     //
 532     // - Cached transitions usually steal the property table, and assume that this is possible because they
 533     //   can just rebuild the table by looking at past transitions. That code assumes that the table only
 534     //   grew and never shrank. To support removals, we&#39;d have to change the property table materialization
 535     //   code to handle deletions. Also, we have logic to get the list of properties on a structure that
 536     //   lacks a property table by just looking back through the set of transitions since the last
 537     //   structure that had a pinned table. That logic would also have to be changed to handle cached
 538     //   removals.
 539     //
 540     ASSERT(!structure-&gt;isUncacheableDictionary());
 541 
 542     Structure* transition = toUncacheableDictionaryTransition(vm, structure);
 543 
 544     offset = transition-&gt;remove(propertyName);
 545 
 546     transition-&gt;checkOffsetConsistency();
 547     return transition;
 548 }
 549 
 550 Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
 551 {
 552     ASSERT(isValidPrototype(prototype));
 553 
 554     DeferGC deferGC(vm.heap);
 555     Structure* transition = create(vm, structure, &amp;deferred);
 556 
 557     transition-&gt;m_prototype.set(vm, transition, prototype);
 558 
 559     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 560     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 561     transition-&gt;m_offset = structure-&gt;m_offset;
 562 
 563     transition-&gt;checkOffsetConsistency();
 564     return transition;
 565 }
 566 
 567 Structure* Structure::attributeChangeTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes)
 568 {
 569     if (!structure-&gt;isUncacheableDictionary()) {
 570         Structure* transition = create(vm, structure);
 571 
 572         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 573         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 574         transition-&gt;m_offset = structure-&gt;m_offset;
 575 
 576         structure = transition;
 577     }
 578 
 579     PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
 580     ASSERT(entry);
 581     entry-&gt;attributes = attributes;
 582 
 583     structure-&gt;checkOffsetConsistency();
 584     return structure;
 585 }
 586 
 587 Structure* Structure::toDictionaryTransition(VM&amp; vm, Structure* structure, DictionaryKind kind, DeferredStructureTransitionWatchpointFire* deferred)
 588 {
 589     ASSERT(!structure-&gt;isUncacheableDictionary());
 590     DeferGC deferGC(vm.heap);
 591 
 592     Structure* transition = create(vm, structure, deferred);
 593 
 594     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 595     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 596     transition-&gt;m_offset = structure-&gt;m_offset;
 597     transition-&gt;setDictionaryKind(kind);
 598     transition-&gt;setHasBeenDictionary(true);
 599 
 600     transition-&gt;checkOffsetConsistency();
 601     return transition;
 602 }
 603 
 604 Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
 605 {
 606     return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
 607 }
 608 
 609 Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure)
 610 {
 611     return toDictionaryTransition(vm, structure, UncachedDictionaryKind);
 612 }
 613 
 614 Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
 615 {
 616     return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
 617 }
 618 
 619 Structure* Structure::freezeTransition(VM&amp; vm, Structure* structure)
 620 {
 621     return nonPropertyTransition(vm, structure, NonPropertyTransition::Freeze);
 622 }
 623 
 624 Structure* Structure::preventExtensionsTransition(VM&amp; vm, Structure* structure)
 625 {
 626     return nonPropertyTransition(vm, structure, NonPropertyTransition::PreventExtensions);
 627 }
 628 
 629 PropertyTable* Structure::takePropertyTableOrCloneIfPinned(VM&amp; vm)
 630 {
 631     // This must always return a property table. It can&#39;t return null.
 632     PropertyTable* result = propertyTableOrNull();
 633     if (result) {
 634         if (isPinnedPropertyTable())
 635             return result-&gt;copy(vm, result-&gt;size() + 1);
 636         ConcurrentJSLocker locker(m_lock);
 637         setPropertyTable(vm, nullptr);
 638         return result;
 639     }
 640     bool setPropertyTable = false;
 641     return materializePropertyTable(vm, setPropertyTable);
 642 }
 643 
 644 Structure* Structure::nonPropertyTransitionSlow(VM&amp; vm, Structure* structure, NonPropertyTransition transitionKind)
 645 {
 646     unsigned attributes = toAttributes(transitionKind);
 647     IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
 648 
 649     Structure* existingTransition;
 650     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes))) {
 651         ASSERT(existingTransition-&gt;attributesInPrevious() == attributes);
 652         ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
 653         return existingTransition;
 654     }
 655 
 656     DeferGC deferGC(vm.heap);
 657 
 658     Structure* transition = create(vm, structure);
 659     transition-&gt;setAttributesInPrevious(attributes);
 660     transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
 661 
 662     if (preventsExtensions(transitionKind))
 663         transition-&gt;setDidPreventExtensions(true);
 664 
 665     if (setsDontDeleteOnAllProperties(transitionKind)
 666         || setsReadOnlyOnNonAccessorProperties(transitionKind)) {
 667         // We pin the property table on transitions that do wholesale editing of the property
 668         // table, since our logic for walking the property transition chain to rematerialize the
 669         // table doesn&#39;t know how to take into account such wholesale edits.
 670 
 671         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 672         transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
 673         transition-&gt;m_offset = structure-&gt;m_offset;
 674 
 675         table = transition-&gt;propertyTableOrNull();
 676         RELEASE_ASSERT(table);
 677         for (auto&amp; entry : *table) {
 678             if (setsDontDeleteOnAllProperties(transitionKind))
 679                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete);
 680             if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
 681                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
 682         }
 683     } else {
 684         transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
 685         transition-&gt;m_offset = structure-&gt;m_offset;
 686         checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());
 687     }
 688 
 689     if (setsReadOnlyOnNonAccessorProperties(transitionKind)
 690         &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
 691         transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
 692 
 693     if (structure-&gt;isDictionary()) {
 694         PropertyTable* table = transition-&gt;ensurePropertyTable(vm);
 695         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 696     } else {
 697         auto locker = holdLock(structure-&gt;m_lock);
 698         structure-&gt;m_transitionTable.add(vm, transition);
 699     }
 700 
 701     transition-&gt;checkOffsetConsistency();
 702     return transition;
 703 }
 704 
 705 // In future we may want to cache this property.
 706 bool Structure::isSealed(VM&amp; vm)
 707 {
 708     if (isStructureExtensible())
 709         return false;
 710 
 711     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 712     if (!table)
 713         return true;
 714 
 715     PropertyTable::iterator end = table-&gt;end();
 716     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 717         if ((iter-&gt;attributes &amp; PropertyAttribute::DontDelete) != static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete))
 718             return false;
 719     }
 720     return true;
 721 }
 722 
 723 // In future we may want to cache this property.
 724 bool Structure::isFrozen(VM&amp; vm)
 725 {
 726     if (isStructureExtensible())
 727         return false;
 728 
 729     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 730     if (!table)
 731         return true;
 732 
 733     PropertyTable::iterator end = table-&gt;end();
 734     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 735         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontDelete))
 736             return false;
 737         if (!(iter-&gt;attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor)))
 738             return false;
 739     }
 740     return true;
 741 }
 742 
 743 Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
 744 {
 745     checkOffsetConsistency();
 746     ASSERT(isDictionary());
 747 
 748     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 749 
 750     object-&gt;setStructureIDDirectly(nuke(id()));
 751     WTF::storeStoreFence();
 752 
 753     size_t beforeOutOfLineCapacity = this-&gt;outOfLineCapacity();
 754     if (isUncacheableDictionary()) {
 755         PropertyTable* table = propertyTableOrNull();
 756         ASSERT(table);
 757 
 758         size_t propertyCount = table-&gt;size();
 759 
 760         // Holds our values compacted by insertion order.
 761         Vector&lt;JSValue&gt; values(propertyCount);
 762 
 763         // Copies out our values from their hashed locations, compacting property table offsets as we go.
 764         unsigned i = 0;
 765         PropertyTable::iterator end = table-&gt;end();
 766         m_offset = invalidOffset;
 767         for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
 768             values[i] = object-&gt;getDirect(iter-&gt;offset);
 769             m_offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);
 770         }
 771 
 772         // Copies in our values to their compacted locations.
 773         for (unsigned i = 0; i &lt; propertyCount; i++)
 774             object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
 775 
 776         table-&gt;clearDeletedOffsets();
 777 
 778         // We need to zero our unused property space; otherwise the GC might see a
 779         // stale pointer when we add properties in the future.
 780         memset(
 781             object-&gt;inlineStorageUnsafe() + inlineSize(),
 782             0,
 783             (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
 784 
 785         Butterfly* butterfly = object-&gt;butterfly();
 786         size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
 787         void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
 788         void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
 789         memset(startOfPropertyStorageSlots, 0, (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));
 790         checkOffsetConsistency();
 791     }
 792 
 793     setDictionaryKind(NoneDictionaryKind);
 794     setHasBeenFlattenedBefore(true);
 795 
 796     size_t afterOutOfLineCapacity = this-&gt;outOfLineCapacity();
 797 
 798     if (object-&gt;butterfly() &amp;&amp; beforeOutOfLineCapacity != afterOutOfLineCapacity) {
 799         ASSERT(beforeOutOfLineCapacity &gt; afterOutOfLineCapacity);
 800         // If the object had a Butterfly but after flattening/compacting we no longer have need of it,
 801         // we need to zero it out because the collector depends on the Structure to know the size for copying.
 802         if (!afterOutOfLineCapacity &amp;&amp; !this-&gt;hasIndexingHeader(object))
 803             object-&gt;setButterfly(vm, nullptr);
 804         // If the object was down-sized to the point where the base of the Butterfly is no longer within the
 805         // first CopiedBlock::blockSize bytes, we&#39;ll get the wrong answer if we try to mask the base back to
 806         // the CopiedBlock header. To prevent this case we need to memmove the Butterfly down.
 807         else
 808             object-&gt;shiftButterflyAfterFlattening(locker, vm, this, afterOutOfLineCapacity);
 809     }
 810 
 811     WTF::storeStoreFence();
 812     object-&gt;setStructureIDDirectly(id());
 813 
 814     // We need to do a writebarrier here because the GC thread might be scanning the butterfly while
 815     // we are shuffling properties around. See: https://bugs.webkit.org/show_bug.cgi?id=166989
 816     vm.heap.writeBarrier(object);
 817 
 818     return this;
 819 }
 820 
 821 void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 822 {
 823     setIsPinnedPropertyTable(true);
 824     setPropertyTable(vm, table);
 825     clearPreviousID();
 826     m_nameInPrevious = nullptr;
 827 }
 828 
 829 void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 830 {
 831     setIsPinnedPropertyTable(true);
 832     setPropertyTable(vm, table);
 833     m_nameInPrevious = nullptr;
 834 }
 835 
 836 void Structure::allocateRareData(VM&amp; vm)
 837 {
 838     ASSERT(!hasRareData());
 839     StructureRareData* rareData = StructureRareData::create(vm, previousID());
 840     WTF::storeStoreFence();
 841     m_previousOrRareData.set(vm, this, rareData);
 842     ASSERT(hasRareData());
 843 }
 844 
 845 WatchpointSet* Structure::ensurePropertyReplacementWatchpointSet(VM&amp; vm, PropertyOffset offset)
 846 {
 847     ASSERT(!isUncacheableDictionary());
 848 
 849     // In some places it&#39;s convenient to call this with an invalid offset. So, we do the check here.
 850     if (!isValidOffset(offset))
 851         return nullptr;
 852 
 853     if (!hasRareData())
 854         allocateRareData(vm);
 855     ConcurrentJSLocker locker(m_lock);
 856     StructureRareData* rareData = this-&gt;rareData();
 857     if (!rareData-&gt;m_replacementWatchpointSets) {
 858         rareData-&gt;m_replacementWatchpointSets =
 859             makeUnique&lt;StructureRareData::PropertyWatchpointMap&gt;();
 860         WTF::storeStoreFence();
 861     }
 862     auto result = rareData-&gt;m_replacementWatchpointSets-&gt;add(offset, nullptr);
 863     if (result.isNewEntry)
 864         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
 865     return result.iterator-&gt;value.get();
 866 }
 867 
 868 void Structure::startWatchingPropertyForReplacements(VM&amp; vm, PropertyName propertyName)
 869 {
 870     ASSERT(!isUncacheableDictionary());
 871 
 872     startWatchingPropertyForReplacements(vm, get(vm, propertyName));
 873 }
 874 
 875 void Structure::didCachePropertyReplacement(VM&amp; vm, PropertyOffset offset)
 876 {
 877     RELEASE_ASSERT(isValidOffset(offset));
 878     ensurePropertyReplacementWatchpointSet(vm, offset)-&gt;fireAll(vm, &quot;Did cache property replacement&quot;);
 879 }
 880 
 881 void Structure::startWatchingInternalProperties(VM&amp; vm)
 882 {
 883     if (!isUncacheableDictionary()) {
 884         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;toString);
 885         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;valueOf);
 886     }
 887     setDidWatchInternalProperties(true);
 888 }
 889 
 890 #if DUMP_PROPERTYMAP_STATS
 891 
 892 PropertyMapHashTableStats* propertyMapHashTableStats = 0;
 893 
 894 struct PropertyMapStatisticsExitLogger {
 895     PropertyMapStatisticsExitLogger();
 896     ~PropertyMapStatisticsExitLogger();
 897 };
 898 
 899 DEFINE_GLOBAL_FOR_LOGGING(PropertyMapStatisticsExitLogger, logger, );
 900 
 901 PropertyMapStatisticsExitLogger::PropertyMapStatisticsExitLogger()
 902 {
 903     propertyMapHashTableStats = adoptPtr(new PropertyMapHashTableStats()).leakPtr();
 904 }
 905 
 906 PropertyMapStatisticsExitLogger::~PropertyMapStatisticsExitLogger()
 907 {
 908     unsigned finds = propertyMapHashTableStats-&gt;numFinds;
 909     unsigned collisions = propertyMapHashTableStats-&gt;numCollisions;
 910     dataLogF(&quot;\nJSC::PropertyMap statistics for process %d\n\n&quot;, getCurrentProcessID());
 911     dataLogF(&quot;%d finds\n&quot;, finds);
 912     dataLogF(&quot;%d collisions (%.1f%%)\n&quot;, collisions, 100.0 * collisions / finds);
 913     dataLogF(&quot;%d lookups\n&quot;, propertyMapHashTableStats-&gt;numLookups.load());
 914     dataLogF(&quot;%d lookup probings\n&quot;, propertyMapHashTableStats-&gt;numLookupProbing.load());
 915     dataLogF(&quot;%d adds\n&quot;, propertyMapHashTableStats-&gt;numAdds.load());
 916     dataLogF(&quot;%d removes\n&quot;, propertyMapHashTableStats-&gt;numRemoves.load());
 917     dataLogF(&quot;%d rehashes\n&quot;, propertyMapHashTableStats-&gt;numRehashes.load());
 918     dataLogF(&quot;%d reinserts\n&quot;, propertyMapHashTableStats-&gt;numReinserts.load());
 919 }
 920 
 921 #endif
 922 
 923 PropertyTable* Structure::copyPropertyTableForPinning(VM&amp; vm)
 924 {
 925     if (PropertyTable* table = propertyTableOrNull())
 926         return PropertyTable::clone(vm, *table);
 927     bool setPropertyTable = false;
 928     return materializePropertyTable(vm, setPropertyTable);
 929 }
 930 
 931 PropertyOffset Structure::getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes)
 932 {
 933     PropertyOffset result = invalidOffset;
 934 
 935     forEachPropertyConcurrently(
 936         [&amp;] (const PropertyMapEntry&amp; candidate) -&gt; bool {
 937             if (candidate.key != uid)
 938                 return true;
 939 
 940             result = candidate.offset;
 941             attributes = candidate.attributes;
 942             return false;
 943         });
 944 
 945     return result;
 946 }
 947 
 948 Vector&lt;PropertyMapEntry&gt; Structure::getPropertiesConcurrently()
 949 {
 950     Vector&lt;PropertyMapEntry&gt; result;
 951 
 952     forEachPropertyConcurrently(
 953         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
 954             result.append(entry);
 955             return true;
 956         });
 957 
 958     return result;
 959 }
 960 
 961 PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
 962 {
 963     return add&lt;ShouldPin::No&gt;(
 964         vm, propertyName, attributes,
 965         [this] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newLastOffset) {
 966             setLastOffset(newLastOffset);
 967         });
 968 }
 969 
 970 PropertyOffset Structure::remove(PropertyName propertyName)
 971 {
 972     return remove(propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });
 973 }
 974 
 975 void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
 976 {
 977     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 978     if (!table)
 979         return;
 980 
 981     bool knownUnique = propertyNames.canAddKnownUniqueForStructure();
 982 
 983     PropertyTable::iterator end = table-&gt;end();
 984     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 985         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !(iter-&gt;attributes &amp; PropertyAttribute::DontEnum));
 986         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !iter-&gt;key-&gt;isSymbol());
 987         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties()) {
 988             if (iter-&gt;key-&gt;isSymbol() &amp;&amp; !propertyNames.includeSymbolProperties())
 989                 continue;
 990             if (knownUnique)
 991                 propertyNames.addUnchecked(iter-&gt;key);
 992             else
 993                 propertyNames.add(iter-&gt;key);
 994         }
 995     }
 996 }
 997 
 998 void StructureFireDetail::dump(PrintStream&amp; out) const
 999 {
1000     out.print(&quot;Structure transition from &quot;, *m_structure);
1001 }
1002 
1003 DeferredStructureTransitionWatchpointFire::DeferredStructureTransitionWatchpointFire(VM&amp; vm, Structure* structure)
1004     : DeferredWatchpointFire(vm)
1005     , m_structure(structure)
1006 {
1007 }
1008 
1009 DeferredStructureTransitionWatchpointFire::~DeferredStructureTransitionWatchpointFire()
1010 {
1011     fireAll();
1012 }
1013 
1014 void DeferredStructureTransitionWatchpointFire::dump(PrintStream&amp; out) const
1015 {
1016     out.print(&quot;Structure transition from &quot;, *m_structure);
1017 }
1018 
1019 void Structure::didTransitionFromThisStructure(DeferredStructureTransitionWatchpointFire* deferred) const
1020 {
1021     // If the structure is being watched, and this is the kind of structure that the DFG would
1022     // like to watch, then make sure to note for all future versions of this structure that it&#39;s
1023     // unwise to watch it.
1024     if (m_transitionWatchpointSet.isBeingWatched())
1025         const_cast&lt;Structure*&gt;(this)-&gt;setTransitionWatchpointIsLikelyToBeFired(true);
1026 
1027     if (deferred) {
1028         ASSERT(deferred-&gt;structure() == this);
1029         m_transitionWatchpointSet.fireAll(vm(), deferred);
1030     } else
1031         m_transitionWatchpointSet.fireAll(vm(), StructureFireDetail(this));
1032 }
1033 
1034 void Structure::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1035 {
1036     Structure* thisObject = jsCast&lt;Structure*&gt;(cell);
1037     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1038 
1039     Base::visitChildren(thisObject, visitor);
1040 
1041     ConcurrentJSLocker locker(thisObject-&gt;m_lock);
1042 
1043     visitor.append(thisObject-&gt;m_globalObject);
1044     if (!thisObject-&gt;isObject())
1045         thisObject-&gt;m_cachedPrototypeChain.clear();
1046     else {
1047         visitor.append(thisObject-&gt;m_prototype);
1048         visitor.append(thisObject-&gt;m_cachedPrototypeChain);
1049     }
1050     visitor.append(thisObject-&gt;m_previousOrRareData);
1051 
1052     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;isAddingPropertyForTransition()) {
1053         // NOTE: This can interleave in pin(), in which case it may see a null property table.
1054         // That&#39;s fine, because then the barrier will fire and we will scan this again.
1055         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1056     } else if (visitor.isAnalyzingHeap())
1057         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1058     else if (thisObject-&gt;m_propertyTableUnsafe)
1059         thisObject-&gt;m_propertyTableUnsafe.clear();
1060 }
1061 
1062 bool Structure::isCheapDuringGC(VM&amp; vm)
1063 {
1064     // FIXME: We could make this even safer by returning false if this structure&#39;s property table
1065     // has any large property names.
1066     // https://bugs.webkit.org/show_bug.cgi?id=157334
1067 
1068     return (!m_globalObject || vm.heap.isMarked(m_globalObject.get()))
1069         &amp;&amp; (hasPolyProto() || !storedPrototypeObject() || vm.heap.isMarked(storedPrototypeObject()));
1070 }
1071 
1072 bool Structure::markIfCheap(SlotVisitor&amp; visitor)
1073 {
1074     VM&amp; vm = visitor.vm();
1075     if (!isCheapDuringGC(vm))
1076         return vm.heap.isMarked(this);
1077 
1078     visitor.appendUnbarriered(this);
1079     return true;
1080 }
1081 
1082 Ref&lt;StructureShape&gt; Structure::toStructureShape(JSValue value, bool&amp; sawPolyProtoStructure)
1083 {
1084     Ref&lt;StructureShape&gt; baseShape = StructureShape::create();
1085     RefPtr&lt;StructureShape&gt; curShape = baseShape.ptr();
1086     Structure* curStructure = this;
1087     JSValue curValue = value;
1088     sawPolyProtoStructure = false;
1089     while (curStructure) {
1090         sawPolyProtoStructure |= curStructure-&gt;hasPolyProto();
1091         curStructure-&gt;forEachPropertyConcurrently(
1092             [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1093                 if (!PropertyName(entry.key).isPrivateName())
1094                     curShape-&gt;addProperty(*entry.key);
1095                 return true;
1096             });
1097 
1098         if (JSObject* curObject = curValue.getObject())
1099             curShape-&gt;setConstructorName(JSObject::calculatedClassName(curObject));
1100         else
1101             curShape-&gt;setConstructorName(curStructure-&gt;classInfo()-&gt;className);
1102 
1103         if (curStructure-&gt;isDictionary())
1104             curShape-&gt;enterDictionaryMode();
1105 
1106         curShape-&gt;markAsFinal();
1107 
1108         if (!curValue.isObject())
1109             break;
1110 
1111         JSObject* object = asObject(curValue);
1112         JSObject* prototypeObject = object-&gt;structure()-&gt;storedPrototypeObject(object);
1113         if (!prototypeObject)
1114             break;
1115 
1116         auto newShape = StructureShape::create();
1117         curShape-&gt;setProto(newShape.copyRef());
1118         curShape = WTFMove(newShape);
1119         curValue = prototypeObject;
1120         curStructure = prototypeObject-&gt;structure();
1121     }
1122 
1123     return baseShape;
1124 }
1125 
1126 void Structure::dump(PrintStream&amp; out) const
1127 {
1128     out.print(RawPointer(this), &quot;:[&quot;, classInfo()-&gt;className, &quot;, {&quot;);
1129 
1130     CommaPrinter comma;
1131 
1132     const_cast&lt;Structure*&gt;(this)-&gt;forEachPropertyConcurrently(
1133         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1134             out.print(comma, entry.key, &quot;:&quot;, static_cast&lt;int&gt;(entry.offset));
1135             return true;
1136         });
1137 
1138     out.print(&quot;}, &quot;, IndexingTypeDump(indexingMode()));
1139 
1140     if (hasPolyProto())
1141         out.print(&quot;, PolyProto offset:&quot;, knownPolyProtoOffset);
1142     else if (m_prototype.get().isCell())
1143         out.print(&quot;, Proto:&quot;, RawPointer(m_prototype.get().asCell()));
1144 
1145     switch (dictionaryKind()) {
1146     case NoneDictionaryKind:
1147         if (hasBeenDictionary())
1148             out.print(&quot;, Has been dictionary&quot;);
1149         break;
1150     case CachedDictionaryKind:
1151         out.print(&quot;, Dictionary&quot;);
1152         break;
1153     case UncachedDictionaryKind:
1154         out.print(&quot;, UncacheableDictionary&quot;);
1155         break;
1156     }
1157 
1158     if (transitionWatchpointSetIsStillValid())
1159         out.print(&quot;, Leaf&quot;);
1160     else if (transitionWatchpointIsLikelyToBeFired())
1161         out.print(&quot;, Shady leaf&quot;);
1162 
1163     out.print(&quot;]&quot;);
1164 }
1165 
1166 void Structure::dumpInContext(PrintStream&amp; out, DumpContext* context) const
1167 {
1168     if (context)
1169         context-&gt;structures.dumpBrief(this, out);
1170     else
1171         dump(out);
1172 }
1173 
1174 void Structure::dumpBrief(PrintStream&amp; out, const CString&amp; string) const
1175 {
1176     out.print(&quot;%&quot;, string, &quot;:&quot;, classInfo()-&gt;className);
1177 }
1178 
1179 void Structure::dumpContextHeader(PrintStream&amp; out)
1180 {
1181     out.print(&quot;Structures:&quot;);
1182 }
1183 
1184 bool ClassInfo::hasStaticSetterOrReadonlyProperties() const
1185 {
1186     for (const ClassInfo* ci = this; ci; ci = ci-&gt;parentClass) {
1187         if (const HashTable* table = ci-&gt;staticPropHashTable) {
1188             if (table-&gt;hasSetterOrReadonlyProperties)
1189                 return true;
1190         }
1191     }
1192     return false;
1193 }
1194 
1195 void Structure::setCachedPropertyNameEnumerator(VM&amp; vm, JSPropertyNameEnumerator* enumerator)
1196 {
1197     ASSERT(!isDictionary());
1198     if (!hasRareData())
1199         allocateRareData(vm);
1200     rareData()-&gt;setCachedPropertyNameEnumerator(vm, enumerator);
1201 }
1202 
1203 JSPropertyNameEnumerator* Structure::cachedPropertyNameEnumerator() const
1204 {
1205     if (!hasRareData())
1206         return nullptr;
1207     return rareData()-&gt;cachedPropertyNameEnumerator();
1208 }
1209 
1210 bool Structure::canCachePropertyNameEnumerator() const
1211 {
1212     if (!this-&gt;canCacheOwnKeys())
1213         return false;
1214 
1215     StructureChain* structureChain = m_cachedPrototypeChain.get();
1216     ASSERT(structureChain);
1217     WriteBarrier&lt;Structure&gt;* structure = structureChain-&gt;head();
1218     while (true) {
1219         if (!structure-&gt;get())
1220             return true;
1221         if (!structure-&gt;get()-&gt;canCacheOwnKeys())
1222             return false;
1223         structure++;
1224     }
1225 
1226     ASSERT_NOT_REACHED();
1227     return true;
1228 }
1229 
1230 bool Structure::canAccessPropertiesQuicklyForEnumeration() const
1231 {
1232     if (!isQuickPropertyAccessAllowedForEnumeration())
1233         return false;
1234     if (hasGetterSetterProperties())
1235         return false;
1236     if (isUncacheableDictionary())
1237         return false;
1238     return true;
1239 }
1240 
1241 } // namespace JSC
    </pre>
  </body>
</html>