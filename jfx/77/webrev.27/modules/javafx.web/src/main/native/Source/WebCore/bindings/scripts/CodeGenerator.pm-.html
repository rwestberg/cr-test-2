<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # WebKit IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # Copyright (C) 2006 Samuel Weinig &lt;sam.weinig@gmail.com&gt;
   6 # Copyright (C) 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  10 #
  11 # This library is free software; you can redistribute it and/or
  12 # modify it under the terms of the GNU Library General Public
  13 # License as published by the Free Software Foundation; either
  14 # version 2 of the License, or (at your option) any later version.
  15 #
  16 # This library is distributed in the hope that it will be useful,
  17 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  18 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19 # Library General Public License for more details.
  20 #
  21 # You should have received a copy of the GNU Library General Public License
  22 # along with this library; see the file COPYING.LIB.  If not, write to
  23 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24 # Boston, MA 02110-1301, USA.
  25 #
  26 
  27 package CodeGenerator;
  28 
  29 use strict;
  30 
  31 use File::Basename;
  32 use File::Find;
  33 use Carp qw&lt;longmess&gt;;
  34 use Data::Dumper;
  35 
  36 my $useDocument = &quot;&quot;;
  37 my $useGenerator = &quot;&quot;;
  38 my $useOutputDir = &quot;&quot;;
  39 my $useOutputHeadersDir = &quot;&quot;;
  40 my $useDirectories = &quot;&quot;;
  41 my $preprocessor;
  42 my $idlAttributes;
  43 my $writeDependencies = 0;
  44 my $defines = &quot;&quot;;
  45 my $targetIdlFilePath = &quot;&quot;;
  46 
  47 my $codeGenerator = 0;
  48 
  49 my $verbose = 0;
  50 
  51 my %integerTypeHash = (
  52     &quot;byte&quot; =&gt; 1,
  53     &quot;long long&quot; =&gt; 1,
  54     &quot;long&quot; =&gt; 1,
  55     &quot;octet&quot; =&gt; 1,
  56     &quot;short&quot; =&gt; 1,
  57     &quot;unsigned long long&quot; =&gt; 1,
  58     &quot;unsigned long&quot; =&gt; 1,
  59     &quot;unsigned short&quot; =&gt; 1,
  60 );
  61 
  62 my %floatingPointTypeHash = (
  63     &quot;float&quot; =&gt; 1,
  64     &quot;unrestricted float&quot; =&gt; 1,
  65     &quot;double&quot; =&gt; 1,
  66     &quot;unrestricted double&quot; =&gt; 1,
  67 );
  68 
  69 my %stringTypeHash = (
  70     &quot;ByteString&quot; =&gt; 1,
  71     &quot;DOMString&quot; =&gt; 1,
  72     &quot;USVString&quot; =&gt; 1,
  73 );
  74 
  75 my %bufferSourceTypes = (
  76     &quot;ArrayBuffer&quot; =&gt; 1,
  77     &quot;ArrayBufferView&quot; =&gt; 1,
  78     &quot;DataView&quot; =&gt; 1,
  79     &quot;Float32Array&quot; =&gt; 1,
  80     &quot;Float64Array&quot; =&gt; 1,
  81     &quot;Int16Array&quot; =&gt; 1,
  82     &quot;Int32Array&quot; =&gt; 1,
  83     &quot;Int8Array&quot; =&gt; 1,
  84     &quot;Uint16Array&quot; =&gt; 1,
  85     &quot;Uint32Array&quot; =&gt; 1,
  86     &quot;Uint8Array&quot; =&gt; 1,
  87     &quot;Uint8ClampedArray&quot; =&gt; 1,
  88 );
  89 
  90 my %primitiveTypeHash = ( 
  91     &quot;boolean&quot; =&gt; 1, 
  92     &quot;void&quot; =&gt; 1,
  93     &quot;Date&quot; =&gt; 1
  94 );
  95 
  96 my %dictionaryTypeImplementationNameOverrides = ();
  97 my %enumTypeImplementationNameOverrides = ();
  98 
  99 my %svgAttributesInHTMLHash = (
 100     &quot;class&quot; =&gt; 1,
 101     &quot;id&quot; =&gt; 1,
 102     &quot;onabort&quot; =&gt; 1,
 103     &quot;onclick&quot; =&gt; 1,
 104     &quot;onerror&quot; =&gt; 1,
 105     &quot;onload&quot; =&gt; 1,
 106     &quot;onmousedown&quot; =&gt; 1,
 107     &quot;onmouseenter&quot; =&gt; 1,
 108     &quot;onmouseleave&quot; =&gt; 1,
 109     &quot;onmousemove&quot; =&gt; 1,
 110     &quot;onmouseout&quot; =&gt; 1,
 111     &quot;onmouseover&quot; =&gt; 1,
 112     &quot;onmouseup&quot; =&gt; 1,
 113     &quot;onresize&quot; =&gt; 1,
 114     &quot;onscroll&quot; =&gt; 1,
 115     &quot;onunload&quot; =&gt; 1,
 116 );
 117 
 118 # Cache of IDL file pathnames.
 119 my $idlFiles;
 120 my $cachedInterfaces = {};
 121 my $cachedExternalDictionaries = {};
 122 my $cachedExternalEnumerations = {};
 123 my $cachedTypes = {};
 124 
 125 sub assert
 126 {
 127     my $message = shift;
 128     
 129     my $mess = longmess();
 130     print Dumper($mess);
 131 
 132     die $message;
 133 }
 134 
 135 # Default constructor
 136 sub new
 137 {
 138     my $object = shift;
 139     my $reference = { };
 140 
 141     $useDirectories = shift;
 142     $useGenerator = shift;
 143     $useOutputDir = shift;
 144     $useOutputHeadersDir = shift;
 145     $preprocessor = shift;
 146     $writeDependencies = shift;
 147     $verbose = shift;
 148     $targetIdlFilePath = shift;
 149     $idlAttributes = shift;
 150 
 151     bless($reference, $object);
 152     return $reference;
 153 }
 154 
 155 sub ProcessDocument
 156 {
 157     my $object = shift;
 158     $useDocument = shift;
 159     $defines = shift;
 160 
 161     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 162     require $ifaceName . &quot;.pm&quot;;
 163 
 164     foreach my $dictionary (@{$useDocument-&gt;dictionaries}) {
 165         if ($dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 166             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $dictionary-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 167         }
 168     }
 169 
 170     foreach my $enumeration (@{$useDocument-&gt;enumerations}) {
 171         if ($enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 172             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $enumeration-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 173         }
 174     }
 175 
 176     # Dynamically load external code generation perl module
 177     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose, $targetIdlFilePath);
 178     unless (defined($codeGenerator)) {
 179         my $interfaces = $useDocument-&gt;interfaces;
 180         foreach my $interface (@$interfaces) {
 181             print &quot;Skipping $useGenerator code generation for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;.\n&quot; if $verbose;
 182         }
 183         return;
 184     }
 185 
 186     my $interfaces = $useDocument-&gt;interfaces;
 187     if (@$interfaces) {
 188         die &quot;Multiple interfaces per document are not supported&quot; if @$interfaces &gt; 1;
 189 
 190         my $interface = @$interfaces[0];
 191         print &quot;Generating $useGenerator bindings code for IDL interface \&quot;&quot; . $interface-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 192         $codeGenerator-&gt;GenerateInterface($interface, $defines, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 193         $codeGenerator-&gt;WriteData($interface, $useOutputDir, $useOutputHeadersDir);
 194         return;
 195     }
 196 
 197     my $callbackFunctions = $useDocument-&gt;callbackFunctions;
 198     if (@$callbackFunctions) {
 199         die &quot;Multiple standalone callback functions per document are not supported&quot; if @$callbackFunctions &gt; 1;
 200 
 201         my $callbackFunction = @$callbackFunctions[0];
 202         print &quot;Generating $useGenerator bindings code for IDL callback function \&quot;&quot; . $callbackFunction-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 203         $codeGenerator-&gt;GenerateCallbackFunction($callbackFunction, $useDocument-&gt;enumerations, $useDocument-&gt;dictionaries);
 204         $codeGenerator-&gt;WriteData($callbackFunction, $useOutputDir, $useOutputHeadersDir);
 205         return;
 206     }
 207 
 208     my $dictionaries = $useDocument-&gt;dictionaries;
 209     if (@$dictionaries) {
 210         my $dictionary;
 211         my $otherDictionaries;
 212         if (@$dictionaries == 1) {
 213             $dictionary = @$dictionaries[0];
 214         } else {
 215             my $primaryDictionaryName = fileparse($targetIdlFilePath, &quot;.idl&quot;);
 216             for my $candidate (@$dictionaries) {
 217                 if ($candidate-&gt;type-&gt;name eq $primaryDictionaryName) {
 218                     $dictionary = $candidate;
 219                 } else {
 220                     push @$otherDictionaries, $candidate;
 221                 }
 222             }
 223             die &quot;Multiple dictionaries per document are only supported if one matches the filename&quot; unless $dictionary;
 224         }
 225 
 226         print &quot;Generating $useGenerator bindings code for IDL dictionary \&quot;&quot; . $dictionary-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 227         $codeGenerator-&gt;GenerateDictionary($dictionary, $useDocument-&gt;enumerations, $otherDictionaries);
 228         $codeGenerator-&gt;WriteData($dictionary, $useOutputDir, $useOutputHeadersDir);
 229         return;
 230     }
 231     
 232     my $enumerations = $useDocument-&gt;enumerations;
 233     if (@$enumerations) {
 234         die &quot;Multiple standalone enumerations per document are not supported&quot; if @$enumerations &gt; 1;
 235 
 236         my $enumeration = @$enumerations[0];
 237         print &quot;Generating $useGenerator bindings code for IDL enumeration \&quot;&quot; . $enumeration-&gt;type-&gt;name . &quot;\&quot;...\n&quot; if $verbose;
 238         $codeGenerator-&gt;GenerateEnumeration($enumeration);
 239         $codeGenerator-&gt;WriteData($enumeration, $useOutputDir, $useOutputHeadersDir);
 240         return;
 241     }
 242 
 243     die &quot;Processing document &quot; . $useDocument-&gt;fileName . &quot; did not generate anything&quot;
 244 }
 245 
 246 sub FileNamePrefix
 247 {
 248     my $object = shift;
 249 
 250     my $ifaceName = &quot;CodeGenerator&quot; . $useGenerator;
 251     require $ifaceName . &quot;.pm&quot;;
 252 
 253     # Dynamically load external code generation perl module
 254     $codeGenerator = $ifaceName-&gt;new($object, $writeDependencies, $verbose);
 255     return $codeGenerator-&gt;FileNamePrefix();
 256 }
 257 
 258 sub UpdateFile
 259 {
 260     my $object = shift;
 261     my $fileName = shift;
 262     my $contents = shift;
 263 
 264     # FIXME: We should only write content if it is different from what is in the file.
 265     # But that would mean running more often the binding generator, see https://bugs.webkit.org/show_bug.cgi?id=131756
 266     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
 267     print FH $contents;
 268     close FH;
 269 }
 270 
 271 sub ForAllParents
 272 {
 273     my $object = shift;
 274     my $interface = shift;
 275     my $beforeRecursion = shift;
 276     my $afterRecursion = shift;
 277 
 278     my $recurse;
 279     $recurse = sub {
 280         my $outerInterface = shift;
 281         my $currentInterface = shift;
 282 
 283         if  ($currentInterface-&gt;parentType) {
 284             my $interfaceName = $currentInterface-&gt;parentType-&gt;name;
 285             my $parentInterface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 286 
 287             if ($beforeRecursion) {
 288                 &amp;$beforeRecursion($parentInterface) eq &#39;prune&#39; and next;
 289             }
 290             &amp;$recurse($outerInterface, $parentInterface);
 291             &amp;$afterRecursion($parentInterface) if $afterRecursion;
 292         }
 293     };
 294 
 295     &amp;$recurse($interface, $interface);
 296 }
 297 
 298 sub IDLFileForInterface
 299 {
 300     my $object = shift;
 301     my $interfaceName = shift;
 302 
 303     unless ($idlFiles) {
 304         my $sourceRoot = $ENV{SOURCE_ROOT};
 305         my @directories = map { $_ = &quot;$sourceRoot/$_&quot; if $sourceRoot &amp;&amp; -d &quot;$sourceRoot/$_&quot;; $_ } @$useDirectories;
 306         push(@directories, &quot;.&quot;);
 307 
 308         $idlFiles = { };
 309 
 310         my $wanted = sub {
 311             $idlFiles-&gt;{$1} = $File::Find::name if /^([A-Z].*)\.idl$/;
 312             $File::Find::prune = 1 if /^\../;
 313         };
 314         find($wanted, @directories);
 315     }
 316 
 317     return $idlFiles-&gt;{$interfaceName};
 318 }
 319 
 320 sub GetInterfaceForType
 321 {
 322     my ($object, $currentInterface, $type) = @_;
 323 
 324     return undef unless $object-&gt;IsInterfaceType($type);
 325 
 326     return $object-&gt;ParseInterface($currentInterface, $type-&gt;name);
 327 }
 328 
 329 sub GetAttributeFromInterface
 330 {
 331     my ($object, $outerInterface, $interfaceName, $attributeName) = @_;
 332 
 333     my $interface = $object-&gt;ParseInterface($outerInterface, $interfaceName);
 334     for my $attribute (@{$interface-&gt;attributes}) {
 335         return $attribute if $attribute-&gt;name eq $attributeName;
 336     }
 337     die(&quot;Could not find attribute &#39;$attributeName&#39; on interface &#39;$interfaceName&#39;.&quot;);
 338 }
 339 
 340 sub ParseInterface
 341 {
 342     my $object = shift;
 343     my $outerInterface = shift;
 344     my $interfaceName = shift;
 345 
 346     return undef if $interfaceName eq &#39;Object&#39;;
 347     return undef if $interfaceName eq &#39;UNION&#39;;
 348 
 349     if (exists $cachedInterfaces-&gt;{$interfaceName}) {
 350         return $cachedInterfaces-&gt;{$interfaceName};
 351     }
 352 
 353     # Step #1: Find the IDL file associated with &#39;interface&#39;
 354     my $filename = $object-&gt;IDLFileForInterface($interfaceName)
 355         or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;, reachable from \&quot;&quot; . $outerInterface-&gt;type-&gt;name . &quot;\&quot;!\n&quot;);
 356 
 357     print &quot;  |  |&gt;  Parsing parent IDL \&quot;$filename\&quot; for interface \&quot;$interfaceName\&quot;\n&quot; if $verbose;
 358 
 359     # Step #2: Parse the found IDL file (in quiet mode).
 360     my $parser = IDLParser-&gt;new(1);
 361     my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 362 
 363     foreach my $interface (@{$document-&gt;interfaces}) {
 364         if ($interface-&gt;type-&gt;name eq $interfaceName) {
 365             $cachedInterfaces-&gt;{$interfaceName} = $interface;
 366             return $interface;
 367         }
 368     }
 369 
 370     die(&quot;Could NOT find interface definition for $interfaceName in $filename&quot;);
 371 }
 372 
 373 sub ParseType
 374 {
 375     my ($object, $typeString) = @_;
 376 
 377     return $cachedTypes-&gt;{$typeString} if exists($cachedTypes-&gt;{$typeString});
 378 
 379     my $parser = IDLParser-&gt;new(1);
 380     my $type = $parser-&gt;ParseType($typeString, $idlAttributes);
 381 
 382     $cachedTypes-&gt;{$typeString} = $type;
 383 
 384     return $type;
 385 }
 386 
 387 # Helpers for all CodeGenerator***.pm modules
 388 
 389 sub IsNumericType
 390 {
 391     my ($object, $type) = @_;
 392 
 393     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 394 
 395     return 1 if $integerTypeHash{$type-&gt;name};
 396     return 1 if $floatingPointTypeHash{$type-&gt;name};
 397     return 0;
 398 }
 399 
 400 sub IsStringOrEnumType
 401 {
 402     my ($object, $type) = @_;
 403     
 404     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 405 
 406     return 1 if $object-&gt;IsStringType($type);
 407     return 1 if $object-&gt;IsEnumType($type);
 408     return 0;
 409 }
 410 
 411 sub IsIntegerType
 412 {
 413     my ($object, $type) = @_;
 414 
 415     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 416 
 417     return 1 if $integerTypeHash{$type-&gt;name};
 418     return 0;
 419 }
 420 
 421 sub IsFloatingPointType
 422 {
 423     my ($object, $type) = @_;
 424 
 425     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 426 
 427     return 1 if $floatingPointTypeHash{$type-&gt;name};
 428     return 0;
 429 }
 430 
 431 sub IsPrimitiveType
 432 {
 433     my ($object, $type) = @_;
 434 
 435     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 436 
 437     return 1 if $primitiveTypeHash{$type-&gt;name};
 438     return 1 if $object-&gt;IsNumericType($type);
 439     return 0;
 440 }
 441 
 442 sub IsStringType
 443 {
 444     my ($object, $type) = @_;
 445 
 446     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 447 
 448     return 1 if $stringTypeHash{$type-&gt;name};
 449     return 0;
 450 }
 451 
 452 sub IsEnumType
 453 {
 454     my ($object, $type) = @_;
 455 
 456     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 457 
 458     return defined($object-&gt;GetEnumByType($type));
 459 }
 460 
 461 sub GetEnumByType
 462 {
 463     my ($object, $type) = @_;
 464 
 465     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 466 
 467     my $name = $type-&gt;name;
 468 
 469     die &quot;GetEnumByType() was called with an undefined enumeration name&quot; unless defined($name);
 470 
 471     for my $enumeration (@{$useDocument-&gt;enumerations}) {
 472         return $enumeration if $enumeration-&gt;type-&gt;name eq $name;
 473     }
 474 
 475     return $cachedExternalEnumerations-&gt;{$name} if exists($cachedExternalEnumerations-&gt;{$name});
 476 
 477     # Find the IDL file associated with the dictionary.
 478     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 479 
 480     # Do a fast check to see if it seems to contain a dictionary.
 481     my $fileContents = slurp($filename);
 482 
 483     if ($fileContents =~ /\benum\s+$name/gs) {
 484         # Parse the IDL.
 485         my $parser = IDLParser-&gt;new(1);
 486         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 487 
 488         foreach my $enumeration (@{$document-&gt;enumerations}) {
 489             next unless $enumeration-&gt;type-&gt;name eq $name;
 490 
 491             $cachedExternalEnumerations-&gt;{$name} = $enumeration;
 492             my $implementedAs = $enumeration-&gt;extendedAttributes-&gt;{ImplementedAs};
 493             $enumTypeImplementationNameOverrides{$enumeration-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 494             return $enumeration;
 495         }
 496     }
 497     $cachedExternalEnumerations-&gt;{$name} = undef;
 498 }
 499 
 500 # An enumeration defined in its own IDL file.
 501 sub IsExternalEnumType
 502 {
 503     my ($object, $type) = @_;
 504 
 505     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 506 
 507     return $object-&gt;IsEnumType($type) &amp;&amp; defined($cachedExternalEnumerations-&gt;{$type-&gt;name});
 508 }
 509 
 510 sub HasEnumImplementationNameOverride
 511 {
 512     my ($object, $type) = @_;
 513 
 514     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 515 
 516     return 1 if exists $enumTypeImplementationNameOverrides{$type-&gt;name};
 517     return 0;
 518 }
 519 
 520 sub GetEnumImplementationNameOverride
 521 {
 522     my ($object, $type) = @_;
 523 
 524     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 525 
 526     return $enumTypeImplementationNameOverrides{$type-&gt;name};
 527 }
 528 
 529 sub GetDictionaryByType
 530 {
 531     my ($object, $type) = @_;
 532 
 533     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 534 
 535     my $name = $type-&gt;name;
 536 
 537     die &quot;GetDictionaryByType() was called with an undefined dictionary name&quot; unless defined($name);
 538 
 539     for my $dictionary (@{$useDocument-&gt;dictionaries}) {
 540         return $dictionary if $dictionary-&gt;type-&gt;name eq $name;
 541     }
 542 
 543     return $cachedExternalDictionaries-&gt;{$name} if exists($cachedExternalDictionaries-&gt;{$name});
 544 
 545     # Find the IDL file associated with the dictionary.
 546     my $filename = $object-&gt;IDLFileForInterface($name) or return;
 547 
 548     # Do a fast check to see if it seems to contain a dictionary.
 549     my $fileContents = slurp($filename);
 550 
 551     if ($fileContents =~ /\bdictionary\s+$name/gs) {
 552         # Parse the IDL.
 553         my $parser = IDLParser-&gt;new(1);
 554         my $document = $parser-&gt;Parse($filename, $defines, $preprocessor, $idlAttributes);
 555 
 556         foreach my $dictionary (@{$document-&gt;dictionaries}) {
 557             next unless $dictionary-&gt;type-&gt;name eq $name;
 558 
 559             $cachedExternalDictionaries-&gt;{$name} = $dictionary;
 560             my $implementedAs = $dictionary-&gt;extendedAttributes-&gt;{ImplementedAs};
 561             $dictionaryTypeImplementationNameOverrides{$dictionary-&gt;type-&gt;name} = $implementedAs if $implementedAs;
 562             return $dictionary;
 563         }
 564     }
 565     $cachedExternalDictionaries-&gt;{$name} = undef;
 566 }
 567 
 568 sub IsDictionaryType
 569 {
 570     my ($object, $type) = @_;
 571 
 572     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 573 
 574     return $type-&gt;name =~ /^[A-Z]/ &amp;&amp; defined($object-&gt;GetDictionaryByType($type));
 575 }
 576 
 577 # A dictionary defined in its own IDL file.
 578 sub IsExternalDictionaryType
 579 {
 580     my ($object, $type) = @_;
 581 
 582     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 583 
 584     return $object-&gt;IsDictionaryType($type) &amp;&amp; defined($cachedExternalDictionaries-&gt;{$type-&gt;name});
 585 }
 586 
 587 sub HasDictionaryImplementationNameOverride
 588 {
 589     my ($object, $type) = @_;
 590 
 591     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 592 
 593     return 1 if exists $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 594     return 0;
 595 }
 596 
 597 sub GetDictionaryImplementationNameOverride
 598 {
 599     my ($object, $type) = @_;
 600 
 601     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 602 
 603     return $dictionaryTypeImplementationNameOverrides{$type-&gt;name};
 604 }
 605 
 606 sub IsSVGAnimatedTypeName
 607 {
 608     my ($object, $typeName) = @_;
 609 
 610     return $typeName =~ /^SVGAnimated/;
 611 }
 612 
 613 sub IsSVGAnimatedType
 614 {
 615     my ($object, $type) = @_;
 616 
 617     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 618 
 619     return $object-&gt;IsSVGAnimatedTypeName($type-&gt;name);
 620 }
 621 
 622 sub IsConstructorType
 623 {
 624     my ($object, $type) = @_;
 625 
 626     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 627 
 628     return $type-&gt;name =~ /Constructor$/;
 629 }
 630 
 631 sub IsSequenceType
 632 {
 633     my ($object, $type) = @_;
 634 
 635     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 636 
 637     return $type-&gt;name eq &quot;sequence&quot;;
 638 }
 639 
 640 sub IsFrozenArrayType
 641 {
 642     my ($object, $type) = @_;
 643 
 644     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 645 
 646     return $type-&gt;name eq &quot;FrozenArray&quot;;
 647 }
 648 
 649 sub IsSequenceOrFrozenArrayType
 650 {
 651     my ($object, $type) = @_;
 652 
 653     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 654 
 655     return $object-&gt;IsSequenceType($type) || $object-&gt;IsFrozenArrayType($type);
 656 }
 657 
 658 sub IsRecordType
 659 {
 660     my ($object, $type) = @_;
 661 
 662     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 663 
 664     return $type-&gt;name eq &quot;record&quot;;
 665 }
 666 
 667 sub IsBufferSourceType
 668 {
 669     my ($object, $type) = @_;
 670 
 671     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 672 
 673     return 1 if $bufferSourceTypes{$type-&gt;name};
 674     return 0;
 675 }
 676 
 677 sub IsPromiseType
 678 {
 679     my ($object, $type) = @_;
 680 
 681     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 682 
 683     return $type-&gt;name eq &quot;Promise&quot;;
 684 }
 685 
 686 # These match WK_lcfirst and WK_ucfirst defined in builtins_generator.py.
 687 # Uppercase the first letter while respecting WebKit style guidelines.
 688 # E.g., xmlEncoding becomes XMLEncoding, but xmlllang becomes Xmllang.
 689 sub WK_ucfirst
 690 {
 691     my ($object, $param) = @_;
 692 
 693     my $ret = ucfirst($param);
 694     $ret =~ s/Xml/XML/ if $ret =~ /^Xml[^a-z]/;
 695     $ret =~ s/Svg/SVG/ if $ret =~ /^Svg/;
 696     $ret =~ s/Srgb/SRGB/ if $ret =~ /^Srgb/;
 697     $ret =~ s/Cenc/cenc/ if $ret =~ /^Cenc/;
 698     $ret =~ s/Cbcs/cbcs/ if $ret =~ /^Cbcs/;
 699 
 700     return $ret;
 701 }
 702 
 703 # Lowercase the first letter while respecting WebKit style guidelines.
 704 # URL becomes url, but SetURL becomes setURL.
 705 sub WK_lcfirst
 706 {
 707     my ($object, $param) = @_;
 708 
 709     my $ret = lcfirst($param);
 710     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
 711     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
 712     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
 713     $ret =~ s/jS/js/ if $ret =~ /^jS/;
 714     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
 715     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
 716     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
 717     $ret =~ s/rTC/rtc/ if $ret =~ /^rTC/;
 718 
 719     # For HTML5 FileSystem API Flags attributes.
 720     # (create is widely used to instantiate an object and must be avoided.)
 721     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
 722     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
 723 
 724     return $ret;
 725 }
 726 
 727 sub slurp
 728 {
 729     my $file = shift;
 730 
 731     open my $fh, &#39;&lt;&#39;, $file or die;
 732     local $/ = undef;
 733     my $content = &lt;$fh&gt;;
 734     close $fh;
 735     return $content;
 736 }
 737 
 738 sub trim
 739 {
 740     my $string = shift;
 741 
 742     $string =~ s/^\s+|\s+$//g;
 743     return $string;
 744 }
 745 
 746 # Return the C++ namespace that a given attribute name string is defined in.
 747 sub NamespaceForAttributeName
 748 {
 749     my ($object, $interfaceName, $attributeName) = @_;
 750 
 751     return &quot;SVGNames&quot; if $interfaceName =~ /^SVG/ &amp;&amp; !$svgAttributesInHTMLHash{$attributeName};
 752     return &quot;HTMLNames&quot;;
 753 }
 754 
 755 # Identifies overloaded functions and for each function adds an array with
 756 # links to its respective overloads (including itself).
 757 sub LinkOverloadedOperations
 758 {
 759     my ($object, $interface) = @_;
 760 
 761     my %nameToOperationsMap = ();
 762     foreach my $operation (@{$interface-&gt;operations}) {
 763         my $name = $operation-&gt;name;
 764         $nameToOperationsMap{$name} = [] if !exists $nameToOperationsMap{$name};
 765         push(@{$nameToOperationsMap{$name}}, $operation);
 766         $operation-&gt;{overloads} = $nameToOperationsMap{$name};
 767         $operation-&gt;{overloadIndex} = @{$nameToOperationsMap{$name}};
 768     }
 769 
 770     my $index = 1;
 771     foreach my $constructor (@{$interface-&gt;constructors}) {
 772         $constructor-&gt;{overloads} = $interface-&gt;constructors;
 773         $constructor-&gt;{overloadIndex} = $index;
 774         $index++;
 775     }
 776 }
 777 
 778 sub AttributeNameForGetterAndSetter
 779 {
 780     my ($generator, $attribute) = @_;
 781 
 782     my $attributeName = $attribute-&gt;name;
 783     if ($attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;}) {
 784         $attributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;ImplementedAs&quot;};
 785     }
 786     my $attributeType = $attribute-&gt;type;
 787 
 788     # SVG animated types need to use a special attribute name.
 789     # The rest of the special casing for SVG animated types is handled in the language-specific code generators.
 790     $attributeName .= &quot;Animated&quot; if $generator-&gt;IsSVGAnimatedType($attributeType);
 791 
 792     return $attributeName;
 793 }
 794 
 795 sub ContentAttributeName
 796 {
 797     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 798 
 799     my $contentAttributeName = $attribute-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;};
 800     return undef if !$contentAttributeName;
 801 
 802     $contentAttributeName = lc $generator-&gt;AttributeNameForGetterAndSetter($attribute) if $contentAttributeName eq &quot;VALUE_IS_MISSING&quot;;
 803 
 804     my $namespace = $generator-&gt;NamespaceForAttributeName($interfaceName, $contentAttributeName);
 805 
 806     $implIncludes-&gt;{&quot;${namespace}.h&quot;} = 1;
 807     return &quot;WebCore::${namespace}::${contentAttributeName}Attr&quot;;
 808 }
 809 
 810 sub GetterExpression
 811 {
 812     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 813 
 814     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
 815 
 816     if (!$contentAttributeName) {
 817         return ($generator-&gt;WK_lcfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
 818     }
 819 
 820     my $attributeType = $attribute-&gt;type;
 821 
 822     my $functionName;
 823     if ($attribute-&gt;extendedAttributes-&gt;{&quot;URL&quot;}) {
 824         $functionName = &quot;getURLAttribute&quot;;
 825     } elsif ($attributeType-&gt;name eq &quot;boolean&quot;) {
 826         $functionName = &quot;hasAttributeWithoutSynchronization&quot;;
 827     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
 828         $functionName = &quot;getIntegralAttribute&quot;;
 829     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
 830         $functionName = &quot;getUnsignedIntegralAttribute&quot;;
 831     } else {
 832         if ($contentAttributeName eq &quot;WebCore::HTMLNames::idAttr&quot;) {
 833             $functionName = &quot;getIdAttribute&quot;;
 834             $contentAttributeName = &quot;&quot;;
 835         } elsif ($contentAttributeName eq &quot;WebCore::HTMLNames::nameAttr&quot;) {
 836             $functionName = &quot;getNameAttribute&quot;;
 837             $contentAttributeName = &quot;&quot;;
 838         } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
 839             $functionName = &quot;getAttribute&quot;;
 840         } else {
 841             $functionName = &quot;attributeWithoutSynchronization&quot;;
 842         }
 843     }
 844 
 845     return ($functionName, $contentAttributeName);
 846 }
 847 
 848 sub SetterExpression
 849 {
 850     my ($generator, $implIncludes, $interfaceName, $attribute) = @_;
 851 
 852     my $contentAttributeName = $generator-&gt;ContentAttributeName($implIncludes, $interfaceName, $attribute);
 853 
 854     if (!$contentAttributeName) {
 855         return (&quot;set&quot; . $generator-&gt;WK_ucfirst($generator-&gt;AttributeNameForGetterAndSetter($attribute)));
 856     }
 857 
 858     my $attributeType = $attribute-&gt;type;
 859 
 860     my $functionName;
 861     if ($attributeType-&gt;name eq &quot;boolean&quot;) {
 862         $functionName = &quot;setBooleanAttribute&quot;;
 863     } elsif ($attributeType-&gt;name eq &quot;long&quot;) {
 864         $functionName = &quot;setIntegralAttribute&quot;;
 865     } elsif ($attributeType-&gt;name eq &quot;unsigned long&quot;) {
 866         $functionName = &quot;setUnsignedIntegralAttribute&quot;;
 867     } elsif ($generator-&gt;IsSVGAnimatedType($attributeType)) {
 868         $functionName = &quot;setAttribute&quot;;
 869     } else {
 870         $functionName = &quot;setAttributeWithoutSynchronization&quot;;
 871     }
 872 
 873     return ($functionName, $contentAttributeName);
 874 }
 875 
 876 sub IsBuiltinType
 877 {
 878     my ($object, $type) = @_;
 879 
 880     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 881 
 882     return 1 if $object-&gt;IsPrimitiveType($type);
 883     return 1 if $object-&gt;IsSequenceOrFrozenArrayType($type);
 884     return 1 if $object-&gt;IsRecordType($type);
 885     return 1 if $object-&gt;IsStringType($type);
 886     return 1 if $object-&gt;IsBufferSourceType($type);
 887     return 1 if $type-&gt;isUnion;
 888     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
 889     return 1 if $type-&gt;name eq &quot;JSON&quot;;
 890     return 1 if $type-&gt;name eq &quot;Promise&quot;;
 891     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
 892     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
 893     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
 894     return 1 if $type-&gt;name eq &quot;any&quot;;
 895     return 1 if $type-&gt;name eq &quot;object&quot;;
 896 
 897     return 0;
 898 }
 899 
 900 sub IsInterfaceType
 901 {
 902     my ($object, $type) = @_;
 903 
 904     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 905 
 906     return 0 if $object-&gt;IsBuiltinType($type);
 907     return 0 if $object-&gt;IsDictionaryType($type);
 908     return 0 if $object-&gt;IsEnumType($type);
 909 
 910     return 1;
 911 }
 912 
 913 sub IsWrapperType
 914 {
 915     my ($object, $type) = @_;
 916 
 917     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
 918 
 919     return 1 if $object-&gt;IsInterfaceType($type);
 920     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
 921 
 922     return 0;
 923 }
 924 
 925 sub InheritsSerializable
 926 {
 927     my ($object, $interface) = @_;
 928 
 929     my $anyParentIsSerializable = 0;
 930     $object-&gt;ForAllParents($interface, sub {
 931         my $parentInterface = shift;
 932         $anyParentIsSerializable = 1 if $parentInterface-&gt;serializable;
 933     }, 0);
 934 
 935     return $anyParentIsSerializable;
 936 }
 937 
 938 sub IsSerializableType
 939 {
 940     my ($object, $interface, $type) = @_;
 941 
 942     # https://heycam.github.io/webidl/#dfn-serializable-type
 943 
 944     return 1 if $type-&gt;name eq &quot;boolean&quot;;
 945     return 1 if $object-&gt;IsNumericType($type);
 946     return 1 if $object-&gt;IsEnumType($type);
 947     return 1 if $object-&gt;IsStringType($type);
 948     return 0 if $type-&gt;name eq &quot;EventHandler&quot;;
 949 
 950     if ($type-&gt;isUnion || $object-&gt;IsDictionaryType($type)) {
 951         die &quot;Serializers for union and dictionary types are not currently supported.\n&quot;;
 952     }
 953 
 954     if ($object-&gt;IsSequenceOrFrozenArrayType($type)) {
 955         my $subtype = @{$type-&gt;subtypes}[0];
 956 
 957         # FIXME: webkit.org/b/194439 [WebIDL] Support serializing sequences and FrozenArrays of interfaces
 958         return 0 if $object-&gt;IsInterfaceType($subtype);
 959 
 960         return $object-&gt;IsSerializableType($interface, $subtype);
 961     }
 962 
 963     return 0 if !$object-&gt;IsInterfaceType($type);
 964 
 965     my $interfaceForType = $object-&gt;GetInterfaceForType($interface, $type);
 966     if ($interfaceForType) {
 967         return 1 if $interfaceForType-&gt;serializable;
 968         return $object-&gt;InheritsSerializable($interfaceForType);
 969     }
 970 
 971     return 0;
 972 }
 973 
 974 sub hasCachedAttributeOrCustomGetterExtendedAttribute
 975 {
 976     my ($attribute) = @_;
 977     return $attribute-&gt;extendedAttributes-&gt;{CachedAttribute} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
 978 }
 979 
 980 sub IsSerializableAttribute
 981 {
 982     my ($object, $interface, $attribute) = @_;
 983 
 984     if ($object-&gt;IsSequenceType($attribute-&gt;type) &amp;&amp; hasCachedAttributeOrCustomGetterExtendedAttribute($attribute)) {
 985         die &quot;Serializers for sequence types with CachedAttribute or CustomGetter extended attributes are not currently supported.\n&quot;;
 986     }
 987 
 988     return $object-&gt;IsSerializableType($interface, $attribute-&gt;type);
 989 }
 990 
 991 sub GetInterfaceExtendedAttributesFromName
 992 {
 993     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
 994     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
 995 
 996     my ($object, $interfaceName) = @_;
 997 
 998     my $idlFile = $object-&gt;IDLFileForInterface($interfaceName) or assert(&quot;Could NOT find IDL file for interface \&quot;$interfaceName\&quot;!\n&quot;);
 999 
1000     open FILE, &quot;&lt;&quot;, $idlFile or die;
1001     my @lines = &lt;FILE&gt;;
1002     close FILE;
1003 
1004     my $fileContents = join(&#39;&#39;, @lines);
1005 
1006     my $extendedAttributes = {};
1007 
1008     if ($fileContents =~ /\[(.*)\]\s+(callback interface|interface|exception)\s+(\w+)/gs) {
1009         my @parts = split(&#39;,&#39;, $1);
1010         foreach my $part (@parts) {
1011             my @keyValue = split(&#39;=&#39;, $part);
1012             my $key = trim($keyValue[0]);
1013             next unless length($key);
1014             my $value = &quot;VALUE_IS_MISSING&quot;;
1015             $value = trim($keyValue[1]) if @keyValue &gt; 1;
1016             $extendedAttributes-&gt;{$key} = $value;
1017         }
1018     }
1019 
1020     return $extendedAttributes;
1021 }
1022 
1023 sub ComputeIsCallbackInterface
1024 {
1025     my ($object, $type) = @_;
1026 
1027     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1028 
1029     return 0 unless $object-&gt;IsInterfaceType($type);
1030     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1031 
1032     my $typeName = $type-&gt;name;
1033     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1034 
1035     open FILE, &quot;&lt;&quot;, $idlFile or die;
1036     my @lines = &lt;FILE&gt;;
1037     close FILE;
1038 
1039     my $fileContents = join(&#39;&#39;, @lines);
1040     return ($fileContents =~ /callback\s+interface\s+(\w+)/gs);
1041 }
1042 
1043 my %isCallbackInterface = ();
1044 
1045 sub IsCallbackInterface
1046 {
1047     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1048     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1049     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1050 
1051     my ($object, $type) = @_;
1052 
1053     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1054 
1055     return $isCallbackInterface{$type-&gt;name} if exists $isCallbackInterface{$type-&gt;name};
1056     my $result = $object-&gt;ComputeIsCallbackInterface($type);
1057     $isCallbackInterface{$type-&gt;name} = $result;
1058     return $result;
1059 }
1060 
1061 sub ComputeIsCallbackFunction
1062 {
1063     my ($object, $type) = @_;
1064 
1065     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1066 
1067     return 0 unless $object-&gt;IsInterfaceType($type);
1068     return 0 if $type-&gt;name eq &quot;WindowProxy&quot;;
1069 
1070     my $typeName = $type-&gt;name;
1071     my $idlFile = $object-&gt;IDLFileForInterface($typeName) or assert(&quot;Could NOT find IDL file for interface \&quot;$typeName\&quot;!\n&quot;);
1072 
1073     open FILE, &quot;&lt;&quot;, $idlFile or die;
1074     my @lines = &lt;FILE&gt;;
1075     close FILE;
1076 
1077     my $fileContents = join(&#39;&#39;, @lines);
1078     return ($fileContents =~ /(.*)callback\s+(\w+)\s+=/gs);
1079 }
1080 
1081 my %isCallbackFunction = ();
1082 
1083 sub IsCallbackFunction
1084 {
1085     # FIXME: It&#39;s bad to have a function like this that opens another IDL file to answer a question.
1086     # Overusing this kind of function can make things really slow. Lets avoid these if we can.
1087     # To mitigate that, lets cache what we learn in a hash so we don&#39;t open the same file over and over.
1088 
1089     my ($object, $type) = @_;
1090 
1091     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
1092 
1093     return $isCallbackFunction{$type-&gt;name} if exists $isCallbackFunction{$type-&gt;name};
1094     my $result = $object-&gt;ComputeIsCallbackFunction($type);
1095     $isCallbackFunction{$type-&gt;name} = $result;
1096     return $result;
1097 }
1098 
1099 sub GenerateConditionalString
1100 {
1101     my ($generator, $node) = @_;
1102 
1103     my $conditional = $node-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1104     if ($conditional) {
1105         return $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1106     } else {
1107         return &quot;&quot;;
1108     }
1109 }
1110 
1111 sub GenerateConditionalStringFromAttributeValue
1112 {
1113     my ($generator, $conditional) = @_;
1114 
1115     my %disjunction;
1116     map {
1117         my $expression = $_;
1118         my %conjunction;
1119         map { $conjunction{$_} = 1; } split(/&amp;/, $expression);
1120         $expression = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, sort keys %conjunction) . &quot;)&quot;;
1121         $disjunction{$expression} = 1
1122     } split(/\|/, $conditional);
1123 
1124     return &quot;1&quot; if keys %disjunction == 0;
1125     return (%disjunction)[0] if keys %disjunction == 1;
1126 
1127     my @parenthesized;
1128     map {
1129         my $expression = $_;
1130         $expression = &quot;($expression)&quot; if $expression =~ / /;
1131         push @parenthesized, $expression;
1132     } sort keys %disjunction;
1133 
1134     return join(&quot; || &quot;, @parenthesized);
1135 }
1136 
1137 sub GenerateCompileTimeCheckForEnumsIfNeeded
1138 {
1139     my ($generator, $interface) = @_;
1140 
1141     return () if $interface-&gt;extendedAttributes-&gt;{&quot;DoNotCheckConstants&quot;} || !@{$interface-&gt;constants};
1142 
1143     my $baseScope = $interface-&gt;extendedAttributes-&gt;{&quot;ConstantsScope&quot;} || $interface-&gt;type-&gt;name;
1144 
1145     my @checks = ();
1146     foreach my $constant (@{$interface-&gt;constants}) {
1147         my $scope = $constant-&gt;extendedAttributes-&gt;{&quot;ImplementedBy&quot;} || $baseScope;
1148         my $name = $constant-&gt;extendedAttributes-&gt;{&quot;Reflect&quot;} || $constant-&gt;name;
1149         my $value = $constant-&gt;value;
1150         my $conditional = $constant-&gt;extendedAttributes-&gt;{&quot;Conditional&quot;};
1151         push(@checks, &quot;#if &quot; . $generator-&gt;GenerateConditionalStringFromAttributeValue($conditional) . &quot;\n&quot;) if $conditional;
1152         push(@checks, &quot;static_assert(${scope}::${name} == ${value}, \&quot;${name} in ${scope} does not match value from IDL\&quot;);\n&quot;);
1153         push(@checks, &quot;#endif\n&quot;) if $conditional;
1154     }
1155     push(@checks, &quot;\n&quot;);
1156     return @checks;
1157 }
1158 
1159 sub ExtendedAttributeContains
1160 {
1161     my $object = shift;
1162     my $callWith = shift;
1163     return 0 unless $callWith;
1164     my $keyword = shift;
1165 
1166     my @callWithKeywords = split /\s*\&amp;\s*/, $callWith;
1167     return grep { $_ eq $keyword } @callWithKeywords;
1168 }
1169 
1170 # FIXME: This is backwards. We currently name the interface and the IDL files with the implementation name. We
1171 # should use the real interface name in the IDL files and then use ImplementedAs to map this to the implementation name.
1172 sub GetVisibleInterfaceName
1173 {
1174     my ($object, $interface) = @_;
1175 
1176     my $interfaceName = $interface-&gt;extendedAttributes-&gt;{&quot;InterfaceName&quot;};
1177     return $interfaceName ? $interfaceName : $interface-&gt;type-&gt;name;
1178 }
1179 
1180 sub InheritsInterface
1181 {
1182     my ($object, $interface, $interfaceName) = @_;
1183 
1184     return 1 if $interfaceName eq $interface-&gt;type-&gt;name;
1185 
1186     my $found = 0;
1187     $object-&gt;ForAllParents($interface, sub {
1188         my $currentInterface = shift;
1189         if ($currentInterface-&gt;type-&gt;name eq $interfaceName) {
1190             $found = 1;
1191         }
1192         return 1 if $found;
1193     }, 0);
1194 
1195     return $found;
1196 }
1197 
1198 sub InheritsExtendedAttribute
1199 {
1200     my ($object, $interface, $extendedAttribute) = @_;
1201 
1202     return 1 if $interface-&gt;extendedAttributes-&gt;{$extendedAttribute};
1203 
1204     my $found = 0;
1205     $object-&gt;ForAllParents($interface, sub {
1206         my $currentInterface = shift;
1207         if ($currentInterface-&gt;extendedAttributes-&gt;{$extendedAttribute}) {
1208             $found = 1;
1209         }
1210         return 1 if $found;
1211     }, 0);
1212 
1213     return $found;
1214 }
1215 
1216 
1217 1;
    </pre>
  </body>
</html>