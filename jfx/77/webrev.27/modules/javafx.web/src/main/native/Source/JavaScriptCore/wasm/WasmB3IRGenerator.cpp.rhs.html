<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WasmB3IRGenerator.h&quot;
  28 
  29 #if ENABLE(WEBASSEMBLY)
  30 
  31 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3CCallValue.h&quot;
  34 #include &quot;B3Compile.h&quot;
  35 #include &quot;B3ConstPtrValue.h&quot;
  36 #include &quot;B3FixSSA.h&quot;
  37 #include &quot;B3Generate.h&quot;
  38 #include &quot;B3InsertionSet.h&quot;
  39 #include &quot;B3SlotBaseValue.h&quot;
  40 #include &quot;B3StackmapGenerationParams.h&quot;
  41 #include &quot;B3SwitchValue.h&quot;
  42 #include &quot;B3UpsilonValue.h&quot;
  43 #include &quot;B3Validate.h&quot;
  44 #include &quot;B3ValueInlines.h&quot;
  45 #include &quot;B3ValueKey.h&quot;
  46 #include &quot;B3Variable.h&quot;
  47 #include &quot;B3VariableValue.h&quot;
  48 #include &quot;B3WasmAddressValue.h&quot;
  49 #include &quot;B3WasmBoundsCheckValue.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  50 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
  51 #include &quot;JSCInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  52 #include &quot;JSWebAssemblyInstance.h&quot;</span>
  53 #include &quot;ScratchRegisterAllocator.h&quot;
  54 #include &quot;VirtualRegister.h&quot;
  55 #include &quot;WasmCallingConvention.h&quot;
  56 #include &quot;WasmContextInlines.h&quot;
  57 #include &quot;WasmExceptionType.h&quot;
  58 #include &quot;WasmFunctionParser.h&quot;
  59 #include &quot;WasmInstance.h&quot;
  60 #include &quot;WasmMemory.h&quot;
  61 #include &quot;WasmOMGPlan.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  62 #include &quot;WasmOSREntryData.h&quot;</span>
  63 #include &quot;WasmOpcodeOrigin.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  64 #include &quot;WasmOperations.h&quot;</span>
  65 #include &quot;WasmSignatureInlines.h&quot;
  66 #include &quot;WasmThunks.h&quot;
  67 #include &lt;limits&gt;
  68 #include &lt;wtf/Optional.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 
  71 void dumpProcedure(void* ptr)
  72 {
  73     JSC::B3::Procedure* proc = static_cast&lt;JSC::B3::Procedure*&gt;(ptr);
  74     proc-&gt;dump(WTF::dataFile());
  75 }
  76 
  77 namespace JSC { namespace Wasm {
  78 
  79 using namespace B3;
  80 
  81 namespace {
  82 namespace WasmB3IRGeneratorInternal {
  83 static const bool verbose = false;
  84 }
  85 }
  86 
  87 class B3IRGenerator {
  88 public:
  89     struct ControlData {
  90         ControlData(Procedure&amp; proc, Origin origin, Type signature, BlockType type, BasicBlock* continuation, BasicBlock* special = nullptr)
  91             : blockType(type)
  92             , continuation(continuation)
  93             , special(special)
  94         {
  95             if (signature != Void)
  96                 result.append(proc.add&lt;Value&gt;(Phi, toB3Type(signature), origin));
  97         }
  98 
  99         ControlData()
 100         {
 101         }
 102 
 103         void dump(PrintStream&amp; out) const
 104         {
 105             switch (type()) {
 106             case BlockType::If:
 107                 out.print(&quot;If:       &quot;);
 108                 break;
 109             case BlockType::Block:
 110                 out.print(&quot;Block:    &quot;);
 111                 break;
 112             case BlockType::Loop:
 113                 out.print(&quot;Loop:     &quot;);
 114                 break;
 115             case BlockType::TopLevel:
 116                 out.print(&quot;TopLevel: &quot;);
 117                 break;
 118             }
 119             out.print(&quot;Continuation: &quot;, *continuation, &quot;, Special: &quot;);
 120             if (special)
 121                 out.print(*special);
 122             else
 123                 out.print(&quot;None&quot;);
 124         }
 125 
 126         BlockType type() const { return blockType; }
 127 
 128         bool hasNonVoidSignature() const { return result.size(); }
 129 
 130         BasicBlock* targetBlockForBranch()
 131         {
 132             if (type() == BlockType::Loop)
 133                 return special;
 134             return continuation;
 135         }
 136 
 137         void convertIfToBlock()
 138         {
 139             ASSERT(type() == BlockType::If);
 140             blockType = BlockType::Block;
 141             special = nullptr;
 142         }
 143 
 144         using ResultList = Vector&lt;Value*, 1&gt;; // Value must be a Phi
 145 
 146         ResultList resultForBranch() const
 147         {
 148             if (type() == BlockType::Loop)
 149                 return ResultList();
 150             return result;
 151         }
 152 
 153     private:
 154         friend class B3IRGenerator;
 155         BlockType blockType;
 156         BasicBlock* continuation;
 157         BasicBlock* special;
 158         ResultList result;
 159     };
 160 
 161     typedef Value* ExpressionType;
<a name="5" id="anc5"></a>
 162     typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;
<a name="6" id="anc6"></a><span class="line-modified"> 163 </span>
<span class="line-modified"> 164     friend class Stack;</span>
<span class="line-added"> 165     class Stack {</span>
<span class="line-added"> 166     public:</span>
<span class="line-added"> 167         Stack(B3IRGenerator* generator)</span>
<span class="line-added"> 168             : m_generator(generator)</span>
<span class="line-added"> 169         {</span>
<span class="line-added"> 170         }</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172         void append(ExpressionType expression)</span>
<span class="line-added"> 173         {</span>
<span class="line-added"> 174             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 175                 Variable* variable = m_generator-&gt;m_proc.addVariable(expression-&gt;type());</span>
<span class="line-added"> 176                 m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, Set, m_generator-&gt;origin(), variable, expression);</span>
<span class="line-added"> 177                 m_stack.append(variable);</span>
<span class="line-added"> 178                 return;</span>
<span class="line-added"> 179             }</span>
<span class="line-added"> 180             m_data.append(expression);</span>
<span class="line-added"> 181         }</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183         ExpressionType takeLast()</span>
<span class="line-added"> 184         {</span>
<span class="line-added"> 185             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 186                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.takeLast());</span>
<span class="line-added"> 187             return m_data.takeLast();</span>
<span class="line-added"> 188         }</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190         ExpressionType last()</span>
<span class="line-added"> 191         {</span>
<span class="line-added"> 192             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 193                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.last());</span>
<span class="line-added"> 194             return m_data.last();</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197         unsigned size() const</span>
<span class="line-added"> 198         {</span>
<span class="line-added"> 199             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 200                 return m_stack.size();</span>
<span class="line-added"> 201             return m_data.size();</span>
<span class="line-added"> 202         }</span>
<span class="line-added"> 203         bool isEmpty() const { return size() == 0; }</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205         ExpressionList convertToExpressionList()</span>
<span class="line-added"> 206         {</span>
<span class="line-added"> 207             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 208                 ExpressionList results;</span>
<span class="line-added"> 209                 for (unsigned i = 0; i &lt; m_stack.size(); ++i)</span>
<span class="line-added"> 210                     results.append(at(i));</span>
<span class="line-added"> 211                 return results;</span>
<span class="line-added"> 212             }</span>
<span class="line-added"> 213             return m_data;</span>
<span class="line-added"> 214         }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216         ExpressionType at(unsigned i) const</span>
<span class="line-added"> 217         {</span>
<span class="line-added"> 218             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 219                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.at(i));</span>
<span class="line-added"> 220             return m_data.at(i);</span>
<span class="line-added"> 221         }</span>
<span class="line-added"> 222 </span>
<span class="line-added"> 223         Variable* variableAt(unsigned i) const</span>
<span class="line-added"> 224         {</span>
<span class="line-added"> 225             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 226                 return m_stack.at(i);</span>
<span class="line-added"> 227             return nullptr;</span>
<span class="line-added"> 228         }</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230         void shrink(unsigned i)</span>
<span class="line-added"> 231         {</span>
<span class="line-added"> 232             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 233                 m_stack.shrink(i);</span>
<span class="line-added"> 234                 return;</span>
<span class="line-added"> 235             }</span>
<span class="line-added"> 236             m_data.shrink(i);</span>
<span class="line-added"> 237         }</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239         void swap(Stack&amp; stack)</span>
<span class="line-added"> 240         {</span>
<span class="line-added"> 241             std::swap(m_generator, stack.m_generator);</span>
<span class="line-added"> 242             m_data.swap(stack.m_data);</span>
<span class="line-added"> 243             m_stack.swap(stack.m_stack);</span>
<span class="line-added"> 244         }</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246         void dump() const</span>
<span class="line-added"> 247         {</span>
<span class="line-added"> 248             CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-added"> 249             dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-added"> 250             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 251                 for (const auto&amp; variable : m_stack)</span>
<span class="line-added"> 252                     dataLog(comma, *variable);</span>
<span class="line-added"> 253                 return;</span>
<span class="line-added"> 254             }</span>
<span class="line-added"> 255             for (const auto&amp; expression : m_data)</span>
<span class="line-added"> 256                 dataLog(comma, *expression);</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258 </span>
<span class="line-added"> 259     private:</span>
<span class="line-added"> 260         B3IRGenerator* m_generator { nullptr };</span>
<span class="line-added"> 261         ExpressionList m_data;</span>
<span class="line-added"> 262         Vector&lt;Variable*&gt; m_stack;</span>
<span class="line-added"> 263     };</span>
<span class="line-added"> 264     Stack createStack() { return Stack(this); }</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266     using ControlType = ControlData;</span>
<span class="line-added"> 267     using ResultList = ControlData::ResultList;</span>
<span class="line-added"> 268     using ControlEntry = FunctionParser&lt;B3IRGenerator&gt;::ControlEntry;</span>
 269 
 270     static constexpr ExpressionType emptyExpression() { return nullptr; }
 271 
 272     typedef String ErrorType;
 273     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 274     typedef Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt; Result;
 275     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 276     template &lt;typename ...Args&gt;
 277     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 278     {
 279         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 280         return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
 281     }
 282 #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
 283         if (UNLIKELY(condition))                  \
 284             return fail(__VA_ARGS__);             \
 285     } while (0)
 286 
<a name="7" id="anc7"></a><span class="line-modified"> 287     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, unsigned&amp; osrEntryScratchBufferSize, MemoryMode, CompilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount*, ThrowWasmException);</span>
 288 
 289     PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
 290     PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
 291     ExpressionType addConstant(Type, uint64_t);
 292 
<a name="8" id="anc8"></a><span class="line-added"> 293     // References</span>
<span class="line-added"> 294     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
<span class="line-added"> 295     PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297     // Tables</span>
<span class="line-added"> 298     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="line-added"> 299     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
<span class="line-added"> 300     PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);</span>
<span class="line-added"> 301     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="line-added"> 302     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
 303     // Locals
 304     PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
 305     PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
 306 
 307     // Globals
 308     PartialResult WARN_UNUSED_RETURN getGlobal(uint32_t index, ExpressionType&amp; result);
 309     PartialResult WARN_UNUSED_RETURN setGlobal(uint32_t index, ExpressionType value);
 310 
 311     // Memory
 312     PartialResult WARN_UNUSED_RETURN load(LoadOpType, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset);
 313     PartialResult WARN_UNUSED_RETURN store(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 314     PartialResult WARN_UNUSED_RETURN addGrowMemory(ExpressionType delta, ExpressionType&amp; result);
 315     PartialResult WARN_UNUSED_RETURN addCurrentMemory(ExpressionType&amp; result);
 316 
 317     // Basic operators
 318     template&lt;OpType&gt;
 319     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
 320     template&lt;OpType&gt;
 321     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
 322     PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
 323 
 324     // Control flow
 325     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
 326     ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<a name="9" id="anc9"></a><span class="line-modified"> 327     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t);</span>
 328     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<a name="10" id="anc10"></a><span class="line-modified"> 329     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);</span>
 330     PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
 331 
 332     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);
<a name="11" id="anc11"></a><span class="line-modified"> 333     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);</span>
<span class="line-modified"> 334     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);</span>
<span class="line-modified"> 335     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);</span>
 336     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
 337 
 338     // Calls
 339     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<a name="12" id="anc12"></a><span class="line-modified"> 340     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
 341     PartialResult WARN_UNUSED_RETURN addUnreachable();
 342 
<a name="13" id="anc13"></a><span class="line-modified"> 343     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
 344     void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
 345 
 346     Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
 347     void insertConstants();
 348 
 349     ALWAYS_INLINE void didKill(ExpressionType) { }
 350 
 351 private:
 352     void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
 353 
<a name="14" id="anc14"></a><span class="line-modified"> 354     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="line-added"> 355     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
 356 
<a name="15" id="anc15"></a><span class="line-added"> 357     void emitWriteBarrierForJSWrapper();</span>
 358     ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
 359     B3::Kind memoryKind(B3::Opcode memoryOp);
 360     ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
 361     void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 362 
 363     void unify(const ExpressionType phi, const ExpressionType source);
<a name="16" id="anc16"></a><span class="line-modified"> 364     void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);</span>
 365 
 366     void emitChecksForModOrDiv(B3::Opcode, ExpressionType left, ExpressionType right);
 367 
 368     int32_t WARN_UNUSED_RETURN fixupPointerPlusOffset(ExpressionType&amp;, uint32_t);
 369 
 370     void restoreWasmContextInstance(Procedure&amp;, BasicBlock*, Value*);
 371     enum class RestoreCachedStackLimit { No, Yes };
 372     void restoreWebAssemblyGlobalState(RestoreCachedStackLimit, const MemoryInformation&amp;, Value* instance, Procedure&amp;, BasicBlock*);
 373 
 374     Origin origin();
 375 
<a name="17" id="anc17"></a><span class="line-added"> 376     uint32_t outerLoopIndex() const</span>
<span class="line-added"> 377     {</span>
<span class="line-added"> 378         if (m_outerLoops.isEmpty())</span>
<span class="line-added"> 379             return UINT32_MAX;</span>
<span class="line-added"> 380         return m_outerLoops.last();</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382 </span>
 383     FunctionParser&lt;B3IRGenerator&gt;* m_parser { nullptr };
 384     const ModuleInformation&amp; m_info;
 385     const MemoryMode m_mode { MemoryMode::BoundsChecking };
 386     const CompilationMode m_compilationMode { CompilationMode::BBQMode };
 387     const unsigned m_functionIndex { UINT_MAX };
<a name="18" id="anc18"></a><span class="line-modified"> 388     const unsigned m_loopIndexForOSREntry { UINT_MAX };</span>
<span class="line-added"> 389     TierUpCount* m_tierUp { nullptr };</span>
 390 
 391     Procedure&amp; m_proc;
<a name="19" id="anc19"></a><span class="line-added"> 392     BasicBlock* m_rootBlock { nullptr };</span>
 393     BasicBlock* m_currentBlock { nullptr };
<a name="20" id="anc20"></a><span class="line-added"> 394     Vector&lt;uint32_t&gt; m_outerLoops;</span>
 395     Vector&lt;Variable*&gt; m_locals;
 396     Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.
<a name="21" id="anc21"></a><span class="line-added"> 397     unsigned&amp; m_osrEntryScratchBufferSize;</span>
 398     HashMap&lt;ValueKey, Value*&gt; m_constantPool;
 399     InsertionSet m_constantInsertionValues;
 400     GPRReg m_memoryBaseGPR { InvalidGPRReg };
 401     GPRReg m_memorySizeGPR { InvalidGPRReg };
 402     GPRReg m_wasmContextInstanceGPR { InvalidGPRReg };
 403     bool m_makesCalls { false };
 404 
 405     Value* m_instanceValue { nullptr }; // Always use the accessor below to ensure the instance value is materialized when used.
 406     bool m_usesInstanceValue { false };
 407     Value* instanceValue()
 408     {
 409         m_usesInstanceValue = true;
 410         return m_instanceValue;
 411     }
 412 
 413     uint32_t m_maxNumJSCallArguments { 0 };
<a name="22" id="anc22"></a><span class="line-added"> 414     unsigned m_numImportFunctions;</span>
 415 };
 416 
 417 // Memory accesses in WebAssembly have unsigned 32-bit offsets, whereas they have signed 32-bit offsets in B3.
 418 int32_t B3IRGenerator::fixupPointerPlusOffset(ExpressionType&amp; ptr, uint32_t offset)
 419 {
 420     if (static_cast&lt;uint64_t&gt;(offset) &gt; static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max())) {
 421         ptr = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), ptr, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), offset));
 422         return 0;
 423     }
 424     return offset;
 425 }
 426 
 427 void B3IRGenerator::restoreWasmContextInstance(Procedure&amp; proc, BasicBlock* block, Value* arg)
 428 {
 429     if (Context::useFastTLS()) {
 430         PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 431         if (CCallHelpers::storeWasmContextInstanceNeedsMacroScratchRegister())
 432             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 433         patchpoint-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
 434         patchpoint-&gt;setGenerator(
 435             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 436                 AllowMacroScratchRegisterUsageIf allowScratch(jit, CCallHelpers::storeWasmContextInstanceNeedsMacroScratchRegister());
 437                 jit.storeWasmContextInstance(params[0].gpr());
 438             });
 439         return;
 440     }
 441 
 442     // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 443     // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 444     PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 445     Effects effects = Effects::none();
 446     effects.writesPinned = true;
 447     effects.reads = B3::HeapRange::top();
 448     patchpoint-&gt;effects = effects;
 449     patchpoint-&gt;clobberLate(RegisterSet(m_wasmContextInstanceGPR));
 450     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
 451     GPRReg wasmContextInstanceGPR = m_wasmContextInstanceGPR;
 452     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
 453         jit.move(param[0].gpr(), wasmContextInstanceGPR);
 454     });
 455 }
 456 
<a name="23" id="anc23"></a><span class="line-modified"> 457 B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
 458     : m_info(info)
 459     , m_mode(mode)
 460     , m_compilationMode(compilationMode)
 461     , m_functionIndex(functionIndex)
<a name="24" id="anc24"></a><span class="line-added"> 462     , m_loopIndexForOSREntry(loopIndexForOSREntry)</span>
 463     , m_tierUp(tierUp)
 464     , m_proc(procedure)
 465     , m_unlinkedWasmToWasmCalls(unlinkedWasmToWasmCalls)
<a name="25" id="anc25"></a><span class="line-added"> 466     , m_osrEntryScratchBufferSize(osrEntryScratchBufferSize)</span>
 467     , m_constantInsertionValues(m_proc)
<a name="26" id="anc26"></a><span class="line-added"> 468     , m_numImportFunctions(info.importFunctionCount())</span>
 469 {
<a name="27" id="anc27"></a><span class="line-modified"> 470     m_rootBlock = m_proc.addBlock();</span>
<span class="line-added"> 471     m_currentBlock = m_rootBlock;</span>
 472 
 473     // FIXME we don&#39;t really need to pin registers here if there&#39;s no memory. It makes wasm -&gt; wasm thunks simpler for now. https://bugs.webkit.org/show_bug.cgi?id=166623
 474     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
 475 
 476     m_memoryBaseGPR = pinnedRegs.baseMemoryPointer;
 477     m_proc.pinRegister(m_memoryBaseGPR);
 478 
 479     m_wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
 480     if (!Context::useFastTLS())
 481         m_proc.pinRegister(m_wasmContextInstanceGPR);
 482 
 483     if (mode != MemoryMode::Signaling) {
<a name="28" id="anc28"></a><span class="line-modified"> 484         m_memorySizeGPR = pinnedRegs.sizeRegister;</span>
<span class="line-modified"> 485         m_proc.pinRegister(m_memorySizeGPR);</span>


 486     }
 487 
 488     if (throwWasmException)
 489         Thunks::singleton().setThrowWasmException(throwWasmException);
 490 
 491     if (info.memory) {
 492         m_proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
 493             AllowMacroScratchRegisterUsage allowScratch(jit);
 494             switch (m_mode) {
 495             case MemoryMode::BoundsChecking:
 496                 ASSERT_UNUSED(pinnedGPR, m_memorySizeGPR == pinnedGPR);
 497                 break;
 498             case MemoryMode::Signaling:
 499                 ASSERT_UNUSED(pinnedGPR, InvalidGPRReg == pinnedGPR);
 500                 break;
 501             }
 502             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
 503         });
 504 
 505         switch (m_mode) {
 506         case MemoryMode::BoundsChecking:
 507             break;
 508         case MemoryMode::Signaling:
 509             // Most memory accesses in signaling mode don&#39;t do an explicit
 510             // exception check because they can rely on fault handling to detect
 511             // out-of-bounds accesses. FaultSignalHandler nonetheless needs the
 512             // thunk to exist so that it can jump to that thunk.
 513             if (UNLIKELY(!Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator)))
 514                 CRASH();
 515             break;
 516         }
 517     }
 518 
 519     wasmCallingConvention().setupFrameInPrologue(&amp;compilation-&gt;calleeMoveLocation, m_proc, Origin(), m_currentBlock);
 520 
 521     {
 522         B3::Value* framePointer = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, Origin());
 523         B3::PatchpointValue* stackOverflowCheck = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, pointerType(), Origin());
 524         m_instanceValue = stackOverflowCheck;
 525         stackOverflowCheck-&gt;appendSomeRegister(framePointer);
 526         stackOverflowCheck-&gt;clobber(RegisterSet::macroScratchRegisters());
 527         if (!Context::useFastTLS()) {
 528             // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 529             // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 530             stackOverflowCheck-&gt;effects.writesPinned = false;
 531             stackOverflowCheck-&gt;effects.readsPinned = true;
<a name="29" id="anc29"></a><span class="line-modified"> 532             stackOverflowCheck-&gt;resultConstraints = { ValueRep::reg(m_wasmContextInstanceGPR) };</span>
 533         }
 534         stackOverflowCheck-&gt;numGPScratchRegisters = 2;
 535         stackOverflowCheck-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
 536             const Checked&lt;int32_t&gt; wasmFrameSize = params.proc().frameSize();
 537             const unsigned minimumParentCheckSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), 1024);
 538             const unsigned extraFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), std::max&lt;uint32_t&gt;(
 539                 // This allows us to elide stack checks for functions that are terminal nodes in the call
 540                 // tree, (e.g they don&#39;t make any calls) and have a small enough frame size. This works by
 541                 // having any such terminal node have its parent caller include some extra size in its
 542                 // own check for it. The goal here is twofold:
 543                 // 1. Emit less code.
 544                 // 2. Try to speed things up by skipping stack checks.
 545                 minimumParentCheckSize,
 546                 // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
 547                 // spill all arguments to the stack, we ensure that a stack check here covers the
 548                 // stack that such a stub would use.
 549                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jscCallingConvention().headerSizeInBytes()).unsafeGet()
 550             ));
 551             const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
 552             bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
 553             bool needsOverflowCheck = m_makesCalls || wasmFrameSize &gt;= minimumParentCheckSize || needUnderflowCheck;
 554 
 555             GPRReg contextInstance = Context::useFastTLS() ? params[0].gpr() : m_wasmContextInstanceGPR;
 556 
 557             // This allows leaf functions to not do stack checks if their frame size is within
 558             // certain limits since their caller would have already done the check.
 559             if (needsOverflowCheck) {
 560                 AllowMacroScratchRegisterUsage allowScratch(jit);
 561                 GPRReg fp = params[1].gpr();
 562                 GPRReg scratch1 = params.gpScratch(0);
 563                 GPRReg scratch2 = params.gpScratch(1);
 564 
 565                 if (Context::useFastTLS())
 566                     jit.loadWasmContextInstance(contextInstance);
 567 
 568                 jit.loadPtr(CCallHelpers::Address(contextInstance, Instance::offsetOfCachedStackLimit()), scratch2);
 569                 jit.addPtr(CCallHelpers::TrustedImm32(-checkSize), fp, scratch1);
 570                 MacroAssembler::JumpList overflow;
 571                 if (UNLIKELY(needUnderflowCheck))
 572                     overflow.append(jit.branchPtr(CCallHelpers::Above, scratch1, fp));
 573                 overflow.append(jit.branchPtr(CCallHelpers::Below, scratch1, scratch2));
 574                 jit.addLinkTask([overflow] (LinkBuffer&amp; linkBuffer) {
 575                     linkBuffer.link(overflow, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwStackOverflowFromWasmThunkGenerator).code()));
 576                 });
 577             } else if (m_usesInstanceValue &amp;&amp; Context::useFastTLS()) {
 578                 // No overflow check is needed, but the instance values still needs to be correct.
 579                 AllowMacroScratchRegisterUsageIf allowScratch(jit, CCallHelpers::loadWasmContextInstanceNeedsMacroScratchRegister());
 580                 jit.loadWasmContextInstance(contextInstance);
 581             } else {
 582                 // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
 583             }
 584         });
 585     }
 586 
<a name="30" id="anc30"></a><span class="line-modified"> 587     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), Origin());</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     if (m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 590         m_currentBlock = m_proc.addBlock();</span>
 591 }
 592 
 593 void B3IRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, Value* instance, Procedure&amp; proc, BasicBlock* block)
 594 {
 595     restoreWasmContextInstance(proc, block, instance);
 596 
 597     if (restoreCachedStackLimit == RestoreCachedStackLimit::Yes) {
 598         // The Instance caches the stack limit, but also knows where its canonical location is.
 599         Value* pointerToActualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfPointerToActualStackLimit()));
 600         Value* actualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), pointerToActualStackLimit);
 601         block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), actualStackLimit, instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfCachedStackLimit()));
 602     }
 603 
 604     if (!!memory) {
 605         const PinnedRegisterInfo* pinnedRegs = &amp;PinnedRegisterInfo::get();
 606         RegisterSet clobbers;
 607         clobbers.set(pinnedRegs-&gt;baseMemoryPointer);
<a name="31" id="anc31"></a><span class="line-modified"> 608         clobbers.set(pinnedRegs-&gt;sizeRegister);</span>
<span class="line-modified"> 609         if (!isARM64())</span>
<span class="line-added"> 610             clobbers.set(RegisterSet::macroScratchRegisters());</span>
 611 
 612         B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Void, origin());
 613         Effects effects = Effects::none();
 614         effects.writesPinned = true;
 615         effects.reads = B3::HeapRange::top();
 616         patchpoint-&gt;effects = effects;
 617         patchpoint-&gt;clobber(clobbers);
<a name="32" id="anc32"></a><span class="line-added"> 618         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
 619 
 620         patchpoint-&gt;append(instance, ValueRep::SomeRegister);
<a name="33" id="anc33"></a>
 621         patchpoint-&gt;setGenerator([pinnedRegs] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
<a name="34" id="anc34"></a><span class="line-added"> 622             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
 623             GPRReg baseMemory = pinnedRegs-&gt;baseMemoryPointer;
<a name="35" id="anc35"></a><span class="line-modified"> 624             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs-&gt;sizeRegister;</span>
<span class="line-modified"> 625 </span>
<span class="line-modified"> 626             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), pinnedRegs-&gt;sizeRegister);</span>

 627             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemory()), baseMemory);
<a name="36" id="anc36"></a><span class="line-modified"> 628 </span>
<span class="line-modified"> 629             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs-&gt;sizeRegister, scratchOrSize);</span>
 630         });
 631     }
 632 }
 633 
 634 void B3IRGenerator::emitExceptionCheck(CCallHelpers&amp; jit, ExceptionType type)
 635 {
 636     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;uint32_t&gt;(type)), GPRInfo::argumentGPR1);
 637     auto jumpToExceptionStub = jit.jump();
 638 
 639     jit.addLinkTask([jumpToExceptionStub] (LinkBuffer&amp; linkBuffer) {
 640         linkBuffer.link(jumpToExceptionStub, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator).code()));
 641     });
 642 }
 643 
 644 Value* B3IRGenerator::constant(B3::Type type, uint64_t bits, Optional&lt;Origin&gt; maybeOrigin)
 645 {
 646     auto result = m_constantPool.ensure(ValueKey(opcodeForConstant(type), type, static_cast&lt;int64_t&gt;(bits)), [&amp;] {
 647         Value* result = m_proc.addConstant(maybeOrigin ? *maybeOrigin : origin(), type, bits);
 648         m_constantInsertionValues.insertValue(0, result);
 649         return result;
 650     });
 651     return result.iterator-&gt;value;
 652 }
 653 
 654 void B3IRGenerator::insertConstants()
 655 {
 656     m_constantInsertionValues.execute(m_proc.at(0));
 657 }
 658 
 659 auto B3IRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
 660 {
<a name="37" id="anc37"></a><span class="line-modified"> 661     size_t newSize = m_locals.size() + count;</span>
<span class="line-modified"> 662     ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());</span>
<span class="line-modified"> 663     ASSERT(newSize &lt;= maxFunctionLocals);</span>
<span class="line-modified"> 664     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(newSize), &quot;can&#39;t allocate memory for &quot;, newSize, &quot; locals&quot;);</span>
 665 
 666     for (uint32_t i = 0; i &lt; count; ++i) {
 667         Variable* local = m_proc.addVariable(toB3Type(type));
 668         m_locals.uncheckedAppend(local);
<a name="38" id="anc38"></a><span class="line-modified"> 669         auto val = isSubtype(type, Anyref) ? JSValue::encode(jsNull()) : 0;</span>
<span class="line-added"> 670         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, constant(toB3Type(type), val, Origin()));</span>
 671     }
 672     return { };
 673 }
 674 
 675 auto B3IRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
 676 {
 677     ASSERT(!m_locals.size());
 678     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(signature.argumentCount()), &quot;can&#39;t allocate memory for &quot;, signature.argumentCount(), &quot; arguments&quot;);
 679 
 680     m_locals.grow(signature.argumentCount());
 681     wasmCallingConvention().loadArguments(signature, m_proc, m_currentBlock, Origin(),
 682         [=] (ExpressionType argument, unsigned i) {
 683             Variable* argumentVariable = m_proc.addVariable(argument-&gt;type());
 684             m_locals[i] = argumentVariable;
 685             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);
 686         });
 687     return { };
 688 }
 689 
<a name="39" id="anc39"></a><span class="line-added"> 690 auto B3IRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 691 {</span>
<span class="line-added"> 692     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Equal, origin(), value, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), JSValue::encode(jsNull())));</span>
<span class="line-added"> 693     return { };</span>
<span class="line-added"> 694 }</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696 auto B3IRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 697 {</span>
<span class="line-added"> 698     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 699     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(Anyref), origin(),</span>
<span class="line-added"> 700         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;getWasmTableElement, B3CCallPtrTag)),</span>
<span class="line-added"> 701         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index);</span>
<span class="line-added"> 702 </span>
<span class="line-added"> 703     {</span>
<span class="line-added"> 704         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 705             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 708             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 709         });</span>
<span class="line-added"> 710     }</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712     return { };</span>
<span class="line-added"> 713 }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715 auto B3IRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
<span class="line-added"> 716 {</span>
<span class="line-added"> 717     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 718     auto shouldThrow = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int32, origin(),</span>
<span class="line-added"> 719         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;setWasmTableElement, B3CCallPtrTag)),</span>
<span class="line-added"> 720         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index, value);</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722     {</span>
<span class="line-added"> 723         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 724             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), shouldThrow, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 727             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 728         });</span>
<span class="line-added"> 729     }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731     return { };</span>
<span class="line-added"> 732 }</span>
<span class="line-added"> 733 </span>
<span class="line-added"> 734 auto B3IRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 735 {</span>
<span class="line-added"> 736     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int64, origin(),</span>
<span class="line-added"> 739         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmRefFunc, B3CCallPtrTag)),</span>
<span class="line-added"> 740         instanceValue(), addConstant(Type::I32, index));</span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742     return { };</span>
<span class="line-added"> 743 }</span>
<span class="line-added"> 744 </span>
<span class="line-added"> 745 auto B3IRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 746 {</span>
<span class="line-added"> 747     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 748     uint32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; uint32_t {</span>
<span class="line-added"> 749         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added"> 750     };</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 753         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(doSize, B3CCallPtrTag)),</span>
<span class="line-added"> 754         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex));</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     return { };</span>
<span class="line-added"> 757 }</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759 auto B3IRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 762         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableGrow, B3CCallPtrTag)),</span>
<span class="line-added"> 763         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), fill, delta);</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765     return { };</span>
<span class="line-added"> 766 }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768 auto B3IRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
<span class="line-added"> 769 {</span>
<span class="line-added"> 770     auto result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 771         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableFill, B3CCallPtrTag)),</span>
<span class="line-added"> 772         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), offset, fill, count);</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     {</span>
<span class="line-added"> 775         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 776             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 779             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 780         });</span>
<span class="line-added"> 781     }</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783     return { };</span>
<span class="line-added"> 784 }</span>
<span class="line-added"> 785 </span>
 786 auto B3IRGenerator::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 787 {
 788     ASSERT(m_locals[index]);
 789     result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin(), m_locals[index]);
 790     return { };
 791 }
 792 
 793 auto B3IRGenerator::addUnreachable() -&gt; PartialResult
 794 {
 795     B3::PatchpointValue* unreachable = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());
 796     unreachable-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 797         this-&gt;emitExceptionCheck(jit, ExceptionType::Unreachable);
 798     });
 799     unreachable-&gt;effects.terminal = true;
 800     return { };
 801 }
 802 
 803 auto B3IRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
 804 {
 805     int32_t (*growMemory)(void*, Instance*, int32_t) = [] (void* callFrame, Instance* instance, int32_t delta) -&gt; int32_t {
 806         instance-&gt;storeTopCallFrame(callFrame);
 807 
 808         if (delta &lt; 0)
 809             return -1;
 810 
 811         auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));
 812         if (!grown) {
 813             switch (grown.error()) {
 814             case Memory::GrowFailReason::InvalidDelta:
 815             case Memory::GrowFailReason::InvalidGrowSize:
 816             case Memory::GrowFailReason::WouldExceedMaximum:
 817             case Memory::GrowFailReason::OutOfMemory:
 818                 return -1;
 819             }
 820             RELEASE_ASSERT_NOT_REACHED();
 821         }
 822 
 823         return grown.value().pageCount();
 824     };
 825 
 826     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(),
 827         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(growMemory, B3CCallPtrTag)),
 828         m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, origin()), instanceValue(), delta);
 829 
 830     restoreWebAssemblyGlobalState(RestoreCachedStackLimit::No, m_info.memory, instanceValue(), m_proc, m_currentBlock);
 831 
 832     return { };
 833 }
 834 
 835 auto B3IRGenerator::addCurrentMemory(ExpressionType&amp; result) -&gt; PartialResult
 836 {
 837     static_assert(sizeof(decltype(static_cast&lt;Memory*&gt;(nullptr)-&gt;size())) == sizeof(uint64_t), &quot;codegen relies on this size&quot;);
 838     Value* size = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int64, origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfCachedMemorySize()));
 839 
 840     constexpr uint32_t shiftValue = 16;
 841     static_assert(PageCount::pageSize == 1ull &lt;&lt; shiftValue, &quot;This must hold for the code below to be correct.&quot;);
 842     Value* numPages = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZShr, origin(),
 843         size, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), shiftValue));
 844 
 845     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Trunc, origin(), numPages);
 846 
 847     return { };
 848 }
 849 
 850 auto B3IRGenerator::setLocal(uint32_t index, ExpressionType value) -&gt; PartialResult
 851 {
 852     ASSERT(m_locals[index]);
 853     m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Set, origin(), m_locals[index], value);
 854     return { };
 855 }
 856 
 857 auto B3IRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 858 {
 859     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 860     result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(m_info.globals[index].type), origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
 861     return { };
 862 }
 863 
 864 auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
 865 {
 866     ASSERT(toB3Type(m_info.globals[index].type) == value-&gt;type());
 867     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 868     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
<a name="40" id="anc40"></a><span class="line-added"> 869 </span>
<span class="line-added"> 870     if (isSubtype(m_info.globals[index].type, Anyref))</span>
<span class="line-added"> 871         emitWriteBarrierForJSWrapper();</span>
<span class="line-added"> 872 </span>
 873     return { };
 874 }
 875 
<a name="41" id="anc41"></a><span class="line-added"> 876 inline void B3IRGenerator::emitWriteBarrierForJSWrapper()</span>
<span class="line-added"> 877 {</span>
<span class="line-added"> 878     Value* cell = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfOwner()));</span>
<span class="line-added"> 879     Value* cellState = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added"> 880     Value* vm = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), cell, safeCast&lt;int32_t&gt;(JSWebAssemblyInstance::offsetOfVM()));</span>
<span class="line-added"> 881     Value* threshold = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapBarrierThreshold()));</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883     BasicBlock* fenceCheckPath = m_proc.addBlock();</span>
<span class="line-added"> 884     BasicBlock* fencePath = m_proc.addBlock();</span>
<span class="line-added"> 885     BasicBlock* doSlowPath = m_proc.addBlock();</span>
<span class="line-added"> 886     BasicBlock* continuation = m_proc.addBlock();</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 889         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellState, threshold),</span>
<span class="line-added"> 890         FrequentedBlock(continuation), FrequentedBlock(fenceCheckPath, FrequencyClass::Rare));</span>
<span class="line-added"> 891     fenceCheckPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 892     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 893     m_currentBlock = fenceCheckPath;</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895     Value* shouldFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapMutatorShouldBeFenced()));</span>
<span class="line-added"> 896     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 897         shouldFence,</span>
<span class="line-added"> 898         FrequentedBlock(fencePath), FrequentedBlock(doSlowPath));</span>
<span class="line-added"> 899     fencePath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 900     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 901     m_currentBlock = fencePath;</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903     B3::PatchpointValue* doFence = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());</span>
<span class="line-added"> 904     doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 905         jit.memoryFence();</span>
<span class="line-added"> 906     });</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908     Value* cellStateLoadAfterFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added"> 909     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 910         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellStateLoadAfterFence, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), blackThreshold)),</span>
<span class="line-added"> 911         FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));</span>
<span class="line-added"> 912     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 913     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 914     m_currentBlock = doSlowPath;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="line-added"> 917         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="line-added"> 918     };</span>
<span class="line-added"> 919 </span>
<span class="line-added"> 920     Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(writeBarrier, B3CCallPtrTag));</span>
<span class="line-added"> 921     m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);</span>
<span class="line-added"> 922     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 925     m_currentBlock = continuation;</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
 928 inline Value* B3IRGenerator::emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOperation)
 929 {
 930     ASSERT(m_memoryBaseGPR);
 931 
 932     switch (m_mode) {
 933     case MemoryMode::BoundsChecking: {
 934         // We&#39;re not using signal handling at all, we must therefore check that no memory access exceeds the current memory size.
 935         ASSERT(m_memorySizeGPR);
 936         ASSERT(sizeOfOperation + offset &gt; offset);
 937         m_currentBlock-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(m_proc, origin(), m_memorySizeGPR, pointer, sizeOfOperation + offset - 1);
 938         break;
 939     }
 940 
 941     case MemoryMode::Signaling: {
 942         // We&#39;ve virtually mapped 4GiB+redzone for this memory. Only the user-allocated pages are addressable, contiguously in range [0, current],
 943         // and everything above is mapped PROT_NONE. We don&#39;t need to perform any explicit bounds check in the 4GiB range because WebAssembly register
 944         // memory accesses are 32-bit. However WebAssembly register + offset accesses perform the addition in 64-bit which can push an access above
 945         // the 32-bit limit (the offset is unsigned 32-bit). The redzone will catch most small offsets, and we&#39;ll explicitly bounds check any
 946         // register + large offset access. We don&#39;t think this will be generated frequently.
 947         //
 948         // We could check that register + large offset doesn&#39;t exceed 4GiB+redzone since that&#39;s technically the limit we need to avoid overflowing the
 949         // PROT_NONE region, but it&#39;s better if we use a smaller immediate because it can codegens better. We know that anything equal to or greater
 950         // than the declared &#39;maximum&#39; will trap, so we can compare against that number. If there was no declared &#39;maximum&#39; then we still know that
 951         // any access equal to or greater than 4GiB will trap, no need to add the redzone.
 952         if (offset &gt;= Memory::fastMappedRedzoneBytes()) {
 953             size_t maximum = m_info.memory.maximum() ? m_info.memory.maximum().bytes() : std::numeric_limits&lt;uint32_t&gt;::max();
 954             m_currentBlock-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(m_proc, origin(), pointer, sizeOfOperation + offset - 1, maximum);
 955         }
 956         break;
 957     }
 958     }
 959 
 960     pointer = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), pointer);
 961     return m_currentBlock-&gt;appendNew&lt;WasmAddressValue&gt;(m_proc, origin(), pointer, m_memoryBaseGPR);
 962 }
 963 
 964 inline uint32_t sizeOfLoadOp(LoadOpType op)
 965 {
 966     switch (op) {
 967     case LoadOpType::I32Load8S:
 968     case LoadOpType::I32Load8U:
 969     case LoadOpType::I64Load8S:
 970     case LoadOpType::I64Load8U:
 971         return 1;
 972     case LoadOpType::I32Load16S:
 973     case LoadOpType::I64Load16S:
 974     case LoadOpType::I32Load16U:
 975     case LoadOpType::I64Load16U:
 976         return 2;
 977     case LoadOpType::I32Load:
 978     case LoadOpType::I64Load32S:
 979     case LoadOpType::I64Load32U:
 980     case LoadOpType::F32Load:
 981         return 4;
 982     case LoadOpType::I64Load:
 983     case LoadOpType::F64Load:
 984         return 8;
 985     }
 986     RELEASE_ASSERT_NOT_REACHED();
 987 }
 988 
 989 inline B3::Kind B3IRGenerator::memoryKind(B3::Opcode memoryOp)
 990 {
 991     if (m_mode == MemoryMode::Signaling)
 992         return trapping(memoryOp);
 993     return memoryOp;
 994 }
 995 
 996 inline Value* B3IRGenerator::emitLoadOp(LoadOpType op, ExpressionType pointer, uint32_t uoffset)
 997 {
 998     int32_t offset = fixupPointerPlusOffset(pointer, uoffset);
 999 
1000     switch (op) {
1001     case LoadOpType::I32Load8S: {
1002         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load8S), origin(), pointer, offset);
1003     }
1004 
1005     case LoadOpType::I64Load8S: {
1006         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load8S), origin(), pointer, offset);
1007         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, SExt32, origin(), value);
1008     }
1009 
1010     case LoadOpType::I32Load8U: {
1011         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load8Z), origin(), pointer, offset);
1012     }
1013 
1014     case LoadOpType::I64Load8U: {
1015         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load8Z), origin(), pointer, offset);
1016         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), value);
1017     }
1018 
1019     case LoadOpType::I32Load16S: {
1020         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load16S), origin(), pointer, offset);
1021     }
1022 
1023     case LoadOpType::I64Load16S: {
1024         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load16S), origin(), pointer, offset);
1025         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, SExt32, origin(), value);
1026     }
1027 
1028     case LoadOpType::I32Load16U: {
1029         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load16Z), origin(), pointer, offset);
1030     }
1031 
1032     case LoadOpType::I64Load16U: {
1033         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load16Z), origin(), pointer, offset);
1034         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), value);
1035     }
1036 
1037     case LoadOpType::I32Load: {
1038         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Int32, origin(), pointer, offset);
1039     }
1040 
1041     case LoadOpType::I64Load32U: {
1042         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Int32, origin(), pointer, offset);
1043         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), value);
1044     }
1045 
1046     case LoadOpType::I64Load32S: {
1047         Value* value = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Int32, origin(), pointer, offset);
1048         return m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, SExt32, origin(), value);
1049     }
1050 
1051     case LoadOpType::I64Load: {
1052         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Int64, origin(), pointer, offset);
1053     }
1054 
1055     case LoadOpType::F32Load: {
1056         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Float, origin(), pointer, offset);
1057     }
1058 
1059     case LoadOpType::F64Load: {
1060         return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Load), Double, origin(), pointer, offset);
1061     }
1062     }
1063     RELEASE_ASSERT_NOT_REACHED();
1064 }
1065 
1066 auto B3IRGenerator::load(LoadOpType op, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset) -&gt; PartialResult
1067 {
1068     ASSERT(pointer-&gt;type() == Int32);
1069 
1070     if (UNLIKELY(sumOverflows&lt;uint32_t&gt;(offset, sizeOfLoadOp(op)))) {
1071         // FIXME: Even though this is provably out of bounds, it&#39;s not a validation error, so we have to handle it
1072         // as a runtime exception. However, this may change: https://bugs.webkit.org/show_bug.cgi?id=166435
1073         B3::PatchpointValue* throwException = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());
1074         throwException-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1075             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
1076         });
1077 
1078         switch (op) {
1079         case LoadOpType::I32Load8S:
1080         case LoadOpType::I32Load16S:
1081         case LoadOpType::I32Load:
1082         case LoadOpType::I32Load16U:
1083         case LoadOpType::I32Load8U:
1084             result = constant(Int32, 0);
1085             break;
1086         case LoadOpType::I64Load8S:
1087         case LoadOpType::I64Load8U:
1088         case LoadOpType::I64Load16S:
1089         case LoadOpType::I64Load32U:
1090         case LoadOpType::I64Load32S:
1091         case LoadOpType::I64Load:
1092         case LoadOpType::I64Load16U:
1093             result = constant(Int64, 0);
1094             break;
1095         case LoadOpType::F32Load:
1096             result = constant(Float, 0);
1097             break;
1098         case LoadOpType::F64Load:
1099             result = constant(Double, 0);
1100             break;
1101         }
1102 
1103     } else
1104         result = emitLoadOp(op, emitCheckAndPreparePointer(pointer, offset, sizeOfLoadOp(op)), offset);
1105 
1106     return { };
1107 }
1108 
1109 inline uint32_t sizeOfStoreOp(StoreOpType op)
1110 {
1111     switch (op) {
1112     case StoreOpType::I32Store8:
1113     case StoreOpType::I64Store8:
1114         return 1;
1115     case StoreOpType::I32Store16:
1116     case StoreOpType::I64Store16:
1117         return 2;
1118     case StoreOpType::I32Store:
1119     case StoreOpType::I64Store32:
1120     case StoreOpType::F32Store:
1121         return 4;
1122     case StoreOpType::I64Store:
1123     case StoreOpType::F64Store:
1124         return 8;
1125     }
1126     RELEASE_ASSERT_NOT_REACHED();
1127 }
1128 
1129 
1130 inline void B3IRGenerator::emitStoreOp(StoreOpType op, ExpressionType pointer, ExpressionType value, uint32_t uoffset)
1131 {
1132     int32_t offset = fixupPointerPlusOffset(pointer, uoffset);
1133 
1134     switch (op) {
1135     case StoreOpType::I64Store8:
1136         value = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Trunc, origin(), value);
1137         FALLTHROUGH;
1138 
1139     case StoreOpType::I32Store8:
1140         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Store8), origin(), value, pointer, offset);
1141         return;
1142 
1143     case StoreOpType::I64Store16:
1144         value = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Trunc, origin(), value);
1145         FALLTHROUGH;
1146 
1147     case StoreOpType::I32Store16:
1148         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Store16), origin(), value, pointer, offset);
1149         return;
1150 
1151     case StoreOpType::I64Store32:
1152         value = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Trunc, origin(), value);
1153         FALLTHROUGH;
1154 
1155     case StoreOpType::I64Store:
1156     case StoreOpType::I32Store:
1157     case StoreOpType::F32Store:
1158     case StoreOpType::F64Store:
1159         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, memoryKind(Store), origin(), value, pointer, offset);
1160         return;
1161     }
1162     RELEASE_ASSERT_NOT_REACHED();
1163 }
1164 
1165 auto B3IRGenerator::store(StoreOpType op, ExpressionType pointer, ExpressionType value, uint32_t offset) -&gt; PartialResult
1166 {
1167     ASSERT(pointer-&gt;type() == Int32);
1168 
1169     if (UNLIKELY(sumOverflows&lt;uint32_t&gt;(offset, sizeOfStoreOp(op)))) {
1170         // FIXME: Even though this is provably out of bounds, it&#39;s not a validation error, so we have to handle it
1171         // as a runtime exception. However, this may change: https://bugs.webkit.org/show_bug.cgi?id=166435
1172         B3::PatchpointValue* throwException = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());
1173         throwException-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1174             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
1175         });
1176     } else
1177         emitStoreOp(op, emitCheckAndPreparePointer(pointer, offset, sizeOfStoreOp(op)), value, offset);
1178 
1179     return { };
1180 }
1181 
1182 auto B3IRGenerator::addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result) -&gt; PartialResult
1183 {
1184     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Select, origin(), condition, nonZero, zero);
1185     return { };
1186 }
1187 
1188 B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
1189 {
1190     return constant(toB3Type(type), value);
1191 }
1192 
<a name="42" id="anc42"></a><span class="line-modified">1193 void B3IRGenerator::emitEntryTierUpCheck(int32_t incrementCount, Origin origin)</span>
1194 {
1195     if (!m_tierUp)
1196         return;
1197 
1198     ASSERT(m_tierUp);
<a name="43" id="anc43"></a><span class="line-modified">1199     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>



1200 
1201     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
1202     Effects effects = Effects::none();
1203     // FIXME: we should have a more precise heap range for the tier up count.
1204     effects.reads = B3::HeapRange::top();
1205     effects.writes = B3::HeapRange::top();
1206     patch-&gt;effects = effects;
<a name="44" id="anc44"></a><span class="line-added">1207     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
1208 
<a name="45" id="anc45"></a><span class="line-modified">1209     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>

1210     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<a name="46" id="anc46"></a><span class="line-modified">1211         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-modified">1212         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="line-added">1213         CCallHelpers::Label tierUpResume = jit.label();</span>
1214 
1215         params.addLatePath([=] (CCallHelpers&amp; jit) {
1216             tierUp.link(&amp;jit);
1217 
1218             const unsigned extraPaddingBytes = 0;
1219             RegisterSet registersToSpill = { };
1220             registersToSpill.add(GPRInfo::argumentGPR1);
1221             unsigned numberOfStackBytesUsedForRegisterPreservation = ScratchRegisterAllocator::preserveRegistersToStackForCall(jit, registersToSpill, extraPaddingBytes);
1222 
1223             jit.move(MacroAssembler::TrustedImm32(m_functionIndex), GPRInfo::argumentGPR1);
1224             MacroAssembler::Call call = jit.nearCall();
1225 
1226             ScratchRegisterAllocator::restoreRegistersFromStackForCall(jit, registersToSpill, RegisterSet(), numberOfStackBytesUsedForRegisterPreservation, extraPaddingBytes);
1227             jit.jump(tierUpResume);
1228 
1229             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<a name="47" id="anc47"></a><span class="line-modified">1230                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGEntryTierUpThunkGenerator).code()));</span>

1231             });
1232         });
1233     });
1234 }
1235 
<a name="48" id="anc48"></a><span class="line-modified">1236 void B3IRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
<span class="line-added">1237 {</span>
<span class="line-added">1238     if (!m_tierUp)</span>
<span class="line-added">1239         return;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241     ASSERT(m_tierUp);</span>
<span class="line-added">1242 </span>
<span class="line-added">1243     ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);</span>
<span class="line-added">1244     m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);</span>
<span class="line-added">1245     m_tierUp-&gt;outerLoops().append(outerLoopIndex);</span>
<span class="line-added">1246 </span>
<span class="line-added">1247     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     Vector&lt;ExpressionType&gt; stackmap;</span>
<span class="line-added">1250     Vector&lt;B3::Type&gt; types;</span>
<span class="line-added">1251     for (auto&amp; local : m_locals) {</span>
<span class="line-added">1252         ExpressionType result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin, local);</span>
<span class="line-added">1253         stackmap.append(result);</span>
<span class="line-added">1254         types.append(result-&gt;type());</span>
<span class="line-added">1255     }</span>
<span class="line-added">1256     for (unsigned i = 0; i &lt; expressionStack.size(); ++i) {</span>
<span class="line-added">1257         ExpressionType result = expressionStack.at(i);</span>
<span class="line-added">1258         stackmap.append(result);</span>
<span class="line-added">1259         types.append(result-&gt;type());</span>
<span class="line-added">1260     }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);</span>
<span class="line-added">1263     Effects effects = Effects::none();</span>
<span class="line-added">1264     // FIXME: we should have a more precise heap range for the tier up count.</span>
<span class="line-added">1265     effects.reads = B3::HeapRange::top();</span>
<span class="line-added">1266     effects.writes = B3::HeapRange::top();</span>
<span class="line-added">1267     effects.exitsSideways = true;</span>
<span class="line-added">1268     patch-&gt;effects = effects;</span>
<span class="line-added">1269 </span>
<span class="line-added">1270     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="line-added">1271     RegisterSet clobberLate;</span>
<span class="line-added">1272     clobberLate.add(GPRInfo::argumentGPR0);</span>
<span class="line-added">1273     patch-&gt;clobberLate(clobberLate);</span>
<span class="line-added">1274 </span>
<span class="line-added">1275     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>
<span class="line-added">1276     patch-&gt;appendVectorWithRep(stackmap, ValueRep::ColdAny);</span>
<span class="line-added">1277 </span>
<span class="line-added">1278     TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());</span>
<span class="line-added">1279     static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);</span>
<span class="line-added">1280     static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);</span>
<span class="line-added">1281     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">1282         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">1283         CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));</span>
<span class="line-added">1284         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="line-added">1285         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);</span>
<span class="line-added">1288         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="line-added">1289             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
<span class="line-added">1290         OSREntryData* osrEntryDataPtr = &amp;osrEntryData;</span>
<span class="line-added">1291 </span>
<span class="line-added">1292         params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1293             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">1294             forceOSREntry.link(&amp;jit);</span>
<span class="line-added">1295             tierUp.link(&amp;jit);</span>
<span class="line-added">1296 </span>
<span class="line-added">1297             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
<span class="line-added">1298             jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);</span>
<span class="line-added">1299             jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);</span>
<span class="line-added">1300         });</span>
<span class="line-added">1301     });</span>
<span class="line-added">1302 }</span>
<span class="line-added">1303 </span>
<span class="line-added">1304 B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature, const Stack&amp; stack, uint32_t loopIndex)</span>
1305 {
1306     BasicBlock* body = m_proc.addBlock();
1307     BasicBlock* continuation = m_proc.addBlock();
1308 
1309     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
<a name="49" id="anc49"></a><span class="line-added">1310     if (loopIndex == m_loopIndexForOSREntry) {</span>
<span class="line-added">1311         m_currentBlock = m_rootBlock;</span>
<span class="line-added">1312         m_osrEntryScratchBufferSize = m_locals.size() + stack.size();</span>
<span class="line-added">1313         Value* pointer = m_rootBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(m_proc, Origin(), GPRInfo::argumentGPR0);</span>
<span class="line-added">1314 </span>
<span class="line-added">1315         auto loadFromScratchBuffer = [&amp;] (B3::Type type, unsigned index) {</span>
<span class="line-added">1316             size_t offset = sizeof(uint64_t) * index;</span>
<span class="line-added">1317             switch (type.kind()) {</span>
<span class="line-added">1318             case B3::Int32:</span>
<span class="line-added">1319                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), pointer, offset);</span>
<span class="line-added">1320             case B3::Int64:</span>
<span class="line-added">1321                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), pointer, offset);</span>
<span class="line-added">1322             case B3::Float:</span>
<span class="line-added">1323                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Float, origin(), pointer, offset);</span>
<span class="line-added">1324             case B3::Double:</span>
<span class="line-added">1325                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Double, origin(), pointer, offset);</span>
<span class="line-added">1326             default:</span>
<span class="line-added">1327                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1328                 break;</span>
<span class="line-added">1329             }</span>
<span class="line-added">1330         };</span>
<span class="line-added">1331 </span>
<span class="line-added">1332         unsigned indexInBuffer = 0;</span>
<span class="line-added">1333         for (auto&amp; local : m_locals)</span>
<span class="line-added">1334             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, loadFromScratchBuffer(local-&gt;type(), indexInBuffer++));</span>
<span class="line-added">1335         for (unsigned i = 0; i &lt; stack.size(); ++i) {</span>
<span class="line-added">1336             auto* variable = stack.variableAt(i);</span>
<span class="line-added">1337             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), variable, loadFromScratchBuffer(variable-&gt;type(), indexInBuffer++));</span>
<span class="line-added">1338         }</span>
<span class="line-added">1339         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);</span>
<span class="line-added">1340         body-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">1341     }</span>
1342 
<a name="50" id="anc50"></a><span class="line-added">1343     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-added">1344     m_outerLoops.append(loopIndex);</span>
1345     m_currentBlock = body;
<a name="51" id="anc51"></a><span class="line-modified">1346     emitLoopTierUpCheck(TierUpCount::loopIncrement(), stack, loopIndex, outerLoopIndex, origin());</span>
1347 
1348     return ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);
1349 }
1350 
1351 B3IRGenerator::ControlData B3IRGenerator::addTopLevel(Type signature)
1352 {
1353     return ControlData(m_proc, Origin(), signature, BlockType::TopLevel, m_proc.addBlock());
1354 }
1355 
1356 B3IRGenerator::ControlData B3IRGenerator::addBlock(Type signature)
1357 {
1358     return ControlData(m_proc, origin(), signature, BlockType::Block, m_proc.addBlock());
1359 }
1360 
1361 auto B3IRGenerator::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; PartialResult
1362 {
1363     // FIXME: This needs to do some kind of stack passing.
1364 
1365     BasicBlock* taken = m_proc.addBlock();
1366     BasicBlock* notTaken = m_proc.addBlock();
1367     BasicBlock* continuation = m_proc.addBlock();
1368 
1369     m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
1370     m_currentBlock-&gt;setSuccessors(FrequentedBlock(taken), FrequentedBlock(notTaken));
1371     taken-&gt;addPredecessor(m_currentBlock);
1372     notTaken-&gt;addPredecessor(m_currentBlock);
1373 
1374     m_currentBlock = taken;
1375     result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
1376     return { };
1377 }
1378 
<a name="52" id="anc52"></a><span class="line-modified">1379 auto B3IRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult</span>
1380 {
1381     unifyValuesWithBlock(currentStack, data.result);
1382     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
1383     return addElseToUnreachable(data);
1384 }
1385 
1386 auto B3IRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
1387 {
1388     ASSERT(data.type() == BlockType::If);
1389     m_currentBlock = data.special;
1390     data.convertIfToBlock();
1391     return { };
1392 }
1393 
1394 auto B3IRGenerator::addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues) -&gt; PartialResult
1395 {
1396     ASSERT(returnValues.size() &lt;= 1);
1397     if (returnValues.size())
1398         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin(), returnValues[0]);
1399     else
1400         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin());
1401     return { };
1402 }
1403 
<a name="53" id="anc53"></a><span class="line-modified">1404 auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult</span>
1405 {
1406     unifyValuesWithBlock(returnValues, data.resultForBranch());
1407 
1408     BasicBlock* target = data.targetBlockForBranch();
1409     if (condition) {
1410         BasicBlock* continuation = m_proc.addBlock();
1411         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
1412         m_currentBlock-&gt;setSuccessors(FrequentedBlock(target), FrequentedBlock(continuation));
1413         target-&gt;addPredecessor(m_currentBlock);
1414         continuation-&gt;addPredecessor(m_currentBlock);
1415         m_currentBlock = continuation;
1416     } else {
1417         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), FrequentedBlock(target));
1418         target-&gt;addPredecessor(m_currentBlock);
1419     }
1420 
1421     return { };
1422 }
1423 
<a name="54" id="anc54"></a><span class="line-modified">1424 auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult</span>
1425 {
1426     for (size_t i = 0; i &lt; targets.size(); ++i)
1427         unifyValuesWithBlock(expressionStack, targets[i]-&gt;resultForBranch());
1428     unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());
1429 
1430     SwitchValue* switchValue = m_currentBlock-&gt;appendNew&lt;SwitchValue&gt;(m_proc, origin(), condition);
1431     switchValue-&gt;setFallThrough(FrequentedBlock(defaultTarget.targetBlockForBranch()));
1432     for (size_t i = 0; i &lt; targets.size(); ++i)
1433         switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
1434 
1435     return { };
1436 }
1437 
<a name="55" id="anc55"></a><span class="line-modified">1438 auto B3IRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult</span>
1439 {
1440     ControlData&amp; data = entry.controlData;
1441 
1442     unifyValuesWithBlock(expressionStack, data.result);
1443     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
1444     data.continuation-&gt;addPredecessor(m_currentBlock);
1445 
<a name="56" id="anc56"></a><span class="line-added">1446     if (data.type() == BlockType::Loop)</span>
<span class="line-added">1447         m_outerLoops.removeLast();</span>
<span class="line-added">1448 </span>
1449     return addEndToUnreachable(entry);
1450 }
1451 
1452 
1453 auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult
1454 {
1455     ControlData&amp; data = entry.controlData;
1456     m_currentBlock = data.continuation;
1457 
1458     if (data.type() == BlockType::If) {
1459         data.special-&gt;appendNewControlValue(m_proc, Jump, origin(), m_currentBlock);
1460         m_currentBlock-&gt;addPredecessor(data.special);
1461     }
1462 
1463     for (Value* result : data.result) {
1464         m_currentBlock-&gt;append(result);
1465         entry.enclosedExpressionStack.append(result);
1466     }
1467 
1468     // TopLevel does not have any code after this so we need to make sure we emit a return here.
1469     if (data.type() == BlockType::TopLevel)
<a name="57" id="anc57"></a><span class="line-modified">1470         return addReturn(entry.controlData, entry.enclosedExpressionStack.convertToExpressionList());</span>
1471 
1472     return { };
1473 }
1474 
1475 auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult
1476 {
1477     ASSERT(signature.argumentCount() == args.size());
1478 
1479     m_makesCalls = true;
1480 
1481     Type returnType = signature.returnType();
1482     Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
1483 
1484     if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
1485         m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1486 
1487         // FIXME imports can be linked here, instead of generating a patchpoint, because all import stubs are generated before B3 compilation starts. https://bugs.webkit.org/show_bug.cgi?id=166462
1488         Value* targetInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTargetInstance(functionIndex)));
1489         // The target instance is 0 unless the call is wasm-&gt;wasm.
1490         Value* isWasmCall = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), targetInstance, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0));
1491 
1492         BasicBlock* isWasmBlock = m_proc.addBlock();
1493         BasicBlock* isEmbedderBlock = m_proc.addBlock();
1494         BasicBlock* continuation = m_proc.addBlock();
1495         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(), isWasmCall, FrequentedBlock(isWasmBlock), FrequentedBlock(isEmbedderBlock));
1496 
1497         Value* wasmCallResult = wasmCallingConvention().setupCall(m_proc, isWasmBlock, origin(), args, toB3Type(returnType),
1498             [=] (PatchpointValue* patchpoint) {
1499                 patchpoint-&gt;effects.writesPinned = true;
1500                 patchpoint-&gt;effects.readsPinned = true;
1501                 // We need to clobber all potential pinned registers since we might be leaving the instance.
1502                 // We pessimistically assume we could be calling to something that is bounds checking.
1503                 // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
1504                 patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1505                 patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1506                     AllowMacroScratchRegisterUsage allowScratch(jit);
1507                     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
1508                     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
1509                         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
1510                     });
1511                 });
1512             });
1513         UpsilonValue* wasmCallResultUpsilon = returnType == Void ? nullptr : isWasmBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), wasmCallResult);
1514         isWasmBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
1515 
1516         // FIXME: Let&#39;s remove this indirection by creating a PIC friendly IC
1517         // for calls out to the embedder. This shouldn&#39;t be that hard to do. We could probably
1518         // implement the IC to be over Context*.
1519         // https://bugs.webkit.org/show_bug.cgi?id=170375
1520         Value* jumpDestination = isEmbedderBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc,
1521             Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfWasmToEmbedderStub(functionIndex)));
1522 
1523         Value* embedderCallResult = wasmCallingConvention().setupCall(m_proc, isEmbedderBlock, origin(), args, toB3Type(returnType),
1524             [=] (PatchpointValue* patchpoint) {
1525                 patchpoint-&gt;effects.writesPinned = true;
1526                 patchpoint-&gt;effects.readsPinned = true;
1527                 patchpoint-&gt;append(jumpDestination, ValueRep::SomeRegister);
1528                 // We need to clobber all potential pinned registers since we might be leaving the instance.
1529                 // We pessimistically assume we could be calling to something that is bounds checking.
1530                 // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
1531                 patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1532                 patchpoint-&gt;setGenerator([returnType] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1533                     AllowMacroScratchRegisterUsage allowScratch(jit);
1534                     jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);
1535                 });
1536             });
1537         UpsilonValue* embedderCallResultUpsilon = returnType == Void ? nullptr : isEmbedderBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), embedderCallResult);
1538         isEmbedderBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
1539 
1540         m_currentBlock = continuation;
1541 
1542         if (returnType == Void)
1543             result = nullptr;
1544         else {
1545             result = continuation-&gt;appendNew&lt;Value&gt;(m_proc, Phi, toB3Type(returnType), origin());
1546             wasmCallResultUpsilon-&gt;setPhi(result);
1547             embedderCallResultUpsilon-&gt;setPhi(result);
1548         }
1549 
1550         // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
1551         restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, continuation);
1552     } else {
1553         result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1554             [=] (PatchpointValue* patchpoint) {
1555                 patchpoint-&gt;effects.writesPinned = true;
1556                 patchpoint-&gt;effects.readsPinned = true;
1557 
1558                 patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1559                     AllowMacroScratchRegisterUsage allowScratch(jit);
1560                     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
1561                     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
1562                         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
1563                     });
1564                 });
1565             });
1566     }
1567 
1568     return { };
1569 }
1570 
<a name="58" id="anc58"></a><span class="line-modified">1571 auto B3IRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
1572 {
1573     ExpressionType calleeIndex = args.takeLast();
1574     ASSERT(signature.argumentCount() == args.size());
1575 
1576     m_makesCalls = true;
1577     // Note: call indirect can call either WebAssemblyFunction or WebAssemblyWrapperFunction. Because
1578     // WebAssemblyWrapperFunction is like calling into the embedder, we conservatively assume all call indirects
1579     // can be to the embedder for our stack check calculation.
1580     m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1581 
1582     ExpressionType callableFunctionBuffer;
1583     ExpressionType instancesBuffer;
1584     ExpressionType callableFunctionBufferLength;
1585     ExpressionType mask;
1586     {
1587         ExpressionType table = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<a name="59" id="anc59"></a><span class="line-modified">1588             instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)));</span>
1589         callableFunctionBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<a name="60" id="anc60"></a><span class="line-modified">1590             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfFunctions()));</span>
1591         instancesBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<a name="61" id="anc61"></a><span class="line-modified">1592             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfInstances()));</span>
1593         callableFunctionBufferLength = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1594             table, safeCast&lt;int32_t&gt;(Table::offsetOfLength()));
1595         mask = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(),
1596             m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1597                 table, safeCast&lt;int32_t&gt;(Table::offsetOfMask())));
1598     }
1599 
1600     // Check the index we are looking for is valid.
1601     {
1602         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1603             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, AboveEqual, origin(), calleeIndex, callableFunctionBufferLength));
1604 
1605         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1606             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsCallIndirect);
1607         });
1608     }
1609 
1610     calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), calleeIndex);
1611 
1612     if (Options::enableSpectreMitigations())
1613         calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(), mask, calleeIndex);
1614 
1615     ExpressionType callableFunction;
1616     {
1617         // Compute the offset in the table index space we are looking for.
1618         ExpressionType offset = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Mul, origin(),
1619             calleeIndex, constant(pointerType(), sizeof(WasmToWasmImportableFunction)));
1620         callableFunction = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), callableFunctionBuffer, offset);
1621 
1622         // Check that the WasmToWasmImportableFunction is initialized. We trap if it isn&#39;t. An &quot;invalid&quot; SignatureIndex indicates it&#39;s not initialized.
1623         // FIXME: when we have trap handlers, we can just let the call fail because Signature::invalidIndex is 0. https://bugs.webkit.org/show_bug.cgi?id=177210
1624         static_assert(sizeof(WasmToWasmImportableFunction::signatureIndex) == sizeof(uint64_t), &quot;Load codegen assumes i64&quot;);
1625         ExpressionType calleeSignatureIndex = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int64, origin(), callableFunction, safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfSignatureIndex()));
1626         {
1627             CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1628                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(),
1629                     calleeSignatureIndex,
1630                     m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), Signature::invalidIndex)));
1631 
1632             check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1633                 this-&gt;emitExceptionCheck(jit, ExceptionType::NullTableEntry);
1634             });
1635         }
1636 
1637         // Check the signature matches the value we expect.
1638         {
1639             ExpressionType expectedSignatureIndex = m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), SignatureInformation::get(signature));
1640             CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1641                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), calleeSignatureIndex, expectedSignatureIndex));
1642 
1643             check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1644                 this-&gt;emitExceptionCheck(jit, ExceptionType::BadSignature);
1645             });
1646         }
1647     }
1648 
1649     // Do a context switch if needed.
1650     {
1651         Value* offset = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Mul, origin(),
1652             calleeIndex, constant(pointerType(), sizeof(Instance*)));
1653         Value* newContextInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1654             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), instancesBuffer, offset));
1655 
1656         BasicBlock* continuation = m_proc.addBlock();
1657         BasicBlock* doContextSwitch = m_proc.addBlock();
1658 
1659         Value* isSameContextInstance = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(),
1660             newContextInstance, instanceValue());
1661         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),
1662             isSameContextInstance, FrequentedBlock(continuation), FrequentedBlock(doContextSwitch));
1663 
1664         PatchpointValue* patchpoint = doContextSwitch-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin());
1665         patchpoint-&gt;effects.writesPinned = true;
1666         // We pessimistically assume we&#39;re calling something with BoundsChecking memory.
1667         // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
1668         patchpoint-&gt;clobber(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1669         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1670         patchpoint-&gt;append(newContextInstance, ValueRep::SomeRegister);
1671         patchpoint-&gt;append(instanceValue(), ValueRep::SomeRegister);
<a name="62" id="anc62"></a><span class="line-added">1672         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
<span class="line-added">1673 </span>
1674         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1675             AllowMacroScratchRegisterUsage allowScratch(jit);
1676             GPRReg newContextInstance = params[0].gpr();
1677             GPRReg oldContextInstance = params[1].gpr();
1678             const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
<a name="63" id="anc63"></a>
1679             GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
1680             ASSERT(newContextInstance != baseMemory);
1681             jit.loadPtr(CCallHelpers::Address(oldContextInstance, Instance::offsetOfCachedStackLimit()), baseMemory);
1682             jit.storePtr(baseMemory, CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedStackLimit()));
1683             jit.storeWasmContextInstance(newContextInstance);
<a name="64" id="anc64"></a><span class="line-modified">1684             ASSERT(pinnedRegs.sizeRegister != baseMemory);</span>
1685             // FIXME: We should support more than one memory size register
1686             //   see: https://bugs.webkit.org/show_bug.cgi?id=162952
<a name="65" id="anc65"></a><span class="line-modified">1687             ASSERT(pinnedRegs.sizeRegister != newContextInstance);</span>
<span class="line-modified">1688             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs.sizeRegister;</span>
<span class="line-modified">1689 </span>
<span class="line-modified">1690             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister); // Memory size.</span>
1691             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemory()), baseMemory); // Memory::void*.
<a name="66" id="anc66"></a><span class="line-added">1692 </span>
<span class="line-added">1693             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs.sizeRegister, scratchOrSize);</span>
1694         });
1695         doContextSwitch-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
1696 
1697         m_currentBlock = continuation;
1698     }
1699 
1700     ExpressionType calleeCode = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1701         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), callableFunction,
1702             safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfEntrypointLoadLocation())));
1703 
1704     Type returnType = signature.returnType();
1705     result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1706         [=] (PatchpointValue* patchpoint) {
1707             patchpoint-&gt;effects.writesPinned = true;
1708             patchpoint-&gt;effects.readsPinned = true;
1709             // We need to clobber all potential pinned registers since we might be leaving the instance.
1710             // We pessimistically assume we&#39;re always calling something that is bounds checking so
1711             // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
1712             // FIXME: We should not have to do this, but the wasm-&gt;wasm stub assumes it can
1713             // use all the pinned registers as scratch: https://bugs.webkit.org/show_bug.cgi?id=172181
1714             patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1715 
1716             patchpoint-&gt;append(calleeCode, ValueRep::SomeRegister);
1717             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1718                 AllowMacroScratchRegisterUsage allowScratch(jit);
1719                 jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);
1720             });
1721         });
1722 
1723     // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
1724     restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, m_currentBlock);
1725 
1726     return { };
1727 }
1728 
1729 void B3IRGenerator::unify(const ExpressionType phi, const ExpressionType source)
1730 {
1731     m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), source, phi);
1732 }
1733 
<a name="67" id="anc67"></a><span class="line-modified">1734 void B3IRGenerator::unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; result)</span>
1735 {
1736     ASSERT(result.size() &lt;= resultStack.size());
1737 
1738     for (size_t i = 0; i &lt; result.size(); ++i)
<a name="68" id="anc68"></a><span class="line-modified">1739         unify(result[result.size() - 1 - i], resultStack.at(resultStack.size() - 1 - i));</span>







1740 }
1741 
<a name="69" id="anc69"></a><span class="line-modified">1742 void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack)</span>
1743 {
1744     dataLogLn(&quot;Constants:&quot;);
1745     for (const auto&amp; constant : m_constantPool)
1746         dataLogLn(deepDump(m_proc, constant.value));
1747 
1748     dataLogLn(&quot;Processing Graph:&quot;);
1749     dataLog(m_proc);
1750     dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
1751     dataLogLn(&quot;Control stack:&quot;);
1752     ASSERT(controlStack.size());
1753     for (size_t i = controlStack.size(); i--;) {
1754         dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<a name="70" id="anc70"></a><span class="line-modified">1755         expressionStack-&gt;dump();</span>

1756         expressionStack = &amp;controlStack[i].enclosedExpressionStack;
1757         dataLogLn();
1758     }
1759     dataLogLn();
1760 }
1761 
1762 auto B3IRGenerator::origin() -&gt; Origin
1763 {
1764     OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
1765     ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
1766     return bitwise_cast&lt;Origin&gt;(origin);
1767 }
1768 
<a name="71" id="anc71"></a><span class="line-modified">1769 Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, uint32_t loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
1770 {
<a name="72" id="anc72"></a><span class="line-modified">1771     auto result = makeUnique&lt;InternalFunction&gt;();</span>
1772 
<a name="73" id="anc73"></a><span class="line-modified">1773     compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
<span class="line-modified">1774     compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
1775 
1776     Procedure procedure;
1777 
1778     procedure.setOriginPrinter([] (PrintStream&amp; out, Origin origin) {
1779         if (origin.data())
1780             out.print(&quot;Wasm: &quot;, bitwise_cast&lt;OpcodeOrigin&gt;(origin));
1781     });
1782 
1783     // This means we cannot use either StackmapGenerationParams::usedRegisters() or
1784     // StackmapGenerationParams::unavailableRegisters(). In exchange for this concession, we
1785     // don&#39;t strictly need to run Air::reportUsedRegisters(), which saves a bit of CPU time at
1786     // optLevel=1.
1787     procedure.setNeedsUsedRegisters(false);
1788 
1789     procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
<a name="74" id="anc74"></a><span class="line-modified">1790         ? Options::webAssemblyBBQB3OptimizationLevel()</span>
1791         : Options::webAssemblyOMGOptimizationLevel());
1792 
<a name="75" id="anc75"></a><span class="line-modified">1793     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, mode, compilationMode, functionIndex, loopIndexForOSREntry, tierUp, throwWasmException);</span>
1794     FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);
1795     WASM_FAIL_IF_HELPER_FAILS(parser.parse());
1796 
1797     irGenerator.insertConstants();
1798 
1799     procedure.resetReachability();
1800     if (!ASSERT_DISABLED)
1801         validate(procedure, &quot;After parsing:\n&quot;);
1802 
1803     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Pre SSA: &quot;, procedure);
1804     fixSSA(procedure);
1805     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Post SSA: &quot;, procedure);
1806 
1807     {
1808         B3::prepareForGeneration(procedure);
1809         B3::generate(procedure, *compilationContext.wasmEntrypointJIT);
1810         compilationContext.wasmEntrypointByproducts = procedure.releaseByproducts();
1811         result-&gt;entrypoint.calleeSaveRegisters = procedure.calleeSaveRegisterAtOffsetList();
1812     }
1813 
<a name="76" id="anc76"></a><span class="line-modified">1814     return result;</span>
1815 }
1816 
1817 // Custom wasm ops. These are the ones too messy to do in wasm.json.
1818 
1819 void B3IRGenerator::emitChecksForModOrDiv(B3::Opcode operation, ExpressionType left, ExpressionType right)
1820 {
1821     ASSERT(operation == Div || operation == Mod || operation == UDiv || operation == UMod);
1822     const B3::Type type = left-&gt;type();
1823 
1824     {
1825         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1826             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), right, constant(type, 0)));
1827 
1828         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1829             this-&gt;emitExceptionCheck(jit, ExceptionType::DivisionByZero);
1830         });
1831     }
1832 
1833     if (operation == Div) {
1834         int64_t min = type == Int32 ? std::numeric_limits&lt;int32_t&gt;::min() : std::numeric_limits&lt;int64_t&gt;::min();
1835 
1836         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1837             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
1838                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), left, constant(type, min)),
1839                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), right, constant(type, -1))));
1840 
1841         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1842             this-&gt;emitExceptionCheck(jit, ExceptionType::IntegerOverflow);
1843         });
1844     }
1845 }
1846 
1847 template&lt;&gt;
1848 auto B3IRGenerator::addOp&lt;OpType::I32DivS&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1849 {
1850     const B3::Opcode op = Div;
1851     emitChecksForModOrDiv(op, left, right);
1852     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1853     return { };
1854 }
1855 
1856 template&lt;&gt;
1857 auto B3IRGenerator::addOp&lt;OpType::I32RemS&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1858 {
1859     const B3::Opcode op = Mod;
1860     emitChecksForModOrDiv(op, left, right);
1861     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, chill(op), origin(), left, right);
1862     return { };
1863 }
1864 
1865 template&lt;&gt;
1866 auto B3IRGenerator::addOp&lt;OpType::I32DivU&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1867 {
1868     const B3::Opcode op = UDiv;
1869     emitChecksForModOrDiv(op, left, right);
1870     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1871     return { };
1872 }
1873 
1874 template&lt;&gt;
1875 auto B3IRGenerator::addOp&lt;OpType::I32RemU&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1876 {
1877     const B3::Opcode op = UMod;
1878     emitChecksForModOrDiv(op, left, right);
1879     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1880     return { };
1881 }
1882 
1883 template&lt;&gt;
1884 auto B3IRGenerator::addOp&lt;OpType::I64DivS&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1885 {
1886     const B3::Opcode op = Div;
1887     emitChecksForModOrDiv(op, left, right);
1888     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1889     return { };
1890 }
1891 
1892 template&lt;&gt;
1893 auto B3IRGenerator::addOp&lt;OpType::I64RemS&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1894 {
1895     const B3::Opcode op = Mod;
1896     emitChecksForModOrDiv(op, left, right);
1897     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, chill(op), origin(), left, right);
1898     return { };
1899 }
1900 
1901 template&lt;&gt;
1902 auto B3IRGenerator::addOp&lt;OpType::I64DivU&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1903 {
1904     const B3::Opcode op = UDiv;
1905     emitChecksForModOrDiv(op, left, right);
1906     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1907     return { };
1908 }
1909 
1910 template&lt;&gt;
1911 auto B3IRGenerator::addOp&lt;OpType::I64RemU&gt;(ExpressionType left, ExpressionType right, ExpressionType&amp; result) -&gt; PartialResult
1912 {
1913     const B3::Opcode op = UMod;
1914     emitChecksForModOrDiv(op, left, right);
1915     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, op, origin(), left, right);
1916     return { };
1917 }
1918 
1919 template&lt;&gt;
1920 auto B3IRGenerator::addOp&lt;OpType::I32Ctz&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
1921 {
1922     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
1923     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
1924     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1925         jit.countTrailingZeros32(params[1].gpr(), params[0].gpr());
1926     });
1927     patchpoint-&gt;effects = Effects::none();
1928     result = patchpoint;
1929     return { };
1930 }
1931 
1932 template&lt;&gt;
1933 auto B3IRGenerator::addOp&lt;OpType::I64Ctz&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
1934 {
1935     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
1936     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
1937     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1938         jit.countTrailingZeros64(params[1].gpr(), params[0].gpr());
1939     });
1940     patchpoint-&gt;effects = Effects::none();
1941     result = patchpoint;
1942     return { };
1943 }
1944 
1945 template&lt;&gt;
1946 auto B3IRGenerator::addOp&lt;OpType::I32Popcnt&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
1947 {
1948 #if CPU(X86_64)
1949     if (MacroAssembler::supportsCountPopulation()) {
1950         PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
1951         patchpoint-&gt;append(arg, ValueRep::SomeRegister);
1952         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1953             jit.countPopulation32(params[1].gpr(), params[0].gpr());
1954         });
1955         patchpoint-&gt;effects = Effects::none();
1956         result = patchpoint;
1957         return { };
1958     }
1959 #endif
1960 
1961     uint32_t (*popcount)(int32_t) = [] (int32_t value) -&gt; uint32_t { return __builtin_popcount(value); };
1962     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(popcount, B3CCallPtrTag));
1963     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(), Effects::none(), funcAddress, arg);
1964     return { };
1965 }
1966 
1967 template&lt;&gt;
1968 auto B3IRGenerator::addOp&lt;OpType::I64Popcnt&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
1969 {
1970 #if CPU(X86_64)
1971     if (MacroAssembler::supportsCountPopulation()) {
1972         PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
1973         patchpoint-&gt;append(arg, ValueRep::SomeRegister);
1974         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1975             jit.countPopulation64(params[1].gpr(), params[0].gpr());
1976         });
1977         patchpoint-&gt;effects = Effects::none();
1978         result = patchpoint;
1979         return { };
1980     }
1981 #endif
1982 
1983     uint64_t (*popcount)(int64_t) = [] (int64_t value) -&gt; uint64_t { return __builtin_popcountll(value); };
1984     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(popcount, B3CCallPtrTag));
1985     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int64, origin(), Effects::none(), funcAddress, arg);
1986     return { };
1987 }
1988 
1989 template&lt;&gt;
1990 auto B3IRGenerator::addOp&lt;F64ConvertUI64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
1991 {
1992     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Double, origin());
1993     if (isX86())
1994         patchpoint-&gt;numGPScratchRegisters = 1;
1995     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1996     patchpoint-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
1997     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
1998         AllowMacroScratchRegisterUsage allowScratch(jit);
1999 #if CPU(X86_64)
2000         jit.convertUInt64ToDouble(params[1].gpr(), params[0].fpr(), params.gpScratch(0));
2001 #else
2002         jit.convertUInt64ToDouble(params[1].gpr(), params[0].fpr());
2003 #endif
2004     });
2005     patchpoint-&gt;effects = Effects::none();
2006     result = patchpoint;
2007     return { };
2008 }
2009 
2010 template&lt;&gt;
2011 auto B3IRGenerator::addOp&lt;OpType::F32ConvertUI64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2012 {
2013     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Float, origin());
2014     if (isX86())
2015         patchpoint-&gt;numGPScratchRegisters = 1;
2016     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
2017     patchpoint-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
2018     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2019         AllowMacroScratchRegisterUsage allowScratch(jit);
2020 #if CPU(X86_64)
2021         jit.convertUInt64ToFloat(params[1].gpr(), params[0].fpr(), params.gpScratch(0));
2022 #else
2023         jit.convertUInt64ToFloat(params[1].gpr(), params[0].fpr());
2024 #endif
2025     });
2026     patchpoint-&gt;effects = Effects::none();
2027     result = patchpoint;
2028     return { };
2029 }
2030 
2031 template&lt;&gt;
2032 auto B3IRGenerator::addOp&lt;OpType::F64Nearest&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2033 {
2034     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Double, origin());
2035     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2036     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2037         jit.roundTowardNearestIntDouble(params[1].fpr(), params[0].fpr());
2038     });
2039     patchpoint-&gt;effects = Effects::none();
2040     result = patchpoint;
2041     return { };
2042 }
2043 
2044 template&lt;&gt;
2045 auto B3IRGenerator::addOp&lt;OpType::F32Nearest&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2046 {
2047     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Float, origin());
2048     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2049     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2050         jit.roundTowardNearestIntFloat(params[1].fpr(), params[0].fpr());
2051     });
2052     patchpoint-&gt;effects = Effects::none();
2053     result = patchpoint;
2054     return { };
2055 }
2056 
2057 template&lt;&gt;
2058 auto B3IRGenerator::addOp&lt;OpType::F64Trunc&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2059 {
2060     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Double, origin());
2061     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2062     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2063         jit.roundTowardZeroDouble(params[1].fpr(), params[0].fpr());
2064     });
2065     patchpoint-&gt;effects = Effects::none();
2066     result = patchpoint;
2067     return { };
2068 }
2069 
2070 template&lt;&gt;
2071 auto B3IRGenerator::addOp&lt;OpType::F32Trunc&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2072 {
2073     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Float, origin());
2074     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2075     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2076         jit.roundTowardZeroFloat(params[1].fpr(), params[0].fpr());
2077     });
2078     patchpoint-&gt;effects = Effects::none();
2079     result = patchpoint;
2080     return { };
2081 }
2082 
2083 template&lt;&gt;
2084 auto B3IRGenerator::addOp&lt;OpType::I32TruncSF64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2085 {
2086     Value* max = constant(Double, bitwise_cast&lt;uint64_t&gt;(-static_cast&lt;double&gt;(std::numeric_limits&lt;int32_t&gt;::min())));
2087     Value* min = constant(Double, bitwise_cast&lt;uint64_t&gt;(static_cast&lt;double&gt;(std::numeric_limits&lt;int32_t&gt;::min())));
2088     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2089         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2090         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterEqual, origin(), arg, min));
2091     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2092     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2093     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2094         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2095     });
2096     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
2097     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2098     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2099         jit.truncateDoubleToInt32(params[1].fpr(), params[0].gpr());
2100     });
2101     patchpoint-&gt;effects = Effects::none();
2102     result = patchpoint;
2103     return { };
2104 }
2105 
2106 template&lt;&gt;
2107 auto B3IRGenerator::addOp&lt;OpType::I32TruncSF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2108 {
2109     Value* max = constant(Float, bitwise_cast&lt;uint32_t&gt;(-static_cast&lt;float&gt;(std::numeric_limits&lt;int32_t&gt;::min())));
2110     Value* min = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;int32_t&gt;::min())));
2111     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2112         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2113         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterEqual, origin(), arg, min));
2114     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2115     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2116     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2117         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2118     });
2119     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
2120     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2121     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2122         jit.truncateFloatToInt32(params[1].fpr(), params[0].gpr());
2123     });
2124     patchpoint-&gt;effects = Effects::none();
2125     result = patchpoint;
2126     return { };
2127 }
2128 
2129 
2130 template&lt;&gt;
2131 auto B3IRGenerator::addOp&lt;OpType::I32TruncUF64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2132 {
2133     Value* max = constant(Double, bitwise_cast&lt;uint64_t&gt;(static_cast&lt;double&gt;(std::numeric_limits&lt;int32_t&gt;::min()) * -2.0));
2134     Value* min = constant(Double, bitwise_cast&lt;uint64_t&gt;(-1.0));
2135     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2136         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2137         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterThan, origin(), arg, min));
2138     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2139     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2140     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2141         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2142     });
2143     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
2144     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2145     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2146         jit.truncateDoubleToUint32(params[1].fpr(), params[0].gpr());
2147     });
2148     patchpoint-&gt;effects = Effects::none();
2149     result = patchpoint;
2150     return { };
2151 }
2152 
2153 template&lt;&gt;
2154 auto B3IRGenerator::addOp&lt;OpType::I32TruncUF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2155 {
2156     Value* max = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;int32_t&gt;::min()) * static_cast&lt;float&gt;(-2.0)));
2157     Value* min = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(-1.0)));
2158     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2159         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2160         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterThan, origin(), arg, min));
2161     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2162     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2163     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2164         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2165     });
2166     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int32, origin());
2167     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2168     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2169         jit.truncateFloatToUint32(params[1].fpr(), params[0].gpr());
2170     });
2171     patchpoint-&gt;effects = Effects::none();
2172     result = patchpoint;
2173     return { };
2174 }
2175 
2176 template&lt;&gt;
2177 auto B3IRGenerator::addOp&lt;OpType::I64TruncSF64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2178 {
2179     Value* max = constant(Double, bitwise_cast&lt;uint64_t&gt;(-static_cast&lt;double&gt;(std::numeric_limits&lt;int64_t&gt;::min())));
2180     Value* min = constant(Double, bitwise_cast&lt;uint64_t&gt;(static_cast&lt;double&gt;(std::numeric_limits&lt;int64_t&gt;::min())));
2181     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2182         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2183         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterEqual, origin(), arg, min));
2184     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2185     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2186     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2187         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2188     });
2189     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
2190     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2191     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2192         jit.truncateDoubleToInt64(params[1].fpr(), params[0].gpr());
2193     });
2194     patchpoint-&gt;effects = Effects::none();
2195     result = patchpoint;
2196     return { };
2197 }
2198 
2199 template&lt;&gt;
2200 auto B3IRGenerator::addOp&lt;OpType::I64TruncUF64&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2201 {
2202     Value* max = constant(Double, bitwise_cast&lt;uint64_t&gt;(static_cast&lt;double&gt;(std::numeric_limits&lt;int64_t&gt;::min()) * -2.0));
2203     Value* min = constant(Double, bitwise_cast&lt;uint64_t&gt;(-1.0));
2204     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2205         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2206         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterThan, origin(), arg, min));
2207     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2208     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2209     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2210         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2211     });
2212 
2213     Value* signBitConstant;
2214     if (isX86()) {
2215         // Since x86 doesn&#39;t have an instruction to convert floating points to unsigned integers, we at least try to do the smart thing if
2216         // the numbers are would be positive anyway as a signed integer. Since we cannot materialize constants into fprs we have b3 do it
2217         // so we can pool them if needed.
2218         signBitConstant = constant(Double, bitwise_cast&lt;uint64_t&gt;(static_cast&lt;double&gt;(std::numeric_limits&lt;uint64_t&gt;::max() - std::numeric_limits&lt;int64_t&gt;::max())));
2219     }
2220     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
2221     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2222     if (isX86()) {
2223         patchpoint-&gt;append(signBitConstant, ValueRep::SomeRegister);
2224         patchpoint-&gt;numFPScratchRegisters = 1;
2225     }
2226     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
2227     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2228         AllowMacroScratchRegisterUsage allowScratch(jit);
2229         FPRReg scratch = InvalidFPRReg;
2230         FPRReg constant = InvalidFPRReg;
2231         if (isX86()) {
2232             scratch = params.fpScratch(0);
2233             constant = params[2].fpr();
2234         }
2235         jit.truncateDoubleToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
2236     });
2237     patchpoint-&gt;effects = Effects::none();
2238     result = patchpoint;
2239     return { };
2240 }
2241 
2242 template&lt;&gt;
2243 auto B3IRGenerator::addOp&lt;OpType::I64TruncSF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2244 {
2245     Value* max = constant(Float, bitwise_cast&lt;uint32_t&gt;(-static_cast&lt;float&gt;(std::numeric_limits&lt;int64_t&gt;::min())));
2246     Value* min = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;int64_t&gt;::min())));
2247     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2248         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2249         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterEqual, origin(), arg, min));
2250     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2251     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2252     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2253         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2254     });
2255     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
2256     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2257     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2258         jit.truncateFloatToInt64(params[1].fpr(), params[0].gpr());
2259     });
2260     patchpoint-&gt;effects = Effects::none();
2261     result = patchpoint;
2262     return { };
2263 }
2264 
2265 template&lt;&gt;
2266 auto B3IRGenerator::addOp&lt;OpType::I64TruncUF32&gt;(ExpressionType arg, ExpressionType&amp; result) -&gt; PartialResult
2267 {
2268     Value* max = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;int64_t&gt;::min()) * static_cast&lt;float&gt;(-2.0)));
2269     Value* min = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(-1.0)));
2270     Value* outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(),
2271         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, LessThan, origin(), arg, max),
2272         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, GreaterThan, origin(), arg, min));
2273     outOfBounds = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), outOfBounds, constant(Int32, 0));
2274     CheckValue* trap = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(), outOfBounds);
2275     trap-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
2276         this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTrunc);
2277     });
2278 
2279     Value* signBitConstant;
2280     if (isX86()) {
2281         // Since x86 doesn&#39;t have an instruction to convert floating points to unsigned integers, we at least try to do the smart thing if
2282         // the numbers would be positive anyway as a signed integer. Since we cannot materialize constants into fprs we have b3 do it
2283         // so we can pool them if needed.
2284         signBitConstant = constant(Float, bitwise_cast&lt;uint32_t&gt;(static_cast&lt;float&gt;(std::numeric_limits&lt;uint64_t&gt;::max() - std::numeric_limits&lt;int64_t&gt;::max())));
2285     }
2286     PatchpointValue* patchpoint = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, Int64, origin());
2287     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
2288     if (isX86()) {
2289         patchpoint-&gt;append(signBitConstant, ValueRep::SomeRegister);
2290         patchpoint-&gt;numFPScratchRegisters = 1;
2291     }
2292     patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
2293     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
2294         AllowMacroScratchRegisterUsage allowScratch(jit);
2295         FPRReg scratch = InvalidFPRReg;
2296         FPRReg constant = InvalidFPRReg;
2297         if (isX86()) {
2298             scratch = params.fpScratch(0);
2299             constant = params[2].fpr();
2300         }
2301         jit.truncateFloatToUint64(params[1].fpr(), params[0].gpr(), scratch, constant);
2302     });
2303     patchpoint-&gt;effects = Effects::none();
2304     result = patchpoint;
2305     return { };
2306 }
2307 
2308 } } // namespace JSC::Wasm
2309 
2310 #include &quot;WasmB3IRGeneratorInlines.h&quot;
2311 
2312 #endif // ENABLE(WEBASSEMBLY)
<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>