<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FloatingContext.h&quot;
 32 #include &quot;FloatingState.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &quot;InlineLine.h&quot;</span>
 35 #include &quot;InlineLineBreaker.h&quot;
<a name="2" id="anc2"></a>
 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
 38 #include &quot;LayoutState.h&quot;
 39 #include &quot;TextUtil.h&quot;
 40 
 41 namespace WebCore {
 42 namespace Layout {
 43 
<a name="3" id="anc3"></a><span class="line-modified"> 44 static LayoutUnit inlineItemWidth(const LayoutState&amp; layoutState, const InlineItem&amp; inlineItem, LayoutUnit contentLogicalLeft)</span>
<span class="line-modified"> 45 {</span>
<span class="line-modified"> 46     if (inlineItem.isLineBreak())</span>
<span class="line-modified"> 47         return 0;</span>
 48 
<a name="4" id="anc4"></a><span class="line-modified"> 49     if (is&lt;InlineTextItem&gt;(inlineItem)) {</span>
<span class="line-added"> 50         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added"> 51         auto end = inlineTextItem.isCollapsed() ? inlineTextItem.start() + 1 : inlineTextItem.end();</span>
<span class="line-added"> 52         return TextUtil::width(inlineTextItem.layoutBox(), inlineTextItem.start(), end, contentLogicalLeft);</span>
<span class="line-added"> 53     }</span>
 54 
<a name="5" id="anc5"></a><span class="line-modified"> 55     auto&amp; layoutBox = inlineItem.layoutBox();</span>
<span class="line-modified"> 56     ASSERT(layoutState.hasDisplayBox(layoutBox));</span>
<span class="line-added"> 57     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
 58 
<a name="6" id="anc6"></a><span class="line-modified"> 59     if (layoutBox.isFloatingPositioned())</span>
<span class="line-modified"> 60         return displayBox.marginBoxWidth();</span>


 61 
<a name="7" id="anc7"></a><span class="line-modified"> 62     if (layoutBox.replaced())</span>
<span class="line-modified"> 63         return displayBox.width();</span>


 64 
<a name="8" id="anc8"></a><span class="line-modified"> 65     if (inlineItem.isContainerStart())</span>
<span class="line-modified"> 66         return displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0);</span>

 67 
<a name="9" id="anc9"></a><span class="line-modified"> 68     if (inlineItem.isContainerEnd())</span>
<span class="line-modified"> 69         return displayBox.marginEnd() + displayBox.borderRight() + displayBox.paddingRight().valueOr(0);</span>






 70 
<a name="10" id="anc10"></a><span class="line-modified"> 71     // Non-replaced inline box (e.g. inline-block)</span>
<span class="line-modified"> 72     return displayBox.width();</span>
<span class="line-added"> 73 }</span>
 74 
<a name="11" id="anc11"></a><span class="line-modified"> 75 struct IndexAndRange {</span>
<span class="line-modified"> 76     unsigned index { 0 };</span>
<span class="line-modified"> 77     struct Range {</span>
<span class="line-added"> 78         unsigned start { 0 };</span>
<span class="line-added"> 79         unsigned length { 0 };</span>
<span class="line-added"> 80     };</span>
<span class="line-added"> 81     Optional&lt;Range&gt; partialContext;</span>
 82 };
 83 
<a name="12" id="anc12"></a><span class="line-modified"> 84 struct LineInput {</span>
<span class="line-modified"> 85     LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp;);</span>











 86 
<a name="13" id="anc13"></a><span class="line-modified"> 87     Line::InitialConstraints initialConstraints;</span>
<span class="line-modified"> 88     // FIXME Alternatively we could just have a second pass with vertical positioning (preferred width computation opts out)</span>
<span class="line-modified"> 89     Line::SkipVerticalAligment skipVerticalAligment;</span>
<span class="line-added"> 90     IndexAndRange firstInlineItem;</span>
<span class="line-added"> 91     const InlineItems&amp; inlineItems;</span>
<span class="line-added"> 92     Optional&lt;LayoutUnit&gt; floatMinimumLogicalBottom;</span>
<span class="line-added"> 93 };</span>
 94 
<a name="14" id="anc14"></a><span class="line-modified"> 95 struct LineContent {</span>
<span class="line-modified"> 96     Optional&lt;IndexAndRange&gt; lastCommitted;</span>
<span class="line-added"> 97     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; floats;</span>
<span class="line-added"> 98     std::unique_ptr&lt;Line::Content&gt; runs;</span>
<span class="line-added"> 99 };</span>
100 
<a name="15" id="anc15"></a><span class="line-modified">101 class LineLayout {</span>
<span class="line-modified">102 public:</span>
<span class="line-modified">103     LineLayout(const LayoutState&amp;, const LineInput&amp;);</span>
104 
<a name="16" id="anc16"></a><span class="line-modified">105     LineContent layout();</span>


106 
<a name="17" id="anc17"></a><span class="line-modified">107 private:</span>
<span class="line-modified">108     const LayoutState&amp; layoutState() const { return m_layoutState; }</span>
<span class="line-modified">109     enum class IsEndOfLine { No, Yes };</span>
<span class="line-added">110     IsEndOfLine placeInlineItem(const InlineItem&amp;);</span>
<span class="line-added">111     void commitPendingContent();</span>
<span class="line-added">112     LineContent close();</span>
<span class="line-added">113 </span>
<span class="line-added">114     struct UncommittedContent {</span>
<span class="line-added">115         struct Run {</span>
<span class="line-added">116             const InlineItem&amp; inlineItem;</span>
<span class="line-added">117             LayoutUnit logicalWidth;</span>
<span class="line-added">118         };</span>
<span class="line-added">119         void add(const InlineItem&amp;, LayoutUnit logicalWidth);</span>
<span class="line-added">120         void reset();</span>
121 
<a name="18" id="anc18"></a><span class="line-modified">122         Vector&lt;Run&gt; runs() { return m_uncommittedRuns; }</span>
<span class="line-modified">123         bool isEmpty() const { return m_uncommittedRuns.isEmpty(); }</span>
<span class="line-modified">124         unsigned size() const { return m_uncommittedRuns.size(); }</span>
<span class="line-modified">125         LayoutUnit width() const { return m_width; }</span>
126 
<a name="19" id="anc19"></a><span class="line-modified">127     private:</span>
<span class="line-modified">128         Vector&lt;Run&gt; m_uncommittedRuns;</span>
<span class="line-modified">129         LayoutUnit m_width;</span>
<span class="line-modified">130     };</span>
131 
<a name="20" id="anc20"></a><span class="line-modified">132     const LayoutState&amp; m_layoutState;</span>
<span class="line-modified">133     const LineInput&amp; m_lineInput;</span>
<span class="line-added">134     Line m_line;</span>
<span class="line-added">135     LineBreaker m_lineBreaker;</span>
<span class="line-added">136     bool m_lineHasFloatBox { false };</span>
<span class="line-added">137     UncommittedContent m_uncommittedContent;</span>
<span class="line-added">138     unsigned m_committedInlineItemCount { 0 };</span>
<span class="line-added">139     Vector&lt;WeakPtr&lt;InlineItem&gt;&gt; m_floats;</span>
<span class="line-added">140     std::unique_ptr&lt;InlineTextItem&gt; m_leadingPartialInlineTextItem;</span>
<span class="line-added">141     std::unique_ptr&lt;InlineTextItem&gt; m_trailingPartialInlineTextItem;</span>
<span class="line-added">142 };</span>
143 
<a name="21" id="anc21"></a><span class="line-modified">144 void LineLayout::UncommittedContent::add(const InlineItem&amp; inlineItem, LayoutUnit logicalWidth)</span>
145 {
<a name="22" id="anc22"></a><span class="line-modified">146     m_uncommittedRuns.append({ inlineItem, logicalWidth });</span>
<span class="line-modified">147     m_width += logicalWidth;</span>































148 }
149 
<a name="23" id="anc23"></a><span class="line-modified">150 void LineLayout::UncommittedContent::reset()</span>
151 {
<a name="24" id="anc24"></a><span class="line-modified">152     m_uncommittedRuns.clear();</span>
<span class="line-modified">153     m_width = 0;</span>

















154 }
155 
<a name="25" id="anc25"></a><span class="line-modified">156 LineLayout::LineLayout(const LayoutState&amp; layoutState, const LineInput&amp; lineInput)</span>
<span class="line-modified">157     : m_layoutState(layoutState)</span>
<span class="line-modified">158     , m_lineInput(lineInput)</span>
<span class="line-modified">159     , m_line(layoutState, lineInput.initialConstraints, lineInput.skipVerticalAligment)</span>
<span class="line-modified">160     , m_lineHasFloatBox(lineInput.floatMinimumLogicalBottom.hasValue())</span>
161 {
162 }
163 
<a name="26" id="anc26"></a><span class="line-modified">164 void LineLayout::commitPendingContent()</span>
165 {
<a name="27" id="anc27"></a><span class="line-modified">166     if (m_uncommittedContent.isEmpty())</span>
<span class="line-added">167         return;</span>
<span class="line-added">168     m_committedInlineItemCount += m_uncommittedContent.size();</span>
<span class="line-added">169     for (auto&amp; uncommittedRun : m_uncommittedContent.runs())</span>
<span class="line-added">170         m_line.append(uncommittedRun.inlineItem, uncommittedRun.logicalWidth);</span>
<span class="line-added">171     m_uncommittedContent.reset();</span>
172 }
173 
<a name="28" id="anc28"></a><span class="line-modified">174 LineContent LineLayout::close()</span>
175 {
<a name="29" id="anc29"></a><span class="line-modified">176     ASSERT(m_committedInlineItemCount || m_lineHasFloatBox);</span>
<span class="line-modified">177     if (!m_committedInlineItemCount)</span>
<span class="line-added">178         return LineContent { WTF::nullopt, WTFMove(m_floats), m_line.close() };</span>
179 
<a name="30" id="anc30"></a><span class="line-modified">180     auto lastInlineItemIndex = m_lineInput.firstInlineItem.index + m_committedInlineItemCount - 1;</span>
<span class="line-modified">181     Optional&lt;IndexAndRange::Range&gt; partialContext;</span>
<span class="line-added">182     if (m_trailingPartialInlineTextItem)</span>
<span class="line-added">183         partialContext = IndexAndRange::Range { m_trailingPartialInlineTextItem-&gt;start(), m_trailingPartialInlineTextItem-&gt;length() };</span>
184 
<a name="31" id="anc31"></a><span class="line-modified">185     auto lastCommitedItem = IndexAndRange { lastInlineItemIndex, partialContext };</span>
<span class="line-modified">186     return LineContent { lastCommitedItem, WTFMove(m_floats), m_line.close() };</span>
<span class="line-modified">187 }</span>


188 
<a name="32" id="anc32"></a><span class="line-modified">189 LineLayout::IsEndOfLine LineLayout::placeInlineItem(const InlineItem&amp; inlineItem)</span>
<span class="line-modified">190 {</span>
<span class="line-modified">191     auto availableWidth = m_line.availableWidth() - m_uncommittedContent.width();</span>
<span class="line-modified">192     auto currentLogicalRight = m_line.contentLogicalRight() + m_uncommittedContent.width();</span>
<span class="line-modified">193     auto itemLogicalWidth = inlineItemWidth(layoutState(), inlineItem, currentLogicalRight);</span>
<span class="line-added">194 </span>
<span class="line-added">195     // FIXME: Ensure LineContext::trimmableWidth includes uncommitted content if needed.</span>
<span class="line-added">196     auto lineIsConsideredEmpty = !m_line.hasContent() &amp;&amp; !m_lineHasFloatBox;</span>
<span class="line-added">197     auto breakingContext = m_lineBreaker.breakingContext(inlineItem, itemLogicalWidth, { availableWidth, currentLogicalRight, m_line.trailingTrimmableWidth(), lineIsConsideredEmpty });</span>
<span class="line-added">198     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">199         commitPendingContent();</span>
<span class="line-added">200 </span>
<span class="line-added">201     // Content does not fit the current line.</span>
<span class="line-added">202     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Wrap)</span>
<span class="line-added">203         return IsEndOfLine::Yes;</span>
<span class="line-added">204 </span>
<span class="line-added">205     // Partial content stays on the current line.</span>
<span class="line-added">206     if (breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Split) {</span>
<span class="line-added">207         ASSERT(inlineItem.isText());</span>
<span class="line-added">208         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added">209         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), itemLogicalWidth, availableWidth, currentLogicalRight);</span>
<span class="line-added">210         // Construct a partial trailing inline item.</span>
<span class="line-added">211         ASSERT(!m_trailingPartialInlineTextItem);</span>
<span class="line-added">212         m_trailingPartialInlineTextItem = inlineTextItem.split(splitData.start, splitData.length);</span>
<span class="line-added">213         m_uncommittedContent.add(*m_trailingPartialInlineTextItem, splitData.logicalWidth);</span>
<span class="line-added">214         commitPendingContent();</span>
<span class="line-added">215         return IsEndOfLine::Yes;</span>
<span class="line-added">216     }</span>
217 
<a name="33" id="anc33"></a><span class="line-modified">218     ASSERT(breakingContext.breakingBehavior == LineBreaker::BreakingBehavior::Keep);</span>
<span class="line-modified">219     if (inlineItem.isFloat()) {</span>
<span class="line-modified">220         auto&amp; floatBox = inlineItem.layoutBox();</span>
<span class="line-added">221         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">222         // Shrink available space for current line and move existing inline runs.</span>
<span class="line-added">223         auto floatBoxWidth = layoutState().displayBoxForLayoutBox(floatBox).marginBoxWidth();</span>
<span class="line-added">224         floatBox.isLeftFloatingPositioned() ? m_line.moveLogicalLeft(floatBoxWidth) : m_line.moveLogicalRight(floatBoxWidth);</span>
<span class="line-added">225         m_floats.append(makeWeakPtr(inlineItem));</span>
<span class="line-added">226         ++m_committedInlineItemCount;</span>
<span class="line-added">227         m_lineHasFloatBox = true;</span>
<span class="line-added">228         return IsEndOfLine::No;</span>
<span class="line-added">229     }</span>
230 
<a name="34" id="anc34"></a><span class="line-modified">231     m_uncommittedContent.add(inlineItem, itemLogicalWidth);</span>
<span class="line-modified">232     if (breakingContext.isAtBreakingOpportunity)</span>
<span class="line-added">233         commitPendingContent();</span>
234 
<a name="35" id="anc35"></a><span class="line-modified">235     return inlineItem.isHardLineBreak() ? IsEndOfLine::Yes : IsEndOfLine::No;</span>
<span class="line-modified">236 }</span>















237 
<a name="36" id="anc36"></a><span class="line-modified">238 LineContent LineLayout::layout()</span>
<span class="line-modified">239 {</span>
<span class="line-modified">240     // Iterate through the inline content and place the inline boxes on the current line.</span>
<span class="line-modified">241     // Start with the partial text from the previous line.</span>
<span class="line-modified">242     auto firstInlineItem = m_lineInput.firstInlineItem;</span>
<span class="line-added">243     unsigned firstNonPartialIndex = firstInlineItem.index;</span>
<span class="line-added">244     if (firstInlineItem.partialContext) {</span>
<span class="line-added">245         // Handle partial inline item (split text from the previous line).</span>
<span class="line-added">246         auto&amp; originalTextItem = m_lineInput.inlineItems[firstInlineItem.index];</span>
<span class="line-added">247         RELEASE_ASSERT(originalTextItem-&gt;isText());</span>
<span class="line-added">248 </span>
<span class="line-added">249         auto textRange = *firstInlineItem.partialContext;</span>
<span class="line-added">250         // Construct a partial leading inline item.</span>
<span class="line-added">251         ASSERT(!m_leadingPartialInlineTextItem);</span>
<span class="line-added">252         m_leadingPartialInlineTextItem = downcast&lt;InlineTextItem&gt;(*originalTextItem).split(textRange.start, textRange.length);</span>
<span class="line-added">253         if (placeInlineItem(*m_leadingPartialInlineTextItem) == IsEndOfLine::Yes)</span>
<span class="line-added">254             return close();</span>
<span class="line-added">255         ++firstNonPartialIndex;</span>
<span class="line-added">256     }</span>
257 
<a name="37" id="anc37"></a><span class="line-modified">258     for (auto inlineItemIndex = firstNonPartialIndex; inlineItemIndex &lt; m_lineInput.inlineItems.size(); ++inlineItemIndex) {</span>
<span class="line-modified">259         if (placeInlineItem(*m_lineInput.inlineItems[inlineItemIndex]) == IsEndOfLine::Yes)</span>
<span class="line-added">260             return close();</span>
261     }
<a name="38" id="anc38"></a><span class="line-added">262     commitPendingContent();</span>
<span class="line-added">263     return close();</span>
<span class="line-added">264 }</span>
<span class="line-added">265 </span>
<span class="line-added">266 LineInput::LineInput(const Line::InitialConstraints&amp; initialLineConstraints, Line::SkipVerticalAligment skipVerticalAligment, IndexAndRange firstToProcess, const InlineItems&amp; inlineItems)</span>
<span class="line-added">267     : initialConstraints(initialLineConstraints)</span>
<span class="line-added">268     , skipVerticalAligment(skipVerticalAligment)</span>
<span class="line-added">269     , firstInlineItem(firstToProcess)</span>
<span class="line-added">270     , inlineItems(inlineItems)</span>
<span class="line-added">271 {</span>
<span class="line-added">272 }</span>
273 
<a name="39" id="anc39"></a><span class="line-modified">274 InlineFormattingContext::InlineLayout::InlineLayout(const InlineFormattingContext&amp; inlineFormattingContext)</span>
<span class="line-added">275     : m_layoutState(inlineFormattingContext.layoutState())</span>
<span class="line-added">276     , m_formattingRoot(downcast&lt;Container&gt;(inlineFormattingContext.root()))</span>
<span class="line-added">277 {</span>
278 }
279 
<a name="40" id="anc40"></a><span class="line-modified">280 void InlineFormattingContext::InlineLayout::layout(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
281 {
<a name="41" id="anc41"></a><span class="line-modified">282     auto&amp; formattingRootDisplayBox = layoutState().displayBoxForLayoutBox(m_formattingRoot);</span>
<span class="line-added">283     auto&amp; floatingState = layoutState().establishedFormattingState(m_formattingRoot).floatingState();</span>
284 
<a name="42" id="anc42"></a><span class="line-added">285     auto lineLogicalTop = formattingRootDisplayBox.contentBoxTop();</span>
286     auto lineLogicalLeft = formattingRootDisplayBox.contentBoxLeft();
<a name="43" id="anc43"></a>

287 
<a name="44" id="anc44"></a><span class="line-modified">288     auto applyFloatConstraint = [&amp;](auto&amp; lineInput) {</span>
<span class="line-modified">289         // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-modified">290         if (floatingState.isEmpty())</span>
<span class="line-added">291             return;</span>
<span class="line-added">292         auto availableWidth = lineInput.initialConstraints.availableLogicalWidth;</span>
<span class="line-added">293         auto lineLogicalLeft = lineInput.initialConstraints.logicalTopLeft.x();</span>
<span class="line-added">294         auto floatConstraints = floatingState.constraints({ lineLogicalTop }, m_formattingRoot);</span>
295         // Check if these constraints actually put limitation on the line.
<a name="45" id="anc45"></a><span class="line-modified">296         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= formattingRootDisplayBox.contentBoxLeft())</span>
297             floatConstraints.left = { };
298 
<a name="46" id="anc46"></a><span class="line-modified">299         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= formattingRootDisplayBox.contentBoxRight())</span>
300             floatConstraints.right = { };
301 
<a name="47" id="anc47"></a><span class="line-added">302         // Set the minimum float bottom value as a hint for the next line if needed.</span>
<span class="line-added">303         static auto inifitePoint = PointInContextRoot::max();</span>
<span class="line-added">304         auto floatMinimumLogicalBottom = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);</span>
<span class="line-added">305         if (floatMinimumLogicalBottom != inifitePoint.y)</span>
<span class="line-added">306             lineInput.floatMinimumLogicalBottom = floatMinimumLogicalBottom;</span>
<span class="line-added">307 </span>
308         if (floatConstraints.left &amp;&amp; floatConstraints.right) {
<a name="48" id="anc48"></a><span class="line-modified">309             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);</span>
<span class="line-modified">310             availableWidth = floatConstraints.right-&gt;x - floatConstraints.left-&gt;x;</span>
<span class="line-modified">311             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
312         } else if (floatConstraints.left) {
<a name="49" id="anc49"></a><span class="line-modified">313             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">314             availableWidth -= (floatConstraints.left-&gt;x - lineLogicalLeft);</span>
<span class="line-modified">315             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
316         } else if (floatConstraints.right) {
<a name="50" id="anc50"></a><span class="line-modified">317             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-modified">318             availableWidth = floatConstraints.right-&gt;x - lineLogicalLeft;</span>
319         }
<a name="51" id="anc51"></a><span class="line-modified">320         lineInput.initialConstraints.availableLogicalWidth = availableWidth;</span>
<span class="line-modified">321         lineInput.initialConstraints.logicalTopLeft.setX(lineLogicalLeft);</span>










































322     };
323 
<a name="52" id="anc52"></a><span class="line-modified">324     IndexAndRange currentInlineItem;</span>
<span class="line-modified">325     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">326         auto lineInput = LineInput { { { lineLogicalLeft, lineLogicalTop }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::No, currentInlineItem, inlineItems };</span>
<span class="line-modified">327         applyFloatConstraint(lineInput);</span>
<span class="line-modified">328         auto lineContent = LineLayout(layoutState(), lineInput).layout();</span>
<span class="line-modified">329         createDisplayRuns(*lineContent.runs, lineContent.floats, widthConstraint);</span>
<span class="line-modified">330         if (!lineContent.lastCommitted) {</span>
<span class="line-modified">331             // Floats prevented us putting any content on the line.</span>
<span class="line-modified">332             ASSERT(lineInput.floatMinimumLogicalBottom);</span>
<span class="line-modified">333             ASSERT(lineContent.runs-&gt;isEmpty());</span>
<span class="line-modified">334             lineLogicalTop = *lineInput.floatMinimumLogicalBottom;</span>
<span class="line-modified">335         } else {</span>
<span class="line-modified">336             currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">337             lineLogicalTop = lineContent.runs-&gt;logicalBottom();</span>











338         }
<a name="53" id="anc53"></a>
















339     }
<a name="54" id="anc54"></a>




340 }
341 
<a name="55" id="anc55"></a><span class="line-modified">342 LayoutUnit InlineFormattingContext::InlineLayout::computedIntrinsicWidth(const InlineItems&amp; inlineItems, LayoutUnit widthConstraint) const</span>
343 {
<a name="56" id="anc56"></a><span class="line-modified">344     LayoutUnit maximumLineWidth;</span>
<span class="line-modified">345     IndexAndRange currentInlineItem;</span>
<span class="line-modified">346     while (currentInlineItem.index &lt; inlineItems.size()) {</span>
<span class="line-modified">347         auto lineContent = LineLayout(layoutState(), { { { }, widthConstraint, Quirks::lineHeightConstraints(layoutState(), m_formattingRoot) }, Line::SkipVerticalAligment::Yes, currentInlineItem, inlineItems }).layout();</span>
<span class="line-modified">348         currentInlineItem = { lineContent.lastCommitted-&gt;index + 1, WTF::nullopt };</span>
<span class="line-modified">349         LayoutUnit floatsWidth;</span>
<span class="line-modified">350         for (auto&amp; floatItem : lineContent.floats)</span>
<span class="line-modified">351             floatsWidth += layoutState().displayBoxForLayoutBox(floatItem-&gt;layoutBox()).marginBoxWidth();</span>
<span class="line-modified">352         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.runs-&gt;logicalWidth());</span>















353     }
<a name="57" id="anc57"></a><span class="line-added">354     return maximumLineWidth;</span>
355 }
356 
<a name="58" id="anc58"></a><span class="line-modified">357 void InlineFormattingContext::InlineLayout::createDisplayRuns(const Line::Content&amp; lineContent, const Vector&lt;WeakPtr&lt;InlineItem&gt;&gt;&amp; floats, LayoutUnit widthConstraint) const</span>
358 {
<a name="59" id="anc59"></a><span class="line-modified">359     auto&amp; formattingState = downcast&lt;InlineFormattingState&gt;(layoutState().establishedFormattingState(m_formattingRoot));</span>
<span class="line-modified">360     auto&amp; floatingState = formattingState.floatingState();</span>
<span class="line-modified">361     auto floatingContext = FloatingContext { floatingState };</span>
<span class="line-modified">362 </span>
<span class="line-modified">363     // Move floats to their final position.</span>
<span class="line-modified">364     for (auto floatItem : floats) {</span>
<span class="line-added">365         auto&amp; floatBox = floatItem-&gt;layoutBox();</span>
<span class="line-added">366         ASSERT(layoutState().hasDisplayBox(floatBox));</span>
<span class="line-added">367         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(floatBox);</span>
<span class="line-added">368         // Set static position first.</span>
<span class="line-added">369         displayBox.setTopLeft({ lineContent.logicalLeft(), lineContent.logicalTop() });</span>
<span class="line-added">370         // Float it.</span>
<span class="line-added">371         displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-added">372         floatingState.append(floatBox);</span>
<span class="line-added">373     }</span>
374 
<a name="60" id="anc60"></a><span class="line-modified">375     if (lineContent.isEmpty()) {</span>
<span class="line-modified">376         // Spec tells us to create a zero height, empty line box.</span>
<span class="line-modified">377         auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0 , 0 };</span>
<span class="line-modified">378         formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
379         return;
<a name="61" id="anc61"></a><span class="line-added">380     }</span>
381 
<a name="62" id="anc62"></a><span class="line-modified">382     auto&amp; inlineDisplayRuns = formattingState.inlineRuns();</span>
<span class="line-modified">383     Optional&lt;unsigned&gt; previousLineLastRunIndex = inlineDisplayRuns.isEmpty() ? Optional&lt;unsigned&gt;() : inlineDisplayRuns.size() - 1;</span>
<span class="line-modified">384     // 9.4.2 Inline formatting contexts</span>
<span class="line-modified">385     // A line box is always tall enough for all of the boxes it contains.</span>
<span class="line-modified">386     auto lineBoxRect = Display::Rect { lineContent.logicalTop(), lineContent.logicalLeft(), 0, lineContent.logicalHeight()};</span>
<span class="line-modified">387     // Create final display runs.</span>
<span class="line-modified">388     auto&amp; lineRuns = lineContent.runs();</span>
<span class="line-added">389     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {</span>
<span class="line-added">390         auto&amp; lineRun = lineRuns.at(index);</span>
<span class="line-added">391         auto&amp; logicalRect = lineRun-&gt;logicalRect();</span>
<span class="line-added">392         auto&amp; layoutBox = lineRun-&gt;layoutBox();</span>
<span class="line-added">393         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-added">394 </span>
<span class="line-added">395         if (lineRun-&gt;isLineBreak()) {</span>
<span class="line-added">396             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">397             displayBox.setContentBoxWidth(logicalRect.width());</span>
<span class="line-added">398             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">399             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">400             continue;</span>
<span class="line-added">401         }</span>
402 
<a name="63" id="anc63"></a><span class="line-modified">403         // Inline level box (replaced or inline-block)</span>
<span class="line-modified">404         if (lineRun-&gt;isBox()) {</span>
<span class="line-modified">405             auto topLeft = logicalRect.topLeft();</span>
<span class="line-added">406             if (layoutBox.isInFlowPositioned())</span>
<span class="line-added">407                 topLeft += Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-added">408             displayBox.setTopLeft(topLeft);</span>
<span class="line-added">409             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">410             formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect));</span>
<span class="line-added">411             continue;</span>
<span class="line-added">412         }</span>
413 
<a name="64" id="anc64"></a><span class="line-modified">414         // Inline level container start (&lt;span&gt;)</span>
<span class="line-modified">415         if (lineRun-&gt;isContainerStart()) {</span>
<span class="line-modified">416             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-modified">417             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-modified">418             continue;</span>
<span class="line-modified">419         }</span>





420 
<a name="65" id="anc65"></a><span class="line-modified">421         // Inline level container end (&lt;/span&gt;)</span>
<span class="line-modified">422         if (lineRun-&gt;isContainerEnd()) {</span>
<span class="line-modified">423             if (layoutBox.isInFlowPositioned()) {</span>
<span class="line-modified">424                 auto inflowOffset = Geometry::inFlowPositionedPositionOffset(layoutState(), layoutBox);</span>
<span class="line-modified">425                 displayBox.moveHorizontally(inflowOffset.width());</span>
<span class="line-modified">426                 displayBox.moveVertically(inflowOffset.height());</span>








427             }
<a name="66" id="anc66"></a><span class="line-modified">428             auto marginBoxWidth = logicalRect.left() - displayBox.left();</span>
<span class="line-modified">429             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));</span>
<span class="line-added">430             // FIXME fix it for multiline.</span>
<span class="line-added">431             displayBox.setContentBoxWidth(contentBoxWidth);</span>
<span class="line-added">432             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">433             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">434             continue;</span>
<span class="line-added">435         }</span>
436 
<a name="67" id="anc67"></a><span class="line-modified">437         // Text content. Try to join multiple text runs when possible.</span>
<span class="line-modified">438         ASSERT(lineRun-&gt;isText());</span>
<span class="line-modified">439         auto textContext = lineRun-&gt;textContext();</span>
<span class="line-added">440         const Line::Content::Run* previousLineRun = !index ? nullptr : lineRuns[index - 1].get();</span>
<span class="line-added">441         if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">442             auto previousRunCanBeExtended = previousLineRun &amp;&amp; previousLineRun-&gt;textContext() ? previousLineRun-&gt;textContext()-&gt;canBeExtended : false;</span>
<span class="line-added">443             auto requiresNewRun = !index || !previousRunCanBeExtended || &amp;layoutBox != &amp;previousLineRun-&gt;layoutBox();</span>
<span class="line-added">444             if (requiresNewRun)</span>
<span class="line-added">445                 formattingState.addInlineRun(makeUnique&lt;Display::Run&gt;(logicalRect, Display::Run::TextContext { textContext-&gt;start, textContext-&gt;length }));</span>
<span class="line-added">446             else {</span>
<span class="line-added">447                 auto&amp; lastDisplayRun = formattingState.inlineRuns().last();</span>
<span class="line-added">448                 lastDisplayRun-&gt;expandHorizontally(logicalRect.width());</span>
<span class="line-added">449                 lastDisplayRun-&gt;textContext()-&gt;expand(textContext-&gt;length);</span>
<span class="line-added">450             }</span>
<span class="line-added">451             lineBoxRect.expandHorizontally(logicalRect.width());</span>
<span class="line-added">452         }</span>
<span class="line-added">453         // FIXME take content breaking into account when part of the layout box is on the previous line.</span>
<span class="line-added">454         auto firstInlineRunForLayoutBox = !previousLineRun || &amp;previousLineRun-&gt;layoutBox() != &amp;layoutBox;</span>
<span class="line-added">455         if (firstInlineRunForLayoutBox) {</span>
<span class="line-added">456             // Setup display box for the associated layout box.</span>
<span class="line-added">457             displayBox.setTopLeft(logicalRect.topLeft());</span>
<span class="line-added">458             displayBox.setContentBoxWidth(textContext-&gt;isCollapsed ? LayoutUnit() : logicalRect.width());</span>
<span class="line-added">459             displayBox.setContentBoxHeight(logicalRect.height());</span>
<span class="line-added">460         } else if (!textContext-&gt;isCollapsed) {</span>
<span class="line-added">461             // FIXME fix it for multirun/multiline.</span>
<span class="line-added">462             displayBox.setContentBoxWidth(displayBox.contentBoxWidth() + logicalRect.width());</span>
463         }
464     }
<a name="68" id="anc68"></a><span class="line-added">465     // FIXME linebox needs to be ajusted after content alignment.</span>
<span class="line-added">466     formattingState.addLineBox({ lineBoxRect, lineContent.baseline(), lineContent.baselineOffset() });</span>
<span class="line-added">467     alignRuns(m_formattingRoot.style().textAlign(), inlineDisplayRuns, previousLineLastRunIndex.valueOr(-1) + 1, widthConstraint - lineContent.logicalWidth());</span>
468 }
469 
<a name="69" id="anc69"></a><span class="line-modified">470 static Optional&lt;LayoutUnit&gt; horizontalAdjustmentForAlignment(TextAlignMode align, LayoutUnit remainingWidth)</span>
471 {
472     switch (align) {
473     case TextAlignMode::Left:
474     case TextAlignMode::WebKitLeft:
475     case TextAlignMode::Start:
<a name="70" id="anc70"></a><span class="line-modified">476         return { };</span>
477     case TextAlignMode::Right:
478     case TextAlignMode::WebKitRight:
479     case TextAlignMode::End:
<a name="71" id="anc71"></a><span class="line-modified">480         return std::max(remainingWidth, 0_lu);</span>
481     case TextAlignMode::Center:
482     case TextAlignMode::WebKitCenter:
<a name="72" id="anc72"></a><span class="line-modified">483         return std::max(remainingWidth / 2, 0_lu);</span>
484     case TextAlignMode::Justify:
485         ASSERT_NOT_REACHED();
486         break;
487     }
488     ASSERT_NOT_REACHED();
<a name="73" id="anc73"></a><span class="line-modified">489     return { };</span>


























































490 }
491 
<a name="74" id="anc74"></a><span class="line-modified">492 void InlineFormattingContext::InlineLayout::alignRuns(TextAlignMode textAlign, InlineRuns&amp; inlineDisplayRuns, unsigned firstRunIndex, LayoutUnit availableWidth) const</span>
493 {
<a name="75" id="anc75"></a><span class="line-modified">494     auto adjustment = horizontalAdjustmentForAlignment(textAlign, availableWidth);</span>
<span class="line-modified">495     if (!adjustment)</span>

496         return;
<a name="76" id="anc76"></a>










497 
<a name="77" id="anc77"></a><span class="line-modified">498     for (unsigned index = firstRunIndex; index &lt; inlineDisplayRuns.size(); ++index)</span>
<span class="line-modified">499         inlineDisplayRuns[index]-&gt;moveHorizontally(*adjustment);</span>




















500 }
501 
502 }
503 }
504 
505 #endif
<a name="78" id="anc78"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="78" type="hidden" />
</body>
</html>