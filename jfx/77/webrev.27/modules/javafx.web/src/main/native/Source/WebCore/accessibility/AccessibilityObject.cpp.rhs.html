<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2009, 2011, 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;AccessibilityObject.h&quot;
  31 
  32 #include &quot;AXObjectCache.h&quot;
  33 #include &quot;AccessibilityRenderObject.h&quot;
  34 #include &quot;AccessibilityScrollView.h&quot;
  35 #include &quot;AccessibilityTable.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  36 #include &quot;Chrome.h&quot;</span>
<span class="line-added">  37 #include &quot;ChromeClient.h&quot;</span>
  38 #include &quot;DOMTokenList.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;ElementIterator.h&quot;
  42 #include &quot;Event.h&quot;
  43 #include &quot;EventDispatcher.h&quot;
  44 #include &quot;EventHandler.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  45 #include &quot;EventNames.h&quot;</span>
  46 #include &quot;FloatRect.h&quot;
  47 #include &quot;FocusController.h&quot;
  48 #include &quot;Frame.h&quot;
  49 #include &quot;FrameLoader.h&quot;
  50 #include &quot;FrameSelection.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  51 #include &quot;HTMLDataListElement.h&quot;</span>
  52 #include &quot;HTMLDetailsElement.h&quot;
  53 #include &quot;HTMLFormControlElement.h&quot;
  54 #include &quot;HTMLInputElement.h&quot;
  55 #include &quot;HTMLMediaElement.h&quot;
  56 #include &quot;HTMLNames.h&quot;
  57 #include &quot;HTMLParserIdioms.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  58 #include &quot;HTMLTextAreaElement.h&quot;</span>
  59 #include &quot;HitTestResult.h&quot;
  60 #include &quot;LocalizedStrings.h&quot;
  61 #include &quot;MathMLNames.h&quot;
  62 #include &quot;NodeList.h&quot;
  63 #include &quot;NodeTraversal.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;RenderImage.h&quot;
  66 #include &quot;RenderLayer.h&quot;
  67 #include &quot;RenderListItem.h&quot;
  68 #include &quot;RenderListMarker.h&quot;
  69 #include &quot;RenderMenuList.h&quot;
  70 #include &quot;RenderText.h&quot;
  71 #include &quot;RenderTextControl.h&quot;
  72 #include &quot;RenderTheme.h&quot;
  73 #include &quot;RenderView.h&quot;
  74 #include &quot;RenderWidget.h&quot;
  75 #include &quot;RenderedPosition.h&quot;
  76 #include &quot;RuntimeEnabledFeatures.h&quot;
  77 #include &quot;Settings.h&quot;
  78 #include &quot;TextCheckerClient.h&quot;
  79 #include &quot;TextCheckingHelper.h&quot;
  80 #include &quot;TextIterator.h&quot;
  81 #include &quot;UserGestureIndicator.h&quot;
  82 #include &quot;VisibleUnits.h&quot;
  83 #include &lt;wtf/NeverDestroyed.h&gt;
  84 #include &lt;wtf/StdLibExtras.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 #include &lt;wtf/text/StringView.h&gt;
  87 #include &lt;wtf/text/WTFString.h&gt;
  88 #include &lt;wtf/unicode/CharacterNames.h&gt;
  89 
  90 namespace WebCore {
  91 
  92 using namespace HTMLNames;
  93 
  94 AccessibilityObject::~AccessibilityObject()
  95 {
  96     ASSERT(isDetached());
  97 }
  98 
  99 void AccessibilityObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
 100 {
 101     // Menu close events need to notify the platform. No element is used in the notification because it&#39;s a destruction event.
 102     if (detachmentType == AccessibilityDetachmentType::ElementDestroyed &amp;&amp; roleValue() == AccessibilityRole::Menu &amp;&amp; cache)
 103         cache-&gt;postNotification(nullptr, &amp;cache-&gt;document(), AXObjectCache::AXMenuClosed);
 104 
 105     // Clear any children and call detachFromParent on them so that
 106     // no children are left with dangling pointers to their parent.
 107     clearChildren();
 108 
<a name="5" id="anc5"></a><span class="line-modified"> 109 #if ENABLE(ACCESSIBILITY)</span>
 110     setWrapper(nullptr);
 111 #endif
 112 }
 113 
 114 bool AccessibilityObject::isDetached() const
 115 {
<a name="6" id="anc6"></a><span class="line-modified"> 116 #if ENABLE(ACCESSIBILITY)</span>
 117     return !wrapper();
 118 #else
 119     return true;
 120 #endif
 121 }
 122 
 123 bool AccessibilityObject::isAccessibilityObjectSearchMatchAtIndex(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria, size_t index)
 124 {
 125     switch (criteria-&gt;searchKeys[index]) {
 126     // The AccessibilitySearchKey::AnyType matches any non-null AccessibilityObject.
 127     case AccessibilitySearchKey::AnyType:
 128         return true;
 129 
 130     case AccessibilitySearchKey::Article:
 131         return axObject-&gt;roleValue() == AccessibilityRole::DocumentArticle;
 132 
 133     case AccessibilitySearchKey::BlockquoteSameLevel:
 134         return criteria-&gt;startObject
 135             &amp;&amp; axObject-&gt;isBlockquote()
 136             &amp;&amp; axObject-&gt;blockquoteLevel() == criteria-&gt;startObject-&gt;blockquoteLevel();
 137 
 138     case AccessibilitySearchKey::Blockquote:
 139         return axObject-&gt;isBlockquote();
 140 
 141     case AccessibilitySearchKey::BoldFont:
 142         return axObject-&gt;hasBoldFont();
 143 
 144     case AccessibilitySearchKey::Button:
 145         return axObject-&gt;isButton();
 146 
 147     case AccessibilitySearchKey::CheckBox:
 148         return axObject-&gt;isCheckbox();
 149 
 150     case AccessibilitySearchKey::Control:
 151         return axObject-&gt;isControl();
 152 
 153     case AccessibilitySearchKey::DifferentType:
 154         return criteria-&gt;startObject
 155             &amp;&amp; axObject-&gt;roleValue() != criteria-&gt;startObject-&gt;roleValue();
 156 
 157     case AccessibilitySearchKey::FontChange:
 158         return criteria-&gt;startObject
 159             &amp;&amp; !axObject-&gt;hasSameFont(criteria-&gt;startObject-&gt;renderer());
 160 
 161     case AccessibilitySearchKey::FontColorChange:
 162         return criteria-&gt;startObject
 163             &amp;&amp; !axObject-&gt;hasSameFontColor(criteria-&gt;startObject-&gt;renderer());
 164 
 165     case AccessibilitySearchKey::Frame:
 166         return axObject-&gt;isWebArea();
 167 
 168     case AccessibilitySearchKey::Graphic:
 169         return axObject-&gt;isImage();
 170 
 171     case AccessibilitySearchKey::HeadingLevel1:
 172         return axObject-&gt;headingLevel() == 1;
 173 
 174     case AccessibilitySearchKey::HeadingLevel2:
 175         return axObject-&gt;headingLevel() == 2;
 176 
 177     case AccessibilitySearchKey::HeadingLevel3:
 178         return axObject-&gt;headingLevel() == 3;
 179 
 180     case AccessibilitySearchKey::HeadingLevel4:
 181         return axObject-&gt;headingLevel() == 4;
 182 
 183     case AccessibilitySearchKey::HeadingLevel5:
 184         return axObject-&gt;headingLevel() == 5;
 185 
 186     case AccessibilitySearchKey::HeadingLevel6:
 187         return axObject-&gt;headingLevel() == 6;
 188 
 189     case AccessibilitySearchKey::HeadingSameLevel:
 190         return criteria-&gt;startObject
 191             &amp;&amp; axObject-&gt;isHeading()
 192             &amp;&amp; axObject-&gt;headingLevel() == criteria-&gt;startObject-&gt;headingLevel();
 193 
 194     case AccessibilitySearchKey::Heading:
 195         return axObject-&gt;isHeading();
 196 
 197     case AccessibilitySearchKey::Highlighted:
 198         return axObject-&gt;hasHighlighting();
 199 
<a name="7" id="anc7"></a><span class="line-added"> 200     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added"> 201         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added"> 202 </span>
 203     case AccessibilitySearchKey::ItalicFont:
 204         return axObject-&gt;hasItalicFont();
 205 
 206     case AccessibilitySearchKey::Landmark:
 207         return axObject-&gt;isLandmark();
 208 
 209     case AccessibilitySearchKey::Link: {
 210         bool isLink = axObject-&gt;isLink();
 211 #if PLATFORM(IOS_FAMILY)
 212         if (!isLink)
 213             isLink = axObject-&gt;isDescendantOfRole(AccessibilityRole::WebCoreLink);
 214 #endif
 215         return isLink;
 216     }
 217 
 218     case AccessibilitySearchKey::List:
 219         return axObject-&gt;isList();
 220 
 221     case AccessibilitySearchKey::LiveRegion:
 222         return axObject-&gt;supportsLiveRegion();
 223 
 224     case AccessibilitySearchKey::MisspelledWord:
 225         return axObject-&gt;hasMisspelling();
 226 
 227     case AccessibilitySearchKey::Outline:
 228         return axObject-&gt;isTree();
 229 
 230     case AccessibilitySearchKey::PlainText:
 231         return axObject-&gt;hasPlainText();
 232 
 233     case AccessibilitySearchKey::RadioGroup:
 234         return axObject-&gt;isRadioGroup();
 235 
 236     case AccessibilitySearchKey::SameType:
 237         return criteria-&gt;startObject
 238             &amp;&amp; axObject-&gt;roleValue() == criteria-&gt;startObject-&gt;roleValue();
 239 
 240     case AccessibilitySearchKey::StaticText:
 241         return axObject-&gt;isStaticText();
 242 
 243     case AccessibilitySearchKey::StyleChange:
 244         return criteria-&gt;startObject
 245             &amp;&amp; !axObject-&gt;hasSameStyle(criteria-&gt;startObject-&gt;renderer());
 246 
 247     case AccessibilitySearchKey::TableSameLevel:
 248         return criteria-&gt;startObject
 249             &amp;&amp; is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility()
 250             &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).tableLevel() == criteria-&gt;startObject-&gt;tableLevel();
 251 
 252     case AccessibilitySearchKey::Table:
 253         return is&lt;AccessibilityTable&gt;(*axObject) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*axObject).isExposableThroughAccessibility();
 254 
 255     case AccessibilitySearchKey::TextField:
 256         return axObject-&gt;isTextControl();
 257 
 258     case AccessibilitySearchKey::Underline:
 259         return axObject-&gt;hasUnderline();
 260 
 261     case AccessibilitySearchKey::UnvisitedLink:
 262         return axObject-&gt;isUnvisited();
 263 
 264     case AccessibilitySearchKey::VisitedLink:
 265         return axObject-&gt;isVisited();
 266 
 267     default:
 268         return false;
 269     }
 270 }
 271 
 272 bool AccessibilityObject::isAccessibilityObjectSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)
 273 {
 274     if (!axObject || !criteria)
 275         return false;
 276 
 277     size_t length = criteria-&gt;searchKeys.size();
 278     for (size_t i = 0; i &lt; length; ++i) {
 279         if (isAccessibilityObjectSearchMatchAtIndex(axObject, criteria, i)) {
 280             if (criteria-&gt;visibleOnly &amp;&amp; !axObject-&gt;isOnscreen())
 281                 return false;
 282             return true;
 283         }
 284     }
 285     return false;
 286 }
 287 
 288 bool AccessibilityObject::isAccessibilityTextSearchMatch(AccessibilityObject* axObject, AccessibilitySearchCriteria* criteria)
 289 {
 290     if (!axObject || !criteria)
 291         return false;
 292 
 293     return axObject-&gt;accessibilityObjectContainsText(&amp;criteria-&gt;searchText);
 294 }
 295 
 296 bool AccessibilityObject::accessibilityObjectContainsText(String* text) const
 297 {
 298     // If text is null or empty we return true.
 299     return !text
 300         || text-&gt;isEmpty()
 301         || findPlainText(title(), *text, CaseInsensitive)
 302         || findPlainText(accessibilityDescription(), *text, CaseInsensitive)
 303         || findPlainText(stringValue(), *text, CaseInsensitive);
 304 }
 305 
 306 // ARIA marks elements as having their accessible name derive from either their contents, or their author provide name.
 307 bool AccessibilityObject::accessibleNameDerivesFromContent() const
 308 {
 309     // First check for objects specifically identified by ARIA.
 310     switch (ariaRoleAttribute()) {
 311     case AccessibilityRole::ApplicationAlert:
 312     case AccessibilityRole::ApplicationAlertDialog:
 313     case AccessibilityRole::ApplicationDialog:
 314     case AccessibilityRole::ApplicationGroup:
 315     case AccessibilityRole::ApplicationLog:
 316     case AccessibilityRole::ApplicationMarquee:
 317     case AccessibilityRole::ApplicationStatus:
 318     case AccessibilityRole::ApplicationTimer:
 319     case AccessibilityRole::ComboBox:
 320     case AccessibilityRole::Definition:
 321     case AccessibilityRole::Document:
 322     case AccessibilityRole::DocumentArticle:
 323     case AccessibilityRole::DocumentMath:
 324     case AccessibilityRole::DocumentNote:
 325     case AccessibilityRole::LandmarkRegion:
 326     case AccessibilityRole::LandmarkDocRegion:
 327     case AccessibilityRole::Form:
 328     case AccessibilityRole::Grid:
 329     case AccessibilityRole::Group:
 330     case AccessibilityRole::Image:
 331     case AccessibilityRole::List:
 332     case AccessibilityRole::ListBox:
 333     case AccessibilityRole::LandmarkBanner:
 334     case AccessibilityRole::LandmarkComplementary:
 335     case AccessibilityRole::LandmarkContentInfo:
 336     case AccessibilityRole::LandmarkNavigation:
 337     case AccessibilityRole::LandmarkMain:
 338     case AccessibilityRole::LandmarkSearch:
 339     case AccessibilityRole::Menu:
 340     case AccessibilityRole::MenuBar:
 341     case AccessibilityRole::ProgressIndicator:
<a name="8" id="anc8"></a><span class="line-added"> 342     case AccessibilityRole::Meter:</span>
 343     case AccessibilityRole::RadioGroup:
 344     case AccessibilityRole::ScrollBar:
 345     case AccessibilityRole::Slider:
 346     case AccessibilityRole::SpinButton:
 347     case AccessibilityRole::Splitter:
 348     case AccessibilityRole::Table:
 349     case AccessibilityRole::TabList:
 350     case AccessibilityRole::TabPanel:
 351     case AccessibilityRole::TextArea:
 352     case AccessibilityRole::TextField:
 353     case AccessibilityRole::Toolbar:
 354     case AccessibilityRole::TreeGrid:
 355     case AccessibilityRole::Tree:
 356     case AccessibilityRole::WebApplication:
 357         return false;
 358     default:
 359         break;
 360     }
 361 
 362     // Now check for generically derived elements now that we know the element does not match a specific ARIA role.
 363     switch (roleValue()) {
 364     case AccessibilityRole::Slider:
 365     case AccessibilityRole::ListBox:
 366         return false;
 367     default:
 368         break;
 369     }
 370 
 371     return true;
 372 }
 373 
 374 String AccessibilityObject::computedLabel()
 375 {
 376     // This method is being called by WebKit inspector, which may happen at any time, so we need to update our backing store now.
 377     // Also hold onto this object in case updateBackingStore deletes this node.
 378     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
 379     updateBackingStore();
 380     Vector&lt;AccessibilityText&gt; text;
 381     accessibilityText(text);
 382     if (text.size())
 383         return text[0].text;
 384     return String();
 385 }
 386 
 387 bool AccessibilityObject::isBlockquote() const
 388 {
 389     return roleValue() == AccessibilityRole::Blockquote;
 390 }
 391 
 392 bool AccessibilityObject::isTextControl() const
 393 {
 394     switch (roleValue()) {
 395     case AccessibilityRole::ComboBox:
 396     case AccessibilityRole::SearchField:
 397     case AccessibilityRole::TextArea:
 398     case AccessibilityRole::TextField:
 399         return true;
 400     default:
 401         return false;
 402     }
 403 }
 404 
 405 bool AccessibilityObject::isARIATextControl() const
 406 {
 407     return ariaRoleAttribute() == AccessibilityRole::TextArea || ariaRoleAttribute() == AccessibilityRole::TextField || ariaRoleAttribute() == AccessibilityRole::SearchField;
 408 }
 409 
 410 bool AccessibilityObject::isNonNativeTextControl() const
 411 {
 412     return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
 413 }
 414 
 415 bool AccessibilityObject::isLandmark() const
 416 {
<a name="9" id="anc9"></a><span class="line-modified"> 417     switch (roleValue()) {</span>
<span class="line-modified"> 418     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-modified"> 419     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-modified"> 420     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-modified"> 421     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-modified"> 422     case AccessibilityRole::LandmarkMain:</span>
<span class="line-modified"> 423     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-modified"> 424     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-modified"> 425     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-modified"> 426         return true;</span>
<span class="line-added"> 427     default:</span>
<span class="line-added"> 428         return false;</span>
<span class="line-added"> 429     }</span>
 430 }
 431 
 432 bool AccessibilityObject::hasMisspelling() const
 433 {
 434     if (!node())
 435         return false;
 436 
 437     Frame* frame = node()-&gt;document().frame();
 438     if (!frame)
 439         return false;
 440 
 441     Editor&amp; editor = frame-&gt;editor();
 442 
 443     TextCheckerClient* textChecker = editor.textChecker();
 444     if (!textChecker)
 445         return false;
 446 
 447     bool isMisspelled = false;
 448 
 449     if (unifiedTextCheckerEnabled(frame)) {
 450         Vector&lt;TextCheckingResult&gt; results;
 451         checkTextOfParagraph(*textChecker, stringValue(), TextCheckingType::Spelling, results, frame-&gt;selection().selection());
 452         if (!results.isEmpty())
 453             isMisspelled = true;
 454         return isMisspelled;
 455     }
 456 
 457     int misspellingLength = 0;
 458     int misspellingLocation = -1;
 459     textChecker-&gt;checkSpellingOfString(stringValue(), &amp;misspellingLocation, &amp;misspellingLength);
 460     if (misspellingLength || misspellingLocation != -1)
 461         isMisspelled = true;
 462 
 463     return isMisspelled;
 464 }
 465 
 466 unsigned AccessibilityObject::blockquoteLevel() const
 467 {
 468     unsigned level = 0;
 469     for (Node* elementNode = node(); elementNode; elementNode = elementNode-&gt;parentNode()) {
 470         if (elementNode-&gt;hasTagName(blockquoteTag))
 471             ++level;
 472     }
 473 
 474     return level;
 475 }
 476 
 477 AccessibilityObject* AccessibilityObject::parentObjectUnignored() const
 478 {
 479     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
 480         return !object.accessibilityIsIgnored();
 481     }));
 482 }
 483 
 484 AccessibilityObject* AccessibilityObject::previousSiblingUnignored(int limit) const
 485 {
 486     AccessibilityObject* previous;
 487     ASSERT(limit &gt;= 0);
 488     for (previous = previousSibling(); previous &amp;&amp; previous-&gt;accessibilityIsIgnored(); previous = previous-&gt;previousSibling()) {
 489         limit--;
 490         if (limit &lt;= 0)
 491             break;
 492     }
 493     return previous;
 494 }
 495 
<a name="10" id="anc10"></a><span class="line-added"> 496 FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const</span>
<span class="line-added"> 497 {</span>
<span class="line-added"> 498     ASSERT(isMainThread());</span>
<span class="line-added"> 499 </span>
<span class="line-added"> 500     // Find the appropriate scroll view to use to convert the contents to the window.</span>
<span class="line-added"> 501     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);</span>
<span class="line-added"> 502     auto* parentScrollView = parentAccessibilityScrollView ? parentAccessibilityScrollView-&gt;scrollView() : nullptr;</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504     auto snappedFrameRect = snappedIntRect(IntRect(frameRect));</span>
<span class="line-added"> 505     if (parentScrollView)</span>
<span class="line-added"> 506         snappedFrameRect = parentScrollView-&gt;contentsToRootView(snappedFrameRect);</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508     if (conversionSpace == AccessibilityConversionSpace::Screen) {</span>
<span class="line-added"> 509         auto page = this-&gt;page();</span>
<span class="line-added"> 510         if (!page)</span>
<span class="line-added"> 511             return snappedFrameRect;</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513         // If we have an empty chrome client (like SVG) then we should use the page</span>
<span class="line-added"> 514         // of the scroll view parent to help us get to the screen rect.</span>
<span class="line-added"> 515         if (parentAccessibilityScrollView &amp;&amp; page-&gt;chrome().client().isEmptyChromeClient())</span>
<span class="line-added"> 516             page = parentAccessibilityScrollView-&gt;page();</span>
<span class="line-added"> 517 </span>
<span class="line-added"> 518         snappedFrameRect = page-&gt;chrome().rootViewToAccessibilityScreen(snappedFrameRect);</span>
<span class="line-added"> 519     }</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     return snappedFrameRect;</span>
<span class="line-added"> 522 }</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524 FloatRect AccessibilityObject::relativeFrame() const</span>
<span class="line-added"> 525 {</span>
<span class="line-added"> 526     return convertFrameToSpace(elementRect(), AccessibilityConversionSpace::Page);</span>
<span class="line-added"> 527 }</span>
<span class="line-added"> 528 </span>
 529 AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
 530 {
 531     AccessibilityObject* next;
 532     ASSERT(limit &gt;= 0);
 533     for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
 534         limit--;
 535         if (limit &lt;= 0)
 536             break;
 537     }
 538     return next;
 539 }
 540 
 541 AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
<a name="11" id="anc11"></a><span class="line-added"> 542 {</span>
<span class="line-added"> 543     return WebCore::firstAccessibleObjectFromNode(node, [] (const AccessibilityObject&amp; accessible) {</span>
<span class="line-added"> 544         return !accessible.accessibilityIsIgnored();</span>
<span class="line-added"> 545     });</span>
<span class="line-added"> 546 }</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548 AccessibilityObject* firstAccessibleObjectFromNode(const Node* node, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible)</span>
 549 {
 550     if (!node)
 551         return nullptr;
 552 
 553     AXObjectCache* cache = node-&gt;document().axObjectCache();
 554     if (!cache)
 555         return nullptr;
 556 
 557     AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
<a name="12" id="anc12"></a><span class="line-modified"> 558     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {</span>
 559         node = NodeTraversal::next(*node);
 560 
 561         while (node &amp;&amp; !node-&gt;renderer())
 562             node = NodeTraversal::nextSkippingChildren(*node);
 563 
 564         if (!node)
 565             return nullptr;
 566 
 567         accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
 568     }
 569 
 570     return accessibleObject;
 571 }
 572 
 573 bool AccessibilityObject::isDescendantOfRole(AccessibilityRole role) const
 574 {
 575     return AccessibilityObject::matchedParent(*this, false, [&amp;role] (const AccessibilityObject&amp; object) {
 576         return object.roleValue() == role;
 577     }) != nullptr;
 578 }
 579 
 580 static void appendAccessibilityObject(AccessibilityObject* object, AccessibilityObject::AccessibilityChildrenVector&amp; results)
 581 {
 582     // Find the next descendant of this attachment object so search can continue through frames.
 583     if (object-&gt;isAttachment()) {
 584         Widget* widget = object-&gt;widgetForAttachmentView();
 585         if (!is&lt;FrameView&gt;(widget))
 586             return;
 587 
 588         Document* document = downcast&lt;FrameView&gt;(*widget).frame().document();
 589         if (!document || !document-&gt;hasLivingRenderTree())
 590             return;
 591 
 592         object = object-&gt;axObjectCache()-&gt;getOrCreate(document);
 593     }
 594 
 595     if (object)
 596         results.append(object);
 597 }
 598 
 599 void AccessibilityObject::insertChild(AccessibilityObject* child, unsigned index)
 600 {
 601     if (!child)
 602         return;
 603 
 604     // If the parent is asking for this child&#39;s children, then either it&#39;s the first time (and clearing is a no-op),
 605     // or its visibility has changed. In the latter case, this child may have a stale child cached.
 606     // This can prevent aria-hidden changes from working correctly. Hence, whenever a parent is getting children, ensure data is not stale.
 607     // Only clear the child&#39;s children when we know it&#39;s in the updating chain in order to avoid unnecessary work.
 608     if (child-&gt;needsToUpdateChildren() || m_subtreeDirty) {
 609         child-&gt;clearChildren();
 610         // Pass m_subtreeDirty flag down to the child so that children cache gets reset properly.
 611         if (m_subtreeDirty)
 612             child-&gt;setNeedsToUpdateSubtree();
 613     } else {
 614         // For some reason the grand children might be detached so that we need to regenerate the
 615         // children list of this child.
 616         for (const auto&amp; grandChild : child-&gt;children(false)) {
 617             if (grandChild-&gt;isDetachedFromParent()) {
 618                 child-&gt;clearChildren();
 619                 break;
 620             }
 621         }
 622     }
 623 
 624     setIsIgnoredFromParentDataForChild(child);
 625     if (child-&gt;accessibilityIsIgnored()) {
 626         const auto&amp; children = child-&gt;children();
 627         size_t length = children.size();
 628         for (size_t i = 0; i &lt; length; ++i)
 629             m_children.insert(index + i, children[i]);
 630     } else {
 631         ASSERT(child-&gt;parentObject() == this);
 632         m_children.insert(index, child);
 633     }
 634 
 635     // Reset the child&#39;s m_isIgnoredFromParentData since we are done adding that child and its children.
 636     child-&gt;clearIsIgnoredFromParentData();
 637 }
 638 
 639 void AccessibilityObject::addChild(AccessibilityObject* child)
 640 {
 641     insertChild(child, m_children.size());
 642 }
 643 
 644 static void appendChildrenToArray(AccessibilityObject* object, bool isForward, AccessibilityObject* startObject, AccessibilityObject::AccessibilityChildrenVector&amp; results)
 645 {
 646     // A table&#39;s children includes elements whose own children are also the table&#39;s children (due to the way the Mac exposes tables).
 647     // The rows from the table should be queried, since those are direct descendants of the table, and they contain content.
 648     const auto&amp; searchChildren = is&lt;AccessibilityTable&gt;(*object) &amp;&amp; downcast&lt;AccessibilityTable&gt;(*object).isExposableThroughAccessibility() ? downcast&lt;AccessibilityTable&gt;(*object).rows() : object-&gt;children();
 649 
 650     size_t childrenSize = searchChildren.size();
 651 
 652     size_t startIndex = isForward ? childrenSize : 0;
 653     size_t endIndex = isForward ? 0 : childrenSize;
 654 
 655     // If the startObject is ignored, we should use an accessible sibling as a start element instead.
 656     if (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored() &amp;&amp; startObject-&gt;isDescendantOfObject(object)) {
 657         AccessibilityObject* parentObject = startObject-&gt;parentObject();
 658         // Go up the parent chain to find the highest ancestor that&#39;s also being ignored.
 659         while (parentObject &amp;&amp; parentObject-&gt;accessibilityIsIgnored()) {
 660             if (parentObject == object)
 661                 break;
 662             startObject = parentObject;
 663             parentObject = parentObject-&gt;parentObject();
 664         }
 665         // Get the un-ignored sibling based on the search direction, and update the searchPosition.
 666         while (startObject &amp;&amp; startObject-&gt;accessibilityIsIgnored())
 667             startObject = isForward ? startObject-&gt;previousSibling() : startObject-&gt;nextSibling();
 668     }
 669 
 670     size_t searchPosition = startObject ? searchChildren.find(startObject) : WTF::notFound;
 671 
 672     if (searchPosition != WTF::notFound) {
 673         if (isForward)
 674             endIndex = searchPosition + 1;
 675         else
 676             endIndex = searchPosition;
 677     }
 678 
 679     // This is broken into two statements so that it&#39;s easier read.
 680     if (isForward) {
 681         for (size_t i = startIndex; i &gt; endIndex; i--)
 682             appendAccessibilityObject(searchChildren.at(i - 1).get(), results);
 683     } else {
 684         for (size_t i = startIndex; i &lt; endIndex; i++)
 685             appendAccessibilityObject(searchChildren.at(i).get(), results);
 686     }
 687 }
 688 
 689 // Returns true if the number of results is now &gt;= the number of results desired.
 690 bool AccessibilityObject::objectMatchesSearchCriteriaWithResultLimit(AccessibilityObject* object, AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 691 {
 692     if (isAccessibilityObjectSearchMatch(object, criteria) &amp;&amp; isAccessibilityTextSearchMatch(object, criteria)) {
 693         results.append(object);
 694 
 695         // Enough results were found to stop searching.
 696         if (results.size() &gt;= criteria-&gt;resultsLimit)
 697             return true;
 698     }
 699 
 700     return false;
 701 }
 702 
 703 void AccessibilityObject::findMatchingObjects(AccessibilitySearchCriteria* criteria, AccessibilityChildrenVector&amp; results)
 704 {
 705     ASSERT(criteria);
 706 
 707     if (!criteria)
 708         return;
 709 
 710     if (AXObjectCache* cache = axObjectCache())
 711         cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
 712 
 713     // This search mechanism only searches the elements before/after the starting object.
 714     // It does this by stepping up the parent chain and at each level doing a DFS.
 715 
 716     // If there&#39;s no start object, it means we want to search everything.
 717     AccessibilityObject* startObject = criteria-&gt;startObject;
 718     if (!startObject)
 719         startObject = this;
 720 
 721     bool isForward = criteria-&gt;searchDirection == AccessibilitySearchDirection::Next;
 722 
 723     // The first iteration of the outer loop will examine the children of the start object for matches. However, when
 724     // iterating backwards, the start object children should not be considered, so the loop is skipped ahead. We make an
 725     // exception when no start object was specified because we want to search everything regardless of search direction.
 726     AccessibilityObject* previousObject = nullptr;
 727     if (!isForward &amp;&amp; startObject != this) {
 728         previousObject = startObject;
 729         startObject = startObject-&gt;parentObjectUnignored();
 730     }
 731 
 732     // The outer loop steps up the parent chain each time (unignored is important here because otherwise elements would be searched twice)
 733     for (AccessibilityObject* stopSearchElement = parentObjectUnignored(); startObject &amp;&amp; startObject != stopSearchElement; startObject = startObject-&gt;parentObjectUnignored()) {
 734 
 735         // Only append the children after/before the previous element, so that the search does not check elements that are
 736         // already behind/ahead of start element.
 737         AccessibilityChildrenVector searchStack;
 738         if (!criteria-&gt;immediateDescendantsOnly || startObject == this)
 739             appendChildrenToArray(startObject, isForward, previousObject, searchStack);
 740 
 741         // This now does a DFS at the current level of the parent.
 742         while (!searchStack.isEmpty()) {
 743             AccessibilityObject* searchObject = searchStack.last().get();
 744             searchStack.removeLast();
 745 
 746             if (objectMatchesSearchCriteriaWithResultLimit(searchObject, criteria, results))
 747                 break;
 748 
 749             if (!criteria-&gt;immediateDescendantsOnly)
 750                 appendChildrenToArray(searchObject, isForward, 0, searchStack);
 751         }
 752 
 753         if (results.size() &gt;= criteria-&gt;resultsLimit)
 754             break;
 755 
 756         // When moving backwards, the parent object needs to be checked, because technically it&#39;s &quot;before&quot; the starting element.
 757         if (!isForward &amp;&amp; startObject != this &amp;&amp; objectMatchesSearchCriteriaWithResultLimit(startObject, criteria, results))
 758             break;
 759 
 760         previousObject = startObject;
 761     }
 762 }
 763 
 764 // Returns the range that is fewer positions away from the reference range.
 765 // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
 766 // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<a name="13" id="anc13"></a><span class="line-modified"> 767 static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)</span>
 768 {
 769     if (!referenceRange)
 770         return nullptr;
 771 
 772     // The treeScope for shadow nodes may not be the same scope as another element in a document.
 773     // Comparisons may fail in that case, which are expected behavior and should not assert.
 774     if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 775         return nullptr;
<a name="14" id="anc14"></a><span class="line-modified"> 776     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);</span>
 777 
 778     if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
 779         return nullptr;
<a name="15" id="anc15"></a><span class="line-modified"> 780     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);</span>
 781 
 782     if (!afterRange &amp;&amp; !beforeRange)
 783         return nullptr;
 784     if (afterRange &amp;&amp; !beforeRange)
 785         return WTFMove(afterRange);
 786     if (!afterRange &amp;&amp; beforeRange)
 787         return WTFMove(beforeRange);
 788 
 789     unsigned positionsToAfterRange = Position::positionCountBetweenPositions(afterRange-&gt;startPosition(), referenceRange-&gt;endPosition());
 790     unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
 791 
 792     return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
 793 }
 794 
<a name="16" id="anc16"></a><span class="line-modified"> 795 RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt; const&amp; searchStrings) const</span>
 796 {
 797     Frame* frame = this-&gt;frame();
 798     if (!frame)
 799         return nullptr;
 800 
 801     if (!referenceRange)
 802         return nullptr;
 803 
 804     bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
 805     FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
 806     if (isBackwardSearch)
<a name="17" id="anc17"></a><span class="line-modified"> 807         findOptions.add(FindOptionFlag::Backwards);</span>
 808 
 809     RefPtr&lt;Range&gt; closestStringRange = nullptr;
 810     for (const auto&amp; searchString : searchStrings) {
 811         if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
 812             if (!closestStringRange)
 813                 closestStringRange = searchStringRange;
 814             else {
 815                 // If searching backward, use the trailing range edges to correctly determine which
 816                 // range is closest. Similarly, if searching forward, use the leading range edges.
 817                 Position closestStringPosition = isBackwardSearch ? closestStringRange-&gt;endPosition() : closestStringRange-&gt;startPosition();
 818                 Position searchStringPosition = isBackwardSearch ? searchStringRange-&gt;endPosition() : searchStringRange-&gt;startPosition();
 819 
 820                 int closestPositionOffset = closestStringPosition.computeOffsetInContainerNode();
 821                 int searchPositionOffset = searchStringPosition.computeOffsetInContainerNode();
 822                 Node* closestContainerNode = closestStringPosition.containerNode();
 823                 Node* searchContainerNode = searchStringPosition.containerNode();
 824 
 825                 short result = Range::compareBoundaryPoints(closestContainerNode, closestPositionOffset, searchContainerNode, searchPositionOffset).releaseReturnValue();
 826                 if ((!isBackwardSearch &amp;&amp; result &gt; 0) || (isBackwardSearch &amp;&amp; result &lt; 0))
 827                     closestStringRange = searchStringRange;
 828             }
 829         }
 830     }
 831     return closestStringRange;
 832 }
 833 
 834 // Returns the range of the entire document if there is no selection.
 835 RefPtr&lt;Range&gt; AccessibilityObject::selectionRange() const
 836 {
 837     Frame* frame = this-&gt;frame();
 838     if (!frame)
 839         return nullptr;
 840 
 841     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
 842     if (!selection.isNone())
 843         return selection.firstRange();
 844 
 845     return Range::create(*frame-&gt;document());
 846 }
 847 
 848 RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
 849 {
 850     return AXObjectCache::rangeForNodeContents(node());
 851 }
 852 
<a name="18" id="anc18"></a><span class="line-modified"> 853 RefPtr&lt;Range&gt; AccessibilityObject::findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection direction) const</span>
 854 {
<a name="19" id="anc19"></a><span class="line-modified"> 855     RefPtr&lt;Range&gt; found;</span>
<span class="line-modified"> 856     if (direction == AccessibilitySearchTextDirection::Forward)</span>
<span class="line-modified"> 857         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified"> 858     else if (direction == AccessibilitySearchTextDirection::Backward)</span>
<span class="line-modified"> 859         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-modified"> 860     else if (direction == AccessibilitySearchTextDirection::Closest) {</span>
<span class="line-modified"> 861         auto foundAfter = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified"> 862         auto foundBefore = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-added"> 863         found = rangeClosestToRange(start.get(), WTFMove(foundAfter), WTFMove(foundBefore));</span>
<span class="line-added"> 864     }</span>
 865 
<a name="20" id="anc20"></a><span class="line-modified"> 866     if (found) {</span>



















 867         // If the search started within a text control, ensure that the result is inside that element.
 868         if (element() &amp;&amp; element()-&gt;isTextField()) {
<a name="21" id="anc21"></a><span class="line-modified"> 869             if (!found-&gt;startContainer().isDescendantOrShadowDescendantOf(element())</span>
<span class="line-modified"> 870                 || !found-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))</span>
<span class="line-added"> 871                 return nullptr;</span>
 872         }
<a name="22" id="anc22"></a><span class="line-added"> 873     }</span>
<span class="line-added"> 874     return found;</span>
<span class="line-added"> 875 }</span>
 876 
<a name="23" id="anc23"></a><span class="line-modified"> 877 Vector&lt;RefPtr&lt;Range&gt;&gt; AccessibilityObject::findTextRanges(AccessibilitySearchTextCriteria const&amp; criteria) const</span>
<span class="line-modified"> 878 {</span>
<span class="line-modified"> 879     Vector&lt;RefPtr&lt;Range&gt;&gt; result;</span>




























 880 
<a name="24" id="anc24"></a><span class="line-modified"> 881     // Determine start range.</span>
<span class="line-modified"> 882     RefPtr&lt;Range&gt; startRange;</span>
<span class="line-modified"> 883     if (criteria.start == AccessibilitySearchTextStartFrom::Selection)</span>
<span class="line-modified"> 884         startRange = selectionRange();</span>
<span class="line-modified"> 885     else</span>
<span class="line-added"> 886         startRange = elementRange();</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     if (startRange) {</span>
<span class="line-added"> 889         // Collapse the range to the start unless searching from the end of the doc or searching backwards.</span>
<span class="line-added"> 890         if (criteria.start == AccessibilitySearchTextStartFrom::Begin)</span>
<span class="line-added"> 891             startRange-&gt;collapse(true);</span>
<span class="line-added"> 892         else if (criteria.start == AccessibilitySearchTextStartFrom::End)</span>
<span class="line-added"> 893             startRange-&gt;collapse(false);</span>
<span class="line-added"> 894         else</span>
<span class="line-added"> 895             startRange-&gt;collapse(criteria.direction != AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added"> 896     } else</span>
<span class="line-added"> 897         return result;</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899     RefPtr&lt;Range&gt; found;</span>
<span class="line-added"> 900     switch (criteria.direction) {</span>
<span class="line-added"> 901     case AccessibilitySearchTextDirection::Forward:</span>
<span class="line-added"> 902     case AccessibilitySearchTextDirection::Backward:</span>
<span class="line-added"> 903     case AccessibilitySearchTextDirection::Closest:</span>
<span class="line-added"> 904         found = findTextRange(criteria.searchStrings, startRange, criteria.direction);</span>
<span class="line-added"> 905         if (found)</span>
<span class="line-added"> 906             result.append(found);</span>
<span class="line-added"> 907         break;</span>
<span class="line-added"> 908     case AccessibilitySearchTextDirection::All: {</span>
<span class="line-added"> 909         auto findAll = [&amp;](AccessibilitySearchTextDirection dir) {</span>
<span class="line-added"> 910             found = findTextRange(criteria.searchStrings, startRange, dir);</span>
<span class="line-added"> 911             while (found) {</span>
<span class="line-added"> 912                 result.append(found);</span>
<span class="line-added"> 913                 found = findTextRange(criteria.searchStrings, found, dir);</span>
 914             }
<a name="25" id="anc25"></a><span class="line-added"> 915         };</span>
<span class="line-added"> 916         findAll(AccessibilitySearchTextDirection::Forward);</span>
<span class="line-added"> 917         findAll(AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added"> 918         break;</span>
<span class="line-added"> 919     }</span>
<span class="line-added"> 920     }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922     return result;</span>
<span class="line-added"> 923 }</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925 Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)</span>
<span class="line-added"> 926 {</span>
<span class="line-added"> 927     Vector&lt;String&gt; result;</span>
<span class="line-added"> 928 </span>
<span class="line-added"> 929     if (operation.textRanges.isEmpty())</span>
<span class="line-added"> 930         return result;</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932     Frame* frame = this-&gt;frame();</span>
<span class="line-added"> 933     if (!frame)</span>
<span class="line-added"> 934         return result;</span>
 935 
<a name="26" id="anc26"></a><span class="line-modified"> 936     for (auto textRange : operation.textRanges) {</span>
<span class="line-added"> 937         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))</span>
<span class="line-added"> 938             continue;</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940         String text = textRange-&gt;text();</span>
<span class="line-added"> 941         String replacementString = operation.replacementText;</span>
<span class="line-added"> 942         bool replaceSelection = false;</span>
<span class="line-added"> 943         switch (operation.type) {</span>
<span class="line-added"> 944         case AccessibilityTextOperationType::Capitalize:</span>
<span class="line-added"> 945             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added"> 946             replaceSelection = true;</span>
<span class="line-added"> 947             break;</span>
<span class="line-added"> 948         case AccessibilityTextOperationType::Uppercase:</span>
<span class="line-added"> 949             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 950             replaceSelection = true;</span>
<span class="line-added"> 951             break;</span>
<span class="line-added"> 952         case AccessibilityTextOperationType::Lowercase:</span>
<span class="line-added"> 953             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 954             replaceSelection = true;</span>
<span class="line-added"> 955             break;</span>
<span class="line-added"> 956         case AccessibilityTextOperationType::Replace: {</span>
<span class="line-added"> 957             replaceSelection = true;</span>
<span class="line-added"> 958             // When applying find and replace activities, we want to match the capitalization of the replaced text,</span>
<span class="line-added"> 959             // (unless we&#39;re replacing with an abbreviation.)</span>
<span class="line-added"> 960             if (text.length() &gt; 0</span>
<span class="line-added"> 961                 &amp;&amp; replacementString.length() &gt; 2</span>
<span class="line-added"> 962                 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {</span>
<span class="line-added"> 963                 if (text[0] == u_toupper(text[0]))</span>
<span class="line-added"> 964                     replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added"> 965                 else</span>
<span class="line-added"> 966                     replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added"> 967             }</span>
<span class="line-added"> 968             break;</span>
 969         }
<a name="27" id="anc27"></a><span class="line-added"> 970         case AccessibilityTextOperationType::Select:</span>
<span class="line-added"> 971             break;</span>
<span class="line-added"> 972         }</span>
<span class="line-added"> 973 </span>
<span class="line-added"> 974         // A bit obvious, but worth noting the API contract for this method is that we should</span>
<span class="line-added"> 975         // return the replacement string when replacing, but the selected string if not.</span>
<span class="line-added"> 976         if (replaceSelection) {</span>
<span class="line-added"> 977             frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);</span>
<span class="line-added"> 978             result.append(replacementString);</span>
<span class="line-added"> 979         } else</span>
<span class="line-added"> 980             result.append(text);</span>
 981     }
 982 
<a name="28" id="anc28"></a><span class="line-modified"> 983     return result;</span>
 984 }
 985 
 986 bool AccessibilityObject::hasAttributesRequiredForInclusion() const
 987 {
 988     // These checks are simplified in the interest of execution speed.
 989     if (!getAttribute(aria_helpAttr).isEmpty()
 990         || !getAttribute(aria_describedbyAttr).isEmpty()
 991         || !getAttribute(altAttr).isEmpty()
 992         || !getAttribute(titleAttr).isEmpty())
 993         return true;
 994 
 995 #if ENABLE(MATHML)
 996     if (!getAttribute(MathMLNames::alttextAttr).isEmpty())
 997         return true;
 998 #endif
 999 
1000     return false;
1001 }
1002 
1003 bool AccessibilityObject::isARIAInput(AccessibilityRole ariaRole)
1004 {
1005     return ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::CheckBox || ariaRole == AccessibilityRole::TextField || ariaRole == AccessibilityRole::Switch || ariaRole == AccessibilityRole::SearchField;
1006 }
1007 
1008 bool AccessibilityObject::isARIAControl(AccessibilityRole ariaRole)
1009 {
1010     return isARIAInput(ariaRole) || ariaRole == AccessibilityRole::TextArea || ariaRole == AccessibilityRole::Button || ariaRole == AccessibilityRole::ComboBox || ariaRole == AccessibilityRole::Slider || ariaRole == AccessibilityRole::ListBox;
1011 }
1012 
1013 bool AccessibilityObject::isRangeControl() const
1014 {
1015     switch (roleValue()) {
<a name="29" id="anc29"></a><span class="line-added">1016     case AccessibilityRole::Meter:</span>
1017     case AccessibilityRole::ProgressIndicator:
1018     case AccessibilityRole::Slider:
1019     case AccessibilityRole::ScrollBar:
1020     case AccessibilityRole::SpinButton:
1021         return true;
1022     case AccessibilityRole::Splitter:
1023         return canSetFocusAttribute();
1024     default:
1025         return false;
1026     }
1027 }
1028 
1029 bool AccessibilityObject::isMeter() const
1030 {
<a name="30" id="anc30"></a><span class="line-added">1031     if (ariaRoleAttribute() == AccessibilityRole::Meter)</span>
<span class="line-added">1032         return true;</span>
<span class="line-added">1033 </span>
1034 #if ENABLE(METER_ELEMENT)
1035     RenderObject* renderer = this-&gt;renderer();
1036     return renderer &amp;&amp; renderer-&gt;isMeter();
1037 #else
1038     return false;
1039 #endif
1040 }
1041 
1042 IntPoint AccessibilityObject::clickPoint()
1043 {
1044     LayoutRect rect = elementRect();
1045     return roundedIntPoint(LayoutPoint(rect.x() + rect.width() / 2, rect.y() + rect.height() / 2));
1046 }
1047 
1048 IntRect AccessibilityObject::boundingBoxForQuads(RenderObject* obj, const Vector&lt;FloatQuad&gt;&amp; quads)
1049 {
1050     ASSERT(obj);
1051     if (!obj)
1052         return IntRect();
1053 
1054     FloatRect result;
1055     for (const auto&amp; quad : quads) {
1056         FloatRect r = quad.enclosingBoundingBox();
1057         if (!r.isEmpty()) {
1058             if (obj-&gt;style().hasAppearance())
1059                 obj-&gt;theme().adjustRepaintRect(*obj, r);
1060             result.unite(r);
1061         }
1062     }
1063     return snappedIntRect(LayoutRect(result));
1064 }
1065 
1066 bool AccessibilityObject::press()
1067 {
1068     // The presence of the actionElement will confirm whether we should even attempt a press.
1069     Element* actionElem = actionElement();
1070     if (!actionElem)
1071         return false;
1072     if (Frame* f = actionElem-&gt;document().frame())
1073         f-&gt;loader().resetMultipleFormSubmissionProtection();
1074 
1075     // Hit test at this location to determine if there is a sub-node element that should act
1076     // as the target of the action.
1077     Element* hitTestElement = nullptr;
1078     Document* document = this-&gt;document();
1079     if (document) {
1080         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
1081         HitTestResult hitTestResult(clickPoint());
1082         document-&gt;hitTest(request, hitTestResult);
1083         if (auto* innerNode = hitTestResult.innerNode()) {
1084             if (auto* shadowHost = innerNode-&gt;shadowHost())
1085                 hitTestElement = shadowHost;
1086             else if (is&lt;Element&gt;(*innerNode))
1087                 hitTestElement = &amp;downcast&lt;Element&gt;(*innerNode);
1088             else
1089                 hitTestElement = innerNode-&gt;parentElement();
1090         }
1091     }
1092 
1093     // Prefer the actionElement instead of this node, if the actionElement is inside this node.
1094     Element* pressElement = this-&gt;element();
1095     if (!pressElement || actionElem-&gt;isDescendantOf(*pressElement))
1096         pressElement = actionElem;
1097 
1098     ASSERT(pressElement);
1099     // Prefer the hit test element, if it is inside the target element.
1100     if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
1101         pressElement = hitTestElement;
1102 
<a name="31" id="anc31"></a>







1103     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
1104 
1105     bool dispatchedTouchEvent = false;
1106 #if PLATFORM(IOS_FAMILY)
1107     if (hasTouchEventListener())
1108         dispatchedTouchEvent = dispatchTouchEvent();
1109 #endif
1110     if (!dispatchedTouchEvent)
1111         pressElement-&gt;accessKeyAction(true);
1112 
1113     return true;
1114 }
1115 
1116 bool AccessibilityObject::dispatchTouchEvent()
1117 {
1118 #if ENABLE(IOS_TOUCH_EVENTS)
1119     if (auto* frame = mainFrame())
1120         return frame-&gt;eventHandler().dispatchSimulatedTouchEvent(clickPoint());
1121 #endif
1122     return false;
1123 }
1124 
1125 Frame* AccessibilityObject::frame() const
1126 {
1127     Node* node = this-&gt;node();
<a name="32" id="anc32"></a><span class="line-modified">1128     return node ? node-&gt;document().frame() : nullptr;</span>



1129 }
1130 
1131 Frame* AccessibilityObject::mainFrame() const
1132 {
1133     Document* document = topDocument();
1134     if (!document)
1135         return nullptr;
1136 
1137     Frame* frame = document-&gt;frame();
1138     if (!frame)
1139         return nullptr;
1140 
1141     return &amp;frame-&gt;mainFrame();
1142 }
1143 
1144 Document* AccessibilityObject::topDocument() const
1145 {
1146     if (!document())
1147         return nullptr;
1148     return &amp;document()-&gt;topDocument();
1149 }
1150 
1151 String AccessibilityObject::language() const
1152 {
<a name="33" id="anc33"></a><span class="line-modified">1153     const AtomString&amp; lang = getAttribute(langAttr);</span>
1154     if (!lang.isEmpty())
1155         return lang;
1156 
1157     AccessibilityObject* parent = parentObject();
1158 
1159     // as a last resort, fall back to the content language specified in the meta tag
1160     if (!parent) {
1161         Document* doc = document();
1162         if (doc)
1163             return doc-&gt;contentLanguage();
1164         return nullAtom();
1165     }
1166 
1167     return parent-&gt;language();
1168 }
1169 
1170 VisiblePositionRange AccessibilityObject::visiblePositionRangeForUnorderedPositions(const VisiblePosition&amp; visiblePos1, const VisiblePosition&amp; visiblePos2) const
1171 {
1172     if (visiblePos1.isNull() || visiblePos2.isNull())
1173         return VisiblePositionRange();
1174 
1175     // If there&#39;s no common tree scope between positions, return early.
1176     if (!commonTreeScope(visiblePos1.deepEquivalent().deprecatedNode(), visiblePos2.deepEquivalent().deprecatedNode()))
1177         return VisiblePositionRange();
1178 
1179     VisiblePosition startPos;
1180     VisiblePosition endPos;
1181     bool alreadyInOrder;
1182 
1183     // upstream is ordered before downstream for the same position
1184     if (visiblePos1 == visiblePos2 &amp;&amp; visiblePos2.affinity() == UPSTREAM)
1185         alreadyInOrder = false;
1186 
1187     // use selection order to see if the positions are in order
1188     else
1189         alreadyInOrder = VisibleSelection(visiblePos1, visiblePos2).isBaseFirst();
1190 
1191     if (alreadyInOrder) {
1192         startPos = visiblePos1;
1193         endPos = visiblePos2;
1194     } else {
1195         startPos = visiblePos2;
1196         endPos = visiblePos1;
1197     }
1198 
1199     return VisiblePositionRange(startPos, endPos);
1200 }
1201 
1202 VisiblePositionRange AccessibilityObject::positionOfLeftWord(const VisiblePosition&amp; visiblePos) const
1203 {
1204     VisiblePosition startPosition = startOfWord(visiblePos, LeftWordIfOnBoundary);
1205     VisiblePosition endPosition = endOfWord(startPosition);
1206     return VisiblePositionRange(startPosition, endPosition);
1207 }
1208 
1209 VisiblePositionRange AccessibilityObject::positionOfRightWord(const VisiblePosition&amp; visiblePos) const
1210 {
1211     VisiblePosition startPosition = startOfWord(visiblePos, RightWordIfOnBoundary);
1212     VisiblePosition endPosition = endOfWord(startPosition);
1213     return VisiblePositionRange(startPosition, endPosition);
1214 }
1215 
1216 static VisiblePosition updateAXLineStartForVisiblePosition(const VisiblePosition&amp; visiblePosition)
1217 {
1218     // A line in the accessibility sense should include floating objects, such as aligned image, as part of a line.
1219     // So let&#39;s update the position to include that.
1220     VisiblePosition tempPosition;
1221     VisiblePosition startPosition = visiblePosition;
1222     while (true) {
1223         tempPosition = startPosition.previous();
1224         if (tempPosition.isNull())
1225             break;
1226         Position p = tempPosition.deepEquivalent();
1227         RenderObject* renderer = p.deprecatedNode()-&gt;renderer();
1228         if (!renderer || (renderer-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset()))
1229             break;
1230         if (!RenderedPosition(tempPosition).isNull())
1231             break;
1232         startPosition = tempPosition;
1233     }
1234 
1235     return startPosition;
1236 }
1237 
1238 VisiblePositionRange AccessibilityObject::leftLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1239 {
1240     if (visiblePos.isNull())
1241         return VisiblePositionRange();
1242 
1243     // make a caret selection for the position before marker position (to make sure
1244     // we move off of a line start)
1245     VisiblePosition prevVisiblePos = visiblePos.previous();
1246     if (prevVisiblePos.isNull())
1247         return VisiblePositionRange();
1248 
1249     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1250 
1251     // keep searching for a valid line start position.  Unless the VisiblePosition is at the very beginning, there should
1252     // always be a valid line range.  However, startOfLine will return null for position next to a floating object,
1253     // since floating object doesn&#39;t really belong to any line.
1254     // This check will reposition the marker before the floating object, to ensure we get a line start.
1255     if (startPosition.isNull()) {
1256         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1257             prevVisiblePos = prevVisiblePos.previous();
1258             startPosition = startOfLine(prevVisiblePos);
1259         }
1260     } else
1261         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1262 
1263     VisiblePosition endPosition = endOfLine(prevVisiblePos);
1264     return VisiblePositionRange(startPosition, endPosition);
1265 }
1266 
1267 VisiblePositionRange AccessibilityObject::rightLineVisiblePositionRange(const VisiblePosition&amp; visiblePos) const
1268 {
1269     if (visiblePos.isNull())
1270         return VisiblePositionRange();
1271 
1272     // make sure we move off of a line end
1273     VisiblePosition nextVisiblePos = visiblePos.next();
1274     if (nextVisiblePos.isNull())
1275         return VisiblePositionRange();
1276 
1277     VisiblePosition startPosition = startOfLine(nextVisiblePos);
1278 
1279     // fetch for a valid line start position
1280     if (startPosition.isNull()) {
1281         startPosition = visiblePos;
1282         nextVisiblePos = nextVisiblePos.next();
1283     } else
1284         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1285 
1286     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1287 
1288     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1289     // Unless the VisiblePosition is at the very end, there should always be a valid line range.  However, endOfLine will
1290     // return null for position by a floating object, since floating object doesn&#39;t really belong to any line.
1291     // This check will reposition the marker after the floating object, to ensure we get a line end.
1292     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1293         nextVisiblePos = nextVisiblePos.next();
1294         endPosition = endOfLine(nextVisiblePos);
1295     }
1296 
1297     return VisiblePositionRange(startPosition, endPosition);
1298 }
1299 
1300 VisiblePositionRange AccessibilityObject::sentenceForPosition(const VisiblePosition&amp; visiblePos) const
1301 {
1302     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1303     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1304     VisiblePosition startPosition = startOfSentence(visiblePos);
1305     VisiblePosition endPosition = endOfSentence(startPosition);
1306     return VisiblePositionRange(startPosition, endPosition);
1307 }
1308 
1309 VisiblePositionRange AccessibilityObject::paragraphForPosition(const VisiblePosition&amp; visiblePos) const
1310 {
1311     VisiblePosition startPosition = startOfParagraph(visiblePos);
1312     VisiblePosition endPosition = endOfParagraph(startPosition);
1313     return VisiblePositionRange(startPosition, endPosition);
1314 }
1315 
1316 static VisiblePosition startOfStyleRange(const VisiblePosition&amp; visiblePos)
1317 {
1318     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1319     RenderObject* startRenderer = renderer;
1320     auto* style = &amp;renderer-&gt;style();
1321 
1322     // traverse backward by renderer to look for style change
1323     for (RenderObject* r = renderer-&gt;previousInPreOrder(); r; r = r-&gt;previousInPreOrder()) {
1324         // skip non-leaf nodes
1325         if (r-&gt;firstChildSlow())
1326             continue;
1327 
1328         // stop at style change
1329         if (&amp;r-&gt;style() != style)
1330             break;
1331 
1332         // remember match
1333         startRenderer = r;
1334     }
1335 
1336     return firstPositionInOrBeforeNode(startRenderer-&gt;node());
1337 }
1338 
1339 static VisiblePosition endOfStyleRange(const VisiblePosition&amp; visiblePos)
1340 {
1341     RenderObject* renderer = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1342     RenderObject* endRenderer = renderer;
1343     const RenderStyle&amp; style = renderer-&gt;style();
1344 
1345     // traverse forward by renderer to look for style change
1346     for (RenderObject* r = renderer-&gt;nextInPreOrder(); r; r = r-&gt;nextInPreOrder()) {
1347         // skip non-leaf nodes
1348         if (r-&gt;firstChildSlow())
1349             continue;
1350 
1351         // stop at style change
1352         if (&amp;r-&gt;style() != &amp;style)
1353             break;
1354 
1355         // remember match
1356         endRenderer = r;
1357     }
1358 
1359     return lastPositionInOrAfterNode(endRenderer-&gt;node());
1360 }
1361 
1362 VisiblePositionRange AccessibilityObject::styleRangeForPosition(const VisiblePosition&amp; visiblePos) const
1363 {
1364     if (visiblePos.isNull())
1365         return VisiblePositionRange();
1366 
1367     return VisiblePositionRange(startOfStyleRange(visiblePos), endOfStyleRange(visiblePos));
1368 }
1369 
1370 // NOTE: Consider providing this utility method as AX API
1371 VisiblePositionRange AccessibilityObject::visiblePositionRangeForRange(const PlainTextRange&amp; range) const
1372 {
1373     unsigned textLength = getLengthForTextRange();
1374     if (range.start + range.length &gt; textLength)
1375         return VisiblePositionRange();
1376 
1377     VisiblePosition startPosition = visiblePositionForIndex(range.start);
1378     startPosition.setAffinity(DOWNSTREAM);
1379     VisiblePosition endPosition = visiblePositionForIndex(range.start + range.length);
1380     return VisiblePositionRange(startPosition, endPosition);
1381 }
1382 
1383 RefPtr&lt;Range&gt; AccessibilityObject::rangeForPlainTextRange(const PlainTextRange&amp; range) const
1384 {
1385     unsigned textLength = getLengthForTextRange();
1386     if (range.start + range.length &gt; textLength)
1387         return nullptr;
1388 
1389     if (AXObjectCache* cache = axObjectCache()) {
1390         CharacterOffset start = cache-&gt;characterOffsetForIndex(range.start, this);
1391         CharacterOffset end = cache-&gt;characterOffsetForIndex(range.start + range.length, this);
1392         return cache-&gt;rangeForUnorderedCharacterOffsets(start, end);
1393     }
1394     return nullptr;
1395 }
1396 
1397 VisiblePositionRange AccessibilityObject::lineRangeForPosition(const VisiblePosition&amp; visiblePosition) const
1398 {
1399     VisiblePosition startPosition = startOfLine(visiblePosition);
1400     VisiblePosition endPosition = endOfLine(visiblePosition);
1401     return VisiblePositionRange(startPosition, endPosition);
1402 }
1403 
1404 bool AccessibilityObject::replacedNodeNeedsCharacter(Node* replacedNode)
1405 {
1406     // we should always be given a rendered node and a replaced node, but be safe
1407     // replaced nodes are either attachments (widgets) or images
1408     if (!replacedNode || !isRendererReplacedElement(replacedNode-&gt;renderer()) || replacedNode-&gt;isTextNode())
1409         return false;
1410 
1411     // create an AX object, but skip it if it is not supposed to be seen
1412     AccessibilityObject* object = replacedNode-&gt;renderer()-&gt;document().axObjectCache()-&gt;getOrCreate(replacedNode);
1413     if (object-&gt;accessibilityIsIgnored())
1414         return false;
1415 
1416     return true;
1417 }
1418 
1419 // Finds a RenderListItem parent give a node.
1420 static RenderListItem* renderListItemContainerForNode(Node* node)
1421 {
1422     for (; node; node = node-&gt;parentNode()) {
1423         RenderBoxModelObject* renderer = node-&gt;renderBoxModelObject();
1424         if (is&lt;RenderListItem&gt;(renderer))
1425             return downcast&lt;RenderListItem&gt;(renderer);
1426     }
1427     return nullptr;
1428 }
1429 
1430 static String listMarkerTextForNode(Node* node)
1431 {
1432     RenderListItem* listItem = renderListItemContainerForNode(node);
1433     if (!listItem)
1434         return String();
1435 
1436     // If this is in a list item, we need to manually add the text for the list marker
1437     // because a RenderListMarker does not have a Node equivalent and thus does not appear
1438     // when iterating text.
1439     return listItem-&gt;markerTextWithSuffix();
1440 }
1441 
1442 // Returns the text associated with a list marker if this node is contained within a list item.
1443 String AccessibilityObject::listMarkerTextForNodeAndPosition(Node* node, const VisiblePosition&amp; visiblePositionStart)
1444 {
1445     // If the range does not contain the start of the line, the list marker text should not be included.
1446     if (!isStartOfLine(visiblePositionStart))
1447         return String();
1448 
1449     // We should speak the list marker only for the first line.
1450     RenderListItem* listItem = renderListItemContainerForNode(node);
1451     if (!listItem)
1452         return String();
1453     if (!inSameLine(visiblePositionStart, firstPositionInNode(&amp;listItem-&gt;element())))
1454         return String();
1455 
1456     return listMarkerTextForNode(node);
1457 }
1458 
1459 String AccessibilityObject::stringForRange(RefPtr&lt;Range&gt; range) const
1460 {
1461     if (!range)
1462         return String();
1463 
1464     TextIterator it(range.get());
1465     if (it.atEnd())
1466         return String();
1467 
1468     StringBuilder builder;
1469     for (; !it.atEnd(); it.advance()) {
1470         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1471         if (it.text().length()) {
1472             // Add a textual representation for list marker text.
1473             // Don&#39;t add list marker text for new line character.
1474             if (it.text().length() != 1 || !isSpaceOrNewline(it.text()[0]))
1475                 builder.append(listMarkerTextForNodeAndPosition(it.node(), VisiblePosition(range-&gt;startPosition())));
1476             it.appendTextToStringBuilder(builder);
1477         } else {
1478             // locate the node and starting offset for this replaced range
1479             Node&amp; node = it.range()-&gt;startContainer();
1480             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1481             int offset = it.range()-&gt;startOffset();
1482             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1483                 builder.append(objectReplacementCharacter);
1484         }
1485     }
1486 
1487     return builder.toString();
1488 }
1489 
1490 String AccessibilityObject::stringForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange)
1491 {
1492     if (visiblePositionRange.isNull())
1493         return String();
1494 
1495     StringBuilder builder;
1496     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1497     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1498         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1499         if (it.text().length()) {
1500             // Add a textual representation for list marker text.
1501             builder.append(listMarkerTextForNodeAndPosition(it.node(), visiblePositionRange.start));
1502             it.appendTextToStringBuilder(builder);
1503         } else {
1504             // locate the node and starting offset for this replaced range
1505             Node&amp; node = it.range()-&gt;startContainer();
1506             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1507             int offset = it.range()-&gt;startOffset();
1508             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1509                 builder.append(objectReplacementCharacter);
1510         }
1511     }
1512 
1513     return builder.toString();
1514 }
1515 
1516 int AccessibilityObject::lengthForVisiblePositionRange(const VisiblePositionRange&amp; visiblePositionRange) const
1517 {
1518     // FIXME: Multi-byte support
1519     if (visiblePositionRange.isNull())
1520         return -1;
1521 
1522     int length = 0;
1523     RefPtr&lt;Range&gt; range = makeRange(visiblePositionRange.start, visiblePositionRange.end);
1524     for (TextIterator it(range.get()); !it.atEnd(); it.advance()) {
1525         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1526         if (it.text().length())
1527             length += it.text().length();
1528         else {
1529             // locate the node and starting offset for this replaced range
1530             Node&amp; node = it.range()-&gt;startContainer();
1531             ASSERT(&amp;node == &amp;it.range()-&gt;endContainer());
1532             int offset = it.range()-&gt;startOffset();
1533 
1534             if (replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1535                 ++length;
1536         }
1537     }
1538 
1539     return length;
1540 }
1541 
1542 VisiblePosition AccessibilityObject::visiblePositionForBounds(const IntRect&amp; rect, AccessibilityVisiblePositionForBounds visiblePositionForBounds) const
1543 {
1544     if (rect.isEmpty())
1545         return VisiblePosition();
1546 
1547     auto* mainFrame = this-&gt;mainFrame();
1548     if (!mainFrame)
1549         return VisiblePosition();
1550 
1551     // FIXME: Add support for right-to-left languages.
1552     IntPoint corner = (visiblePositionForBounds == AccessibilityVisiblePositionForBounds::First) ? rect.minXMinYCorner() : rect.maxXMaxYCorner();
1553     VisiblePosition position = mainFrame-&gt;visiblePositionForPoint(corner);
1554 
1555     if (rect.contains(position.absoluteCaretBounds().center()))
1556         return position;
1557 
1558     // If the initial position is located outside the bounds adjust it incrementally as needed.
1559     VisiblePosition nextPosition = position.next();
1560     VisiblePosition previousPosition = position.previous();
1561     while (nextPosition.isNotNull() || previousPosition.isNotNull()) {
1562         if (rect.contains(nextPosition.absoluteCaretBounds().center()))
1563             return nextPosition;
1564         if (rect.contains(previousPosition.absoluteCaretBounds().center()))
1565             return previousPosition;
1566 
1567         nextPosition = nextPosition.next();
1568         previousPosition = previousPosition.previous();
1569     }
1570 
1571     return VisiblePosition();
1572 }
1573 
1574 VisiblePosition AccessibilityObject::nextWordEnd(const VisiblePosition&amp; visiblePos) const
1575 {
1576     if (visiblePos.isNull())
1577         return VisiblePosition();
1578 
1579     // make sure we move off of a word end
1580     VisiblePosition nextVisiblePos = visiblePos.next();
1581     if (nextVisiblePos.isNull())
1582         return VisiblePosition();
1583 
1584     return endOfWord(nextVisiblePos, LeftWordIfOnBoundary);
1585 }
1586 
1587 VisiblePosition AccessibilityObject::previousWordStart(const VisiblePosition&amp; visiblePos) const
1588 {
1589     if (visiblePos.isNull())
1590         return VisiblePosition();
1591 
1592     // make sure we move off of a word start
1593     VisiblePosition prevVisiblePos = visiblePos.previous();
1594     if (prevVisiblePos.isNull())
1595         return VisiblePosition();
1596 
1597     return startOfWord(prevVisiblePos, RightWordIfOnBoundary);
1598 }
1599 
1600 VisiblePosition AccessibilityObject::nextLineEndPosition(const VisiblePosition&amp; visiblePos) const
1601 {
1602     if (visiblePos.isNull())
1603         return VisiblePosition();
1604 
1605     // to make sure we move off of a line end
1606     VisiblePosition nextVisiblePos = visiblePos.next();
1607     if (nextVisiblePos.isNull())
1608         return VisiblePosition();
1609 
1610     VisiblePosition endPosition = endOfLine(nextVisiblePos);
1611 
1612     // as long as the position hasn&#39;t reached the end of the doc,  keep searching for a valid line end position
1613     // There are cases like when the position is next to a floating object that&#39;ll return null for end of line. This code will avoid returning null.
1614     while (endPosition.isNull() &amp;&amp; nextVisiblePos.isNotNull()) {
1615         nextVisiblePos = nextVisiblePos.next();
1616         endPosition = endOfLine(nextVisiblePos);
1617     }
1618 
1619     return endPosition;
1620 }
1621 
1622 VisiblePosition AccessibilityObject::previousLineStartPosition(const VisiblePosition&amp; visiblePos) const
1623 {
1624     if (visiblePos.isNull())
1625         return VisiblePosition();
1626 
1627     // make sure we move off of a line start
1628     VisiblePosition prevVisiblePos = visiblePos.previous();
1629     if (prevVisiblePos.isNull())
1630         return VisiblePosition();
1631 
1632     VisiblePosition startPosition = startOfLine(prevVisiblePos);
1633 
1634     // as long as the position hasn&#39;t reached the beginning of the doc,  keep searching for a valid line start position
1635     // There are cases like when the position is next to a floating object that&#39;ll return null for start of line. This code will avoid returning null.
1636     if (startPosition.isNull()) {
1637         while (startPosition.isNull() &amp;&amp; prevVisiblePos.isNotNull()) {
1638             prevVisiblePos = prevVisiblePos.previous();
1639             startPosition = startOfLine(prevVisiblePos);
1640         }
1641     } else
1642         startPosition = updateAXLineStartForVisiblePosition(startPosition);
1643 
1644     return startPosition;
1645 }
1646 
1647 VisiblePosition AccessibilityObject::nextSentenceEndPosition(const VisiblePosition&amp; visiblePos) const
1648 {
1649     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1650     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1651     if (visiblePos.isNull())
1652         return VisiblePosition();
1653 
1654     // make sure we move off of a sentence end
1655     VisiblePosition nextVisiblePos = visiblePos.next();
1656     if (nextVisiblePos.isNull())
1657         return VisiblePosition();
1658 
1659     // an empty line is considered a sentence. If it&#39;s skipped, then the sentence parser will not
1660     // see this empty line.  Instead, return the end position of the empty line.
1661     VisiblePosition endPosition;
1662 
1663     String lineString = plainText(makeRange(startOfLine(nextVisiblePos), endOfLine(nextVisiblePos)).get());
1664     if (lineString.isEmpty())
1665         endPosition = nextVisiblePos;
1666     else
1667         endPosition = endOfSentence(nextVisiblePos);
1668 
1669     return endPosition;
1670 }
1671 
1672 VisiblePosition AccessibilityObject::previousSentenceStartPosition(const VisiblePosition&amp; visiblePos) const
1673 {
1674     // FIXME: FO 2 IMPLEMENT (currently returns incorrect answer)
1675     // Related? &lt;rdar://problem/3927736&gt; Text selection broken in 8A336
1676     if (visiblePos.isNull())
1677         return VisiblePosition();
1678 
1679     // make sure we move off of a sentence start
1680     VisiblePosition previousVisiblePos = visiblePos.previous();
1681     if (previousVisiblePos.isNull())
1682         return VisiblePosition();
1683 
1684     // treat empty line as a separate sentence.
1685     VisiblePosition startPosition;
1686 
1687     String lineString = plainText(makeRange(startOfLine(previousVisiblePos), endOfLine(previousVisiblePos)).get());
1688     if (lineString.isEmpty())
1689         startPosition = previousVisiblePos;
1690     else
1691         startPosition = startOfSentence(previousVisiblePos);
1692 
1693     return startPosition;
1694 }
1695 
1696 VisiblePosition AccessibilityObject::nextParagraphEndPosition(const VisiblePosition&amp; visiblePos) const
1697 {
1698     if (visiblePos.isNull())
1699         return VisiblePosition();
1700 
1701     // make sure we move off of a paragraph end
1702     VisiblePosition nextPos = visiblePos.next();
1703     if (nextPos.isNull())
1704         return VisiblePosition();
1705 
1706     return endOfParagraph(nextPos);
1707 }
1708 
1709 VisiblePosition AccessibilityObject::previousParagraphStartPosition(const VisiblePosition&amp; visiblePos) const
1710 {
1711     if (visiblePos.isNull())
1712         return VisiblePosition();
1713 
1714     // make sure we move off of a paragraph start
1715     VisiblePosition previousPos = visiblePos.previous();
1716     if (previousPos.isNull())
1717         return VisiblePosition();
1718 
1719     return startOfParagraph(previousPos);
1720 }
1721 
1722 AccessibilityObject* AccessibilityObject::accessibilityObjectForPosition(const VisiblePosition&amp; visiblePos) const
1723 {
1724     if (visiblePos.isNull())
1725         return nullptr;
1726 
1727     RenderObject* obj = visiblePos.deepEquivalent().deprecatedNode()-&gt;renderer();
1728     if (!obj)
1729         return nullptr;
1730 
1731     return obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1732 }
1733 
1734 // If you call node-&gt;hasEditableStyle() since that will return true if an ancestor is editable.
1735 // This only returns true if this is the element that actually has the contentEditable attribute set.
1736 bool AccessibilityObject::hasContentEditableAttributeSet() const
1737 {
1738     return contentEditableAttributeIsEnabled(element());
1739 }
1740 
1741 bool AccessibilityObject::supportsReadOnly() const
1742 {
1743     AccessibilityRole role = roleValue();
1744 
1745     return role == AccessibilityRole::CheckBox
1746         || role == AccessibilityRole::ColumnHeader
1747         || role == AccessibilityRole::ComboBox
1748         || role == AccessibilityRole::Grid
1749         || role == AccessibilityRole::GridCell
1750         || role == AccessibilityRole::ListBox
1751         || role == AccessibilityRole::MenuItemCheckbox
1752         || role == AccessibilityRole::MenuItemRadio
1753         || role == AccessibilityRole::RadioGroup
1754         || role == AccessibilityRole::RowHeader
1755         || role == AccessibilityRole::SearchField
1756         || role == AccessibilityRole::Slider
1757         || role == AccessibilityRole::SpinButton
1758         || role == AccessibilityRole::Switch
1759         || role == AccessibilityRole::TextField
1760         || role == AccessibilityRole::TreeGrid
1761         || isPasswordField();
1762 }
1763 
1764 String AccessibilityObject::readOnlyValue() const
1765 {
1766     if (!hasAttribute(aria_readonlyAttr))
1767         return ariaRoleAttribute() != AccessibilityRole::Unknown &amp;&amp; supportsReadOnly() ? &quot;false&quot; : String();
1768 
1769     return getAttribute(aria_readonlyAttr).string().convertToASCIILowercase();
1770 }
1771 
1772 bool AccessibilityObject::supportsAutoComplete() const
1773 {
1774     return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
1775 }
1776 
1777 String AccessibilityObject::autoCompleteValue() const
1778 {
<a name="34" id="anc34"></a><span class="line-modified">1779     const AtomString&amp; autoComplete = getAttribute(aria_autocompleteAttr);</span>
1780     if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
1781         || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
1782         || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
1783         return autoComplete;
1784 
1785     return &quot;none&quot;;
1786 }
1787 
1788 bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
1789 {
1790     if (!element)
1791         return false;
1792 
<a name="35" id="anc35"></a><span class="line-modified">1793     const AtomString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);</span>
1794     if (contentEditableValue.isNull())
1795         return false;
1796 
1797     // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
1798     return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
1799 }
1800 
<a name="36" id="anc36"></a><span class="line-modified">1801 #if ENABLE(ACCESSIBILITY)</span>
1802 int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
1803 {
1804     if (visiblePos.isNull() || !node())
1805         return -1;
1806 
1807     // If the position is not in the same editable region as this AX object, return -1.
1808     Node* containerNode = visiblePos.deepEquivalent().containerNode();
1809     if (!containerNode-&gt;containsIncludingShadowDOM(node()) &amp;&amp; !node()-&gt;containsIncludingShadowDOM(containerNode))
1810         return -1;
1811 
1812     int lineCount = -1;
1813     VisiblePosition currentVisiblePos = visiblePos;
1814     VisiblePosition savedVisiblePos;
1815 
1816     // move up until we get to the top
1817     // FIXME: This only takes us to the top of the rootEditableElement, not the top of the
1818     // top document.
1819     do {
1820         savedVisiblePos = currentVisiblePos;
1821         VisiblePosition prevVisiblePos = previousLinePosition(currentVisiblePos, 0, HasEditableAXRole);
1822         currentVisiblePos = prevVisiblePos;
1823         ++lineCount;
1824     }  while (currentVisiblePos.isNotNull() &amp;&amp; !(inSameLine(currentVisiblePos, savedVisiblePos)));
1825 
1826     return lineCount;
1827 }
1828 #endif
1829 
1830 // NOTE: Consider providing this utility method as AX API
1831 PlainTextRange AccessibilityObject::plainTextRangeForVisiblePositionRange(const VisiblePositionRange&amp; positionRange) const
1832 {
1833     int index1 = index(positionRange.start);
1834     int index2 = index(positionRange.end);
1835     if (index1 &lt; 0 || index2 &lt; 0 || index1 &gt; index2)
1836         return PlainTextRange();
1837 
1838     return PlainTextRange(index1, index2 - index1);
1839 }
1840 
1841 // The composed character range in the text associated with this accessibility object that
1842 // is specified by the given screen coordinates. This parameterized attribute returns the
1843 // complete range of characters (including surrogate pairs of multi-byte glyphs) at the given
1844 // screen coordinates.
1845 // NOTE: This varies from AppKit when the point is below the last line. AppKit returns an
1846 // an error in that case. We return textControl-&gt;text().length(), 1. Does this matter?
1847 PlainTextRange AccessibilityObject::doAXRangeForPosition(const IntPoint&amp; point) const
1848 {
1849     int i = index(visiblePositionForPoint(point));
1850     if (i &lt; 0)
1851         return PlainTextRange();
1852 
1853     return PlainTextRange(i, 1);
1854 }
1855 
1856 // Given a character index, the range of text associated with this accessibility object
1857 // over which the style in effect at that character index applies.
1858 PlainTextRange AccessibilityObject::doAXStyleRangeForIndex(unsigned index) const
1859 {
1860     VisiblePositionRange range = styleRangeForPosition(visiblePositionForIndex(index, false));
1861     return plainTextRangeForVisiblePositionRange(range);
1862 }
1863 
1864 // Given an indexed character, the line number of the text associated with this accessibility
1865 // object that contains the character.
1866 unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
1867 {
1868     return lineForPosition(visiblePositionForIndex(index, false));
1869 }
1870 
<a name="37" id="anc37"></a><span class="line-modified">1871 #if ENABLE(ACCESSIBILITY)</span>
1872 void AccessibilityObject::updateBackingStore()
1873 {
1874     if (!axObjectCache())
1875         return;
1876 
1877     // Updating the layout may delete this object.
1878     RefPtr&lt;AccessibilityObject&gt; protectedThis(this);
1879     if (auto* document = this-&gt;document()) {
1880         if (!document-&gt;view()-&gt;layoutContext().isInRenderTreeLayout() &amp;&amp; !document-&gt;inRenderTreeUpdate() &amp;&amp; !document-&gt;inStyleRecalc())
1881             document-&gt;updateLayoutIgnorePendingStylesheets();
1882     }
1883 
1884     if (auto cache = axObjectCache())
1885         cache-&gt;performDeferredCacheUpdate();
1886 
1887     updateChildrenIfNecessary();
1888 }
1889 #endif
1890 
<a name="38" id="anc38"></a><span class="line-modified">1891 const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const</span>
1892 {
<a name="39" id="anc39"></a><span class="line-modified">1893     return downcast&lt;AccessibilityScrollView&gt;(AccessibilityObject::matchedParent(*this, includeSelf, [] (const auto&amp; object) {</span>
1894         return is&lt;AccessibilityScrollView&gt;(object);
<a name="40" id="anc40"></a><span class="line-modified">1895     }));</span>
<span class="line-modified">1896 }</span>
<span class="line-added">1897 </span>
<span class="line-added">1898 ScrollView* AccessibilityObject::scrollViewAncestor() const</span>
<span class="line-added">1899 {</span>
<span class="line-added">1900     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))</span>
<span class="line-added">1901         return parentScrollView-&gt;scrollView();</span>
1902 
1903     return nullptr;
1904 }
1905 
1906 Document* AccessibilityObject::document() const
1907 {
1908     FrameView* frameView = documentFrameView();
1909     if (!frameView)
1910         return nullptr;
1911 
1912     return frameView-&gt;frame().document();
1913 }
1914 
1915 Page* AccessibilityObject::page() const
1916 {
1917     Document* document = this-&gt;document();
1918     if (!document)
1919         return nullptr;
1920     return document-&gt;page();
1921 }
1922 
1923 FrameView* AccessibilityObject::documentFrameView() const
1924 {
1925     const AccessibilityObject* object = this;
1926     while (object &amp;&amp; !object-&gt;isAccessibilityRenderObject())
1927         object = object-&gt;parentObject();
1928 
1929     if (!object)
1930         return nullptr;
1931 
1932     return object-&gt;documentFrameView();
1933 }
1934 
<a name="41" id="anc41"></a><span class="line-modified">1935 #if ENABLE(ACCESSIBILITY)</span>
1936 const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
1937 {
1938     if (updateChildrenIfNeeded)
1939         updateChildrenIfNecessary();
1940 
1941     return m_children;
1942 }
1943 #endif
1944 
1945 void AccessibilityObject::updateChildrenIfNecessary()
1946 {
1947     if (!hasChildren()) {
<a name="42" id="anc42"></a>
1948         // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
1949         AXAttributeCacheEnabler enableCache(axObjectCache());
<a name="43" id="anc43"></a>
1950         addChildren();
1951     }
1952 }
1953 
1954 void AccessibilityObject::clearChildren()
1955 {
1956     // Some objects have weak pointers to their parents and those associations need to be detached.
1957     for (const auto&amp; child : m_children)
1958         child-&gt;detachFromParent();
1959 
1960     m_children.clear();
1961     m_haveChildren = false;
1962 }
1963 
1964 AccessibilityObject* AccessibilityObject::anchorElementForNode(Node* node)
1965 {
1966     RenderObject* obj = node-&gt;renderer();
1967     if (!obj)
1968         return nullptr;
1969 
1970     RefPtr&lt;AccessibilityObject&gt; axObj = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);
1971     Element* anchor = axObj-&gt;anchorElement();
1972     if (!anchor)
1973         return nullptr;
1974 
1975     RenderObject* anchorRenderer = anchor-&gt;renderer();
1976     if (!anchorRenderer)
1977         return nullptr;
1978 
1979     return anchorRenderer-&gt;document().axObjectCache()-&gt;getOrCreate(anchorRenderer);
1980 }
1981 
1982 AccessibilityObject* AccessibilityObject::headingElementForNode(Node* node)
1983 {
1984     if (!node)
1985         return nullptr;
1986 
1987     RenderObject* renderObject = node-&gt;renderer();
1988     if (!renderObject)
1989         return nullptr;
1990 
1991     AccessibilityObject* axObject = renderObject-&gt;document().axObjectCache()-&gt;getOrCreate(renderObject);
1992 
1993     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*axObject, true, [] (const AccessibilityObject&amp; object) {
1994         return object.roleValue() == AccessibilityRole::Heading;
1995     }));
1996 }
1997 
1998 const AccessibilityObject* AccessibilityObject::matchedParent(const AccessibilityObject&amp; object, bool includeSelf, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; matches)
1999 {
2000     const AccessibilityObject* parent = includeSelf ? &amp;object : object.parentObject();
2001     for (; parent; parent = parent-&gt;parentObject()) {
2002         if (matches(*parent))
2003             return parent;
2004     }
2005     return nullptr;
2006 }
2007 
2008 void AccessibilityObject::ariaTreeRows(AccessibilityChildrenVector&amp; result)
2009 {
2010     for (const auto&amp; child : children()) {
2011         // Add tree items as the rows.
2012         if (child-&gt;roleValue() == AccessibilityRole::TreeItem)
2013             result.append(child);
2014 
2015         // Now see if this item also has rows hiding inside of it.
2016         child-&gt;ariaTreeRows(result);
2017     }
2018 }
2019 
2020 void AccessibilityObject::ariaTreeItemContent(AccessibilityChildrenVector&amp; result)
2021 {
2022     // The ARIA tree item content are the item that are not other tree items or their containing groups.
2023     for (const auto&amp; child : children()) {
2024         if (!child-&gt;isGroup() &amp;&amp; child-&gt;roleValue() != AccessibilityRole::TreeItem)
2025             result.append(child);
2026     }
2027 }
2028 
2029 void AccessibilityObject::ariaTreeItemDisclosedRows(AccessibilityChildrenVector&amp; result)
2030 {
2031     for (const auto&amp; obj : children()) {
2032         // Add tree items as the rows.
2033         if (obj-&gt;roleValue() == AccessibilityRole::TreeItem)
2034             result.append(obj);
2035         // If it&#39;s not a tree item, then descend into the group to find more tree items.
2036         else
2037             obj-&gt;ariaTreeRows(result);
2038     }
2039 }
2040 
2041 const String AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityRole role)
2042 {
2043     switch (role) {
2044     case AccessibilityRole::ApplicationAlertDialog:
2045     case AccessibilityRole::ApplicationAlert:
2046         return &quot;assertive&quot;_s;
2047     case AccessibilityRole::ApplicationLog:
2048     case AccessibilityRole::ApplicationStatus:
2049         return &quot;polite&quot;_s;
2050     case AccessibilityRole::ApplicationTimer:
2051     case AccessibilityRole::ApplicationMarquee:
2052         return &quot;off&quot;_s;
2053     default:
2054         return nullAtom();
2055     }
2056 }
2057 
<a name="44" id="anc44"></a><span class="line-modified">2058 #if ENABLE(ACCESSIBILITY)</span>
2059 const String&amp; AccessibilityObject::actionVerb() const
2060 {
2061 #if !PLATFORM(IOS_FAMILY)
2062     // FIXME: Need to add verbs for select elements.
2063     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
2064     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
2065     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
2066     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXCheckedCheckBoxActionVerb());
2067     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
2068     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
2069     static NeverDestroyed&lt;const String&gt; menuListAction(AXMenuListActionVerb());
2070     static NeverDestroyed&lt;const String&gt; menuListPopupAction(AXMenuListPopupActionVerb());
2071     static NeverDestroyed&lt;const String&gt; listItemAction(AXListItemActionVerb());
2072 
2073     switch (roleValue()) {
2074     case AccessibilityRole::Button:
2075     case AccessibilityRole::ToggleButton:
2076         return buttonAction;
2077     case AccessibilityRole::TextField:
2078     case AccessibilityRole::TextArea:
2079         return textFieldAction;
2080     case AccessibilityRole::RadioButton:
2081         return radioButtonAction;
2082     case AccessibilityRole::CheckBox:
2083     case AccessibilityRole::Switch:
2084         return isChecked() ? checkedCheckBoxAction : uncheckedCheckBoxAction;
2085     case AccessibilityRole::Link:
2086     case AccessibilityRole::WebCoreLink:
2087         return linkAction;
2088     case AccessibilityRole::PopUpButton:
2089         return menuListAction;
2090     case AccessibilityRole::MenuListPopup:
2091         return menuListPopupAction;
2092     case AccessibilityRole::ListItem:
2093         return listItemAction;
2094     default:
2095         return nullAtom();
2096     }
2097 #else
2098     return nullAtom();
2099 #endif
2100 }
2101 #endif
2102 
2103 bool AccessibilityObject::ariaIsMultiline() const
2104 {
2105     return equalLettersIgnoringASCIICase(getAttribute(aria_multilineAttr), &quot;true&quot;);
2106 }
2107 
2108 String AccessibilityObject::invalidStatus() const
2109 {
2110     String grammarValue = &quot;grammar&quot;_s;
2111     String falseValue = &quot;false&quot;_s;
2112     String spellingValue = &quot;spelling&quot;_s;
2113     String trueValue = &quot;true&quot;_s;
2114     String undefinedValue = &quot;undefined&quot;_s;
2115 
2116     // aria-invalid can return false (default), grammar, spelling, or true.
2117     String ariaInvalid = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_invalidAttr));
2118 
2119     if (ariaInvalid.isEmpty()) {
2120         // We should expose invalid status for input types.
2121         Node* node = this-&gt;node();
2122         if (node &amp;&amp; is&lt;HTMLInputElement&gt;(*node)) {
2123             HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2124             if (input.hasBadInput() || input.typeMismatch())
2125                 return trueValue;
2126         }
2127         return falseValue;
2128     }
2129 
2130     // If &quot;false&quot;, &quot;undefined&quot; [sic, string value], empty, or missing, return &quot;false&quot;.
2131     if (ariaInvalid == falseValue || ariaInvalid == undefinedValue)
2132         return falseValue;
2133     // Besides true/false/undefined, the only tokens defined by WAI-ARIA 1.0...
2134     // ...for @aria-invalid are &quot;grammar&quot; and &quot;spelling&quot;.
2135     if (ariaInvalid == grammarValue)
2136         return grammarValue;
2137     if (ariaInvalid == spellingValue)
2138         return spellingValue;
2139     // Any other non empty string should be treated as &quot;true&quot;.
2140     return trueValue;
2141 }
2142 
2143 bool AccessibilityObject::supportsCurrent() const
2144 {
2145     return hasAttribute(aria_currentAttr);
2146 }
2147 
2148 AccessibilityCurrentState AccessibilityObject::currentState() const
2149 {
2150     // aria-current can return false (default), true, page, step, location, date or time.
2151     String currentStateValue = stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_currentAttr));
2152 
2153     // If &quot;false&quot;, empty, or missing, return false state.
2154     if (currentStateValue.isEmpty() || currentStateValue == &quot;false&quot;)
2155         return AccessibilityCurrentState::False;
2156 
2157     if (currentStateValue == &quot;page&quot;)
2158         return AccessibilityCurrentState::Page;
2159     if (currentStateValue == &quot;step&quot;)
2160         return AccessibilityCurrentState::Step;
2161     if (currentStateValue == &quot;location&quot;)
2162         return AccessibilityCurrentState::Location;
2163     if (currentStateValue == &quot;date&quot;)
2164         return AccessibilityCurrentState::Date;
2165     if (currentStateValue == &quot;time&quot;)
2166         return AccessibilityCurrentState::Time;
2167 
2168     // Any value not included in the list of allowed values should be treated as &quot;true&quot;.
2169     return AccessibilityCurrentState::True;
2170 }
2171 
2172 String AccessibilityObject::currentValue() const
2173 {
2174     switch (currentState()) {
2175     case AccessibilityCurrentState::False:
2176         return &quot;false&quot;;
2177     case AccessibilityCurrentState::Page:
2178         return &quot;page&quot;;
2179     case AccessibilityCurrentState::Step:
2180         return &quot;step&quot;;
2181     case AccessibilityCurrentState::Location:
2182         return &quot;location&quot;;
2183     case AccessibilityCurrentState::Time:
2184         return &quot;time&quot;;
2185     case AccessibilityCurrentState::Date:
2186         return &quot;date&quot;;
2187     default:
2188     case AccessibilityCurrentState::True:
2189         return &quot;true&quot;;
2190     }
2191 }
2192 
2193 bool AccessibilityObject::isModalDescendant(Node* modalNode) const
2194 {
2195     Node* node = this-&gt;node();
2196     if (!modalNode || !node)
2197         return false;
2198 
2199     if (node == modalNode)
2200         return true;
2201 
2202     // ARIA 1.1 aria-modal, indicates whether an element is modal when displayed.
2203     // For the decendants of the modal object, they should also be considered as aria-modal=true.
2204     return node-&gt;isDescendantOf(*modalNode);
2205 }
2206 
2207 bool AccessibilityObject::isModalNode() const
2208 {
2209     if (AXObjectCache* cache = axObjectCache())
2210         return node() &amp;&amp; cache-&gt;modalNode() == node();
2211 
2212     return false;
2213 }
2214 
2215 bool AccessibilityObject::ignoredFromModalPresence() const
2216 {
2217     // We shouldn&#39;t ignore the top node.
2218     if (!node() || !node()-&gt;parentNode())
2219         return false;
2220 
2221     AXObjectCache* cache = axObjectCache();
2222     if (!cache)
2223         return false;
2224 
2225     // modalNode is the current displayed modal dialog.
2226     Node* modalNode = cache-&gt;modalNode();
2227     if (!modalNode)
2228         return false;
2229 
2230     // We only want to ignore the objects within the same frame as the modal dialog.
2231     if (modalNode-&gt;document().frame() != this-&gt;frame())
2232         return false;
2233 
2234     return !isModalDescendant(modalNode);
2235 }
2236 
2237 bool AccessibilityObject::hasTagName(const QualifiedName&amp; tagName) const
2238 {
2239     Node* node = this-&gt;node();
2240     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hasTagName(tagName);
2241 }
2242 
2243 bool AccessibilityObject::hasAttribute(const QualifiedName&amp; attribute) const
2244 {
2245     Node* node = this-&gt;node();
2246     if (!is&lt;Element&gt;(node))
2247         return false;
2248 
2249     return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
2250 }
2251 
<a name="45" id="anc45"></a><span class="line-modified">2252 const AtomString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const</span>
2253 {
2254     if (auto* element = this-&gt;element())
2255         return element-&gt;attributeWithoutSynchronization(attribute);
2256     return nullAtom();
2257 }
2258 
<a name="46" id="anc46"></a><span class="line-modified">2259 bool AccessibilityObject::replaceTextInRange(const String&amp; replacementString, const PlainTextRange&amp; range)</span>
2260 {
<a name="47" id="anc47"></a><span class="line-modified">2261     if (!renderer() || !is&lt;Element&gt;(node()))</span>









2262         return false;
2263 
<a name="48" id="anc48"></a><span class="line-modified">2264     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>






2265 
<a name="49" id="anc49"></a><span class="line-modified">2266     // We should use the editor&#39;s insertText to mimic typing into the field.</span>
<span class="line-modified">2267     // Also only do this when the field is in editing mode.</span>
<span class="line-added">2268     auto&amp; frame = renderer()-&gt;frame();</span>
<span class="line-added">2269     if (element.shouldUseInputMethod()) {</span>
<span class="line-added">2270         frame.selection().setSelectedRange(rangeForPlainTextRange(range).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);</span>
<span class="line-added">2271         frame.editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::No, Editor::SmartReplace::No);</span>
<span class="line-added">2272         return true;</span>
<span class="line-added">2273     }</span>
2274 
<a name="50" id="anc50"></a><span class="line-modified">2275     if (is&lt;HTMLInputElement&gt;(element)) {</span>
<span class="line-added">2276         downcast&lt;HTMLInputElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">2277         return true;</span>
<span class="line-added">2278     }</span>
<span class="line-added">2279     if (is&lt;HTMLTextAreaElement&gt;(element)) {</span>
<span class="line-added">2280         downcast&lt;HTMLTextAreaElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">2281         return true;</span>
<span class="line-added">2282     }</span>
2283 
<a name="51" id="anc51"></a><span class="line-modified">2284     return false;</span>

2285 }
2286 
<a name="52" id="anc52"></a><span class="line-modified">2287 bool AccessibilityObject::insertText(const String&amp; text)</span>
2288 {
<a name="53" id="anc53"></a><span class="line-modified">2289     if (!renderer() || !is&lt;Element&gt;(node()))</span>


























2290         return false;
<a name="54" id="anc54"></a>
2291 
<a name="55" id="anc55"></a><span class="line-modified">2292     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>


2293 
<a name="56" id="anc56"></a><span class="line-modified">2294     // Only try to insert text if the field is in editing mode.</span>
<span class="line-modified">2295     if (!element.shouldUseInputMethod())</span>

2296         return false;
<a name="57" id="anc57"></a><span class="line-modified">2297 </span>
<span class="line-modified">2298     // Use Editor::insertText to mimic typing into the field.</span>
<span class="line-added">2299     auto&amp; editor = renderer()-&gt;frame().editor();</span>
<span class="line-added">2300     return editor.insertText(text, nullptr);</span>
2301 }
2302 
2303 // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
2304 AccessibilityOrientation AccessibilityObject::orientation() const
2305 {
2306     LayoutRect bounds = elementRect();
2307     if (bounds.size().width() &gt; bounds.size().height())
2308         return AccessibilityOrientation::Horizontal;
2309     if (bounds.size().height() &gt; bounds.size().width())
2310         return AccessibilityOrientation::Vertical;
2311 
2312     return AccessibilityOrientation::Undefined;
2313 }
2314 
2315 bool AccessibilityObject::isDescendantOfObject(const AccessibilityObject* axObject) const
2316 {
2317     if (!axObject || !axObject-&gt;hasChildren())
2318         return false;
2319 
2320     return AccessibilityObject::matchedParent(*this, false, [axObject] (const AccessibilityObject&amp; object) {
2321         return &amp;object == axObject;
2322     }) != nullptr;
2323 }
2324 
2325 bool AccessibilityObject::isAncestorOfObject(const AccessibilityObject* axObject) const
2326 {
2327     if (!axObject)
2328         return false;
2329 
2330     return this == axObject || axObject-&gt;isDescendantOfObject(this);
2331 }
2332 
2333 AccessibilityObject* AccessibilityObject::firstAnonymousBlockChild() const
2334 {
2335     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
2336         if (child-&gt;renderer() &amp;&amp; child-&gt;renderer()-&gt;isAnonymousBlock())
2337             return child;
2338     }
2339     return nullptr;
2340 }
2341 
2342 using ARIARoleMap = HashMap&lt;String, AccessibilityRole, ASCIICaseInsensitiveHash&gt;;
2343 using ARIAReverseRoleMap = HashMap&lt;AccessibilityRole, String, DefaultHash&lt;int&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt;;
2344 
2345 static ARIARoleMap* gAriaRoleMap = nullptr;
2346 static ARIAReverseRoleMap* gAriaReverseRoleMap = nullptr;
2347 
2348 struct RoleEntry {
2349     String ariaRole;
2350     AccessibilityRole webcoreRole;
2351 };
2352 
2353 static void initializeRoleMap()
2354 {
2355     if (gAriaRoleMap)
2356         return;
2357     ASSERT(!gAriaReverseRoleMap);
2358 
2359     const RoleEntry roles[] = {
2360         { &quot;alert&quot;, AccessibilityRole::ApplicationAlert },
2361         { &quot;alertdialog&quot;, AccessibilityRole::ApplicationAlertDialog },
2362         { &quot;application&quot;, AccessibilityRole::WebApplication },
2363         { &quot;article&quot;, AccessibilityRole::DocumentArticle },
2364         { &quot;banner&quot;, AccessibilityRole::LandmarkBanner },
2365         { &quot;blockquote&quot;, AccessibilityRole::Blockquote },
2366         { &quot;button&quot;, AccessibilityRole::Button },
2367         { &quot;caption&quot;, AccessibilityRole::Caption },
2368         { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
2369         { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
2370         { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },
<a name="58" id="anc58"></a><span class="line-added">2371         { &quot;deletion&quot;, AccessibilityRole::Deletion },</span>
2372         { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
2373         { &quot;directory&quot;, AccessibilityRole::Directory },
2374         // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
2375         // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
2376         { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
2377         { &quot;doc-acknowledgments&quot;, AccessibilityRole::LandmarkDocRegion },
2378         { &quot;doc-afterword&quot;, AccessibilityRole::LandmarkDocRegion },
2379         { &quot;doc-appendix&quot;, AccessibilityRole::LandmarkDocRegion },
2380         { &quot;doc-backlink&quot;, AccessibilityRole::WebCoreLink },
2381         { &quot;doc-biblioentry&quot;, AccessibilityRole::ListItem },
2382         { &quot;doc-bibliography&quot;, AccessibilityRole::LandmarkDocRegion },
2383         { &quot;doc-biblioref&quot;, AccessibilityRole::WebCoreLink },
2384         { &quot;doc-chapter&quot;, AccessibilityRole::LandmarkDocRegion },
2385         { &quot;doc-colophon&quot;, AccessibilityRole::ApplicationTextGroup },
2386         { &quot;doc-conclusion&quot;, AccessibilityRole::LandmarkDocRegion },
2387         { &quot;doc-cover&quot;, AccessibilityRole::Image },
2388         { &quot;doc-credit&quot;, AccessibilityRole::ApplicationTextGroup },
2389         { &quot;doc-credits&quot;, AccessibilityRole::LandmarkDocRegion },
2390         { &quot;doc-dedication&quot;, AccessibilityRole::ApplicationTextGroup },
2391         { &quot;doc-endnote&quot;, AccessibilityRole::ListItem },
2392         { &quot;doc-endnotes&quot;, AccessibilityRole::LandmarkDocRegion },
2393         { &quot;doc-epigraph&quot;, AccessibilityRole::ApplicationTextGroup },
2394         { &quot;doc-epilogue&quot;, AccessibilityRole::LandmarkDocRegion },
2395         { &quot;doc-errata&quot;, AccessibilityRole::LandmarkDocRegion },
2396         { &quot;doc-example&quot;, AccessibilityRole::ApplicationTextGroup },
2397         { &quot;doc-footnote&quot;, AccessibilityRole::Footnote },
2398         { &quot;doc-foreword&quot;, AccessibilityRole::LandmarkDocRegion },
2399         { &quot;doc-glossary&quot;, AccessibilityRole::LandmarkDocRegion },
2400         { &quot;doc-glossref&quot;, AccessibilityRole::WebCoreLink },
2401         { &quot;doc-index&quot;, AccessibilityRole::LandmarkNavigation },
2402         { &quot;doc-introduction&quot;, AccessibilityRole::LandmarkDocRegion },
2403         { &quot;doc-noteref&quot;, AccessibilityRole::WebCoreLink },
2404         { &quot;doc-notice&quot;, AccessibilityRole::DocumentNote },
2405         { &quot;doc-pagebreak&quot;, AccessibilityRole::Splitter },
2406         { &quot;doc-pagelist&quot;, AccessibilityRole::LandmarkNavigation },
2407         { &quot;doc-part&quot;, AccessibilityRole::LandmarkDocRegion },
2408         { &quot;doc-preface&quot;, AccessibilityRole::LandmarkDocRegion },
2409         { &quot;doc-prologue&quot;, AccessibilityRole::LandmarkDocRegion },
2410         { &quot;doc-pullquote&quot;, AccessibilityRole::ApplicationTextGroup },
2411         { &quot;doc-qna&quot;, AccessibilityRole::ApplicationTextGroup },
2412         { &quot;doc-subtitle&quot;, AccessibilityRole::Heading },
2413         { &quot;doc-tip&quot;, AccessibilityRole::DocumentNote },
2414         { &quot;doc-toc&quot;, AccessibilityRole::LandmarkNavigation },
2415         { &quot;figure&quot;, AccessibilityRole::Figure },
2416         // The mappings for &#39;graphics-*&#39; roles are defined in this spec: https://w3c.github.io/graphics-aam/
2417         { &quot;graphics-document&quot;, AccessibilityRole::GraphicsDocument },
2418         { &quot;graphics-object&quot;, AccessibilityRole::GraphicsObject },
2419         { &quot;graphics-symbol&quot;, AccessibilityRole::GraphicsSymbol },
2420         { &quot;grid&quot;, AccessibilityRole::Grid },
2421         { &quot;gridcell&quot;, AccessibilityRole::GridCell },
2422         { &quot;table&quot;, AccessibilityRole::Table },
2423         { &quot;cell&quot;, AccessibilityRole::Cell },
2424         { &quot;columnheader&quot;, AccessibilityRole::ColumnHeader },
2425         { &quot;combobox&quot;, AccessibilityRole::ComboBox },
2426         { &quot;definition&quot;, AccessibilityRole::Definition },
2427         { &quot;document&quot;, AccessibilityRole::Document },
2428         { &quot;feed&quot;, AccessibilityRole::Feed },
2429         { &quot;form&quot;, AccessibilityRole::Form },
2430         { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
2431         { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
2432         { &quot;heading&quot;, AccessibilityRole::Heading },
2433         { &quot;img&quot;, AccessibilityRole::Image },
<a name="59" id="anc59"></a><span class="line-added">2434         { &quot;insertion&quot;, AccessibilityRole::Insertion },</span>
2435         { &quot;link&quot;, AccessibilityRole::WebCoreLink },
2436         { &quot;list&quot;, AccessibilityRole::List },
2437         { &quot;listitem&quot;, AccessibilityRole::ListItem },
2438         { &quot;listbox&quot;, AccessibilityRole::ListBox },
2439         { &quot;log&quot;, AccessibilityRole::ApplicationLog },
2440         { &quot;main&quot;, AccessibilityRole::LandmarkMain },
2441         { &quot;marquee&quot;, AccessibilityRole::ApplicationMarquee },
2442         { &quot;math&quot;, AccessibilityRole::DocumentMath },
2443         { &quot;menu&quot;, AccessibilityRole::Menu },
2444         { &quot;menubar&quot;, AccessibilityRole::MenuBar },
2445         { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
2446         { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
2447         { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },
<a name="60" id="anc60"></a><span class="line-added">2448         { &quot;meter&quot;, AccessibilityRole::Meter },</span>
2449         { &quot;none&quot;, AccessibilityRole::Presentational },
2450         { &quot;note&quot;, AccessibilityRole::DocumentNote },
2451         { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
2452         { &quot;option&quot;, AccessibilityRole::ListBoxOption },
2453         { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
2454         { &quot;presentation&quot;, AccessibilityRole::Presentational },
2455         { &quot;progressbar&quot;, AccessibilityRole::ProgressIndicator },
2456         { &quot;radio&quot;, AccessibilityRole::RadioButton },
2457         { &quot;radiogroup&quot;, AccessibilityRole::RadioGroup },
2458         { &quot;region&quot;, AccessibilityRole::LandmarkRegion },
2459         { &quot;row&quot;, AccessibilityRole::Row },
2460         { &quot;rowgroup&quot;, AccessibilityRole::RowGroup },
2461         { &quot;scrollbar&quot;, AccessibilityRole::ScrollBar },
2462         { &quot;search&quot;, AccessibilityRole::LandmarkSearch },
2463         { &quot;searchbox&quot;, AccessibilityRole::SearchField },
2464         { &quot;separator&quot;, AccessibilityRole::Splitter },
2465         { &quot;slider&quot;, AccessibilityRole::Slider },
2466         { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
2467         { &quot;status&quot;, AccessibilityRole::ApplicationStatus },
<a name="61" id="anc61"></a><span class="line-added">2468         { &quot;subscript&quot;, AccessibilityRole::Subscript },</span>
<span class="line-added">2469         { &quot;superscript&quot;, AccessibilityRole::Superscript },</span>
2470         { &quot;switch&quot;, AccessibilityRole::Switch },
2471         { &quot;tab&quot;, AccessibilityRole::Tab },
2472         { &quot;tablist&quot;, AccessibilityRole::TabList },
2473         { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
2474         { &quot;text&quot;, AccessibilityRole::StaticText },
2475         { &quot;textbox&quot;, AccessibilityRole::TextArea },
2476         { &quot;term&quot;, AccessibilityRole::Term },
<a name="62" id="anc62"></a><span class="line-added">2477         { &quot;time&quot;, AccessibilityRole::Time },</span>
2478         { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
2479         { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
2480         { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
2481         { &quot;tree&quot;, AccessibilityRole::Tree },
2482         { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
2483         { &quot;treeitem&quot;, AccessibilityRole::TreeItem }
2484     };
2485 
2486     gAriaRoleMap = new ARIARoleMap;
2487     gAriaReverseRoleMap = new ARIAReverseRoleMap;
2488     size_t roleLength = WTF_ARRAY_LENGTH(roles);
2489     for (size_t i = 0; i &lt; roleLength; ++i) {
2490         gAriaRoleMap-&gt;set(roles[i].ariaRole, roles[i].webcoreRole);
2491         gAriaReverseRoleMap-&gt;set(static_cast&lt;int&gt;(roles[i].webcoreRole), roles[i].ariaRole);
2492     }
2493 }
2494 
2495 static ARIARoleMap&amp; ariaRoleMap()
2496 {
2497     initializeRoleMap();
2498     return *gAriaRoleMap;
2499 }
2500 
2501 static ARIAReverseRoleMap&amp; reverseAriaRoleMap()
2502 {
2503     initializeRoleMap();
2504     return *gAriaReverseRoleMap;
2505 }
2506 
2507 AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
2508 {
<a name="63" id="anc63"></a><span class="line-modified">2509     if (value.isNull() || value.isEmpty())</span>
<span class="line-added">2510         return AccessibilityRole::Unknown;</span>
<span class="line-added">2511 </span>
2512     for (auto roleName : StringView(value).split(&#39; &#39;)) {
2513         AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
2514         if (static_cast&lt;int&gt;(role))
2515             return role;
2516     }
2517     return AccessibilityRole::Unknown;
2518 }
2519 
2520 String AccessibilityObject::computedRoleString() const
2521 {
2522     // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
2523     AccessibilityRole role = roleValue();
2524 
<a name="64" id="anc64"></a><span class="line-added">2525     if (role == AccessibilityRole::Image &amp;&amp; accessibilityIsIgnored())</span>
<span class="line-added">2526         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Presentational));</span>
<span class="line-added">2527 </span>
2528     // We do not compute a role string for generic block elements with user-agent assigned roles.
2529     if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
2530         return &quot;&quot;;
2531 
2532     // We do compute a role string for block elements with author-provided roles.
2533     if (role == AccessibilityRole::ApplicationTextGroup
2534         || role == AccessibilityRole::Footnote
2535         || role == AccessibilityRole::GraphicsObject)
2536         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::ApplicationGroup));
2537 
2538     if (role == AccessibilityRole::GraphicsDocument)
2539         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Document));
2540 
2541     if (role == AccessibilityRole::GraphicsSymbol)
2542         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Image));
2543 
2544     if (role == AccessibilityRole::HorizontalRule)
2545         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Splitter));
2546 
2547     if (role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton)
2548         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Button));
2549 
2550     if (role == AccessibilityRole::LandmarkDocRegion)
2551         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::LandmarkRegion));
2552 
2553     return reverseAriaRoleMap().get(static_cast&lt;int&gt;(role));
2554 }
2555 
2556 bool AccessibilityObject::hasHighlighting() const
2557 {
2558     for (Node* node = this-&gt;node(); node; node = node-&gt;parentNode()) {
2559         if (node-&gt;hasTagName(markTag))
2560             return true;
2561     }
2562 
2563     return false;
2564 }
2565 
2566 String AccessibilityObject::roleDescription() const
2567 {
2568     return stripLeadingAndTrailingHTMLSpaces(getAttribute(aria_roledescriptionAttr));
2569 }
2570 
2571 bool nodeHasPresentationRole(Node* node)
2572 {
2573     return nodeHasRole(node, &quot;presentation&quot;) || nodeHasRole(node, &quot;none&quot;);
2574 }
2575 
2576 bool AccessibilityObject::supportsPressAction() const
2577 {
2578     if (isButton())
2579         return true;
2580     if (roleValue() == AccessibilityRole::Details)
2581         return true;
2582 
2583     Element* actionElement = this-&gt;actionElement();
2584     if (!actionElement)
2585         return false;
2586 
2587     // [Bug: 136247] Heuristic: element handlers that have more than one accessible descendant should not be exposed as supporting press.
2588     if (actionElement != element()) {
2589         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(actionElement)) {
2590             AccessibilityChildrenVector results;
2591             // Search within for immediate descendants that are static text. If we find more than one
2592             // then this is an event delegator actionElement and we should expose the press action.
2593             Vector&lt;AccessibilitySearchKey&gt; keys({ AccessibilitySearchKey::StaticText, AccessibilitySearchKey::Control, AccessibilitySearchKey::Graphic, AccessibilitySearchKey::Heading, AccessibilitySearchKey::Link });
2594             AccessibilitySearchCriteria criteria(axObj, AccessibilitySearchDirection::Next, emptyString(), 2, false, false);
2595             criteria.searchKeys = keys;
2596             axObj-&gt;findMatchingObjects(&amp;criteria, results);
2597             if (results.size() &gt; 1)
2598                 return false;
2599         }
2600     }
2601 
2602     // [Bug: 133613] Heuristic: If the action element is presentational, we shouldn&#39;t expose press as a supported action.
2603     return !nodeHasPresentationRole(actionElement);
2604 }
2605 
2606 bool AccessibilityObject::supportsDatetimeAttribute() const
2607 {
2608     return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
2609 }
2610 
<a name="65" id="anc65"></a><span class="line-modified">2611 const AtomString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
2612 {
2613     return getAttribute(datetimeAttr);
2614 }
2615 
<a name="66" id="anc66"></a><span class="line-modified">2616 const AtomString&amp; AccessibilityObject::linkRelValue() const</span>
2617 {
2618     return getAttribute(relAttr);
2619 }
2620 
2621 const String AccessibilityObject::keyShortcutsValue() const
2622 {
2623     return getAttribute(aria_keyshortcutsAttr);
2624 }
2625 
2626 Element* AccessibilityObject::element() const
2627 {
2628     Node* node = this-&gt;node();
2629     if (is&lt;Element&gt;(node))
2630         return downcast&lt;Element&gt;(node);
2631     return nullptr;
2632 }
2633 
2634 bool AccessibilityObject::isValueAutofillAvailable() const
2635 {
2636     if (!isNativeTextControl())
2637         return false;
2638 
2639     Node* node = this-&gt;node();
2640     if (!is&lt;HTMLInputElement&gt;(node))
2641         return false;
2642 
2643     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFillAvailable() || downcast&lt;HTMLInputElement&gt;(*node).autoFillButtonType() != AutoFillButtonType::None;
2644 }
2645 
2646 AutoFillButtonType AccessibilityObject::valueAutofillButtonType() const
2647 {
2648     if (!isValueAutofillAvailable())
2649         return AutoFillButtonType::None;
2650 
2651     return downcast&lt;HTMLInputElement&gt;(*this-&gt;node()).autoFillButtonType();
2652 }
2653 
2654 bool AccessibilityObject::isValueAutofilled() const
2655 {
2656     if (!isNativeTextControl())
2657         return false;
2658 
2659     Node* node = this-&gt;node();
2660     if (!is&lt;HTMLInputElement&gt;(node))
2661         return false;
2662 
2663     return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
2664 }
2665 
2666 const String AccessibilityObject::placeholderValue() const
2667 {
<a name="67" id="anc67"></a><span class="line-modified">2668     const AtomString&amp; placeholder = getAttribute(placeholderAttr);</span>
2669     if (!placeholder.isEmpty())
2670         return placeholder;
2671 
<a name="68" id="anc68"></a><span class="line-modified">2672     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);</span>
2673     if (!ariaPlaceholder.isEmpty())
2674         return ariaPlaceholder;
2675 
2676     return nullAtom();
2677 }
2678 
2679 bool AccessibilityObject::isInsideLiveRegion(bool excludeIfOff) const
2680 {
2681     return liveRegionAncestor(excludeIfOff);
2682 }
2683 
2684 AccessibilityObject* AccessibilityObject::liveRegionAncestor(bool excludeIfOff) const
2685 {
2686     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [excludeIfOff] (const AccessibilityObject&amp; object) {
2687         return object.supportsLiveRegion(excludeIfOff);
2688     }));
2689 }
2690 
2691 bool AccessibilityObject::supportsARIAAttributes() const
2692 {
2693     // This returns whether the element supports any global ARIA attributes.
2694     return supportsLiveRegion()
2695         || supportsARIADragging()
2696         || supportsARIADropping()
2697         || supportsARIAOwns()
2698         || hasAttribute(aria_atomicAttr)
2699         || hasAttribute(aria_busyAttr)
2700         || hasAttribute(aria_controlsAttr)
2701         || hasAttribute(aria_currentAttr)
2702         || hasAttribute(aria_describedbyAttr)
2703         || hasAttribute(aria_detailsAttr)
2704         || hasAttribute(aria_disabledAttr)
2705         || hasAttribute(aria_errormessageAttr)
2706         || hasAttribute(aria_flowtoAttr)
2707         || hasAttribute(aria_haspopupAttr)
2708         || hasAttribute(aria_invalidAttr)
2709         || hasAttribute(aria_labelAttr)
2710         || hasAttribute(aria_labelledbyAttr)
2711         || hasAttribute(aria_relevantAttr);
2712 }
2713 
<a name="69" id="anc69"></a><span class="line-modified">2714 bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)</span>
2715 {
2716     return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
2717 }
2718 
2719 bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
2720 {
<a name="70" id="anc70"></a><span class="line-modified">2721     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();</span>
2722     return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
2723 }
2724 
<a name="71" id="anc71"></a><span class="line-modified">2725 AccessibilityObjectInterface* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2726 {
2727     // Send the hit test back into the sub-frame if necessary.
2728     if (isAttachment()) {
2729         Widget* widget = widgetForAttachmentView();
2730         // Normalize the point for the widget&#39;s bounds.
2731         if (widget &amp;&amp; widget-&gt;isFrameView()) {
2732             if (AXObjectCache* cache = axObjectCache())
2733                 return cache-&gt;getOrCreate(widget)-&gt;accessibilityHitTest(IntPoint(point - widget-&gt;frameRect().location()));
2734         }
2735     }
2736 
2737     // Check if there are any mock elements that need to be handled.
2738     for (const auto&amp; child : m_children) {
2739         if (child-&gt;isMockObject() &amp;&amp; child-&gt;elementRect().contains(point))
2740             return child-&gt;elementAccessibilityHitTest(point);
2741     }
2742 
2743     return const_cast&lt;AccessibilityObject*&gt;(this);
2744 }
2745 
2746 AXObjectCache* AccessibilityObject::axObjectCache() const
2747 {
2748     auto* document = this-&gt;document();
2749     return document ? document-&gt;axObjectCache() : nullptr;
2750 }
2751 
<a name="72" id="anc72"></a><span class="line-modified">2752 AccessibilityObjectInterface* AccessibilityObject::focusedUIElement() const</span>
2753 {
2754     auto* page = this-&gt;page();
2755     return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
2756 }
2757 
2758 AccessibilitySortDirection AccessibilityObject::sortDirection() const
2759 {
2760     AccessibilityRole role = roleValue();
2761     if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
2762         return AccessibilitySortDirection::Invalid;
2763 
<a name="73" id="anc73"></a><span class="line-modified">2764     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);</span>
2765     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
2766         return AccessibilitySortDirection::Ascending;
2767     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
2768         return AccessibilitySortDirection::Descending;
2769     if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
2770         return AccessibilitySortDirection::Other;
2771 
2772     return AccessibilitySortDirection::None;
2773 }
2774 
2775 bool AccessibilityObject::supportsRangeValue() const
2776 {
2777     return isProgressIndicator()
2778         || isSlider()
2779         || isScrollbar()
2780         || isSpinButton()
2781         || (isSplitter() &amp;&amp; canSetFocusAttribute())
2782         || isAttachmentElement();
2783 }
2784 
2785 bool AccessibilityObject::supportsHasPopup() const
2786 {
2787     return hasAttribute(aria_haspopupAttr) || isComboBox();
2788 }
2789 
<a name="74" id="anc74"></a><span class="line-modified">2790 String AccessibilityObject::popupValue() const</span>
2791 {
<a name="75" id="anc75"></a><span class="line-modified">2792     static const NeverDestroyed&lt;HashSet&lt;String&gt;&gt; allowedPopupValues(std::initializer_list&lt;String&gt; {</span>
<span class="line-modified">2793         &quot;menu&quot;, &quot;listbox&quot;, &quot;tree&quot;, &quot;grid&quot;, &quot;dialog&quot;</span>
<span class="line-modified">2794     });</span>
<span class="line-modified">2795 </span>
<span class="line-modified">2796     auto hasPopup = getAttribute(aria_haspopupAttr).convertToASCIILowercase();</span>
<span class="line-modified">2797     if (hasPopup.isNull() || hasPopup.isEmpty()) {</span>
<span class="line-modified">2798         // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;</span>
<span class="line-added">2799         if (isComboBox() || hasDatalist())</span>
<span class="line-added">2800             return &quot;listbox&quot;;</span>
<span class="line-added">2801         return &quot;false&quot;;</span>
<span class="line-added">2802     }</span>
<span class="line-added">2803 </span>
<span class="line-added">2804     if (allowedPopupValues-&gt;contains(hasPopup))</span>
2805         return hasPopup;
2806 
<a name="76" id="anc76"></a><span class="line-modified">2807     // aria-haspopup specification states that true must be treated as menu.</span>
<span class="line-modified">2808     if (hasPopup == &quot;true&quot;)</span>
<span class="line-modified">2809         return &quot;menu&quot;;</span>
2810 
2811     // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
2812     // included in the list of allowed values, including an empty string, as if the value
2813     // false had been provided.&quot;
2814     return &quot;false&quot;;
2815 }
2816 
<a name="77" id="anc77"></a><span class="line-added">2817 bool AccessibilityObject::hasDatalist() const</span>
<span class="line-added">2818 {</span>
<span class="line-added">2819 #if ENABLE(DATALIST_ELEMENT)</span>
<span class="line-added">2820     auto datalistId = getAttribute(listAttr);</span>
<span class="line-added">2821     if (datalistId.isNull() || datalistId.isEmpty())</span>
<span class="line-added">2822         return false;</span>
<span class="line-added">2823 </span>
<span class="line-added">2824     auto element = this-&gt;element();</span>
<span class="line-added">2825     if (!element)</span>
<span class="line-added">2826         return false;</span>
<span class="line-added">2827 </span>
<span class="line-added">2828     auto datalist = element-&gt;treeScope().getElementById(datalistId);</span>
<span class="line-added">2829     return is&lt;HTMLDataListElement&gt;(datalist);</span>
<span class="line-added">2830 #else</span>
<span class="line-added">2831     return false;</span>
<span class="line-added">2832 #endif</span>
<span class="line-added">2833 }</span>
<span class="line-added">2834 </span>
2835 bool AccessibilityObject::supportsSetSize() const
2836 {
2837     return hasAttribute(aria_setsizeAttr);
2838 }
2839 
2840 bool AccessibilityObject::supportsPosInSet() const
2841 {
2842     return hasAttribute(aria_posinsetAttr);
2843 }
2844 
2845 int AccessibilityObject::setSize() const
2846 {
2847     return getAttribute(aria_setsizeAttr).toInt();
2848 }
2849 
2850 int AccessibilityObject::posInSet() const
2851 {
2852     return getAttribute(aria_posinsetAttr).toInt();
2853 }
2854 
<a name="78" id="anc78"></a><span class="line-modified">2855 const AtomString&amp; AccessibilityObject::identifierAttribute() const</span>
2856 {
2857     return getAttribute(idAttr);
2858 }
2859 
2860 void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
2861 {
2862     Node* node = this-&gt;node();
2863     if (!is&lt;Element&gt;(node))
2864         return;
2865 
2866     Element* element = downcast&lt;Element&gt;(node);
2867     DOMTokenList&amp; list = element-&gt;classList();
2868     unsigned length = list.length();
2869     for (unsigned k = 0; k &lt; length; k++)
2870         classList.append(list.item(k).string());
2871 }
2872 
2873 bool AccessibilityObject::supportsPressed() const
2874 {
<a name="79" id="anc79"></a><span class="line-modified">2875     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);</span>
2876     return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
2877 }
2878 
2879 bool AccessibilityObject::supportsExpanded() const
2880 {
2881     // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
<a name="80" id="anc80"></a><span class="line-modified">2882     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);</span>
2883     if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
2884         return true;
2885     switch (roleValue()) {
2886     case AccessibilityRole::ComboBox:
2887     case AccessibilityRole::DisclosureTriangle:
2888     case AccessibilityRole::Details:
2889         return true;
2890     default:
2891         return false;
2892     }
2893 }
2894 
2895 bool AccessibilityObject::isExpanded() const
2896 {
2897     if (equalLettersIgnoringASCIICase(getAttribute(aria_expandedAttr), &quot;true&quot;))
2898         return true;
2899 
2900     if (is&lt;HTMLDetailsElement&gt;(node()))
2901         return downcast&lt;HTMLDetailsElement&gt;(node())-&gt;isOpen();
2902 
2903     // Summary element should use its details parent&#39;s expanded status.
2904     if (isSummary()) {
2905         if (const AccessibilityObject* parent = AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
2906             return is&lt;HTMLDetailsElement&gt;(object.node());
2907         }))
2908             return parent-&gt;isExpanded();
2909     }
2910 
2911     return false;
2912 }
2913 
2914 bool AccessibilityObject::supportsChecked() const
2915 {
2916     switch (roleValue()) {
2917     case AccessibilityRole::CheckBox:
2918     case AccessibilityRole::MenuItemCheckbox:
2919     case AccessibilityRole::MenuItemRadio:
2920     case AccessibilityRole::RadioButton:
2921     case AccessibilityRole::Switch:
2922         return true;
2923     default:
2924         return false;
2925     }
2926 }
2927 
2928 AccessibilityButtonState AccessibilityObject::checkboxOrRadioValue() const
2929 {
2930     // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
2931     // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
2932     // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
2933 
2934     if (isToggleButton()) {
<a name="81" id="anc81"></a><span class="line-modified">2935         const AtomString&amp; ariaPressed = getAttribute(aria_pressedAttr);</span>
2936         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
2937             return AccessibilityButtonState::On;
2938         if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
2939             return AccessibilityButtonState::Mixed;
2940         return AccessibilityButtonState::Off;
2941     }
2942 
<a name="82" id="anc82"></a><span class="line-modified">2943     const AtomString&amp; result = getAttribute(aria_checkedAttr);</span>
2944     if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
2945         return AccessibilityButtonState::On;
2946     if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
2947         // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
2948         AccessibilityRole ariaRole = ariaRoleAttribute();
2949         if (ariaRole == AccessibilityRole::RadioButton || ariaRole == AccessibilityRole::MenuItemRadio || ariaRole == AccessibilityRole::Switch)
2950             return AccessibilityButtonState::Off;
2951         return AccessibilityButtonState::Mixed;
2952     }
2953 
2954     if (isIndeterminate())
2955         return AccessibilityButtonState::Mixed;
2956 
2957     return AccessibilityButtonState::Off;
2958 }
2959 
2960 // This is a 1-dimensional scroll offset helper function that&#39;s applied
2961 // separately in the horizontal and vertical directions, because the
2962 // logic is the same. The goal is to compute the best scroll offset
2963 // in order to make an object visible within a viewport.
2964 //
2965 // If the object is already fully visible, returns the same scroll
2966 // offset.
2967 //
2968 // In case the whole object cannot fit, you can specify a
2969 // subfocus - a smaller region within the object that should
2970 // be prioritized. If the whole object can fit, the subfocus is
2971 // ignored.
2972 //
2973 // If possible, the object and subfocus are centered within the
2974 // viewport.
2975 //
2976 // Example 1: the object is already visible, so nothing happens.
2977 //   +----------Viewport---------+
2978 //                 +---Object---+
2979 //                 +--SubFocus--+
2980 //
2981 // Example 2: the object is not fully visible, so it&#39;s centered
2982 // within the viewport.
2983 //   Before:
2984 //   +----------Viewport---------+
2985 //                         +---Object---+
2986 //                         +--SubFocus--+
2987 //
2988 //   After:
2989 //                 +----------Viewport---------+
2990 //                         +---Object---+
2991 //                         +--SubFocus--+
2992 //
2993 // Example 3: the object is larger than the viewport, so the
2994 // viewport moves to show as much of the object as possible,
2995 // while also trying to center the subfocus.
2996 //   Before:
2997 //   +----------Viewport---------+
2998 //     +---------------Object--------------+
2999 //                         +-SubFocus-+
3000 //
3001 //   After:
3002 //             +----------Viewport---------+
3003 //     +---------------Object--------------+
3004 //                         +-SubFocus-+
3005 //
3006 // When constraints cannot be fully satisfied, the min
3007 // (left/top) position takes precedence over the max (right/bottom).
3008 //
3009 // Note that the return value represents the ideal new scroll offset.
3010 // This may be out of range - the calling function should clip this
3011 // to the available range.
3012 static int computeBestScrollOffset(int currentScrollOffset, int subfocusMin, int subfocusMax, int objectMin, int objectMax, int viewportMin, int viewportMax)
3013 {
3014     int viewportSize = viewportMax - viewportMin;
3015 
3016     // If the object size is larger than the viewport size, consider
3017     // only a portion that&#39;s as large as the viewport, centering on
3018     // the subfocus as much as possible.
3019     if (objectMax - objectMin &gt; viewportSize) {
3020         // Since it&#39;s impossible to fit the whole object in the
3021         // viewport, exit now if the subfocus is already within the viewport.
3022         if (subfocusMin - currentScrollOffset &gt;= viewportMin &amp;&amp; subfocusMax - currentScrollOffset &lt;= viewportMax)
3023             return currentScrollOffset;
3024 
3025         // Subfocus must be within focus.
3026         subfocusMin = std::max(subfocusMin, objectMin);
3027         subfocusMax = std::min(subfocusMax, objectMax);
3028 
3029         // Subfocus must be no larger than the viewport size; favor top/left.
3030         if (subfocusMax - subfocusMin &gt; viewportSize)
3031             subfocusMax = subfocusMin + viewportSize;
3032 
3033         // Compute the size of an object centered on the subfocus, the size of the viewport.
3034         int centeredObjectMin = (subfocusMin + subfocusMax - viewportSize) / 2;
3035         int centeredObjectMax = centeredObjectMin + viewportSize;
3036 
3037         objectMin = std::max(objectMin, centeredObjectMin);
3038         objectMax = std::min(objectMax, centeredObjectMax);
3039     }
3040 
3041     // Exit now if the focus is already within the viewport.
3042     if (objectMin - currentScrollOffset &gt;= viewportMin
3043         &amp;&amp; objectMax - currentScrollOffset &lt;= viewportMax)
3044         return currentScrollOffset;
3045 
3046     // Center the object in the viewport.
3047     return (objectMin + objectMax - viewportMin - viewportMax) / 2;
3048 }
3049 
3050 bool AccessibilityObject::isOnscreen() const
3051 {
3052     bool isOnscreen = true;
3053 
3054     // To figure out if the element is onscreen, we start by building of a stack starting with the
3055     // element, and then include every scrollable parent in the hierarchy.
3056     Vector&lt;const AccessibilityObject*&gt; objects;
3057 
3058     objects.append(this);
3059     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
3060         if (parentObject-&gt;getScrollableAreaIfScrollable())
3061             objects.append(parentObject);
3062     }
3063 
3064     // Now, go back through that chain and make sure each inner object is within the
3065     // visible bounds of the outer object.
3066     size_t levels = objects.size() - 1;
3067 
3068     for (size_t i = levels; i &gt;= 1; i--) {
3069         const AccessibilityObject* outer = objects[i];
3070         const AccessibilityObject* inner = objects[i - 1];
3071         // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3072         const IntRect outerRect = i &lt; levels ? snappedIntRect(outer-&gt;boundingBoxRect()) : outer-&gt;getScrollableAreaIfScrollable()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3073         const IntRect innerRect = snappedIntRect(inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect());
3074 
3075         if (!outerRect.intersects(innerRect)) {
3076             isOnscreen = false;
3077             break;
3078         }
3079     }
3080 
3081     return isOnscreen;
3082 }
3083 
3084 void AccessibilityObject::scrollToMakeVisible() const
3085 {
<a name="83" id="anc83"></a><span class="line-modified">3086     scrollToMakeVisible({ SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });</span>
<span class="line-modified">3087 }</span>
3088 
<a name="84" id="anc84"></a><span class="line-added">3089 void AccessibilityObject::scrollToMakeVisible(const ScrollRectToVisibleOptions&amp; options) const</span>
<span class="line-added">3090 {</span>
3091     if (isScrollView() &amp;&amp; parentObject())
3092         parentObject()-&gt;scrollToMakeVisible();
3093 
3094     if (auto* renderer = this-&gt;renderer())
<a name="85" id="anc85"></a><span class="line-modified">3095         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, options);</span>
3096 }
3097 
3098 void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
3099 {
3100     // Search up the parent chain until we find the first one that&#39;s scrollable.
3101     AccessibilityObject* scrollParent = parentObject();
3102     ScrollableArea* scrollableArea;
3103     for (scrollableArea = nullptr;
3104          scrollParent &amp;&amp; !(scrollableArea = scrollParent-&gt;getScrollableAreaIfScrollable());
3105          scrollParent = scrollParent-&gt;parentObject()) { }
3106     if (!scrollableArea)
3107         return;
3108 
3109     LayoutRect objectRect = boundingBoxRect();
3110     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3111     // FIXME: unclear if we need LegacyIOSDocumentVisibleRect.
3112     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3113 
3114     if (!scrollParent-&gt;isScrollView()) {
3115         objectRect.moveBy(scrollPosition);
3116         objectRect.moveBy(-snappedIntRect(scrollParent-&gt;elementRect()).location());
3117     }
3118 
3119     int desiredX = computeBestScrollOffset(
3120         scrollPosition.x(),
3121         objectRect.x() + subfocus.x(), objectRect.x() + subfocus.maxX(),
3122         objectRect.x(), objectRect.maxX(),
3123         0, scrollVisibleRect.width());
3124     int desiredY = computeBestScrollOffset(
3125         scrollPosition.y(),
3126         objectRect.y() + subfocus.y(), objectRect.y() + subfocus.maxY(),
3127         objectRect.y(), objectRect.maxY(),
3128         0, scrollVisibleRect.height());
3129 
3130     scrollParent-&gt;scrollTo(IntPoint(desiredX, desiredY));
3131 
3132     // Convert the subfocus into the coordinates of the scroll parent.
3133     IntRect newSubfocus = subfocus;
3134     IntRect newElementRect = snappedIntRect(elementRect());
3135     IntRect scrollParentRect = snappedIntRect(scrollParent-&gt;elementRect());
3136     newSubfocus.move(newElementRect.x(), newElementRect.y());
3137     newSubfocus.move(-scrollParentRect.x(), -scrollParentRect.y());
3138 
3139     // Recursively make sure the scroll parent itself is visible.
3140     if (scrollParent-&gt;parentObject())
3141         scrollParent-&gt;scrollToMakeVisibleWithSubFocus(newSubfocus);
3142 }
3143 
3144 void AccessibilityObject::scrollToGlobalPoint(const IntPoint&amp; globalPoint) const
3145 {
3146     // Search up the parent chain and create a vector of all scrollable parent objects
3147     // and ending with this object itself.
3148     Vector&lt;const AccessibilityObject*&gt; objects;
3149 
3150     objects.append(this);
3151     for (AccessibilityObject* parentObject = this-&gt;parentObject(); parentObject; parentObject = parentObject-&gt;parentObject()) {
3152         if (parentObject-&gt;getScrollableAreaIfScrollable())
3153             objects.append(parentObject);
3154     }
3155 
3156     objects.reverse();
3157 
3158     // Start with the outermost scrollable (the main window) and try to scroll the
3159     // next innermost object to the given point.
3160     int offsetX = 0, offsetY = 0;
3161     IntPoint point = globalPoint;
3162     size_t levels = objects.size() - 1;
3163     for (size_t i = 0; i &lt; levels; i++) {
3164         const AccessibilityObject* outer = objects[i];
3165         const AccessibilityObject* inner = objects[i + 1];
3166 
3167         ScrollableArea* scrollableArea = outer-&gt;getScrollableAreaIfScrollable();
3168 
3169         LayoutRect innerRect = inner-&gt;isAccessibilityScrollView() ? inner-&gt;parentObject()-&gt;boundingBoxRect() : inner-&gt;boundingBoxRect();
3170         LayoutRect objectRect = innerRect;
3171         IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3172 
3173         // Convert the object rect into local coordinates.
3174         objectRect.move(offsetX, offsetY);
3175         if (!outer-&gt;isAccessibilityScrollView())
3176             objectRect.move(scrollPosition.x(), scrollPosition.y());
3177 
3178         int desiredX = computeBestScrollOffset(
3179             0,
3180             objectRect.x(), objectRect.maxX(),
3181             objectRect.x(), objectRect.maxX(),
3182             point.x(), point.x());
3183         int desiredY = computeBestScrollOffset(
3184             0,
3185             objectRect.y(), objectRect.maxY(),
3186             objectRect.y(), objectRect.maxY(),
3187             point.y(), point.y());
3188         outer-&gt;scrollTo(IntPoint(desiredX, desiredY));
3189 
3190         if (outer-&gt;isAccessibilityScrollView() &amp;&amp; !inner-&gt;isAccessibilityScrollView()) {
3191             // If outer object we just scrolled is a scroll view (main window or iframe) but the
3192             // inner object is not, keep track of the coordinate transformation to apply to
3193             // future nested calculations.
3194             scrollPosition = scrollableArea-&gt;scrollPosition();
3195             offsetX -= (scrollPosition.x() + point.x());
3196             offsetY -= (scrollPosition.y() + point.y());
3197             point.move(scrollPosition.x() - innerRect.x(),
3198                        scrollPosition.y() - innerRect.y());
3199         } else if (inner-&gt;isAccessibilityScrollView()) {
3200             // Otherwise, if the inner object is a scroll view, reset the coordinate transformation.
3201             offsetX = 0;
3202             offsetY = 0;
3203         }
3204     }
3205 }
3206 
3207 void AccessibilityObject::scrollAreaAndAncestor(std::pair&lt;ScrollableArea*, AccessibilityObject*&gt;&amp; scrollers) const
3208 {
3209     // Search up the parent chain until we find the first one that&#39;s scrollable.
3210     scrollers.first = nullptr;
3211     for (scrollers.second = parentObject(); scrollers.second; scrollers.second = scrollers.second-&gt;parentObject()) {
3212         if ((scrollers.first = scrollers.second-&gt;getScrollableAreaIfScrollable()))
3213             break;
3214     }
3215 }
3216 
3217 ScrollableArea* AccessibilityObject::scrollableAreaAncestor() const
3218 {
3219     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3220     scrollAreaAndAncestor(scrollers);
3221     return scrollers.first;
3222 }
3223 
3224 IntPoint AccessibilityObject::scrollPosition() const
3225 {
3226     if (auto scroller = scrollableAreaAncestor())
3227         return scroller-&gt;scrollPosition();
3228 
3229     return IntPoint();
3230 }
3231 
3232 IntRect AccessibilityObject::scrollVisibleContentRect() const
3233 {
3234     if (auto scroller = scrollableAreaAncestor())
3235         return scroller-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3236 
3237     return IntRect();
3238 }
3239 
3240 IntSize AccessibilityObject::scrollContentsSize() const
3241 {
3242     if (auto scroller = scrollableAreaAncestor())
3243         return scroller-&gt;contentsSize();
3244 
3245     return IntSize();
3246 }
3247 
3248 bool AccessibilityObject::scrollByPage(ScrollByPageDirection direction) const
3249 {
3250     std::pair&lt;ScrollableArea*, AccessibilityObject*&gt; scrollers;
3251     scrollAreaAndAncestor(scrollers);
3252     ScrollableArea* scrollableArea = scrollers.first;
3253     AccessibilityObject* scrollParent = scrollers.second;
3254 
3255     if (!scrollableArea)
3256         return false;
3257 
3258     IntPoint scrollPosition = scrollableArea-&gt;scrollPosition();
3259     IntPoint newScrollPosition = scrollPosition;
3260     IntSize scrollSize = scrollableArea-&gt;contentsSize();
3261     IntRect scrollVisibleRect = scrollableArea-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
3262     switch (direction) {
3263     case ScrollByPageDirection::Right: {
3264         int scrollAmount = scrollVisibleRect.size().width();
3265         int newX = scrollPosition.x() - scrollAmount;
3266         newScrollPosition.setX(std::max(newX, 0));
3267         break;
3268     }
3269     case ScrollByPageDirection::Left: {
3270         int scrollAmount = scrollVisibleRect.size().width();
3271         int newX = scrollAmount + scrollPosition.x();
3272         int maxX = scrollSize.width() - scrollAmount;
3273         newScrollPosition.setX(std::min(newX, maxX));
3274         break;
3275     }
3276     case ScrollByPageDirection::Up: {
3277         int scrollAmount = scrollVisibleRect.size().height();
3278         int newY = scrollPosition.y() - scrollAmount;
3279         newScrollPosition.setY(std::max(newY, 0));
3280         break;
3281     }
3282     case ScrollByPageDirection::Down: {
3283         int scrollAmount = scrollVisibleRect.size().height();
3284         int newY = scrollAmount + scrollPosition.y();
3285         int maxY = scrollSize.height() - scrollAmount;
3286         newScrollPosition.setY(std::min(newY, maxY));
3287         break;
3288     }
3289     }
3290 
3291     if (newScrollPosition != scrollPosition) {
3292         scrollParent-&gt;scrollTo(newScrollPosition);
3293         document()-&gt;updateLayoutIgnorePendingStylesheets();
3294         return true;
3295     }
3296 
3297     return false;
3298 }
3299 
3300 
3301 bool AccessibilityObject::lastKnownIsIgnoredValue()
3302 {
3303     if (m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::DefaultBehavior)
3304         m_lastKnownIsIgnoredValue = accessibilityIsIgnored() ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3305 
3306     return m_lastKnownIsIgnoredValue == AccessibilityObjectInclusion::IgnoreObject;
3307 }
3308 
3309 void AccessibilityObject::setLastKnownIsIgnoredValue(bool isIgnored)
3310 {
3311     m_lastKnownIsIgnoredValue = isIgnored ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject;
3312 }
3313 
3314 void AccessibilityObject::notifyIfIgnoredValueChanged()
3315 {
3316     bool isIgnored = accessibilityIsIgnored();
3317     if (lastKnownIsIgnoredValue() != isIgnored) {
3318         if (AXObjectCache* cache = axObjectCache())
3319             cache-&gt;childrenChanged(parentObject());
3320         setLastKnownIsIgnoredValue(isIgnored);
3321     }
3322 }
3323 
3324 bool AccessibilityObject::pressedIsPresent() const
3325 {
3326     return !getAttribute(aria_pressedAttr).isEmpty();
3327 }
3328 
3329 TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
3330 {
3331     TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
3332 
<a name="86" id="anc86"></a><span class="line-modified">3333 #if USE(ATK)</span>
3334     // We need to emit replaced elements for GTK, and present
3335     // them with the &#39;object replacement character&#39; (0xFFFC).
3336     behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
3337 #endif
3338 
3339     return behavior;
3340 }
3341 
3342 AccessibilityRole AccessibilityObject::buttonRoleType() const
3343 {
3344     // If aria-pressed is present, then it should be exposed as a toggle button.
3345     // http://www.w3.org/TR/wai-aria/states_and_properties#aria-pressed
3346     if (pressedIsPresent())
3347         return AccessibilityRole::ToggleButton;
3348     if (hasPopup())
3349         return AccessibilityRole::PopUpButton;
3350     // We don&#39;t contemplate AccessibilityRole::RadioButton, as it depends on the input
3351     // type.
3352 
3353     return AccessibilityRole::Button;
3354 }
3355 
3356 bool AccessibilityObject::isButton() const
3357 {
3358     AccessibilityRole role = roleValue();
3359 
3360     return role == AccessibilityRole::Button || role == AccessibilityRole::PopUpButton || role == AccessibilityRole::ToggleButton;
3361 }
3362 
3363 bool AccessibilityObject::accessibilityIsIgnoredByDefault() const
3364 {
3365     return defaultObjectInclusion() == AccessibilityObjectInclusion::IgnoreObject;
3366 }
3367 
3368 // ARIA component of hidden definition.
3369 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3370 bool AccessibilityObject::isAXHidden() const
3371 {
3372     return AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3373         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;true&quot;);
3374     }) != nullptr;
3375 }
3376 
3377 // DOM component of hidden definition.
3378 // http://www.w3.org/TR/wai-aria/terms#def_hidden
3379 bool AccessibilityObject::isDOMHidden() const
3380 {
3381     RenderObject* renderer = this-&gt;renderer();
3382     if (!renderer)
3383         return true;
3384 
3385     const RenderStyle&amp; style = renderer-&gt;style();
3386     return style.display() == DisplayType::None || style.visibility() != Visibility::Visible;
3387 }
3388 
3389 bool AccessibilityObject::isShowingValidationMessage() const
3390 {
3391     if (is&lt;HTMLFormControlElement&gt;(node()))
3392         return downcast&lt;HTMLFormControlElement&gt;(*node()).isShowingValidationMessage();
3393     return false;
3394 }
3395 
3396 String AccessibilityObject::validationMessage() const
3397 {
3398     if (is&lt;HTMLFormControlElement&gt;(node()))
3399         return downcast&lt;HTMLFormControlElement&gt;(*node()).validationMessage();
3400     return String();
3401 }
3402 
3403 AccessibilityObjectInclusion AccessibilityObject::defaultObjectInclusion() const
3404 {
3405     bool useParentData = !m_isIgnoredFromParentData.isNull();
3406 
3407     if (useParentData ? m_isIgnoredFromParentData.isAXHidden : isAXHidden())
3408         return AccessibilityObjectInclusion::IgnoreObject;
3409 
3410     if (ignoredFromModalPresence())
3411         return AccessibilityObjectInclusion::IgnoreObject;
3412 
3413     if (useParentData ? m_isIgnoredFromParentData.isPresentationalChildOfAriaRole : isPresentationalChildOfAriaRole())
3414         return AccessibilityObjectInclusion::IgnoreObject;
3415 
3416     return accessibilityPlatformIncludesObject();
3417 }
3418 
3419 bool AccessibilityObject::accessibilityIsIgnored() const
3420 {
3421     AXComputedObjectAttributeCache* attributeCache = nullptr;
3422     AXObjectCache* cache = axObjectCache();
3423     if (cache)
3424         attributeCache = cache-&gt;computedObjectAttributeCache();
3425 
3426     if (attributeCache) {
3427         AccessibilityObjectInclusion ignored = attributeCache-&gt;getIgnored(axObjectID());
3428         switch (ignored) {
3429         case AccessibilityObjectInclusion::IgnoreObject:
3430             return true;
3431         case AccessibilityObjectInclusion::IncludeObject:
3432             return false;
3433         case AccessibilityObjectInclusion::DefaultBehavior:
3434             break;
3435         }
3436     }
3437 
3438     bool result = computeAccessibilityIsIgnored();
3439 
3440     // In case computing axIsIgnored disables attribute caching, we should refetch the object to see if it exists.
3441     if (cache &amp;&amp; (attributeCache = cache-&gt;computedObjectAttributeCache()))
3442         attributeCache-&gt;setIgnored(axObjectID(), result ? AccessibilityObjectInclusion::IgnoreObject : AccessibilityObjectInclusion::IncludeObject);
3443 
3444     return result;
3445 }
3446 
3447 void AccessibilityObject::elementsFromAttribute(Vector&lt;Element*&gt;&amp; elements, const QualifiedName&amp; attribute) const
3448 {
3449     Node* node = this-&gt;node();
3450     if (!node || !node-&gt;isElementNode())
3451         return;
3452 
3453     TreeScope&amp; treeScope = node-&gt;treeScope();
3454 
<a name="87" id="anc87"></a><span class="line-modified">3455     const AtomString&amp; idList = getAttribute(attribute);</span>
3456     if (idList.isEmpty())
3457         return;
3458 
3459     auto spaceSplitString = SpaceSplitString(idList, false);
3460     size_t length = spaceSplitString.size();
3461     for (size_t i = 0; i &lt; length; ++i) {
3462         if (auto* idElement = treeScope.getElementById(spaceSplitString[i]))
3463             elements.append(idElement);
3464     }
3465 }
3466 
3467 #if PLATFORM(COCOA)
3468 bool AccessibilityObject::preventKeyboardDOMEventDispatch() const
3469 {
3470     Frame* frame = this-&gt;frame();
3471     return frame &amp;&amp; frame-&gt;settings().preventKeyboardDOMEventDispatch();
3472 }
3473 
3474 void AccessibilityObject::setPreventKeyboardDOMEventDispatch(bool on)
3475 {
3476     Frame* frame = this-&gt;frame();
3477     if (!frame)
3478         return;
3479     frame-&gt;settings().setPreventKeyboardDOMEventDispatch(on);
3480 }
3481 #endif
3482 
3483 AccessibilityObject* AccessibilityObject::focusableAncestor()
3484 {
3485     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3486         return object.canSetFocusAttribute();
3487     }));
3488 }
3489 
3490 AccessibilityObject* AccessibilityObject::editableAncestor()
3491 {
3492     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {
3493         return object.isTextControl();
3494     }));
3495 }
3496 
3497 AccessibilityObject* AccessibilityObject::highestEditableAncestor()
3498 {
3499     AccessibilityObject* editableAncestor = this-&gt;editableAncestor();
3500     AccessibilityObject* previousEditableAncestor = nullptr;
3501     while (editableAncestor) {
3502         if (editableAncestor == previousEditableAncestor) {
3503             if (AccessibilityObject* parent = editableAncestor-&gt;parentObject()) {
3504                 editableAncestor = parent-&gt;editableAncestor();
3505                 continue;
3506             }
3507             break;
3508         }
3509         previousEditableAncestor = editableAncestor;
3510         editableAncestor = editableAncestor-&gt;editableAncestor();
3511     }
3512     return previousEditableAncestor;
3513 }
3514 
3515 AccessibilityObject* AccessibilityObject::radioGroupAncestor() const
3516 {
3517     return const_cast&lt;AccessibilityObject*&gt;(AccessibilityObject::matchedParent(*this, false, [] (const AccessibilityObject&amp; object) {
3518         return object.isRadioGroup();
3519     }));
3520 }
3521 
3522 bool AccessibilityObject::isStyleFormatGroup() const
3523 {
3524     Node* node = this-&gt;node();
3525     if (!node)
3526         return false;
3527 
3528     return node-&gt;hasTagName(kbdTag) || node-&gt;hasTagName(codeTag)
3529     || node-&gt;hasTagName(preTag) || node-&gt;hasTagName(sampTag)
3530     || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
3531     || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
3532     || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
3533 }
3534 
<a name="88" id="anc88"></a><span class="line-modified">3535 bool AccessibilityObject::isFigureElement() const</span>






3536 {
3537     Node* node = this-&gt;node();
<a name="89" id="anc89"></a><span class="line-modified">3538     return node &amp;&amp; node-&gt;hasTagName(figureTag);</span>
3539 }
3540 
<a name="90" id="anc90"></a><span class="line-modified">3541 bool AccessibilityObject::isKeyboardFocusable() const</span>
3542 {
<a name="91" id="anc91"></a><span class="line-modified">3543     if (auto element = this-&gt;element())</span>
<span class="line-modified">3544         return element-&gt;isFocusable();</span>
<span class="line-added">3545     return false;</span>
3546 }
3547 
3548 bool AccessibilityObject::isOutput() const
3549 {
3550     Node* node = this-&gt;node();
3551     return node &amp;&amp; node-&gt;hasTagName(outputTag);
3552 }
3553 
3554 bool AccessibilityObject::isContainedByPasswordField() const
3555 {
3556     Node* node = this-&gt;node();
3557     if (!node)
3558         return false;
3559 
3560     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
3561         return false;
3562 
3563     Element* element = node-&gt;shadowHost();
3564     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*element).isPasswordField();
3565 }
3566 
3567 AccessibilityObject* AccessibilityObject::selectedListItem()
3568 {
3569     for (const auto&amp; child : children()) {
3570         if (child-&gt;isListItem() &amp;&amp; (child-&gt;isSelected() || child-&gt;isActiveDescendantOfFocusedContainer()))
3571             return child.get();
3572     }
3573 
3574     return nullptr;
3575 }
3576 
3577 void AccessibilityObject::ariaElementsFromAttribute(AccessibilityChildrenVector&amp; children, const QualifiedName&amp; attributeName) const
3578 {
3579     Vector&lt;Element*&gt; elements;
3580     elementsFromAttribute(elements, attributeName);
3581     AXObjectCache* cache = axObjectCache();
3582     for (const auto&amp; element : elements) {
3583         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(element))
3584             children.append(axObject);
3585     }
3586 }
3587 
3588 void AccessibilityObject::ariaElementsReferencedByAttribute(AccessibilityChildrenVector&amp; elements, const QualifiedName&amp; attribute) const
3589 {
3590     auto id = identifierAttribute();
3591     if (id.isEmpty())
3592         return;
3593 
3594     AXObjectCache* cache = axObjectCache();
3595     if (!cache)
3596         return;
3597 
3598     for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
<a name="92" id="anc92"></a><span class="line-modified">3599         const AtomString&amp; idList = element.attributeWithoutSynchronization(attribute);</span>
3600         if (!SpaceSplitString(idList, false).contains(id))
3601             continue;
3602 
3603         if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
3604             elements.append(axObject);
3605     }
3606 }
3607 
3608 bool AccessibilityObject::isActiveDescendantOfFocusedContainer() const
3609 {
3610     AccessibilityChildrenVector containers;
3611     ariaActiveDescendantReferencingElements(containers);
3612     for (auto&amp; container : containers) {
3613         if (container-&gt;isFocused())
3614             return true;
3615     }
3616 
3617     return false;
3618 }
3619 
3620 void AccessibilityObject::ariaActiveDescendantReferencingElements(AccessibilityChildrenVector&amp; containers) const
3621 {
3622     ariaElementsReferencedByAttribute(containers, aria_activedescendantAttr);
3623 }
3624 
3625 void AccessibilityObject::ariaControlsElements(AccessibilityChildrenVector&amp; ariaControls) const
3626 {
3627     ariaElementsFromAttribute(ariaControls, aria_controlsAttr);
3628 }
3629 
3630 void AccessibilityObject::ariaControlsReferencingElements(AccessibilityChildrenVector&amp; controllers) const
3631 {
3632     ariaElementsReferencedByAttribute(controllers, aria_controlsAttr);
3633 }
3634 
3635 void AccessibilityObject::ariaDescribedByElements(AccessibilityChildrenVector&amp; ariaDescribedBy) const
3636 {
3637     ariaElementsFromAttribute(ariaDescribedBy, aria_describedbyAttr);
3638 }
3639 
3640 void AccessibilityObject::ariaDescribedByReferencingElements(AccessibilityChildrenVector&amp; describers) const
3641 {
3642     ariaElementsReferencedByAttribute(describers, aria_describedbyAttr);
3643 }
3644 
3645 void AccessibilityObject::ariaDetailsElements(AccessibilityChildrenVector&amp; ariaDetails) const
3646 {
3647     ariaElementsFromAttribute(ariaDetails, aria_detailsAttr);
3648 }
3649 
3650 void AccessibilityObject::ariaDetailsReferencingElements(AccessibilityChildrenVector&amp; detailsFor) const
3651 {
3652     ariaElementsReferencedByAttribute(detailsFor, aria_detailsAttr);
3653 }
3654 
3655 void AccessibilityObject::ariaErrorMessageElements(AccessibilityChildrenVector&amp; ariaErrorMessage) const
3656 {
3657     ariaElementsFromAttribute(ariaErrorMessage, aria_errormessageAttr);
3658 }
3659 
3660 void AccessibilityObject::ariaErrorMessageReferencingElements(AccessibilityChildrenVector&amp; errorMessageFor) const
3661 {
3662     ariaElementsReferencedByAttribute(errorMessageFor, aria_errormessageAttr);
3663 }
3664 
3665 void AccessibilityObject::ariaFlowToElements(AccessibilityChildrenVector&amp; flowTo) const
3666 {
3667     ariaElementsFromAttribute(flowTo, aria_flowtoAttr);
3668 }
3669 
3670 void AccessibilityObject::ariaFlowToReferencingElements(AccessibilityChildrenVector&amp; flowFrom) const
3671 {
3672     ariaElementsReferencedByAttribute(flowFrom, aria_flowtoAttr);
3673 }
3674 
3675 void AccessibilityObject::ariaLabelledByElements(AccessibilityChildrenVector&amp; ariaLabelledBy) const
3676 {
3677     ariaElementsFromAttribute(ariaLabelledBy, aria_labelledbyAttr);
3678     if (!ariaLabelledBy.size())
3679         ariaElementsFromAttribute(ariaLabelledBy, aria_labeledbyAttr);
3680 }
3681 
3682 void AccessibilityObject::ariaLabelledByReferencingElements(AccessibilityChildrenVector&amp; labels) const
3683 {
3684     ariaElementsReferencedByAttribute(labels, aria_labelledbyAttr);
3685     if (!labels.size())
3686         ariaElementsReferencedByAttribute(labels, aria_labeledbyAttr);
3687 }
3688 
3689 void AccessibilityObject::ariaOwnsElements(AccessibilityChildrenVector&amp; axObjects) const
3690 {
3691     ariaElementsFromAttribute(axObjects, aria_ownsAttr);
3692 }
3693 
3694 void AccessibilityObject::ariaOwnsReferencingElements(AccessibilityChildrenVector&amp; owners) const
3695 {
3696     ariaElementsReferencedByAttribute(owners, aria_ownsAttr);
3697 }
3698 
3699 void AccessibilityObject::setIsIgnoredFromParentDataForChild(AccessibilityObject* child)
3700 {
3701     if (!child)
3702         return;
3703 
3704     if (child-&gt;parentObject() != this) {
3705         child-&gt;clearIsIgnoredFromParentData();
3706         return;
3707     }
3708 
3709     AccessibilityIsIgnoredFromParentData result = AccessibilityIsIgnoredFromParentData(this);
3710     if (!m_isIgnoredFromParentData.isNull()) {
3711         result.isAXHidden = m_isIgnoredFromParentData.isAXHidden || equalLettersIgnoringASCIICase(child-&gt;getAttribute(aria_hiddenAttr), &quot;true&quot;);
3712         result.isPresentationalChildOfAriaRole = m_isIgnoredFromParentData.isPresentationalChildOfAriaRole || ariaRoleHasPresentationalChildren();
3713         result.isDescendantOfBarrenParent = m_isIgnoredFromParentData.isDescendantOfBarrenParent || !canHaveChildren();
3714     } else {
3715         result.isAXHidden = child-&gt;isAXHidden();
3716         result.isPresentationalChildOfAriaRole = child-&gt;isPresentationalChildOfAriaRole();
3717         result.isDescendantOfBarrenParent = child-&gt;isDescendantOfBarrenParent();
3718     }
3719 
3720     child-&gt;setIsIgnoredFromParentData(result);
3721 }
3722 
3723 } // namespace WebCore
<a name="93" id="anc93"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="93" type="hidden" />
</body>
</html>