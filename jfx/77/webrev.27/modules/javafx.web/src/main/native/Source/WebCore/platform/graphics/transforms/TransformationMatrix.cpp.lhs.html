<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005, 2006, 2013 Apple Inc.  All rights reserved.
   3  * Copyright (C) 2009 Torch Mobile, Inc.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TransformationMatrix.h&quot;
  29 
  30 #include &quot;AffineTransform.h&quot;
  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;FloatRect.h&quot;
  33 #include &quot;IntRect.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &lt;cmath&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/MathExtras.h&gt;
<a name="1" id="anc1"></a>
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 #if CPU(X86_64)
  41 #include &lt;emmintrin.h&gt;
  42 #endif
  43 
  44 namespace WebCore {
  45 
  46 //
  47 // Adapted from Matrix Inversion by Richard Carling, Graphics Gems &lt;http://tog.acm.org/GraphicsGems/index.html&gt;.
  48 
  49 // EULA: The Graphics Gems code is copyright-protected. In other words, you cannot claim the text of the code
  50 // as your own and resell it. Using the code is permitted in any program, product, or library, non-commercial
  51 // or commercial. Giving credit is not required, though is a nice gesture. The code comes as-is, and if there
  52 // are any flaws or problems with any Gems code, nobody involved with Gems - authors, editors, publishers, or
  53 // webmasters - are to be held responsible. Basically, don&#39;t be a jerk, and remember that anything free comes
  54 // with no guarantee.
  55 
  56 // A clarification about the storage of matrix elements
  57 //
  58 // This class uses a 2 dimensional array internally to store the elements of the matrix. The first index into
  59 // the array refers to the column that the element lies in; the second index refers to the row.
  60 //
  61 // In other words, this is the layout of the matrix:
  62 //
  63 // | m_matrix[0][0] m_matrix[1][0] m_matrix[2][0] m_matrix[3][0] |
  64 // | m_matrix[0][1] m_matrix[1][1] m_matrix[2][1] m_matrix[3][1] |
  65 // | m_matrix[0][2] m_matrix[1][2] m_matrix[2][2] m_matrix[3][2] |
  66 // | m_matrix[0][3] m_matrix[1][3] m_matrix[2][3] m_matrix[3][3] |
  67 
  68 typedef double Vector4[4];
  69 typedef double Vector3[3];
  70 
  71 const double SMALL_NUMBER = 1.e-8;
  72 
  73 const TransformationMatrix TransformationMatrix::identity { };
  74 
  75 // inverse(original_matrix, inverse_matrix)
  76 //
  77 // calculate the inverse of a 4x4 matrix
  78 //
  79 // -1
  80 // A  = ___1__ adjoint A
  81 //       det A
  82 
  83 //  double = determinant2x2(double a, double b, double c, double d)
  84 //
  85 //  calculate the determinant of a 2x2 matrix.
  86 
  87 static double determinant2x2(double a, double b, double c, double d)
  88 {
  89     return a * d - b * c;
  90 }
  91 
  92 //  double = determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3)
  93 //
  94 //  Calculate the determinant of a 3x3 matrix
  95 //  in the form
  96 //
  97 //      | a1,  b1,  c1 |
  98 //      | a2,  b2,  c2 |
  99 //      | a3,  b3,  c3 |
 100 
 101 static double determinant3x3(double a1, double a2, double a3, double b1, double b2, double b3, double c1, double c2, double c3)
 102 {
 103     return a1 * determinant2x2(b2, b3, c2, c3)
 104          - b1 * determinant2x2(a2, a3, c2, c3)
 105          + c1 * determinant2x2(a2, a3, b2, b3);
 106 }
 107 
 108 //  double = determinant4x4(matrix)
 109 //
 110 //  calculate the determinant of a 4x4 matrix.
 111 
 112 static double determinant4x4(const TransformationMatrix::Matrix4&amp; m)
 113 {
 114     // Assign to individual variable names to aid selecting
 115     // correct elements
 116 
 117     double a1 = m[0][0];
 118     double b1 = m[0][1];
 119     double c1 = m[0][2];
 120     double d1 = m[0][3];
 121 
 122     double a2 = m[1][0];
 123     double b2 = m[1][1];
 124     double c2 = m[1][2];
 125     double d2 = m[1][3];
 126 
 127     double a3 = m[2][0];
 128     double b3 = m[2][1];
 129     double c3 = m[2][2];
 130     double d3 = m[2][3];
 131 
 132     double a4 = m[3][0];
 133     double b4 = m[3][1];
 134     double c4 = m[3][2];
 135     double d4 = m[3][3];
 136 
 137     return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4)
 138          - b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4)
 139          + c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4)
 140          - d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
 141 }
 142 
 143 // adjoint( original_matrix, inverse_matrix )
 144 //
 145 //   calculate the adjoint of a 4x4 matrix
 146 //
 147 //    Let  a   denote the minor determinant of matrix A obtained by
 148 //         ij
 149 //
 150 //    deleting the ith row and jth column from A.
 151 //
 152 //                  i+j
 153 //   Let  b   = (-1)    a
 154 //        ij            ji
 155 //
 156 //  The matrix B = (b  ) is the adjoint of A
 157 //                   ij
 158 
 159 static void adjoint(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Matrix4&amp; result)
 160 {
 161     // Assign to individual variable names to aid
 162     // selecting correct values
 163     double a1 = matrix[0][0];
 164     double b1 = matrix[0][1];
 165     double c1 = matrix[0][2];
 166     double d1 = matrix[0][3];
 167 
 168     double a2 = matrix[1][0];
 169     double b2 = matrix[1][1];
 170     double c2 = matrix[1][2];
 171     double d2 = matrix[1][3];
 172 
 173     double a3 = matrix[2][0];
 174     double b3 = matrix[2][1];
 175     double c3 = matrix[2][2];
 176     double d3 = matrix[2][3];
 177 
 178     double a4 = matrix[3][0];
 179     double b4 = matrix[3][1];
 180     double c4 = matrix[3][2];
 181     double d4 = matrix[3][3];
 182 
 183     // Row column labeling reversed since we transpose rows &amp; columns
 184     result[0][0]  =   determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
 185     result[1][0]  = - determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
 186     result[2][0]  =   determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
 187     result[3][0]  = - determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
 188 
 189     result[0][1]  = - determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
 190     result[1][1]  =   determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
 191     result[2][1]  = - determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
 192     result[3][1]  =   determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
 193 
 194     result[0][2]  =   determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
 195     result[1][2]  = - determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
 196     result[2][2]  =   determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
 197     result[3][2]  = - determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
 198 
 199     result[0][3]  = - determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
 200     result[1][3]  =   determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
 201     result[2][3]  = - determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
 202     result[3][3]  =   determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
 203 }
 204 
 205 // Returns false if the matrix is not invertible
 206 static bool inverse(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Matrix4&amp; result)
 207 {
 208     // Calculate the adjoint matrix
 209     adjoint(matrix, result);
 210 
 211     // Calculate the 4x4 determinant
 212     // If the determinant is zero,
 213     // then the inverse matrix is not unique.
 214     double det = determinant4x4(matrix);
 215 
 216     if (fabs(det) &lt; SMALL_NUMBER)
 217         return false;
 218 
 219     // Scale the adjoint matrix to get the inverse
 220 
 221     for (int i = 0; i &lt; 4; i++)
 222         for (int j = 0; j &lt; 4; j++)
 223             result[i][j] = result[i][j] / det;
 224 
 225     return true;
 226 }
 227 
 228 // End of code adapted from Matrix Inversion by Richard Carling
 229 
 230 // Perform a decomposition on the passed matrix, return false if unsuccessful
 231 // From Graphics Gems: unmatrix.c
 232 
 233 // Transpose rotation portion of matrix a, return b
 234 static void transposeMatrix4(const TransformationMatrix::Matrix4&amp; a, TransformationMatrix::Matrix4&amp; b)
 235 {
 236     for (int i = 0; i &lt; 4; i++)
 237         for (int j = 0; j &lt; 4; j++)
 238             b[i][j] = a[j][i];
 239 }
 240 
 241 // Multiply a homogeneous point by a matrix and return the transformed point
 242 static void v4MulPointByMatrix(const Vector4 p, const TransformationMatrix::Matrix4&amp; m, Vector4 result)
 243 {
 244     result[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +
 245                 (p[2] * m[2][0]) + (p[3] * m[3][0]);
 246     result[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +
 247                 (p[2] * m[2][1]) + (p[3] * m[3][1]);
 248     result[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +
 249                 (p[2] * m[2][2]) + (p[3] * m[3][2]);
 250     result[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +
 251                 (p[2] * m[2][3]) + (p[3] * m[3][3]);
 252 }
 253 
 254 static double v3Length(Vector3 a)
 255 {
 256     return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));
 257 }
 258 
 259 static void v3Scale(Vector3 v, double desiredLength)
 260 {
 261     double len = v3Length(v);
 262     if (len != 0) {
 263         double l = desiredLength / len;
 264         v[0] *= l;
 265         v[1] *= l;
 266         v[2] *= l;
 267     }
 268 }
 269 
 270 static double v3Dot(const Vector3 a, const Vector3 b)
 271 {
 272     return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
 273 }
 274 
 275 // Make a linear combination of two vectors and return the result.
 276 // result = (a * ascl) + (b * bscl)
 277 static void v3Combine(const Vector3 a, const Vector3 b, Vector3 result, double ascl, double bscl)
 278 {
 279     result[0] = (ascl * a[0]) + (bscl * b[0]);
 280     result[1] = (ascl * a[1]) + (bscl * b[1]);
 281     result[2] = (ascl * a[2]) + (bscl * b[2]);
 282 }
 283 
 284 // Return the cross product result = a cross b */
 285 static void v3Cross(const Vector3 a, const Vector3 b, Vector3 result)
 286 {
 287     result[0] = (a[1] * b[2]) - (a[2] * b[1]);
 288     result[1] = (a[2] * b[0]) - (a[0] * b[2]);
 289     result[2] = (a[0] * b[1]) - (a[1] * b[0]);
 290 }
 291 
 292 static bool decompose2(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Decomposed2Type&amp; result)
 293 {
 294     double row0x = matrix[0][0];
 295     double row0y = matrix[0][1];
 296     double row1x = matrix[1][0];
 297     double row1y = matrix[1][1];
 298     result.translateX = matrix[3][0];
 299     result.translateY = matrix[3][1];
 300 
 301     // Compute scaling factors.
 302     result.scaleX = sqrt(row0x * row0x + row0y * row0y);
 303     result.scaleY = sqrt(row1x * row1x + row1y * row1y);
 304 
 305     // If determinant is negative, one axis was flipped.
 306     double determinant = row0x * row1y - row0y * row1x;
 307     if (determinant &lt; 0) {
 308         // Flip axis with minimum unit vector dot product.
 309         if (row0x &lt; row1y)
 310             result.scaleX = -result.scaleX;
 311         else
 312             result.scaleY = -result.scaleY;
 313     }
 314 
 315     // Renormalize matrix to remove scale.
 316     if (result.scaleX) {
 317         row0x *= 1 / result.scaleX;
 318         row0y *= 1 / result.scaleX;
 319     }
 320     if (result.scaleY) {
 321         row1x *= 1 / result.scaleY;
 322         row1y *= 1 / result.scaleY;
 323     }
 324 
 325     // Compute rotation and renormalize matrix.
 326     result.angle = atan2(row0y, row0x);
 327 
 328     if (result.angle) {
 329         // Rotate(-angle) = [cos(angle), sin(angle), -sin(angle), cos(angle)]
 330         //                = [row0x, -row0y, row0y, row0x]
 331         // Thanks to the normalization above.
 332         double sn = -row0y;
 333         double cs = row0x;
 334         double m11 = row0x, m12 = row0y;
 335         double m21 = row1x, m22 = row1y;
 336 
 337         row0x = cs * m11 + sn * m21;
 338         row0y = cs * m12 + sn * m22;
 339         row1x = -sn * m11 + cs * m21;
 340         row1y = -sn * m12 + cs * m22;
 341     }
 342 
 343     result.m11 = row0x;
 344     result.m12 = row0y;
 345     result.m21 = row1x;
 346     result.m22 = row1y;
 347 
 348     // Convert into degrees because our rotation functions expect it.
 349     result.angle = rad2deg(result.angle);
 350 
 351     return true;
 352 }
 353 
 354 static bool decompose4(const TransformationMatrix::Matrix4&amp; mat, TransformationMatrix::Decomposed4Type&amp; result)
 355 {
 356     TransformationMatrix::Matrix4 localMatrix;
 357     memcpy(localMatrix, mat, sizeof(TransformationMatrix::Matrix4));
 358 
 359     // Normalize the matrix.
 360     if (localMatrix[3][3] == 0)
 361         return false;
 362 
 363     int i, j;
 364     for (i = 0; i &lt; 4; i++)
 365         for (j = 0; j &lt; 4; j++)
 366             localMatrix[i][j] /= localMatrix[3][3];
 367 
 368     // perspectiveMatrix is used to solve for perspective, but it also provides
 369     // an easy way to test for singularity of the upper 3x3 component.
 370     TransformationMatrix::Matrix4 perspectiveMatrix;
 371     memcpy(perspectiveMatrix, localMatrix, sizeof(TransformationMatrix::Matrix4));
 372     for (i = 0; i &lt; 3; i++)
 373         perspectiveMatrix[i][3] = 0;
 374     perspectiveMatrix[3][3] = 1;
 375 
 376     if (determinant4x4(perspectiveMatrix) == 0)
 377         return false;
 378 
 379     // First, isolate perspective. This is the messiest.
 380     if (localMatrix[0][3] != 0 || localMatrix[1][3] != 0 || localMatrix[2][3] != 0) {
 381         // rightHandSide is the right hand side of the equation.
 382         Vector4 rightHandSide;
 383         rightHandSide[0] = localMatrix[0][3];
 384         rightHandSide[1] = localMatrix[1][3];
 385         rightHandSide[2] = localMatrix[2][3];
 386         rightHandSide[3] = localMatrix[3][3];
 387 
 388         // Solve the equation by inverting perspectiveMatrix and multiplying
 389         // rightHandSide by the inverse. (This is the easiest way, not
 390         // necessarily the best.)
 391         TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;
 392         inverse(perspectiveMatrix, inversePerspectiveMatrix);
 393         transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);
 394 
 395         Vector4 perspectivePoint;
 396         v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspectivePoint);
 397 
 398         result.perspectiveX = perspectivePoint[0];
 399         result.perspectiveY = perspectivePoint[1];
 400         result.perspectiveZ = perspectivePoint[2];
 401         result.perspectiveW = perspectivePoint[3];
 402 
 403         // Clear the perspective partition
 404         localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;
 405         localMatrix[3][3] = 1;
 406     } else {
 407         // No perspective.
 408         result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;
 409         result.perspectiveW = 1;
 410     }
 411 
 412     // Next take care of translation (easy).
 413     result.translateX = localMatrix[3][0];
 414     localMatrix[3][0] = 0;
 415     result.translateY = localMatrix[3][1];
 416     localMatrix[3][1] = 0;
 417     result.translateZ = localMatrix[3][2];
 418     localMatrix[3][2] = 0;
 419 
 420     // Vector4 type and functions need to be added to the common set.
 421     Vector3 row[3], pdum3;
 422 
 423     // Now get scale and shear.
 424     for (i = 0; i &lt; 3; i++) {
 425         row[i][0] = localMatrix[i][0];
 426         row[i][1] = localMatrix[i][1];
 427         row[i][2] = localMatrix[i][2];
 428     }
 429 
 430     // Compute X scale factor and normalize first row.
 431     result.scaleX = v3Length(row[0]);
 432     v3Scale(row[0], 1.0);
 433 
 434     // Compute XY shear factor and make 2nd row orthogonal to 1st.
 435     result.skewXY = v3Dot(row[0], row[1]);
 436     v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);
 437 
 438     // Now, compute Y scale and normalize 2nd row.
 439     result.scaleY = v3Length(row[1]);
 440     v3Scale(row[1], 1.0);
 441     result.skewXY /= result.scaleY;
 442 
 443     // Compute XZ and YZ shears, orthogonalize 3rd row.
 444     result.skewXZ = v3Dot(row[0], row[2]);
 445     v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);
 446     result.skewYZ = v3Dot(row[1], row[2]);
 447     v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);
 448 
 449     // Next, get Z scale and normalize 3rd row.
 450     result.scaleZ = v3Length(row[2]);
 451     v3Scale(row[2], 1.0);
 452     result.skewXZ /= result.scaleZ;
 453     result.skewYZ /= result.scaleZ;
 454 
 455     // At this point, the matrix (in rows[]) is orthonormal.
 456     // Check for a coordinate system flip. If the determinant
 457     // is -1, then negate the matrix and the scaling factors.
 458     v3Cross(row[1], row[2], pdum3);
 459     if (v3Dot(row[0], pdum3) &lt; 0) {
 460 
 461         result.scaleX *= -1;
 462         result.scaleY *= -1;
 463         result.scaleZ *= -1;
 464 
 465         for (i = 0; i &lt; 3; i++) {
 466             row[i][0] *= -1;
 467             row[i][1] *= -1;
 468             row[i][2] *= -1;
 469         }
 470     }
 471 
 472     // Now, get the rotations out, as described in the gem.
 473 
 474     // FIXME - Add the ability to return either quaternions (which are
 475     // easier to recompose with) or Euler angles (rx, ry, rz), which
 476     // are easier for authors to deal with. The latter will only be useful
 477     // when we fix https://bugs.webkit.org/show_bug.cgi?id=23799, so I
 478     // will leave the Euler angle code here for now.
 479 
 480     // ret.rotateY = asin(-row[0][2]);
 481     // if (cos(ret.rotateY) != 0) {
 482     //     ret.rotateX = atan2(row[1][2], row[2][2]);
 483     //     ret.rotateZ = atan2(row[0][1], row[0][0]);
 484     // } else {
 485     //     ret.rotateX = atan2(-row[2][0], row[1][1]);
 486     //     ret.rotateZ = 0;
 487     // }
 488 
 489     double s, t, x, y, z, w;
 490 
 491     t = row[0][0] + row[1][1] + row[2][2] + 1.0;
 492 
 493     if (t &gt; 1e-4) {
 494         s = 0.5 / sqrt(t);
 495         w = 0.25 / s;
 496         x = (row[2][1] - row[1][2]) * s;
 497         y = (row[0][2] - row[2][0]) * s;
 498         z = (row[1][0] - row[0][1]) * s;
 499     } else if (row[0][0] &gt; row[1][1] &amp;&amp; row[0][0] &gt; row[2][2]) {
 500         s = sqrt(1.0 + row[0][0] - row[1][1] - row[2][2]) * 2.0; // S = 4 * qx.
 501         x = 0.25 * s;
 502         y = (row[0][1] + row[1][0]) / s;
 503         z = (row[0][2] + row[2][0]) / s;
 504         w = (row[2][1] - row[1][2]) / s;
 505     } else if (row[1][1] &gt; row[2][2]) {
 506         s = sqrt(1.0 + row[1][1] - row[0][0] - row[2][2]) * 2.0; // S = 4 * qy.
 507         x = (row[0][1] + row[1][0]) / s;
 508         y = 0.25 * s;
 509         z = (row[1][2] + row[2][1]) / s;
 510         w = (row[0][2] - row[2][0]) / s;
 511     } else {
 512         s = sqrt(1.0 + row[2][2] - row[0][0] - row[1][1]) * 2.0; // S = 4 * qz.
 513         x = (row[0][2] + row[2][0]) / s;
 514         y = (row[1][2] + row[2][1]) / s;
 515         z = 0.25 * s;
 516         w = (row[1][0] - row[0][1]) / s;
 517     }
 518 
 519     result.quaternionX = x;
 520     result.quaternionY = y;
 521     result.quaternionZ = z;
 522     result.quaternionW = w;
 523 
 524     return true;
 525 }
 526 
 527 // Perform a spherical linear interpolation between the two
 528 // passed quaternions with 0 &lt;= t &lt;= 1.
 529 static void slerp(double qa[4], const double qb[4], double t)
 530 {
 531     double ax, ay, az, aw;
 532     double bx, by, bz, bw;
 533     double cx, cy, cz, cw;
 534     double angle;
 535     double th, invth, scale, invscale;
 536 
 537     ax = qa[0]; ay = qa[1]; az = qa[2]; aw = qa[3];
 538     bx = qb[0]; by = qb[1]; bz = qb[2]; bw = qb[3];
 539 
 540     angle = ax * bx + ay * by + az * bz + aw * bw;
 541 
 542     if (angle &lt; 0.0) {
 543         ax = -ax; ay = -ay;
 544         az = -az; aw = -aw;
 545         angle = -angle;
 546     }
 547 
 548     if (angle + 1.0 &gt; .05) {
 549         if (1.0 - angle &gt;= .05) {
 550             th = acos (angle);
 551             invth = 1.0 / sin (th);
 552             scale = sin (th * (1.0 - t)) * invth;
 553             invscale = sin (th * t) * invth;
 554         } else {
 555             scale = 1.0 - t;
 556             invscale = t;
 557         }
 558     } else {
 559         bx = -ay;
 560         by = ax;
 561         bz = -aw;
 562         bw = az;
 563         scale = sin(piDouble * (.5 - t));
 564         invscale = sin (piDouble * t);
 565     }
 566 
 567     cx = ax * scale + bx * invscale;
 568     cy = ay * scale + by * invscale;
 569     cz = az * scale + bz * invscale;
 570     cw = aw * scale + bw * invscale;
 571 
 572     qa[0] = cx; qa[1] = cy; qa[2] = cz; qa[3] = cw;
 573 }
 574 
 575 // End of Supporting Math Functions
 576 
 577 TransformationMatrix::TransformationMatrix(const AffineTransform&amp; t)
 578 {
 579     setMatrix(t.a(), t.b(), t.c(), t.d(), t.e(), t.f());
 580 }
 581 
 582 TransformationMatrix&amp; TransformationMatrix::scale(double s)
 583 {
 584     return scaleNonUniform(s, s);
 585 }
 586 
 587 TransformationMatrix&amp; TransformationMatrix::rotateFromVector(double x, double y)
 588 {
 589     return rotate(rad2deg(atan2(y, x)));
 590 }
 591 
 592 TransformationMatrix&amp; TransformationMatrix::flipX()
 593 {
 594     return scaleNonUniform(-1.0, 1.0);
 595 }
 596 
 597 TransformationMatrix&amp; TransformationMatrix::flipY()
 598 {
 599     return scaleNonUniform(1.0, -1.0);
 600 }
 601 
 602 FloatPoint TransformationMatrix::projectPoint(const FloatPoint&amp; p, bool* clamped) const
 603 {
 604     // This is basically raytracing. We have a point in the destination
 605     // plane with z=0, and we cast a ray parallel to the z-axis from that
 606     // point to find the z-position at which it intersects the z=0 plane
 607     // with the transform applied. Once we have that point we apply the
 608     // inverse transform to find the corresponding point in the source
 609     // space.
 610     //
 611     // Given a plane with normal Pn, and a ray starting at point R0 and
 612     // with direction defined by the vector Rd, we can find the
 613     // intersection point as a distance d from R0 in units of Rd by:
 614     //
 615     // d = -dot (Pn&#39;, R0) / dot (Pn&#39;, Rd)
 616     if (clamped)
 617         *clamped = false;
 618 
 619     if (m33() == 0) {
 620         // In this case, the projection plane is parallel to the ray we are trying to
 621         // trace, and there is no well-defined value for the projection.
 622         return FloatPoint();
 623     }
 624 
 625     double x = p.x();
 626     double y = p.y();
 627     double z = -(m13() * x + m23() * y + m43()) / m33();
 628 
 629     // FIXME: use multVecMatrix()
 630     double outX = x * m11() + y * m21() + z * m31() + m41();
 631     double outY = x * m12() + y * m22() + z * m32() + m42();
 632 
 633     double w = x * m14() + y * m24() + z * m34() + m44();
 634     if (w &lt;= 0) {
 635         // Using int max causes overflow when other code uses the projected point. To
 636         // represent infinity yet reduce the risk of overflow, we use a large but
 637         // not-too-large number here when clamping.
 638         const int largeNumber = 100000000 / kFixedPointDenominator;
 639         outX = copysign(largeNumber, outX);
 640         outY = copysign(largeNumber, outY);
 641         if (clamped)
 642             *clamped = true;
 643     } else if (w != 1) {
 644         outX /= w;
 645         outY /= w;
 646     }
 647 
 648     return FloatPoint(static_cast&lt;float&gt;(outX), static_cast&lt;float&gt;(outY));
 649 }
 650 
 651 FloatQuad TransformationMatrix::projectQuad(const FloatQuad&amp; q, bool* clamped) const
 652 {
 653     FloatQuad projectedQuad;
 654 
 655     bool clamped1 = false;
 656     bool clamped2 = false;
 657     bool clamped3 = false;
 658     bool clamped4 = false;
 659 
 660     projectedQuad.setP1(projectPoint(q.p1(), &amp;clamped1));
 661     projectedQuad.setP2(projectPoint(q.p2(), &amp;clamped2));
 662     projectedQuad.setP3(projectPoint(q.p3(), &amp;clamped3));
 663     projectedQuad.setP4(projectPoint(q.p4(), &amp;clamped4));
 664 
 665     if (clamped)
 666         *clamped = clamped1 || clamped2 || clamped3 || clamped4;
 667 
 668     // If all points on the quad had w &lt; 0, then the entire quad would not be visible to the projected surface.
 669     bool everythingWasClipped = clamped1 &amp;&amp; clamped2 &amp;&amp; clamped3 &amp;&amp; clamped4;
 670     if (everythingWasClipped)
 671         return FloatQuad();
 672 
 673     return projectedQuad;
 674 }
 675 
 676 static float clampEdgeValue(float f)
 677 {
 678     ASSERT(!std::isnan(f));
 679     return std::min&lt;float&gt;(std::max&lt;float&gt;(f, -LayoutUnit::max() / 2), LayoutUnit::max() / 2);
 680 }
 681 
 682 LayoutRect TransformationMatrix::clampedBoundsOfProjectedQuad(const FloatQuad&amp; q) const
 683 {
 684     FloatRect mappedQuadBounds = projectQuad(q).boundingBox();
 685 
 686     float left = clampEdgeValue(floorf(mappedQuadBounds.x()));
 687     float top = clampEdgeValue(floorf(mappedQuadBounds.y()));
 688 
 689     float right;
 690     if (std::isinf(mappedQuadBounds.x()) &amp;&amp; std::isinf(mappedQuadBounds.width()))
 691         right = LayoutUnit::max() / 2;
 692     else
 693         right = clampEdgeValue(ceilf(mappedQuadBounds.maxX()));
 694 
 695     float bottom;
 696     if (std::isinf(mappedQuadBounds.y()) &amp;&amp; std::isinf(mappedQuadBounds.height()))
 697         bottom = LayoutUnit::max() / 2;
 698     else
 699         bottom = clampEdgeValue(ceilf(mappedQuadBounds.maxY()));
 700 
 701     return LayoutRect(LayoutUnit::clamp(left), LayoutUnit::clamp(top),  LayoutUnit::clamp(right - left), LayoutUnit::clamp(bottom - top));
 702 }
 703 
 704 void TransformationMatrix::map4ComponentPoint(double&amp; x, double&amp; y, double&amp; z, double&amp; w) const
 705 {
 706     if (isIdentityOrTranslation()) {
 707         x += m_matrix[3][0];
 708         y += m_matrix[3][1];
 709         z += m_matrix[3][2];
 710         return;
 711     }
 712 
 713     Vector4 input = { x, y, z, w };
 714     Vector4 result;
 715     v4MulPointByMatrix(input, m_matrix, result);
 716 
 717     x = result[0];
 718     y = result[1];
 719     z = result[2];
 720     w = result[3];
 721 }
 722 
 723 FloatPoint TransformationMatrix::mapPoint(const FloatPoint&amp; p) const
 724 {
 725     if (isIdentityOrTranslation())
 726         return FloatPoint(p.x() + static_cast&lt;float&gt;(m_matrix[3][0]), p.y() + static_cast&lt;float&gt;(m_matrix[3][1]));
 727 
 728     return internalMapPoint(p);
 729 }
 730 
 731 FloatPoint3D TransformationMatrix::mapPoint(const FloatPoint3D&amp; p) const
 732 {
 733     if (isIdentityOrTranslation())
 734         return FloatPoint3D(p.x() + static_cast&lt;float&gt;(m_matrix[3][0]),
 735                             p.y() + static_cast&lt;float&gt;(m_matrix[3][1]),
 736                             p.z() + static_cast&lt;float&gt;(m_matrix[3][2]));
 737 
 738     return internalMapPoint(p);
 739 }
 740 
 741 IntRect TransformationMatrix::mapRect(const IntRect &amp;rect) const
 742 {
 743     return enclosingIntRect(mapRect(FloatRect(rect)));
 744 }
 745 
 746 LayoutRect TransformationMatrix::mapRect(const LayoutRect&amp; r) const
 747 {
 748     return enclosingLayoutRect(mapRect(FloatRect(r)));
 749 }
 750 
 751 FloatRect TransformationMatrix::mapRect(const FloatRect&amp; r) const
 752 {
 753     if (isIdentityOrTranslation()) {
 754         FloatRect mappedRect(r);
 755         mappedRect.move(static_cast&lt;float&gt;(m_matrix[3][0]), static_cast&lt;float&gt;(m_matrix[3][1]));
 756         return mappedRect;
 757     }
 758 
 759     FloatQuad result;
 760 
 761     float maxX = r.maxX();
 762     float maxY = r.maxY();
 763     result.setP1(internalMapPoint(FloatPoint(r.x(), r.y())));
 764     result.setP2(internalMapPoint(FloatPoint(maxX, r.y())));
 765     result.setP3(internalMapPoint(FloatPoint(maxX, maxY)));
 766     result.setP4(internalMapPoint(FloatPoint(r.x(), maxY)));
 767 
 768     return result.boundingBox();
 769 }
 770 
 771 FloatQuad TransformationMatrix::mapQuad(const FloatQuad&amp; q) const
 772 {
 773     if (isIdentityOrTranslation()) {
 774         FloatQuad mappedQuad(q);
 775         mappedQuad.move(static_cast&lt;float&gt;(m_matrix[3][0]), static_cast&lt;float&gt;(m_matrix[3][1]));
 776         return mappedQuad;
 777     }
 778 
 779     FloatQuad result;
 780     result.setP1(internalMapPoint(q.p1()));
 781     result.setP2(internalMapPoint(q.p2()));
 782     result.setP3(internalMapPoint(q.p3()));
 783     result.setP4(internalMapPoint(q.p4()));
 784     return result;
 785 }
 786 
 787 TransformationMatrix&amp; TransformationMatrix::scaleNonUniform(double sx, double sy)
 788 {
 789     m_matrix[0][0] *= sx;
 790     m_matrix[0][1] *= sx;
 791     m_matrix[0][2] *= sx;
 792     m_matrix[0][3] *= sx;
 793 
 794     m_matrix[1][0] *= sy;
 795     m_matrix[1][1] *= sy;
 796     m_matrix[1][2] *= sy;
 797     m_matrix[1][3] *= sy;
 798     return *this;
 799 }
 800 
 801 TransformationMatrix&amp; TransformationMatrix::scale3d(double sx, double sy, double sz)
 802 {
 803     scaleNonUniform(sx, sy);
 804 
 805     m_matrix[2][0] *= sz;
 806     m_matrix[2][1] *= sz;
 807     m_matrix[2][2] *= sz;
 808     m_matrix[2][3] *= sz;
 809     return *this;
 810 }
 811 
 812 TransformationMatrix&amp; TransformationMatrix::rotate3d(double x, double y, double z, double angle)
 813 {
 814     // Normalize the axis of rotation
 815     double length = sqrt(x * x + y * y + z * z);
 816     if (length == 0) {
 817         // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
 818         return *this;
 819     } else if (length != 1) {
 820         x /= length;
 821         y /= length;
 822         z /= length;
 823     }
 824 
 825     // Angles are in degrees. Switch to radians.
 826     angle = deg2rad(angle);
 827 
 828     double sinTheta = sin(angle);
 829     double cosTheta = cos(angle);
 830 
 831     TransformationMatrix mat;
 832 
 833     // Optimize cases where the axis is along a major axis
 834     if (x == 1.0 &amp;&amp; y == 0.0 &amp;&amp; z == 0.0) {
 835         mat.m_matrix[0][0] = 1.0;
 836         mat.m_matrix[0][1] = 0.0;
 837         mat.m_matrix[0][2] = 0.0;
 838         mat.m_matrix[1][0] = 0.0;
 839         mat.m_matrix[1][1] = cosTheta;
 840         mat.m_matrix[1][2] = sinTheta;
 841         mat.m_matrix[2][0] = 0.0;
 842         mat.m_matrix[2][1] = -sinTheta;
 843         mat.m_matrix[2][2] = cosTheta;
 844         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 845         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 846         mat.m_matrix[3][3] = 1.0;
 847     } else if (x == 0.0 &amp;&amp; y == 1.0 &amp;&amp; z == 0.0) {
 848         mat.m_matrix[0][0] = cosTheta;
 849         mat.m_matrix[0][1] = 0.0;
 850         mat.m_matrix[0][2] = -sinTheta;
 851         mat.m_matrix[1][0] = 0.0;
 852         mat.m_matrix[1][1] = 1.0;
 853         mat.m_matrix[1][2] = 0.0;
 854         mat.m_matrix[2][0] = sinTheta;
 855         mat.m_matrix[2][1] = 0.0;
 856         mat.m_matrix[2][2] = cosTheta;
 857         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 858         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 859         mat.m_matrix[3][3] = 1.0;
 860     } else if (x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; z == 1.0) {
 861         mat.m_matrix[0][0] = cosTheta;
 862         mat.m_matrix[0][1] = sinTheta;
 863         mat.m_matrix[0][2] = 0.0;
 864         mat.m_matrix[1][0] = -sinTheta;
 865         mat.m_matrix[1][1] = cosTheta;
 866         mat.m_matrix[1][2] = 0.0;
 867         mat.m_matrix[2][0] = 0.0;
 868         mat.m_matrix[2][1] = 0.0;
 869         mat.m_matrix[2][2] = 1.0;
 870         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 871         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 872         mat.m_matrix[3][3] = 1.0;
 873     } else {
 874         // This case is the rotation about an arbitrary unit vector.
 875         //
 876         // Formula is adapted from Wikipedia article on Rotation matrix,
 877         // http://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
 878         //
 879         // An alternate resource with the same matrix: http://www.fastgraph.com/makegames/3drotation/
 880         //
 881         double oneMinusCosTheta = 1 - cosTheta;
 882         mat.m_matrix[0][0] = cosTheta + x * x * oneMinusCosTheta;
 883         mat.m_matrix[0][1] = y * x * oneMinusCosTheta + z * sinTheta;
 884         mat.m_matrix[0][2] = z * x * oneMinusCosTheta - y * sinTheta;
 885         mat.m_matrix[1][0] = x * y * oneMinusCosTheta - z * sinTheta;
 886         mat.m_matrix[1][1] = cosTheta + y * y * oneMinusCosTheta;
 887         mat.m_matrix[1][2] = z * y * oneMinusCosTheta + x * sinTheta;
 888         mat.m_matrix[2][0] = x * z * oneMinusCosTheta + y * sinTheta;
 889         mat.m_matrix[2][1] = y * z * oneMinusCosTheta - x * sinTheta;
 890         mat.m_matrix[2][2] = cosTheta + z * z * oneMinusCosTheta;
 891         mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 892         mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 893         mat.m_matrix[3][3] = 1.0;
 894     }
 895     multiply(mat);
 896     return *this;
 897 }
 898 
 899 TransformationMatrix&amp; TransformationMatrix::rotate3d(double rx, double ry, double rz)
 900 {
 901     // Angles are in degrees. Switch to radians.
 902     rx = deg2rad(rx);
 903     ry = deg2rad(ry);
 904     rz = deg2rad(rz);
 905 
 906     TransformationMatrix mat;
 907 
 908     double sinTheta = sin(rz);
 909     double cosTheta = cos(rz);
 910 
 911     mat.m_matrix[0][0] = cosTheta;
 912     mat.m_matrix[0][1] = sinTheta;
 913     mat.m_matrix[0][2] = 0.0;
 914     mat.m_matrix[1][0] = -sinTheta;
 915     mat.m_matrix[1][1] = cosTheta;
 916     mat.m_matrix[1][2] = 0.0;
 917     mat.m_matrix[2][0] = 0.0;
 918     mat.m_matrix[2][1] = 0.0;
 919     mat.m_matrix[2][2] = 1.0;
 920     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 921     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 922     mat.m_matrix[3][3] = 1.0;
 923 
 924     TransformationMatrix rmat(mat);
 925 
 926     sinTheta = sin(ry);
 927     cosTheta = cos(ry);
 928 
 929     mat.m_matrix[0][0] = cosTheta;
 930     mat.m_matrix[0][1] = 0.0;
 931     mat.m_matrix[0][2] = -sinTheta;
 932     mat.m_matrix[1][0] = 0.0;
 933     mat.m_matrix[1][1] = 1.0;
 934     mat.m_matrix[1][2] = 0.0;
 935     mat.m_matrix[2][0] = sinTheta;
 936     mat.m_matrix[2][1] = 0.0;
 937     mat.m_matrix[2][2] = cosTheta;
 938     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 939     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 940     mat.m_matrix[3][3] = 1.0;
 941 
 942     rmat.multiply(mat);
 943 
 944     sinTheta = sin(rx);
 945     cosTheta = cos(rx);
 946 
 947     mat.m_matrix[0][0] = 1.0;
 948     mat.m_matrix[0][1] = 0.0;
 949     mat.m_matrix[0][2] = 0.0;
 950     mat.m_matrix[1][0] = 0.0;
 951     mat.m_matrix[1][1] = cosTheta;
 952     mat.m_matrix[1][2] = sinTheta;
 953     mat.m_matrix[2][0] = 0.0;
 954     mat.m_matrix[2][1] = -sinTheta;
 955     mat.m_matrix[2][2] = cosTheta;
 956     mat.m_matrix[0][3] = mat.m_matrix[1][3] = mat.m_matrix[2][3] = 0.0;
 957     mat.m_matrix[3][0] = mat.m_matrix[3][1] = mat.m_matrix[3][2] = 0.0;
 958     mat.m_matrix[3][3] = 1.0;
 959 
 960     rmat.multiply(mat);
 961 
 962     multiply(rmat);
 963     return *this;
 964 }
 965 
 966 TransformationMatrix&amp; TransformationMatrix::translate(double tx, double ty)
 967 {
 968     m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0];
 969     m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1];
 970     m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2];
 971     m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3];
 972     return *this;
 973 }
 974 
 975 TransformationMatrix&amp; TransformationMatrix::translate3d(double tx, double ty, double tz)
 976 {
 977     m_matrix[3][0] += tx * m_matrix[0][0] + ty * m_matrix[1][0] + tz * m_matrix[2][0];
 978     m_matrix[3][1] += tx * m_matrix[0][1] + ty * m_matrix[1][1] + tz * m_matrix[2][1];
 979     m_matrix[3][2] += tx * m_matrix[0][2] + ty * m_matrix[1][2] + tz * m_matrix[2][2];
 980     m_matrix[3][3] += tx * m_matrix[0][3] + ty * m_matrix[1][3] + tz * m_matrix[2][3];
 981     return *this;
 982 }
 983 
 984 TransformationMatrix&amp; TransformationMatrix::translateRight(double tx, double ty)
 985 {
 986     if (tx != 0) {
 987         m_matrix[0][0] +=  m_matrix[0][3] * tx;
 988         m_matrix[1][0] +=  m_matrix[1][3] * tx;
 989         m_matrix[2][0] +=  m_matrix[2][3] * tx;
 990         m_matrix[3][0] +=  m_matrix[3][3] * tx;
 991     }
 992 
 993     if (ty != 0) {
 994         m_matrix[0][1] +=  m_matrix[0][3] * ty;
 995         m_matrix[1][1] +=  m_matrix[1][3] * ty;
 996         m_matrix[2][1] +=  m_matrix[2][3] * ty;
 997         m_matrix[3][1] +=  m_matrix[3][3] * ty;
 998     }
 999 
1000     return *this;
1001 }
1002 
1003 TransformationMatrix&amp; TransformationMatrix::translateRight3d(double tx, double ty, double tz)
1004 {
1005     translateRight(tx, ty);
1006     if (tz != 0) {
1007         m_matrix[0][2] +=  m_matrix[0][3] * tz;
1008         m_matrix[1][2] +=  m_matrix[1][3] * tz;
1009         m_matrix[2][2] +=  m_matrix[2][3] * tz;
1010         m_matrix[3][2] +=  m_matrix[3][3] * tz;
1011     }
1012 
1013     return *this;
1014 }
1015 
1016 TransformationMatrix&amp; TransformationMatrix::skew(double sx, double sy)
1017 {
1018     // angles are in degrees. Switch to radians
1019     sx = deg2rad(sx);
1020     sy = deg2rad(sy);
1021 
1022     TransformationMatrix mat;
1023     mat.m_matrix[0][1] = tan(sy); // note that the y shear goes in the first row
1024     mat.m_matrix[1][0] = tan(sx); // and the x shear in the second row
1025 
1026     multiply(mat);
1027     return *this;
1028 }
1029 
1030 TransformationMatrix&amp; TransformationMatrix::applyPerspective(double p)
1031 {
1032     TransformationMatrix mat;
1033     if (p != 0)
1034         mat.m_matrix[2][3] = -1/p;
1035 
1036     multiply(mat);
1037     return *this;
1038 }
1039 
1040 TransformationMatrix TransformationMatrix::rectToRect(const FloatRect&amp; from, const FloatRect&amp; to)
1041 {
1042     ASSERT(!from.isEmpty());
1043     return TransformationMatrix(to.width() / from.width(),
1044                                 0, 0,
1045                                 to.height() / from.height(),
1046                                 to.x() - from.x(),
1047                                 to.y() - from.y());
1048 }
1049 
1050 // this = mat * this.
1051 TransformationMatrix&amp; TransformationMatrix::multiply(const TransformationMatrix&amp; mat)
1052 {
1053 #if CPU(ARM64) &amp;&amp; defined(_LP64)
1054     double* leftMatrix = &amp;(m_matrix[0][0]);
1055     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1056     asm volatile (
1057         // First, load the leftMatrix completely in memory. The leftMatrix is in v16-v23.
1058         &quot;mov   x4, %[leftMatrix]\n\t&quot;
1059         &quot;ld1   {v16.2d, v17.2d, v18.2d, v19.2d}, [%[leftMatrix]], #64\n\t&quot;
1060         &quot;ld1   {v20.2d, v21.2d, v22.2d, v23.2d}, [%[leftMatrix]]\n\t&quot;
1061 
1062         // First row.
1063         &quot;ld4r  {v24.2d, v25.2d, v26.2d, v27.2d}, [%[rightMatrix]], #32\n\t&quot;
1064         &quot;fmul  v28.2d, v24.2d, v16.2d\n\t&quot;
1065         &quot;fmul  v29.2d, v24.2d, v17.2d\n\t&quot;
1066         &quot;fmla  v28.2d, v25.2d, v18.2d\n\t&quot;
1067         &quot;fmla  v29.2d, v25.2d, v19.2d\n\t&quot;
1068         &quot;fmla  v28.2d, v26.2d, v20.2d\n\t&quot;
1069         &quot;fmla  v29.2d, v26.2d, v21.2d\n\t&quot;
1070         &quot;fmla  v28.2d, v27.2d, v22.2d\n\t&quot;
1071         &quot;fmla  v29.2d, v27.2d, v23.2d\n\t&quot;
1072 
1073         &quot;ld4r  {v0.2d, v1.2d, v2.2d, v3.2d}, [%[rightMatrix]], #32\n\t&quot;
1074         &quot;st1  {v28.2d, v29.2d}, [x4], #32\n\t&quot;
1075 
1076         // Second row.
1077         &quot;fmul  v30.2d, v0.2d, v16.2d\n\t&quot;
1078         &quot;fmul  v31.2d, v0.2d, v17.2d\n\t&quot;
1079         &quot;fmla  v30.2d, v1.2d, v18.2d\n\t&quot;
1080         &quot;fmla  v31.2d, v1.2d, v19.2d\n\t&quot;
1081         &quot;fmla  v30.2d, v2.2d, v20.2d\n\t&quot;
1082         &quot;fmla  v31.2d, v2.2d, v21.2d\n\t&quot;
1083         &quot;fmla  v30.2d, v3.2d, v22.2d\n\t&quot;
1084         &quot;fmla  v31.2d, v3.2d, v23.2d\n\t&quot;
1085 
1086         &quot;ld4r  {v24.2d, v25.2d, v26.2d, v27.2d}, [%[rightMatrix]], #32\n\t&quot;
1087         &quot;st1   {v30.2d, v31.2d}, [x4], #32\n\t&quot;
1088 
1089         // Third row.
1090         &quot;fmul  v28.2d, v24.2d, v16.2d\n\t&quot;
1091         &quot;fmul  v29.2d, v24.2d, v17.2d\n\t&quot;
1092         &quot;fmla  v28.2d, v25.2d, v18.2d\n\t&quot;
1093         &quot;fmla  v29.2d, v25.2d, v19.2d\n\t&quot;
1094         &quot;fmla  v28.2d, v26.2d, v20.2d\n\t&quot;
1095         &quot;fmla  v29.2d, v26.2d, v21.2d\n\t&quot;
1096         &quot;fmla  v28.2d, v27.2d, v22.2d\n\t&quot;
1097         &quot;fmla  v29.2d, v27.2d, v23.2d\n\t&quot;
1098 
1099         &quot;ld4r  {v0.2d, v1.2d, v2.2d, v3.2d}, [%[rightMatrix]], #32\n\t&quot;
1100         &quot;st1   {v28.2d, v29.2d}, [x4], #32\n\t&quot;
1101 
1102         // Fourth row.
1103         &quot;fmul  v30.2d, v0.2d, v16.2d\n\t&quot;
1104         &quot;fmul  v31.2d, v0.2d, v17.2d\n\t&quot;
1105         &quot;fmla  v30.2d, v1.2d, v18.2d\n\t&quot;
1106         &quot;fmla  v31.2d, v1.2d, v19.2d\n\t&quot;
1107         &quot;fmla  v30.2d, v2.2d, v20.2d\n\t&quot;
1108         &quot;fmla  v31.2d, v2.2d, v21.2d\n\t&quot;
1109         &quot;fmla  v30.2d, v3.2d, v22.2d\n\t&quot;
1110         &quot;fmla  v31.2d, v3.2d, v23.2d\n\t&quot;
1111 
1112         &quot;st1  {v30.2d, v31.2d}, [x4]\n\t&quot;
1113 
1114         : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1115         :
1116         : &quot;memory&quot;, &quot;x4&quot;, &quot;v0&quot;, &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, &quot;v16&quot;, &quot;v17&quot;, &quot;v18&quot;, &quot;v19&quot;, &quot;v20&quot;, &quot;v21&quot;, &quot;v22&quot;, &quot;v23&quot;, &quot;v24&quot;, &quot;v25&quot;, &quot;v26&quot;, &quot;v27&quot;, &quot;v28&quot;, &quot;v29&quot;, &quot;v30&quot;, &quot;v31&quot;);
1117 #elif CPU(APPLE_ARMV7S)
1118     double* leftMatrix = &amp;(m_matrix[0][0]);
1119     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1120     asm volatile (// First row of leftMatrix.
1121         &quot;mov        r3, %[leftMatrix]\n\t&quot;
1122         &quot;vld1.64    { d16-d19 }, [%[leftMatrix], :128]!\n\t&quot;
1123         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1124         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1125         &quot;vld1.64    { d20-d23 }, [%[leftMatrix], :128]!\n\t&quot;
1126         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1127         &quot;vld1.64    { d24-d27 }, [%[leftMatrix], :128]!\n\t&quot;
1128         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1129         &quot;vld1.64    { d28-d31 }, [%[leftMatrix], :128]!\n\t&quot;
1130         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1131 
1132         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1133         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1134         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1135         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1136 
1137         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1138         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1139         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1140         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1141 
1142         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1143         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1144         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1145         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1146         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1147         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1148 
1149         // Second row of leftMatrix.
1150         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1151         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1152         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1153         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1154 
1155         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1156         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1157         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1158         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1159 
1160         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1161         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1162         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1163         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1164 
1165         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1166         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1167         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1168         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1169         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]!\n\t&quot;
1170         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1171 
1172         // Third row of leftMatrix.
1173         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1174         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1175         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1176         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1177 
1178         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1179         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1180         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1181         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1182 
1183         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1184         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1185         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1186         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1187 
1188         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1189         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1190         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1191         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1192         &quot;vld1.64    { d0-d3}, [%[rightMatrix], :128]\n\t&quot;
1193         &quot;vst1.64    { d4-d7 }, [r3, :128]!\n\t&quot;
1194 
1195         // Fourth and last row of leftMatrix.
1196         &quot;vmul.f64   d4, d0, d16\n\t&quot;
1197         &quot;vmla.f64   d4, d1, d20\n\t&quot;
1198         &quot;vmla.f64   d4, d2, d24\n\t&quot;
1199         &quot;vmla.f64   d4, d3, d28\n\t&quot;
1200 
1201         &quot;vmul.f64   d5, d0, d17\n\t&quot;
1202         &quot;vmla.f64   d5, d1, d21\n\t&quot;
1203         &quot;vmla.f64   d5, d2, d25\n\t&quot;
1204         &quot;vmla.f64   d5, d3, d29\n\t&quot;
1205 
1206         &quot;vmul.f64   d6, d0, d18\n\t&quot;
1207         &quot;vmla.f64   d6, d1, d22\n\t&quot;
1208         &quot;vmla.f64   d6, d2, d26\n\t&quot;
1209         &quot;vmla.f64   d6, d3, d30\n\t&quot;
1210 
1211         &quot;vmul.f64   d7, d0, d19\n\t&quot;
1212         &quot;vmla.f64   d7, d1, d23\n\t&quot;
1213         &quot;vmla.f64   d7, d2, d27\n\t&quot;
1214         &quot;vmla.f64   d7, d3, d31\n\t&quot;
1215         &quot;vst1.64    { d4-d7 }, [r3, :128]\n\t&quot;
1216         : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1217         :
1218         : &quot;memory&quot;, &quot;r3&quot;, &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;, &quot;d16&quot;, &quot;d17&quot;, &quot;d18&quot;, &quot;d19&quot;, &quot;d20&quot;, &quot;d21&quot;, &quot;d22&quot;, &quot;d23&quot;, &quot;d24&quot;, &quot;d25&quot;, &quot;d26&quot;, &quot;d27&quot;, &quot;d28&quot;, &quot;d29&quot;, &quot;d30&quot;, &quot;d31&quot;);
1219 #elif CPU(ARM_VFP) &amp;&amp; PLATFORM(IOS_FAMILY)
1220 
1221 #define MATRIX_MULTIPLY_ONE_LINE \
1222     &quot;vldmia.64  %[rightMatrix]!, { d0-d3}\n\t&quot; \
1223     &quot;vmul.f64   d4, d0, d16\n\t&quot; \
1224     &quot;vmla.f64   d4, d1, d20\n\t&quot; \
1225     &quot;vmla.f64   d4, d2, d24\n\t&quot; \
1226     &quot;vmla.f64   d4, d3, d28\n\t&quot; \
1227     \
1228     &quot;vmul.f64   d5, d0, d17\n\t&quot; \
1229     &quot;vmla.f64   d5, d1, d21\n\t&quot; \
1230     &quot;vmla.f64   d5, d2, d25\n\t&quot; \
1231     &quot;vmla.f64   d5, d3, d29\n\t&quot; \
1232     \
1233     &quot;vmul.f64   d6, d0, d18\n\t&quot; \
1234     &quot;vmla.f64   d6, d1, d22\n\t&quot; \
1235     &quot;vmla.f64   d6, d2, d26\n\t&quot; \
1236     &quot;vmla.f64   d6, d3, d30\n\t&quot; \
1237     \
1238     &quot;vmul.f64   d7, d0, d19\n\t&quot; \
1239     &quot;vmla.f64   d7, d1, d23\n\t&quot; \
1240     &quot;vmla.f64   d7, d2, d27\n\t&quot; \
1241     &quot;vmla.f64   d7, d3, d31\n\t&quot; \
1242     &quot;vstmia.64  %[leftMatrix]!, { d4-d7 }\n\t&quot;
1243 
1244     double* leftMatrix = &amp;(m_matrix[0][0]);
1245     const double* rightMatrix = &amp;(mat.m_matrix[0][0]);
1246     // We load the full m_matrix at once in d16-d31.
1247     asm volatile(&quot;vldmia.64  %[leftMatrix], { d16-d31 }\n\t&quot;
1248                  :
1249                  : [leftMatrix]&quot;r&quot;(leftMatrix)
1250                  : &quot;d16&quot;, &quot;d17&quot;, &quot;d18&quot;, &quot;d19&quot;, &quot;d20&quot;, &quot;d21&quot;, &quot;d22&quot;, &quot;d23&quot;, &quot;d24&quot;, &quot;d25&quot;, &quot;d26&quot;, &quot;d27&quot;, &quot;d28&quot;, &quot;d29&quot;, &quot;d30&quot;, &quot;d31&quot;);
1251     for (unsigned i = 0; i &lt; 4; ++i) {
1252         asm volatile(MATRIX_MULTIPLY_ONE_LINE
1253                      : [leftMatrix]&quot;+r&quot;(leftMatrix), [rightMatrix]&quot;+r&quot;(rightMatrix)
1254                      :
1255                      : &quot;memory&quot;, &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;);
1256     }
1257 #undef MATRIX_MULTIPLY_ONE_LINE
1258 
1259 #elif defined(TRANSFORMATION_MATRIX_USE_X86_64_SSE2)
1260     // x86_64 has 16 XMM registers which is enough to do the multiplication fully in registers.
1261     __m128d matrixBlockA = _mm_load_pd(&amp;(m_matrix[0][0]));
1262     __m128d matrixBlockC = _mm_load_pd(&amp;(m_matrix[1][0]));
1263     __m128d matrixBlockE = _mm_load_pd(&amp;(m_matrix[2][0]));
1264     __m128d matrixBlockG = _mm_load_pd(&amp;(m_matrix[3][0]));
1265 
1266     // First row.
1267     __m128d otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[0][0]);
1268     __m128d otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[0][1]);
1269     __m128d otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[0][2]);
1270     __m128d otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[0][3]);
1271 
1272     // output00 and output01.
1273     __m128d accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1274     __m128d temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1275     __m128d temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1276     __m128d temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1277 
1278     __m128d matrixBlockB = _mm_load_pd(&amp;(m_matrix[0][2]));
1279     __m128d matrixBlockD = _mm_load_pd(&amp;(m_matrix[1][2]));
1280     __m128d matrixBlockF = _mm_load_pd(&amp;(m_matrix[2][2]));
1281     __m128d matrixBlockH = _mm_load_pd(&amp;(m_matrix[3][2]));
1282 
1283     accumulator = _mm_add_pd(accumulator, temp1);
1284     accumulator = _mm_add_pd(accumulator, temp2);
1285     accumulator = _mm_add_pd(accumulator, temp3);
1286     _mm_store_pd(&amp;m_matrix[0][0], accumulator);
1287 
1288     // output02 and output03.
1289     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1290     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1291     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1292     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1293 
1294     accumulator = _mm_add_pd(accumulator, temp1);
1295     accumulator = _mm_add_pd(accumulator, temp2);
1296     accumulator = _mm_add_pd(accumulator, temp3);
1297     _mm_store_pd(&amp;m_matrix[0][2], accumulator);
1298 
1299     // Second row.
1300     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[1][0]);
1301     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[1][1]);
1302     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[1][2]);
1303     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[1][3]);
1304 
1305     // output10 and output11.
1306     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1307     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1308     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1309     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1310 
1311     accumulator = _mm_add_pd(accumulator, temp1);
1312     accumulator = _mm_add_pd(accumulator, temp2);
1313     accumulator = _mm_add_pd(accumulator, temp3);
1314     _mm_store_pd(&amp;m_matrix[1][0], accumulator);
1315 
1316     // output12 and output13.
1317     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1318     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1319     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1320     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1321 
1322     accumulator = _mm_add_pd(accumulator, temp1);
1323     accumulator = _mm_add_pd(accumulator, temp2);
1324     accumulator = _mm_add_pd(accumulator, temp3);
1325     _mm_store_pd(&amp;m_matrix[1][2], accumulator);
1326 
1327     // Third row.
1328     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[2][0]);
1329     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[2][1]);
1330     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[2][2]);
1331     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[2][3]);
1332 
1333     // output20 and output21.
1334     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1335     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1336     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1337     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1338 
1339     accumulator = _mm_add_pd(accumulator, temp1);
1340     accumulator = _mm_add_pd(accumulator, temp2);
1341     accumulator = _mm_add_pd(accumulator, temp3);
1342     _mm_store_pd(&amp;m_matrix[2][0], accumulator);
1343 
1344     // output22 and output23.
1345     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1346     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1347     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1348     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1349 
1350     accumulator = _mm_add_pd(accumulator, temp1);
1351     accumulator = _mm_add_pd(accumulator, temp2);
1352     accumulator = _mm_add_pd(accumulator, temp3);
1353     _mm_store_pd(&amp;m_matrix[2][2], accumulator);
1354 
1355     // Fourth row.
1356     otherMatrixFirstParam = _mm_set1_pd(mat.m_matrix[3][0]);
1357     otherMatrixSecondParam = _mm_set1_pd(mat.m_matrix[3][1]);
1358     otherMatrixThirdParam = _mm_set1_pd(mat.m_matrix[3][2]);
1359     otherMatrixFourthParam = _mm_set1_pd(mat.m_matrix[3][3]);
1360 
1361     // output30 and output31.
1362     accumulator = _mm_mul_pd(matrixBlockA, otherMatrixFirstParam);
1363     temp1 = _mm_mul_pd(matrixBlockC, otherMatrixSecondParam);
1364     temp2 = _mm_mul_pd(matrixBlockE, otherMatrixThirdParam);
1365     temp3 = _mm_mul_pd(matrixBlockG, otherMatrixFourthParam);
1366 
1367     accumulator = _mm_add_pd(accumulator, temp1);
1368     accumulator = _mm_add_pd(accumulator, temp2);
1369     accumulator = _mm_add_pd(accumulator, temp3);
1370     _mm_store_pd(&amp;m_matrix[3][0], accumulator);
1371 
1372     // output32 and output33.
1373     accumulator = _mm_mul_pd(matrixBlockB, otherMatrixFirstParam);
1374     temp1 = _mm_mul_pd(matrixBlockD, otherMatrixSecondParam);
1375     temp2 = _mm_mul_pd(matrixBlockF, otherMatrixThirdParam);
1376     temp3 = _mm_mul_pd(matrixBlockH, otherMatrixFourthParam);
1377 
1378     accumulator = _mm_add_pd(accumulator, temp1);
1379     accumulator = _mm_add_pd(accumulator, temp2);
1380     accumulator = _mm_add_pd(accumulator, temp3);
1381     _mm_store_pd(&amp;m_matrix[3][2], accumulator);
1382 #else
1383     Matrix4 tmp;
1384 
1385     tmp[0][0] = (mat.m_matrix[0][0] * m_matrix[0][0] + mat.m_matrix[0][1] * m_matrix[1][0]
1386                + mat.m_matrix[0][2] * m_matrix[2][0] + mat.m_matrix[0][3] * m_matrix[3][0]);
1387     tmp[0][1] = (mat.m_matrix[0][0] * m_matrix[0][1] + mat.m_matrix[0][1] * m_matrix[1][1]
1388                + mat.m_matrix[0][2] * m_matrix[2][1] + mat.m_matrix[0][3] * m_matrix[3][1]);
1389     tmp[0][2] = (mat.m_matrix[0][0] * m_matrix[0][2] + mat.m_matrix[0][1] * m_matrix[1][2]
1390                + mat.m_matrix[0][2] * m_matrix[2][2] + mat.m_matrix[0][3] * m_matrix[3][2]);
1391     tmp[0][3] = (mat.m_matrix[0][0] * m_matrix[0][3] + mat.m_matrix[0][1] * m_matrix[1][3]
1392                + mat.m_matrix[0][2] * m_matrix[2][3] + mat.m_matrix[0][3] * m_matrix[3][3]);
1393 
1394     tmp[1][0] = (mat.m_matrix[1][0] * m_matrix[0][0] + mat.m_matrix[1][1] * m_matrix[1][0]
1395                + mat.m_matrix[1][2] * m_matrix[2][0] + mat.m_matrix[1][3] * m_matrix[3][0]);
1396     tmp[1][1] = (mat.m_matrix[1][0] * m_matrix[0][1] + mat.m_matrix[1][1] * m_matrix[1][1]
1397                + mat.m_matrix[1][2] * m_matrix[2][1] + mat.m_matrix[1][3] * m_matrix[3][1]);
1398     tmp[1][2] = (mat.m_matrix[1][0] * m_matrix[0][2] + mat.m_matrix[1][1] * m_matrix[1][2]
1399                + mat.m_matrix[1][2] * m_matrix[2][2] + mat.m_matrix[1][3] * m_matrix[3][2]);
1400     tmp[1][3] = (mat.m_matrix[1][0] * m_matrix[0][3] + mat.m_matrix[1][1] * m_matrix[1][3]
1401                + mat.m_matrix[1][2] * m_matrix[2][3] + mat.m_matrix[1][3] * m_matrix[3][3]);
1402 
1403     tmp[2][0] = (mat.m_matrix[2][0] * m_matrix[0][0] + mat.m_matrix[2][1] * m_matrix[1][0]
1404                + mat.m_matrix[2][2] * m_matrix[2][0] + mat.m_matrix[2][3] * m_matrix[3][0]);
1405     tmp[2][1] = (mat.m_matrix[2][0] * m_matrix[0][1] + mat.m_matrix[2][1] * m_matrix[1][1]
1406                + mat.m_matrix[2][2] * m_matrix[2][1] + mat.m_matrix[2][3] * m_matrix[3][1]);
1407     tmp[2][2] = (mat.m_matrix[2][0] * m_matrix[0][2] + mat.m_matrix[2][1] * m_matrix[1][2]
1408                + mat.m_matrix[2][2] * m_matrix[2][2] + mat.m_matrix[2][3] * m_matrix[3][2]);
1409     tmp[2][3] = (mat.m_matrix[2][0] * m_matrix[0][3] + mat.m_matrix[2][1] * m_matrix[1][3]
1410                + mat.m_matrix[2][2] * m_matrix[2][3] + mat.m_matrix[2][3] * m_matrix[3][3]);
1411 
1412     tmp[3][0] = (mat.m_matrix[3][0] * m_matrix[0][0] + mat.m_matrix[3][1] * m_matrix[1][0]
1413                + mat.m_matrix[3][2] * m_matrix[2][0] + mat.m_matrix[3][3] * m_matrix[3][0]);
1414     tmp[3][1] = (mat.m_matrix[3][0] * m_matrix[0][1] + mat.m_matrix[3][1] * m_matrix[1][1]
1415                + mat.m_matrix[3][2] * m_matrix[2][1] + mat.m_matrix[3][3] * m_matrix[3][1]);
1416     tmp[3][2] = (mat.m_matrix[3][0] * m_matrix[0][2] + mat.m_matrix[3][1] * m_matrix[1][2]
1417                + mat.m_matrix[3][2] * m_matrix[2][2] + mat.m_matrix[3][3] * m_matrix[3][2]);
1418     tmp[3][3] = (mat.m_matrix[3][0] * m_matrix[0][3] + mat.m_matrix[3][1] * m_matrix[1][3]
1419                + mat.m_matrix[3][2] * m_matrix[2][3] + mat.m_matrix[3][3] * m_matrix[3][3]);
1420 
1421     memcpy(&amp;m_matrix[0][0], &amp;tmp[0][0], sizeof(Matrix4));
1422 #endif
1423     return *this;
1424 }
1425 
1426 void TransformationMatrix::multVecMatrix(double x, double y, double&amp; resultX, double&amp; resultY) const
1427 {
1428     resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0];
1429     resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1];
1430     double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3];
1431     if (w != 1 &amp;&amp; w != 0) {
1432         resultX /= w;
1433         resultY /= w;
1434     }
1435 }
1436 
1437 void TransformationMatrix::multVecMatrix(double x, double y, double z, double&amp; resultX, double&amp; resultY, double&amp; resultZ) const
1438 {
1439     resultX = m_matrix[3][0] + x * m_matrix[0][0] + y * m_matrix[1][0] + z * m_matrix[2][0];
1440     resultY = m_matrix[3][1] + x * m_matrix[0][1] + y * m_matrix[1][1] + z * m_matrix[2][1];
1441     resultZ = m_matrix[3][2] + x * m_matrix[0][2] + y * m_matrix[1][2] + z * m_matrix[2][2];
1442     double w = m_matrix[3][3] + x * m_matrix[0][3] + y * m_matrix[1][3] + z * m_matrix[2][3];
1443     if (w != 1 &amp;&amp; w != 0) {
1444         resultX /= w;
1445         resultY /= w;
1446         resultZ /= w;
1447     }
1448 }
1449 
1450 bool TransformationMatrix::isInvertible() const
1451 {
1452     if (isIdentityOrTranslation())
1453         return true;
1454 
1455     double det = WebCore::determinant4x4(m_matrix);
1456 
1457     if (fabs(det) &lt; SMALL_NUMBER)
1458         return false;
1459 
1460     return true;
1461 }
1462 
1463 Optional&lt;TransformationMatrix&gt; TransformationMatrix::inverse() const
1464 {
1465     if (isIdentityOrTranslation()) {
1466         // identity matrix
1467         if (m_matrix[3][0] == 0 &amp;&amp; m_matrix[3][1] == 0 &amp;&amp; m_matrix[3][2] == 0)
1468             return TransformationMatrix();
1469 
1470         // translation
1471         return TransformationMatrix(1, 0, 0, 0,
1472                                     0, 1, 0, 0,
1473                                     0, 0, 1, 0,
1474                                     -m_matrix[3][0], -m_matrix[3][1], -m_matrix[3][2], 1);
1475     }
1476 
1477     TransformationMatrix invMat;
1478     // FIXME: Use LU decomposition to apply the inverse instead of calculating the inverse explicitly.
1479     // Calculating the inverse of a 4x4 matrix using cofactors is numerically unstable and unnecessary to apply the inverse transformation to a point.
1480     if (!WebCore::inverse(m_matrix, invMat.m_matrix))
1481         return WTF::nullopt;
1482 
1483     return invMat;
1484 }
1485 
1486 void TransformationMatrix::makeAffine()
1487 {
1488     m_matrix[0][2] = 0;
1489     m_matrix[0][3] = 0;
1490 
1491     m_matrix[1][2] = 0;
1492     m_matrix[1][3] = 0;
1493 
1494     m_matrix[2][0] = 0;
1495     m_matrix[2][1] = 0;
1496     m_matrix[2][2] = 1;
1497     m_matrix[2][3] = 0;
1498 
1499     m_matrix[3][2] = 0;
1500     m_matrix[3][3] = 1;
1501 }
1502 
1503 AffineTransform TransformationMatrix::toAffineTransform() const
1504 {
1505     return AffineTransform(m_matrix[0][0], m_matrix[0][1], m_matrix[1][0],
1506                            m_matrix[1][1], m_matrix[3][0], m_matrix[3][1]);
1507 }
1508 
1509 static inline void blendFloat(double&amp; from, double to, double progress)
1510 {
1511     if (from != to)
1512         from = from + (to - from) * progress;
1513 }
1514 
1515 void TransformationMatrix::blend2(const TransformationMatrix&amp; from, double progress)
1516 {
1517     Decomposed2Type fromDecomp;
1518     Decomposed2Type toDecomp;
1519     if (!from.decompose2(fromDecomp) || !decompose2(toDecomp)) {
1520         if (progress &lt; 0.5)
1521             *this = from;
1522         return;
1523     }
1524 
1525     // If x-axis of one is flipped, and y-axis of the other, convert to an unflipped rotation.
1526     if ((fromDecomp.scaleX &lt; 0 &amp;&amp; toDecomp.scaleY &lt; 0) || (fromDecomp.scaleY &lt; 0 &amp;&amp; toDecomp.scaleX &lt; 0)) {
1527         fromDecomp.scaleX = -fromDecomp.scaleX;
1528         fromDecomp.scaleY = -fromDecomp.scaleY;
1529         fromDecomp.angle += fromDecomp.angle &lt; 0 ? 180 : -180;
1530     }
1531 
1532     // Don&#39;t rotate the long way around.
1533     if (!fromDecomp.angle)
1534         fromDecomp.angle = 360;
1535     if (!toDecomp.angle)
1536         toDecomp.angle = 360;
1537 
1538     if (fabs(fromDecomp.angle - toDecomp.angle) &gt; 180) {
1539         if (fromDecomp.angle &gt; toDecomp.angle)
1540             fromDecomp.angle -= 360;
1541         else
1542             toDecomp.angle -= 360;
1543     }
1544 
1545     blendFloat(fromDecomp.m11, toDecomp.m11, progress);
1546     blendFloat(fromDecomp.m12, toDecomp.m12, progress);
1547     blendFloat(fromDecomp.m21, toDecomp.m21, progress);
1548     blendFloat(fromDecomp.m22, toDecomp.m22, progress);
1549     blendFloat(fromDecomp.translateX, toDecomp.translateX, progress);
1550     blendFloat(fromDecomp.translateY, toDecomp.translateY, progress);
1551     blendFloat(fromDecomp.scaleX, toDecomp.scaleX, progress);
1552     blendFloat(fromDecomp.scaleY, toDecomp.scaleY, progress);
1553     blendFloat(fromDecomp.angle, toDecomp.angle, progress);
1554 
1555     recompose2(fromDecomp);
1556 }
1557 
1558 void TransformationMatrix::blend4(const TransformationMatrix&amp; from, double progress)
1559 {
1560     Decomposed4Type fromDecomp;
1561     Decomposed4Type toDecomp;
1562     if (!from.decompose4(fromDecomp) || !decompose4(toDecomp)) {
1563         if (progress &lt; 0.5)
1564             *this = from;
1565         return;
1566     }
1567 
1568     blendFloat(fromDecomp.scaleX, toDecomp.scaleX, progress);
1569     blendFloat(fromDecomp.scaleY, toDecomp.scaleY, progress);
1570     blendFloat(fromDecomp.scaleZ, toDecomp.scaleZ, progress);
1571     blendFloat(fromDecomp.skewXY, toDecomp.skewXY, progress);
1572     blendFloat(fromDecomp.skewXZ, toDecomp.skewXZ, progress);
1573     blendFloat(fromDecomp.skewYZ, toDecomp.skewYZ, progress);
1574     blendFloat(fromDecomp.translateX, toDecomp.translateX, progress);
1575     blendFloat(fromDecomp.translateY, toDecomp.translateY, progress);
1576     blendFloat(fromDecomp.translateZ, toDecomp.translateZ, progress);
1577     blendFloat(fromDecomp.perspectiveX, toDecomp.perspectiveX, progress);
1578     blendFloat(fromDecomp.perspectiveY, toDecomp.perspectiveY, progress);
1579     blendFloat(fromDecomp.perspectiveZ, toDecomp.perspectiveZ, progress);
1580     blendFloat(fromDecomp.perspectiveW, toDecomp.perspectiveW, progress);
1581 
1582     slerp(&amp;fromDecomp.quaternionX, &amp;toDecomp.quaternionX, progress);
1583 
1584     recompose4(fromDecomp);
1585 }
1586 
1587 void TransformationMatrix::blend(const TransformationMatrix&amp; from, double progress)
1588 {
1589     if (from.isIdentity() &amp;&amp; isIdentity())
1590         return;
1591 
1592     if (from.isAffine() &amp;&amp; isAffine())
1593         blend2(from, progress);
1594     else
1595         blend4(from, progress);
1596 }
1597 
1598 bool TransformationMatrix::decompose2(Decomposed2Type&amp; decomp) const
1599 {
1600     if (isIdentity()) {
1601         memset(&amp;decomp, 0, sizeof(decomp));
1602         decomp.scaleX = 1;
1603         decomp.scaleY = 1;
1604         decomp.m11 = 1;
1605         decomp.m22 = 1;
1606         return true;
1607     }
1608 
1609     return WebCore::decompose2(m_matrix, decomp);
1610 }
1611 
1612 bool TransformationMatrix::decompose4(Decomposed4Type&amp; decomp) const
1613 {
1614     if (isIdentity()) {
1615         memset(&amp;decomp, 0, sizeof(decomp));
1616         decomp.perspectiveW = 1;
1617         decomp.scaleX = 1;
1618         decomp.scaleY = 1;
1619         decomp.scaleZ = 1;
1620         return true;
1621     }
1622 
1623     return WebCore::decompose4(m_matrix, decomp);
1624 }
1625 
1626 void TransformationMatrix::recompose2(const Decomposed2Type&amp; decomp)
1627 {
1628     makeIdentity();
1629 
1630     m_matrix[0][0] = decomp.m11;
1631     m_matrix[0][1] = decomp.m12;
1632     m_matrix[1][0] = decomp.m21;
1633     m_matrix[1][1] = decomp.m22;
1634 
1635     translate3d(decomp.translateX, decomp.translateY, 0);
1636     rotate(decomp.angle);
1637     scale3d(decomp.scaleX, decomp.scaleY, 1);
1638 }
1639 
1640 void TransformationMatrix::recompose4(const Decomposed4Type&amp; decomp)
1641 {
1642     makeIdentity();
1643 
1644     // First apply perspective.
1645     m_matrix[0][3] = decomp.perspectiveX;
1646     m_matrix[1][3] = decomp.perspectiveY;
1647     m_matrix[2][3] = decomp.perspectiveZ;
1648     m_matrix[3][3] = decomp.perspectiveW;
1649 
1650     // Next, translate.
1651     translate3d(decomp.translateX, decomp.translateY, decomp.translateZ);
1652 
1653     // Apply rotation.
1654     double xx = decomp.quaternionX * decomp.quaternionX;
1655     double xy = decomp.quaternionX * decomp.quaternionY;
1656     double xz = decomp.quaternionX * decomp.quaternionZ;
1657     double xw = decomp.quaternionX * decomp.quaternionW;
1658     double yy = decomp.quaternionY * decomp.quaternionY;
1659     double yz = decomp.quaternionY * decomp.quaternionZ;
1660     double yw = decomp.quaternionY * decomp.quaternionW;
1661     double zz = decomp.quaternionZ * decomp.quaternionZ;
1662     double zw = decomp.quaternionZ * decomp.quaternionW;
1663 
1664     // Construct a composite rotation matrix from the quaternion values.
1665     TransformationMatrix rotationMatrix(1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 0,
1666                            2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 0,
1667                            2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy), 0,
1668                            0, 0, 0, 1);
1669 
1670     multiply(rotationMatrix);
1671 
1672     // Apply skew.
1673     if (decomp.skewYZ) {
1674         TransformationMatrix tmp;
1675         tmp.setM32(decomp.skewYZ);
1676         multiply(tmp);
1677     }
1678 
1679     if (decomp.skewXZ) {
1680         TransformationMatrix tmp;
1681         tmp.setM31(decomp.skewXZ);
1682         multiply(tmp);
1683     }
1684 
1685     if (decomp.skewXY) {
1686         TransformationMatrix tmp;
1687         tmp.setM21(decomp.skewXY);
1688         multiply(tmp);
1689     }
1690 
1691     // Finally, apply scale.
1692     scale3d(decomp.scaleX, decomp.scaleY, decomp.scaleZ);
1693 }
1694 
1695 bool TransformationMatrix::isIntegerTranslation() const
1696 {
1697     if (!isIdentityOrTranslation())
1698         return false;
1699 
1700     // Check for translate Z.
1701     if (m_matrix[3][2])
1702         return false;
1703 
1704     // Check for non-integer translate X/Y.
1705     if (static_cast&lt;int&gt;(m_matrix[3][0]) != m_matrix[3][0] || static_cast&lt;int&gt;(m_matrix[3][1]) != m_matrix[3][1])
1706         return false;
1707 
1708     return true;
1709 }
1710 
1711 bool TransformationMatrix::containsOnlyFiniteValues() const
1712 {
1713     return std::isfinite(m_matrix[0][0]) &amp;&amp; std::isfinite(m_matrix[0][1]) &amp;&amp; std::isfinite(m_matrix[0][2]) &amp;&amp; std::isfinite(m_matrix[0][3])
1714         &amp;&amp; std::isfinite(m_matrix[1][0]) &amp;&amp; std::isfinite(m_matrix[1][1]) &amp;&amp; std::isfinite(m_matrix[1][2]) &amp;&amp; std::isfinite(m_matrix[1][3])
1715         &amp;&amp; std::isfinite(m_matrix[2][0]) &amp;&amp; std::isfinite(m_matrix[2][1]) &amp;&amp; std::isfinite(m_matrix[2][2]) &amp;&amp; std::isfinite(m_matrix[2][3])
1716         &amp;&amp; std::isfinite(m_matrix[3][0]) &amp;&amp; std::isfinite(m_matrix[3][1]) &amp;&amp; std::isfinite(m_matrix[3][2]) &amp;&amp; std::isfinite(m_matrix[3][3]);
1717 }
1718 
1719 TransformationMatrix TransformationMatrix::to2dTransform() const
1720 {
1721     return TransformationMatrix(m_matrix[0][0], m_matrix[0][1], 0, m_matrix[0][3],
1722                                 m_matrix[1][0], m_matrix[1][1], 0, m_matrix[1][3],
1723                                 0, 0, 1, 0,
1724                                 m_matrix[3][0], m_matrix[3][1], 0, m_matrix[3][3]);
1725 }
1726 
1727 auto TransformationMatrix::toColumnMajorFloatArray() const -&gt; FloatMatrix4
1728 {
1729     return { {
1730         float(m11()), float(m12()), float(m13()), float(m14()),
1731         float(m21()), float(m22()), float(m23()), float(m24()),
1732         float(m31()), float(m32()), float(m33()), float(m34()),
1733         float(m41()), float(m42()), float(m43()), float(m44()) } };
1734 }
1735 
1736 bool TransformationMatrix::isBackFaceVisible() const
1737 {
1738     // Back-face visibility is determined by transforming the normal vector (0, 0, 1) and
1739     // checking the sign of the resulting z component. However, normals cannot be
1740     // transformed by the original matrix, they require being transformed by the
1741     // inverse-transpose.
1742     //
1743     // Since we know we will be using (0, 0, 1), and we only care about the z-component of
1744     // the transformed normal, then we only need the m33() element of the
1745     // inverse-transpose. Therefore we do not need the transpose.
1746     //
1747     // Additionally, if we only need the m33() element, we do not need to compute a full
1748     // inverse. Instead, knowing the inverse of a matrix is adjoint(matrix) / determinant,
1749     // we can simply compute the m33() of the adjoint (adjugate) matrix, without computing
1750     // the full adjoint.
1751 
1752     double determinant = WebCore::determinant4x4(m_matrix);
1753 
1754     // If the matrix is not invertible, then we assume its backface is not visible.
1755     if (fabs(determinant) &lt; SMALL_NUMBER)
1756         return false;
1757 
1758     double cofactor33 = determinant3x3(m11(), m12(), m14(), m21(), m22(), m24(), m41(), m42(), m44());
1759     double zComponentOfTransformedNormal = cofactor33 / determinant;
1760 
1761     return zComponentOfTransformedNormal &lt; 0;
1762 }
1763 
1764 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const TransformationMatrix&amp; transform)
1765 {
1766     TextStream::IndentScope indentScope(ts);
1767     ts &lt;&lt; &quot;\n&quot;;
1768     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m11() &lt;&lt; &quot; &quot; &lt;&lt; transform.m12() &lt;&lt; &quot; &quot; &lt;&lt; transform.m13() &lt;&lt; &quot; &quot; &lt;&lt; transform.m14() &lt;&lt; &quot;]\n&quot;;
1769     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m21() &lt;&lt; &quot; &quot; &lt;&lt; transform.m22() &lt;&lt; &quot; &quot; &lt;&lt; transform.m23() &lt;&lt; &quot; &quot; &lt;&lt; transform.m24() &lt;&lt; &quot;]\n&quot;;
1770     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m31() &lt;&lt; &quot; &quot; &lt;&lt; transform.m32() &lt;&lt; &quot; &quot; &lt;&lt; transform.m33() &lt;&lt; &quot; &quot; &lt;&lt; transform.m34() &lt;&lt; &quot;]\n&quot;;
1771     ts &lt;&lt; indent &lt;&lt; &quot;[&quot; &lt;&lt; transform.m41() &lt;&lt; &quot; &quot; &lt;&lt; transform.m42() &lt;&lt; &quot; &quot; &lt;&lt; transform.m43() &lt;&lt; &quot; &quot; &lt;&lt; transform.m44() &lt;&lt; &quot;]&quot;;
1772     return ts;
1773 }
1774 
1775 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>