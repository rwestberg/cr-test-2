<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArgList.h&quot;
  26 #include &quot;CallFrame.h&quot;
  27 #include &quot;CommonIdentifiers.h&quot;
  28 #include &quot;Identifier.h&quot;
  29 #include &quot;PropertyDescriptor.h&quot;
  30 #include &quot;PropertySlot.h&quot;
  31 #include &quot;Structure.h&quot;
  32 #include &quot;ThrowScope.h&quot;
  33 #include &lt;array&gt;
  34 #include &lt;wtf/CheckedArithmetic.h&gt;
  35 #include &lt;wtf/ForbidHeapAllocation.h&gt;
  36 #include &lt;wtf/text/StringView.h&gt;
  37 
  38 namespace JSC {
  39 
  40 class JSString;
  41 class JSRopeString;
  42 class LLIntOffsetsExtractor;
  43 
<a name="1" id="anc1"></a><span class="line-modified">  44 JSString* jsEmptyString(VM&amp;);</span>
<span class="line-modified">  45 JSString* jsString(VM&amp;, const String&amp;); // returns empty string if passed null string</span>


  46 
<a name="2" id="anc2"></a><span class="line-modified">  47 JSString* jsSingleCharacterString(VM&amp;, UChar);</span>
<span class="line-modified">  48 JSString* jsSubstring(VM&amp;, const String&amp;, unsigned offset, unsigned length);</span>


  49 
  50 // Non-trivial strings are two or more characters long.
  51 // These functions are faster than just calling jsString.
<a name="3" id="anc3"></a><span class="line-modified">  52 JSString* jsNontrivialString(VM&amp;, const String&amp;);</span>
<span class="line-modified">  53 JSString* jsNontrivialString(VM&amp;, String&amp;&amp;);</span>

  54 
  55 // Should be used for strings that are owned by an object that will
  56 // likely outlive the JSValue this makes, such as the parse tree or a
  57 // DOM object that contains a String
<a name="4" id="anc4"></a><span class="line-modified">  58 JSString* jsOwnedString(VM&amp;, const String&amp;);</span>

  59 
  60 bool isJSString(JSCell*);
  61 bool isJSString(JSValue);
  62 JSString* asString(JSValue);
  63 
  64 // In 64bit architecture, JSString and JSRopeString have the following memory layout to make sizeof(JSString) == 16 and sizeof(JSRopeString) == 32.
  65 // JSString has only one pointer. We use it for String. length() and is8Bit() queries go to StringImpl. In JSRopeString, we reuse the above pointer
  66 // place for the 1st fiber. JSRopeString has three fibers so its size is 48. To keep length and is8Bit flag information in JSRopeString, JSRopeString
  67 // encodes these information into the fiber pointers. is8Bit flag is encoded in the 1st fiber pointer. length is embedded directly, and two fibers
  68 // are compressed into 12bytes. isRope information is encoded in the first fiber&#39;s LSB.
  69 //
  70 // Since length of JSRopeString should be frequently accessed compared to each fiber, we put length in contiguous 32byte field, and compress 2nd
  71 // and 3rd fibers into the following 80byte fields. One problem is that now 2nd and 3rd fibers are split. Storing and loading 2nd and 3rd fibers
  72 // are not one pointer load operation. To make concurrent collector work correctly, we must initialize 2nd and 3rd fibers at JSRopeString creation
  73 // and we must not modify these part later.
  74 //
  75 //              0                        8        10               16                       32                                     48
  76 // JSString     [   ID      ][  header  ][   String pointer      0]
<a name="5" id="anc5"></a><span class="line-modified">  77 // JSRopeString [   ID      ][  header  ][   1st fiber         xyz][  length  ][2nd lower32][2nd upper16][3rd lower16][3rd upper32]</span>
  78 //                                                               ^
<a name="6" id="anc6"></a><span class="line-modified">  79 //                                            x:(is8Bit),y:(isSubstring),z:(isRope) bit flags</span>
  80 class JSString : public JSCell {
  81 public:
  82     friend class JIT;
  83     friend class VM;
  84     friend class SpecializedThunkJIT;
  85     friend class JSRopeString;
  86     friend class MarkStack;
  87     friend class SlotVisitor;
  88     friend class SmallStrings;
  89 
  90     typedef JSCell Base;
  91     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | StructureIsImmortal | OverridesToThis;
  92 
  93     static const bool needsDestruction = true;
  94     static void destroy(JSCell*);
  95 
  96     // We specialize the string subspace to get the fastest possible sweep. This wouldn&#39;t be
  97     // necessary if JSString didn&#39;t have a destructor.
  98     template&lt;typename, SubspaceAccess&gt;
  99     static CompleteSubspace* subspaceFor(VM&amp; vm)
 100     {
 101         return &amp;vm.stringSpace;
 102     }
 103 
 104     // We employ overflow checks in many places with the assumption that MaxLength
 105     // is INT_MAX. Hence, it cannot be changed into another length value without
 106     // breaking all the bounds and overflow checks that assume this.
 107     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 108     static_assert(MaxLength == String::MaxLength, &quot;&quot;);
 109 
 110     static constexpr uintptr_t isRopeInPointer = 0x1;
 111 
 112 private:
 113     String&amp; uninitializedValueInternal() const
 114     {
 115         return *bitwise_cast&lt;String*&gt;(&amp;m_fiber);
 116     }
 117 
 118     String&amp; valueInternal() const
 119     {
 120         ASSERT(!isRope());
 121         return uninitializedValueInternal();
 122     }
 123 
 124     JSString(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 125         : JSCell(vm, vm.stringStructure.get())
 126     {
 127         new (&amp;uninitializedValueInternal()) String(WTFMove(value));
 128     }
 129 
 130     JSString(VM&amp; vm)
 131         : JSCell(vm, vm.stringStructure.get())
 132         , m_fiber(isRopeInPointer)
 133     {
 134     }
 135 
 136     void finishCreation(VM&amp; vm, unsigned length)
 137     {
 138         ASSERT_UNUSED(length, length &gt; 0);
 139         ASSERT(!valueInternal().isNull());
 140         Base::finishCreation(vm);
 141     }
 142 
 143     void finishCreation(VM&amp; vm, unsigned length, size_t cost)
 144     {
 145         ASSERT_UNUSED(length, length &gt; 0);
 146         ASSERT(!valueInternal().isNull());
 147         Base::finishCreation(vm);
 148         vm.heap.reportExtraMemoryAllocated(cost);
 149     }
 150 
 151     static JSString* createEmptyString(VM&amp;);
 152 
 153     static JSString* create(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 154     {
 155         unsigned length = value-&gt;length();
 156         ASSERT(length &gt; 0);
 157         size_t cost = value-&gt;cost();
 158         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 159         newString-&gt;finishCreation(vm, length, cost);
 160         return newString;
 161     }
 162     static JSString* createHasOtherOwner(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 163     {
 164         unsigned length = value-&gt;length();
 165         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 166         newString-&gt;finishCreation(vm, length);
 167         return newString;
 168     }
 169 
 170 protected:
 171     void finishCreation(VM&amp; vm)
 172     {
 173         Base::finishCreation(vm);
 174     }
 175 
 176 public:
 177     ~JSString();
 178 
 179     Identifier toIdentifier(ExecState*) const;
<a name="7" id="anc7"></a><span class="line-modified"> 180     AtomString toAtomString(ExecState*) const;</span>
<span class="line-modified"> 181     RefPtr&lt;AtomStringImpl&gt; toExistingAtomString(ExecState*) const;</span>
 182 
 183     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;
 184 
 185     inline bool equal(ExecState*, JSString* other) const;
 186     const String&amp; value(ExecState*) const;
 187     inline const String&amp; tryGetValue(bool allocationAllowed = true) const;
 188     const StringImpl* tryGetValueImpl() const;
 189     ALWAYS_INLINE unsigned length() const;
 190 
 191     JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;
 192     bool toBoolean() const { return !!length(); }
 193     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;
 194     JSObject* toObject(ExecState*, JSGlobalObject*) const;
 195     double toNumber(ExecState*) const;
 196 
 197     bool getStringPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);
 198     bool getStringPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);
 199     bool getStringPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);
 200 
 201     bool canGetIndex(unsigned i) { return i &lt; length(); }
 202     JSString* getIndex(ExecState*, unsigned);
 203 
 204     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue);
 205 
 206     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(JSString, m_fiber); }
 207 
 208     DECLARE_EXPORT_INFO;
 209 
 210     static void dumpToStream(const JSCell*, PrintStream&amp;);
 211     static size_t estimatedSize(JSCell*, VM&amp;);
 212     static void visitChildren(JSCell*, SlotVisitor&amp;);
 213 
 214     ALWAYS_INLINE bool isRope() const
 215     {
 216         return m_fiber &amp; isRopeInPointer;
 217     }
 218 
 219     bool is8Bit() const;
 220 
 221 protected:
 222     friend class JSValue;
 223 
 224     JS_EXPORT_PRIVATE bool equalSlowCase(ExecState*, JSString* other) const;
 225     bool isSubstring() const;
 226 
 227     mutable uintptr_t m_fiber;
 228 
 229 private:
 230     friend class LLIntOffsetsExtractor;
 231 
 232     static JSValue toThis(JSCell*, ExecState*, ECMAMode);
 233 
 234     StringView unsafeView(ExecState*) const;
 235 
<a name="8" id="anc8"></a><span class="line-modified"> 236     friend JSString* jsString(VM&amp;, const String&amp;);</span>
 237     friend JSString* jsString(ExecState*, JSString*, JSString*);
 238     friend JSString* jsString(ExecState*, const String&amp;, JSString*);
 239     friend JSString* jsString(ExecState*, JSString*, const String&amp;);
 240     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);
 241     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);
 242     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);
<a name="9" id="anc9"></a><span class="line-modified"> 243     friend JSString* jsSingleCharacterString(VM&amp;, UChar);</span>
<span class="line-modified"> 244     friend JSString* jsNontrivialString(VM&amp;, const String&amp;);</span>
<span class="line-modified"> 245     friend JSString* jsNontrivialString(VM&amp;, String&amp;&amp;);</span>
<span class="line-modified"> 246     friend JSString* jsSubstring(VM&amp;, const String&amp;, unsigned, unsigned);</span>
 247     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);
 248     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
<a name="10" id="anc10"></a><span class="line-modified"> 249     friend JSString* jsOwnedString(VM&amp;, const String&amp;);</span>
 250 };
 251 
 252 // NOTE: This class cannot override JSString&#39;s destructor. JSString&#39;s destructor is called directly
 253 // from JSStringSubspace::
 254 class JSRopeString final : public JSString {
 255     friend class JSString;
 256 public:
<a name="11" id="anc11"></a><span class="line-added"> 257     // We use lower 3bits of fiber0 for flags. These bits are usable due to alignment, and it is OK even in 32bit architecture.</span>
<span class="line-added"> 258     static constexpr uintptr_t is8BitInPointer = static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());</span>
<span class="line-added"> 259     static constexpr uintptr_t isSubstringInPointer = 0x2;</span>
<span class="line-added"> 260     static_assert(is8BitInPointer == 0b100, &quot;&quot;);</span>
<span class="line-added"> 261     static_assert(isSubstringInPointer == 0b010, &quot;&quot;);</span>
<span class="line-added"> 262     static_assert(isRopeInPointer == 0b001, &quot;&quot;);</span>
<span class="line-added"> 263     static constexpr uintptr_t stringMask = ~(isRopeInPointer | is8BitInPointer | isSubstringInPointer);</span>
 264 #if CPU(ADDRESS64)
 265     static_assert(sizeof(uintptr_t) == sizeof(uint64_t), &quot;&quot;);
<a name="12" id="anc12"></a>




 266     class CompactFibers {
 267     public:
<a name="13" id="anc13"></a><span class="line-added"> 268         static constexpr uintptr_t addressMask = (1ULL &lt;&lt; WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) - 1;</span>
 269         JSString* fiber1() const
 270         {
<a name="14" id="anc14"></a><span class="line-added"> 271 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added"> 272             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber1Lower) &amp; addressMask);</span>
<span class="line-added"> 273 #else</span>
 274             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber1Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber1Upper) &lt;&lt; 32));
<a name="15" id="anc15"></a><span class="line-added"> 275 #endif</span>
 276         }
 277 
 278         void initializeFiber1(JSString* fiber)
 279         {
 280             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 281             m_fiber1Lower = static_cast&lt;uint32_t&gt;(pointer);
 282             m_fiber1Upper = static_cast&lt;uint16_t&gt;(pointer &gt;&gt; 32);
 283         }
 284 
 285         JSString* fiber2() const
 286         {
<a name="16" id="anc16"></a><span class="line-modified"> 287 #if CPU(LITTLE_ENDIAN)</span>
<span class="line-added"> 288             // This access exceeds the sizeof(JSRopeString). But this is OK because JSRopeString is always allocated in MarkedBlock,</span>
<span class="line-added"> 289             // and the last JSRopeString cell in the block has some subsequent bytes which are used for MarkedBlock::Footer.</span>
<span class="line-added"> 290             // So the following access does not step over the page boundary in which the latter page does not have read permission.</span>
<span class="line-added"> 291             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber2Lower) &amp; addressMask);</span>
<span class="line-added"> 292 #else</span>
<span class="line-added"> 293             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber2Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber2Upper) &lt;&lt; 16));</span>
<span class="line-added"> 294 #endif</span>
 295         }
 296         void initializeFiber2(JSString* fiber)
 297         {
 298             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
<a name="17" id="anc17"></a><span class="line-modified"> 299             m_fiber2Lower = static_cast&lt;uint16_t&gt;(pointer);</span>
<span class="line-modified"> 300             m_fiber2Upper = static_cast&lt;uint32_t&gt;(pointer &gt;&gt; 16);</span>
 301         }
 302 
 303         unsigned length() const { return m_length; }
 304         void initializeLength(unsigned length)
 305         {
 306             m_length = length;
 307         }
 308 
 309         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
<a name="18" id="anc18"></a><span class="line-modified"> 310         static ptrdiff_t offsetOfFiber1() { return OBJECT_OFFSETOF(CompactFibers, m_length); }</span>
<span class="line-modified"> 311         static ptrdiff_t offsetOfFiber2() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1Upper); }</span>


 312 
 313     private:
<a name="19" id="anc19"></a><span class="line-added"> 314         friend class LLIntOffsetsExtractor;</span>
<span class="line-added"> 315 </span>
 316         uint32_t m_length { 0 };
 317         uint32_t m_fiber1Lower { 0 };
 318         uint16_t m_fiber1Upper { 0 };
<a name="20" id="anc20"></a><span class="line-modified"> 319         uint16_t m_fiber2Lower { 0 };</span>
<span class="line-modified"> 320         uint32_t m_fiber2Upper { 0 };</span>
 321     };
 322     static_assert(sizeof(CompactFibers) == sizeof(void*) * 2, &quot;&quot;);
 323 #else
<a name="21" id="anc21"></a>

 324     class CompactFibers {
 325     public:
 326         JSString* fiber1() const
 327         {
 328             return m_fiber1;
 329         }
 330         void initializeFiber1(JSString* fiber)
 331         {
 332             m_fiber1 = fiber;
 333         }
 334 
 335         JSString* fiber2() const
 336         {
 337             return m_fiber2;
 338         }
 339         void initializeFiber2(JSString* fiber)
 340         {
 341             m_fiber2 = fiber;
 342         }
 343 
 344         unsigned length() const { return m_length; }
 345         void initializeLength(unsigned length)
 346         {
 347             m_length = length;
 348         }
 349 
<a name="22" id="anc22"></a>












 350         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
<a name="23" id="anc23"></a><span class="line-added"> 351         static ptrdiff_t offsetOfFiber1() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1); }</span>
<span class="line-added"> 352         static ptrdiff_t offsetOfFiber2() { return OBJECT_OFFSETOF(CompactFibers, m_fiber2); }</span>
 353 
 354     private:
<a name="24" id="anc24"></a><span class="line-added"> 355         friend class LLIntOffsetsExtractor;</span>
<span class="line-added"> 356 </span>
 357         uint32_t m_length { 0 };
<a name="25" id="anc25"></a>
 358         JSString* m_fiber1 { nullptr };
 359         JSString* m_fiber2 { nullptr };
 360     };
 361 #endif
 362 
 363     template &lt;class OverflowHandler = CrashOnOverflow&gt;
 364     class RopeBuilder : public OverflowHandler {
 365         WTF_FORBID_HEAP_ALLOCATION;
 366     public:
 367         RopeBuilder(VM&amp; vm)
 368             : m_vm(vm)
 369         {
 370         }
 371 
 372         bool append(JSString* jsString)
 373         {
 374             if (UNLIKELY(this-&gt;hasOverflowed()))
 375                 return false;
 376             if (!jsString-&gt;length())
 377                 return true;
 378             if (m_strings.size() == JSRopeString::s_maxInternalRopeLength)
 379                 expand();
 380 
 381             static_assert(JSString::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
 382             auto sum = checkedSum&lt;int32_t&gt;(m_length, jsString-&gt;length());
 383             if (sum.hasOverflowed()) {
 384                 this-&gt;overflowed();
 385                 return false;
 386             }
 387             ASSERT(static_cast&lt;unsigned&gt;(sum.unsafeGet()) &lt;= MaxLength);
 388             m_strings.append(jsString);
 389             m_length = static_cast&lt;unsigned&gt;(sum.unsafeGet());
 390             return true;
 391         }
 392 
 393         JSString* release()
 394         {
 395             RELEASE_ASSERT(!this-&gt;hasOverflowed());
 396             JSString* result = nullptr;
 397             switch (m_strings.size()) {
 398             case 0: {
 399                 ASSERT(!m_length);
<a name="26" id="anc26"></a><span class="line-modified"> 400                 result = jsEmptyString(m_vm);</span>
 401                 break;
 402             }
 403             case 1: {
 404                 result = asString(m_strings.at(0));
 405                 break;
 406             }
 407             case 2: {
 408                 result = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)));
 409                 break;
 410             }
 411             case 3: {
 412                 result = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)), asString(m_strings.at(2)));
 413                 break;
 414             }
 415             default:
 416                 ASSERT_NOT_REACHED();
 417                 break;
 418             }
 419             ASSERT(result-&gt;length() == m_length);
 420             m_strings.clear();
 421             m_length = 0;
 422             return result;
 423         }
 424 
 425         unsigned length() const
 426         {
 427             ASSERT(!this-&gt;hasOverflowed());
 428             return m_length;
 429         }
 430 
 431     private:
 432         void expand();
 433 
 434         VM&amp; m_vm;
 435         MarkedArgumentBuffer m_strings;
 436         unsigned m_length { 0 };
 437     };
 438 
 439     inline unsigned length() const
 440     {
 441         return m_compactFibers.length();
 442     }
 443 
 444 private:
<a name="27" id="anc27"></a><span class="line-added"> 445     friend class LLIntOffsetsExtractor;</span>
<span class="line-added"> 446 </span>
 447     void convertToNonRope(String&amp;&amp;) const;
 448 
 449     void initializeIs8Bit(bool flag) const
 450     {
<a name="28" id="anc28"></a>
 451         if (flag)
 452             m_fiber |= is8BitInPointer;
 453         else
 454             m_fiber &amp;= ~is8BitInPointer;
<a name="29" id="anc29"></a><span class="line-modified"> 455     }</span>
<span class="line-modified"> 456 </span>
<span class="line-modified"> 457     void initializeIsSubstring(bool flag) const</span>
<span class="line-added"> 458     {</span>
<span class="line-added"> 459         if (flag)</span>
<span class="line-added"> 460             m_fiber |= isSubstringInPointer;</span>
<span class="line-added"> 461         else</span>
<span class="line-added"> 462             m_fiber &amp;= ~isSubstringInPointer;</span>
 463     }
 464 
 465     ALWAYS_INLINE void initializeLength(unsigned length)
 466     {
 467         ASSERT(length &lt;= MaxLength);
 468         m_compactFibers.initializeLength(length);
 469     }
 470 
<a name="30" id="anc30"></a><span class="line-added"> 471     JSRopeString(VM&amp; vm)</span>
<span class="line-added"> 472         : JSString(vm)</span>
<span class="line-added"> 473     {</span>
<span class="line-added"> 474         initializeIsSubstring(false);</span>
<span class="line-added"> 475         initializeLength(0);</span>
<span class="line-added"> 476         initializeIs8Bit(true);</span>
<span class="line-added"> 477         initializeFiber0(nullptr);</span>
<span class="line-added"> 478         initializeFiber1(nullptr);</span>
<span class="line-added"> 479         initializeFiber2(nullptr);</span>
<span class="line-added"> 480     }</span>
<span class="line-added"> 481 </span>
 482     JSRopeString(VM&amp; vm, JSString* s1, JSString* s2)
 483         : JSString(vm)
 484     {
 485         ASSERT(!sumOverflows&lt;int32_t&gt;(s1-&gt;length(), s2-&gt;length()));
 486         initializeIsSubstring(false);
 487         initializeLength(s1-&gt;length() + s2-&gt;length());
 488         initializeIs8Bit(s1-&gt;is8Bit() &amp;&amp; s2-&gt;is8Bit());
 489         initializeFiber0(s1);
 490         initializeFiber1(s2);
 491         initializeFiber2(nullptr);
 492         ASSERT((s1-&gt;length() + s2-&gt;length()) == length());
 493     }
 494 
 495     JSRopeString(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 496         : JSString(vm)
 497     {
 498         ASSERT(!sumOverflows&lt;int32_t&gt;(s1-&gt;length(), s2-&gt;length(), s3-&gt;length()));
 499         initializeIsSubstring(false);
 500         initializeLength(s1-&gt;length() + s2-&gt;length() + s3-&gt;length());
 501         initializeIs8Bit(s1-&gt;is8Bit() &amp;&amp; s2-&gt;is8Bit() &amp;&amp;  s3-&gt;is8Bit());
 502         initializeFiber0(s1);
 503         initializeFiber1(s2);
 504         initializeFiber2(s3);
 505         ASSERT((s1-&gt;length() + s2-&gt;length() + s3-&gt;length()) == length());
 506     }
 507 
 508     JSRopeString(VM&amp; vm, JSString* base, unsigned offset, unsigned length)
 509         : JSString(vm)
<a name="31" id="anc31"></a>



















 510     {
 511         RELEASE_ASSERT(!sumOverflows&lt;int32_t&gt;(offset, length));
 512         RELEASE_ASSERT(offset + length &lt;= base-&gt;length());
 513         initializeIsSubstring(true);
 514         initializeLength(length);
 515         initializeIs8Bit(base-&gt;is8Bit());
 516         initializeSubstringBase(base);
 517         initializeSubstringOffset(offset);
 518         ASSERT(length == this-&gt;length());
<a name="32" id="anc32"></a><span class="line-modified"> 519         ASSERT(!base-&gt;isRope());</span>










 520     }
 521 
 522     ALWAYS_INLINE void finishCreationSubstringOfResolved(VM&amp; vm)
 523     {
 524         Base::finishCreation(vm);
 525     }
 526 
 527 public:
 528     static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfLength(); } // 32byte width.
<a name="33" id="anc33"></a><span class="line-added"> 529     static ptrdiff_t offsetOfFlags() { return offsetOfValue(); }</span>
 530     static ptrdiff_t offsetOfFiber0() { return offsetOfValue(); }
<a name="34" id="anc34"></a><span class="line-modified"> 531     static ptrdiff_t offsetOfFiber1() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber1(); }</span>
<span class="line-modified"> 532     static ptrdiff_t offsetOfFiber2() { return OBJECT_OFFSETOF(JSRopeString, m_compactFibers) + CompactFibers::offsetOfFiber2(); }</span>














 533 
 534     static constexpr unsigned s_maxInternalRopeLength = 3;
 535 
<a name="35" id="anc35"></a><span class="line-added"> 536     // This JSRopeString is only used to simulate half-baked JSRopeString in DFG and FTL MakeRope. If OSR exit happens in</span>
<span class="line-added"> 537     // the middle of MakeRope due to string length overflow, we have half-baked JSRopeString which is the same to the result</span>
<span class="line-added"> 538     // of this function. This half-baked JSRopeString will not be exposed to users, but still collectors can see it due to</span>
<span class="line-added"> 539     // the conservative stack scan. This JSRopeString is used to test the collector with such a half-baked JSRopeString.</span>
<span class="line-added"> 540     // Because this JSRopeString breaks the JSString&#39;s invariant (only one singleton JSString can be zero length), almost all the</span>
<span class="line-added"> 541     // operations in JS fail to handle this string correctly.</span>
<span class="line-added"> 542     static JSRopeString* createNullForTesting(VM&amp; vm)</span>
<span class="line-added"> 543     {</span>
<span class="line-added"> 544         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm);</span>
<span class="line-added"> 545         newString-&gt;finishCreation(vm);</span>
<span class="line-added"> 546         ASSERT(!newString-&gt;length());</span>
<span class="line-added"> 547         ASSERT(newString-&gt;isRope());</span>
<span class="line-added"> 548         ASSERT(newString-&gt;fiber0() == nullptr);</span>
<span class="line-added"> 549         return newString;</span>
<span class="line-added"> 550     }</span>
<span class="line-added"> 551 </span>
 552 private:
 553     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2)
 554     {
 555         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2);
 556         newString-&gt;finishCreation(vm);
 557         ASSERT(newString-&gt;length());
<a name="36" id="anc36"></a><span class="line-added"> 558         ASSERT(newString-&gt;isRope());</span>
 559         return newString;
 560     }
 561     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 562     {
 563         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2, s3);
 564         newString-&gt;finishCreation(vm);
 565         ASSERT(newString-&gt;length());
<a name="37" id="anc37"></a><span class="line-modified"> 566         ASSERT(newString-&gt;isRope());</span>







 567         return newString;
 568     }
 569 
 570     ALWAYS_INLINE static JSRopeString* createSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* base, unsigned offset, unsigned length)
 571     {
<a name="38" id="anc38"></a><span class="line-modified"> 572         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap, deferralContext)) JSRopeString(vm, base, offset, length);</span>
 573         newString-&gt;finishCreationSubstringOfResolved(vm);
 574         ASSERT(newString-&gt;length());
<a name="39" id="anc39"></a><span class="line-added"> 575         ASSERT(newString-&gt;isRope());</span>
 576         return newString;
 577     }
 578 
 579     friend JSValue jsStringFromRegisterArray(ExecState*, Register*, unsigned);
 580     friend JSValue jsStringFromArguments(ExecState*, JSValue);
 581 
 582     // If nullOrExecForOOM is null, resolveRope() will be do nothing in the event of an OOM error.
 583     // The rope value will remain a null string in that case.
 584     JS_EXPORT_PRIVATE const String&amp; resolveRope(ExecState* nullOrExecForOOM) const;
 585     template&lt;typename Function&gt; const String&amp; resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp;) const;
<a name="40" id="anc40"></a><span class="line-modified"> 586     JS_EXPORT_PRIVATE AtomString resolveRopeToAtomString(ExecState*) const;</span>
<span class="line-modified"> 587     JS_EXPORT_PRIVATE RefPtr&lt;AtomStringImpl&gt; resolveRopeToExistingAtomString(ExecState*) const;</span>
 588     void resolveRopeSlowCase8(LChar*) const;
 589     void resolveRopeSlowCase(UChar*) const;
 590     void outOfMemory(ExecState* nullOrExecForOOM) const;
 591     void resolveRopeInternal8(LChar*) const;
 592     void resolveRopeInternal8NoSubstring(LChar*) const;
 593     void resolveRopeInternal16(UChar*) const;
 594     void resolveRopeInternal16NoSubstring(UChar*) const;
 595     StringView unsafeView(ExecState*) const;
 596     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;
 597 
 598     JSString* fiber0() const
 599     {
 600         return bitwise_cast&lt;JSString*&gt;(m_fiber &amp; stringMask);
 601     }
 602 
 603     JSString* fiber1() const
 604     {
 605         return m_compactFibers.fiber1();
 606     }
 607 
 608     JSString* fiber2() const
 609     {
 610         return m_compactFibers.fiber2();
 611     }
 612 
 613     JSString* fiber(unsigned i) const
 614     {
 615         ASSERT(!isSubstring());
 616         ASSERT(i &lt; s_maxInternalRopeLength);
 617         switch (i) {
 618         case 0:
 619             return fiber0();
 620         case 1:
 621             return fiber1();
 622         case 2:
 623             return fiber2();
 624         }
 625         ASSERT_NOT_REACHED();
 626         return nullptr;
 627     }
 628 
 629     void initializeFiber0(JSString* fiber)
 630     {
 631         uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 632         ASSERT(!(pointer &amp; ~stringMask));
 633         m_fiber = (pointer | (m_fiber &amp; ~stringMask));
 634     }
 635 
 636     void initializeFiber1(JSString* fiber)
 637     {
 638         m_compactFibers.initializeFiber1(fiber);
 639     }
 640 
 641     void initializeFiber2(JSString* fiber)
 642     {
 643         m_compactFibers.initializeFiber2(fiber);
 644     }
 645 
 646     void initializeSubstringBase(JSString* fiber)
 647     {
 648         initializeFiber1(fiber);
 649     }
 650 
 651     JSString* substringBase() const { return fiber1(); }
 652 
 653     void initializeSubstringOffset(unsigned offset)
 654     {
 655         m_compactFibers.initializeFiber2(bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(offset)));
 656     }
 657 
 658     unsigned substringOffset() const
 659     {
 660         return static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(fiber2()));
 661     }
 662 
<a name="41" id="anc41"></a>



















 663     static_assert(s_maxInternalRopeLength &gt;= 2, &quot;&quot;);
 664     mutable CompactFibers m_compactFibers;
 665 
 666     friend JSString* jsString(ExecState*, JSString*, JSString*);
 667     friend JSString* jsString(ExecState*, const String&amp;, JSString*);
 668     friend JSString* jsString(ExecState*, JSString*, const String&amp;);
 669     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);
 670     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);
 671     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);
 672     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
 673     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);
 674 };
 675 
 676 JS_EXPORT_PRIVATE JSString* jsStringWithCacheSlowCase(VM&amp;, StringImpl&amp;);
 677 
 678 // JSString::is8Bit is safe to be called concurrently. Concurrent threads can access is8Bit even if the main thread
 679 // is in the middle of converting JSRopeString to JSString.
 680 ALWAYS_INLINE bool JSString::is8Bit() const
 681 {
 682     uintptr_t pointer = m_fiber;
 683     if (pointer &amp; isRopeInPointer) {
<a name="42" id="anc42"></a>
 684         // Do not load m_fiber twice. We should use the information in pointer.
 685         // Otherwise, JSRopeString may be converted to JSString between the first and second accesses.
 686         return pointer &amp; JSRopeString::is8BitInPointer;
<a name="43" id="anc43"></a>



 687     }
 688     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;is8Bit();
 689 }
 690 
 691 // JSString::length is safe to be called concurrently. Concurrent threads can access length even if the main thread
 692 // is in the middle of converting JSRopeString to JSString. This is OK because we never override the length bits
 693 // when we resolve a JSRopeString.
 694 ALWAYS_INLINE unsigned JSString::length() const
 695 {
 696     uintptr_t pointer = m_fiber;
 697     if (pointer &amp; isRopeInPointer)
 698         return jsCast&lt;const JSRopeString*&gt;(this)-&gt;length();
 699     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;length();
 700 }
 701 
 702 inline const StringImpl* JSString::tryGetValueImpl() const
 703 {
 704     uintptr_t pointer = m_fiber;
 705     if (pointer &amp; isRopeInPointer)
 706         return nullptr;
 707     return bitwise_cast&lt;StringImpl*&gt;(pointer);
 708 }
 709 
 710 inline JSString* asString(JSValue value)
 711 {
 712     ASSERT(value.asCell()-&gt;isString());
 713     return jsCast&lt;JSString*&gt;(value.asCell());
 714 }
 715 
 716 // This MUST NOT GC.
<a name="44" id="anc44"></a><span class="line-modified"> 717 inline JSString* jsEmptyString(VM&amp; vm)</span>
 718 {
<a name="45" id="anc45"></a><span class="line-modified"> 719     return vm.smallStrings.emptyString();</span>
 720 }
 721 
<a name="46" id="anc46"></a><span class="line-modified"> 722 ALWAYS_INLINE JSString* jsSingleCharacterString(VM&amp; vm, UChar c)</span>
 723 {
 724     if (validateDFGDoesGC)
<a name="47" id="anc47"></a><span class="line-modified"> 725         RELEASE_ASSERT(vm.heap.expectDoesGC());</span>
 726     if (c &lt;= maxSingleCharacterString)
<a name="48" id="anc48"></a><span class="line-modified"> 727         return vm.smallStrings.singleCharacterString(c);</span>
<span class="line-modified"> 728     return JSString::create(vm, StringImpl::create(&amp;c, 1));</span>
 729 }
 730 
<a name="49" id="anc49"></a><span class="line-modified"> 731 inline JSString* jsNontrivialString(VM&amp; vm, const String&amp; s)</span>
 732 {
 733     ASSERT(s.length() &gt; 1);
<a name="50" id="anc50"></a><span class="line-modified"> 734     return JSString::create(vm, *s.impl());</span>
 735 }
 736 
<a name="51" id="anc51"></a><span class="line-modified"> 737 inline JSString* jsNontrivialString(VM&amp; vm, String&amp;&amp; s)</span>
 738 {
 739     ASSERT(s.length() &gt; 1);
<a name="52" id="anc52"></a><span class="line-modified"> 740     return JSString::create(vm, s.releaseImpl().releaseNonNull());</span>
 741 }
 742 
 743 ALWAYS_INLINE Identifier JSString::toIdentifier(ExecState* exec) const
 744 {
<a name="53" id="anc53"></a><span class="line-modified"> 745     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 746     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 747     AtomString atomString = toAtomString(exec);</span>
<span class="line-added"> 748     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 749     return Identifier::fromString(vm, atomString);</span>
 750 }
 751 
<a name="54" id="anc54"></a><span class="line-modified"> 752 ALWAYS_INLINE AtomString JSString::toAtomString(ExecState* exec) const</span>
 753 {
 754     if (validateDFGDoesGC)
<a name="55" id="anc55"></a><span class="line-modified"> 755         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
 756     if (isRope())
<a name="56" id="anc56"></a><span class="line-modified"> 757         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToAtomString(exec);</span>
<span class="line-modified"> 758     return AtomString(valueInternal());</span>
 759 }
 760 
<a name="57" id="anc57"></a><span class="line-modified"> 761 ALWAYS_INLINE RefPtr&lt;AtomStringImpl&gt; JSString::toExistingAtomString(ExecState* exec) const</span>
 762 {
 763     if (validateDFGDoesGC)
<a name="58" id="anc58"></a><span class="line-modified"> 764         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
 765     if (isRope())
<a name="59" id="anc59"></a><span class="line-modified"> 766         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToExistingAtomString(exec);</span>
<span class="line-modified"> 767     if (valueInternal().impl()-&gt;isAtom())</span>
<span class="line-modified"> 768         return static_cast&lt;AtomStringImpl*&gt;(valueInternal().impl());</span>
<span class="line-modified"> 769     return AtomStringImpl::lookUp(valueInternal().impl());</span>
 770 }
 771 
 772 inline const String&amp; JSString::value(ExecState* exec) const
 773 {
 774     if (validateDFGDoesGC)
<a name="60" id="anc60"></a><span class="line-modified"> 775         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
 776     if (isRope())
 777         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(exec);
 778     return valueInternal();
 779 }
 780 
 781 inline const String&amp; JSString::tryGetValue(bool allocationAllowed) const
 782 {
 783     if (allocationAllowed) {
 784         if (validateDFGDoesGC)
<a name="61" id="anc61"></a><span class="line-modified"> 785             RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
<span class="line-modified"> 786         if (isRope()) {</span>
<span class="line-modified"> 787             // Pass nullptr for the ExecState so that resolveRope does not throw in the event of an OOM error.</span>
 788             return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(nullptr);
<a name="62" id="anc62"></a><span class="line-modified"> 789         }</span>
 790     } else
 791         RELEASE_ASSERT(!isRope());
 792     return valueInternal();
 793 }
 794 
 795 inline JSString* JSString::getIndex(ExecState* exec, unsigned i)
 796 {
 797     VM&amp; vm = exec-&gt;vm();
 798     auto scope = DECLARE_THROW_SCOPE(vm);
 799     ASSERT(canGetIndex(i));
 800     StringView view = unsafeView(exec);
 801     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="63" id="anc63"></a><span class="line-modified"> 802     return jsSingleCharacterString(vm, view[i]);</span>
 803 }
 804 
<a name="64" id="anc64"></a><span class="line-modified"> 805 inline JSString* jsString(VM&amp; vm, const String&amp; s)</span>
 806 {
 807     int size = s.length();
 808     if (!size)
<a name="65" id="anc65"></a><span class="line-modified"> 809         return vm.smallStrings.emptyString();</span>
 810     if (size == 1) {
 811         UChar c = s.characterAt(0);
 812         if (c &lt;= maxSingleCharacterString)
<a name="66" id="anc66"></a><span class="line-modified"> 813             return vm.smallStrings.singleCharacterString(c);</span>
 814     }
<a name="67" id="anc67"></a><span class="line-modified"> 815     return JSString::create(vm, *s.impl());</span>
 816 }
 817 
<a name="68" id="anc68"></a><span class="line-modified"> 818 inline JSString* jsSubstring(VM&amp; vm, ExecState* exec, JSString* base, unsigned offset, unsigned length)</span>
 819 {
<a name="69" id="anc69"></a><span class="line-modified"> 820     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-modified"> 821 </span>
<span class="line-modified"> 822     ASSERT(offset &lt;= base-&gt;length());</span>
<span class="line-added"> 823     ASSERT(length &lt;= base-&gt;length());</span>
<span class="line-added"> 824     ASSERT(offset + length &lt;= base-&gt;length());</span>
 825     if (!length)
 826         return vm.smallStrings.emptyString();
<a name="70" id="anc70"></a><span class="line-modified"> 827     if (!offset &amp;&amp; length == base-&gt;length())</span>
<span class="line-modified"> 828         return base;</span>
<span class="line-modified"> 829 </span>
<span class="line-added"> 830     // For now, let&#39;s not allow substrings with a rope base.</span>
<span class="line-added"> 831     // Resolve non-substring rope bases so we don&#39;t have to deal with it.</span>
<span class="line-added"> 832     // FIXME: Evaluate if this would be worth adding more branches.</span>
<span class="line-added"> 833     if (base-&gt;isSubstring()) {</span>
<span class="line-added"> 834         JSRopeString* baseRope = jsCast&lt;JSRopeString*&gt;(base);</span>
<span class="line-added"> 835         base = baseRope-&gt;substringBase();</span>
<span class="line-added"> 836         offset = baseRope-&gt;substringOffset() + offset;</span>
<span class="line-added"> 837         ASSERT(!base-&gt;isRope());</span>
<span class="line-added"> 838     } else if (base-&gt;isRope()) {</span>
<span class="line-added"> 839         jsCast&lt;JSRopeString*&gt;(base)-&gt;resolveRope(exec);</span>
<span class="line-added"> 840         RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 841     }</span>
<span class="line-added"> 842     return jsSubstringOfResolved(vm, nullptr, base, offset, length);</span>
 843 }
 844 
 845 inline JSString* jsSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* s, unsigned offset, unsigned length)
 846 {
 847     ASSERT(offset &lt;= s-&gt;length());
 848     ASSERT(length &lt;= s-&gt;length());
 849     ASSERT(offset + length &lt;= s-&gt;length());
<a name="71" id="anc71"></a><span class="line-added"> 850     ASSERT(!s-&gt;isRope());</span>
 851     if (!length)
 852         return vm.smallStrings.emptyString();
 853     if (!offset &amp;&amp; length == s-&gt;length())
 854         return s;
<a name="72" id="anc72"></a><span class="line-added"> 855     if (length == 1) {</span>
<span class="line-added"> 856         auto&amp; base = s-&gt;valueInternal();</span>
<span class="line-added"> 857         UChar character = base.characterAt(offset);</span>
<span class="line-added"> 858         if (character &lt;= maxSingleCharacterString)</span>
<span class="line-added"> 859             return vm.smallStrings.singleCharacterString(character);</span>
<span class="line-added"> 860     }</span>
 861     return JSRopeString::createSubstringOfResolved(vm, deferralContext, s, offset, length);
 862 }
 863 
 864 inline JSString* jsSubstringOfResolved(VM&amp; vm, JSString* s, unsigned offset, unsigned length)
 865 {
 866     return jsSubstringOfResolved(vm, nullptr, s, offset, length);
 867 }
 868 
 869 inline JSString* jsSubstring(ExecState* exec, JSString* s, unsigned offset, unsigned length)
 870 {
 871     return jsSubstring(exec-&gt;vm(), exec, s, offset, length);
 872 }
 873 
<a name="73" id="anc73"></a><span class="line-modified"> 874 inline JSString* jsSubstring(VM&amp; vm, const String&amp; s, unsigned offset, unsigned length)</span>
 875 {
 876     ASSERT(offset &lt;= s.length());
 877     ASSERT(length &lt;= s.length());
 878     ASSERT(offset + length &lt;= s.length());
 879     if (!length)
<a name="74" id="anc74"></a><span class="line-modified"> 880         return vm.smallStrings.emptyString();</span>
 881     if (length == 1) {
 882         UChar c = s.characterAt(offset);
 883         if (c &lt;= maxSingleCharacterString)
<a name="75" id="anc75"></a><span class="line-modified"> 884             return vm.smallStrings.singleCharacterString(c);</span>
 885     }
 886     auto impl = StringImpl::createSubstringSharingImpl(*s.impl(), offset, length);
 887     if (impl-&gt;isSubString())
<a name="76" id="anc76"></a><span class="line-modified"> 888         return JSString::createHasOtherOwner(vm, WTFMove(impl));</span>
<span class="line-modified"> 889     return JSString::create(vm, WTFMove(impl));</span>
 890 }
 891 
<a name="77" id="anc77"></a><span class="line-modified"> 892 inline JSString* jsOwnedString(VM&amp; vm, const String&amp; s)</span>
 893 {
 894     int size = s.length();
 895     if (!size)
<a name="78" id="anc78"></a><span class="line-modified"> 896         return vm.smallStrings.emptyString();</span>
 897     if (size == 1) {
 898         UChar c = s.characterAt(0);
 899         if (c &lt;= maxSingleCharacterString)
<a name="79" id="anc79"></a><span class="line-modified"> 900             return vm.smallStrings.singleCharacterString(c);</span>
 901     }
<a name="80" id="anc80"></a><span class="line-modified"> 902     return JSString::createHasOtherOwner(vm, *s.impl());</span>
 903 }
 904 
<a name="81" id="anc81"></a>







 905 ALWAYS_INLINE JSString* jsStringWithCache(ExecState* exec, const String&amp; s)
 906 {
 907     VM&amp; vm = exec-&gt;vm();
 908     StringImpl* stringImpl = s.impl();
 909     if (!stringImpl || !stringImpl-&gt;length())
<a name="82" id="anc82"></a><span class="line-modified"> 910         return jsEmptyString(vm);</span>
 911 
 912     if (stringImpl-&gt;length() == 1) {
 913         UChar singleCharacter = (*stringImpl)[0u];
 914         if (singleCharacter &lt;= maxSingleCharacterString)
 915             return vm.smallStrings.singleCharacterString(static_cast&lt;unsigned char&gt;(singleCharacter));
 916     }
 917 
 918     if (JSString* lastCachedString = vm.lastCachedString.get()) {
 919         if (lastCachedString-&gt;tryGetValueImpl() == stringImpl)
 920             return lastCachedString;
 921     }
 922 
 923     return jsStringWithCacheSlowCase(vm, *stringImpl);
 924 }
 925 
 926 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 927 {
 928     VM&amp; vm = exec-&gt;vm();
 929     auto scope = DECLARE_THROW_SCOPE(vm);
 930 
 931     if (propertyName == vm.propertyNames-&gt;length) {
 932         slot.setValue(this, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, jsNumber(length()));
 933         return true;
 934     }
 935 
 936     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 937     if (index &amp;&amp; index.value() &lt; length()) {
 938         JSValue value = getIndex(exec, index.value());
 939         RETURN_IF_EXCEPTION(scope, false);
 940         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 941         return true;
 942     }
 943 
 944     return false;
 945 }
 946 
 947 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
 948 {
 949     VM&amp; vm = exec-&gt;vm();
 950     auto scope = DECLARE_THROW_SCOPE(vm);
 951 
 952     if (propertyName &lt; length()) {
 953         JSValue value = getIndex(exec, propertyName);
 954         RETURN_IF_EXCEPTION(scope, false);
 955         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 956         return true;
 957     }
 958 
 959     return false;
 960 }
 961 
 962 inline bool isJSString(JSCell* cell)
 963 {
 964     return cell-&gt;type() == StringType;
 965 }
 966 
 967 inline bool isJSString(JSValue v)
 968 {
 969     return v.isCell() &amp;&amp; isJSString(v.asCell());
 970 }
 971 
 972 ALWAYS_INLINE StringView JSRopeString::unsafeView(ExecState* exec) const
 973 {
 974     if (validateDFGDoesGC)
<a name="83" id="anc83"></a><span class="line-modified"> 975         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
 976     if (isSubstring()) {
 977         auto&amp; base = substringBase()-&gt;valueInternal();
 978         if (base.is8Bit())
 979             return StringView(base.characters8() + substringOffset(), length());
 980         return StringView(base.characters16() + substringOffset(), length());
 981     }
 982     return resolveRope(exec);
 983 }
 984 
 985 ALWAYS_INLINE StringViewWithUnderlyingString JSRopeString::viewWithUnderlyingString(ExecState* exec) const
 986 {
 987     if (validateDFGDoesGC)
<a name="84" id="anc84"></a><span class="line-modified"> 988         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
 989     if (isSubstring()) {
 990         auto&amp; base = substringBase()-&gt;valueInternal();
 991         if (base.is8Bit())
 992             return { { base.characters8() + substringOffset(), length() }, base };
 993         return { { base.characters16() + substringOffset(), length() }, base };
 994     }
 995     auto&amp; string = resolveRope(exec);
 996     return { string, string };
 997 }
 998 
 999 ALWAYS_INLINE StringView JSString::unsafeView(ExecState* exec) const
1000 {
1001     if (validateDFGDoesGC)
<a name="85" id="anc85"></a><span class="line-modified">1002         RELEASE_ASSERT(vm().heap.expectDoesGC());</span>
1003     if (isRope())
1004         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;unsafeView(exec);
1005     return valueInternal();
1006 }
1007 
1008 ALWAYS_INLINE StringViewWithUnderlyingString JSString::viewWithUnderlyingString(ExecState* exec) const
1009 {
1010     if (isRope())
1011         return static_cast&lt;const JSRopeString&amp;&gt;(*this).viewWithUnderlyingString(exec);
1012     return { valueInternal(), valueInternal() };
1013 }
1014 
1015 inline bool JSString::isSubstring() const
1016 {
<a name="86" id="anc86"></a><span class="line-modified">1017     return m_fiber &amp; JSRopeString::isSubstringInPointer;</span>
1018 }
1019 
1020 // --- JSValue inlines ----------------------------
1021 
1022 inline bool JSValue::toBoolean(ExecState* exec) const
1023 {
1024     if (isInt32())
1025         return asInt32();
1026     if (isDouble())
1027         return asDouble() &gt; 0.0 || asDouble() &lt; 0.0; // false for NaN
1028     if (isCell())
1029         return asCell()-&gt;toBoolean(exec);
1030     return isTrue(); // false, null, and undefined all convert to false.
1031 }
1032 
1033 inline JSString* JSValue::toString(ExecState* exec) const
1034 {
1035     if (isString())
1036         return asString(asCell());
1037     bool returnEmptyStringOnError = true;
1038     return toStringSlowCase(exec, returnEmptyStringOnError);
1039 }
1040 
1041 inline JSString* JSValue::toStringOrNull(ExecState* exec) const
1042 {
1043     if (isString())
1044         return asString(asCell());
1045     bool returnEmptyStringOnError = false;
1046     return toStringSlowCase(exec, returnEmptyStringOnError);
1047 }
1048 
1049 inline String JSValue::toWTFString(ExecState* exec) const
1050 {
1051     if (isString())
1052         return static_cast&lt;JSString*&gt;(asCell())-&gt;value(exec);
1053     return toWTFStringSlowCase(exec);
1054 }
1055 
1056 } // namespace JSC
<a name="87" id="anc87"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="87" type="hidden" />
</body>
</html>