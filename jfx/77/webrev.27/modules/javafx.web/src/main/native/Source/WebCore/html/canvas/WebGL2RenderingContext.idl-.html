<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.idl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 typedef unsigned long      GLenum;
 27 typedef boolean            GLboolean;
 28 typedef unsigned long      GLbitfield;
 29 typedef byte               GLbyte;
 30 typedef short              GLshort;
 31 typedef long               GLint;
 32 typedef long               GLsizei;
 33 typedef long long          GLintptr;
 34 typedef long long          GLsizeiptr;
 35 typedef long long          GLint64;
 36 typedef octet              GLubyte;
 37 typedef unsigned short     GLushort;
 38 typedef unsigned long      GLuint;
 39 typedef unsigned long long GLuint64;
 40 typedef unrestricted float GLfloat;
 41 typedef unrestricted float GLclampf;
 42 typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
 43 typedef (Float32Array or sequence&lt;GLfloat&gt;) Float32List;
 44 typedef (Int32Array or sequence&lt;GLint&gt;) Int32List;
 45 typedef (Uint32Array or sequence&lt;GLuint&gt;) Uint32List;
 46 
 47 #ifdef ENABLE_VIDEO
 48 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement or HTMLVideoElement) TexImageSource;
 49 #else
 50 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement) TexImageSource;
 51 #endif
 52 
 53 [
 54     Conditional=WEBGL2,
 55     EnabledAtRuntime=WebGL2,
 56     JSCustomMarkFunction,
 57     JSGenerateToJSObject,
 58     DoNotCheckConstants,
 59 ] interface WebGL2RenderingContext {
 60     const GLenum READ_BUFFER                                   = 0x0C02;
 61     const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
 62     const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
 63     const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
 64     const GLenum PACK_ROW_LENGTH                               = 0x0D02;
 65     const GLenum PACK_SKIP_ROWS                                = 0x0D03;
 66     const GLenum PACK_SKIP_PIXELS                              = 0x0D04;
 67     const GLenum COLOR                                         = 0x1800;
 68     const GLenum DEPTH                                         = 0x1801;
 69     const GLenum STENCIL                                       = 0x1802;
 70     const GLenum RED                                           = 0x1903;
 71     const GLenum RGB8                                          = 0x8051;
 72     const GLenum RGBA8                                         = 0x8058;
 73     const GLenum RGB10_A2                                      = 0x8059;
 74     const GLenum TEXTURE_BINDING_3D                            = 0x806A;
 75     const GLenum UNPACK_SKIP_IMAGES                            = 0x806D;
 76     const GLenum UNPACK_IMAGE_HEIGHT                           = 0x806E;
 77     const GLenum TEXTURE_3D                                    = 0x806F;
 78     const GLenum TEXTURE_WRAP_R                                = 0x8072;
 79     const GLenum MAX_3D_TEXTURE_SIZE                           = 0x8073;
 80     const GLenum UNSIGNED_INT_2_10_10_10_REV                   = 0x8368;
 81     const GLenum MAX_ELEMENTS_VERTICES                         = 0x80E8;
 82     const GLenum MAX_ELEMENTS_INDICES                          = 0x80E9;
 83     const GLenum TEXTURE_MIN_LOD                               = 0x813A;
 84     const GLenum TEXTURE_MAX_LOD                               = 0x813B;
 85     const GLenum TEXTURE_BASE_LEVEL                            = 0x813C;
 86     const GLenum TEXTURE_MAX_LEVEL                             = 0x813D;
 87     const GLenum MIN                                           = 0x8007;
 88     const GLenum MAX                                           = 0x8008;
 89     const GLenum DEPTH_COMPONENT24                             = 0x81A6;
 90     const GLenum MAX_TEXTURE_LOD_BIAS                          = 0x84FD;
 91     const GLenum TEXTURE_COMPARE_MODE                          = 0x884C;
 92     const GLenum TEXTURE_COMPARE_FUNC                          = 0x884D;
 93     const GLenum CURRENT_QUERY                                 = 0x8865;
 94     const GLenum QUERY_RESULT                                  = 0x8866;
 95     const GLenum QUERY_RESULT_AVAILABLE                        = 0x8867;
 96     const GLenum STREAM_READ                                   = 0x88E1;
 97     const GLenum STREAM_COPY                                   = 0x88E2;
 98     const GLenum STATIC_READ                                   = 0x88E5;
 99     const GLenum STATIC_COPY                                   = 0x88E6;
100     const GLenum DYNAMIC_READ                                  = 0x88E9;
101     const GLenum DYNAMIC_COPY                                  = 0x88EA;
102     const GLenum MAX_DRAW_BUFFERS                              = 0x8824;
103     const GLenum DRAW_BUFFER0                                  = 0x8825;
104     const GLenum DRAW_BUFFER1                                  = 0x8826;
105     const GLenum DRAW_BUFFER2                                  = 0x8827;
106     const GLenum DRAW_BUFFER3                                  = 0x8828;
107     const GLenum DRAW_BUFFER4                                  = 0x8829;
108     const GLenum DRAW_BUFFER5                                  = 0x882A;
109     const GLenum DRAW_BUFFER6                                  = 0x882B;
110     const GLenum DRAW_BUFFER7                                  = 0x882C;
111     const GLenum DRAW_BUFFER8                                  = 0x882D;
112     const GLenum DRAW_BUFFER9                                  = 0x882E;
113     const GLenum DRAW_BUFFER10                                 = 0x882F;
114     const GLenum DRAW_BUFFER11                                 = 0x8830;
115     const GLenum DRAW_BUFFER12                                 = 0x8831;
116     const GLenum DRAW_BUFFER13                                 = 0x8832;
117     const GLenum DRAW_BUFFER14                                 = 0x8833;
118     const GLenum DRAW_BUFFER15                                 = 0x8834;
119     const GLenum MAX_FRAGMENT_UNIFORM_COMPONENTS               = 0x8B49;
120     const GLenum MAX_VERTEX_UNIFORM_COMPONENTS                 = 0x8B4A;
121     const GLenum SAMPLER_3D                                    = 0x8B5F;
122     const GLenum SAMPLER_2D_SHADOW                             = 0x8B62;
123     const GLenum FRAGMENT_SHADER_DERIVATIVE_HINT               = 0x8B8B;
124     const GLenum PIXEL_PACK_BUFFER                             = 0x88EB;
125     const GLenum PIXEL_UNPACK_BUFFER                           = 0x88EC;
126     const GLenum PIXEL_PACK_BUFFER_BINDING                     = 0x88ED;
127     const GLenum PIXEL_UNPACK_BUFFER_BINDING                   = 0x88EF;
128     const GLenum FLOAT_MAT2x3                                  = 0x8B65;
129     const GLenum FLOAT_MAT2x4                                  = 0x8B66;
130     const GLenum FLOAT_MAT3x2                                  = 0x8B67;
131     const GLenum FLOAT_MAT3x4                                  = 0x8B68;
132     const GLenum FLOAT_MAT4x2                                  = 0x8B69;
133     const GLenum FLOAT_MAT4x3                                  = 0x8B6A;
134     const GLenum SRGB                                          = 0x8C40;
135     const GLenum SRGB8                                         = 0x8C41;
136     const GLenum SRGB8_ALPHA8                                  = 0x8C43;
137     const GLenum COMPARE_REF_TO_TEXTURE                        = 0x884E;
138     const GLenum RGBA32F                                       = 0x8814;
139     const GLenum RGB32F                                        = 0x8815;
140     const GLenum RGBA16F                                       = 0x881A;
141     const GLenum RGB16F                                        = 0x881B;
142     const GLenum VERTEX_ATTRIB_ARRAY_INTEGER                   = 0x88FD;
143     const GLenum MAX_ARRAY_TEXTURE_LAYERS                      = 0x88FF;
144     const GLenum MIN_PROGRAM_TEXEL_OFFSET                      = 0x8904;
145     const GLenum MAX_PROGRAM_TEXEL_OFFSET                      = 0x8905;
146     const GLenum MAX_VARYING_COMPONENTS                        = 0x8B4B;
147     const GLenum TEXTURE_2D_ARRAY                              = 0x8C1A;
148     const GLenum TEXTURE_BINDING_2D_ARRAY                      = 0x8C1D;
149     const GLenum R11F_G11F_B10F                                = 0x8C3A;
150     const GLenum UNSIGNED_INT_10F_11F_11F_REV                  = 0x8C3B;
151     const GLenum RGB9_E5                                       = 0x8C3D;
152     const GLenum UNSIGNED_INT_5_9_9_9_REV                      = 0x8C3E;
153     const GLenum TRANSFORM_FEEDBACK_BUFFER_MODE                = 0x8C7F;
154     const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS    = 0x8C80;
155     const GLenum TRANSFORM_FEEDBACK_VARYINGS                   = 0x8C83;
156     const GLenum TRANSFORM_FEEDBACK_BUFFER_START               = 0x8C84;
157     const GLenum TRANSFORM_FEEDBACK_BUFFER_SIZE                = 0x8C85;
158     const GLenum TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN         = 0x8C88;
159     const GLenum RASTERIZER_DISCARD                            = 0x8C89;
160     const GLenum MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
161     const GLenum MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS       = 0x8C8B;
162     const GLenum INTERLEAVED_ATTRIBS                           = 0x8C8C;
163     const GLenum SEPARATE_ATTRIBS                              = 0x8C8D;
164     const GLenum TRANSFORM_FEEDBACK_BUFFER                     = 0x8C8E;
165     const GLenum TRANSFORM_FEEDBACK_BUFFER_BINDING             = 0x8C8F;
166     const GLenum RGBA32UI                                      = 0x8D70;
167     const GLenum RGB32UI                                       = 0x8D71;
168     const GLenum RGBA16UI                                      = 0x8D76;
169     const GLenum RGB16UI                                       = 0x8D77;
170     const GLenum RGBA8UI                                       = 0x8D7C;
171     const GLenum RGB8UI                                        = 0x8D7D;
172     const GLenum RGBA32I                                       = 0x8D82;
173     const GLenum RGB32I                                        = 0x8D83;
174     const GLenum RGBA16I                                       = 0x8D88;
175     const GLenum RGB16I                                        = 0x8D89;
176     const GLenum RGBA8I                                        = 0x8D8E;
177     const GLenum RGB8I                                         = 0x8D8F;
178     const GLenum RED_INTEGER                                   = 0x8D94;
179     const GLenum RGB_INTEGER                                   = 0x8D98;
180     const GLenum RGBA_INTEGER                                  = 0x8D99;
181     const GLenum SAMPLER_2D_ARRAY                              = 0x8DC1;
182     const GLenum SAMPLER_2D_ARRAY_SHADOW                       = 0x8DC4;
183     const GLenum SAMPLER_CUBE_SHADOW                           = 0x8DC5;
184     const GLenum UNSIGNED_INT_VEC2                             = 0x8DC6;
185     const GLenum UNSIGNED_INT_VEC3                             = 0x8DC7;
186     const GLenum UNSIGNED_INT_VEC4                             = 0x8DC8;
187     const GLenum INT_SAMPLER_2D                                = 0x8DCA;
188     const GLenum INT_SAMPLER_3D                                = 0x8DCB;
189     const GLenum INT_SAMPLER_CUBE                              = 0x8DCC;
190     const GLenum INT_SAMPLER_2D_ARRAY                          = 0x8DCF;
191     const GLenum UNSIGNED_INT_SAMPLER_2D                       = 0x8DD2;
192     const GLenum UNSIGNED_INT_SAMPLER_3D                       = 0x8DD3;
193     const GLenum UNSIGNED_INT_SAMPLER_CUBE                     = 0x8DD4;
194     const GLenum UNSIGNED_INT_SAMPLER_2D_ARRAY                 = 0x8DD7;
195     const GLenum DEPTH_COMPONENT32F                            = 0x8CAC;
196     const GLenum DEPTH32F_STENCIL8                             = 0x8CAD;
197     const GLenum FLOAT_32_UNSIGNED_INT_24_8_REV                = 0x8DAD;
198     const GLenum FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING         = 0x8210;
199     const GLenum FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE         = 0x8211;
200     const GLenum FRAMEBUFFER_ATTACHMENT_RED_SIZE               = 0x8212;
201     const GLenum FRAMEBUFFER_ATTACHMENT_GREEN_SIZE             = 0x8213;
202     const GLenum FRAMEBUFFER_ATTACHMENT_BLUE_SIZE              = 0x8214;
203     const GLenum FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE             = 0x8215;
204     const GLenum FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE             = 0x8216;
205     const GLenum FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE           = 0x8217;
206     const GLenum FRAMEBUFFER_DEFAULT                           = 0x8218;
207     const GLenum DEPTH_STENCIL_ATTACHMENT                      = 0x821A;
208     const GLenum DEPTH_STENCIL                                 = 0x84F9;
209     const GLenum UNSIGNED_INT_24_8                             = 0x84FA;
210     const GLenum DEPTH24_STENCIL8                              = 0x88F0;
211     const GLenum UNSIGNED_NORMALIZED                           = 0x8C17;
212     const GLenum DRAW_FRAMEBUFFER_BINDING                      = 0x8CA6; /* Same as FRAMEBUFFER_BINDING */
213     const GLenum READ_FRAMEBUFFER                              = 0x8CA8;
214     const GLenum DRAW_FRAMEBUFFER                              = 0x8CA9;
215     const GLenum READ_FRAMEBUFFER_BINDING                      = 0x8CAA;
216     const GLenum RENDERBUFFER_SAMPLES                          = 0x8CAB;
217     const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER          = 0x8CD4;
218     const GLenum MAX_COLOR_ATTACHMENTS                         = 0x8CDF;
219     const GLenum COLOR_ATTACHMENT1                             = 0x8CE1;
220     const GLenum COLOR_ATTACHMENT2                             = 0x8CE2;
221     const GLenum COLOR_ATTACHMENT3                             = 0x8CE3;
222     const GLenum COLOR_ATTACHMENT4                             = 0x8CE4;
223     const GLenum COLOR_ATTACHMENT5                             = 0x8CE5;
224     const GLenum COLOR_ATTACHMENT6                             = 0x8CE6;
225     const GLenum COLOR_ATTACHMENT7                             = 0x8CE7;
226     const GLenum COLOR_ATTACHMENT8                             = 0x8CE8;
227     const GLenum COLOR_ATTACHMENT9                             = 0x8CE9;
228     const GLenum COLOR_ATTACHMENT10                            = 0x8CEA;
229     const GLenum COLOR_ATTACHMENT11                            = 0x8CEB;
230     const GLenum COLOR_ATTACHMENT12                            = 0x8CEC;
231     const GLenum COLOR_ATTACHMENT13                            = 0x8CED;
232     const GLenum COLOR_ATTACHMENT14                            = 0x8CEE;
233     const GLenum COLOR_ATTACHMENT15                            = 0x8CEF;
234     const GLenum FRAMEBUFFER_INCOMPLETE_MULTISAMPLE            = 0x8D56;
235     const GLenum MAX_SAMPLES                                   = 0x8D57;
236     const GLenum HALF_FLOAT                                    = 0x140B;
237     const GLenum RG                                            = 0x8227;
238     const GLenum RG_INTEGER                                    = 0x8228;
239     const GLenum R8                                            = 0x8229;
240     const GLenum RG8                                           = 0x822B;
241     const GLenum R16F                                          = 0x822D;
242     const GLenum R32F                                          = 0x822E;
243     const GLenum RG16F                                         = 0x822F;
244     const GLenum RG32F                                         = 0x8230;
245     const GLenum R8I                                           = 0x8231;
246     const GLenum R8UI                                          = 0x8232;
247     const GLenum R16I                                          = 0x8233;
248     const GLenum R16UI                                         = 0x8234;
249     const GLenum R32I                                          = 0x8235;
250     const GLenum R32UI                                         = 0x8236;
251     const GLenum RG8I                                          = 0x8237;
252     const GLenum RG8UI                                         = 0x8238;
253     const GLenum RG16I                                         = 0x8239;
254     const GLenum RG16UI                                        = 0x823A;
255     const GLenum RG32I                                         = 0x823B;
256     const GLenum RG32UI                                        = 0x823C;
257     const GLenum VERTEX_ARRAY_BINDING                          = 0x85B5;
258     const GLenum R8_SNORM                                      = 0x8F94;
259     const GLenum RG8_SNORM                                     = 0x8F95;
260     const GLenum RGB8_SNORM                                    = 0x8F96;
261     const GLenum RGBA8_SNORM                                   = 0x8F97;
262     const GLenum SIGNED_NORMALIZED                             = 0x8F9C;
263     const GLenum COPY_READ_BUFFER                              = 0x8F36;
264     const GLenum COPY_WRITE_BUFFER                             = 0x8F37;
265     const GLenum COPY_READ_BUFFER_BINDING                      = 0x8F36; /* Same as COPY_READ_BUFFER */
266     const GLenum COPY_WRITE_BUFFER_BINDING                     = 0x8F37; /* Same as COPY_WRITE_BUFFER */
267     const GLenum UNIFORM_BUFFER                                = 0x8A11;
268     const GLenum UNIFORM_BUFFER_BINDING                        = 0x8A28;
269     const GLenum UNIFORM_BUFFER_START                          = 0x8A29;
270     const GLenum UNIFORM_BUFFER_SIZE                           = 0x8A2A;
271     const GLenum MAX_VERTEX_UNIFORM_BLOCKS                     = 0x8A2B;
272     const GLenum MAX_FRAGMENT_UNIFORM_BLOCKS                   = 0x8A2D;
273     const GLenum MAX_COMBINED_UNIFORM_BLOCKS                   = 0x8A2E;
274     const GLenum MAX_UNIFORM_BUFFER_BINDINGS                   = 0x8A2F;
275     const GLenum MAX_UNIFORM_BLOCK_SIZE                        = 0x8A30;
276     const GLenum MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS        = 0x8A31;
277     const GLenum MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS      = 0x8A33;
278     const GLenum UNIFORM_BUFFER_OFFSET_ALIGNMENT               = 0x8A34;
279     const GLenum ACTIVE_UNIFORM_BLOCKS                         = 0x8A36;
280     const GLenum UNIFORM_TYPE                                  = 0x8A37;
281     const GLenum UNIFORM_SIZE                                  = 0x8A38;
282     const GLenum UNIFORM_BLOCK_INDEX                           = 0x8A3A;
283     const GLenum UNIFORM_OFFSET                                = 0x8A3B;
284     const GLenum UNIFORM_ARRAY_STRIDE                          = 0x8A3C;
285     const GLenum UNIFORM_MATRIX_STRIDE                         = 0x8A3D;
286     const GLenum UNIFORM_IS_ROW_MAJOR                          = 0x8A3E;
287     const GLenum UNIFORM_BLOCK_BINDING                         = 0x8A3F;
288     const GLenum UNIFORM_BLOCK_DATA_SIZE                       = 0x8A40;
289     const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORMS                 = 0x8A42;
290     const GLenum UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES          = 0x8A43;
291     const GLenum UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER     = 0x8A44;
292     const GLenum UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER   = 0x8A46;
293     const GLenum INVALID_INDEX                                 = 0xFFFFFFFF;
294     const GLenum MAX_VERTEX_OUTPUT_COMPONENTS                  = 0x9122;
295     const GLenum MAX_FRAGMENT_INPUT_COMPONENTS                 = 0x9125;
296     const GLenum MAX_SERVER_WAIT_TIMEOUT                       = 0x9111;
297     const GLenum OBJECT_TYPE                                   = 0x9112;
298     const GLenum SYNC_CONDITION                                = 0x9113;
299     const GLenum SYNC_STATUS                                   = 0x9114;
300     const GLenum SYNC_FLAGS                                    = 0x9115;
301     const GLenum SYNC_FENCE                                    = 0x9116;
302     const GLenum SYNC_GPU_COMMANDS_COMPLETE                    = 0x9117;
303     const GLenum UNSIGNALED                                    = 0x9118;
304     const GLenum SIGNALED                                      = 0x9119;
305     const GLenum ALREADY_SIGNALED                              = 0x911A;
306     const GLenum TIMEOUT_EXPIRED                               = 0x911B;
307     const GLenum CONDITION_SATISFIED                           = 0x911C;
308     const GLenum WAIT_FAILED                                   = 0x911D;
309     const GLenum SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001;
310     const GLenum VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE;
311     const GLenum ANY_SAMPLES_PASSED                            = 0x8C2F;
312     const GLenum ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A;
313     const GLenum SAMPLER_BINDING                               = 0x8919;
314     const GLenum RGB10_A2UI                                    = 0x906F;
315     const GLenum INT_2_10_10_10_REV                            = 0x8D9F;
316     const GLenum TRANSFORM_FEEDBACK                            = 0x8E22;
317     const GLenum TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23;
318     const GLenum TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24;
319     const GLenum TRANSFORM_FEEDBACK_BINDING                    = 0x8E25;
320     const GLenum TEXTURE_IMMUTABLE_FORMAT                      = 0x912F;
321     const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
322     const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;
323 
324     const GLint64 TIMEOUT_IGNORED                              = -1;
325 
326     /* WebGL-specific enums */
327     const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;
328 
329     /* Buffer objects */
330     void bufferData(GLenum target, ArrayBufferView data, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
331     void bufferSubData(GLenum target, GLintptr dstByteOffset, ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
332 
333     void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
334     // MapBufferRange, in particular its read-only and write-only modes,
335     // can not be exposed safely to JavaScript. GetBufferSubData
336     // replaces it for the purpose of fetching data back from the GPU.
337     void getBufferSubData(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstData, optional GLuint dstOffset = 0, optional GLuint length = 0);
338 
339     /* Framebuffer objects */
340     void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
341     void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer);
342     void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
343     void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
344     void readBuffer(GLenum src);
345 
346     /* Renderbuffer objects */
347     [OverrideIDLType=IDLWebGLAny] any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
348     void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
349 
350     /* Texture objects */
351     void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
352     void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
353 
354     // WebGL1 legacy entrypoints:
355     void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
356     [MayThrowException] void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, TexImageSource? source);
357 
358     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView? pixels);
359     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, TexImageSource? source);
360 
361     // WebGL2 entrypoints:
362     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
363     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, TexImageSource source);
364     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
365 
366     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
367     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexImageSource source);
368     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
369     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
370 
371     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);
372     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, TexImageSource source);
373     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
374 
375     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr pboOffset);
376     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexImageSource source);
377     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? srcData, optional GLuint srcOffset = 0);
378 
379     void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
380 
381     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);
382     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
383 
384     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
385     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
386     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset);
387     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
388 
389     /* Programs and shaders */
390     GLint getFragDataLocation(WebGLProgram program, DOMString name);
391 
392     /* Uniforms and attributes */
393     void uniform1ui(WebGLUniformLocation? location, GLuint v0);
394     void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
395     void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
396     void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
397     void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
398     void uniform2uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
399     void uniform3uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
400     void uniform4uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
401     void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
402     void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
403     void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
404     void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
405     void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
406     void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
407     void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
408     void vertexAttribI4iv(GLuint index, Int32List values);
409     void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
410     void vertexAttribI4uiv(GLuint index, Uint32List values);
411     void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
412 
413     /* Writing to the drawing buffer */
414     void vertexAttribDivisor(GLuint index, GLuint divisor);
415     void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
416     void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
417     void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);
418 
419     /* Multiple Render Targets */
420     void drawBuffers(sequence&lt;GLenum&gt; buffers);
421     void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values, optional GLuint srcOffset = 0);
422     void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values, optional GLuint srcOffset = 0);
423     void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values, optional GLuint srcOffset = 0);
424     void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
425 
426     /* Query Objects */
427     WebGLQuery? createQuery();
428     void deleteQuery(WebGLQuery? query);
429     GLboolean isQuery(WebGLQuery? query);
430     void beginQuery(GLenum target, WebGLQuery query);
431     void endQuery(GLenum target);
432     WebGLQuery? getQuery(GLenum target, GLenum pname);
433     [OverrideIDLType=IDLWebGLAny] any getQueryParameter(WebGLQuery query, GLenum pname);
434 
435     /* Sampler Objects */
436     WebGLSampler? createSampler();
437     void deleteSampler(WebGLSampler? sampler);
438     GLboolean isSampler(WebGLSampler? sampler);
439     void bindSampler(GLuint unit, WebGLSampler? sampler);
440     void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
441     void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
442     [OverrideIDLType=IDLWebGLAny] any getSamplerParameter(WebGLSampler sampler, GLenum pname);
443 
444     /* Sync objects */
445     WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
446     GLboolean isSync(WebGLSync? sync);
447     void deleteSync(WebGLSync? sync);
448     GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
449     void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
450     [OverrideIDLType=IDLWebGLAny] any getSyncParameter(WebGLSync sync, GLenum pname);
451 
452     /* Transform Feedback */
453     WebGLTransformFeedback? createTransformFeedback();
454     void deleteTransformFeedback(WebGLTransformFeedback? id);
455     GLboolean isTransformFeedback(WebGLTransformFeedback? id);
456     void bindTransformFeedback(GLenum target, WebGLTransformFeedback? id);
457     void beginTransformFeedback(GLenum primitiveMode);
458     void endTransformFeedback();
459     void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
460     WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
461     void pauseTransformFeedback();
462     void resumeTransformFeedback();
463 
464     /* Uniform Buffer Objects and Transform Feedback Buffers */
465     void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
466     void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
467     [OverrideIDLType=IDLWebGLAny] any getIndexedParameter(GLenum target, GLuint index);
468     sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
469     [OverrideIDLType=IDLWebGLAny] any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
470     GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
471     [OverrideIDLType=IDLWebGLAny] any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
472     [OverrideIDLType=IDLWebGLAny] DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
473     void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
474 
475     /* Vertex Array Objects */
476     WebGLVertexArrayObject? createVertexArray();
477     void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
478     GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
479     void bindVertexArray(WebGLVertexArrayObject? vertexArray);
480 };
481 
482 WebGL2RenderingContext implements WebGLRenderingContextBase;
    </pre>
  </body>
</html>