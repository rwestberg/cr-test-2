<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;VideoTextureCopierCV.h&quot;
 28 
 29 #if HAVE(CORE_VIDEO)
 30 
 31 #include &quot;FourCC.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;TextureCacheCV.h&quot;
 34 #include &lt;pal/spi/cocoa/IOSurfaceSPI.h&gt;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 #include &lt;wtf/StdMap.h&gt;
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 #if USE(OPENGL_ES)
 40 #include &lt;OpenGLES/ES3/glext.h&gt;
 41 #endif
 42 
 43 #include &quot;CoreVideoSoftLink.h&quot;
 44 
 45 namespace WebCore {
 46 
 47 #if HAVE(IOSURFACE)
 48 enum class PixelRange {
 49     Unknown,
 50     Video,
 51     Full,
 52 };
 53 
 54 enum class TransferFunction {
 55     Unknown,
 56     kITU_R_709_2,
 57     kITU_R_601_4,
 58     kSMPTE_240M_1995,
 59     kDCI_P3,
 60     kP3_D65,
 61     kITU_R_2020,
 62 };
 63 
 64 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
 65 {
 66     switch (pixelFormat) {
 67     case kCVPixelFormatType_4444AYpCbCr8:
 68     case kCVPixelFormatType_4444AYpCbCr16:
 69     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
 70     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
 71     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
 72     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
 73     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
 74         return PixelRange::Video;
 75     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
 76     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
 77     case kCVPixelFormatType_422YpCbCr8FullRange:
 78     case kCVPixelFormatType_ARGB2101010LEPacked:
 79     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
 80     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
 81     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
 82         return PixelRange::Full;
 83     default:
 84         return PixelRange::Unknown;
 85     }
 86 }
 87 
 88 static TransferFunction transferFunctionFromString(CFStringRef string)
 89 {
 90     if (!string || CFGetTypeID(string) != CFStringGetTypeID())
 91         return TransferFunction::Unknown;
 92     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
 93         return TransferFunction::kITU_R_709_2;
 94     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
 95         return TransferFunction::kITU_R_601_4;
 96     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
 97         return TransferFunction::kSMPTE_240M_1995;
 98     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
 99         return TransferFunction::kDCI_P3;
100     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
101         return TransferFunction::kP3_D65;
102     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
103         return TransferFunction::kITU_R_2020;
104     return TransferFunction::Unknown;
105 }
106 
107 struct GLfloatColor {
108     union {
109         struct {
110             GLfloat r;
111             GLfloat g;
112             GLfloat b;
113         } rgb;
114         struct {
115             GLfloat y;
116             GLfloat cb;
117             GLfloat cr;
118         } ycbcr;
119     };
120 
121     constexpr GLfloatColor(GLfloat r, GLfloat g, GLfloat b)
122         : rgb { r, g, b }
123     {
124     }
125 
126     constexpr GLfloatColor(int r, int g, int b, GLfloat scale)
127         : rgb { r / scale, g / scale, b / scale}
128     {
129     }
130 
131     static constexpr GLfloat abs(GLfloat value)
132     {
133         return value &gt;= 0 ? value : -value;
134     }
135 
136     constexpr bool isApproximatelyEqualTo(const GLfloatColor&amp; color, GLfloat maxDelta) const
137     {
138         return abs(rgb.r - color.rgb.r) &lt; abs(maxDelta)
139             &amp;&amp; abs(rgb.g - color.rgb.g) &lt; abs(maxDelta)
140             &amp;&amp; abs(rgb.b - color.rgb.b) &lt; abs(maxDelta);
141     }
142 };
143 
144 struct GLfloatColors {
145     static constexpr GLfloatColor black   {0, 0, 0};
146     static constexpr GLfloatColor white   {1, 1, 1};
147     static constexpr GLfloatColor red     {1, 0, 0};
148     static constexpr GLfloatColor green   {0, 1, 0};
149     static constexpr GLfloatColor blue    {0, 0, 1};
150     static constexpr GLfloatColor cyan    {0, 1, 1};
151     static constexpr GLfloatColor magenta {1, 0, 1};
152     static constexpr GLfloatColor yellow  {1, 1, 0};
153 };
154 
155 struct YCbCrMatrix {
156     union {
157         GLfloat rows[4][4];
158         GLfloat data[16];
159     };
160 
161     constexpr YCbCrMatrix(PixelRange, GLfloat cbCoefficient, GLfloat crCoefficient);
162 
163     operator Vector&lt;GLfloat&gt;() const
164     {
165         Vector&lt;GLfloat&gt; vector;
166         vector.append(data, 16);
167         return vector;
168     }
169 
170     constexpr GLfloatColor operator*(const GLfloatColor&amp;) const;
171 };
172 
173 constexpr YCbCrMatrix::YCbCrMatrix(PixelRange range, GLfloat cbCoefficient, GLfloat crCoefficient)
174     : rows { }
175 {
176     // The conversion from YCbCr -&gt; RGB generally takes the form:
177     // Y = Kr * R + Kg * G + Kb * B
178     // Cb = (B - Y) / (2 * (1 - Kb))
179     // Cr = (R - Y) / (2 * (1 - Kr))
180     // Where the values of Kb and Kr are defined in a specification and Kg is derived from: Kr + Kg + Kb = 1
181     //
182     // Solving the above equations for R, B, and G derives the following:
183     // R = Y + (2 * (1 - Kr)) * Cr
184     // B = Y + (2 * (1 - Kb)) * Cb
185     // G = Y - (2 * (1 - Kb)) * (Kb / Kg) * Cb - ((1 - Kr) * 2) * (Kr / Kg) * Cr
186     //
187     // When the color values are Video range, Y has a range of [16, 235] with a width of 219, and Cb &amp; Cr have
188     // a range of [16, 240] with a width of 224. When the color values are Full range, Y, Cb, and Cr all have
189     // a range of [0, 255] with a width of 256.
190 
191     GLfloat cgCoefficient = 1 - cbCoefficient - crCoefficient;
192     GLfloat yScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 219.f;
193     GLfloat cbcrScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 224.f;
194 
195     rows[0][0] = yScalingFactor;
196     rows[0][1] = 0;
197     rows[0][2] = cbcrScalingFactor * 2 * (1 - crCoefficient);
198     rows[0][3] = 0;
199 
200     rows[1][0] = yScalingFactor;
201     rows[1][1] = -cbcrScalingFactor * 2 * (1 - cbCoefficient) * (cbCoefficient / cgCoefficient);
202     rows[1][2] = -cbcrScalingFactor * 2 * (1 - crCoefficient) * (crCoefficient / cgCoefficient);
203     rows[1][3] = 0;
204 
205     rows[2][0] = yScalingFactor;
206     rows[2][1] = cbcrScalingFactor * 2 * (1 - cbCoefficient);
207     rows[2][2] = 0;
208     rows[2][3] = 0;
209 
210     rows[3][0] = 0;
211     rows[3][1] = 0;
212     rows[3][2] = 0;
213     rows[3][3] = 1;
214 
215     // Configure the final column of the matrix to convert Cb and Cr to [-128, 128]
216     // and, in the case of video-range, to convert Y to [16, 240]:
217     for (auto rowNumber = 0; rowNumber &lt; 3; ++rowNumber) {
218         auto&amp; row = rows[rowNumber];
219         auto&amp; x = row[0];
220         auto&amp; y = row[1];
221         auto&amp; z = row[2];
222         auto&amp; w = row[3];
223 
224         w -= (y + z) * 128 / 255;
225         if (range == PixelRange::Video)
226             w -= x * 16 / 255;
227     }
228 }
229 
230 constexpr GLfloatColor YCbCrMatrix::operator*(const GLfloatColor&amp; color) const
231 {
232     return GLfloatColor(
233         rows[0][0] * color.rgb.r + rows[0][1] * color.rgb.g + rows[0][2] * color.rgb.b + rows[0][3],
234         rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
235         rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
236     );
237 }
238 
239 static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunction transferFunction)
240 {
241     using MapKey = std::pair&lt;PixelRange, TransferFunction&gt;;
242     using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
243 
244     static NeverDestroyed&lt;MatrixMap&gt; matrices;
245     static dispatch_once_t onceToken;
246 
247     // Matrices are derived from the components in the ITU R.601 rev 4 specification
248     // https://www.itu.int/rec/R-REC-BT.601
249     constexpr static YCbCrMatrix r601VideoMatrix { PixelRange::Video, 0.114f, 0.299f };
250     constexpr static YCbCrMatrix r601FullMatrix { PixelRange::Full, 0.114f, 0.299f };
251 
252     static_assert((r601VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 video matrix does not produce black color&quot;);
253     static_assert((r601VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 video matrix does not produce white color&quot;);
254     static_assert((r601VideoMatrix * GLfloatColor(81,  90,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 video matrix does not produce red color&quot;);
255     static_assert((r601VideoMatrix * GLfloatColor(145, 54,  34,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 video matrix does not produce green color&quot;);
256     static_assert((r601VideoMatrix * GLfloatColor(41,  240, 110, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 video matrix does not produce blue color&quot;);
257     static_assert((r601VideoMatrix * GLfloatColor(210, 16,  146, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 video matrix does not produce yellow color&quot;);
258     static_assert((r601VideoMatrix * GLfloatColor(106, 202, 222, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 video matrix does not produce magenta color&quot;);
259     static_assert((r601VideoMatrix * GLfloatColor(170, 166, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 video matrix does not produce cyan color&quot;);
260 
261     static_assert((r601FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 full matrix does not produce black color&quot;);
262     static_assert((r601FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 full matrix does not produce white color&quot;);
263     static_assert((r601FullMatrix * GLfloatColor(76,  85,  255, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 full matrix does not produce red color&quot;);
264     static_assert((r601FullMatrix * GLfloatColor(150, 44,  21,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 full matrix does not produce green color&quot;);
265     static_assert((r601FullMatrix * GLfloatColor(29,  255, 107, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 full matrix does not produce blue color&quot;);
266     static_assert((r601FullMatrix * GLfloatColor(226, 0,   149, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 full matrix does not produce yellow color&quot;);
267     static_assert((r601FullMatrix * GLfloatColor(105, 212, 235, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 full matrix does not produce magenta color&quot;);
268     static_assert((r601FullMatrix * GLfloatColor(179, 171, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 full matrix does not produce cyan color&quot;);
269 
270     // Matrices are derived from the components in the ITU R.709 rev 2 specification
271     // https://www.itu.int/rec/R-REC-BT.709-2-199510-S
272     constexpr static YCbCrMatrix r709VideoMatrix { PixelRange::Video, 0.0722, 0.2126 };
273     constexpr static YCbCrMatrix r709FullMatrix { PixelRange::Full, 0.0722, 0.2126 };
274 
275     static_assert((r709VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 video matrix does not produce black color&quot;);
276     static_assert((r709VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 video matrix does not produce white color&quot;);
277     static_assert((r709VideoMatrix * GLfloatColor(63,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 video matrix does not produce red color&quot;);
278     static_assert((r709VideoMatrix * GLfloatColor(173, 42,  26,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 video matrix does not produce green color&quot;);
279     static_assert((r709VideoMatrix * GLfloatColor(32,  240, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 video matrix does not produce blue color&quot;);
280     static_assert((r709VideoMatrix * GLfloatColor(219, 16,  138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 video matrix does not produce yellow color&quot;);
281     static_assert((r709VideoMatrix * GLfloatColor(78,  214, 230, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 video matrix does not produce magenta color&quot;);
282     static_assert((r709VideoMatrix * GLfloatColor(188, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 video matrix does not produce cyan color&quot;);
283 
284     static_assert((r709FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 full matrix does not produce black color&quot;);
285     static_assert((r709FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 full matrix does not produce white color&quot;);
286     static_assert((r709FullMatrix * GLfloatColor(54,  99,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 full matrix does not produce red color&quot;);
287     static_assert((r709FullMatrix * GLfloatColor(182, 30,  12,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 full matrix does not produce green color&quot;);
288     static_assert((r709FullMatrix * GLfloatColor(18,  256, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 full matrix does not produce blue color&quot;);
289     static_assert((r709FullMatrix * GLfloatColor(237, 1,   140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 full matrix does not produce yellow color&quot;);
290     static_assert((r709FullMatrix * GLfloatColor(73,  226, 244, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 full matrix does not produce magenta color&quot;);
291     static_assert((r709FullMatrix * GLfloatColor(201, 157, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 full matrix does not produce cyan color&quot;);
292 
293     // Matrices are derived from the components in the ITU-R BT.2020-2 specification
294     // https://www.itu.int/rec/R-REC-BT.2020
295     constexpr static YCbCrMatrix bt2020VideoMatrix { PixelRange::Video, 0.0593, 0.2627 };
296     constexpr static YCbCrMatrix bt2020FullMatrix { PixelRange::Full, 0.0593, 0.2627 };
297 
298     static_assert((bt2020VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce black color&quot;);
299     static_assert((bt2020VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce white color&quot;);
300     static_assert((bt2020VideoMatrix * GLfloatColor(74,  97,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 video matrix does not produce red color&quot;);
301     static_assert((bt2020VideoMatrix * GLfloatColor(164, 47,  25,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce green color&quot;);
302     static_assert((bt2020VideoMatrix * GLfloatColor(29,  240, 119, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce blue color&quot;);
303     static_assert((bt2020VideoMatrix * GLfloatColor(222, 16,  137, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 video matrix does not produce yellow color&quot;);
304     static_assert((bt2020VideoMatrix * GLfloatColor(87,  209, 231, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 video matrix does not produce magenta color&quot;);
305     static_assert((bt2020VideoMatrix * GLfloatColor(177, 159, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce cyan color&quot;);
306 
307     static_assert((bt2020FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce black color&quot;);
308     static_assert((bt2020FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce white color&quot;);
309     static_assert((bt2020FullMatrix * GLfloatColor(67,  92,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 full matrix does not produce red color&quot;);
310     static_assert((bt2020FullMatrix * GLfloatColor(173, 36,  11,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce green color&quot;);
311     static_assert((bt2020FullMatrix * GLfloatColor(15,  256, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce blue color&quot;);
312     static_assert((bt2020FullMatrix * GLfloatColor(240, 0,   138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 full matrix does not produce yellow color&quot;);
313     static_assert((bt2020FullMatrix * GLfloatColor(82,  220, 245, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 full matrix does not produce magenta color&quot;);
314     static_assert((bt2020FullMatrix * GLfloatColor(188, 164, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce cyan color&quot;);
315 
316     // Matrices are derived from the components in the SMPTE 240M-1999 specification
317     // http://ieeexplore.ieee.org/document/7291461/
318     constexpr static YCbCrMatrix smpte240MVideoMatrix { PixelRange::Video, 0.087, 0.212 };
319     constexpr static YCbCrMatrix smpte240MFullMatrix { PixelRange::Full, 0.087, 0.212 };
320 
321     static_assert((smpte240MVideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce black color&quot;);
322     static_assert((smpte240MVideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce white color&quot;);
323     static_assert((smpte240MVideoMatrix * GLfloatColor(62,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce red color&quot;);
324     static_assert((smpte240MVideoMatrix * GLfloatColor(170, 42,  28,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce green color&quot;);
325     static_assert((smpte240MVideoMatrix * GLfloatColor(35,  240, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce blue color&quot;);
326     static_assert((smpte240MVideoMatrix * GLfloatColor(216, 16,  140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce yellow color&quot;);
327     static_assert((smpte240MVideoMatrix * GLfloatColor(81,  214, 228, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce magenta color&quot;);
328     static_assert((smpte240MVideoMatrix * GLfloatColor(189, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce cyan color&quot;);
329 
330     static_assert((smpte240MFullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce black color&quot;);
331     static_assert((smpte240MFullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce white color&quot;);
332     static_assert((smpte240MFullMatrix * GLfloatColor(54,  98,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce red color&quot;);
333     static_assert((smpte240MFullMatrix * GLfloatColor(179, 30,  15,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce green color&quot;);
334     static_assert((smpte240MFullMatrix * GLfloatColor(22,  256, 114, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce blue color&quot;);
335     static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
336     static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
337     static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
338 
339     dispatch_once(&amp;onceToken, ^{
340         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_601_4), r601VideoMatrix);
341         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_601_4), r601FullMatrix);
342         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_709_2), r709VideoMatrix);
343         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_709_2), r709FullMatrix);
344         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_2020), bt2020VideoMatrix);
345         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_2020), bt2020FullMatrix);
346         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kSMPTE_240M_1995), smpte240MVideoMatrix);
347         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kSMPTE_240M_1995), smpte240MFullMatrix);
348     });
349 
350     // We should never be asked to handle a Pixel Format whose range value is unknown.
351     ASSERT(range != PixelRange::Unknown);
352     if (range == PixelRange::Unknown)
353         range = PixelRange::Full;
354 
355     auto iterator = matrices.get().find({range, transferFunction});
356 
357     // Assume unknown transfer functions are r.601:
358     if (iterator == matrices.get().end())
359         iterator = matrices.get().find({range, TransferFunction::kITU_R_601_4});
360 
361     ASSERT(iterator != matrices.get().end());
362     return iterator-&gt;second;
363 }
364 #endif // HAVE(IOSURFACE)
365 
366 VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContext3D&amp; context)
367     : m_sharedContext(context)
368     , m_context(GraphicsContext3D::createShared(context))
369     , m_framebuffer(context.createFramebuffer())
370 {
371 }
372 
373 VideoTextureCopierCV::~VideoTextureCopierCV()
374 {
375     if (m_vertexBuffer)
376         m_context-&gt;deleteProgram(m_vertexBuffer);
377     if (m_program)
378         m_context-&gt;deleteProgram(m_program);
379     if (m_yuvVertexBuffer)
380         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
381     if (m_yuvProgram)
382         m_context-&gt;deleteProgram(m_yuvProgram);
383     m_context-&gt;deleteFramebuffer(m_framebuffer);
384 }
385 
386 #if !LOG_DISABLED
387 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
388 #define STRINGIFY_PAIR(e) e, #e
389 static StringMap&amp; enumToStringMap()
390 {
391     static NeverDestroyed&lt;StringMap&gt; map;
392     if (map.get().empty()) {
393         StringMap stringMap;
394         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));
395         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));
396         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));
397         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));
398         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));
399         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8));
400         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16F));
401         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32F));
402         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8UI));
403         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8I));
404         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16UI));
405         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16I));
406         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32UI));
407         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32I));
408         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8));
409         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16F));
410         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32F));
411         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8UI));
412         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8I));
413         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16UI));
414         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16I));
415         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32UI));
416         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32I));
417         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB8));
418         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8));
419         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA8));
420         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8_ALPHA8));
421         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA4));
422         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB10_A2));
423         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT16));
424         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT24));
425         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT32F));
426         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH24_STENCIL8));
427         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH32F_STENCIL8));
428         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));
429         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));
430         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));
431         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));
432         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));
433         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RED));
434         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG_INTEGER));
435         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_STENCIL));
436         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_BYTE));
437         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_6_5));
438         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4));
439         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1));
440         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::BYTE));
441         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::HALF_FLOAT));
442         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT));
443         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT));
444         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SHORT));
445         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT));
446         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::INT));
447         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV));
448         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_24_8));
449         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV));
450 
451 #if USE(OPENGL_ES)
452         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
453         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
454         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
455         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
456         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
457         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
458         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
459         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
460         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
461         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
462         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
463         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
464         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
465         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
466         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
467         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
468         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
469         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
470         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8UI));
471         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8I));
472         map.get().emplace(STRINGIFY_PAIR(GL_RGB10_A2UI));
473         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16UI));
474         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16I));
475         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32I));
476         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32UI));
477         map.get().emplace(STRINGIFY_PAIR(GL_RGB5_A1));
478         map.get().emplace(STRINGIFY_PAIR(GL_RG));
479         map.get().emplace(STRINGIFY_PAIR(GL_RGBA_INTEGER));
480         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT));
481         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_10F_11F_11F_REV));
482         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_5_9_9_9_REV));
483 #endif
484     }
485     return map.get();
486 }
487 
488 #endif
489 
490 bool VideoTextureCopierCV::initializeContextObjects()
491 {
492     StringBuilder vertexShaderSource;
493     vertexShaderSource.appendLiteral(&quot;attribute vec4 a_position;\n&quot;);
494     vertexShaderSource.appendLiteral(&quot;uniform int u_flipY;\n&quot;);
495     vertexShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
496     vertexShaderSource.appendLiteral(&quot;void main() {\n&quot;);
497     vertexShaderSource.appendLiteral(&quot;    v_texturePosition = vec2((a_position.x + 1.0) / 2.0, (a_position.y + 1.0) / 2.0);\n&quot;);
498     vertexShaderSource.appendLiteral(&quot;    if (u_flipY == 1) {\n&quot;);
499     vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
500     vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
501     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
502     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
503 
504     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
505     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
506     m_context-&gt;compileShaderDirect(vertexShader);
507 
508     GC3Dint value = 0;
509     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
510     if (!value) {
511         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
512         m_context-&gt;deleteShader(vertexShader);
513         return false;
514     }
515 
516     StringBuilder fragmentShaderSource;
517 
518 #if USE(OPENGL_ES)
519     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
520     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
521 #elif USE(OPENGL)
522     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
523 #elif USE(ANGLE)
524     // FIXME: determine how to access rectangular textures via ANGLE.
525     ASSERT_NOT_REACHED();
526 #else
527 #error Unsupported configuration
528 #endif
529     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
530     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
531     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
532     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
533     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
534     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
535 #if USE(OPENGL_ES)
536     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
537 #elif USE(OPENGL)
538     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
539 #elif USE(ANGLE)
540     // FIXME: determine how to access rectangular textures via ANGLE.
541     ASSERT_NOT_REACHED();
542 #else
543 #error Unsupported configuration
544 #endif
545     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
546     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
547     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
548     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
549     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
550     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
551     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
552     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
553     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
554 
555     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
556     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
557     m_context-&gt;compileShaderDirect(fragmentShader);
558 
559     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
560     if (!value) {
561         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
562         m_context-&gt;deleteShader(vertexShader);
563         m_context-&gt;deleteShader(fragmentShader);
564         return false;
565     }
566 
567     m_program = m_context-&gt;createProgram();
568     m_context-&gt;attachShader(m_program, vertexShader);
569     m_context-&gt;attachShader(m_program, fragmentShader);
570     m_context-&gt;linkProgram(m_program);
571 
572     m_context-&gt;getProgramiv(m_program, GraphicsContext3D::LINK_STATUS, &amp;value);
573     if (!value) {
574         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
575         m_context-&gt;deleteShader(vertexShader);
576         m_context-&gt;deleteShader(fragmentShader);
577         m_context-&gt;deleteProgram(m_program);
578         m_program = 0;
579         return false;
580     }
581 
582     m_textureUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_texture&quot;_s);
583     m_textureDimensionsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_textureDimensions&quot;_s);
584     m_flipYUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_flipY&quot;_s);
585     m_swapColorChannelsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_swapColorChannels&quot;_s);
586     m_premultiplyUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_premultiply&quot;_s);
587     m_positionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_program, &quot;a_position&quot;_s);
588 
589     m_context-&gt;detachShader(m_program, vertexShader);
590     m_context-&gt;detachShader(m_program, fragmentShader);
591     m_context-&gt;deleteShader(vertexShader);
592     m_context-&gt;deleteShader(fragmentShader);
593 
594     LOG(WebGL, &quot;Uniform and Attribute locations: u_texture = %d, u_textureDimensions = %d, u_flipY = %d, u_premultiply = %d, a_position = %d&quot;, m_textureUniformLocation, m_textureDimensionsUniformLocation, m_flipYUniformLocation, m_premultiplyUniformLocation, m_positionAttributeLocation);
595     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
596 
597     m_vertexBuffer = m_context-&gt;createBuffer();
598     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
599 
600     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);
601     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContext3D::STATIC_DRAW);
602 
603     return true;
604 }
605 
606 bool VideoTextureCopierCV::initializeUVContextObjects()
607 {
608     String vertexShaderSource {
609         &quot;attribute vec2 a_position;\n&quot;
610         &quot;uniform vec2 u_yTextureSize;\n&quot;
611         &quot;uniform vec2 u_uvTextureSize;\n&quot;
612         &quot;uniform int u_flipY;\n&quot;
613         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
614         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
615         &quot;void main() {\n&quot;
616         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
617         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
618         &quot;   if (u_flipY == 1) {\n&quot;
619         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
620         &quot;   }\n&quot;
621 #if USE(OPENGL_ES)
622         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
623         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
624 #elif USE(OPENGL)
625         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
626         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
627 #elif USE(ANGLE)
628         // FIXME: determine how to access rectangular textures via ANGLE.
629 #else
630 #error Unsupported configuration
631 #endif
632         &quot;}\n&quot;_s
633     };
634 
635     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
636     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
637     m_context-&gt;compileShaderDirect(vertexShader);
638 
639     GC3Dint status = 0;
640     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
641     if (!status) {
642         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
643         m_context-&gt;deleteShader(vertexShader);
644         return false;
645     }
646 
647     String fragmentShaderSource {
648 #if USE(OPENGL_ES)
649         &quot;precision mediump float;\n&quot;
650         &quot;#define SAMPLERTYPE sampler2D\n&quot;
651         &quot;#define TEXTUREFUNC texture2D\n&quot;
652 #elif USE(OPENGL)
653         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
654         &quot;#define TEXTUREFUNC texture2DRect\n&quot;
655 #elif USE(ANGLE)
656         // FIXME: determine how to access rectangular textures via ANGLE.
657 #else
658 #error Unsupported configuration
659 #endif
660         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
661         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
662         &quot;uniform mat4 u_colorMatrix;\n&quot;
663         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
664         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
665         &quot;void main() {\n&quot;
666         &quot;    vec4 yuv;\n&quot;
667         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
668         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
669         &quot;    yuv.a = 1.0;\n&quot;
670         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
671         &quot;}\n&quot;_s
672     };
673 
674     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
675     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
676     m_context-&gt;compileShaderDirect(fragmentShader);
677 
678     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
679     if (!status) {
680         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
681         m_context-&gt;deleteShader(vertexShader);
682         m_context-&gt;deleteShader(fragmentShader);
683         return false;
684     }
685 
686     m_yuvProgram = m_context-&gt;createProgram();
687     m_context-&gt;attachShader(m_yuvProgram, vertexShader);
688     m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
689     m_context-&gt;linkProgram(m_yuvProgram);
690 
691     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContext3D::LINK_STATUS, &amp;status);
692     if (!status) {
693         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
694         m_context-&gt;deleteShader(vertexShader);
695         m_context-&gt;deleteShader(fragmentShader);
696         m_context-&gt;deleteProgram(m_yuvProgram);
697         m_yuvProgram = 0;
698         return false;
699     }
700 
701     m_yTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTexture&quot;_s);
702     m_uvTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTexture&quot;_s);
703     m_colorMatrixUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_colorMatrix&quot;_s);
704     m_yuvFlipYUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_flipY&quot;_s);
705     m_yTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTextureSize&quot;_s);
706     m_uvTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTextureSize&quot;_s);
707     m_yuvPositionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_yuvProgram, &quot;a_position&quot;_s);
708 
709     m_context-&gt;detachShader(m_yuvProgram, vertexShader);
710     m_context-&gt;detachShader(m_yuvProgram, fragmentShader);
711     m_context-&gt;deleteShader(vertexShader);
712     m_context-&gt;deleteShader(fragmentShader);
713 
714     m_yuvVertexBuffer = m_context-&gt;createBuffer();
715     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
716 
717     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_yuvVertexBuffer);
718     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContext3D::STATIC_DRAW);
719     m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
720     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);
721 
722     return true;
723 }
724 
725 bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
726 {
727     if (!m_textureCache) {
728         m_textureCache = TextureCacheCV::create(m_context);
729         if (!m_textureCache)
730             return false;
731     }
732 
733     if (auto texture = m_textureCache-&gt;textureFromImage(image, outputTarget, level, internalFormat, format, type)) {
734         bool swapColorChannels = false;
735 #if USE(OPENGL_ES)
736         // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
737         swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
738 #endif
739         return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
740     }
741 
742 #if HAVE(IOSURFACE)
743     // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
744     OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
745     if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
746         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Asked to copy an unsupported pixel format (&#39;%s&#39;).&quot;, this, FourCC(pixelFormat).toString().utf8().data());
747         return false;
748     }
749 
750     IOSurfaceRef surface = CVPixelBufferGetIOSurface(image);
751     if (!surface)
752         return false;
753 
754     auto newSurfaceSeed = IOSurfaceGetSeed(surface);
755     if (flipY == m_lastFlipY
756         &amp;&amp; surface == m_lastSurface
757         &amp;&amp; newSurfaceSeed == m_lastSurfaceSeed
758         &amp;&amp; lastTextureSeed(outputTexture) == m_context-&gt;textureSeed(outputTexture)) {
759         // If the texture hasn&#39;t been modified since the last time we copied to it, and the
760         // image hasn&#39;t been modified since the last time it was copied, this is a no-op.
761         return true;
762     }
763 
764     if (!m_yuvProgram) {
765         if (!initializeUVContextObjects()) {
766             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
767             return false;
768         }
769     }
770 
771     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
772 
773     // Allocate memory for the output texture.
774     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);
775     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
776     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
777     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
778     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
779     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
780 
781     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
782     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
783     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
784         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
785         return false;
786     }
787 
788     m_context-&gt;useProgram(m_yuvProgram);
789     m_context-&gt;viewport(0, 0, width, height);
790 
791     // Bind and set up the textures for the video source.
792     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
793     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
794     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
795     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
796 
797 #if USE(OPENGL_ES)
798     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;
799 #elif USE(OPENGL)
800     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;
801 #elif USE(ANGLE)
802     // FIXME: determine how to access rectangular textures via ANGLE.
803     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;
804 #else
805 #error Unsupported configuration
806 #endif
807     auto uvTexture = m_context-&gt;createTexture();
808     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);
809     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
810     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
811     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
812     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
813     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
814     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContext3D::RG, GraphicsContext3D::UNSIGNED_BYTE, surface, 1)) {
815         m_context-&gt;deleteTexture(uvTexture);
816         return false;
817     }
818 
819     auto yTexture = m_context-&gt;createTexture();
820     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
821     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
822     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
823     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
824     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
825     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
826     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContext3D::LUMINANCE, GraphicsContext3D::UNSIGNED_BYTE, surface, 0)) {
827         m_context-&gt;deleteTexture(yTexture);
828         m_context-&gt;deleteTexture(uvTexture);
829         return false;
830     }
831 
832     // Configure the drawing parameters.
833     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
834     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
835     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
836     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
837     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
838 
839     auto range = pixelRangeFromPixelFormat(pixelFormat);
840     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
841     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
842     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
843 
844     // Do the actual drawing.
845     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
846 
847 #if USE(OPENGL_ES)
848     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
849     // two EAGL contexts.
850     m_context-&gt;flush();
851 #endif
852 
853     // Clean-up.
854     m_context-&gt;deleteTexture(yTexture);
855     m_context-&gt;deleteTexture(uvTexture);
856 
857     m_lastSurface = surface;
858     m_lastSurfaceSeed = newSurfaceSeed;
859     m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
860     m_lastFlipY = flipY;
861 
862     return true;
863 #else
864     return false;
865 #endif // HAVE(IOSURFACE)
866 }
867 
868 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
869 {
870     if (!inputVideoTexture)
871         return false;
872 
873     GLfloat lowerLeft[2] = { 0, 0 };
874     GLfloat lowerRight[2] = { 0, 0 };
875     GLfloat upperRight[2] = { 0, 0 };
876     GLfloat upperLeft[2] = { 0, 0 };
877 #if USE(OPENGL_ES)
878     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);
879     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);
880     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
881 #elif USE(OPENGL)
882     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);
883     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);
884     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
885 #elif USE(ANGLE)
886     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);
887     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);
888     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
889     // FIXME: determine how to access rectangular textures via ANGLE.
890     ASSERT_NOT_REACHED();
891 #endif
892 
893     if (lowerLeft[1] &lt; upperRight[1])
894         flipY = !flipY;
895 
896     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
897 }
898 
899 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
900 {
901     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
902 
903     if (!m_program) {
904         if (!initializeContextObjects()) {
905             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
906             return false;
907         }
908     }
909 
910     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
911 
912     // Allocate memory for the output texture.
913     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);
914     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
915     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
916     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
917     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
918     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
919 
920     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
921     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
922     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
923         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
924         return false;
925     }
926 
927     m_context-&gt;useProgram(m_program);
928     m_context-&gt;viewport(0, 0, width, height);
929 
930     // Bind and set up the texture for the video source.
931     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
932     m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
933     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
934     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
935     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
936     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
937 
938     // Configure the drawing parameters.
939     m_context-&gt;uniform1i(m_textureUniformLocation, 0);
940 #if USE(OPENGL_ES)
941     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
942 #else
943     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, width, height);
944 #endif
945 
946     m_context-&gt;uniform1i(m_flipYUniformLocation, flipY);
947     m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
948     m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
949 
950     // Do the actual drawing.
951     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
952     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);
953     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);
954     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
955 
956 #if USE(OPENGL_ES)
957     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
958     // two EAGL contexts.
959     m_context-&gt;flush();
960 #endif
961 
962     // Clean-up.
963     m_context-&gt;bindTexture(videoTextureTarget, 0);
964     m_context-&gt;bindTexture(outputTarget, outputTexture);
965 
966     return true;
967 }
968 
969 }
970 
971 #endif // HAVE(CORE_VIDEO)
    </pre>
  </body>
</html>