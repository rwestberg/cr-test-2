<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGLRenderingContextBase.h&quot;
  28 
  29 #if ENABLE(WEBGL)
  30 
  31 #include &quot;ANGLEInstancedArrays.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;DOMWindow.h&quot;
  34 #include &quot;DiagnosticLoggingClient.h&quot;
  35 #include &quot;DiagnosticLoggingKeys.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;EXTBlendMinMax.h&quot;
  38 #include &quot;EXTFragDepth.h&quot;
  39 #include &quot;EXTShaderTextureLOD.h&quot;
  40 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  41 #include &quot;EXTsRGB.h&quot;
  42 #include &quot;EventNames.h&quot;
  43 #include &quot;Extensions3D.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;FrameLoader.h&quot;
  46 #include &quot;FrameLoaderClient.h&quot;
  47 #include &quot;FrameView.h&quot;
  48 #include &quot;GraphicsContext.h&quot;
  49 #include &quot;HTMLCanvasElement.h&quot;
  50 #include &quot;HTMLImageElement.h&quot;
  51 #include &quot;HTMLVideoElement.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;InspectorInstrumentation.h&quot;
  55 #include &quot;IntSize.h&quot;
  56 #include &quot;JSExecState.h&quot;
  57 #include &quot;Logging.h&quot;
  58 #include &quot;NotImplemented.h&quot;
  59 #include &quot;OESElementIndexUint.h&quot;
  60 #include &quot;OESStandardDerivatives.h&quot;
  61 #include &quot;OESTextureFloat.h&quot;
  62 #include &quot;OESTextureFloatLinear.h&quot;
  63 #include &quot;OESTextureHalfFloat.h&quot;
  64 #include &quot;OESTextureHalfFloatLinear.h&quot;
  65 #include &quot;OESVertexArrayObject.h&quot;
  66 #include &quot;OffscreenCanvas.h&quot;
  67 #include &quot;Page.h&quot;
  68 #include &quot;RenderBox.h&quot;
  69 #include &quot;RuntimeEnabledFeatures.h&quot;
  70 #include &quot;Settings.h&quot;
  71 #include &quot;WebGL2RenderingContext.h&quot;
  72 #include &quot;WebGLActiveInfo.h&quot;
  73 #include &quot;WebGLBuffer.h&quot;
  74 #include &quot;WebGLCompressedTextureASTC.h&quot;
  75 #include &quot;WebGLCompressedTextureATC.h&quot;
  76 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  77 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  78 #include &quot;WebGLContextAttributes.h&quot;
  79 #include &quot;WebGLContextEvent.h&quot;
  80 #include &quot;WebGLContextGroup.h&quot;
  81 #include &quot;WebGLDebugRendererInfo.h&quot;
  82 #include &quot;WebGLDebugShaders.h&quot;
  83 #include &quot;WebGLDepthTexture.h&quot;
  84 #include &quot;WebGLDrawBuffers.h&quot;
  85 #include &quot;WebGLFramebuffer.h&quot;
  86 #include &quot;WebGLLoseContext.h&quot;
  87 #include &quot;WebGLProgram.h&quot;
  88 #include &quot;WebGLRenderbuffer.h&quot;
  89 #include &quot;WebGLRenderingContext.h&quot;
  90 #include &quot;WebGLShader.h&quot;
  91 #include &quot;WebGLShaderPrecisionFormat.h&quot;
  92 #include &quot;WebGLTexture.h&quot;
  93 #include &quot;WebGLUniformLocation.h&quot;
  94 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
  95 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  96 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  97 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  98 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  99 #include &lt;JavaScriptCore/Uint32Array.h&gt;
 100 #include &lt;wtf/CheckedArithmetic.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 101 #include &lt;wtf/HashMap.h&gt;</span>
 102 #include &lt;wtf/HexNumber.h&gt;
<a name="2" id="anc2"></a><span class="line-added"> 103 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
<span class="line-added"> 104 #include &lt;wtf/Lock.h&gt;</span>
 105 #include &lt;wtf/StdLibExtras.h&gt;
 106 #include &lt;wtf/UniqueArray.h&gt;
 107 #include &lt;wtf/text/CString.h&gt;
 108 #include &lt;wtf/text/StringBuilder.h&gt;
 109 
 110 namespace WebCore {
 111 
<a name="3" id="anc3"></a><span class="line-added"> 112 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);</span>
<span class="line-added"> 113 </span>
 114 static const Seconds secondsBetweenRestoreAttempts { 1_s };
 115 const int maxGLErrorsAllowedToConsole = 256;
 116 static const Seconds checkContextLossHandlingDelay { 3_s };
 117 
 118 namespace {
 119 
<a name="4" id="anc4"></a>




 120     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)
 121     {
 122         if (value &lt; min)
 123             value = min;
 124         if (value &gt; max)
 125             value = max;
 126         return value;
 127     }
 128 
 129     // Return true if a character belongs to the ASCII subset as defined in
 130     // GLSL ES 1.0 spec section 3.1.
 131     bool validateCharacter(unsigned char c)
 132     {
 133         // Printing characters are valid except &quot; $ ` @ \ &#39; DEL.
 134         if (c &gt;= 32 &amp;&amp; c &lt;= 126
 135             &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;$&#39; &amp;&amp; c != &#39;`&#39; &amp;&amp; c != &#39;@&#39; &amp;&amp; c != &#39;\\&#39; &amp;&amp; c != &#39;\&#39;&#39;)
 136             return true;
 137         // Horizontal tab, line feed, vertical tab, form feed, carriage return
 138         // are also valid.
 139         if (c &gt;= 9 &amp;&amp; c &lt;= 13)
 140             return true;
 141         return false;
 142     }
 143 
 144     bool isPrefixReserved(const String&amp; name)
 145     {
 146         if (name.startsWith(&quot;gl_&quot;) || name.startsWith(&quot;webgl_&quot;) || name.startsWith(&quot;_webgl_&quot;))
 147             return true;
 148         return false;
 149     }
 150 
 151     // Strips comments from shader text. This allows non-ASCII characters
 152     // to be used in comments without potentially breaking OpenGL
 153     // implementations not expecting characters outside the GLSL ES set.
 154     class StripComments {
 155     public:
 156         StripComments(const String&amp; str)
 157             : m_parseState(BeginningOfLine)
 158             , m_sourceString(str)
 159             , m_length(str.length())
 160             , m_position(0)
 161         {
 162             parse();
 163         }
 164 
 165         String result()
 166         {
 167             return m_builder.toString();
 168         }
 169 
 170     private:
 171         bool hasMoreCharacters() const
 172         {
 173             return (m_position &lt; m_length);
 174         }
 175 
 176         void parse()
 177         {
 178             while (hasMoreCharacters()) {
 179                 process(current());
 180                 // process() might advance the position.
 181                 if (hasMoreCharacters())
 182                     advance();
 183             }
 184         }
 185 
 186         void process(UChar);
 187 
 188         bool peek(UChar&amp; character) const
 189         {
 190             if (m_position + 1 &gt;= m_length)
 191                 return false;
 192             character = m_sourceString[m_position + 1];
 193             return true;
 194         }
 195 
 196         UChar current() const
 197         {
 198             ASSERT_WITH_SECURITY_IMPLICATION(m_position &lt; m_length);
 199             return m_sourceString[m_position];
 200         }
 201 
 202         void advance()
 203         {
 204             ++m_position;
 205         }
 206 
 207         bool isNewline(UChar character) const
 208         {
 209             // Don&#39;t attempt to canonicalize newline related characters.
 210             return (character == &#39;\n&#39; || character == &#39;\r&#39;);
 211         }
 212 
 213         void emit(UChar character)
 214         {
 215             m_builder.append(character);
 216         }
 217 
 218         enum ParseState {
 219             // Have not seen an ASCII non-whitespace character yet on
 220             // this line. Possible that we might see a preprocessor
 221             // directive.
 222             BeginningOfLine,
 223 
 224             // Have seen at least one ASCII non-whitespace character
 225             // on this line.
 226             MiddleOfLine,
 227 
 228             // Handling a preprocessor directive. Passes through all
 229             // characters up to the end of the line. Disables comment
 230             // processing.
 231             InPreprocessorDirective,
 232 
 233             // Handling a single-line comment. The comment text is
 234             // replaced with a single space.
 235             InSingleLineComment,
 236 
 237             // Handling a multi-line comment. Newlines are passed
 238             // through to preserve line numbers.
 239             InMultiLineComment
 240         };
 241 
 242         ParseState m_parseState;
 243         String m_sourceString;
 244         unsigned m_length;
 245         unsigned m_position;
 246         StringBuilder m_builder;
 247     };
 248 
 249     void StripComments::process(UChar c)
 250     {
 251         if (isNewline(c)) {
 252             // No matter what state we are in, pass through newlines
 253             // so we preserve line numbers.
 254             emit(c);
 255 
 256             if (m_parseState != InMultiLineComment)
 257                 m_parseState = BeginningOfLine;
 258 
 259             return;
 260         }
 261 
 262         UChar temp = 0;
 263         switch (m_parseState) {
 264         case BeginningOfLine:
 265             if (WTF::isASCIISpace(c)) {
 266                 emit(c);
 267                 break;
 268             }
 269 
 270             if (c == &#39;#&#39;) {
 271                 m_parseState = InPreprocessorDirective;
 272                 emit(c);
 273                 break;
 274             }
 275 
 276             // Transition to normal state and re-handle character.
 277             m_parseState = MiddleOfLine;
 278             process(c);
 279             break;
 280 
 281         case MiddleOfLine:
 282             if (c == &#39;/&#39; &amp;&amp; peek(temp)) {
 283                 if (temp == &#39;/&#39;) {
 284                     m_parseState = InSingleLineComment;
 285                     emit(&#39; &#39;);
 286                     advance();
 287                     break;
 288                 }
 289 
 290                 if (temp == &#39;*&#39;) {
 291                     m_parseState = InMultiLineComment;
 292                     // Emit the comment start in case the user has
 293                     // an unclosed comment and we want to later
 294                     // signal an error.
 295                     emit(&#39;/&#39;);
 296                     emit(&#39;*&#39;);
 297                     advance();
 298                     break;
 299                 }
 300             }
 301 
 302             emit(c);
 303             break;
 304 
 305         case InPreprocessorDirective:
 306             // No matter what the character is, just pass it
 307             // through. Do not parse comments in this state. This
 308             // might not be the right thing to do long term, but it
 309             // should handle the #error preprocessor directive.
 310             emit(c);
 311             break;
 312 
 313         case InSingleLineComment:
 314             // The newline code at the top of this function takes care
 315             // of resetting our state when we get out of the
 316             // single-line comment. Swallow all other characters.
 317             break;
 318 
 319         case InMultiLineComment:
 320             if (c == &#39;*&#39; &amp;&amp; peek(temp) &amp;&amp; temp == &#39;/&#39;) {
 321                 emit(&#39;*&#39;);
 322                 emit(&#39;/&#39;);
 323                 m_parseState = MiddleOfLine;
 324                 advance();
 325                 break;
 326             }
 327 
 328             // Swallow all other characters. Unclear whether we may
 329             // want or need to just emit a space per character to try
 330             // to preserve column numbers for debugging purposes.
 331             break;
 332         }
 333     }
 334 } // namespace anonymous
 335 
 336 // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
 337 static bool clip2D(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height,
 338     GC3Dsizei sourceWidth, GC3Dsizei sourceHeight,
 339     GC3Dint* clippedX, GC3Dint* clippedY, GC3Dsizei* clippedWidth, GC3Dsizei*clippedHeight)
 340 {
 341     ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
 342 
 343     GC3Dint left = std::max(x, 0);
 344     GC3Dint top = std::max(y, 0);
 345     GC3Dint right = 0;
 346     GC3Dint bottom = 0;
 347 
 348     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputRight = Checked&lt;GC3Dint&gt;(x) + Checked&lt;GC3Dsizei&gt;(width);
 349     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GC3Dint&gt;(y) + Checked&lt;GC3Dsizei&gt;(height);
 350     if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
 351         right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
 352         bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
 353     }
 354 
 355     if (left &gt;= right || top &gt;= bottom) {
 356         *clippedX = 0;
 357         *clippedY = 0;
 358         *clippedWidth = 0;
 359         *clippedHeight = 0;
 360         return true;
 361     }
 362 
 363     *clippedX = left;
 364     *clippedY = top;
 365     *clippedWidth = right - left;
 366     *clippedHeight = bottom - top;
 367 
 368     return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
 369 }
 370 
 371 class WebGLRenderingContextLostCallback : public GraphicsContext3D::ContextLostCallback {
 372     WTF_MAKE_FAST_ALLOCATED;
 373 public:
 374     explicit WebGLRenderingContextLostCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }
 375     virtual ~WebGLRenderingContextLostCallback() = default;
 376 
 377     void onContextLost() override { m_context-&gt;forceLostContext(WebGLRenderingContext::RealLostContext); }
 378 private:
 379     WebGLRenderingContextBase* m_context;
 380 };
 381 
 382 class WebGLRenderingContextErrorMessageCallback : public GraphicsContext3D::ErrorMessageCallback {
 383     WTF_MAKE_FAST_ALLOCATED;
 384 public:
 385     explicit WebGLRenderingContextErrorMessageCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }
 386     virtual ~WebGLRenderingContextErrorMessageCallback() = default;
 387 
 388     void onErrorMessage(const String&amp; message, GC3Dint) override
 389     {
 390         if (m_context-&gt;m_synthesizedErrorsToConsole)
 391             m_context-&gt;printToConsole(MessageLevel::Error, message);
 392     }
 393 private:
 394     WebGLRenderingContextBase* m_context;
 395 };
 396 
 397 class InspectorScopedShaderProgramHighlight {
 398 public:
 399     InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
 400         : m_context(context)
 401         , m_program(program)
 402     {
 403         showHightlight();
 404     }
 405 
 406     ~InspectorScopedShaderProgramHighlight()
 407     {
 408         hideHighlight();
 409     }
 410 
 411 private:
 412     void showHightlight()
 413     {
 414         if (!m_program || LIKELY(!InspectorInstrumentation::isShaderProgramHighlighted(m_context, *m_program)))
 415             return;
 416 
 417         if (hasBufferBinding(GraphicsContext3D::FRAMEBUFFER_BINDING)) {
 418             if (!hasBufferBinding(GraphicsContext3D::RENDERBUFFER_BINDING))
 419                 return;
 420             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_ATTACHMENT))
 421                 return;
 422             if (hasFramebufferParameterAttachment(GraphicsContext3D::STENCIL_ATTACHMENT))
 423                 return;
 424 #if ENABLE(WEBGL2)
 425             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT))
 426                 return;
 427 #endif
 428         }
 429 
 430         saveBlendValue(GraphicsContext3D::BLEND_COLOR, m_savedBlend.color);
 431         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);
 432         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);
 433         saveBlendValue(GraphicsContext3D::BLEND_SRC_RGB, m_savedBlend.srcRGB);
 434         saveBlendValue(GraphicsContext3D::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);
 435         saveBlendValue(GraphicsContext3D::BLEND_DST_RGB, m_savedBlend.dstRGB);
 436         saveBlendValue(GraphicsContext3D::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);
 437         saveBlendValue(GraphicsContext3D::BLEND, m_savedBlend.enabled);
 438 
 439         static const GC3Dfloat red = 111.0 / 255.0;
 440         static const GC3Dfloat green = 168.0 / 255.0;
 441         static const GC3Dfloat blue = 220.0 / 255.0;
 442         static const GC3Dfloat alpha = 2.0 / 3.0;
 443 
 444         m_context.enable(GraphicsContext3D::BLEND);
 445         m_context.blendColor(red, green, blue, alpha);
 446         m_context.blendEquation(GraphicsContext3D::FUNC_ADD);
 447         m_context.blendFunc(GraphicsContext3D::CONSTANT_COLOR, GraphicsContext3D::ONE_MINUS_SRC_ALPHA);
 448 
 449         m_didApply = true;
 450     }
 451 
 452     void hideHighlight()
 453     {
 454         if (!m_didApply)
 455             return;
 456 
 457         if (!m_savedBlend.enabled)
 458             m_context.disable(GraphicsContext3D::BLEND);
 459 
 460         const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
 461         m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
 462         m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
 463         m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
 464 
 465         m_savedBlend.color = nullptr;
 466 
 467         m_didApply = false;
 468     }
 469 
 470     template &lt;typename T&gt;
 471     void saveBlendValue(GC3Denum attachment, T&amp; destination)
 472     {
 473         WebGLAny param = m_context.getParameter(attachment);
 474         if (WTF::holds_alternative&lt;T&gt;(param))
 475             destination = WTF::get&lt;T&gt;(param);
 476     }
 477 
 478     bool hasBufferBinding(GC3Denum pname)
 479     {
 480         WebGLAny binding = m_context.getParameter(pname);
 481         if (pname == GraphicsContext3D::FRAMEBUFFER_BINDING)
 482             return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
 483         if (pname == GraphicsContext3D::RENDERBUFFER_BINDING)
 484             return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
 485         return false;
 486     }
 487 
 488     bool hasFramebufferParameterAttachment(GC3Denum attachment)
 489     {
 490         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);
 491         if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
 492             return false;
 493         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER))
 494             return false;
 495         return true;
 496     }
 497 
 498     struct {
 499         RefPtr&lt;Float32Array&gt; color;
 500         unsigned equationRGB { 0 };
 501         unsigned equationAlpha { 0 };
 502         unsigned srcRGB { 0 };
 503         unsigned srcAlpha { 0 };
 504         unsigned dstRGB { 0 };
 505         unsigned dstAlpha { 0 };
 506         bool enabled { false };
 507     } m_savedBlend;
 508 
 509     WebGLRenderingContextBase&amp; m_context;
 510     WebGLProgram* m_program { nullptr };
 511     bool m_didApply { false };
 512 };
 513 
 514 static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContext3D&gt;&amp; context)
 515 {
 516     return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
 517 }
 518 
 519 std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
 520 {
 521 #if ENABLE(WEBGL2)
 522     if (type == &quot;webgl2&quot; &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().webGL2Enabled())
 523         return nullptr;
 524 #else
 525     UNUSED_PARAM(type);
 526 #endif
 527 
 528     bool isPendingPolicyResolution = false;
 529     HostWindow* hostWindow = nullptr;
 530 
 531     auto* canvasElement = is&lt;HTMLCanvasElement&gt;(canvas) ? &amp;downcast&lt;HTMLCanvasElement&gt;(canvas) : nullptr;
 532 
 533     if (canvasElement) {
 534         Document&amp; document = canvasElement-&gt;document();
 535         RefPtr&lt;Frame&gt; frame = document.frame();
 536         if (!frame)
 537             return nullptr;
 538 
 539         // The FrameLoaderClient might block creation of a new WebGL context despite the page settings; in
 540         // particular, if WebGL contexts were lost one or more times via the GL_ARB_robustness extension.
 541         if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled())) {
 542             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 543                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Web page was not allowed to create a WebGL context.&quot;));
 544             return nullptr;
 545         }
 546 
 547         Document&amp; topDocument = document.topDocument();
 548         Page* page = topDocument.page();
 549         bool forcingPendingPolicy = frame-&gt;settings().isForcePendingWebGLPolicy();
 550 
 551         if (forcingPendingPolicy || (page &amp;&amp; !topDocument.url().isLocalFile())) {
 552             WebGLLoadPolicy policy = forcingPendingPolicy ? WebGLPendingCreation : page-&gt;mainFrame().loader().client().webGLPolicyForURL(topDocument.url());
 553 
 554             if (policy == WebGLBlockCreation) {
 555                 LOG(WebGL, &quot;The policy for this URL (%s) is to block WebGL.&quot;, topDocument.url().host().utf8().data());
 556                 return nullptr;
 557             }
 558 
 559             if (policy == WebGLPendingCreation) {
 560                 LOG(WebGL, &quot;WebGL policy is pending. May need to be resolved later.&quot;);
 561                 isPendingPolicyResolution = true;
 562             }
 563         }
 564 
<a name="5" id="anc5"></a>


 565         if (frame-&gt;settings().forceWebGLUsesLowPower()) {
 566             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)
 567                 LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
 568             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;
 569         }
 570 
 571         if (page)
 572             attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
 573 
 574         hostWindow = document.view()-&gt;root()-&gt;hostWindow();
 575     }
 576 
 577     attributes.noExtensions = true;
 578     attributes.shareResources = false;
 579 
 580     attributes.initialPowerPreference = attributes.powerPreference;
 581 
 582 
 583 #if ENABLE(WEBGL2)
 584     if (type == &quot;webgl2&quot;)
 585         attributes.isWebGL2 = true;
 586 #endif
 587 
 588     if (isPendingPolicyResolution) {
 589         LOG(WebGL, &quot;Create a WebGL context that looks real, but will require a policy resolution if used.&quot;);
 590         std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext = nullptr;
 591 #if ENABLE(WEBGL2)
 592         if (type == &quot;webgl2&quot;)
 593             renderingContext = WebGL2RenderingContext::create(canvas, attributes);
 594         else
 595 #endif
 596             renderingContext = WebGLRenderingContext::create(canvas, attributes);
 597         renderingContext-&gt;suspendIfNeeded();
 598         return renderingContext;
 599     }
 600 
 601     auto context = GraphicsContext3D::create(attributes, hostWindow);
 602     if (!context || !context-&gt;makeContextCurrent()) {
 603         if (canvasElement) {
 604             canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
 605                 Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
 606         }
 607         return nullptr;
 608     }
 609 
 610     auto&amp; extensions = context-&gt;getExtensions();
 611     if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
 612         extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
 613 
 614 #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC)
 615     // glTexStorage() was only added to Core in OpenGL 4.2.
 616     // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
 617     if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
 618         return nullptr;
 619 #endif
 620 
 621     std::unique_ptr&lt;WebGLRenderingContextBase&gt; renderingContext;
 622 #if ENABLE(WEBGL2)
 623     if (type == &quot;webgl2&quot;)
 624         renderingContext = WebGL2RenderingContext::create(canvas, context.releaseNonNull(), attributes);
 625     else
 626 #endif
 627         renderingContext = WebGLRenderingContext::create(canvas, context.releaseNonNull(), attributes);
 628     renderingContext-&gt;suspendIfNeeded();
 629 
 630     return renderingContext;
 631 }
 632 
 633 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
 634     : GPUBasedCanvasRenderingContext(canvas)
 635     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 636     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 637     , m_attributes(attributes)
 638     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 639     , m_isPendingPolicyResolution(true)
 640     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 641 {
 642     registerWithWebGLStateTracker();
 643     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 644 }
 645 
 646 WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)
 647     : GPUBasedCanvasRenderingContext(canvas)
 648     , m_context(WTFMove(context))
 649     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)
 650     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)
 651     , m_generatedImageCache(4)
 652     , m_attributes(attributes)
 653     , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
 654     , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
 655 {
 656     m_contextGroup = WebGLContextGroup::create();
 657     m_contextGroup-&gt;addContext(*this);
 658 
<a name="6" id="anc6"></a><span class="line-modified"> 659     m_context-&gt;addClient(*this);</span>
 660 
 661     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);
 662 
 663     setupFlags();
 664     initializeNewContext();
 665     registerWithWebGLStateTracker();
 666     m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
 667 
 668     addActivityStateChangeObserverIfNecessary();
 669 }
 670 
 671 WebGLCanvas WebGLRenderingContextBase::canvas()
 672 {
 673     auto&amp; base = canvasBase();
 674     if (is&lt;OffscreenCanvas&gt;(base))
 675         return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 676     return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
 677 }
 678 
<a name="7" id="anc7"></a>







 679 OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
 680 {
 681     auto&amp; base = canvasBase();
 682     if (!is&lt;OffscreenCanvas&gt;(base))
 683         return nullptr;
 684     return &amp;downcast&lt;OffscreenCanvas&gt;(base);
 685 }
 686 
 687 // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
 688 // and to discard temporary GL contexts (e.g. feature detection).
 689 void WebGLRenderingContextBase::checkForContextLossHandling()
 690 {
 691     auto canvas = htmlCanvas();
 692     if (!canvas)
 693         return;
 694 
 695     if (!canvas-&gt;renderer())
 696         return;
 697 
 698     auto* page = canvas-&gt;document().page();
 699     if (!page)
 700         return;
 701 
 702     bool handlesContextLoss = canvas-&gt;hasEventListeners(eventNames().webglcontextlostEvent) &amp;&amp; canvas-&gt;hasEventListeners(eventNames().webglcontextrestoredEvent);
 703     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::pageHandlesWebGLContextLossKey(), handlesContextLoss ? DiagnosticLoggingKeys::yesKey() : DiagnosticLoggingKeys::noKey(), ShouldSample::No);
 704 }
 705 
 706 void WebGLRenderingContextBase::registerWithWebGLStateTracker()
 707 {
 708     auto canvas = htmlCanvas();
 709     if (!canvas)
 710         return;
 711 
 712     auto* page = canvas-&gt;document().page();
 713     if (!page)
 714         return;
 715 
 716     auto* tracker = page-&gt;webGLStateTracker();
 717     if (!tracker)
 718         return;
 719 
 720     m_trackerToken = tracker-&gt;token(m_attributes.initialPowerPreference);
 721 }
 722 
 723 void WebGLRenderingContextBase::initializeNewContext()
 724 {
 725     ASSERT(!m_contextLost);
 726     m_needsUpdate = true;
 727     m_markedCanvasDirty = false;
 728     m_activeTextureUnit = 0;
 729     m_packAlignment = 4;
 730     m_unpackAlignment = 4;
 731     m_unpackFlipY = false;
 732     m_unpackPremultiplyAlpha = false;
 733     m_unpackColorspaceConversion = GraphicsContext3D::BROWSER_DEFAULT_WEBGL;
 734     m_boundArrayBuffer = nullptr;
 735     m_currentProgram = nullptr;
 736     m_framebufferBinding = nullptr;
 737     m_readFramebufferBinding = nullptr;
 738     m_renderbufferBinding = nullptr;
 739     m_depthMask = true;
 740     m_stencilEnabled = false;
 741     m_stencilMask = 0xFFFFFFFF;
 742     m_stencilMaskBack = 0xFFFFFFFF;
 743     m_stencilFuncRef = 0;
 744     m_stencilFuncRefBack = 0;
 745     m_stencilFuncMask = 0xFFFFFFFF;
 746     m_stencilFuncMaskBack = 0xFFFFFFFF;
 747     m_layerCleared = false;
 748     m_numGLErrorsToConsoleAllowed = maxGLErrorsAllowedToConsole;
 749 
 750     m_clearColor[0] = m_clearColor[1] = m_clearColor[2] = m_clearColor[3] = 0;
 751     m_scissorEnabled = false;
 752     m_clearDepth = 1;
 753     m_clearStencil = 0;
 754     m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
 755 
 756     GC3Dint numCombinedTextureImageUnits = 0;
 757     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);
 758     m_textureUnits.clear();
 759     m_textureUnits.resize(numCombinedTextureImageUnits);
 760     for (GC3Dint i = 0; i &lt; numCombinedTextureImageUnits; ++i)
 761         m_unrenderableTextureUnits.add(i);
 762 
 763     GC3Dint numVertexAttribs = 0;
 764     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);
 765     m_maxVertexAttribs = numVertexAttribs;
 766 
 767     m_maxTextureSize = 0;
 768     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);
 769     m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
 770     m_maxCubeMapTextureSize = 0;
 771     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);
 772     m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
 773     m_maxRenderbufferSize = 0;
 774     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);
 775 
 776     // These two values from EXT_draw_buffers are lazily queried.
 777     m_maxDrawBuffers = 0;
 778     m_maxColorAttachments = 0;
 779 
 780     m_backDrawBuffer = GraphicsContext3D::BACK;
 781     m_drawBuffersWebGLRequirementsChecked = false;
 782     m_drawBuffersSupported = false;
 783 
 784     m_vertexAttribValue.resize(m_maxVertexAttribs);
 785 
 786     if (!isGLES2NPOTStrict())
 787         createFallbackBlackTextures1x1();
 788 
 789     IntSize canvasSize = clampedCanvasSize();
 790     m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
 791     m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
 792     m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
 793 
<a name="8" id="anc8"></a><span class="line-modified"> 794     m_context-&gt;setContextLostCallback(makeUnique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="line-modified"> 795     m_context-&gt;setErrorMessageCallback(makeUnique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
 796 }
 797 
 798 void WebGLRenderingContextBase::setupFlags()
 799 {
 800     ASSERT(m_context);
 801 
 802     auto canvas = htmlCanvas();
 803     if (canvas) {
 804         if (Page* page = canvas-&gt;document().page())
 805             m_synthesizedErrorsToConsole = page-&gt;settings().webGLErrorsToConsoleEnabled();
 806     }
 807 
 808     m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
 809     if (m_isGLES2Compliant) {
 810         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
 811         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);
 812     } else {
 813         m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
 814         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);
 815     }
 816     m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
 817 }
 818 
 819 void WebGLRenderingContextBase::addCompressedTextureFormat(GC3Denum format)
 820 {
 821     if (!m_compressedTextureFormats.contains(format))
 822         m_compressedTextureFormats.append(format);
 823 }
 824 
 825 void WebGLRenderingContextBase::addActivityStateChangeObserverIfNecessary()
 826 {
 827     // We are only interested in visibility changes for contexts
 828     // that are using the high-performance GPU.
 829     if (!isHighPerformanceContext(m_context))
 830         return;
 831 
 832     auto* canvas = htmlCanvas();
 833     if (!canvas)
 834         return;
 835 
 836     auto* page = canvas-&gt;document().page();
 837     if (!page)
 838         return;
 839 
 840     page-&gt;addActivityStateChangeObserver(*this);
 841 
 842     // We won&#39;t get a state change right away, so
 843     // make sure the context knows if it visible or not.
 844     if (m_context)
 845         m_context-&gt;setContextVisibility(page-&gt;isVisible());
 846 }
 847 
 848 void WebGLRenderingContextBase::removeActivityStateChangeObserver()
 849 {
 850     auto* canvas = htmlCanvas();
 851     if (canvas) {
 852         if (auto* page = canvas-&gt;document().page())
 853             page-&gt;removeActivityStateChangeObserver(*this);
 854     }
 855 }
 856 
 857 WebGLRenderingContextBase::~WebGLRenderingContextBase()
 858 {
 859     // Remove all references to WebGLObjects so if they are the last reference
 860     // they will be freed before the last context is removed from the context group.
 861     m_boundArrayBuffer = nullptr;
 862     m_defaultVertexArrayObject = nullptr;
 863     m_boundVertexArrayObject = nullptr;
 864     m_vertexAttrib0Buffer = nullptr;
 865     m_currentProgram = nullptr;
 866     m_framebufferBinding = nullptr;
 867     m_readFramebufferBinding = nullptr;
 868     m_renderbufferBinding = nullptr;
 869 
 870     for (auto&amp; textureUnit : m_textureUnits) {
 871         textureUnit.texture2DBinding = nullptr;
 872         textureUnit.textureCubeMapBinding = nullptr;
 873     }
 874 
 875     m_blackTexture2D = nullptr;
 876     m_blackTextureCubeMap = nullptr;
 877 
 878     if (!m_isPendingPolicyResolution) {
 879         detachAndRemoveAllObjects();
 880         destroyGraphicsContext3D();
 881         m_contextGroup-&gt;removeContext(*this);
 882     }
<a name="9" id="anc9"></a><span class="line-added"> 883 </span>
<span class="line-added"> 884     {</span>
<span class="line-added"> 885         LockHolder lock(WebGLProgram::instancesMutex());</span>
<span class="line-added"> 886         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-added"> 887             if (entry.value == this) {</span>
<span class="line-added"> 888                 // Don&#39;t remove any WebGLProgram from the instances list, as they may still exist.</span>
<span class="line-added"> 889                 // Only remove the association with a WebGL context.</span>
<span class="line-added"> 890                 entry.value = nullptr;</span>
<span class="line-added"> 891             }</span>
<span class="line-added"> 892         }</span>
<span class="line-added"> 893     }</span>
 894 }
 895 
 896 void WebGLRenderingContextBase::destroyGraphicsContext3D()
 897 {
 898     if (m_isPendingPolicyResolution)
 899         return;
 900 
 901     removeActivityStateChangeObserver();
 902 
 903     if (m_context) {
<a name="10" id="anc10"></a><span class="line-added"> 904         m_context-&gt;removeClient(*this);</span>
 905         m_context-&gt;setContextLostCallback(nullptr);
 906         m_context-&gt;setErrorMessageCallback(nullptr);
 907         m_context = nullptr;
 908     }
 909 }
 910 
 911 void WebGLRenderingContextBase::markContextChanged()
 912 {
 913     if (m_framebufferBinding)
 914         return;
 915 
 916     m_context-&gt;markContextChanged();
 917 
 918     m_layerCleared = false;
 919 
 920     auto* canvas = htmlCanvas();
 921     if (!canvas)
 922         return;
 923 
 924     RenderBox* renderBox = canvas-&gt;renderBox();
 925     if (isAccelerated() &amp;&amp; renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing()) {
 926         m_markedCanvasDirty = true;
 927         htmlCanvas()-&gt;clearCopiedImage();
 928         renderBox-&gt;contentChanged(CanvasPixelsChanged);
 929     } else {
 930         if (!m_markedCanvasDirty) {
 931             m_markedCanvasDirty = true;
 932             canvas-&gt;didDraw(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 933         }
 934     }
 935 }
 936 
 937 void WebGLRenderingContextBase::markContextChangedAndNotifyCanvasObserver()
 938 {
 939     markContextChanged();
 940     if (!isAccelerated())
 941         return;
 942 
 943     auto* canvas = htmlCanvas();
 944     if (!canvas)
 945         return;
 946 
 947     RenderBox* renderBox = canvas-&gt;renderBox();
 948     if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
 949         canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
 950 }
 951 
 952 bool WebGLRenderingContextBase::clearIfComposited(GC3Dbitfield mask)
 953 {
 954     if (isContextLostOrPending())
 955         return false;
 956 
 957     if (!m_context-&gt;layerComposited() || m_layerCleared
 958         || m_attributes.preserveDrawingBuffer || (mask &amp;&amp; m_framebufferBinding)
 959         || m_preventBufferClearForInspector)
 960         return false;
 961 
 962     auto contextAttributes = getContextAttributes();
 963     ASSERT(contextAttributes);
 964 
 965     // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
 966     bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
 967 
 968     m_context-&gt;disable(GraphicsContext3D::SCISSOR_TEST);
 969     if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT))
 970         m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
 971                               m_colorMask[1] ? m_clearColor[1] : 0,
 972                               m_colorMask[2] ? m_clearColor[2] : 0,
 973                               m_colorMask[3] ? m_clearColor[3] : 0);
 974     else
 975         m_context-&gt;clearColor(0, 0, 0, 0);
 976     m_context-&gt;colorMask(true, true, true, true);
 977     GC3Dbitfield clearMask = GraphicsContext3D::COLOR_BUFFER_BIT;
 978     if (contextAttributes-&gt;depth) {
 979         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT))
 980             m_context-&gt;clearDepth(1.0f);
 981         clearMask |= GraphicsContext3D::DEPTH_BUFFER_BIT;
 982         m_context-&gt;depthMask(true);
 983     }
 984     if (contextAttributes-&gt;stencil) {
 985         if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT))
 986             m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
 987         else
 988             m_context-&gt;clearStencil(0);
 989         clearMask |= GraphicsContext3D::STENCIL_BUFFER_BIT;
 990         m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, 0xFFFFFFFF);
 991     }
 992     if (m_framebufferBinding)
 993         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);
 994     m_context-&gt;clear(clearMask);
 995 
 996     restoreStateAfterClear();
 997     if (m_framebufferBinding)
 998         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
 999     m_layerCleared = true;
1000 
1001     return combinedClear;
1002 }
1003 
1004 void WebGLRenderingContextBase::restoreStateAfterClear()
1005 {
1006     // Restore the state that the context set.
1007     if (m_scissorEnabled)
1008         m_context-&gt;enable(GraphicsContext3D::SCISSOR_TEST);
1009     m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
1010                           m_clearColor[2], m_clearColor[3]);
1011     m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
1012                          m_colorMask[2], m_colorMask[3]);
1013     m_context-&gt;clearDepth(m_clearDepth);
1014     m_context-&gt;clearStencil(m_clearStencil);
1015     m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, m_stencilMask);
1016     m_context-&gt;depthMask(m_depthMask);
1017 }
1018 
1019 void WebGLRenderingContextBase::markLayerComposited()
1020 {
1021     if (isContextLostOrPending())
1022         return;
1023     m_context-&gt;markLayerComposited();
1024 }
1025 
1026 void WebGLRenderingContextBase::paintRenderingResultsToCanvas()
1027 {
1028     if (isContextLostOrPending())
1029         return;
1030 
1031     auto* canvas = htmlCanvas();
1032     if (!canvas)
1033         return;
1034 
1035     if (canvas-&gt;document().printing())
1036         canvas-&gt;clearPresentationCopy();
1037 
1038     // Until the canvas is written to by the application, the clear that
1039     // happened after it was composited should be ignored by the compositor.
1040     if (m_context-&gt;layerComposited() &amp;&amp; !m_attributes.preserveDrawingBuffer) {
1041         m_context-&gt;paintCompositedResultsToCanvas(canvas-&gt;buffer());
1042 
1043         canvas-&gt;makePresentationCopy();
1044     } else
1045         canvas-&gt;clearPresentationCopy();
1046     clearIfComposited();
1047 
1048     if (!m_markedCanvasDirty &amp;&amp; !m_layerCleared)
1049         return;
1050 
1051     canvas-&gt;clearCopiedImage();
1052     m_markedCanvasDirty = false;
1053 
1054     m_context-&gt;paintRenderingResultsToCanvas(canvas-&gt;buffer());
1055 }
1056 
1057 RefPtr&lt;ImageData&gt; WebGLRenderingContextBase::paintRenderingResultsToImageData()
1058 {
1059     if (isContextLostOrPending())
1060         return nullptr;
1061     clearIfComposited();
1062     return m_context-&gt;paintRenderingResultsToImageData();
1063 }
1064 
1065 WebGLTexture::TextureExtensionFlag WebGLRenderingContextBase::textureExtensionFlags() const
1066 {
1067     return static_cast&lt;WebGLTexture::TextureExtensionFlag&gt;((m_oesTextureFloatLinear ? WebGLTexture::TextureExtensionFloatLinearEnabled : 0) | (m_oesTextureHalfFloatLinear ? WebGLTexture::TextureExtensionHalfFloatLinearEnabled : 0));
1068 }
1069 
1070 void WebGLRenderingContextBase::reshape(int width, int height)
1071 {
1072     if (isContextLostOrPending())
1073         return;
1074 
1075     // This is an approximation because at WebGLRenderingContext level we don&#39;t
1076     // know if the underlying FBO uses textures or renderbuffers.
1077     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);
1078     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);
1079     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);
1080     width = clamp(width, 1, maxWidth);
1081     height = clamp(height, 1, maxHeight);
1082 
1083     if (m_needsUpdate) {
<a name="11" id="anc11"></a><span class="line-modified">1084         notifyCanvasContentChanged();</span>





1085         m_needsUpdate = false;
1086     }
1087 
1088     // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
1089     // clear (and this matches what reshape will do).
1090     m_context-&gt;reshape(width, height);
1091 
1092     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1093     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));
1094     if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
1095         m_unrenderableTextureUnits.add(m_activeTextureUnit);
1096     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));
1097     if (m_framebufferBinding)
1098       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));
1099 }
1100 
1101 int WebGLRenderingContextBase::drawingBufferWidth() const
1102 {
1103     if (isContextLost())
1104         return 0;
1105 
1106     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1107         return 0;
1108 
1109     return m_context-&gt;getInternalFramebufferSize().width();
1110 }
1111 
1112 int WebGLRenderingContextBase::drawingBufferHeight() const
1113 {
1114     if (isContextLost())
1115         return 0;
1116 
1117     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution)
1118         return 0;
1119 
1120     return m_context-&gt;getInternalFramebufferSize().height();
1121 }
1122 
1123 unsigned WebGLRenderingContextBase::sizeInBytes(GC3Denum type)
1124 {
1125     switch (type) {
1126     case GraphicsContext3D::BYTE:
1127         return sizeof(GC3Dbyte);
1128     case GraphicsContext3D::UNSIGNED_BYTE:
1129         return sizeof(GC3Dubyte);
1130     case GraphicsContext3D::SHORT:
1131         return sizeof(GC3Dshort);
1132     case GraphicsContext3D::UNSIGNED_SHORT:
1133         return sizeof(GC3Dushort);
1134     case GraphicsContext3D::INT:
1135         return sizeof(GC3Dint);
1136     case GraphicsContext3D::UNSIGNED_INT:
1137         return sizeof(GC3Duint);
1138     case GraphicsContext3D::FLOAT:
1139         return sizeof(GC3Dfloat);
1140     }
1141     ASSERT_NOT_REACHED();
1142     return 0;
1143 }
1144 
1145 void WebGLRenderingContextBase::activeTexture(GC3Denum texture)
1146 {
1147     if (isContextLostOrPending())
1148         return;
1149     if (texture - GraphicsContext3D::TEXTURE0 &gt;= m_textureUnits.size()) {
1150         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);
1151         return;
1152     }
1153     m_activeTextureUnit = texture - GraphicsContext3D::TEXTURE0;
1154     m_context-&gt;activeTexture(texture);
1155 }
1156 
1157 void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
1158 {
1159     if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
1160         return;
1161     if (!program-&gt;attachShader(shader)) {
1162         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);
1163         return;
1164     }
1165     m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
1166     shader-&gt;onAttached();
1167 }
1168 
1169 void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GC3Duint index, const String&amp; name)
1170 {
1171     if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
1172         return;
1173     if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
1174         return;
1175     if (!validateString(&quot;bindAttribLocation&quot;, name))
1176         return;
1177     if (isPrefixReserved(name)) {
1178         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);
1179         return;
1180     }
1181     if (index &gt;= m_maxVertexAttribs) {
1182         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);
1183         return;
1184     }
1185     m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
1186 }
1187 
1188 bool WebGLRenderingContextBase::checkObjectToBeBound(const char* functionName, WebGLObject* object, bool&amp; deleted)
1189 {
1190     deleted = false;
1191     if (isContextLostOrPending())
1192         return false;
1193     if (object) {
1194         if (!object-&gt;validate(contextGroup(), *this)) {
1195             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);
1196             return false;
1197         }
1198         deleted = !object-&gt;object();
1199     }
1200     return true;
1201 }
1202 
1203 void WebGLRenderingContextBase::bindBuffer(GC3Denum target, WebGLBuffer* buffer)
1204 {
1205     bool deleted;
1206     if (!checkObjectToBeBound(&quot;bindBuffer&quot;, buffer, deleted))
1207         return;
1208     if (deleted)
1209         buffer = nullptr;
1210     if (buffer &amp;&amp; buffer-&gt;getTarget() &amp;&amp; buffer-&gt;getTarget() != target) {
1211         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindBuffer&quot;, &quot;buffers can not be used with multiple targets&quot;);
1212         return;
1213     }
1214     if (target == GraphicsContext3D::ARRAY_BUFFER)
1215         m_boundArrayBuffer = buffer;
1216     else if (target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
1217         m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
1218     else {
1219         bool success = false;
1220 #if ENABLE(WEBGL2)
1221         if (isWebGL2()) {
1222             success = true;
1223             switch (target) {
1224             case GraphicsContext3D::COPY_READ_BUFFER:
1225                 m_boundCopyReadBuffer = buffer;
1226                 break;
1227             case GraphicsContext3D::COPY_WRITE_BUFFER:
1228                 m_boundCopyWriteBuffer = buffer;
1229                 break;
1230             case GraphicsContext3D::PIXEL_PACK_BUFFER:
1231                 m_boundPixelPackBuffer = buffer;
1232                 break;
1233             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
1234                 m_boundPixelUnpackBuffer = buffer;
1235                 break;
1236             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
1237                 m_boundTransformFeedbackBuffer = buffer;
1238                 break;
1239             case GraphicsContext3D::UNIFORM_BUFFER:
1240                 m_boundUniformBuffer = buffer;
1241                 break;
1242             default:
1243                 success = false;
1244                 break;
1245             }
1246         }
1247 #endif
1248         if (!success) {
1249             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);
1250             return;
1251         }
1252     }
1253 
1254     m_context-&gt;bindBuffer(target, objectOrZero(buffer));
1255     if (buffer)
1256         buffer-&gt;setTarget(target, isWebGL2());
1257 }
1258 
1259 void WebGLRenderingContextBase::bindFramebuffer(GC3Denum target, WebGLFramebuffer* buffer)
1260 {
1261     bool deleted;
1262     if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
1263         return;
1264     if (deleted)
1265         buffer = 0;
1266 
1267     bool isWebGL2DrawFramebufferTarget = false;
1268 #if ENABLE(WEBGL2)
1269     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContext3D::DRAW_FRAMEBUFFER;
1270 #endif
1271     bool success = false;
1272 
1273     if (target == GraphicsContext3D::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {
1274         m_framebufferBinding = buffer;
1275         success = true;
1276     }
1277 #if ENABLE(WEBGL2)
1278     if (isWebGL2() &amp;&amp; (target == GraphicsContext3D::FRAMEBUFFER || target == GraphicsContext3D::READ_FRAMEBUFFER)) {
1279         m_readFramebufferBinding = buffer;
1280         success = true;
1281     }
1282 #endif
1283 
1284     if (!success) {
1285         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);
1286         return;
1287     }
1288 
1289     m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
1290     if (buffer)
1291         buffer-&gt;setHasEverBeenBound();
1292     applyStencilTest();
1293 }
1294 
1295 void WebGLRenderingContextBase::bindRenderbuffer(GC3Denum target, WebGLRenderbuffer* renderBuffer)
1296 {
1297     bool deleted;
1298     if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
1299         return;
1300     if (deleted)
1301         renderBuffer = 0;
1302     if (target != GraphicsContext3D::RENDERBUFFER) {
1303         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);
1304         return;
1305     }
1306     m_renderbufferBinding = renderBuffer;
1307     m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
1308     if (renderBuffer)
1309         renderBuffer-&gt;setHasEverBeenBound();
1310 }
1311 
1312 void WebGLRenderingContextBase::bindTexture(GC3Denum target, WebGLTexture* texture)
1313 {
1314     bool deleted;
1315     if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
1316         return;
1317     if (deleted)
1318         texture = nullptr;
1319     if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
1320         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);
1321         return;
1322     }
1323     GC3Dint maxLevel = 0;
1324     auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
1325     if (target == GraphicsContext3D::TEXTURE_2D) {
1326         textureUnit.texture2DBinding = texture;
1327         maxLevel = m_maxTextureLevel;
1328         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1329             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1330         else
1331             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1332     } else if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {
1333         textureUnit.textureCubeMapBinding = texture;
1334         maxLevel = m_maxCubeMapTextureLevel;
1335         if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
1336             m_unrenderableTextureUnits.add(m_activeTextureUnit);
1337         else
1338             m_unrenderableTextureUnits.remove(m_activeTextureUnit);
1339     } else {
1340         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);
1341         return;
1342     }
1343     m_context-&gt;bindTexture(target, objectOrZero(texture));
1344     if (texture)
1345         texture-&gt;setTarget(target, maxLevel);
1346 
1347     // Note: previously we used to automatically set the TEXTURE_WRAP_R
1348     // repeat mode to CLAMP_TO_EDGE for cube map textures, because OpenGL
1349     // ES 2.0 doesn&#39;t expose this flag (a bug in the specification) and
1350     // otherwise the application has no control over the seams in this
1351     // dimension. However, it appears that supporting this properly on all
1352     // platforms is fairly involved (will require a HashMap from texture ID
1353     // in all ports), and we have not had any complaints, so the logic has
1354     // been removed.
1355 }
1356 
1357 void WebGLRenderingContextBase::blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha)
1358 {
1359     if (isContextLostOrPending())
1360         return;
1361     m_context-&gt;blendColor(red, green, blue, alpha);
1362 }
1363 
1364 void WebGLRenderingContextBase::blendEquation(GC3Denum mode)
1365 {
1366     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
1367         return;
1368     m_context-&gt;blendEquation(mode);
1369 }
1370 
1371 void WebGLRenderingContextBase::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)
1372 {
1373     if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
1374         return;
1375     m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
1376 }
1377 
1378 
1379 void WebGLRenderingContextBase::blendFunc(GC3Denum sfactor, GC3Denum dfactor)
1380 {
1381     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
1382         return;
1383     m_context-&gt;blendFunc(sfactor, dfactor);
1384 }
1385 
1386 void WebGLRenderingContextBase::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)
1387 {
1388     // Note: Alpha does not have the same restrictions as RGB.
1389     if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
1390         return;
1391     m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
1392 }
1393 
1394 void WebGLRenderingContextBase::bufferData(GC3Denum target, long long size, GC3Denum usage)
1395 {
1396     if (isContextLostOrPending())
1397         return;
1398     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1399     if (!buffer)
1400         return;
1401     if (size &lt; 0) {
1402         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);
1403         return;
1404     }
1405     if (!size) {
1406         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);
1407         return;
1408     }
1409     if (!buffer-&gt;associateBufferData(static_cast&lt;GC3Dsizeiptr&gt;(size))) {
1410         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1411         return;
1412     }
1413 
1414     m_context-&gt;moveErrorsToSyntheticErrorList();
1415     m_context-&gt;bufferData(target, static_cast&lt;GC3Dsizeiptr&gt;(size), usage);
1416     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1417         // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1418         buffer-&gt;disassociateBufferData();
1419     }
1420 }
1421 
1422 void WebGLRenderingContextBase::bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GC3Denum usage)
1423 {
1424     if (isContextLostOrPending())
1425         return;
1426     if (!data) {
1427         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);
1428         return;
1429     }
1430     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
1431     if (!buffer)
1432         return;
1433 
1434     WTF::visit([&amp;](auto&amp; data) {
1435         if (!buffer-&gt;associateBufferData(data.get())) {
1436             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);
1437             return;
1438         }
1439 
1440         m_context-&gt;moveErrorsToSyntheticErrorList();
1441         m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
1442         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1443             // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1444             buffer-&gt;disassociateBufferData();
1445         }
1446     }, data.value());
1447 }
1448 
1449 void WebGLRenderingContextBase::bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)
1450 {
1451     if (isContextLostOrPending())
1452         return;
1453     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContext3D::STATIC_DRAW);
1454     if (!buffer)
1455         return;
1456     if (offset &lt; 0) {
1457         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);
1458         return;
1459     }
1460     if (!data)
1461         return;
1462 
1463     WTF::visit([&amp;](auto&amp; data) {
1464         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GC3Dintptr&gt;(offset), data.get())) {
1465             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);
1466             return;
1467         }
1468 
1469         m_context-&gt;moveErrorsToSyntheticErrorList();
1470         m_context-&gt;bufferSubData(target, static_cast&lt;GC3Dintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());
1471         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1472             // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
1473             buffer-&gt;disassociateBufferData();
1474         }
1475     }, data.value());
1476 }
1477 
1478 GC3Denum WebGLRenderingContextBase::checkFramebufferStatus(GC3Denum target)
1479 {
1480     if (isContextLostOrPending())
1481         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;
1482     if (target != GraphicsContext3D::FRAMEBUFFER) {
1483 #if ENABLE(WEBGL2)
1484         if (isWebGL1() || (target != GraphicsContext3D::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContext3D::READ_FRAMEBUFFER)) {
1485 #endif
1486             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);
1487             return 0;
1488 #if ENABLE(WEBGL2)
1489         }
1490 #endif
1491     }
1492 
1493     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
1494 
1495     if (!targetFramebuffer || !targetFramebuffer-&gt;object())
1496         return GraphicsContext3D::FRAMEBUFFER_COMPLETE;
1497     const char* reason = &quot;framebuffer incomplete&quot;;
1498     GC3Denum result = targetFramebuffer-&gt;checkStatus(&amp;reason);
1499     if (result != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
1500         String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
1501         printToConsole(MessageLevel::Warning, str);
1502         return result;
1503     }
1504     result = m_context-&gt;checkFramebufferStatus(target);
1505     return result;
1506 }
1507 
1508 void WebGLRenderingContextBase::clearColor(GC3Dfloat r, GC3Dfloat g, GC3Dfloat b, GC3Dfloat a)
1509 {
1510     if (isContextLostOrPending())
1511         return;
1512     if (std::isnan(r))
1513         r = 0;
1514     if (std::isnan(g))
1515         g = 0;
1516     if (std::isnan(b))
1517         b = 0;
1518     if (std::isnan(a))
1519         a = 1;
1520     m_clearColor[0] = r;
1521     m_clearColor[1] = g;
1522     m_clearColor[2] = b;
1523     m_clearColor[3] = a;
1524     m_context-&gt;clearColor(r, g, b, a);
1525 }
1526 
1527 void WebGLRenderingContextBase::clearDepth(GC3Dfloat depth)
1528 {
1529     if (isContextLostOrPending())
1530         return;
1531     m_clearDepth = depth;
1532     m_context-&gt;clearDepth(depth);
1533 }
1534 
1535 void WebGLRenderingContextBase::clearStencil(GC3Dint s)
1536 {
1537     if (isContextLostOrPending())
1538         return;
1539     m_clearStencil = s;
1540     m_context-&gt;clearStencil(s);
1541 }
1542 
1543 void WebGLRenderingContextBase::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)
1544 {
1545     if (isContextLostOrPending())
1546         return;
1547     m_colorMask[0] = red;
1548     m_colorMask[1] = green;
1549     m_colorMask[2] = blue;
1550     m_colorMask[3] = alpha;
1551     m_context-&gt;colorMask(red, green, blue, alpha);
1552 }
1553 
1554 void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
1555 {
1556     if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
1557         return;
1558     m_context-&gt;compileShader(objectOrZero(shader));
1559     GC3Dint value;
1560     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);
1561     shader-&gt;setValid(value);
1562 
1563     auto* canvas = htmlCanvas();
1564 
1565     if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
1566         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
1567 
1568         for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
<a name="12" id="anc12"></a><span class="line-modified">1569             canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));</span>
1570     }
1571 }
1572 
1573 void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)
1574 {
1575     if (isContextLostOrPending())
1576         return;
1577     if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
1578         return;
1579 
1580     if (!validateCompressedTexFormat(internalformat)) {
1581         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);
1582         return;
1583     }
1584     if (border) {
1585         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);
1586         return;
1587     }
1588     if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
1589         return;
1590     if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
1591         return;
1592 
1593     auto tex = validateTextureBinding(&quot;compressedTexImage2D&quot;, target, true);
1594     if (!tex)
1595         return;
1596     if (!validateNPOTTextureLevel(width, height, level, &quot;compressedTexImage2D&quot;))
1597         return;
1598     m_context-&gt;moveErrorsToSyntheticErrorList();
1599     m_context-&gt;compressedTexImage2D(target, level, internalformat, width, height,
1600         border, data.byteLength(), data.baseAddress());
1601     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
1602         // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
1603         tex-&gt;markInvalid(target, level);
1604         return;
1605     }
1606 
1607     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContext3D::UNSIGNED_BYTE);
1608     tex-&gt;setCompressed();
1609 }
1610 
1611 void WebGLRenderingContextBase::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data)
1612 {
1613     if (isContextLostOrPending())
1614         return;
1615     if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
1616         return;
1617     if (!validateCompressedTexFormat(format)) {
1618         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);
1619         return;
1620     }
1621     if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
1622         return;
1623 
1624     auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
1625     if (!tex)
1626         return;
1627 
1628     if (format != tex-&gt;getInternalFormat(target, level)) {
1629         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);
1630         return;
1631     }
1632 
1633     if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
1634         return;
1635 
1636     graphicsContext3D()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());
1637     tex-&gt;setCompressed();
1638 }
1639 
1640 bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GC3Denum internalFormat)
1641 {
1642     switch (internalFormat) {
1643     case GraphicsContext3D::DEPTH_COMPONENT:
1644     case GraphicsContext3D::DEPTH_STENCIL:
1645     case GraphicsContext3D::DEPTH_COMPONENT16:
1646     case GraphicsContext3D::DEPTH_COMPONENT24:
1647     case GraphicsContext3D::DEPTH_COMPONENT32F:
1648     case GraphicsContext3D::DEPTH24_STENCIL8:
1649     case GraphicsContext3D::DEPTH32F_STENCIL8:
1650     case GraphicsContext3D::STENCIL_INDEX8:
1651         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);
1652         return false;
1653     default:
1654         return true;
1655     }
1656 }
1657 
1658 void WebGLRenderingContextBase::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
1659 {
1660     if (isContextLostOrPending())
1661         return;
1662     if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
1663         return;
1664     auto tex = validateTextureBinding(&quot;copyTexSubImage2D&quot;, target, true);
1665     if (!tex)
1666         return;
1667     if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
1668         return;
1669     // Before checking if it is in the range, check if overflow happens first.
1670     if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
1671         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1672         return;
1673     }
1674     if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
1675         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);
1676         return;
1677     }
1678     GC3Denum internalFormat = tex-&gt;getInternalFormat(target, level);
1679     if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
1680         return;
1681     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
1682         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
1683         return;
1684     }
1685     const char* reason = &quot;framebuffer incomplete&quot;;
1686     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
1687         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);
1688         return;
1689     }
1690     clearIfComposited();
1691 
1692     GC3Dint clippedX, clippedY;
1693     GC3Dsizei clippedWidth, clippedHeight;
1694     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
1695         GC3Denum format;
1696         GC3Denum type;
1697         if (!GraphicsContext3D::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {
1698             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);
1699             return;
1700         }
1701         UniqueArray&lt;unsigned char&gt; zero;
1702         if (width &amp;&amp; height) {
1703             unsigned size;
1704             GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);
1705             if (error != GraphicsContext3D::NO_ERROR) {
1706                 synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
1707                 return;
1708             }
1709             zero = makeUniqueArray&lt;unsigned char&gt;(size);
1710             if (!zero) {
1711                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);
1712                 return;
1713             }
1714             memset(zero.get(), 0, size);
1715         }
1716         m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
1717         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0)
1718             m_context-&gt;copyTexSubImage2D(target, level, xoffset + clippedX - x, yoffset + clippedY - y, clippedX, clippedY, clippedWidth, clippedHeight);
1719     } else
1720         m_context-&gt;copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
1721 }
1722 
1723 RefPtr&lt;WebGLBuffer&gt; WebGLRenderingContextBase::createBuffer()
1724 {
1725     if (isContextLostOrPending())
1726         return nullptr;
1727     auto buffer = WebGLBuffer::create(*this);
1728     addSharedObject(buffer.get());
<a name="13" id="anc13"></a><span class="line-modified">1729     return buffer;</span>
1730 }
1731 
1732 RefPtr&lt;WebGLFramebuffer&gt; WebGLRenderingContextBase::createFramebuffer()
1733 {
1734     if (isContextLostOrPending())
1735         return nullptr;
1736     auto buffer = WebGLFramebuffer::create(*this);
1737     addContextObject(buffer.get());
<a name="14" id="anc14"></a><span class="line-modified">1738     return buffer;</span>
1739 }
1740 
1741 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::createTexture()
1742 {
1743     if (isContextLostOrPending())
1744         return nullptr;
1745     auto texture = WebGLTexture::create(*this);
1746     addSharedObject(texture.get());
<a name="15" id="anc15"></a><span class="line-modified">1747     return texture;</span>
1748 }
1749 
1750 RefPtr&lt;WebGLProgram&gt; WebGLRenderingContextBase::createProgram()
1751 {
1752     if (isContextLostOrPending())
1753         return nullptr;
1754     auto program = WebGLProgram::create(*this);
1755     addSharedObject(program.get());
1756 
1757     InspectorInstrumentation::didCreateProgram(*this, program.get());
1758 
<a name="16" id="anc16"></a><span class="line-modified">1759     return program;</span>
1760 }
1761 
1762 RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
1763 {
1764     if (isContextLostOrPending())
1765         return nullptr;
1766     auto buffer = WebGLRenderbuffer::create(*this);
1767     addSharedObject(buffer.get());
<a name="17" id="anc17"></a><span class="line-modified">1768     return buffer;</span>
1769 }
1770 
1771 RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)
1772 {
1773     if (isContextLostOrPending())
1774         return nullptr;
1775     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {
1776         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);
1777         return nullptr;
1778     }
1779 
1780     auto shader = WebGLShader::create(*this, type);
1781     addSharedObject(shader.get());
<a name="18" id="anc18"></a><span class="line-modified">1782     return shader;</span>
1783 }
1784 
1785 void WebGLRenderingContextBase::cullFace(GC3Denum mode)
1786 {
1787     if (isContextLostOrPending())
1788         return;
1789     m_context-&gt;cullFace(mode);
1790 }
1791 
1792 bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
1793 {
1794     if (isContextLostOrPending() || !object)
1795         return false;
1796     if (!object-&gt;validate(contextGroup(), *this)) {
1797         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);
1798         return false;
1799     }
1800     if (object-&gt;isDeleted())
1801         return false;
1802     if (object-&gt;object())
1803         // We need to pass in context here because we want
1804         // things in this context unbound.
1805         object-&gt;deleteObject(graphicsContext3D());
1806     return true;
1807 }
1808 
1809 void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
1810 {
1811     if (!deleteObject(buffer))
1812         return;
1813     if (m_boundArrayBuffer == buffer)
1814         m_boundArrayBuffer = nullptr;
1815 
1816     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);
1817 }
1818 
1819 void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
1820 {
1821     if (!deleteObject(framebuffer))
1822         return;
1823 #if ENABLE(WEBGL2)
1824     if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
1825         m_readFramebufferBinding = nullptr;
1826         m_context-&gt;bindFramebuffer(GraphicsContext3D::READ_FRAMEBUFFER, 0);
1827     }
1828 #endif
1829     if (framebuffer == m_framebufferBinding) {
1830         m_framebufferBinding = nullptr;
1831 #if ENABLE(WEBGL2)
1832         if (isWebGL2())
1833             m_context-&gt;bindFramebuffer(GraphicsContext3D::DRAW_FRAMEBUFFER, 0);
1834         else
1835 #endif
1836             m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);
1837     }
1838 }
1839 
1840 void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
1841 {
1842     if (program)
1843         InspectorInstrumentation::willDeleteProgram(*this, *program);
1844 
1845     deleteObject(program);
1846     // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
1847     // current program is delayed.
1848 }
1849 
1850 void WebGLRenderingContextBase::deleteRenderbuffer(WebGLRenderbuffer* renderbuffer)
1851 {
1852     if (!deleteObject(renderbuffer))
1853         return;
1854     if (renderbuffer == m_renderbufferBinding)
1855         m_renderbufferBinding = nullptr;
1856     if (m_framebufferBinding)
1857         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(renderbuffer);
1858 }
1859 
1860 void WebGLRenderingContextBase::deleteShader(WebGLShader* shader)
1861 {
1862     deleteObject(shader);
1863 }
1864 
1865 void WebGLRenderingContextBase::deleteTexture(WebGLTexture* texture)
1866 {
1867     if (!deleteObject(texture))
1868         return;
1869 
1870     unsigned current = 0;
1871     for (auto&amp; textureUnit : m_textureUnits) {
1872         if (texture == textureUnit.texture2DBinding) {
1873             textureUnit.texture2DBinding = nullptr;
1874             m_unrenderableTextureUnits.remove(current);
1875         }
1876         if (texture == textureUnit.textureCubeMapBinding) {
1877             textureUnit.textureCubeMapBinding = nullptr;
1878             m_unrenderableTextureUnits.remove(current);
1879         }
1880         ++current;
1881     }
1882     if (m_framebufferBinding)
1883         m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
1884 }
1885 
1886 void WebGLRenderingContextBase::depthFunc(GC3Denum func)
1887 {
1888     if (isContextLostOrPending())
1889         return;
1890     m_context-&gt;depthFunc(func);
1891 }
1892 
1893 void WebGLRenderingContextBase::depthMask(GC3Dboolean flag)
1894 {
1895     if (isContextLostOrPending())
1896         return;
1897     m_depthMask = flag;
1898     m_context-&gt;depthMask(flag);
1899 }
1900 
1901 void WebGLRenderingContextBase::depthRange(GC3Dfloat zNear, GC3Dfloat zFar)
1902 {
1903     if (isContextLostOrPending())
1904         return;
1905     if (zNear &gt; zFar) {
1906         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);
1907         return;
1908     }
1909     m_context-&gt;depthRange(zNear, zFar);
1910 }
1911 
1912 void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
1913 {
1914     if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
1915         return;
1916     if (!program-&gt;detachShader(shader)) {
1917         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);
1918         return;
1919     }
1920     m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
1921     shader-&gt;onDetached(graphicsContext3D());
1922 }
1923 
1924 void WebGLRenderingContextBase::disable(GC3Denum cap)
1925 {
1926     if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
1927         return;
1928     if (cap == GraphicsContext3D::STENCIL_TEST) {
1929         m_stencilEnabled = false;
1930         applyStencilTest();
1931         return;
1932     }
1933     if (cap == GraphicsContext3D::SCISSOR_TEST)
1934         m_scissorEnabled = false;
1935     m_context-&gt;disable(cap);
1936 }
1937 
1938 void WebGLRenderingContextBase::disableVertexAttribArray(GC3Duint index)
1939 {
1940     if (isContextLostOrPending())
1941         return;
1942     if (index &gt;= m_maxVertexAttribs) {
1943         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);
1944         return;
1945     }
1946 
1947     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
1948     state.enabled = false;
1949 
1950     if (index &gt; 0 || isGLES2Compliant())
1951         m_context-&gt;disableVertexAttribArray(index);
1952 }
1953 
1954 bool WebGLRenderingContextBase::validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName)
1955 {
1956     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
1957         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);
1958         return false;
1959     }
1960 
1961     return true;
1962 }
1963 
1964 bool WebGLRenderingContextBase::validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset)
1965 {
1966     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
1967 
1968     if (!elementArrayBuffer)
1969         return false;
1970 
1971     if (offset &lt; 0)
1972         return false;
1973 
1974     if (type == GraphicsContext3D::UNSIGNED_INT) {
1975         // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
1976         if (offset % 4)
1977             return false;
1978 
1979         // Make uoffset an element offset.
1980         offset /= 4;
1981 
1982         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;
1983         if (offset &gt; n || count &gt; n - offset)
1984             return false;
1985     } else if (type == GraphicsContext3D::UNSIGNED_SHORT) {
1986         // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
1987         if (offset % 2)
1988             return false;
1989 
1990         // Make uoffset an element offset.
1991         offset /= 2;
1992 
1993         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;
1994         if (offset &gt; n || count &gt; n - offset)
1995             return false;
1996     } else if (type == GraphicsContext3D::UNSIGNED_BYTE) {
1997         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength();
1998         if (offset &gt; n || count &gt; n - offset)
1999             return false;
2000     }
2001     return true;
2002 }
2003 
2004 bool WebGLRenderingContextBase::validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired)
2005 {
2006     ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
2007     unsigned maxIndex = 0;
2008 
2009     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2010 
2011     if (!elementArrayBuffer)
2012         return false;
2013 
2014     if (!count) {
2015         numElementsRequired = 0;
2016         return true;
2017     }
2018 
2019     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2020     if (!buffer)
2021         return false;
2022 
2023     switch (type) {
2024     case GraphicsContext3D::UNSIGNED_INT:
2025         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);
2026         break;
2027     case GraphicsContext3D::UNSIGNED_SHORT:
2028         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);
2029         break;
2030     case GraphicsContext3D::UNSIGNED_BYTE:
2031         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);
2032         break;
2033     }
2034 
2035     // Then set the maxiumum index in the index array and make sure it is valid.
2036     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
2037     if (!checkedNumElementsRequired)
2038         return false;
2039     numElementsRequired = checkedNumElementsRequired.value();
2040     return true;
2041 }
2042 
2043 bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
2044 {
<a name="19" id="anc19"></a><span class="line-added">2045 #if !USE(ANGLE)</span>
2046     if (!m_currentProgram)
2047         return false;
2048 
2049     // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
2050     for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
2051         if (!m_boundVertexArrayObject-&gt;getVertexAttribState(i).validateBinding())
2052             return false;
2053     }
2054 
2055     if (!elementCount)
2056         return true;
2057 
2058     // Look in each consumed vertex attrib (by the current program).
2059     bool sawNonInstancedAttrib = false;
2060     bool sawEnabledAttrib = false;
2061     int numActiveAttribLocations = m_currentProgram-&gt;numActiveAttribLocations();
2062     for (int i = 0; i &lt; numActiveAttribLocations; ++i) {
2063         int loc = m_currentProgram-&gt;getActiveAttribLocation(i);
2064         if (loc &gt;= 0 &amp;&amp; loc &lt; static_cast&lt;int&gt;(m_maxVertexAttribs)) {
2065             const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(loc);
2066             if (state.enabled) {
2067                 sawEnabledAttrib = true;
2068                 // Avoid off-by-one errors in numElements computation.
2069                 // For the last element, we will only touch the data for the
2070                 // element and nothing beyond it.
2071                 int bytesRemaining = static_cast&lt;int&gt;(state.bufferBinding-&gt;byteLength() - state.offset);
2072                 if (bytesRemaining &lt;= 0)
2073                     return false;
2074                 unsigned numElements = 0;
2075                 ASSERT(state.stride &gt; 0);
2076                 if (bytesRemaining &gt;= state.bytesPerElement)
2077                     numElements = 1 + (bytesRemaining - state.bytesPerElement) / state.stride;
2078                 unsigned instancesRequired = 0;
2079                 if (state.divisor) {
2080                     instancesRequired = ceil(static_cast&lt;float&gt;(primitiveCount) / state.divisor);
2081                     if (instancesRequired &gt; numElements)
2082                         return false;
2083                 } else {
2084                     sawNonInstancedAttrib = true;
2085                     if (elementCount &gt; numElements)
2086                         return false;
2087                 }
2088             }
2089         }
2090     }
2091 
2092     if (!sawNonInstancedAttrib &amp;&amp; sawEnabledAttrib)
2093         return false;
2094 
2095     bool usingSimulatedArrayBuffer = m_currentProgram-&gt;isUsingVertexAttrib0();
2096 
2097     // Guard against access into non-existent buffers.
2098     if (elementCount &amp;&amp; !sawEnabledAttrib &amp;&amp; !usingSimulatedArrayBuffer)
2099         return false;
2100 
2101     if (elementCount &amp;&amp; sawEnabledAttrib) {
2102         if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2103             if (usingSimulatedArrayBuffer) {
2104                 auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
2105                 if (state.enabled &amp;&amp; state.isBound()) {
2106                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2107                         return !!state.bufferBinding-&gt;byteLength();
2108                 }
2109             }
2110             return false;
2111         }
2112     }
<a name="20" id="anc20"></a><span class="line-added">2113 #endif</span>
2114 
2115     return true;
2116 }
2117 
2118 bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
2119 {
2120     if (!object || !object-&gt;object()) {
2121         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);
2122         return false;
2123     }
2124     if (!object-&gt;validate(contextGroup(), *this)) {
2125         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);
2126         return false;
2127     }
2128     return true;
2129 }
2130 
2131 bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)
2132 {
2133     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2134         return false;
2135 
2136     if (!validateStencilSettings(functionName))
2137         return false;
2138 
2139     if (first &lt; 0 || count &lt; 0) {
2140         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);
2141         return false;
2142     }
2143 
2144     if (!count) {
2145         markContextChanged();
2146         return false;
2147     }
2148 
2149     if (primitiveCount &lt; 0) {
2150         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2151         return false;
2152     }
2153 
2154     // Ensure we have a valid rendering state.
2155     Checked&lt;GC3Dint, RecordOverflow&gt; checkedSum = Checked&lt;GC3Dint, RecordOverflow&gt;(first) + Checked&lt;GC3Dint, RecordOverflow&gt;(count);
2156     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2157     if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
2158         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2159         return false;
2160     }
2161     if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
2162         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2163         return false;
2164     }
2165 
2166     const char* reason = &quot;framebuffer incomplete&quot;;
2167     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
2168         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2169         return false;
2170     }
2171 
2172     return true;
2173 }
2174 
2175 bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primitiveCount)
2176 {
2177     if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
2178         return false;
2179 
2180     if (!validateStencilSettings(functionName))
2181         return false;
2182 
2183     switch (type) {
2184     case GraphicsContext3D::UNSIGNED_BYTE:
2185     case GraphicsContext3D::UNSIGNED_SHORT:
2186         break;
2187     case GraphicsContext3D::UNSIGNED_INT:
2188         if (m_oesElementIndexUint || isWebGL2())
2189             break;
2190         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2191         return false;
2192     default:
2193         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);
2194         return false;
2195     }
2196 
2197     if (count &lt; 0 || offset &lt; 0) {
2198         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);
2199         return false;
2200     }
2201 
2202     if (!count) {
2203         markContextChanged();
2204         return false;
2205     }
2206 
2207     if (primitiveCount &lt; 0) {
2208         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);
2209         return false;
2210     }
2211 
2212     if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
2213         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);
2214         return false;
2215     }
2216 
2217     // Ensure we have a valid rendering state.
2218     if (!validateElementArraySize(count, type, static_cast&lt;GC3Dintptr&gt;(offset))) {
2219         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);
2220         return false;
2221     }
2222     if (!count)
2223         return false;
2224 
2225     Checked&lt;GC3Dint, RecordOverflow&gt; checkedCount(count);
2226     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);
2227     if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
2228         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2229         return false;
2230     }
2231 
2232     if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2233         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GC3Dintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
2234             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);
2235             return false;
2236         }
2237     }
2238 
2239     if (!validateSimulatedVertexAttrib0(numElements)) {
2240         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);
2241         return false;
2242     }
2243 
2244     const char* reason = &quot;framebuffer incomplete&quot;;
2245     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
2246         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);
2247         return false;
2248     }
2249 
2250     return true;
2251 }
2252 
2253 void WebGLRenderingContextBase::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)
2254 {
2255     if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
2256         return;
2257 
2258     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))
2259         return;
2260 
2261     clearIfComposited();
2262 
2263     bool vertexAttrib0Simulated = false;
2264     if (!isGLES2Compliant()) {
2265         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
2266         if (!simulateVertexAttrib0Status) {
2267             // We were unable to simulate the attribute buffer.
2268             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2269             return;
2270         }
2271         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2272     }
2273     bool usesFallbackTexture = false;
2274     if (!isGLES2NPOTStrict())
2275         usesFallbackTexture = checkTextureCompleteness(&quot;drawArrays&quot;, true);
2276 
2277     {
2278         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2279 
2280         m_context-&gt;drawArrays(mode, first, count);
2281     }
2282 
2283     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2284         restoreStatesAfterVertexAttrib0Simulation();
2285     if (usesFallbackTexture)
2286         checkTextureCompleteness(&quot;drawArrays&quot;, false);
2287     markContextChangedAndNotifyCanvasObserver();
2288 }
2289 
2290 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2291 static GC3Duint getRestartIndex(GC3Denum type)
2292 {
2293     switch (type) {
2294     case GraphicsContext3D::UNSIGNED_BYTE:
2295         return std::numeric_limits&lt;GC3Dubyte&gt;::max();
2296     case GraphicsContext3D::UNSIGNED_SHORT:
2297         return std::numeric_limits&lt;GC3Dushort&gt;::max();
2298     case GraphicsContext3D::UNSIGNED_INT:
2299         return std::numeric_limits&lt;GC3Duint&gt;::max();
2300     }
2301 
2302     return 0;
2303 }
2304 #endif
2305 
2306 void WebGLRenderingContextBase::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset)
2307 {
2308     unsigned numElements = 0;
2309     if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
2310         return;
2311 
2312     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))
2313         return;
2314 
2315     clearIfComposited();
2316 
2317     bool vertexAttrib0Simulated = false;
2318     if (!isGLES2Compliant()) {
2319         if (!numElements)
2320             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);
2321         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
2322         if (!simulateVertexAttrib0Status) {
2323             // We were unable to simulate the attribute buffer.
2324             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
2325             return;
2326         }
2327         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
2328     }
2329 
2330     bool usesFallbackTexture = false;
2331     if (!isGLES2NPOTStrict())
2332         usesFallbackTexture = checkTextureCompleteness(&quot;drawElements&quot;, true);
2333 
2334 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
2335     if (isWebGL2())
2336         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
2337 #endif
2338 
2339     {
2340         InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
2341 
2342         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset));
2343     }
2344 
2345     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
2346         restoreStatesAfterVertexAttrib0Simulation();
2347     if (usesFallbackTexture)
2348         checkTextureCompleteness(&quot;drawElements&quot;, false);
2349     markContextChangedAndNotifyCanvasObserver();
2350 }
2351 
2352 void WebGLRenderingContextBase::enable(GC3Denum cap)
2353 {
2354     if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
2355         return;
2356     if (cap == GraphicsContext3D::STENCIL_TEST) {
2357         m_stencilEnabled = true;
2358         applyStencilTest();
2359         return;
2360     }
2361     if (cap == GraphicsContext3D::SCISSOR_TEST)
2362         m_scissorEnabled = true;
2363     m_context-&gt;enable(cap);
2364 }
2365 
2366 void WebGLRenderingContextBase::enableVertexAttribArray(GC3Duint index)
2367 {
2368     if (isContextLostOrPending())
2369         return;
2370     if (index &gt;= m_maxVertexAttribs) {
2371         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);
2372         return;
2373     }
2374 
2375     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
2376     state.enabled = true;
2377 
2378     m_context-&gt;enableVertexAttribArray(index);
2379 }
2380 
2381 void WebGLRenderingContextBase::finish()
2382 {
2383     if (isContextLostOrPending())
2384         return;
2385     m_context-&gt;finish();
2386 }
2387 
2388 void WebGLRenderingContextBase::flush()
2389 {
2390     if (isContextLostOrPending())
2391         return;
2392     m_context-&gt;flush();
2393 }
2394 
2395 void WebGLRenderingContextBase::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer* buffer)
2396 {
2397     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
2398         return;
2399     if (renderbuffertarget != GraphicsContext3D::RENDERBUFFER) {
2400         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);
2401         return;
2402     }
2403     if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
2404         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);
2405         return;
2406     }
2407 
2408     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2409 
2410     // Don&#39;t allow the default framebuffer to be mutated; all current
2411     // implementations use an FBO internally in place of the default
2412     // FBO.
2413     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2414         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);
2415         return;
2416     }
2417     Platform3DObject bufferObject = objectOrZero(buffer);
2418     switch (attachment) {
2419     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:
2420         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);
2421         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);
2422         break;
2423     default:
2424         m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
2425     }
2426     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
2427     applyStencilTest();
2428 }
2429 
2430 void WebGLRenderingContextBase::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture* texture, GC3Dint level)
2431 {
2432     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
2433         return;
2434     if (level &amp;&amp; isWebGL1()) {
2435         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);
2436         return;
2437     }
2438     if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
2439         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);
2440         return;
2441     }
2442 
2443     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
2444 
2445     // Don&#39;t allow the default framebuffer to be mutated; all current
2446     // implementations use an FBO internally in place of the default
2447     // FBO.
2448     if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
2449         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);
2450         return;
2451     }
2452     Platform3DObject textureObject = objectOrZero(texture);
2453     switch (attachment) {
2454     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:
2455         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::DEPTH_ATTACHMENT, textarget, textureObject, level);
2456         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::STENCIL_ATTACHMENT, textarget, textureObject, level);
2457         break;
2458     case GraphicsContext3D::DEPTH_ATTACHMENT:
2459         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2460         break;
2461     case GraphicsContext3D::STENCIL_ATTACHMENT:
2462         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2463         break;
2464     default:
2465         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
2466     }
2467     targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
2468     applyStencilTest();
2469 }
2470 
2471 void WebGLRenderingContextBase::frontFace(GC3Denum mode)
2472 {
2473     if (isContextLostOrPending())
2474         return;
2475     m_context-&gt;frontFace(mode);
2476 }
2477 
2478 void WebGLRenderingContextBase::generateMipmap(GC3Denum target)
2479 {
2480     if (isContextLostOrPending())
2481         return;
2482     auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
2483     if (!tex)
2484         return;
2485     if (!tex-&gt;canGenerateMipmaps()) {
2486         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);
2487         return;
2488     }
2489     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
2490     if (tex-&gt;isCompressed()) {
2491         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);
2492         return;
2493     }
2494     if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
2495         return;
2496 
2497     // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
2498     // on Mac.  Remove the hack once this driver bug is fixed.
2499 #if OS(DARWIN)
2500     bool needToResetMinFilter = false;
2501     if (tex-&gt;getMinFilter() != GraphicsContext3D::NEAREST_MIPMAP_LINEAR) {
2502         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::NEAREST_MIPMAP_LINEAR);
2503         needToResetMinFilter = true;
2504     }
2505 #endif
2506     m_context-&gt;generateMipmap(target);
2507 #if OS(DARWIN)
2508     if (needToResetMinFilter)
2509         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());
2510 #endif
2511     tex-&gt;generateMipmapLevelInfo();
2512 }
2513 
2514 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GC3Duint index)
2515 {
2516     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
2517         return nullptr;
2518     ActiveInfo info;
2519     if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
2520         return nullptr;
2521 
2522     LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
2523 
2524     return WebGLActiveInfo::create(info.name, info.type, info.size);
2525 }
2526 
2527 RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GC3Duint index)
2528 {
2529     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
2530         return nullptr;
2531     ActiveInfo info;
2532     if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
2533         return nullptr;
2534     if (!isGLES2Compliant())
2535         if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
2536             info.name.append(&quot;[0]&quot;);
2537 
2538     LOG(WebGL, &quot;Returning active uniform %d: %s&quot;, index, info.name.utf8().data());
2539 
2540     return WebGLActiveInfo::create(info.name, info.type, info.size);
2541 }
2542 
2543 Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
2544 {
2545     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
2546         return WTF::nullopt;
2547 
2548     const GC3Denum shaderTypes[] = {
2549         GraphicsContext3D::VERTEX_SHADER,
2550         GraphicsContext3D::FRAGMENT_SHADER
2551     };
2552     Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
2553     for (auto shaderType : shaderTypes) {
2554         RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
2555         if (shader)
2556             shaderObjects.append(shader);
2557     }
2558     return shaderObjects;
2559 }
2560 
2561 GC3Dint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)
2562 {
2563     if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
2564         return -1;
2565     if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
2566         return -1;
2567     if (!validateString(&quot;getAttribLocation&quot;, name))
2568         return -1;
2569     if (isPrefixReserved(name))
2570         return -1;
2571     if (!program-&gt;getLinkStatus()) {
2572         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);
2573         return -1;
2574     }
2575     return m_context-&gt;getAttribLocation(objectOrZero(program), name);
2576 }
2577 
2578 WebGLAny WebGLRenderingContextBase::getBufferParameter(GC3Denum target, GC3Denum pname)
2579 {
2580     if (isContextLostOrPending())
2581         return nullptr;
2582 
2583     bool valid = false;
2584     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)
2585         valid = true;
2586 #if ENABLE(WEBGL2)
2587     if (isWebGL2()) {
2588         switch (target) {
2589         case GraphicsContext3D::COPY_READ_BUFFER:
2590         case GraphicsContext3D::COPY_WRITE_BUFFER:
2591         case GraphicsContext3D::PIXEL_PACK_BUFFER:
2592         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
2593         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
2594         case GraphicsContext3D::UNIFORM_BUFFER:
2595             valid = true;
2596         }
2597     }
2598 #endif
2599     if (!valid) {
2600         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);
2601         return nullptr;
2602     }
2603 
2604     if (pname != GraphicsContext3D::BUFFER_SIZE &amp;&amp; pname != GraphicsContext3D::BUFFER_USAGE) {
2605         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);
2606         return nullptr;
2607     }
2608 
2609     GC3Dint value = 0;
2610     m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
2611     if (pname == GraphicsContext3D::BUFFER_SIZE)
2612         return value;
2613     return static_cast&lt;unsigned&gt;(value);
2614 }
2615 
2616 Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
2617 {
2618     if (isContextLostOrPending())
2619         return WTF::nullopt;
2620 
2621     // Also, we need to enforce requested values of &quot;false&quot; for depth
2622     // and stencil, regardless of the properties of the underlying
2623     // GraphicsContext3D.
2624 
2625     auto attributes = m_context-&gt;getContextAttributes();
2626     if (!m_attributes.depth)
2627         attributes.depth = false;
2628     if (!m_attributes.stencil)
2629         attributes.stencil = false;
<a name="21" id="anc21"></a><span class="line-modified">2630     return attributes;</span>
2631 }
2632 
2633 GC3Denum WebGLRenderingContextBase::getError()
2634 {
2635     if (m_isPendingPolicyResolution)
2636         return GraphicsContext3D::NO_ERROR;
2637     return m_context-&gt;getError();
2638 }
2639 
2640 WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)
2641 {
2642     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
2643         return nullptr;
2644 
2645     GC3Dint value = 0;
2646     switch (pname) {
2647     case GraphicsContext3D::DELETE_STATUS:
2648         return program-&gt;isDeleted();
2649     case GraphicsContext3D::VALIDATE_STATUS:
2650         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2651         return static_cast&lt;bool&gt;(value);
2652     case GraphicsContext3D::LINK_STATUS:
2653         return program-&gt;getLinkStatus();
2654     case GraphicsContext3D::ATTACHED_SHADERS:
2655         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
2656         return value;
2657     case GraphicsContext3D::ACTIVE_ATTRIBUTES:
2658     case GraphicsContext3D::ACTIVE_UNIFORMS:
<a name="22" id="anc22"></a><span class="line-added">2659 #if USE(ANGLE)</span>
<span class="line-added">2660         m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="line-added">2661 #else</span>
2662         m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
<a name="23" id="anc23"></a><span class="line-added">2663 #endif // USE(ANGLE)</span>
2664         return value;
2665     default:
2666         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);
2667         return nullptr;
2668     }
2669 }
2670 
2671 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
2672 {
2673     if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
2674         return String();
2675     return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
2676 }
2677 
2678 WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)
2679 {
2680     if (isContextLostOrPending())
2681         return nullptr;
2682     if (target != GraphicsContext3D::RENDERBUFFER) {
2683         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);
2684         return nullptr;
2685     }
2686     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
2687         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);
2688         return nullptr;
2689     }
2690 
2691     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContext3D::DEPTH_STENCIL
2692         &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
2693         ASSERT(!isDepthStencilSupported());
2694         int value = 0;
2695         switch (pname) {
2696         case GraphicsContext3D::RENDERBUFFER_WIDTH:
2697             value = m_renderbufferBinding-&gt;getWidth();
2698             break;
2699         case GraphicsContext3D::RENDERBUFFER_HEIGHT:
2700             value = m_renderbufferBinding-&gt;getHeight();
2701             break;
2702         case GraphicsContext3D::RENDERBUFFER_RED_SIZE:
2703         case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:
2704         case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:
2705         case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:
2706             value = 0;
2707             break;
2708         case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:
2709             value = 24;
2710             break;
2711         case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:
2712             value = 8;
2713             break;
2714         case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:
2715             return m_renderbufferBinding-&gt;getInternalFormat();
2716         default:
2717             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2718             return nullptr;
2719         }
2720         return value;
2721     }
2722 
2723     GC3Dint value = 0;
2724     switch (pname) {
2725     case GraphicsContext3D::RENDERBUFFER_WIDTH:
2726     case GraphicsContext3D::RENDERBUFFER_HEIGHT:
2727     case GraphicsContext3D::RENDERBUFFER_RED_SIZE:
2728     case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:
2729     case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:
2730     case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:
2731     case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:
2732     case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:
2733         m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
2734         return value;
2735     case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:
2736         return m_renderbufferBinding-&gt;getInternalFormat();
2737     default:
2738         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);
2739         return nullptr;
2740     }
2741 }
2742 
2743 WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GC3Denum pname)
2744 {
2745     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
2746         return nullptr;
2747     GC3Dint value = 0;
2748     switch (pname) {
2749     case GraphicsContext3D::DELETE_STATUS:
2750         return shader-&gt;isDeleted();
2751     case GraphicsContext3D::COMPILE_STATUS:
2752         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2753         return static_cast&lt;bool&gt;(value);
2754     case GraphicsContext3D::SHADER_TYPE:
2755         m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
2756         return static_cast&lt;unsigned&gt;(value);
2757     default:
2758         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);
2759         return nullptr;
2760     }
2761 }
2762 
2763 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
2764 {
2765     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
2766         return String();
2767     return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
2768 }
2769 
2770 RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType)
2771 {
2772     if (isContextLostOrPending())
2773         return nullptr;
2774     switch (shaderType) {
2775     case GraphicsContext3D::VERTEX_SHADER:
2776     case GraphicsContext3D::FRAGMENT_SHADER:
2777         break;
2778     default:
2779         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);
2780         return nullptr;
2781     }
2782     switch (precisionType) {
2783     case GraphicsContext3D::LOW_FLOAT:
2784     case GraphicsContext3D::MEDIUM_FLOAT:
2785     case GraphicsContext3D::HIGH_FLOAT:
2786     case GraphicsContext3D::LOW_INT:
2787     case GraphicsContext3D::MEDIUM_INT:
2788     case GraphicsContext3D::HIGH_INT:
2789         break;
2790     default:
2791         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);
2792         return nullptr;
2793     }
2794 
2795     GC3Dint range[2] = {0, 0};
2796     GC3Dint precision = 0;
2797     m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
2798     return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
2799 }
2800 
2801 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
2802 {
2803     if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
2804         return String();
2805     return ensureNotNull(shader-&gt;getSource());
2806 }
2807 
2808 WebGLAny WebGLRenderingContextBase::getTexParameter(GC3Denum target, GC3Denum pname)
2809 {
2810     if (isContextLostOrPending())
2811         return nullptr;
2812     auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
2813     if (!tex)
2814         return nullptr;
2815     GC3Dint value = 0;
2816     switch (pname) {
2817     case GraphicsContext3D::TEXTURE_MAG_FILTER:
2818     case GraphicsContext3D::TEXTURE_MIN_FILTER:
2819     case GraphicsContext3D::TEXTURE_WRAP_S:
2820     case GraphicsContext3D::TEXTURE_WRAP_T:
2821         m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2822         return static_cast&lt;unsigned&gt;(value);
2823     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
2824         if (m_extTextureFilterAnisotropic) {
2825             m_context-&gt;getTexParameteriv(target, pname, &amp;value);
2826             return static_cast&lt;unsigned&gt;(value);
2827         }
2828         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
2829         return nullptr;
2830     default:
2831         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);
2832         return nullptr;
2833     }
2834 }
2835 
2836 WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
2837 {
2838     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
2839         return nullptr;
2840     if (!uniformLocation || uniformLocation-&gt;program() != program) {
2841         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);
2842         return nullptr;
2843     }
2844     GC3Dint location = uniformLocation-&gt;location();
2845 
2846     GC3Denum baseType;
2847     unsigned length;
2848     switch (uniformLocation-&gt;type()) {
2849     case GraphicsContext3D::BOOL:
2850         baseType = GraphicsContext3D::BOOL;
2851         length = 1;
2852         break;
2853     case GraphicsContext3D::BOOL_VEC2:
2854         baseType = GraphicsContext3D::BOOL;
2855         length = 2;
2856         break;
2857     case GraphicsContext3D::BOOL_VEC3:
2858         baseType = GraphicsContext3D::BOOL;
2859         length = 3;
2860         break;
2861     case GraphicsContext3D::BOOL_VEC4:
2862         baseType = GraphicsContext3D::BOOL;
2863         length = 4;
2864         break;
2865     case GraphicsContext3D::INT:
2866         baseType = GraphicsContext3D::INT;
2867         length = 1;
2868         break;
2869     case GraphicsContext3D::INT_VEC2:
2870         baseType = GraphicsContext3D::INT;
2871         length = 2;
2872         break;
2873     case GraphicsContext3D::INT_VEC3:
2874         baseType = GraphicsContext3D::INT;
2875         length = 3;
2876         break;
2877     case GraphicsContext3D::INT_VEC4:
2878         baseType = GraphicsContext3D::INT;
2879         length = 4;
2880         break;
2881     case GraphicsContext3D::FLOAT:
2882         baseType = GraphicsContext3D::FLOAT;
2883         length = 1;
2884         break;
2885     case GraphicsContext3D::FLOAT_VEC2:
2886         baseType = GraphicsContext3D::FLOAT;
2887         length = 2;
2888         break;
2889     case GraphicsContext3D::FLOAT_VEC3:
2890         baseType = GraphicsContext3D::FLOAT;
2891         length = 3;
2892         break;
2893     case GraphicsContext3D::FLOAT_VEC4:
2894         baseType = GraphicsContext3D::FLOAT;
2895         length = 4;
2896         break;
2897     case GraphicsContext3D::FLOAT_MAT2:
2898         baseType = GraphicsContext3D::FLOAT;
2899         length = 4;
2900         break;
2901     case GraphicsContext3D::FLOAT_MAT3:
2902         baseType = GraphicsContext3D::FLOAT;
2903         length = 9;
2904         break;
2905     case GraphicsContext3D::FLOAT_MAT4:
2906         baseType = GraphicsContext3D::FLOAT;
2907         length = 16;
2908         break;
2909     case GraphicsContext3D::SAMPLER_2D:
2910     case GraphicsContext3D::SAMPLER_CUBE:
2911         baseType = GraphicsContext3D::INT;
2912         length = 1;
2913         break;
2914     default:
2915         // Can&#39;t handle this type
2916         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);
2917         return nullptr;
2918     }
2919     switch (baseType) {
2920     case GraphicsContext3D::FLOAT: {
2921         GC3Dfloat value[16] = {0};
2922         if (m_isRobustnessEXTSupported)
2923             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GC3Dfloat), value);
2924         else
2925             m_context-&gt;getUniformfv(objectOrZero(program), location, value);
2926         if (length == 1)
2927             return value[0];
2928         return Float32Array::tryCreate(value, length);
2929     }
2930     case GraphicsContext3D::INT: {
2931         GC3Dint value[4] = {0};
2932         if (m_isRobustnessEXTSupported)
2933             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2934         else
2935             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2936         if (length == 1)
2937             return value[0];
2938         return Int32Array::tryCreate(value, length);
2939     }
2940     case GraphicsContext3D::BOOL: {
2941         GC3Dint value[4] = {0};
2942         if (m_isRobustnessEXTSupported)
2943             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);
2944         else
2945             m_context-&gt;getUniformiv(objectOrZero(program), location, value);
2946         if (length &gt; 1) {
2947             Vector&lt;bool&gt; vector(length);
2948             for (unsigned j = 0; j &lt; length; j++)
2949                 vector[j] = value[j];
<a name="24" id="anc24"></a><span class="line-modified">2950             return vector;</span>
2951         }
2952         return static_cast&lt;bool&gt;(value[0]);
2953     }
2954     default:
2955         notImplemented();
2956     }
2957 
2958     // If we get here, something went wrong in our unfortunately complex logic above
2959     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);
2960     return nullptr;
2961 }
2962 
2963 RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
2964 {
2965     if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniformLocation&quot;, program))
2966         return nullptr;
2967     if (!validateLocationLength(&quot;getUniformLocation&quot;, name))
2968         return nullptr;
2969     if (!validateString(&quot;getUniformLocation&quot;, name))
2970         return nullptr;
2971     if (isPrefixReserved(name))
2972         return nullptr;
2973     if (!program-&gt;getLinkStatus()) {
2974         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);
2975         return nullptr;
2976     }
2977     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);
2978     if (uniformLocation == -1)
2979         return nullptr;
2980 
2981     GC3Dint activeUniforms = 0;
<a name="25" id="anc25"></a><span class="line-added">2982 #if USE(ANGLE)</span>
<span class="line-added">2983     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
<span class="line-added">2984 #else</span>
2985     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);
<a name="26" id="anc26"></a><span class="line-added">2986 #endif</span>
2987     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {
2988         ActiveInfo info;
2989         if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
2990             return nullptr;
2991         // Strip &quot;[0]&quot; from the name if it&#39;s an array.
2992         if (info.name.endsWith(&quot;[0]&quot;))
2993             info.name = info.name.left(info.name.length() - 3);
2994         // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
2995         for (GC3Dint index = 0; index &lt; info.size; ++index) {
2996             String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
2997 
2998             if (name == uniformName || name == info.name)
2999                 return WebGLUniformLocation::create(program, uniformLocation, info.type);
3000         }
3001     }
3002     return nullptr;
3003 }
3004 
3005 WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)
3006 {
3007     if (isContextLostOrPending())
3008         return nullptr;
3009 
3010     if (index &gt;= m_maxVertexAttribs) {
3011         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);
3012         return nullptr;
3013     }
3014 
3015     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
3016 
3017     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContext3D::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)
3018         return state.divisor;
3019 
3020     switch (pname) {
3021     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
3022         if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
3023             || !state.bufferBinding
3024             || !state.bufferBinding-&gt;object())
3025             return nullptr;
3026         return state.bufferBinding;
3027     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_ENABLED:
3028         return state.enabled;
3029     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_NORMALIZED:
3030         return state.normalized;
3031     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_SIZE:
3032         return state.size;
3033     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_STRIDE:
3034         return state.originalStride;
3035     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_TYPE:
3036         return state.type;
3037     case GraphicsContext3D::CURRENT_VERTEX_ATTRIB:
3038         return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
3039     default:
3040         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);
3041         return nullptr;
3042     }
3043 }
3044 
3045 long long WebGLRenderingContextBase::getVertexAttribOffset(GC3Duint index, GC3Denum pname)
3046 {
3047     if (isContextLostOrPending())
3048         return 0;
3049     return m_context-&gt;getVertexAttribOffset(index, pname);
3050 }
3051 
3052 bool WebGLRenderingContextBase::extensionIsEnabled(const String&amp; name)
3053 {
3054 #define CHECK_EXTENSION(variable, nameLiteral) \
3055     if (equalIgnoringASCIICase(name, nameLiteral)) \
3056         return variable != nullptr;
3057 
3058     CHECK_EXTENSION(m_extFragDepth, &quot;EXT_frag_depth&quot;);
3059     CHECK_EXTENSION(m_extBlendMinMax, &quot;EXT_blend_minmax&quot;);
3060     CHECK_EXTENSION(m_extsRGB, &quot;EXT_sRGB&quot;);
3061     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;);
3062     CHECK_EXTENSION(m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;);
3063     CHECK_EXTENSION(m_extShaderTextureLOD, &quot;EXT_shader_texture_lod&quot;);
3064     CHECK_EXTENSION(m_oesTextureFloat, &quot;OES_texture_float&quot;);
3065     CHECK_EXTENSION(m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;);
3066     CHECK_EXTENSION(m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;);
3067     CHECK_EXTENSION(m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;);
3068     CHECK_EXTENSION(m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;);
3069     CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
3070     CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
3071     CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
3072     CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
3073     CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
3074     CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
3075     CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
3076     CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
3077     CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
3078     CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
3079     CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
3080     return false;
3081 }
3082 
3083 GC3Dboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)
3084 {
3085     if (!buffer || isContextLostOrPending())
3086         return 0;
3087 
3088     if (!buffer-&gt;hasEverBeenBound())
3089         return 0;
3090 
3091     return m_context-&gt;isBuffer(buffer-&gt;object());
3092 }
3093 
3094 bool WebGLRenderingContextBase::isContextLost() const
3095 {
3096     return m_contextLost;
3097 }
3098 
3099 bool WebGLRenderingContextBase::isContextLostOrPending()
3100 {
3101     if (m_isPendingPolicyResolution &amp;&amp; !m_hasRequestedPolicyResolution) {
3102         LOG(WebGL, &quot;Context is being used. Attempt to resolve the policy.&quot;);
3103         auto* canvas = htmlCanvas();
3104         if (canvas) {
3105             Document&amp; document = canvas-&gt;document().topDocument();
3106             Page* page = document.page();
3107             if (page &amp;&amp; !document.url().isLocalFile())
3108                 page-&gt;mainFrame().loader().client().resolveWebGLPolicyForURL(document.url());
3109             // FIXME: We don&#39;t currently do anything with the result from resolution. A more
3110             // complete implementation might try to construct a real context, etc and proceed
3111             // with normal operation.
3112             // https://bugs.webkit.org/show_bug.cgi?id=129122
3113         }
3114         m_hasRequestedPolicyResolution = true;
3115     }
3116 
3117     return m_contextLost || m_isPendingPolicyResolution;
3118 }
3119 
3120 GC3Dboolean WebGLRenderingContextBase::isEnabled(GC3Denum cap)
3121 {
3122     if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
3123         return 0;
3124     if (cap == GraphicsContext3D::STENCIL_TEST)
3125         return m_stencilEnabled;
3126     return m_context-&gt;isEnabled(cap);
3127 }
3128 
3129 GC3Dboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)
3130 {
3131     if (!framebuffer || isContextLostOrPending())
3132         return 0;
3133 
3134     if (!framebuffer-&gt;hasEverBeenBound())
3135         return 0;
3136 
3137     return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
3138 }
3139 
3140 GC3Dboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)
3141 {
3142     if (!program || isContextLostOrPending())
3143         return 0;
3144 
3145     return m_context-&gt;isProgram(program-&gt;object());
3146 }
3147 
3148 GC3Dboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)
3149 {
3150     if (!renderbuffer || isContextLostOrPending())
3151         return 0;
3152 
3153     if (!renderbuffer-&gt;hasEverBeenBound())
3154         return 0;
3155 
3156     return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
3157 }
3158 
3159 GC3Dboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)
3160 {
3161     if (!shader || isContextLostOrPending())
3162         return 0;
3163 
3164     return m_context-&gt;isShader(shader-&gt;object());
3165 }
3166 
3167 GC3Dboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)
3168 {
3169     if (!texture || isContextLostOrPending())
3170         return 0;
3171 
3172     if (!texture-&gt;hasEverBeenBound())
3173         return 0;
3174 
3175     return m_context-&gt;isTexture(texture-&gt;object());
3176 }
3177 
3178 void WebGLRenderingContextBase::lineWidth(GC3Dfloat width)
3179 {
3180     if (isContextLostOrPending())
3181         return;
3182     m_context-&gt;lineWidth(width);
3183 }
3184 
3185 void WebGLRenderingContextBase::linkProgram(WebGLProgram* program)
3186 {
3187     if (!linkProgramWithoutInvalidatingAttribLocations(program))
3188         return;
3189 
3190     program-&gt;increaseLinkCount();
3191 }
3192 
3193 bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
3194 {
3195     if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
3196         return false;
3197 
3198     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);
3199     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);
<a name="27" id="anc27"></a><span class="line-modified">3200     if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {</span>
3201         program-&gt;setLinkStatus(false);
3202         return false;
3203     }
3204 
<a name="28" id="anc28"></a><span class="line-added">3205 #if !USE(ANGLE)</span>
<span class="line-added">3206     if (!m_context-&gt;precisionsMatch(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))</span>
<span class="line-added">3207         || !m_context-&gt;checkVaryingsPacking(objectOrZero(vertexShader.get()), objectOrZero(fragmentShader.get()))) {</span>
<span class="line-added">3208         program-&gt;setLinkStatus(false);</span>
<span class="line-added">3209         return false;</span>
<span class="line-added">3210     }</span>
<span class="line-added">3211 #endif</span>
<span class="line-added">3212 </span>
3213     m_context-&gt;linkProgram(objectOrZero(program));
3214     return true;
3215 }
3216 
3217 void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)
3218 {
3219     if (isContextLostOrPending())
3220         return;
3221     switch (pname) {
3222     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:
3223         m_unpackFlipY = param;
3224         break;
3225     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
3226         m_unpackPremultiplyAlpha = param;
3227         break;
3228     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:
3229         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)
3230             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);
3231         else {
3232             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);
3233             return;
3234         }
3235         break;
3236     case GraphicsContext3D::PACK_ALIGNMENT:
3237     case GraphicsContext3D::UNPACK_ALIGNMENT:
3238         if (param == 1 || param == 2 || param == 4 || param == 8) {
3239             if (pname == GraphicsContext3D::PACK_ALIGNMENT)
3240                 m_packAlignment = param;
3241             else // GraphicsContext3D::UNPACK_ALIGNMENT:
3242                 m_unpackAlignment = param;
3243             m_context-&gt;pixelStorei(pname, param);
3244         } else {
3245             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);
3246             return;
3247         }
3248         break;
3249     default:
3250         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);
3251         return;
3252     }
3253 }
3254 
3255 void WebGLRenderingContextBase::polygonOffset(GC3Dfloat factor, GC3Dfloat units)
3256 {
3257     if (isContextLostOrPending())
3258         return;
3259     m_context-&gt;polygonOffset(factor, units);
3260 }
3261 
3262 enum class InternalFormatTheme {
3263     None,
3264     NormalizedFixedPoint,
3265     Packed,
3266     SignedNormalizedFixedPoint,
3267     FloatingPoint,
3268     SignedInteger,
3269     UnsignedInteger
3270 };
3271 
3272 static InternalFormatTheme internalFormatTheme(GC3Denum internalFormat)
3273 {
3274     switch (internalFormat) {
3275     case GraphicsContext3D::RGB:
3276     case GraphicsContext3D::RGBA:
3277     case GraphicsContext3D::LUMINANCE_ALPHA:
3278     case GraphicsContext3D::LUMINANCE:
3279     case GraphicsContext3D::ALPHA:
3280     case GraphicsContext3D::R8:
3281     case GraphicsContext3D::RG8:
3282     case GraphicsContext3D::RGB8:
3283     case GraphicsContext3D::SRGB8:
3284     case GraphicsContext3D::RGBA8:
3285     case GraphicsContext3D::SRGB8_ALPHA8:
3286     case GraphicsContext3D::SRGB_ALPHA:
3287         return InternalFormatTheme::NormalizedFixedPoint;
3288     case GraphicsContext3D::RGB565:
3289     case GraphicsContext3D::RGB5_A1:
3290     case GraphicsContext3D::RGBA4:
3291     case GraphicsContext3D::RGB9_E5:
3292     case GraphicsContext3D::RGB10_A2:
3293     case GraphicsContext3D::R11F_G11F_B10F:
3294     case GraphicsContext3D::RGB10_A2UI:
3295         return InternalFormatTheme::Packed;
3296     case GraphicsContext3D::R8_SNORM:
3297     case GraphicsContext3D::RG8_SNORM:
3298     case GraphicsContext3D::RGB8_SNORM:
3299     case GraphicsContext3D::RGBA8_SNORM:
3300         return InternalFormatTheme::SignedNormalizedFixedPoint;
3301     case GraphicsContext3D::R16F:
3302     case GraphicsContext3D::R32F:
3303     case GraphicsContext3D::RG16F:
3304     case GraphicsContext3D::RG32F:
3305     case GraphicsContext3D::RGB16F:
3306     case GraphicsContext3D::RGB32F:
3307     case GraphicsContext3D::RGBA16F:
3308     case GraphicsContext3D::RGBA32F:
3309         return InternalFormatTheme::FloatingPoint;
3310     case GraphicsContext3D::R8I:
3311     case GraphicsContext3D::R16I:
3312     case GraphicsContext3D::R32I:
3313     case GraphicsContext3D::RG8I:
3314     case GraphicsContext3D::RG16I:
3315     case GraphicsContext3D::RG32I:
3316     case GraphicsContext3D::RGB8I:
3317     case GraphicsContext3D::RGB16I:
3318     case GraphicsContext3D::RGB32I:
3319     case GraphicsContext3D::RGBA8I:
3320     case GraphicsContext3D::RGBA16I:
3321     case GraphicsContext3D::RGBA32I:
3322         return InternalFormatTheme::SignedInteger;
3323     case GraphicsContext3D::R8UI:
3324     case GraphicsContext3D::R16UI:
3325     case GraphicsContext3D::R32UI:
3326     case GraphicsContext3D::RG8UI:
3327     case GraphicsContext3D::RG16UI:
3328     case GraphicsContext3D::RG32UI:
3329     case GraphicsContext3D::RGB8UI:
3330     case GraphicsContext3D::RGB16UI:
3331     case GraphicsContext3D::RGB32UI:
3332     case GraphicsContext3D::RGBA8UI:
3333     case GraphicsContext3D::RGBA16UI:
3334     case GraphicsContext3D::RGBA32UI:
3335         return InternalFormatTheme::UnsignedInteger;
3336     default:
3337         return InternalFormatTheme::None;
3338     }
3339 }
3340 
3341 static int numberOfComponentsForFormat(GC3Denum format)
3342 {
3343     switch (format) {
3344     case GraphicsContext3D::RED:
3345     case GraphicsContext3D::RED_INTEGER:
3346         return 1;
3347     case GraphicsContext3D::RG:
3348     case GraphicsContext3D::RG_INTEGER:
3349         return 2;
3350     case GraphicsContext3D::RGB:
3351     case GraphicsContext3D::RGB_INTEGER:
3352         return 3;
3353     case GraphicsContext3D::RGBA:
3354     case GraphicsContext3D::RGBA_INTEGER:
3355         return 4;
3356     default:
3357         return 0;
3358     }
3359 }
3360 
3361 static int numberOfComponentsForInternalFormat(GC3Denum internalFormat)
3362 {
3363     switch (internalFormat) {
3364     case GraphicsContext3D::LUMINANCE:
3365     case GraphicsContext3D::ALPHA:
3366     case GraphicsContext3D::R8:
3367     case GraphicsContext3D::R8_SNORM:
3368     case GraphicsContext3D::R16F:
3369     case GraphicsContext3D::R32F:
3370     case GraphicsContext3D::R8UI:
3371     case GraphicsContext3D::R8I:
3372     case GraphicsContext3D::R16UI:
3373     case GraphicsContext3D::R16I:
3374     case GraphicsContext3D::R32UI:
3375     case GraphicsContext3D::R32I:
3376     case GraphicsContext3D::DEPTH_COMPONENT16:
3377     case GraphicsContext3D::DEPTH_COMPONENT24:
3378     case GraphicsContext3D::DEPTH_COMPONENT32F:
3379         return 1;
3380     case GraphicsContext3D::RG8:
3381     case GraphicsContext3D::LUMINANCE_ALPHA:
3382     case GraphicsContext3D::RG8_SNORM:
3383     case GraphicsContext3D::RG16F:
3384     case GraphicsContext3D::RG32F:
3385     case GraphicsContext3D::RG8UI:
3386     case GraphicsContext3D::RG8I:
3387     case GraphicsContext3D::RG16UI:
3388     case GraphicsContext3D::RG16I:
3389     case GraphicsContext3D::RG32UI:
3390     case GraphicsContext3D::RG32I:
3391     case GraphicsContext3D::DEPTH24_STENCIL8:
3392     case GraphicsContext3D::DEPTH32F_STENCIL8:
3393         return 2;
3394     case GraphicsContext3D::RGB:
3395     case GraphicsContext3D::RGB8:
3396     case GraphicsContext3D::SRGB8:
3397     case GraphicsContext3D::RGB565:
3398     case GraphicsContext3D::RGB8_SNORM:
3399     case GraphicsContext3D::R11F_G11F_B10F:
3400     case GraphicsContext3D::RGB9_E5:
3401     case GraphicsContext3D::RGB16F:
3402     case GraphicsContext3D::RGB32F:
3403     case GraphicsContext3D::RGB8UI:
3404     case GraphicsContext3D::RGB8I:
3405     case GraphicsContext3D::RGB16UI:
3406     case GraphicsContext3D::RGB16I:
3407     case GraphicsContext3D::RGB32UI:
3408     case GraphicsContext3D::RGB32I:
3409         return 3;
3410     case GraphicsContext3D::RGBA:
3411     case GraphicsContext3D::RGBA8:
3412     case GraphicsContext3D::SRGB_ALPHA:
3413     case GraphicsContext3D::SRGB8_ALPHA8:
3414     case GraphicsContext3D::RGBA8_SNORM:
3415     case GraphicsContext3D::RGB5_A1:
3416     case GraphicsContext3D::RGBA4:
3417     case GraphicsContext3D::RGB10_A2:
3418     case GraphicsContext3D::RGBA16F:
3419     case GraphicsContext3D::RGBA32F:
3420     case GraphicsContext3D::RGBA8UI:
3421     case GraphicsContext3D::RGBA8I:
3422     case GraphicsContext3D::RGB10_A2UI:
3423     case GraphicsContext3D::RGBA16UI:
3424     case GraphicsContext3D::RGBA16I:
3425     case GraphicsContext3D::RGBA32UI:
3426     case GraphicsContext3D::RGBA32I:
3427         return 4;
3428     default:
3429         return 0;
3430     }
3431 }
3432 
3433 void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)
3434 {
3435     if (isContextLostOrPending())
3436         return;
3437     // Due to WebGL&#39;s same-origin restrictions, it is not possible to
3438     // taint the origin using the WebGL API.
3439     ASSERT(canvasBase().originClean());
3440 
3441     GC3Denum internalFormat = 0;
3442     if (m_framebufferBinding) {
3443         const char* reason = &quot;framebuffer incomplete&quot;;
3444         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
3445             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);
3446             return;
3447         }
3448         // FIXME: readBuffer() should affect this
3449         internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
3450     } else {
3451         if (m_attributes.alpha)
<a name="29" id="anc29"></a>

3452             internalFormat = GraphicsContext3D::RGBA8;
<a name="30" id="anc30"></a><span class="line-added">3453         else</span>
<span class="line-added">3454             internalFormat = GraphicsContext3D::RGB8;</span>
3455     }
3456 
3457     if (!internalFormat) {
3458         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3459         return;
3460     }
3461 
3462     if (isWebGL1()) {
3463         switch (format) {
3464         case GraphicsContext3D::ALPHA:
3465         case GraphicsContext3D::RGB:
3466         case GraphicsContext3D::RGBA:
3467             break;
3468         default:
3469             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);
3470             return;
3471         }
3472         switch (type) {
3473         case GraphicsContext3D::UNSIGNED_BYTE:
3474         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
3475         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
3476         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
3477             break;
<a name="31" id="anc31"></a><span class="line-added">3478         case GraphicsContext3D::FLOAT:</span>
<span class="line-added">3479             if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {</span>
<span class="line-added">3480                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
<span class="line-added">3481                 return;</span>
<span class="line-added">3482             }</span>
<span class="line-added">3483             break;</span>
3484         default:
3485             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);
3486             return;
3487         }
<a name="32" id="anc32"></a><span class="line-modified">3488         if (format != GraphicsContext3D::RGBA || (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::FLOAT)) {</span>
<span class="line-modified">3489             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
3490             return;
3491         }
3492     }
3493 
3494     InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
3495     int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
3496     if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
3497         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);
3498         return;
3499     }
3500 
<a name="33" id="anc33"></a><span class="line-modified">3501 #define CHECK_COMPONENT_COUNT \</span>
<span class="line-modified">3502     if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \</span>
<span class="line-modified">3503         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="line-modified">3504         return; \</span>
<span class="line-modified">3505     }</span>









3506 
<a name="34" id="anc34"></a><span class="line-modified">3507 #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">3508     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3509         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3510         return; \</span>
<span class="line-modified">3511     } \</span>
<span class="line-modified">3512     if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="line-modified">3513         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3514         return; \</span>
<span class="line-modified">3515     } \</span>
<span class="line-modified">3516     CHECK_COMPONENT_COUNT</span>




3517 
<a name="35" id="anc35"></a><span class="line-modified">3518 #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \</span>
<span class="line-modified">3519     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="line-modified">3520         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-modified">3521         return; \</span>
<span class="line-modified">3522     } \</span>
<span class="line-modified">3523     if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="line-modified">3524         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="line-modified">3525         return; \</span>
<span class="line-modified">3526     } \</span>
<span class="line-modified">3527     CHECK_COMPONENT_COUNT</span>
<span class="line-modified">3528 </span>
<span class="line-added">3529 #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="line-added">3530     if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="line-added">3531         &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="line-added">3532         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="line-added">3533         return; \</span>
<span class="line-added">3534     } \</span>
<span class="line-added">3535     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="line-added">3536         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="line-added">3537         return; \</span>
<span class="line-added">3538     } \</span>
<span class="line-added">3539     break;</span>
3540 
3541     switch (internalFormatTheme) {
<a name="36" id="anc36"></a><span class="line-modified">3542     case InternalFormatTheme::NormalizedFixedPoint:</span>
<span class="line-modified">3543         if (type == GraphicsContext3D::FLOAT) {</span>
<span class="line-modified">3544             INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-modified">3545         } else {</span>
<span class="line-modified">3546             INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);</span>
<span class="line-added">3547         }</span>
<span class="line-added">3548         break;</span>
<span class="line-added">3549     case InternalFormatTheme::SignedNormalizedFixedPoint:</span>
<span class="line-added">3550         INTERNAL_FORMAT_CHECK(BYTE, TypeInt8);</span>
<span class="line-added">3551         break;</span>
<span class="line-added">3552     case InternalFormatTheme::FloatingPoint:</span>
<span class="line-added">3553         INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);</span>
<span class="line-added">3554         break;</span>
<span class="line-added">3555     case InternalFormatTheme::SignedInteger:</span>
<span class="line-added">3556         INTERNAL_FORMAT_INTEGER_CHECK(INT, TypeInt32);</span>
<span class="line-added">3557         break;</span>
<span class="line-added">3558     case InternalFormatTheme::UnsignedInteger:</span>
<span class="line-added">3559         INTERNAL_FORMAT_INTEGER_CHECK(UNSIGNED_INT, TypeUint32);</span>
<span class="line-added">3560         break;</span>
3561     case InternalFormatTheme::Packed:
3562         switch (internalFormat) {
<a name="37" id="anc37"></a><span class="line-modified">3563             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB565        , RGB         , UNSIGNED_SHORT_5_6_5        , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3564             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB5_A1       , RGBA        , UNSIGNED_SHORT_5_5_5_1      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3565             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGBA4         , RGBA        , UNSIGNED_SHORT_4_4_4_4      , TypeUint16, UNSIGNED_BYTE              , TypeUint8  );</span>
<span class="line-modified">3566             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB9_E5       , RGB         , UNSIGNED_INT_5_9_9_9_REV    , TypeUint32, UNSIGNED_INT_5_9_9_9_REV   , TypeUint32 );</span>
<span class="line-modified">3567             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2      , RGBA        , UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
<span class="line-modified">3568             CASE_PACKED_INTERNAL_FORMAT_CHECK(R11F_G11F_B10F, RGB         , UNSIGNED_INT_10F_11F_11F_REV, TypeUint32, FLOAT                      , TypeFloat32);</span>
<span class="line-modified">3569             CASE_PACKED_INTERNAL_FORMAT_CHECK(RGB10_A2UI    , RGBA_INTEGER, UNSIGNED_INT_2_10_10_10_REV , TypeUint32, UNSIGNED_INT_2_10_10_10_REV, TypeUint32 );</span>
3570         }
3571         break;
3572     case InternalFormatTheme::None:
3573         ASSERT_NOT_REACHED();
3574     }
<a name="38" id="anc38"></a><span class="line-added">3575 #undef CHECK_COMPONENT_COUNT</span>
3576 #undef INTERNAL_FORMAT_CHECK
3577 #undef INTERNAL_FORMAT_INTEGER_CHECK
<a name="39" id="anc39"></a><span class="line-modified">3578 #undef CASE_PACKED_INTERNAL_FORMAT_CHECK</span>
3579 
3580     // Calculate array size, taking into consideration of PACK_ALIGNMENT.
3581     unsigned totalBytesRequired = 0;
3582     unsigned padding = 0;
3583     if (!m_isRobustnessEXTSupported) {
3584         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);
3585         if (error != GraphicsContext3D::NO_ERROR) {
3586             synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
3587             return;
3588         }
3589         if (pixels.byteLength() &lt; totalBytesRequired) {
3590             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);
3591             return;
3592         }
3593     }
3594 
3595     clearIfComposited();
3596     void* data = pixels.baseAddress();
3597 
3598     if (m_isRobustnessEXTSupported)
3599         m_context-&gt;getExtensions().readnPixelsEXT(x, y, width, height, format, type, pixels.byteLength(), data);
3600     else
3601         m_context-&gt;readPixels(x, y, width, height, format, type, data);
3602 }
3603 
3604 void WebGLRenderingContextBase::releaseShaderCompiler()
3605 {
3606     if (isContextLostOrPending())
3607         return;
3608     m_context-&gt;releaseShaderCompiler();
3609 }
3610 
3611 void WebGLRenderingContextBase::sampleCoverage(GC3Dfloat value, GC3Dboolean invert)
3612 {
3613     if (isContextLostOrPending())
3614         return;
3615     m_context-&gt;sampleCoverage(value, invert);
3616 }
3617 
3618 void WebGLRenderingContextBase::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
3619 {
3620     if (isContextLostOrPending())
3621         return;
3622     if (!validateSize(&quot;scissor&quot;, width, height))
3623         return;
3624     m_context-&gt;scissor(x, y, width, height);
3625 }
3626 
3627 void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
3628 {
3629     if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
3630         return;
3631     String stringWithoutComments = StripComments(string).result();
3632     if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
3633         return;
3634     shader-&gt;setSource(string);
3635     m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
3636 }
3637 
3638 void WebGLRenderingContextBase::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)
3639 {
3640     if (isContextLostOrPending())
3641         return;
3642     if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
3643         return;
3644     m_stencilFuncRef = ref;
3645     m_stencilFuncRefBack = ref;
3646     m_stencilFuncMask = mask;
3647     m_stencilFuncMaskBack = mask;
3648     m_context-&gt;stencilFunc(func, ref, mask);
3649 }
3650 
3651 void WebGLRenderingContextBase::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)
3652 {
3653     if (isContextLostOrPending())
3654         return;
3655     if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
3656         return;
3657     switch (face) {
3658     case GraphicsContext3D::FRONT_AND_BACK:
3659         m_stencilFuncRef = ref;
3660         m_stencilFuncRefBack = ref;
3661         m_stencilFuncMask = mask;
3662         m_stencilFuncMaskBack = mask;
3663         break;
3664     case GraphicsContext3D::FRONT:
3665         m_stencilFuncRef = ref;
3666         m_stencilFuncMask = mask;
3667         break;
3668     case GraphicsContext3D::BACK:
3669         m_stencilFuncRefBack = ref;
3670         m_stencilFuncMaskBack = mask;
3671         break;
3672     default:
3673         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);
3674         return;
3675     }
3676     m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
3677 }
3678 
3679 void WebGLRenderingContextBase::stencilMask(GC3Duint mask)
3680 {
3681     if (isContextLostOrPending())
3682         return;
3683     m_stencilMask = mask;
3684     m_stencilMaskBack = mask;
3685     m_context-&gt;stencilMask(mask);
3686 }
3687 
3688 void WebGLRenderingContextBase::stencilMaskSeparate(GC3Denum face, GC3Duint mask)
3689 {
3690     if (isContextLostOrPending())
3691         return;
3692     switch (face) {
3693     case GraphicsContext3D::FRONT_AND_BACK:
3694         m_stencilMask = mask;
3695         m_stencilMaskBack = mask;
3696         break;
3697     case GraphicsContext3D::FRONT:
3698         m_stencilMask = mask;
3699         break;
3700     case GraphicsContext3D::BACK:
3701         m_stencilMaskBack = mask;
3702         break;
3703     default:
3704         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);
3705         return;
3706     }
3707     m_context-&gt;stencilMaskSeparate(face, mask);
3708 }
3709 
3710 void WebGLRenderingContextBase::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
3711 {
3712     if (isContextLostOrPending())
3713         return;
3714     m_context-&gt;stencilOp(fail, zfail, zpass);
3715 }
3716 
3717 void WebGLRenderingContextBase::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)
3718 {
3719     if (isContextLostOrPending())
3720         return;
3721     m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
3722 }
3723 
3724 void WebGLRenderingContextBase::texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)
3725 {
3726     // FIXME: For now we ignore any errors returned.
3727     auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
3728     ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
3729     ASSERT(tex);
3730     ASSERT(validateNPOTTextureLevel(width, height, level, &quot;texImage2D&quot;));
3731     if (!pixels) {
3732         if (!m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border, format, type, m_unpackAlignment))
3733             return;
3734     } else {
3735         ASSERT(validateSettableTexInternalFormat(&quot;texImage2D&quot;, internalFormat));
3736         m_context-&gt;moveErrorsToSyntheticErrorList();
3737         m_context-&gt;texImage2D(target, level, internalFormat, width, height,
3738                               border, format, type, pixels);
3739         if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
3740             // The texImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
3741             tex-&gt;markInvalid(target, level);
3742             return;
3743         }
3744     }
3745     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
3746 }
3747 
3748 void WebGLRenderingContextBase::texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)
3749 {
3750     Vector&lt;uint8_t&gt; data;
3751     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);
3752     if (!imageExtractor.extractSucceeded()) {
3753         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3754         return;
3755     }
3756     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3757     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3758     const void* imagePixelData = imageExtractor.imagePixelData();
3759 
3760     bool needConversion = true;
3761     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)
3762         needConversion = false;
3763     else {
3764         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3765             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);
3766             return;
3767         }
3768     }
3769 
3770     if (m_unpackAlignment != 1)
3771         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3772     texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
3773     if (m_unpackAlignment != 1)
3774         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3775 }
3776 
3777 bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset)
3778 {
3779     if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
3780         return false;
3781 
3782     auto texture = validateTextureBinding(functionName, target, true);
3783     if (!texture)
3784         return false;
3785 
3786     if (functionType != TexSubImage) {
3787         if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
3788             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);
3789             return false;
3790         }
3791         if (!validateNPOTTextureLevel(width, height, level, functionName))
3792             return false;
3793         // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
3794         // by checking if the ArrayBufferView is null or not.
3795         if (sourceType != SourceArrayBufferView) {
3796             if (!validateSettableTexInternalFormat(functionName, internalFormat))
3797                 return false;
3798         }
3799     } else {
3800         if (!validateSettableTexInternalFormat(functionName, internalFormat))
3801             return false;
3802         if (!validateSize(functionName, xoffset, yoffset))
3803             return false;
3804         // Before checking if it is in the range, check if overflow happens first.
3805         if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
3806             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);
3807             return false;
3808         }
3809         if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
3810             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);
3811             return false;
3812         }
3813         if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
3814             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);
3815             return false;
3816         }
3817     }
3818 
3819     return true;
3820 }
3821 
3822 void WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3823 {
3824     if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
3825         || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
3826         return;
3827     void* data = pixels ? pixels-&gt;baseAddress() : 0;
3828     Vector&lt;uint8_t&gt; tempData;
3829     bool changeUnpackAlignment = false;
3830     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3831         if (!m_context-&gt;extractTextureData(width, height, format, type,
3832                                            m_unpackAlignment,
3833                                            m_unpackFlipY, m_unpackPremultiplyAlpha,
3834                                            data,
3835                                            tempData))
3836             return;
3837         data = tempData.data();
3838         changeUnpackAlignment = true;
3839     }
3840     if (changeUnpackAlignment)
3841         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3842     texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
3843     if (changeUnpackAlignment)
3844         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3845 }
3846 
3847 void WebGLRenderingContextBase::texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)
3848 {
3849     Vector&lt;uint8_t&gt; data;
3850     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);
3851     if (!imageExtractor.extractSucceeded()) {
3852         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);
3853         return;
3854     }
3855     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();
3856     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();
3857     const void* imagePixelData = imageExtractor.imagePixelData();
3858 
3859     bool needConversion = true;
3860     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)
3861         needConversion = false;
3862     else {
3863         if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
3864             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
3865             return;
3866         }
3867     }
3868 
3869     if (m_unpackAlignment != 1)
3870         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3871 
3872     texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
3873 
3874     if (m_unpackAlignment != 1)
3875         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3876 }
3877 
3878 void WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)
3879 {
3880     if (isContextLostOrPending())
3881         return;
3882 
3883     auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3884     if (!texture)
3885         return;
3886 
3887     GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3888     if (!internalFormat) {
3889         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3890         return;
3891     }
3892 
3893     if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
3894         return;
3895 
3896     if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceArrayBufferView, target, level, internalFormat, width, height, 0, format, type, xoffset, yoffset))
3897         return;
3898 
3899     void* data = pixels-&gt;baseAddress();
3900     Vector&lt;uint8_t&gt; tempData;
3901     bool changeUnpackAlignment = false;
3902     if (data &amp;&amp; (m_unpackFlipY || m_unpackPremultiplyAlpha)) {
3903         if (!m_context-&gt;extractTextureData(width, height, format, type, m_unpackAlignment, m_unpackFlipY, m_unpackPremultiplyAlpha, data, tempData))
3904             return;
3905         data = tempData.data();
3906         changeUnpackAlignment = true;
3907     }
3908     if (changeUnpackAlignment)
3909         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3910 
3911     texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
3912 
3913     if (changeUnpackAlignment)
3914         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3915 }
3916 
3917 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)
3918 {
3919     if (!source) {
3920         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);
3921         return { };
3922     }
3923 
3924     if (isContextLostOrPending())
3925         return { };
3926 
3927     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
3928         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3929         if (!texture)
3930             return { };
3931 
3932         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3933         if (!internalFormat) {
3934             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3935             return { };
3936         }
3937 
3938         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
3939             return { };
3940 
3941         ImageBuffer* buffer = bitmap-&gt;buffer();
3942         if (!buffer)
3943             return { };
3944 
3945         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());
3946         if (image)
3947             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
3948         return { };
3949     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
3950         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
3951         if (!texture)
3952             return { };
3953 
3954         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
3955         if (!internalFormat) {
3956             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
3957             return { };
3958         }
3959 
3960         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
3961             return { };
3962 
3963         Vector&lt;uint8_t&gt; data;
3964         bool needConversion = true;
3965         // The data from ImageData is always of format RGBA8.
3966         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
3967         if (format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)
3968             needConversion = false;
3969         else {
3970             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
3971                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);
3972                 return { };
3973             }
3974         }
3975         if (m_unpackAlignment != 1)
3976             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
3977 
3978         texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
3979 
3980         if (m_unpackAlignment != 1)
3981             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
3982 
3983         return { };
3984     } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
3985         if (isContextLostOrPending())
3986             return { };
3987         auto validationResult = validateHTMLImageElement(&quot;texSubImage2D&quot;, image.get());
3988         if (validationResult.hasException())
3989             return validationResult.releaseException();
3990         if (!validationResult.returnValue())
3991             return { };
3992 
3993         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
3994         if (!imageForRender)
3995             return { };
3996 
3997         if (imageForRender-&gt;isSVGImage())
3998             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
3999 
4000         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4001         if (!texture)
4002             return { };
4003 
4004         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
4005         if (!internalFormat) {
4006             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4007             return { };
4008         }
4009 
4010         if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
4011             return { };
4012 
4013         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
4014         return { };
4015     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4016         if (isContextLostOrPending())
4017             return { };
4018         auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
4019         if (validationResult.hasException())
4020             return validationResult.releaseException();
4021         if (!validationResult.returnValue())
4022             return { };
4023 
4024         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4025         if (!texture)
4026             return { };
4027 
4028         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
4029         if (!internalFormat) {
4030             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4031             return { };
4032         }
4033 
4034         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
4035             return { };
4036 
4037         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4038         if (imageData)
4039             texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
4040         else
4041             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4042         return { };
4043     }
4044 #if ENABLE(VIDEO)
4045     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4046         if (isContextLostOrPending())
4047             return { };
4048         auto validationResult = validateHTMLVideoElement(&quot;texSubImage2D&quot;, video.get());
4049         if (validationResult.hasException())
4050             return validationResult.releaseException();
4051         if (!validationResult.returnValue())
4052             return { };
4053 
4054         auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4055         if (!texture)
4056             return { };
4057 
4058         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);
4059         if (!internalFormat) {
4060             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);
4061             return { };
4062         }
4063 
4064         if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
4065             return { };
4066 
4067         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());
4068         if (!image)
4069             return { };
4070         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);
4071         return { };
4072     }
4073 #endif
4074     );
4075 
4076     return WTF::visit(visitor, source.value());
4077 }
4078 
4079 bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)
4080 {
4081 #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
4082             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \
4083             return false; \
4084         } \
4085         break;
4086 
4087     switch (type) {
4088     case GraphicsContext3D::UNSIGNED_BYTE:
4089         TYPE_VALIDATION_CASE(TypeUint8);
4090     case GraphicsContext3D::BYTE:
4091         TYPE_VALIDATION_CASE(TypeInt8);
4092     case GraphicsContext3D::UNSIGNED_SHORT:
4093     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
4094     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
4095     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
4096         TYPE_VALIDATION_CASE(TypeUint16);
4097     case GraphicsContext3D::SHORT:
4098         TYPE_VALIDATION_CASE(TypeInt16);
4099     case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:
4100     case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:
4101     case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:
4102     case GraphicsContext3D::UNSIGNED_INT_24_8:
4103     case GraphicsContext3D::UNSIGNED_INT:
4104         TYPE_VALIDATION_CASE(TypeUint32);
4105     case GraphicsContext3D::INT:
4106         TYPE_VALIDATION_CASE(TypeInt32);
4107     case GraphicsContext3D::FLOAT: // OES_texture_float
4108         TYPE_VALIDATION_CASE(TypeFloat32);
4109     case GraphicsContext3D::HALF_FLOAT_OES: // OES_texture_half_float
4110     case GraphicsContext3D::HALF_FLOAT:
4111     case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:
4112         // As per the specification, ArrayBufferView should be null when
4113         // OES_texture_half_float is enabled.
4114         if (arrayType) {
4115             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type HALF_FLOAT_OES but ArrayBufferView is not NULL&quot;);
4116             return false;
4117         }
4118         break;
4119     default:
4120         ASSERT_NOT_REACHED();
4121         return false;
4122     }
4123 #undef TYPE_VALIDATION_CASE
4124     return true;
4125 }
4126 
4127 bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, ArrayBufferView* pixels, NullDisposition disposition)
4128 {
4129     if (!pixels) {
4130         if (disposition == NullAllowed)
4131             return true;
4132         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no pixels&quot;);
4133         return false;
4134     }
4135 
4136     if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
4137         return false;
4138     if (!validateSettableTexInternalFormat(functionName, internalFormat))
4139         return false;
4140     if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
4141         return false;
4142 
4143     unsigned totalBytesRequired;
4144     GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);
4145     if (error != GraphicsContext3D::NO_ERROR) {
4146         synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
4147         return false;
4148     }
4149     if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
4150         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);
4151         return false;
4152     }
4153     return true;
4154 }
4155 
4156 bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
4157     TexFuncValidationFunctionType functionType,
4158     GC3Denum target, GC3Dint level,
4159     GC3Denum internalformat,
4160     GC3Dsizei width, GC3Dsizei height, GC3Dint border,
4161     GC3Denum format, GC3Denum type)
4162 {
4163     // We absolutely have to validate the format and type combination.
4164     // The texImage2D entry points taking HTMLImage, etc. will produce
4165     // temporary data based on this combination, so it must be legal.
4166     if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
4167         return false;
4168 
4169     if (width &lt; 0 || height &lt; 0) {
4170         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
4171         return false;
4172     }
4173 
4174     GC3Dint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);
4175     switch (target) {
4176     case GraphicsContext3D::TEXTURE_2D:
4177         if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
4178             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);
4179             return false;
4180         }
4181         break;
4182     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
4183     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
4184     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
4185     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
4186     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
4187     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
4188         if (functionType != TexSubImage &amp;&amp; width != height) {
4189             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);
4190             return false;
4191         }
4192         // No need to check height here. For texImage width == height.
4193         // For texSubImage that will be checked when checking yoffset + height is in range.
4194         if (width &gt; maxTextureSizeForLevel) {
4195             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);
4196             return false;
4197         }
4198         break;
4199     default:
4200         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);
4201         return false;
4202     }
4203 
4204     if (border) {
4205         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;border != 0&quot;);
4206         return false;
4207     }
4208 
4209     return true;
4210 }
4211 
4212 bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GC3Denum internalFormat, GC3Denum format, GC3Denum type, GC3Dint level)
4213 {
4214     switch (format) {
4215     case GraphicsContext3D::ALPHA:
4216     case GraphicsContext3D::LUMINANCE:
4217     case GraphicsContext3D::LUMINANCE_ALPHA:
4218     case GraphicsContext3D::RGB:
4219     case GraphicsContext3D::RGBA:
4220         break;
4221     case GraphicsContext3D::DEPTH_STENCIL:
4222     case GraphicsContext3D::DEPTH_COMPONENT:
4223         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4224             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);
4225             return false;
4226         }
4227         if (level &gt; 0) {
4228             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);
4229             return false;
4230         }
4231         break;
4232     case Extensions3D::SRGB_EXT:
4233     case Extensions3D::SRGB_ALPHA_EXT:
4234         if (!m_extsRGB) {
4235             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);
4236             return false;
4237         }
4238         break;
4239     default:
4240 #if ENABLE(WEBGL2)
4241         if (!isWebGL1()) {
4242             switch (format) {
4243             case GraphicsContext3D::RED:
4244             case GraphicsContext3D::RED_INTEGER:
4245             case GraphicsContext3D::RG:
4246             case GraphicsContext3D::RG_INTEGER:
4247             case GraphicsContext3D::RGB_INTEGER:
4248             case GraphicsContext3D::RGBA_INTEGER:
4249                 break;
4250             default:
4251                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4252                 return false;
4253             }
4254         } else
4255 #endif
4256         {
4257             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);
4258             return false;
4259         }
4260     }
4261 
4262     switch (type) {
4263     case GraphicsContext3D::UNSIGNED_BYTE:
4264     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:
4265     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:
4266     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:
4267         break;
4268     case GraphicsContext3D::FLOAT:
4269         if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
4270             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4271             return false;
4272         }
4273         break;
4274     case GraphicsContext3D::HALF_FLOAT:
4275     case GraphicsContext3D::HALF_FLOAT_OES:
4276         if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
4277             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4278             return false;
4279         }
4280         break;
4281     case GraphicsContext3D::UNSIGNED_INT:
4282     case GraphicsContext3D::UNSIGNED_INT_24_8:
4283     case GraphicsContext3D::UNSIGNED_SHORT:
4284         if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
4285             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4286             return false;
4287         }
4288         break;
4289     default:
4290 #if ENABLE(WEBGL2)
4291         if (!isWebGL1()) {
4292             switch (type) {
4293             case GraphicsContext3D::BYTE:
4294             case GraphicsContext3D::SHORT:
4295             case GraphicsContext3D::INT:
4296             case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:
4297             case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:
4298             case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:
4299             case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:
4300                 break;
4301             default:
4302                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4303                 return false;
4304             }
4305         } else
4306 #endif
4307         {
4308             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);
4309             return false;
4310         }
4311     }
4312 
4313     // Verify that the combination of internalformat, format, and type is supported.
4314 #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContext3D::internalFormatMacro: \
4315     if (format != GraphicsContext3D::formatMacro) { \
4316         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \
4317         return false; \
4318     } \
4319     if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
4320         if (type != GraphicsContext3D::HALF_FLOAT_OES || (type0 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type1 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type2 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type3 != GraphicsContext3D::HALF_FLOAT)) { \
4321             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \
4322             return false; \
4323         } \
4324     } \
4325     break;
4326     switch (internalFormat) {
4327     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , GraphicsContext3D::HALF_FLOAT                  , GraphicsContext3D::FLOAT     , 0                       );
4328     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1      , GraphicsContext3D::HALF_FLOAT, GraphicsContext3D::FLOAT);
4329     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4330     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4331     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4332     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4333     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4334     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4335     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4336     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4337     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4338     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4339     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4340     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4341     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4342     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4343     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4344     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4345     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4346     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4347     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4348     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4349     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4350     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4351     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4352     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4353     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4354     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );
4355     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4356     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4357     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );
4358     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4359     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4360     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4361     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4362     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4363     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4364     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4365     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4366     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4367     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4368     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4369     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1, GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );
4370     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );
4371     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4372     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );
4373     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4374     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );
4375     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );
4376     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );
4377     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );
4378     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );
4379     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );
4380     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4381     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4382     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );
4383     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );
4384     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );
4385     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4386     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );
4387     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );
4388     case Extensions3D::SRGB_EXT:
4389         if (format != internalFormat) {
4390             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4391             return false;
4392         }
4393         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {
4394             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4395             return false;
4396         }
4397         break;
4398     case Extensions3D::SRGB_ALPHA_EXT:
4399         if (format != internalFormat) {
4400             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);
4401             return false;
4402         }
4403         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {
4404             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);
4405             return false;
4406         }
4407         break;
4408     default:
4409         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);
4410         return false;
4411     }
4412 #undef INTERNAL_FORMAT_CASE
4413 
4414     return true;
4415 }
4416 
4417 void WebGLRenderingContextBase::texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, const void* pixels)
4418 {
4419     ASSERT(!isContextLost());
4420     ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
4421     ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
4422     ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
4423     auto tex = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
4424     if (!tex) {
4425         ASSERT_NOT_REACHED();
4426         return;
4427     }
4428     ASSERT((xoffset + width) &gt;= 0);
4429     ASSERT((yoffset + height) &gt;= 0);
4430     ASSERT(tex-&gt;getWidth(target, level) &gt;= (xoffset + width));
4431     ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
4432     ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
4433     m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
4434 }
4435 
4436 void WebGLRenderingContextBase::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)
4437 {
4438     if (isContextLostOrPending())
4439         return;
4440     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContext3D::UNSIGNED_BYTE))
4441         return;
4442     if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
4443         return;
4444     auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
4445     if (!tex)
4446         return;
4447     if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
4448         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);
4449         return;
4450     }
4451     if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
4452         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);
4453         return;
4454     }
4455     const char* reason = &quot;framebuffer incomplete&quot;;
4456     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {
4457         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);
4458         return;
4459     }
4460     clearIfComposited();
4461 
4462     GC3Dint clippedX, clippedY;
4463     GC3Dsizei clippedWidth, clippedHeight;
4464     if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
4465         m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
4466             internalFormat, GraphicsContext3D::UNSIGNED_BYTE, m_unpackAlignment);
4467         if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
4468             m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
4469                 clippedX, clippedY, clippedWidth, clippedHeight);
4470         }
4471     } else
4472         m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
4473 
4474     // FIXME: if the framebuffer is not complete, none of the below should be executed.
4475     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);
4476 }
4477 
4478 static bool isRGBFormat(GC3Denum internalFormat)
4479 {
4480     return internalFormat == GraphicsContext3D::RGB
4481         || internalFormat == GraphicsContext3D::RGBA
4482         || internalFormat == GraphicsContext3D::RGB8
4483         || internalFormat == GraphicsContext3D::RGBA8;
4484 }
4485 
4486 ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt; source)
4487 {
4488     if (!source) {
4489         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);
4490         return { };
4491     }
4492 
4493     auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
4494         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
4495             return { };
4496 
4497         ImageBuffer* buffer = bitmap-&gt;buffer();
4498         if (!buffer)
4499             return { };
4500 
4501         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4502         // If possible, copy from the bitmap directly to the texture
4503         // via the GPU, without a read-back to system memory.
4504         //
4505         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4506         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4507         if (texture
4508             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4509             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {
4510             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4511             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4512                 if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4513                     texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
4514                     return { };
4515                 }
4516             }
4517         }
4518 
4519         // Normal pure SW path.
4520         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());
4521         if (image)
4522             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
4523         return { };
4524     }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
4525         if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
4526             return { };
4527         Vector&lt;uint8_t&gt; data;
4528         bool needConversion = true;
4529         // The data from ImageData is always of format RGBA8.
4530         // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
4531         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE)
4532             needConversion = false;
4533         else {
4534             if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
4535                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);
4536                 return { };
4537             }
4538         }
4539         if (m_unpackAlignment != 1)
4540             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);
4541         texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
4542         if (m_unpackAlignment != 1)
4543             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);
4544         return { };
4545     }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
4546         if (isContextLostOrPending())
4547             return { };
4548         auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
4549         if (validationResult.hasException())
4550             return validationResult.releaseException();
4551         if (!validationResult.returnValue())
4552             return { };
4553 
4554         RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
4555         if (!imageForRender)
4556             return { };
4557 
4558         if (imageForRender-&gt;isSVGImage())
4559             imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
4560 
4561         if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
4562             return { };
4563 
4564         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);
4565         return { };
4566     }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
4567         if (isContextLostOrPending())
4568             return { };
4569         auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
4570         if (validationResult.hasException())
4571             return validationResult.releaseException();
4572         if (!validationResult.returnValue())
4573             return { };
4574         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLCanvasElement, target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, 0, 0))
4575             return { };
4576 
4577         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4578         // If possible, copy from the canvas element directly to the texture
4579         // via the GPU, without a read-back to system memory.
4580         //
4581         // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
4582         // ImageBuffer::copyToPlatformTexture implementations are fully functional.
4583         if (texture
4584             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4585             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {
4586             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4587             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4588                 ImageBuffer* buffer = canvas-&gt;buffer();
4589                 if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4590                     texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
4591                     return { };
4592                 }
4593             }
4594         }
4595 
4596         RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
4597         if (imageData)
4598             texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
4599         else
4600             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);
4601         return { };
4602     }
4603 #if ENABLE(VIDEO)
4604     , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
4605         if (isContextLostOrPending())
4606             return { };
4607         auto validationResult = validateHTMLVideoElement(&quot;texImage2D&quot;, video.get());
4608         if (validationResult.hasException())
4609             return validationResult.releaseException();
4610         if (!validationResult.returnValue())
4611             return { };
4612         if (!validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLVideoElement, target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, 0, 0))
4613             return { };
4614 
4615         // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
4616         // Otherwise, it will fall back to the normal SW path.
4617         // FIXME: The current restrictions require that format shoud be RGB or RGBA,
4618         // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
4619         auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
4620         if (GraphicsContext3D::TEXTURE_2D == target &amp;&amp; texture
4621             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)
4622             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE
4623             &amp;&amp; !level) {
4624             auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
4625             if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
4626                 if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
4627                     texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
4628                     return { };
4629                 }
4630             }
4631         }
4632 
4633         // Normal pure SW path.
4634         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());
4635         if (!image)
4636             return { };
4637         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);
4638         return { };
4639     }
4640 #endif
4641     );
4642 
4643     return WTF::visit(visitor, source.value());
4644 }
4645 
4646 RefPtr&lt;Image&gt; WebGLRenderingContextBase::drawImageIntoBuffer(Image&amp; image, int width, int height, int deviceScaleFactor)
4647 {
4648     IntSize size(width, height);
4649     size.scale(deviceScaleFactor);
4650     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4651     if (!buf) {
4652         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4653         return nullptr;
4654     }
4655 
4656     FloatRect srcRect(FloatPoint(), image.size());
4657     FloatRect destRect(FloatPoint(), size);
4658     buf-&gt;context().drawImage(image, destRect, srcRect);
4659     return buf-&gt;copyImage(ImageBuffer::fastCopyImageMode());
4660 }
4661 
4662 #if ENABLE(VIDEO)
4663 
4664 RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
4665 {
4666     IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
4667     ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
4668     if (!buf) {
4669         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);
4670         return nullptr;
4671     }
4672     FloatRect destRect(0, 0, size.width(), size.height());
4673     // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
4674     video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
4675     return buf-&gt;copyImage(backingStoreCopy);
4676 }
4677 
4678 #endif
4679 
4680 void WebGLRenderingContextBase::texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat paramf, GC3Dint parami, bool isFloat)
4681 {
4682     if (isContextLostOrPending())
4683         return;
4684     auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
4685     if (!tex)
4686         return;
4687     switch (pname) {
4688     case GraphicsContext3D::TEXTURE_MIN_FILTER:
4689     case GraphicsContext3D::TEXTURE_MAG_FILTER:
4690         break;
4691     case GraphicsContext3D::TEXTURE_WRAP_S:
4692     case GraphicsContext3D::TEXTURE_WRAP_T:
4693         if ((isFloat &amp;&amp; paramf != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContext3D::REPEAT)
4694             || (!isFloat &amp;&amp; parami != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContext3D::REPEAT)) {
4695             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);
4696             return;
4697         }
4698         break;
4699     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
4700         if (!m_extTextureFilterAnisotropic) {
4701             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);
4702             return;
4703         }
4704         break;
4705     default:
4706         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);
4707         return;
4708     }
4709     if (isFloat) {
4710         tex-&gt;setParameterf(pname, paramf);
4711         m_context-&gt;texParameterf(target, pname, paramf);
4712     } else {
4713         tex-&gt;setParameteri(pname, parami);
4714         m_context-&gt;texParameteri(target, pname, parami);
4715     }
4716 }
4717 
4718 void WebGLRenderingContextBase::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param)
4719 {
4720     texParameter(target, pname, param, 0, true);
4721 }
4722 
4723 void WebGLRenderingContextBase::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param)
4724 {
4725     texParameter(target, pname, 0, param, false);
4726 }
4727 
4728 void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GC3Dfloat x)
4729 {
4730     if (isContextLostOrPending() || !location)
4731         return;
4732 
4733     if (location-&gt;program() != m_currentProgram) {
4734         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);
4735         return;
4736     }
4737 
4738     m_context-&gt;uniform1f(location-&gt;location(), x);
4739 }
4740 
4741 void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y)
4742 {
4743     if (isContextLostOrPending() || !location)
4744         return;
4745 
4746     if (location-&gt;program() != m_currentProgram) {
4747         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);
4748         return;
4749     }
4750 
4751     m_context-&gt;uniform2f(location-&gt;location(), x, y);
4752 }
4753 
4754 void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z)
4755 {
4756     if (isContextLostOrPending() || !location)
4757         return;
4758 
4759     if (location-&gt;program() != m_currentProgram) {
4760         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);
4761         return;
4762     }
4763 
4764     m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
4765 }
4766 
4767 void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w)
4768 {
4769     if (isContextLostOrPending() || !location)
4770         return;
4771 
4772     if (location-&gt;program() != m_currentProgram) {
4773         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);
4774         return;
4775     }
4776 
4777     m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
4778 }
4779 
4780 void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GC3Dint x)
4781 {
4782     if (isContextLostOrPending() || !location)
4783         return;
4784 
4785     if (location-&gt;program() != m_currentProgram) {
4786         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);
4787         return;
4788     }
4789 
4790     if ((location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {
4791         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);
4792         return;
4793     }
4794 
4795     m_context-&gt;uniform1i(location-&gt;location(), x);
4796 }
4797 
4798 void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y)
4799 {
4800     if (isContextLostOrPending() || !location)
4801         return;
4802 
4803     if (location-&gt;program() != m_currentProgram) {
4804         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);
4805         return;
4806     }
4807 
4808     m_context-&gt;uniform2i(location-&gt;location(), x, y);
4809 }
4810 
4811 void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z)
4812 {
4813     if (isContextLostOrPending() || !location)
4814         return;
4815 
4816     if (location-&gt;program() != m_currentProgram) {
4817         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);
4818         return;
4819     }
4820 
4821     m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
4822 }
4823 
4824 void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w)
4825 {
4826     if (isContextLostOrPending() || !location)
4827         return;
4828 
4829     if (location-&gt;program() != m_currentProgram) {
4830         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);
4831         return;
4832     }
4833 
4834     m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
4835 }
4836 
4837 void WebGLRenderingContextBase::uniform1fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4838 {
4839     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1fv&quot;, location, v, 1))
4840         return;
4841 
4842     m_context-&gt;uniform1fv(location-&gt;location(), v.length(), v.data());
4843 }
4844 
4845 void WebGLRenderingContextBase::uniform2fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4846 {
4847     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2fv&quot;, location, v, 2))
4848         return;
4849 
4850     m_context-&gt;uniform2fv(location-&gt;location(), v.length() / 2, v.data());
4851 }
4852 
4853 void WebGLRenderingContextBase::uniform3fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4854 {
4855     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3fv&quot;, location, v, 3))
4856         return;
4857 
4858     m_context-&gt;uniform3fv(location-&gt;location(), v.length() / 3, v.data());
4859 }
4860 
4861 void WebGLRenderingContextBase::uniform4fv(const WebGLUniformLocation* location, Float32List&amp;&amp; v)
4862 {
4863     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4fv&quot;, location, v, 4))
4864         return;
4865 
4866     m_context-&gt;uniform4fv(location-&gt;location(), v.length() / 4, v.data());
4867 }
4868 
4869 void WebGLRenderingContextBase::uniform1iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4870 {
4871     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform1iv&quot;, location, v, 1))
4872         return;
4873 
4874     auto data = v.data();
4875     auto length = v.length();
4876 
4877     if (location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) {
4878         for (auto i = 0; i &lt; length; ++i) {
4879             if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
4880                 LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
4881                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);
4882                 return;
4883             }
4884         }
4885     }
4886 
4887     m_context-&gt;uniform1iv(location-&gt;location(), length, data);
4888 }
4889 
4890 void WebGLRenderingContextBase::uniform2iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4891 {
4892     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform2iv&quot;, location, v, 2))
4893         return;
4894 
4895     m_context-&gt;uniform2iv(location-&gt;location(), v.length() / 2, v.data());
4896 }
4897 
4898 void WebGLRenderingContextBase::uniform3iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4899 {
4900     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform3iv&quot;, location, v, 3))
4901         return;
4902 
4903     m_context-&gt;uniform3iv(location-&gt;location(), v.length() / 3, v.data());
4904 }
4905 
4906 void WebGLRenderingContextBase::uniform4iv(const WebGLUniformLocation* location, Int32List&amp;&amp; v)
4907 {
4908     if (isContextLostOrPending() || !validateUniformParameters(&quot;uniform4iv&quot;, location, v, 4))
4909         return;
4910 
4911     m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
4912 }
4913 
4914 void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4915 {
4916     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
4917         return;
4918     m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
4919 }
4920 
4921 void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4922 {
4923     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
4924         return;
4925     m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
4926 }
4927 
4928 void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)
4929 {
4930     if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
4931         return;
4932     m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
4933 }
4934 
4935 void WebGLRenderingContextBase::useProgram(WebGLProgram* program)
4936 {
4937     bool deleted;
4938     if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
4939         return;
4940     if (deleted)
4941         program = 0;
4942     if (program &amp;&amp; !program-&gt;getLinkStatus()) {
4943         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);
4944         return;
4945     }
4946     if (m_currentProgram != program) {
4947         if (m_currentProgram)
4948             m_currentProgram-&gt;onDetached(graphicsContext3D());
4949         m_currentProgram = program;
4950         m_context-&gt;useProgram(objectOrZero(program));
4951         if (program)
4952             program-&gt;onAttached();
4953     }
4954 }
4955 
4956 void WebGLRenderingContextBase::validateProgram(WebGLProgram* program)
4957 {
4958     if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
4959         return;
4960     m_context-&gt;validateProgram(objectOrZero(program));
4961 }
4962 
4963 void WebGLRenderingContextBase::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)
4964 {
4965     vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
4966 }
4967 
4968 void WebGLRenderingContextBase::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)
4969 {
4970     vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
4971 }
4972 
4973 void WebGLRenderingContextBase::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)
4974 {
4975     vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
4976 }
4977 
4978 void WebGLRenderingContextBase::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
4979 {
4980     vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
4981 }
4982 
4983 void WebGLRenderingContextBase::vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp; v)
4984 {
4985     vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
4986 }
4987 
4988 void WebGLRenderingContextBase::vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp; v)
4989 {
4990     vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
4991 }
4992 
4993 void WebGLRenderingContextBase::vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp; v)
4994 {
4995     vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
4996 }
4997 
4998 void WebGLRenderingContextBase::vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp; v)
4999 {
5000     vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
5001 }
5002 
5003 void WebGLRenderingContextBase::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, long long offset)
5004 {
5005     if (isContextLostOrPending())
5006         return;
5007     switch (type) {
5008     case GraphicsContext3D::BYTE:
5009     case GraphicsContext3D::UNSIGNED_BYTE:
5010     case GraphicsContext3D::SHORT:
5011     case GraphicsContext3D::UNSIGNED_SHORT:
5012     case GraphicsContext3D::FLOAT:
5013         break;
5014     default:
5015         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5016         return;
5017     }
5018     if (index &gt;= m_maxVertexAttribs) {
5019         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);
5020         return;
5021     }
5022     if (size &lt; 1 || size &gt; 4) {
5023         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);
5024         return;
5025     }
5026     if (stride &lt; 0 || stride &gt; 255) {
5027         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);
5028         return;
5029     }
5030     if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
5031         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);
5032         return;
5033     }
<a name="40" id="anc40"></a><span class="line-modified">5034     if (!m_boundArrayBuffer &amp;&amp; offset) {</span>
5035         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);
5036         return;
5037     }
5038     // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
5039     auto typeSize = sizeInBytes(type);
5040     if (!typeSize) {
5041         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);
5042         return;
5043     }
5044     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {
5045         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);
5046         return;
5047     }
5048     GC3Dsizei bytesPerElement = size * typeSize;
5049 
<a name="41" id="anc41"></a><span class="line-modified">5050     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), m_boundArrayBuffer.get());</span>
5051     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));
5052 }
5053 
5054 void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)
5055 {
5056     if (isContextLostOrPending())
5057         return;
5058     if (!validateSize(&quot;viewport&quot;, width, height))
5059         return;
5060     m_context-&gt;viewport(x, y, width, height);
5061 }
5062 
5063 void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
5064 {
5065     if (isContextLostOrPending()) {
5066         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);
5067         return;
5068     }
5069 
5070     m_contextGroup-&gt;loseContextGroup(mode);
5071 }
5072 
<a name="42" id="anc42"></a>








5073 void WebGLRenderingContextBase::loseContextImpl(WebGLRenderingContextBase::LostContextMode mode)
5074 {
5075     if (isContextLost())
5076         return;
5077 
5078     m_contextLost = true;
5079     m_contextLostMode = mode;
5080 
5081     if (mode == RealLostContext) {
5082         // Inform the embedder that a lost context was received. In response, the embedder might
5083         // decide to take action such as asking the user for permission to use WebGL again.
5084         auto* canvas = htmlCanvas();
5085         if (canvas) {
5086             if (RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame())
5087                 frame-&gt;loader().client().didLoseWebGLContext(m_context-&gt;getExtensions().getGraphicsResetStatusARB());
5088         }
5089     }
5090 
5091     detachAndRemoveAllObjects();
5092 
5093     // There is no direct way to clear errors from a GL implementation and
5094     // looping until getError() becomes NO_ERROR might cause an infinite loop if
5095     // the driver or context implementation had a bug. So, loop a reasonably
5096     // large number of times to clear any existing errors.
5097     for (int i = 0; i &lt; 100; ++i) {
5098         if (m_context-&gt;getError() == GraphicsContext3D::NO_ERROR)
5099             break;
5100     }
5101     ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
5102     synthesizeGLError(GraphicsContext3D::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);
5103 
5104     // Don&#39;t allow restoration unless the context lost event has both been
5105     // dispatched and its default behavior prevented.
5106     m_restoreAllowed = false;
5107 
5108     // Always defer the dispatch of the context lost event, to implement
5109     // the spec behavior of queueing a task.
5110     m_dispatchContextLostEventTimer.startOneShot(0_s);
5111 }
5112 
5113 void WebGLRenderingContextBase::forceRestoreContext()
5114 {
5115     if (!isContextLostOrPending()) {
5116         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);
5117         return;
5118     }
5119 
5120     if (!m_restoreAllowed) {
5121         if (m_contextLostMode == SyntheticLostContext)
5122             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);
5123         return;
5124     }
5125 
5126     if (!m_restoreTimer.isActive())
5127         m_restoreTimer.startOneShot(0_s);
5128 }
5129 
5130 PlatformLayer* WebGLRenderingContextBase::platformLayer() const
5131 {
5132     return (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) ? m_context-&gt;platformLayer() : 0;
5133 }
5134 
5135 void WebGLRenderingContextBase::removeSharedObject(WebGLSharedObject&amp; object)
5136 {
5137     if (m_isPendingPolicyResolution)
5138         return;
5139 
5140     m_contextGroup-&gt;removeObject(object);
5141 }
5142 
5143 void WebGLRenderingContextBase::addSharedObject(WebGLSharedObject&amp; object)
5144 {
5145     if (m_isPendingPolicyResolution)
5146         return;
5147 
5148     ASSERT(!isContextLost());
5149     m_contextGroup-&gt;addObject(object);
5150 }
5151 
5152 void WebGLRenderingContextBase::removeContextObject(WebGLContextObject&amp; object)
5153 {
5154     if (m_isPendingPolicyResolution)
5155         return;
5156 
5157     m_contextObjects.remove(&amp;object);
5158 }
5159 
5160 void WebGLRenderingContextBase::addContextObject(WebGLContextObject&amp; object)
5161 {
5162     if (m_isPendingPolicyResolution)
5163         return;
5164 
5165     ASSERT(!isContextLost());
5166     m_contextObjects.add(&amp;object);
5167 }
5168 
5169 void WebGLRenderingContextBase::detachAndRemoveAllObjects()
5170 {
5171     if (m_isPendingPolicyResolution)
5172         return;
5173 
5174     while (m_contextObjects.size() &gt; 0) {
5175         HashSet&lt;WebGLContextObject*&gt;::iterator it = m_contextObjects.begin();
5176         (*it)-&gt;detachContext();
5177     }
5178 }
5179 
5180 bool WebGLRenderingContextBase::hasPendingActivity() const
5181 {
5182     return false;
5183 }
5184 
5185 void WebGLRenderingContextBase::stop()
5186 {
5187     if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
5188         forceLostContext(SyntheticLostContext);
5189         destroyGraphicsContext3D();
5190     }
5191 }
5192 
5193 const char* WebGLRenderingContextBase::activeDOMObjectName() const
5194 {
5195     return &quot;WebGLRenderingContext&quot;;
5196 }
5197 
5198 bool WebGLRenderingContextBase::canSuspendForDocumentSuspension() const
5199 {
5200     // FIXME: We should try and do better here.
5201     return false;
5202 }
5203 
5204 bool WebGLRenderingContextBase::getBooleanParameter(GC3Denum pname)
5205 {
5206     GC3Dboolean value = 0;
5207     m_context-&gt;getBooleanv(pname, &amp;value);
5208     return value;
5209 }
5210 
5211 Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GC3Denum pname)
5212 {
5213     if (pname != GraphicsContext3D::COLOR_WRITEMASK) {
5214         notImplemented();
5215         return { };
5216     }
5217     GC3Dboolean value[4] = { 0 };
5218     m_context-&gt;getBooleanv(pname, value);
5219     Vector&lt;bool&gt; vector(4);
5220     for (unsigned i = 0; i &lt; 4; ++i)
5221         vector[i] = value[i];
5222     return vector;
5223 }
5224 
5225 float WebGLRenderingContextBase::getFloatParameter(GC3Denum pname)
5226 {
5227     GC3Dfloat value = 0;
5228     m_context-&gt;getFloatv(pname, &amp;value);
5229     return value;
5230 }
5231 
5232 int WebGLRenderingContextBase::getIntParameter(GC3Denum pname)
5233 {
5234     GC3Dint value = 0;
5235     m_context-&gt;getIntegerv(pname, &amp;value);
5236     return value;
5237 }
5238 
5239 unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GC3Denum pname)
5240 {
5241     GC3Dint value = 0;
5242     m_context-&gt;getIntegerv(pname, &amp;value);
5243     return value;
5244 }
5245 
5246 long long WebGLRenderingContextBase::getInt64Parameter(GC3Denum pname)
5247 {
5248     GC3Dint64 value = 0;
5249     m_context-&gt;getInteger64v(pname, &amp;value);
5250     return value;
5251 }
5252 
5253 RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GC3Denum pname)
5254 {
5255     GC3Dfloat value[4] = {0};
5256     m_context-&gt;getFloatv(pname, value);
5257     unsigned length = 0;
5258     switch (pname) {
5259     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:
5260     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:
5261     case GraphicsContext3D::DEPTH_RANGE:
5262         length = 2;
5263         break;
5264     case GraphicsContext3D::BLEND_COLOR:
5265     case GraphicsContext3D::COLOR_CLEAR_VALUE:
5266         length = 4;
5267         break;
5268     default:
5269         notImplemented();
5270     }
5271     return Float32Array::tryCreate(value, length);
5272 }
5273 
5274 RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GC3Denum pname)
5275 {
5276     GC3Dint value[4] = {0};
5277     m_context-&gt;getIntegerv(pname, value);
5278     unsigned length = 0;
5279     switch (pname) {
5280     case GraphicsContext3D::MAX_VIEWPORT_DIMS:
5281         length = 2;
5282         break;
5283     case GraphicsContext3D::SCISSOR_BOX:
5284     case GraphicsContext3D::VIEWPORT:
5285         length = 4;
5286         break;
5287     default:
5288         notImplemented();
5289     }
5290     return Int32Array::tryCreate(value, length);
5291 }
5292 
5293 bool WebGLRenderingContextBase::checkTextureCompleteness(const char* functionName, bool prepareToDraw)
5294 {
5295     bool resetActiveUnit = false;
5296     bool usesAtLeastOneBlackTexture = false;
5297     WebGLTexture::TextureExtensionFlag extensions = textureExtensionFlags();
5298 
5299     Vector&lt;unsigned&gt; noLongerUnrenderable;
5300     for (unsigned badTexture : m_unrenderableTextureUnits) {
5301         ASSERT(badTexture &lt; m_textureUnits.size());
5302         auto&amp; textureUnit = m_textureUnits[badTexture];
5303         bool needsToUseBlack2DTexture = textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(extensions);
5304         bool needsToUseBlack3DTexture = textureUnit.textureCubeMapBinding &amp;&amp; textureUnit.textureCubeMapBinding-&gt;needToUseBlackTexture(extensions);
5305 
5306         if (!needsToUseBlack2DTexture &amp;&amp; !needsToUseBlack3DTexture) {
5307             noLongerUnrenderable.append(badTexture);
5308             continue;
5309         }
5310 
5311         usesAtLeastOneBlackTexture = true;
5312 
5313         if (badTexture != m_activeTextureUnit) {
5314             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);
5315             resetActiveUnit = true;
5316         } else if (resetActiveUnit) {
5317             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);
5318             resetActiveUnit = false;
5319         }
5320         RefPtr&lt;WebGLTexture&gt; tex2D;
5321         RefPtr&lt;WebGLTexture&gt; texCubeMap;
5322         if (prepareToDraw) {
5323             printToConsole(MessageLevel::Error, makeString(&quot;WebGL: &quot;, functionName, &quot;: texture bound to texture unit &quot;, badTexture,
5324                 &quot; is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not &#39;texture complete&#39;,&quot;
5325                 &quot; or it is a float/half-float type with linear filtering and without the relevant float/half-float linear extension enabled.&quot;));
5326             tex2D = m_blackTexture2D.get();
5327             texCubeMap = m_blackTextureCubeMap.get();
5328         } else {
5329             tex2D = textureUnit.texture2DBinding.get();
5330             texCubeMap = textureUnit.textureCubeMapBinding.get();
5331         }
5332         if (needsToUseBlack2DTexture)
5333             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(tex2D.get()));
5334         if (needsToUseBlack3DTexture)
5335             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));
5336     }
5337     if (resetActiveUnit)
5338         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContext3D::TEXTURE0);
5339 
5340     for (unsigned renderable : noLongerUnrenderable)
5341         m_unrenderableTextureUnits.remove(renderable);
5342 
5343     return usesAtLeastOneBlackTexture;
5344 }
5345 
5346 void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
5347 {
5348     unsigned char black[] = {0, 0, 0, 255};
5349     m_blackTexture2D = createTexture();
5350     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_blackTexture2D-&gt;object());
5351     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1,
5352                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5353     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, 0);
5354     m_blackTextureCubeMap = createTexture();
5355     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());
5356     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,
5357                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5358     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,
5359                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5360     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,
5361                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5362     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,
5363                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5364     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,
5365                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5366     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,
5367                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);
5368     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, 0);
5369 }
5370 
5371 bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,
5372                                                                            GC3Denum colorBufferFormat)
5373 {
5374     unsigned need = GraphicsContext3D::getChannelBitsByFormat(texInternalFormat);
5375     unsigned have = GraphicsContext3D::getChannelBitsByFormat(colorBufferFormat);
5376     return (need &amp; have) == need;
5377 }
5378 
5379 GC3Denum WebGLRenderingContextBase::getBoundFramebufferColorFormat()
5380 {
5381     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5382         return m_framebufferBinding-&gt;getColorBufferFormat();
5383     if (m_attributes.alpha)
5384         return GraphicsContext3D::RGBA;
5385     return GraphicsContext3D::RGB;
5386 }
5387 
5388 int WebGLRenderingContextBase::getBoundFramebufferWidth()
5389 {
5390     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5391         return m_framebufferBinding-&gt;getColorBufferWidth();
5392     return m_context-&gt;getInternalFramebufferSize().width();
5393 }
5394 
5395 int WebGLRenderingContextBase::getBoundFramebufferHeight()
5396 {
5397     if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
5398         return m_framebufferBinding-&gt;getColorBufferHeight();
5399     return m_context-&gt;getInternalFramebufferSize().height();
5400 }
5401 
5402 RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap)
5403 {
5404     RefPtr&lt;WebGLTexture&gt; texture;
5405     switch (target) {
5406     case GraphicsContext3D::TEXTURE_2D:
5407         texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
5408         break;
5409     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
5410     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
5411     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
5412     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5413     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
5414     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5415         if (!useSixEnumsForCubeMap) {
5416             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5417             return nullptr;
5418         }
5419         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5420         break;
5421     case GraphicsContext3D::TEXTURE_CUBE_MAP:
5422         if (useSixEnumsForCubeMap) {
5423             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5424             return nullptr;
5425         }
5426         texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
5427         break;
5428     default:
5429         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);
5430         return nullptr;
5431     }
5432 
5433     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
5434         m_unrenderableTextureUnits.add(m_activeTextureUnit);
5435 
5436     if (!texture)
5437         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no texture&quot;);
5438     return texture;
5439 }
5440 
5441 bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
5442 {
5443     const unsigned maxWebGLLocationLength = 256;
5444     if (string.length() &gt; maxWebGLLocationLength) {
5445         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);
5446         return false;
5447     }
5448     return true;
5449 }
5450 
5451 bool WebGLRenderingContextBase::validateSize(const char* functionName, GC3Dint x, GC3Dint y)
5452 {
5453     if (x &lt; 0 || y &lt; 0) {
5454         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);
5455         return false;
5456     }
5457     return true;
5458 }
5459 
5460 bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
5461 {
5462     for (size_t i = 0; i &lt; string.length(); ++i) {
5463         if (!validateCharacter(string[i])) {
5464             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);
5465             return false;
5466         }
5467     }
5468     return true;
5469 }
5470 
5471 bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level)
5472 {
5473     if (level &lt; 0) {
5474         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);
5475         return false;
5476     }
5477     switch (target) {
5478     case GraphicsContext3D::TEXTURE_2D:
5479         if (level &gt;= m_maxTextureLevel) {
5480             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5481             return false;
5482         }
5483         break;
5484     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:
5485     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:
5486     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:
5487     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:
5488     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:
5489     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:
5490         if (level &gt;= m_maxCubeMapTextureLevel) {
5491             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);
5492             return false;
5493         }
5494         break;
5495     }
5496     // This function only checks if level is legal, so we return true and don&#39;t
5497     // generate INVALID_ENUM if target is illegal.
5498     return true;
5499 }
5500 
5501 bool WebGLRenderingContextBase::validateCompressedTexFormat(GC3Denum format)
5502 {
5503     return m_compressedTextureFormats.contains(format);
5504 }
5505 
5506 struct BlockParameters {
5507     const int width;
5508     const int height;
5509     const int size;
5510 };
5511 
5512 static inline unsigned calculateBytesForASTC(GC3Dsizei width, GC3Dsizei height, const BlockParameters&amp; parameters)
5513 {
5514     return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
5515 }
5516 
5517 bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels)
5518 {
5519     if (width &lt; 0 || height &lt; 0) {
5520         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
5521         return false;
5522     }
5523 
5524     unsigned bytesRequired = 0;
5525 
5526     // Block parameters for ASTC formats
5527     const int kASTCBlockSize = 16;
5528     static const BlockParameters ASTCParameters[] {
5529         BlockParameters { 4, 4, kASTCBlockSize },
5530         BlockParameters { 5, 4, kASTCBlockSize },
5531         BlockParameters { 5, 5, kASTCBlockSize },
5532         BlockParameters { 6, 5, kASTCBlockSize },
5533         BlockParameters { 6, 6, kASTCBlockSize },
5534         BlockParameters { 8, 5, kASTCBlockSize },
5535         BlockParameters { 8, 6, kASTCBlockSize },
5536         BlockParameters { 8, 8, kASTCBlockSize },
5537         BlockParameters { 10, 5, kASTCBlockSize },
5538         BlockParameters { 10, 6, kASTCBlockSize },
5539         BlockParameters { 10, 8, kASTCBlockSize },
5540         BlockParameters { 10, 10, kASTCBlockSize },
5541         BlockParameters { 12, 10, kASTCBlockSize },
5542         BlockParameters { 12, 12, kASTCBlockSize }
5543     };
5544     const GC3Denum ASTCEnumStartRGBA = Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR;
5545     const GC3Denum ASTCEnumStartSRGB8 = Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
5546 
5547     switch (format) {
5548     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5549     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5550     case Extensions3D::COMPRESSED_ATC_RGB_AMD:
5551         {
5552             const int kBlockSize = 8;
5553             const int kBlockWidth = 4;
5554             const int kBlockHeight = 4;
5555             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5556             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5557             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5558         }
5559         break;
5560     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5561     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT:
5562     case Extensions3D::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:
5563     case Extensions3D::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:
5564         {
5565             const int kBlockSize = 16;
5566             const int kBlockWidth = 4;
5567             const int kBlockHeight = 4;
5568             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
5569             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
5570             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
5571         }
5572         break;
5573     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5574     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5575         {
5576             const int kBlockSize = 8;
5577             const int kBlockWidth = 8;
5578             const int kBlockHeight = 8;
5579             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
5580         }
5581         break;
5582     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5583     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5584         {
5585             const int kBlockSize = 8;
5586             const int kBlockWidth = 16;
5587             const int kBlockHeight = 8;
5588             bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
5589         }
5590         break;
5591     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:
5592     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:
5593     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:
5594     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:
5595     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:
5596     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:
5597     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:
5598     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:
5599     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:
5600     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:
5601     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:
5602     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:
5603     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:
5604     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:
5605         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
5606         break;
5607     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5608     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5609     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5610     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5611     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5612     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5613     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5614     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5615     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5616     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5617     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5618     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5619     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5620     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5621         bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
5622         break;
5623     default:
5624         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid format&quot;);
5625         return false;
5626     }
5627 
5628     if (pixels.byteLength() != bytesRequired) {
5629         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);
5630         return false;
5631     }
5632 
5633     return true;
5634 }
5635 
5636 bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format)
5637 {
5638     switch (format) {
5639     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5640     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5641     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5642     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5643         const GC3Dsizei kBlockWidth = 4;
5644         const GC3Dsizei kBlockHeight = 4;
5645         const GC3Dint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;
5646         const GC3Dsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;
5647         bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
5648         bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
5649         if (!widthValid || !heightValid) {
5650             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5651             return false;
5652         }
5653         return true;
5654     }
5655     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5656     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5657     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5658     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
5659         // Height and width must be powers of 2.
5660         if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
5661             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);
5662             return false;
5663         }
5664         return true;
5665     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:
5666     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:
5667     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:
5668     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:
5669     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:
5670     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:
5671     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:
5672     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:
5673     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:
5674     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:
5675     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:
5676     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:
5677     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:
5678     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:
5679     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
5680     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:
5681     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:
5682     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
5683     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
5684     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:
5685     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:
5686     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
5687     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:
5688     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:
5689     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:
5690     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
5691     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:
5692     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
5693         // No height and width restrictions on ASTC.
5694         return true;
5695     default:
5696         return false;
5697     }
5698 }
5699 
5700 bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,
5701                                                                GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture* tex)
5702 {
5703     if (xoffset &lt; 0 || yoffset &lt; 0) {
5704       synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);
5705       return false;
5706     }
5707 
5708     switch (format) {
5709     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:
5710     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:
5711     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:
5712     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {
5713         const int kBlockWidth = 4;
5714         const int kBlockHeight = 4;
5715         if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
5716             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);
5717             return false;
5718         }
5719         if (width - xoffset &gt; tex-&gt;getWidth(target, level)
5720             || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
5721             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);
5722             return false;
5723         }
5724         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5725     }
5726     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
5727     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
5728     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
5729     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {
5730         if (xoffset || yoffset) {
5731             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);
5732             return false;
5733         }
5734         if (width != tex-&gt;getWidth(target, level)
5735             || height != tex-&gt;getHeight(target, level)) {
5736             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);
5737             return false;
5738         }
5739         return validateCompressedTexDimensions(functionName, target, level, width, height, format);
5740     }
5741     default:
5742         return false;
5743     }
5744 }
5745 
5746 bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GC3Denum mode)
5747 {
5748     switch (mode) {
5749     case GraphicsContext3D::POINTS:
5750     case GraphicsContext3D::LINE_STRIP:
5751     case GraphicsContext3D::LINE_LOOP:
5752     case GraphicsContext3D::LINES:
5753     case GraphicsContext3D::TRIANGLE_STRIP:
5754     case GraphicsContext3D::TRIANGLE_FAN:
5755     case GraphicsContext3D::TRIANGLES:
5756         return true;
5757     default:
5758         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);
5759         return false;
5760     }
5761 }
5762 
5763 bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
5764 {
5765     if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
5766         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);
5767         return false;
5768     }
5769     return true;
5770 }
5771 
5772 bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GC3Denum func)
5773 {
5774     switch (func) {
5775     case GraphicsContext3D::NEVER:
5776     case GraphicsContext3D::LESS:
5777     case GraphicsContext3D::LEQUAL:
5778     case GraphicsContext3D::GREATER:
5779     case GraphicsContext3D::GEQUAL:
5780     case GraphicsContext3D::EQUAL:
5781     case GraphicsContext3D::NOTEQUAL:
5782     case GraphicsContext3D::ALWAYS:
5783         return true;
5784     default:
5785         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);
5786         return false;
5787     }
5788 }
5789 
5790 void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
5791 {
5792     if (!m_synthesizedErrorsToConsole || !m_numGLErrorsToConsoleAllowed)
5793         return;
5794 
5795     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; consoleMessage;
5796 
5797     // Error messages can occur during function calls, so show stack traces for them.
5798     if (level == MessageLevel::Error) {
5799         Ref&lt;Inspector::ScriptCallStack&gt; stackTrace = Inspector::createScriptCallStack(JSExecState::currentState());
<a name="43" id="anc43"></a><span class="line-modified">5800         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message, WTFMove(stackTrace));</span>
5801     } else
<a name="44" id="anc44"></a><span class="line-modified">5802         consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, level, message);</span>
5803 
5804     auto* canvas = htmlCanvas();
5805     if (canvas)
5806         canvas-&gt;document().addConsoleMessage(WTFMove(consoleMessage));
5807 
5808     --m_numGLErrorsToConsoleAllowed;
5809     if (!m_numGLErrorsToConsoleAllowed)
5810         printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
5811 }
5812 
5813 bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)
5814 {
5815     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5816          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))
5817         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)
5818             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {
5819         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);
5820         return false;
5821     }
5822     return true;
5823 }
5824 
5825 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GC3Dsizei requiredMinSize)
5826 {
5827     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5828 }
5829 
5830 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GC3Dsizei requiredMinSize)
5831 {
5832     return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
5833 }
5834 
5835 bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)
5836 {
5837     return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
5838 }
5839 
5840 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const Float32List&amp; v, GC3Dsizei requiredMinSize)
5841 {
5842     return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
5843 }
5844 
5845 bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)
5846 {
5847     if (!location)
5848         return false;
5849     if (location-&gt;program() != m_currentProgram) {
5850         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);
5851         return false;
5852     }
5853     if (!v) {
5854         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);
5855         return false;
5856     }
5857     if (transpose) {
5858         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);
5859         return false;
5860     }
5861     if (size &lt; requiredMinSize || (size % requiredMinSize)) {
5862         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);
5863         return false;
5864     }
5865     return true;
5866 }
5867 
5868 WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage)
5869 {
5870     Optional&lt;WebGLBuffer*&gt; buffer;
5871     switch (target) {
5872     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:
5873         buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
5874         break;
5875     case GraphicsContext3D::ARRAY_BUFFER:
5876         buffer = m_boundArrayBuffer.get();
5877         break;
5878     default:
5879 #if ENABLE(WEBGL2)
5880         if (isWebGL2()) {
5881             switch (target) {
5882             case GraphicsContext3D::COPY_READ_BUFFER:
5883                 buffer = m_boundCopyReadBuffer.get();
5884                 break;
5885             case GraphicsContext3D::COPY_WRITE_BUFFER:
5886                 buffer = m_boundCopyWriteBuffer.get();
5887                 break;
5888             case GraphicsContext3D::PIXEL_PACK_BUFFER:
5889                 buffer = m_boundPixelPackBuffer.get();
5890                 break;
5891             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:
5892                 buffer = m_boundPixelUnpackBuffer.get();
5893                 break;
5894             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:
5895                 buffer = m_boundTransformFeedbackBuffer.get();
5896                 break;
5897             case GraphicsContext3D::UNIFORM_BUFFER:
5898                 buffer = m_boundUniformBuffer.get();
5899                 break;
5900             }
5901             if (buffer)
5902                 break;
5903         }
5904 #endif
5905         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);
5906         return nullptr;
5907     }
5908     if (!buffer || !buffer.value()) {
5909         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no buffer&quot;);
5910         return nullptr;
5911     }
5912     switch (usage) {
5913     case GraphicsContext3D::STREAM_DRAW:
5914     case GraphicsContext3D::STATIC_DRAW:
5915     case GraphicsContext3D::DYNAMIC_DRAW:
5916         return buffer.value();
5917     }
5918     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid usage&quot;);
5919     return nullptr;
5920 }
5921 
5922 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
5923 {
5924     if (!image || !image-&gt;cachedImage()) {
5925         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no image&quot;);
5926         return false;
5927     }
5928     const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
5929     if (url.isNull() || url.isEmpty() || !url.isValid()) {
5930         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid image&quot;);
5931         return false;
5932     }
5933     if (wouldTaintOrigin(image))
5934         return Exception { SecurityError };
5935     return true;
5936 }
5937 
5938 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
5939 {
5940     if (!canvas || !canvas-&gt;buffer()) {
5941         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no canvas&quot;);
5942         return false;
5943     }
5944     if (wouldTaintOrigin(canvas))
5945         return Exception { SecurityError };
5946     return true;
5947 }
5948 
5949 #if ENABLE(VIDEO)
5950 
5951 ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
5952 {
5953     if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
5954         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no video&quot;);
5955         return false;
5956     }
5957     if (wouldTaintOrigin(video))
5958         return Exception { SecurityError };
5959     return true;
5960 }
5961 
5962 #endif
5963 
5964 void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)
5965 {
5966     if (isContextLostOrPending())
5967         return;
5968     if (index &gt;= m_maxVertexAttribs) {
5969         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);
5970         return;
5971     }
5972     // In GL, we skip setting vertexAttrib0 values.
5973     if (index || isGLES2Compliant()) {
5974         switch (expectedSize) {
5975         case 1:
5976             m_context-&gt;vertexAttrib1f(index, v0);
5977             break;
5978         case 2:
5979             m_context-&gt;vertexAttrib2f(index, v0, v1);
5980             break;
5981         case 3:
5982             m_context-&gt;vertexAttrib3f(index, v0, v1, v2);
5983             break;
5984         case 4:
5985             m_context-&gt;vertexAttrib4f(index, v0, v1, v2, v3);
5986             break;
5987         }
5988     }
5989     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
5990     attribValue.value[0] = v0;
5991     attribValue.value[1] = v1;
5992     attribValue.value[2] = v2;
5993     attribValue.value[3] = v3;
5994 }
5995 
5996 void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp; list, GC3Dsizei expectedSize)
5997 {
5998     if (isContextLostOrPending())
5999         return;
6000 
6001     auto data = list.data();
6002     if (!data) {
6003         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);
6004         return;
6005     }
6006 
6007     int size = list.length();
6008     if (size &lt; expectedSize) {
6009         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);
6010         return;
6011     }
6012     if (index &gt;= m_maxVertexAttribs) {
6013         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);
6014         return;
6015     }
6016     // In GL, we skip setting vertexAttrib0 values.
6017     if (index || isGLES2Compliant()) {
6018         switch (expectedSize) {
6019         case 1:
6020             m_context-&gt;vertexAttrib1fv(index, data);
6021             break;
6022         case 2:
6023             m_context-&gt;vertexAttrib2fv(index, data);
6024             break;
6025         case 3:
6026             m_context-&gt;vertexAttrib3fv(index, data);
6027             break;
6028         case 4:
6029             m_context-&gt;vertexAttrib4fv(index, data);
6030             break;
6031         }
6032     }
6033     VertexAttribValue&amp; attribValue = m_vertexAttribValue[index];
6034     attribValue.initValue();
6035     for (int ii = 0; ii &lt; expectedSize; ++ii)
6036         attribValue.value[ii] = data[ii];
6037 }
6038 
6039 void WebGLRenderingContextBase::initVertexAttrib0()
6040 {
6041     WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6042 
6043     m_vertexAttrib0Buffer = createBuffer();
6044     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6045     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, 0, GraphicsContext3D::DYNAMIC_DRAW);
6046     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, false, 0, 0);
6047     state.bufferBinding = m_vertexAttrib0Buffer;
6048     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, 0);
6049     m_context-&gt;enableVertexAttribArray(0);
6050     m_vertexAttrib0BufferSize = 0;
6051     m_vertexAttrib0BufferValue[0] = 0.0f;
6052     m_vertexAttrib0BufferValue[1] = 0.0f;
6053     m_vertexAttrib0BufferValue[2] = 0.0f;
6054     m_vertexAttrib0BufferValue[3] = 1.0f;
6055     m_forceAttrib0BufferRefill = false;
6056     m_vertexAttrib0UsedBefore = false;
6057 }
6058 
6059 bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GC3Duint numVertex)
6060 {
6061     if (!m_currentProgram)
6062         return true;
6063 
6064     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6065     if (!usingVertexAttrib0)
6066         return true;
6067 
6068     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6069     if (state.enabled)
6070         return true;
6071 
6072     auto bufferSize = checkedAddAndMultiply&lt;GC3Duint&gt;(numVertex, 1, 4);
6073     if (!bufferSize)
6074         return false;
6075 
6076     Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());
6077     bufferDataSize *= Checked&lt;GC3Dsizeiptr&gt;(sizeof(GC3Dfloat));
6078     return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
6079 }
6080 
6081 Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GC3Duint numVertex)
6082 {
6083     if (!m_currentProgram)
6084         return false;
6085     bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
6086     if (usingVertexAttrib0)
6087         m_vertexAttrib0UsedBefore = true;
6088 
6089     auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6090     if (state.enabled &amp;&amp; usingVertexAttrib0)
6091         return false;
6092     if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
6093         return false;
6094     m_vertexAttrib0UsedBefore = true;
6095     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());
6096 
6097     // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
6098     GC3Duint bufferSize = (numVertex + 1) * 4;
6099     GC3Dsizeiptr bufferDataSize = bufferSize * sizeof(GC3Dfloat);
6100 
6101     if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
6102         m_context-&gt;moveErrorsToSyntheticErrorList();
6103         m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContext3D::DYNAMIC_DRAW);
6104         if (m_context-&gt;getError() != GraphicsContext3D::NO_ERROR) {
6105             // We were unable to create a buffer.
6106             m_vertexAttrib0UsedBefore = false;
6107             m_vertexAttrib0BufferSize = 0;
6108             m_forceAttrib0BufferRefill = true;
6109             return WTF::nullopt;
6110         }
6111         m_vertexAttrib0BufferSize = bufferDataSize;
6112         m_forceAttrib0BufferRefill = true;
6113     }
6114 
6115     auto&amp; attribValue = m_vertexAttribValue[0];
6116 
6117     if (usingVertexAttrib0
6118         &amp;&amp; (m_forceAttrib0BufferRefill
6119             || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
6120             || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
6121             || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
6122             || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
6123 
6124         auto bufferData = makeUniqueArray&lt;GC3Dfloat&gt;(bufferSize);
6125         for (GC3Duint ii = 0; ii &lt; numVertex + 1; ++ii) {
6126             bufferData[ii * 4] = attribValue.value[0];
6127             bufferData[ii * 4 + 1] = attribValue.value[1];
6128             bufferData[ii * 4 + 2] = attribValue.value[2];
6129             bufferData[ii * 4 + 3] = attribValue.value[3];
6130         }
6131         m_vertexAttrib0BufferValue[0] = attribValue.value[0];
6132         m_vertexAttrib0BufferValue[1] = attribValue.value[1];
6133         m_vertexAttrib0BufferValue[2] = attribValue.value[2];
6134         m_vertexAttrib0BufferValue[3] = attribValue.value[3];
6135         m_forceAttrib0BufferRefill = false;
6136         m_context-&gt;bufferSubData(GraphicsContext3D::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());
6137     }
6138     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, 0, 0, 0);
6139     return true;
6140 }
6141 
6142 void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
6143 {
6144     const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
6145     if (state.bufferBinding != m_vertexAttrib0Buffer) {
6146         m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));
6147         m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
6148     }
6149     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));
6150 }
6151 
6152 void WebGLRenderingContextBase::dispatchContextLostEvent()
6153 {
6154     auto* canvas = htmlCanvas();
6155     if (!canvas)
6156         return;
6157 
6158     Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
6159     canvas-&gt;dispatchEvent(event);
6160     m_restoreAllowed = event-&gt;defaultPrevented();
6161     if (m_contextLostMode == RealLostContext &amp;&amp; m_restoreAllowed)
6162         m_restoreTimer.startOneShot(0_s);
6163 }
6164 
6165 void WebGLRenderingContextBase::maybeRestoreContext()
6166 {
6167     ASSERT(m_contextLost);
6168     if (!m_contextLost)
6169         return;
6170 
6171     // The rendering context is not restored unless the default behavior of the
6172     // webglcontextlost event was prevented earlier.
6173     //
6174     // Because of the way m_restoreTimer is set up for real vs. synthetic lost
6175     // context events, we don&#39;t have to worry about this test short-circuiting
6176     // the retry loop for real context lost events.
6177     if (!m_restoreAllowed)
6178         return;
6179 
6180     int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
6181 
6182     switch (contextLostReason) {
6183     case GraphicsContext3D::NO_ERROR:
6184         // The GraphicsContext3D implementation might not fully
6185         // support GL_ARB_robustness semantics yet. Alternatively, the
6186         // WEBGL_lose_context extension might have been used to force
6187         // a lost context.
6188         break;
6189     case Extensions3D::GUILTY_CONTEXT_RESET_ARB:
6190         // The rendering context is not restored if this context was
6191         // guilty of causing the graphics reset.
6192         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
6193         return;
6194     case Extensions3D::INNOCENT_CONTEXT_RESET_ARB:
6195         // Always allow the context to be restored.
6196         break;
6197     case Extensions3D::UNKNOWN_CONTEXT_RESET_ARB:
6198         // Warn. Ideally, prompt the user telling them that WebGL
6199         // content on the page might have caused the graphics card to
6200         // reset and ask them whether they want to continue running
6201         // the content. Only if they say &quot;yes&quot; should we start
6202         // attempting to restore the context.
6203         printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page might have caused the graphics card to reset&quot;);
6204         break;
6205     }
6206 
6207     auto* canvas = htmlCanvas();
6208     if (!canvas)
6209         return;
6210 
6211     RefPtr&lt;Frame&gt; frame = canvas-&gt;document().frame();
6212     if (!frame)
6213         return;
6214 
6215     if (!frame-&gt;loader().client().allowWebGL(frame-&gt;settings().webGLEnabled()))
6216         return;
6217 
6218     RefPtr&lt;FrameView&gt; view = frame-&gt;view();
6219     if (!view)
6220         return;
6221     RefPtr&lt;ScrollView&gt; root = view-&gt;root();
6222     if (!root)
6223         return;
6224     HostWindow* hostWindow = root-&gt;hostWindow();
6225     if (!hostWindow)
6226         return;
6227 
6228     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));
6229     if (!context) {
6230         if (m_contextLostMode == RealLostContext)
6231             m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
6232         else
6233             // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
6234             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);
6235         return;
6236     }
6237 
6238     m_context = context;
6239     addActivityStateChangeObserverIfNecessary();
6240     m_contextLost = false;
6241     setupFlags();
6242     initializeNewContext();
6243     initializeVertexArrayObjects();
6244     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextrestoredEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
6245 }
6246 
<a name="45" id="anc45"></a>








6247 void WebGLRenderingContextBase::simulateContextChanged()
6248 {
6249     if (m_context)
6250         m_context-&gt;simulateContextChanged();
6251 }
6252 
6253 String WebGLRenderingContextBase::ensureNotNull(const String&amp; text) const
6254 {
6255     if (text.isNull())
6256         return WTF::emptyString();
6257     return text;
6258 }
6259 
6260 WebGLRenderingContextBase::LRUImageBufferCache::LRUImageBufferCache(int capacity)
6261     : m_buffers(capacity)
6262 {
6263 }
6264 
6265 ImageBuffer* WebGLRenderingContextBase::LRUImageBufferCache::imageBuffer(const IntSize&amp; size)
6266 {
6267     size_t i;
6268     for (i = 0; i &lt; m_buffers.size(); ++i) {
6269         ImageBuffer* buf = m_buffers[i].get();
6270         if (!buf)
6271             break;
6272         if (buf-&gt;logicalSize() != size)
6273             continue;
6274         bubbleToFront(i);
6275         buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
6276         return buf;
6277     }
6278 
6279     // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
6280     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, Unaccelerated);
6281     if (!temp)
6282         return nullptr;
6283     ASSERT(m_buffers.size() &gt; 0);
6284     i = std::min(m_buffers.size() - 1, i);
6285     m_buffers[i] = WTFMove(temp);
6286 
6287     ImageBuffer* buf = m_buffers[i].get();
6288     bubbleToFront(i);
6289     return buf;
6290 }
6291 
6292 void WebGLRenderingContextBase::LRUImageBufferCache::bubbleToFront(size_t idx)
6293 {
6294     for (size_t i = idx; i &gt; 0; --i)
6295         m_buffers[i].swap(m_buffers[i-1]);
6296 }
6297 
6298 namespace {
6299 
6300     String GetErrorString(GC3Denum error)
6301     {
6302         switch (error) {
6303         case GraphicsContext3D::INVALID_ENUM:
6304             return &quot;INVALID_ENUM&quot;_s;
6305         case GraphicsContext3D::INVALID_VALUE:
6306             return &quot;INVALID_VALUE&quot;_s;
6307         case GraphicsContext3D::INVALID_OPERATION:
6308             return &quot;INVALID_OPERATION&quot;_s;
6309         case GraphicsContext3D::OUT_OF_MEMORY:
6310             return &quot;OUT_OF_MEMORY&quot;_s;
6311         case GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION:
6312             return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
6313         case GraphicsContext3D::CONTEXT_LOST_WEBGL:
6314             return &quot;CONTEXT_LOST_WEBGL&quot;_s;
6315         default:
6316             return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
6317         }
6318     }
6319 
6320 } // namespace anonymous
6321 
6322 void WebGLRenderingContextBase::synthesizeGLError(GC3Denum error, const char* functionName, const char* description, ConsoleDisplayPreference display)
6323 {
6324     if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
6325         String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
6326         printToConsole(MessageLevel::Error, str);
6327     }
6328     m_context-&gt;synthesizeGLError(error);
6329 }
6330 
6331 void WebGLRenderingContextBase::applyStencilTest()
6332 {
6333     bool haveStencilBuffer = false;
6334 
6335     if (m_framebufferBinding)
6336         haveStencilBuffer = m_framebufferBinding-&gt;hasStencilBuffer();
6337     else {
6338         auto attributes = getContextAttributes();
6339         ASSERT(attributes);
6340         haveStencilBuffer = attributes-&gt;stencil;
6341     }
6342     enableOrDisable(GraphicsContext3D::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);
6343 }
6344 
6345 void WebGLRenderingContextBase::enableOrDisable(GC3Denum capability, bool enable)
6346 {
6347     if (enable)
6348         m_context-&gt;enable(capability);
6349     else
6350         m_context-&gt;disable(capability);
6351 }
6352 
6353 IntSize WebGLRenderingContextBase::clampedCanvasSize()
6354 {
6355     return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
6356         clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
6357 }
6358 
6359 GC3Dint WebGLRenderingContextBase::getMaxDrawBuffers()
6360 {
6361     if (!supportsDrawBuffers())
6362         return 0;
6363     if (!m_maxDrawBuffers)
6364         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);
6365     if (!m_maxColorAttachments)
6366         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6367     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
6368     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
6369 }
6370 
6371 GC3Dint WebGLRenderingContextBase::getMaxColorAttachments()
6372 {
6373     if (!supportsDrawBuffers())
6374         return 0;
6375     if (!m_maxColorAttachments)
6376         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);
6377     return m_maxColorAttachments;
6378 }
6379 
6380 void WebGLRenderingContextBase::setBackDrawBuffer(GC3Denum buf)
6381 {
6382     m_backDrawBuffer = buf;
6383 }
6384 
6385 void WebGLRenderingContextBase::restoreCurrentFramebuffer()
6386 {
6387     bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebufferBinding.get());
6388 }
6389 
6390 void WebGLRenderingContextBase::restoreCurrentTexture2D()
6391 {
6392     auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
6393     bindTexture(GraphicsContext3D::TEXTURE_2D, texture);
6394     if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
6395         m_unrenderableTextureUnits.add(m_activeTextureUnit);
6396 }
6397 
6398 bool WebGLRenderingContextBase::supportsDrawBuffers()
6399 {
6400     if (!m_drawBuffersWebGLRequirementsChecked) {
6401         m_drawBuffersWebGLRequirementsChecked = true;
6402         m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
6403     }
6404     return m_drawBuffersSupported;
6405 }
6406 
6407 void WebGLRenderingContextBase::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount)
6408 {
6409     if (!primcount) {
6410         markContextChanged();
6411         return;
6412     }
6413 
6414     if (!validateDrawArrays(&quot;drawArraysInstanced&quot;, mode, first, count, primcount))
6415         return;
6416 
6417     clearIfComposited();
6418 
6419     bool vertexAttrib0Simulated = false;
6420     if (!isGLES2Compliant()) {
6421         auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
6422         if (!simulateVertexAttrib0Status) {
6423             // We were unable to simulate the attribute buffer.
6424             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6425             return;
6426         }
6427         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6428     }
6429     if (!isGLES2NPOTStrict())
6430         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, true);
6431 
6432     m_context-&gt;drawArraysInstanced(mode, first, count, primcount);
6433 
6434     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6435         restoreStatesAfterVertexAttrib0Simulation();
6436     if (!isGLES2NPOTStrict())
6437         checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
6438     markContextChangedAndNotifyCanvasObserver();
6439 }
6440 
6441 void WebGLRenderingContextBase::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount)
6442 {
6443     if (!primcount) {
6444         markContextChanged();
6445         return;
6446     }
6447 
6448     unsigned numElements = 0;
6449     if (!validateDrawElements(&quot;drawElementsInstanced&quot;, mode, count, type, offset, numElements, primcount))
6450         return;
6451 
6452     clearIfComposited();
6453 
6454     bool vertexAttrib0Simulated = false;
6455     if (!isGLES2Compliant()) {
6456         if (!numElements)
6457             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);
6458         auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
6459         if (!simulateVertexAttrib0Status) {
6460             // We were unable to simulate the attribute buffer.
6461             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);
6462             return;
6463         }
6464         vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
6465     }
6466     if (!isGLES2NPOTStrict())
6467         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, true);
6468 
6469 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
6470     if (isWebGL2())
6471         m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
6472 #endif
6473 
6474     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset), primcount);
6475 
6476     if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
6477         restoreStatesAfterVertexAttrib0Simulation();
6478     if (!isGLES2NPOTStrict())
6479         checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
6480     markContextChangedAndNotifyCanvasObserver();
6481 }
6482 
6483 void WebGLRenderingContextBase::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)
6484 {
6485     if (isContextLostOrPending())
6486         return;
6487 
6488     if (index &gt;= m_maxVertexAttribs) {
6489         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);
6490         return;
6491     }
6492 
6493     m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
6494     m_context-&gt;vertexAttribDivisor(index, divisor);
6495 }
6496 
6497 bool WebGLRenderingContextBase::enableSupportedExtension(ASCIILiteral extensionNameLiteral)
6498 {
6499     ASSERT(m_context);
6500     auto&amp; extensions = m_context-&gt;getExtensions();
6501     String extensionName { extensionNameLiteral };
6502     if (!extensions.supports(extensionName))
6503         return false;
6504     extensions.ensureEnabled(extensionName);
6505     return true;
6506 }
6507 
6508 void WebGLRenderingContextBase::activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState)
6509 {
6510     if (!m_context)
6511         return;
6512 
6513     auto changed = oldActivityState ^ newActivityState;
6514     if (changed &amp; ActivityState::IsVisible)
6515         m_context-&gt;setContextVisibility(newActivityState.contains(ActivityState::IsVisible));
6516 }
6517 
6518 void WebGLRenderingContextBase::setFailNextGPUStatusCheck()
6519 {
6520     if (!m_context)
6521         return;
6522 
6523     m_context-&gt;setFailNextGPUStatusCheck();
6524 }
6525 
<a name="46" id="anc46"></a><span class="line-added">6526 void WebGLRenderingContextBase::didComposite()</span>
<span class="line-added">6527 {</span>
<span class="line-added">6528     if (UNLIKELY(callTracingActive()))</span>
<span class="line-added">6529         InspectorInstrumentation::didFinishRecordingCanvasFrame(*this);</span>
<span class="line-added">6530 }</span>
<span class="line-added">6531 </span>
<span class="line-added">6532 void WebGLRenderingContextBase::forceContextLost()</span>
<span class="line-added">6533 {</span>
<span class="line-added">6534     forceLostContext(WebGLRenderingContextBase::RealLostContext);</span>
<span class="line-added">6535 }</span>
<span class="line-added">6536 </span>
<span class="line-added">6537 void WebGLRenderingContextBase::recycleContext()</span>
<span class="line-added">6538 {</span>
<span class="line-added">6539     printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);</span>
<span class="line-added">6540     // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration</span>
<span class="line-added">6541     // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.</span>
<span class="line-added">6542     forceLostContext(SyntheticLostContext);</span>
<span class="line-added">6543     destroyGraphicsContext3D();</span>
<span class="line-added">6544 }</span>
<span class="line-added">6545 </span>
<span class="line-added">6546 void WebGLRenderingContextBase::dispatchContextChangedNotification()</span>
<span class="line-added">6547 {</span>
<span class="line-added">6548     auto* canvas = htmlCanvas();</span>
<span class="line-added">6549     if (!canvas)</span>
<span class="line-added">6550         return;</span>
<span class="line-added">6551 </span>
<span class="line-added">6552     canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));</span>
<span class="line-added">6553 }</span>
<span class="line-added">6554 </span>
<span class="line-added">6555 </span>
6556 } // namespace WebCore
6557 
6558 #endif // ENABLE(WEBGL)
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>