<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
  29 #include &quot;BytecodeCacheError.h&quot;
  30 #include &quot;BytecodeCacheVersion.h&quot;
  31 #include &quot;BytecodeLivenessAnalysis.h&quot;
  32 #include &quot;JSCInlines.h&quot;
  33 #include &quot;JSImmutableButterfly.h&quot;
  34 #include &quot;JSTemplateObjectDescriptor.h&quot;
  35 #include &quot;ScopedArgumentsTable.h&quot;
  36 #include &quot;SourceCodeKey.h&quot;
  37 #include &quot;SourceProvider.h&quot;
  38 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  39 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  40 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  41 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  42 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  43 #include &lt;wtf/FastMalloc.h&gt;
  44 #include &lt;wtf/Optional.h&gt;
  45 #include &lt;wtf/UUID.h&gt;
  46 #include &lt;wtf/text/AtomStringImpl.h&gt;
  47 
  48 namespace JSC {
  49 
  50 namespace Yarr {
  51 enum class Flags : uint8_t;
  52 }
  53 
  54 template &lt;typename T, typename = void&gt;
  55 struct SourceTypeImpl {
  56     using type = T;
  57 };
  58 
  59 template&lt;typename T&gt;
  60 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  61     using type = typename T::SourceType_;
  62 
  63 };
  64 
  65 template&lt;typename T&gt;
  66 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  67 
  68 class Encoder {
  69     WTF_MAKE_NONCOPYABLE(Encoder);
  70     WTF_FORBID_HEAP_ALLOCATION;
  71 
  72 public:
  73     class Allocation {
  74         friend class Encoder;
  75 
  76     public:
  77         uint8_t* buffer() const { return m_buffer; }
  78         ptrdiff_t offset() const { return m_offset; }
  79 
  80     private:
  81         Allocation(uint8_t* buffer, ptrdiff_t offset)
  82             : m_buffer(buffer)
  83             , m_offset(offset)
  84         {
  85         }
  86 
  87         uint8_t* m_buffer;
  88         ptrdiff_t m_offset;
  89     };
  90 
  91     Encoder(VM&amp; vm, FileSystem::PlatformFileHandle fd = FileSystem::invalidPlatformFileHandle)
  92         : m_vm(vm)
  93         , m_fd(fd)
  94         , m_baseOffset(0)
  95         , m_currentPage(nullptr)
  96     {
  97         allocateNewPage();
  98     }
  99 
 100     VM&amp; vm() { return m_vm; }
 101 
 102     Allocation malloc(unsigned size)
 103     {
 104         RELEASE_ASSERT(size);
 105         ptrdiff_t offset;
 106         if (m_currentPage-&gt;malloc(size, offset))
 107             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 108         allocateNewPage(size);
 109         return malloc(size);
 110     }
 111 
 112     template&lt;typename T, typename... Args&gt;
 113     T* malloc(Args&amp;&amp;... args)
 114     {
 115         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 116     }
 117 
 118     ptrdiff_t offsetOf(const void* address)
 119     {
 120         ptrdiff_t offset;
 121         ptrdiff_t baseOffset = 0;
 122         for (const auto&amp; page : m_pages) {
 123             if (page.getOffset(address, offset))
 124                 return baseOffset + offset;
 125             baseOffset += page.size();
 126         }
 127         RELEASE_ASSERT_NOT_REACHED();
 128         return 0;
 129     }
 130 
 131     void cachePtr(const void* ptr, ptrdiff_t offset)
 132     {
 133         m_ptrToOffsetMap.add(ptr, offset);
 134     }
 135 
 136     Optional&lt;ptrdiff_t&gt; cachedOffsetForPtr(const void* ptr)
 137     {
 138         auto it = m_ptrToOffsetMap.find(ptr);
 139         if (it == m_ptrToOffsetMap.end())
 140             return WTF::nullopt;
 141         return { it-&gt;value };
 142     }
 143 
 144     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 145     {
 146         m_leafExecutables.add(executable, offset);
 147     }
 148 
 149     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)
 150     {
 151         if (!m_currentPage)
 152             return nullptr;
 153         m_currentPage-&gt;alignEnd();
 154 
 155         if (FileSystem::isHandleValid(m_fd)) {
 156             return releaseMapped(error);
 157         }
 158 
 159         size_t size = m_baseOffset + m_currentPage-&gt;size();
 160         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 161         unsigned offset = 0;
 162         for (const auto&amp; page : m_pages) {
 163             memcpy(buffer.get() + offset, page.buffer(), page.size());
 164             offset += page.size();
 165         }
 166         RELEASE_ASSERT(offset == size);
 167         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));
 168     }
 169 
 170 private:
 171     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)
 172     {
 173         size_t size = m_baseOffset + m_currentPage-&gt;size();
 174         if (!FileSystem::truncateFile(m_fd, size)) {
 175             error = BytecodeCacheError::StandardError(errno);
 176             return nullptr;
 177         }
 178 
 179         for (const auto&amp; page : m_pages) {
 180             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());
 181             if (bytesWritten == -1) {
 182                 error = BytecodeCacheError::StandardError(errno);
 183                 return nullptr;
 184             }
 185 
 186             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {
 187                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());
 188                 return nullptr;
 189             }
 190         }
 191 
 192         bool success;
 193         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);
 194         if (!success) {
 195             error = BytecodeCacheError::StandardError(errno);
 196             return nullptr;
 197         }
 198 
 199         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));
 200     }
 201 
 202     class Page {
 203     public:
 204         Page(size_t size)
 205             : m_offset(0)
 206             , m_capacity(size)
 207         {
 208             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 209         }
 210 
 211         bool malloc(size_t size, ptrdiff_t&amp; result)
 212         {
 213             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
 214             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);
 215             size = roundUpToMultipleOf(alignment, size);
 216             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 217                 return false;
 218 
 219             result = offset;
 220             m_offset = offset + size;
 221             return true;
 222         }
 223 
 224         uint8_t* buffer() const { return m_buffer.get(); }
 225         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 226 
 227         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 228         {
 229             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 230             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 231                 result = addr - m_buffer.get();
 232                 return true;
 233             }
 234             return false;
 235         }
 236 
 237         void alignEnd()
 238         {
 239             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);
 240             if (size == m_offset)
 241                 return;
 242             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
 243             m_offset = size;
 244         }
 245 
 246     private:
 247         MallocPtr&lt;uint8_t&gt; m_buffer;
 248         ptrdiff_t m_offset;
 249         size_t m_capacity;
 250     };
 251 
 252     void allocateNewPage(size_t size = 0)
 253     {
 254         static size_t minPageSize = pageSize();
 255         if (m_currentPage) {
 256             m_currentPage-&gt;alignEnd();
 257             m_baseOffset += m_currentPage-&gt;size();
 258         }
 259         if (size &lt; minPageSize)
 260             size = minPageSize;
 261         else
 262             size = roundUpToMultipleOf(minPageSize, size);
 263         m_pages.append(Page { size });
 264         m_currentPage = &amp;m_pages.last();
 265     }
 266 
 267     VM&amp; m_vm;
 268     FileSystem::PlatformFileHandle m_fd;
 269     ptrdiff_t m_baseOffset;
 270     Page* m_currentPage;
 271     Vector&lt;Page&gt; m_pages;
 272     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
 273     LeafExecutableMap m_leafExecutables;
 274 };
 275 
 276 Decoder::Decoder(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)
 277     : m_vm(vm)
 278     , m_cachedBytecode(WTFMove(cachedBytecode))
 279     , m_provider(provider)
 280 {
 281 }
 282 
 283 Decoder::~Decoder()
 284 {
 285     for (auto&amp; finalizer : m_finalizers)
 286         finalizer();
 287 }
 288 
 289 Ref&lt;Decoder&gt; Decoder::create(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, RefPtr&lt;SourceProvider&gt; provider)
 290 {
 291     return adoptRef(*new Decoder(vm, WTFMove(cachedBytecode), WTFMove(provider)));
 292 }
 293 
 294 size_t Decoder::size() const
 295 {
 296     return m_cachedBytecode-&gt;size();
 297 }
 298 
 299 ptrdiff_t Decoder::offsetOf(const void* ptr)
 300 {
 301     const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);
 302     ASSERT(addr &gt;= m_cachedBytecode-&gt;data() &amp;&amp; addr &lt; m_cachedBytecode-&gt;data() + m_cachedBytecode-&gt;size());
 303     return addr - m_cachedBytecode-&gt;data();
 304 }
 305 
 306 void Decoder::cacheOffset(ptrdiff_t offset, void* ptr)
 307 {
 308     m_offsetToPtrMap.add(offset, ptr);
 309 }
 310 
 311 WTF::Optional&lt;void*&gt; Decoder::cachedPtrForOffset(ptrdiff_t offset)
 312 {
 313     auto it = m_offsetToPtrMap.find(offset);
 314     if (it == m_offsetToPtrMap.end())
 315         return WTF::nullopt;
 316     return { it-&gt;value };
 317 }
 318 
 319 const void* Decoder::ptrForOffsetFromBase(ptrdiff_t offset)
 320 {
 321     ASSERT(offset &gt; 0 &amp;&amp; static_cast&lt;size_t&gt;(offset) &lt; m_cachedBytecode-&gt;size());
 322     return m_cachedBytecode-&gt;data() + offset;
 323 }
 324 
 325 CompactVariableMap::Handle Decoder::handleForEnvironment(CompactVariableEnvironment* environment) const
 326 {
 327     auto it = m_environmentToHandleMap.find(environment);
 328     RELEASE_ASSERT(it != m_environmentToHandleMap.end());
 329     return it-&gt;value;
 330 }
 331 
 332 void Decoder::setHandleForEnvironment(CompactVariableEnvironment* environment, const CompactVariableMap::Handle&amp; handle)
 333 {
 334     auto addResult = m_environmentToHandleMap.add(environment, handle);
 335     RELEASE_ASSERT(addResult.isNewEntry);
 336 }
 337 
 338 void Decoder::addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 339 {
 340     m_cachedBytecode-&gt;leafExecutables().add(executable, offset);
 341 }
 342 
 343 template&lt;typename Functor&gt;
 344 void Decoder::addFinalizer(const Functor&amp; fn)
 345 {
 346     m_finalizers.append(fn);
 347 }
 348 
 349 RefPtr&lt;SourceProvider&gt; Decoder::provider() const
 350 {
 351     return m_provider;
 352 }
 353 
 354 template&lt;typename T&gt;
 355 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 356 {
 357     dst = src;
 358 }
 359 
 360 template&lt;typename T&gt;
 361 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 362 {
 363     dst.encode(encoder, src);
 364 }
 365 
 366 template&lt;typename T, typename... Args&gt;
 367 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 368 {
 369     dst = src;
 370 }
 371 
 372 template&lt;typename T, typename... Args&gt;
 373 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp; decoder, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args... args)
 374 {
 375     src.decode(decoder, dst, args...);
 376 }
 377 
 378 template&lt;typename T&gt;
 379 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, T&gt; decode(Decoder&amp;, T src)
 380 {
 381     return src;
 382 }
 383 
 384 template&lt;typename T&gt;
 385 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 386 {
 387     return src.decode(decoder);
 388 }
 389 
 390 template&lt;typename Source&gt;
 391 class CachedObject {
 392     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 393 
 394 public:
 395     using SourceType_ = Source;
 396 
 397     CachedObject() = default;
 398 
 399     inline void* operator new(size_t, void* where) { return where; }
 400     void* operator new[](size_t, void* where) { return where; }
 401 
 402     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
 403     void* operator new(size_t) = delete;
 404     void operator delete(void*) = delete;
 405     void* operator new[](size_t size) = delete;
 406     void operator delete[](void*) = delete;
 407     void* operator new(size_t, NotNullTag, void* location) = delete;
 408 };
 409 
 410 template&lt;typename Source&gt;
 411 class VariableLengthObject : public CachedObject&lt;Source&gt;, VariableLengthObjectBase {
 412     template&lt;typename, typename&gt;
 413     friend class CachedPtr;
 414     friend struct CachedPtrOffsets;
 415 
 416 public:
 417     VariableLengthObject()
 418         : VariableLengthObjectBase(s_invalidOffset)
 419     {
 420     }
 421 
 422     bool isEmpty() const
 423     {
 424         return m_offset == s_invalidOffset;
 425     }
 426 
 427 protected:
 428     const uint8_t* buffer() const
 429     {
 430         ASSERT(!isEmpty());
 431         return bitwise_cast&lt;const uint8_t*&gt;(this) + m_offset;
 432     }
 433 
 434     template&lt;typename T&gt;
 435     const T* buffer() const
 436     {
 437         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(buffer()) % alignof(T)));
 438         return bitwise_cast&lt;const T*&gt;(buffer());
 439     }
 440 
 441     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 442     {
 443         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 444         auto result = encoder.malloc(size);
 445         m_offset = result.offset() - offsetOffset;
 446         return result.buffer();
 447     }
 448 
 449     template&lt;typename T&gt;
 450 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)
 451     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:
 452     // &lt;rdar://problem/49792205&gt;
 453     __attribute__((optnone))
 454 #endif
 455     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 456     {
 457         uint8_t* result = allocate(encoder, sizeof(T) * size);
 458         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));
 459         return new (result) T[size];
 460     }
 461 
 462 private:
 463     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
 464 };
 465 
 466 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 467 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
 468     template&lt;typename, typename&gt;
 469     friend class CachedRefPtr;
 470 
 471     friend struct CachedPtrOffsets;
 472 
 473 public:
 474     void encode(Encoder&amp; encoder, const Source* src)
 475     {
 476         if (!src)
 477             return;
 478 
 479         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {
 480             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 481             return;
 482         }
 483 
 484         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 485         cachedObject-&gt;encode(encoder, *src);
 486         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 487     }
 488 
 489     template&lt;typename... Args&gt;
 490     Source* decode(Decoder&amp; decoder, bool&amp; isNewAllocation, Args&amp;&amp;... args) const
 491     {
 492         if (this-&gt;isEmpty()) {
 493             isNewAllocation = false;
 494             return nullptr;
 495         }
 496 
 497         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
 498         if (Optional&lt;void*&gt; ptr = decoder.cachedPtrForOffset(bufferOffset)) {
 499             isNewAllocation = false;
 500             return static_cast&lt;Source*&gt;(*ptr);
 501         }
 502 
 503         isNewAllocation = true;
 504         Source* ptr = get()-&gt;decode(decoder, std::forward&lt;Args&gt;(args)...);
 505         decoder.cacheOffset(bufferOffset, ptr);
 506         return ptr;
 507     }
 508 
 509     template&lt;typename... Args&gt;
 510     Source* decode(Decoder&amp; decoder, Args&amp;&amp;... args) const
 511     {
 512         bool unusedIsNewAllocation;
 513         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);
 514     }
 515 
 516     const T* operator-&gt;() const { return get(); }
 517 
 518 private:
 519     const T* get() const
 520     {
 521         RELEASE_ASSERT(!this-&gt;isEmpty());
 522         return this-&gt;template buffer&lt;T&gt;();
 523     }
 524 };
 525 
 526 ptrdiff_t CachedPtrOffsets::offsetOffset()
 527 {
 528     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
 529 }
 530 
 531 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 532 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
 533 public:
 534     void encode(Encoder&amp; encoder, const Source* src)
 535     {
 536         m_ptr.encode(encoder, src);
 537     }
 538 
 539     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)
 540     {
 541         encode(encoder, src.get());
 542     }
 543 
 544     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
 545     {
 546         bool isNewAllocation;
 547         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
 548         if (!decodedPtr)
 549             return nullptr;
 550         if (isNewAllocation) {
 551             decoder.addFinalizer([=] {
 552                 derefIfNotNull(decodedPtr);
 553             });
 554         }
 555         refIfNotNull(decodedPtr);
 556         return adoptRef(decodedPtr);
 557     }
 558 
 559     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
 560     {
 561         src = decode(decoder);
 562     }
 563 
 564 private:
 565     CachedPtr&lt;T, Source&gt; m_ptr;
 566 };
 567 
 568 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 569 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
 570     friend struct CachedWriteBarrierOffsets;
 571 
 572 public:
 573     bool isEmpty() const { return m_ptr.isEmpty(); }
 574 
 575     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 576     {
 577         m_ptr.encode(encoder, src.get());
 578     }
 579 
 580     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 581     {
 582         Source* decodedPtr = m_ptr.decode(decoder);
 583         if (decodedPtr)
 584             src.set(decoder.vm(), owner, decodedPtr);
 585     }
 586 
 587 private:
 588     CachedPtr&lt;T, Source&gt; m_ptr;
 589 };
 590 
 591 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
 592 {
 593     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
 594 }
 595 
 596 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
 597 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
 598 public:
 599     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
 600     {
 601         m_size = vector.size();
 602         if (!m_size)
 603             return;
 604         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 605         for (unsigned i = 0; i &lt; m_size; ++i)
 606             ::JSC::encode(encoder, buffer[i], vector[i]);
 607     }
 608 
 609     template&lt;typename... Args&gt;
 610     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const
 611     {
 612         if (!m_size)
 613             return;
 614         vector.resizeToFit(m_size);
 615         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 616         for (unsigned i = 0; i &lt; m_size; ++i)
 617             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 618     }
 619 
 620 private:
 621     unsigned m_size;
 622 };
 623 
 624 template&lt;typename First, typename Second&gt;
 625 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 626 public:
 627     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 628     {
 629         ::JSC::encode(encoder, m_first, pair.first);
 630         ::JSC::encode(encoder, m_second, pair.second);
 631     }
 632 
 633     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 634     {
 635         ::JSC::decode(decoder, m_first, pair.first);
 636         ::JSC::decode(decoder, m_second, pair.second);
 637     }
 638 
 639 private:
 640     First m_first;
 641     Second m_second;
 642 };
 643 
 644 template&lt;typename Key, typename Value, typename HashArg = typename DefaultHash&lt;SourceType&lt;Key&gt;&gt;::Hash, typename KeyTraitsArg = HashTraits&lt;SourceType&lt;Key&gt;&gt;, typename MappedTraitsArg = HashTraits&lt;SourceType&lt;Value&gt;&gt;&gt;
 645 class CachedHashMap : public VariableLengthObject&lt;HashMap&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&gt; {
 646     template&lt;typename K, typename V&gt;
 647     using Map = HashMap&lt;K, V, HashArg, KeyTraitsArg, MappedTraitsArg&gt;;
 648 
 649 public:
 650     void encode(Encoder&amp; encoder, const Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map)
 651     {
 652         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 653         unsigned i = 0;
 654         for (const auto&amp; it : map)
 655             entriesVector[i++] = { it.key, it.value };
 656         m_entries.encode(encoder, entriesVector);
 657     }
 658 
 659     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 660     {
 661         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 662         m_entries.decode(decoder, decodedEntries);
 663         for (const auto&amp; pair : decodedEntries)
 664             map.set(pair.first, pair.second);
 665     }
 666 
 667 private:
 668     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 669 };
 670 
 671 template&lt;typename T&gt;
 672 class CachedUniquedStringImplBase : public VariableLengthObject&lt;T&gt; {
 673 public:
 674     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 675     {
 676         m_isAtomic = string.isAtom();
 677         m_isSymbol = string.isSymbol();
 678         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 679 
 680         if (m_isSymbol) {
 681             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 682             if (!symbol-&gt;isNullSymbol()) {
 683                 // We have special handling for well-known symbols.
 684                 if (!symbol-&gt;isPrivate())
 685                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 686             }
 687         }
 688 
 689         m_is8Bit = impl-&gt;is8Bit();
 690         m_length = impl-&gt;length();
 691 
 692         if (!m_length)
 693             return;
 694 
 695         unsigned size = m_length;
 696         const void* payload;
 697         if (m_is8Bit)
 698             payload = impl-&gt;characters8();
 699         else {
 700             payload = impl-&gt;characters16();
 701             size *= 2;
 702         }
 703 
 704         uint8_t* buffer = this-&gt;allocate(encoder, size);
 705         memcpy(buffer, payload, size);
 706     }
 707 
 708     UniquedStringImpl* decode(Decoder&amp; decoder) const
 709     {
 710         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 711             if (!m_isSymbol)
 712                 return AtomStringImpl::add(buffer, m_length).leakRef();
 713 
 714             Identifier ident = Identifier::fromString(decoder.vm(), buffer, m_length);
 715             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 716             StringImpl* impl = str.releaseImpl().get();
 717             ASSERT(impl-&gt;isSymbol());
 718             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 719         };
 720 
 721         if (!m_length) {
 722             if (m_isSymbol)
 723                 return &amp;SymbolImpl::createNullSymbol().leakRef();
 724             return AtomStringImpl::add(&quot;&quot;).leakRef();
 725         }
 726 
 727         if (m_is8Bit)
 728             return create(this-&gt;template buffer&lt;LChar&gt;());
 729         return create(this-&gt;template buffer&lt;UChar&gt;());
 730     }
 731 
 732 private:
 733     bool m_is8Bit : 1;
 734     bool m_isSymbol : 1;
 735     bool m_isAtomic : 1;
 736     unsigned m_length;
 737 };
 738 
 739 class CachedUniquedStringImpl : public CachedUniquedStringImplBase&lt;UniquedStringImpl&gt; { };
 740 class CachedStringImpl : public CachedUniquedStringImplBase&lt;StringImpl&gt; { };
 741 
 742 class CachedString : public VariableLengthObject&lt;String&gt; {
 743 public:
 744     void encode(Encoder&amp; encoder, const String&amp; string)
 745     {
 746         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 747     }
 748 
 749     String decode(Decoder&amp; decoder) const
 750     {
 751         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 752     }
 753 
 754     void decode(Decoder&amp; decoder, String&amp; dst) const
 755     {
 756         dst = decode(decoder);
 757     }
 758 
 759 private:
 760     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 761 };
 762 
 763 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 764 public:
 765     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 766     {
 767         m_string.encode(encoder, identifier.string());
 768     }
 769 
 770     Identifier decode(Decoder&amp; decoder) const
 771     {
 772         String str = m_string.decode(decoder);
 773         if (str.isNull())
 774             return Identifier();
 775 
 776         return Identifier::fromUid(decoder.vm(), (UniquedStringImpl*)str.impl());
 777     }
 778 
 779     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 780     {
 781         ident = decode(decoder);
 782     }
 783 
 784 private:
 785     CachedString m_string;
 786 };
 787 
 788 template&lt;typename T&gt;
 789 class CachedOptional : public VariableLengthObject&lt;Optional&lt;SourceType&lt;T&gt;&gt;&gt; {
 790 public:
 791     void encode(Encoder&amp; encoder, const Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)
 792     {
 793         if (!source)
 794             return;
 795 
 796         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 797     }
 798 
 799     Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const
 800     {
 801         if (this-&gt;isEmpty())
 802             return WTF::nullopt;
 803 
 804         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 805     }
 806 
 807     void decode(Decoder&amp; decoder, Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const
 808     {
 809         dst = decode(decoder);
 810     }
 811 
 812     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 813     {
 814         if (!source)
 815             encode(encoder, WTF::nullopt);
 816         else
 817             encode(encoder, { *source });
 818     }
 819 };
 820 
 821 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 822 public:
 823     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 824     {
 825         m_min = jumpTable.min;
 826         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 827     }
 828 
 829     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 830     {
 831         jumpTable.min = m_min;
 832         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 833     }
 834 
 835 private:
 836     int32_t m_min;
 837     CachedVector&lt;int32_t&gt; m_branchOffsets;
 838 };
 839 
 840 class CachedStringJumpTable : public CachedObject&lt;UnlinkedStringJumpTable&gt; {
 841 public:
 842     void encode(Encoder&amp; encoder, const UnlinkedStringJumpTable&amp; jumpTable)
 843     {
 844         m_offsetTable.encode(encoder, jumpTable.offsetTable);
 845     }
 846 
 847     void decode(Decoder&amp; decoder, UnlinkedStringJumpTable&amp; jumpTable) const
 848     {
 849         m_offsetTable.decode(decoder, jumpTable.offsetTable);
 850     }
 851 
 852 private:
 853     CachedHashMap&lt;CachedRefPtr&lt;CachedStringImpl&gt;, UnlinkedStringJumpTable:: OffsetLocation&gt; m_offsetTable;
 854 };
 855 
 856 class CachedBitVector : public VariableLengthObject&lt;BitVector&gt; {
 857 public:
 858     void encode(Encoder&amp; encoder, const BitVector&amp; bitVector)
 859     {
 860         m_numBits = bitVector.size();
 861         if (!m_numBits)
 862             return;
 863         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 864         uint8_t* buffer = this-&gt;allocate(encoder, sizeInBytes);
 865         memcpy(buffer, bitVector.bits(), sizeInBytes);
 866     }
 867 
 868     void decode(Decoder&amp;, BitVector&amp; bitVector) const
 869     {
 870         if (!m_numBits)
 871             return;
 872         bitVector.ensureSize(m_numBits);
 873         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 874         memcpy(bitVector.bits(), this-&gt;buffer(), sizeInBytes);
 875     }
 876 
 877 private:
 878     size_t m_numBits;
 879 };
 880 
 881 template&lt;typename T, typename HashArg = typename DefaultHash&lt;T&gt;::Hash&gt;
 882 class CachedHashSet : public CachedObject&lt;HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&gt; {
 883 public:
 884     void encode(Encoder&amp; encoder, const HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set)
 885     {
 886         SourceType&lt;decltype(m_entries)&gt; entriesVector(set.size());
 887         unsigned i = 0;
 888         for (const auto&amp; item : set)
 889             entriesVector[i++] = item;
 890         m_entries.encode(encoder, entriesVector);
 891     }
 892 
 893     void decode(Decoder&amp; decoder, HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set) const
 894     {
 895         SourceType&lt;decltype(m_entries)&gt; entriesVector;
 896         m_entries.decode(decoder, entriesVector);
 897         for (const auto&amp; item : entriesVector)
 898             set.add(item);
 899     }
 900 
 901 private:
 902     CachedVector&lt;T&gt; m_entries;
 903 };
 904 
 905 class CachedConstantIdentifierSetEntry : public VariableLengthObject&lt;ConstantIdentifierSetEntry&gt; {
 906 public:
 907     void encode(Encoder&amp; encoder, const ConstantIdentifierSetEntry&amp; entry)
 908     {
 909         m_constant = entry.second;
 910         m_set.encode(encoder, entry.first);
 911     }
 912 
 913     void decode(Decoder&amp; decoder, ConstantIdentifierSetEntry&amp; entry) const
 914     {
 915         entry.second = m_constant;
 916         m_set.decode(decoder, entry.first);
 917     }
 918 
 919 private:
 920     unsigned m_constant;
 921     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 922 };
 923 
 924 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 925 public:
 926     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 927     {
 928         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 929         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 930         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 931         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 932         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 933         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 934         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 935         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
 936     }
 937 
 938     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 939     {
 940         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 941         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 942         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 943         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 944         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 945         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 946         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 947         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 948         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
 949         return rareData;
 950     }
 951 
 952 private:
 953     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 954     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 955     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 956     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 957     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 958     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 959     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 960     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
 961 };
 962 
 963 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 964 public:
 965     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 966     {
 967         m_isEverythingCaptured = env.m_isEverythingCaptured;
 968         m_map.encode(encoder, env.m_map);
 969     }
 970 
 971     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 972     {
 973         env.m_isEverythingCaptured = m_isEverythingCaptured;
 974         m_map.decode(decoder, env.m_map);
 975     }
 976 
 977 private:
 978     bool m_isEverythingCaptured;
 979     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
 980 };
 981 
 982 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
 983 public:
 984     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
 985     {
 986         m_variables.encode(encoder, env.m_variables);
 987         m_variableMetadata.encode(encoder, env.m_variableMetadata);
 988         m_hash = env.m_hash;
 989         m_isEverythingCaptured = env.m_isEverythingCaptured;
 990     }
 991 
 992     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const
 993     {
 994         m_variables.decode(decoder, env.m_variables);
 995         m_variableMetadata.decode(decoder, env.m_variableMetadata);
 996         env.m_hash = m_hash;
 997         env.m_isEverythingCaptured = m_isEverythingCaptured;
 998     }
 999 
1000     CompactVariableEnvironment* decode(Decoder&amp; decoder) const
1001     {
1002         CompactVariableEnvironment* env = new CompactVariableEnvironment;
1003         decode(decoder, *env);
1004         return env;
1005     }
1006 
1007 private:
1008     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;
1009     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
1010     unsigned m_hash;
1011     bool m_isEverythingCaptured;
1012 };
1013 
1014 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {
1015 public:
1016     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)
1017     {
1018         m_environment.encode(encoder, handle.m_environment);
1019     }
1020 
1021     CompactVariableMap::Handle decode(Decoder&amp; decoder) const
1022     {
1023         bool isNewAllocation;
1024         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);
1025         if (!environment) {
1026             ASSERT(!isNewAllocation);
1027             return CompactVariableMap::Handle();
1028         }
1029 
1030         if (!isNewAllocation)
1031             return decoder.handleForEnvironment(environment);
1032         bool isNewEntry;
1033         CompactVariableMap::Handle handle = decoder.vm().m_compactVariableMap-&gt;get(environment, isNewEntry);
1034         if (!isNewEntry) {
1035             decoder.addFinalizer([=] {
1036                 delete environment;
1037             });
1038         }
1039         decoder.setHandleForEnvironment(environment, handle);
1040         return handle;
1041     }
1042 
1043 private:
1044     CachedPtr&lt;CachedCompactVariableEnvironment&gt; m_environment;
1045 };
1046 
1047 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
1048 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
1049 public:
1050     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
1051     {
1052         if (!size)
1053             return;
1054         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
1055         for (unsigned i = 0; i &lt; size; ++i)
1056             ::JSC::encode(encoder, dst[i], array[i]);
1057     }
1058 
1059     template&lt;typename... Args&gt;
1060     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
1061     {
1062         if (!size)
1063             return;
1064         const T* buffer = this-&gt;template buffer&lt;T&gt;();
1065         for (unsigned i = 0; i &lt; size; ++i)
1066             ::JSC::decode(decoder, buffer[i], array[i], args...);
1067     }
1068 };
1069 
1070 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
1071 public:
1072     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
1073     {
1074         m_length = scopedArgumentsTable.m_length;
1075         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(m_length), m_length);
1076     }
1077 
1078     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
1079     {
1080         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
1081         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(m_length), m_length);
1082         return scopedArgumentsTable;
1083     }
1084 
1085 private:
1086     uint32_t m_length;
1087     CachedArray&lt;ScopeOffset&gt; m_arguments;
1088 };
1089 
1090 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
1091 public:
1092     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
1093     {
1094         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
1095     }
1096 
1097     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
1098     {
1099         symbolTableEntry.m_bits = m_bits;
1100     }
1101 
1102 private:
1103     intptr_t m_bits;
1104 };
1105 
1106 class CachedSymbolTable : public CachedObject&lt;SymbolTable&gt; {
1107 public:
1108     void encode(Encoder&amp; encoder, const SymbolTable&amp; symbolTable)
1109     {
1110         m_map.encode(encoder, symbolTable.m_map);
1111         m_maxScopeOffset = symbolTable.m_maxScopeOffset;
1112         m_usesNonStrictEval = symbolTable.m_usesNonStrictEval;
1113         m_nestedLexicalScope = symbolTable.m_nestedLexicalScope;
1114         m_scopeType = symbolTable.m_scopeType;
1115         m_arguments.encode(encoder, symbolTable.m_arguments.get());
1116     }
1117 
1118     SymbolTable* decode(Decoder&amp; decoder) const
1119     {
1120         SymbolTable* symbolTable = SymbolTable::create(decoder.vm());
1121         m_map.decode(decoder, symbolTable-&gt;m_map);
1122         symbolTable-&gt;m_maxScopeOffset = m_maxScopeOffset;
1123         symbolTable-&gt;m_usesNonStrictEval = m_usesNonStrictEval;
1124         symbolTable-&gt;m_nestedLexicalScope = m_nestedLexicalScope;
1125         symbolTable-&gt;m_scopeType = m_scopeType;
1126         ScopedArgumentsTable* scopedArgumentsTable = m_arguments.decode(decoder);
1127         if (scopedArgumentsTable)
1128             symbolTable-&gt;m_arguments.set(decoder.vm(), symbolTable, scopedArgumentsTable);
1129         return symbolTable;
1130     }
1131 
1132 private:
1133     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, CachedSymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; m_map;
1134     ScopeOffset m_maxScopeOffset;
1135     unsigned m_usesNonStrictEval : 1;
1136     unsigned m_nestedLexicalScope : 1;
1137     unsigned m_scopeType : 3;
1138     CachedPtr&lt;CachedScopedArgumentsTable&gt; m_arguments;
1139 };
1140 
1141 class CachedJSValue;
1142 class CachedImmutableButterfly : public CachedObject&lt;JSImmutableButterfly&gt; {
1143 public:
1144     CachedImmutableButterfly()
1145         : m_cachedDoubles()
1146     {
1147     }
1148 
1149     void encode(Encoder&amp; encoder, JSImmutableButterfly&amp; immutableButterfly)
1150     {
1151         m_length = immutableButterfly.length();
1152         m_indexingType = immutableButterfly.indexingTypeAndMisc();
1153         if (hasDouble(m_indexingType))
1154             m_cachedDoubles.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguousDouble().data(), m_length);
1155         else
1156             m_cachedValues.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguous().data(), m_length);
1157     }
1158 
1159     JSImmutableButterfly* decode(Decoder&amp; decoder) const
1160     {
1161         JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::create(decoder.vm(), m_indexingType, m_length);
1162         if (hasDouble(m_indexingType))
1163             m_cachedDoubles.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguousDouble().data(), m_length, immutableButterfly);
1164         else
1165             m_cachedValues.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguous().data(), m_length, immutableButterfly);
1166         return immutableButterfly;
1167     }
1168 
1169 private:
1170     IndexingType m_indexingType;
1171     unsigned m_length;
1172     union {
1173         CachedArray&lt;double&gt; m_cachedDoubles;
1174         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1175     };
1176 };
1177 
1178 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1179 public:
1180     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1181     {
1182         m_patternString.encode(encoder, regExp.m_patternString);
1183         m_flags = regExp.m_flags;
1184     }
1185 
1186     RegExp* decode(Decoder&amp; decoder) const
1187     {
1188         String pattern { m_patternString.decode(decoder) };
1189         return RegExp::create(decoder.vm(), pattern, m_flags);
1190     }
1191 
1192 private:
1193     CachedString m_patternString;
1194     OptionSet&lt;Yarr::Flags&gt; m_flags;
1195 };
1196 
1197 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1198 public:
1199     void encode(Encoder&amp; encoder, const JSTemplateObjectDescriptor&amp; descriptor)
1200     {
1201         m_rawStrings.encode(encoder, descriptor.descriptor().rawStrings());
1202         m_cookedStrings.encode(encoder, descriptor.descriptor().cookedStrings());
1203         m_endOffset = descriptor.endOffset();
1204     }
1205 
1206     JSTemplateObjectDescriptor* decode(Decoder&amp; decoder) const
1207     {
1208         TemplateObjectDescriptor::StringVector decodedRawStrings;
1209         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1210         m_rawStrings.decode(decoder, decodedRawStrings);
1211         m_cookedStrings.decode(decoder, decodedCookedStrings);
1212         return JSTemplateObjectDescriptor::create(decoder.vm(), TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings)), m_endOffset);
1213     }
1214 
1215 private:
1216     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1217     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
1218     int m_endOffset;
1219 };
1220 
1221 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1222 public:
1223     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1224     {
1225         m_length = bigInt.length();
1226         m_sign = bigInt.sign();
1227 
1228         if (!m_length)
1229             return;
1230 
1231         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1232         uint8_t* buffer = this-&gt;allocate(encoder, size);
1233         memcpy(buffer, bigInt.dataStorage(), size);
1234     }
1235 
1236     JSBigInt* decode(Decoder&amp; decoder) const
1237     {
1238         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
1239         bigInt-&gt;setSign(m_sign);
1240         if (m_length)
1241             memcpy(bigInt-&gt;dataStorage(), this-&gt;buffer(), sizeof(JSBigInt::Digit) * m_length);
1242         return bigInt;
1243     }
1244 
1245 private:
1246     unsigned m_length;
1247     bool m_sign;
1248 };
1249 
1250 class CachedJSValue : public VariableLengthObject&lt;WriteBarrier&lt;Unknown&gt;&gt; {
1251 public:
1252     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Unknown&gt; value)
1253     {
1254         JSValue v = value.get();
1255 
1256         if (!v.isCell() || v.isEmpty()) {
1257             m_type = EncodedType::JSValue;
1258             *this-&gt;allocate&lt;EncodedJSValue&gt;(encoder) = JSValue::encode(v);
1259             return;
1260         }
1261 
1262         JSCell* cell = v.asCell();
1263         VM&amp; vm = encoder.vm();
1264 
1265         if (auto* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {
1266             m_type = EncodedType::SymbolTable;
1267             this-&gt;allocate&lt;CachedSymbolTable&gt;(encoder)-&gt;encode(encoder, *symbolTable);
1268             return;
1269         }
1270 
1271         if (auto* string = jsDynamicCast&lt;JSString*&gt;(vm, cell)) {
1272             m_type = EncodedType::String;
1273             StringImpl* impl = string-&gt;tryGetValue().impl();
1274             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1275             return;
1276         }
1277 
1278         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1279             m_type = EncodedType::ImmutableButterfly;
1280             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1281             return;
1282         }
1283 
1284         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1285             m_type = EncodedType::RegExp;
1286             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1287             return;
1288         }
1289 
1290         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1291             m_type = EncodedType::TemplateObjectDescriptor;
1292             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, *templateObjectDescriptor);
1293             return;
1294         }
1295 
1296         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1297             m_type = EncodedType::BigInt;
1298             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1299             return;
1300         }
1301 
1302         RELEASE_ASSERT_NOT_REACHED();
1303     }
1304 
1305     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1306     {
1307         JSValue v;
1308         switch (m_type) {
1309         case EncodedType::JSValue:
1310             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1311             break;
1312         case EncodedType::SymbolTable:
1313             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1314             break;
1315         case EncodedType::String: {
1316             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
1317             v = jsString(decoder.vm(), adoptRef(*impl));
1318             break;
1319         }
1320         case EncodedType::ImmutableButterfly:
1321             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1322             break;
1323         case EncodedType::RegExp:
1324             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1325             break;
1326         case EncodedType::TemplateObjectDescriptor:
1327             v = this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder);
1328             break;
1329         case EncodedType::BigInt:
1330             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1331             break;
1332         default:
1333             RELEASE_ASSERT_NOT_REACHED();
1334         }
1335         value.set(decoder.vm(), owner, v);
1336     }
1337 
1338 private:
1339     enum class EncodedType : uint8_t {
1340         JSValue,
1341         SymbolTable,
1342         String,
1343         ImmutableButterfly,
1344         RegExp,
1345         TemplateObjectDescriptor,
1346         BigInt,
1347     };
1348 
1349     EncodedType m_type;
1350 };
1351 
1352 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1353 public:
1354     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1355     {
1356         m_instructions.encode(encoder, stream.m_instructions);
1357     }
1358 
1359     InstructionStream* decode(Decoder&amp; decoder) const
1360     {
1361         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;
1362         m_instructions.decode(decoder, instructionsVector);
1363         return new InstructionStream(WTFMove(instructionsVector));
1364     }
1365 
1366 private:
1367     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;
1368 };
1369 
1370 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1371 public:
1372     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1373     {
1374         ASSERT(metadataTable.m_isFinalized);
1375         m_hasMetadata = metadataTable.m_hasMetadata;
1376         if (!m_hasMetadata)
1377             return;
1378         m_is32Bit = metadataTable.m_is32Bit;
1379         if (m_is32Bit) {
1380             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1381                 m_metadata[i] = metadataTable.offsetTable32()[i];
1382         } else {
1383             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1384                 m_metadata[i] = metadataTable.offsetTable16()[i];
1385         }
1386     }
1387 
1388     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1389     {
1390         if (!m_hasMetadata)
1391             return UnlinkedMetadataTable::empty();
1392 
1393         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create(m_is32Bit);
1394         metadataTable-&gt;m_isFinalized = true;
1395         metadataTable-&gt;m_isLinked = false;
1396         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
1397         if (m_is32Bit) {
1398             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1399                 metadataTable-&gt;offsetTable32()[i] = m_metadata[i];
1400         } else {
1401             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1402                 metadataTable-&gt;offsetTable16()[i] = m_metadata[i];
1403         }
1404         return metadataTable;
1405     }
1406 
1407 private:
1408     bool m_hasMetadata;
1409     bool m_is32Bit;
1410     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1411 };
1412 
1413 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1414 public:
1415     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1416     {
1417         m_string.encode(encoder, sourceOrigin.string());
1418     }
1419 
1420     SourceOrigin decode(Decoder&amp; decoder) const
1421     {
1422         return SourceOrigin { m_string.decode(decoder) };
1423     }
1424 
1425 private:
1426     CachedString m_string;
1427 };
1428 
1429 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
1430 public:
1431     void encode(Encoder&amp;, TextPosition textPosition)
1432     {
1433         m_line = textPosition.m_line.zeroBasedInt();
1434         m_column = textPosition.m_column.zeroBasedInt();
1435     }
1436 
1437     TextPosition decode(Decoder&amp;) const
1438     {
1439         return TextPosition { OrdinalNumber::fromZeroBasedInt(m_line), OrdinalNumber::fromZeroBasedInt(m_column) };
1440     }
1441 
1442 private:
1443     int m_line;
1444     int m_column;
1445 };
1446 
1447 template &lt;typename Source, typename CachedType&gt;
1448 class CachedSourceProviderShape : public CachedObject&lt;Source&gt; {
1449 public:
1450     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1451     {
1452         m_sourceOrigin.encode(encoder, sourceProvider.sourceOrigin());
1453         m_url.encode(encoder, sourceProvider.url());
1454         m_sourceURLDirective.encode(encoder, sourceProvider.sourceURLDirective());
1455         m_sourceMappingURLDirective.encode(encoder, sourceProvider.sourceMappingURLDirective());
1456         m_startPosition.encode(encoder, sourceProvider.startPosition());
1457     }
1458 
1459     void decode(Decoder&amp; decoder, SourceProvider&amp; sourceProvider) const
1460     {
1461         sourceProvider.setSourceURLDirective(m_sourceURLDirective.decode(decoder));
1462         sourceProvider.setSourceMappingURLDirective(m_sourceMappingURLDirective.decode(decoder));
1463     }
1464 
1465 protected:
1466     CachedSourceOrigin m_sourceOrigin;
1467     CachedString m_url;
1468     CachedString m_sourceURLDirective;
1469     CachedString m_sourceMappingURLDirective;
1470     CachedTextPosition m_startPosition;
1471 };
1472 
1473 class CachedStringSourceProvider : public CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt; {
1474     using Base = CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt;;
1475 
1476 public:
1477     void encode(Encoder&amp; encoder, const StringSourceProvider&amp; sourceProvider)
1478     {
1479         Base::encode(encoder, sourceProvider);
1480         m_source.encode(encoder, sourceProvider.source().toString());
1481     }
1482 
1483     StringSourceProvider* decode(Decoder&amp; decoder, SourceProviderSourceType sourceType) const
1484     {
1485         String decodedSource = m_source.decode(decoder);
1486         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1487         String decodedURL = m_url.decode(decoder);
1488         TextPosition decodedStartPosition = m_startPosition.decode(decoder);
1489 
1490         Ref&lt;StringSourceProvider&gt; sourceProvider = StringSourceProvider::create(decodedSource, decodedSourceOrigin, URL(URL(), decodedURL), decodedStartPosition, sourceType);
1491         Base::decode(decoder, sourceProvider.get());
1492         return &amp;sourceProvider.leakRef();
1493     }
1494 
1495 private:
1496     CachedString m_source;
1497 };
1498 
1499 #if ENABLE(WEBASSEMBLY)
1500 class CachedWebAssemblySourceProvider : public CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt; {
1501     using Base = CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt;;
1502 
1503 public:
1504     void encode(Encoder&amp; encoder, const WebAssemblySourceProvider&amp; sourceProvider)
1505     {
1506         Base::encode(encoder, sourceProvider);
1507         m_data.encode(encoder, sourceProvider.data());
1508     }
1509 
1510     WebAssemblySourceProvider* decode(Decoder&amp; decoder) const
1511     {
1512         Vector&lt;uint8_t&gt; decodedData;
1513         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1514         String decodedURL = m_url.decode(decoder);
1515 
1516         m_data.decode(decoder, decodedData);
1517 
1518         Ref&lt;WebAssemblySourceProvider&gt; sourceProvider = WebAssemblySourceProvider::create(WTFMove(decodedData), decodedSourceOrigin, URL(URL(), decodedURL));
1519         Base::decode(decoder, sourceProvider.get());
1520 
1521         return &amp;sourceProvider.leakRef();
1522     }
1523 
1524 private:
1525     CachedVector&lt;uint8_t&gt; m_data;
1526 };
1527 #endif
1528 
1529 class CachedSourceProvider : public VariableLengthObject&lt;SourceProvider&gt; {
1530 public:
1531     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1532     {
1533         m_sourceType = sourceProvider.sourceType();
1534         switch (m_sourceType) {
1535         case SourceProviderSourceType::Program:
1536         case SourceProviderSourceType::Module:
1537             this-&gt;allocate&lt;CachedStringSourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const StringSourceProvider&amp;&gt;(sourceProvider));
1538             break;
1539 #if ENABLE(WEBASSEMBLY)
1540         case SourceProviderSourceType::WebAssembly:
1541             this-&gt;allocate&lt;CachedWebAssemblySourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const WebAssemblySourceProvider&amp;&gt;(sourceProvider));
1542             break;
1543 #endif
1544         default:
1545             RELEASE_ASSERT_NOT_REACHED();
1546         }
1547     }
1548 
1549     SourceProvider* decode(Decoder&amp; decoder) const
1550     {
1551         switch (m_sourceType) {
1552         case SourceProviderSourceType::Program:
1553         case SourceProviderSourceType::Module:
1554             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1555 #if ENABLE(WEBASSEMBLY)
1556         case SourceProviderSourceType::WebAssembly:
1557             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1558 #endif
1559         default:
1560             RELEASE_ASSERT_NOT_REACHED();
1561         }
1562     }
1563 
1564 private:
1565     SourceProviderSourceType m_sourceType;
1566 };
1567 
1568 template&lt;typename Source&gt;
1569 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1570 public:
1571     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1572     {
1573         m_provider.encode(encoder, sourceCode.m_provider);
1574         m_startOffset = sourceCode.startOffset();
1575         m_endOffset = sourceCode.endOffset();
1576     }
1577 
1578     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1579     {
1580         sourceCode.m_provider = m_provider.decode(decoder);
1581         sourceCode.m_startOffset = m_startOffset;
1582         sourceCode.m_endOffset = m_endOffset;
1583     }
1584 
1585 private:
1586     CachedRefPtr&lt;CachedSourceProvider&gt; m_provider;
1587     int m_startOffset;
1588     int m_endOffset;
1589 };
1590 
1591 
1592 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1593 
1594 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1595     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1596 
1597 public:
1598     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1599     {
1600         Base::encode(encoder, sourceCode);
1601         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1602         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1603     }
1604 
1605     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1606     {
1607         Base::decode(decoder, sourceCode);
1608         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1609         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1610     }
1611 
1612 private:
1613     int m_firstLine;
1614     int m_startColumn;
1615 };
1616 
1617 class CachedSourceCodeWithoutProvider : public CachedObject&lt;SourceCode&gt; {
1618 public:
1619     void encode(Encoder&amp;, const SourceCode&amp; sourceCode)
1620     {
1621         m_hasProvider = !!sourceCode.provider();
1622         m_startOffset = sourceCode.startOffset();
1623         m_endOffset = sourceCode.endOffset();
1624         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1625         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1626     }
1627 
1628     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1629     {
1630         if (m_hasProvider)
1631             sourceCode.m_provider = decoder.provider();
1632         sourceCode.m_startOffset = m_startOffset;
1633         sourceCode.m_endOffset = m_endOffset;
1634         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1635         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1636     }
1637 
1638 private:
1639     bool m_hasProvider;
1640     int m_startOffset;
1641     int m_endOffset;
1642     int m_firstLine;
1643     int m_startColumn;
1644 };
1645 
1646 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1647 public:
1648     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1649     {
1650         m_classSource.encode(encoder, rareData.m_classSource);
1651         m_parentScopeTDZVariables.encode(encoder, rareData.m_parentScopeTDZVariables);
1652     }
1653 
1654     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1655     {
1656         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1657         m_classSource.decode(decoder, rareData-&gt;m_classSource);
1658         auto parentScopeTDZVariables = m_parentScopeTDZVariables.decode(decoder);
1659         rareData-&gt;m_parentScopeTDZVariables = WTFMove(parentScopeTDZVariables);
1660         return rareData;
1661     }
1662 
1663 private:
1664     CachedSourceCodeWithoutProvider m_classSource;
1665     CachedCompactVariableMapHandle m_parentScopeTDZVariables;
1666 };
1667 
1668 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
1669     friend struct CachedFunctionExecutableOffsets;
1670 
1671 public:
1672     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1673     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1674 
1675     unsigned firstLineOffset() const { return m_firstLineOffset; }
1676     unsigned lineCount() const { return m_lineCount; }
1677     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1678     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1679     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1680     unsigned startOffset() const { return m_startOffset; }
1681     unsigned sourceLength() const { return m_sourceLength; }
1682     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1683     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1684     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1685     unsigned parameterCount() const { return m_parameterCount; }
1686 
1687     CodeFeatures features() const { return m_mutableMetadata.m_features; }
1688     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1689 
1690     unsigned isInStrictContext() const { return m_isInStrictContext; }
1691     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }
1692     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1693     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1694     unsigned constructAbility() const { return m_constructAbility; }
1695     unsigned constructorKind() const { return m_constructorKind; }
1696     unsigned functionMode() const { return m_functionMode; }
1697     unsigned scriptMode() const { return m_scriptMode; }
1698     unsigned superBinding() const { return m_superBinding; }
1699     unsigned derivedContextType() const { return m_derivedContextType; }
1700 
1701     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1702     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
1703 
1704     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1705 
1706     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }
1707     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }
1708 
1709 private:
1710     CachedFunctionExecutableMetadata m_mutableMetadata;
1711 
1712     unsigned m_firstLineOffset : 31;
1713     unsigned m_isInStrictContext : 1;
1714     unsigned m_lineCount : 31;
1715     unsigned m_isBuiltinFunction : 1;
1716     unsigned m_unlinkedFunctionNameStart : 31;
1717     unsigned m_isBuiltinDefaultClassConstructor : 1;
1718     unsigned m_unlinkedBodyStartColumn : 31;
1719     unsigned m_constructAbility: 1;
1720     unsigned m_unlinkedBodyEndColumn : 31;
1721     unsigned m_startOffset : 31;
1722     unsigned m_scriptMode: 1; // JSParserScriptMode
1723     unsigned m_sourceLength : 31;
1724     unsigned m_superBinding : 1;
1725     unsigned m_parametersStartOffset : 31;
1726     unsigned m_typeProfilingStartOffset;
1727     unsigned m_typeProfilingEndOffset;
1728     unsigned m_parameterCount;
1729     SourceParseMode m_sourceParseMode;
1730     unsigned m_constructorKind : 2;
1731     unsigned m_functionMode : 2; // FunctionMode
1732     unsigned m_derivedContextType: 2;
1733 
1734     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;
1735 
1736     CachedIdentifier m_name;
1737     CachedIdentifier m_ecmaName;
1738 
1739     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1740     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1741 };
1742 
1743 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()
1744 {
1745     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);
1746 }
1747 
1748 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()
1749 {
1750     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);
1751 }
1752 
1753 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()
1754 {
1755     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);
1756 }
1757 
1758 template&lt;typename CodeBlockType&gt;
1759 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1760 public:
1761     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1762     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1763 
1764     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1765 
1766     VirtualRegister thisRegister() const { return m_thisRegister; }
1767     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1768 
1769     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }
1770     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }
1771 
1772     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1773 
1774     unsigned usesEval() const { return m_usesEval; }
1775     unsigned isStrictMode() const { return m_isStrictMode; }
1776     unsigned isConstructor() const { return m_isConstructor; }
1777     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1778     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1779     unsigned superBinding() const { return m_superBinding; }
1780     unsigned scriptMode() const { return m_scriptMode; }
1781     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1782     unsigned isClassContext() const { return m_isClassContext; }
1783     unsigned constructorKind() const { return m_constructorKind; }
1784     unsigned derivedContextType() const { return m_derivedContextType; }
1785     unsigned evalContextType() const { return m_evalContextType; }
1786     unsigned hasTailCalls() const { return m_hasTailCalls; }
1787     unsigned lineCount() const { return m_lineCount; }
1788     unsigned endColumn() const { return m_endColumn; }
1789 
1790     int numVars() const { return m_numVars; }
1791     int numCalleeLocals() const { return m_numCalleeLocals; }
1792     int numParameters() const { return m_numParameters; }
1793 
1794     CodeFeatures features() const { return m_features; }
1795     SourceParseMode parseMode() const { return m_parseMode; }
1796     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
1797     unsigned codeType() const { return m_codeType; }
1798 
1799     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1800 
1801 private:
1802     VirtualRegister m_thisRegister;
1803     VirtualRegister m_scopeRegister;
1804     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
1805 
1806     unsigned m_usesEval : 1;
1807     unsigned m_isStrictMode : 1;
1808     unsigned m_isConstructor : 1;
1809     unsigned m_hasCapturedVariables : 1;
1810     unsigned m_isBuiltinFunction : 1;
1811     unsigned m_superBinding : 1;
1812     unsigned m_scriptMode: 1;
1813     unsigned m_isArrowFunctionContext : 1;
1814     unsigned m_isClassContext : 1;
1815     unsigned m_constructorKind : 2;
1816     unsigned m_derivedContextType : 2;
1817     unsigned m_evalContextType : 2;
1818     unsigned m_hasTailCalls : 1;
1819     unsigned m_codeType : 2;
1820 
1821     CodeFeatures m_features;
1822     SourceParseMode m_parseMode;
1823     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
1824 
1825     unsigned m_lineCount;
1826     unsigned m_endColumn;
1827 
1828     int m_numVars;
1829     int m_numCalleeLocals;
1830     int m_numParameters;
1831 
1832     CachedMetadataTable m_metadata;
1833 
1834     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
1835 
1836     CachedString m_sourceURLDirective;
1837     CachedString m_sourceMappingURLDirective;
1838 
1839     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1840     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
1841     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;
1842     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1843     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1844     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1845     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1846 
1847     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1848     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1849     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1850 };
1851 
1852 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1853     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1854 
1855 public:
1856     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1857     {
1858         Base::encode(encoder, codeBlock);
1859         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1860         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1861     }
1862 
1863     UnlinkedProgramCodeBlock* decode(Decoder&amp; decoder) const
1864     {
1865         UnlinkedProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedProgramCodeBlock(decoder, *this);
1866         codeBlock-&gt;finishCreation(decoder.vm());
1867         Base::decode(decoder, *codeBlock);
1868         m_varDeclarations.decode(decoder, codeBlock-&gt;m_varDeclarations);
1869         m_lexicalDeclarations.decode(decoder, codeBlock-&gt;m_lexicalDeclarations);
1870         return codeBlock;
1871     }
1872 
1873 private:
1874     CachedVariableEnvironment m_varDeclarations;
1875     CachedVariableEnvironment m_lexicalDeclarations;
1876 };
1877 
1878 class CachedModuleCodeBlock : public CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt; {
1879     using Base = CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;;
1880 
1881 public:
1882     void encode(Encoder&amp; encoder, const UnlinkedModuleProgramCodeBlock&amp; codeBlock)
1883     {
1884         Base::encode(encoder, codeBlock);
1885         m_moduleEnvironmentSymbolTableConstantRegisterOffset = codeBlock.m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1886     }
1887 
1888     UnlinkedModuleProgramCodeBlock* decode(Decoder&amp; decoder) const
1889     {
1890         UnlinkedModuleProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedModuleProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedModuleProgramCodeBlock(decoder, *this);
1891         codeBlock-&gt;finishCreation(decoder.vm());
1892         Base::decode(decoder, *codeBlock);
1893         codeBlock-&gt;m_moduleEnvironmentSymbolTableConstantRegisterOffset = m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1894         return codeBlock;
1895     }
1896 
1897 private:
1898     int m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1899 };
1900 
1901 class CachedEvalCodeBlock : public CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt; {
1902     using Base = CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;;
1903 
1904 public:
1905     void encode(Encoder&amp; encoder, const UnlinkedEvalCodeBlock&amp; codeBlock)
1906     {
1907         Base::encode(encoder, codeBlock);
1908         m_variables.encode(encoder, codeBlock.m_variables);
1909         m_functionHoistingCandidates.encode(encoder, codeBlock.m_functionHoistingCandidates);
1910     }
1911 
1912     UnlinkedEvalCodeBlock* decode(Decoder&amp; decoder) const
1913     {
1914         UnlinkedEvalCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedEvalCodeBlock&gt;(decoder.vm().heap)) UnlinkedEvalCodeBlock(decoder, *this);
1915         codeBlock-&gt;finishCreation(decoder.vm());
1916         Base::decode(decoder, *codeBlock);
1917         m_variables.decode(decoder, codeBlock-&gt;m_variables);
1918         m_functionHoistingCandidates.decode(decoder, codeBlock-&gt;m_functionHoistingCandidates);
1919         return codeBlock;
1920     }
1921 
1922 private:
1923     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_variables;
1924     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_functionHoistingCandidates;
1925 };
1926 
1927 class CachedFunctionCodeBlock : public CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt; {
1928     using Base = CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt;;
1929 
1930 public:
1931     void encode(Encoder&amp; encoder, const UnlinkedFunctionCodeBlock&amp; codeBlock)
1932     {
1933         Base::encode(encoder, codeBlock);
1934     }
1935 
1936     UnlinkedFunctionCodeBlock* decode(Decoder&amp; decoder) const
1937     {
1938         UnlinkedFunctionCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedFunctionCodeBlock&gt;(decoder.vm().heap)) UnlinkedFunctionCodeBlock(decoder, *this);
1939         codeBlock-&gt;finishCreation(decoder.vm());
1940         Base::decode(decoder, *codeBlock);
1941         return codeBlock;
1942     }
1943 };
1944 
1945 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1946     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1947 {
1948 }
1949 
1950 template&lt;typename T&gt;
1951 struct CachedCodeBlockTypeImpl;
1952 
1953 enum CachedCodeBlockTag {
1954     CachedProgramCodeBlockTag,
1955     CachedModuleCodeBlockTag,
1956     CachedEvalCodeBlockTag,
1957 };
1958 
1959 static CachedCodeBlockTag tagFromSourceCodeType(SourceCodeType type)
1960 {
1961     switch (type) {
1962     case SourceCodeType::ProgramType:
1963         return CachedProgramCodeBlockTag;
1964     case SourceCodeType::EvalType:
1965         return CachedEvalCodeBlockTag;
1966     case SourceCodeType::ModuleType:
1967         return CachedModuleCodeBlockTag;
1968     case SourceCodeType::FunctionType:
1969         break;
1970     }
1971     ASSERT_NOT_REACHED();
1972     return static_cast&lt;CachedCodeBlockTag&gt;(-1);
1973 }
1974 
1975 template&lt;&gt;
1976 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
1977     using type = CachedProgramCodeBlock;
1978     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
1979 };
1980 
1981 template&lt;&gt;
1982 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
1983     using type = CachedModuleCodeBlock;
1984     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
1985 };
1986 
1987 template&lt;&gt;
1988 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
1989     using type = CachedEvalCodeBlock;
1990     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
1991 };
1992 
1993 template&lt;typename T&gt;
1994 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
1995 
1996 template&lt;typename CodeBlockType&gt;
1997 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
1998     : Base(decoder.vm(), structure)
1999     , m_thisRegister(cachedCodeBlock.thisRegister())
2000     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2001 
2002     , m_usesEval(cachedCodeBlock.usesEval())
2003     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2004     , m_isConstructor(cachedCodeBlock.isConstructor())
2005     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2006     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2007     , m_superBinding(cachedCodeBlock.superBinding())
2008     , m_scriptMode(cachedCodeBlock.scriptMode())
2009     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2010     , m_isClassContext(cachedCodeBlock.isClassContext())
2011     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())
2012     , m_constructorKind(cachedCodeBlock.constructorKind())
2013     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2014     , m_evalContextType(cachedCodeBlock.evalContextType())
2015     , m_codeType(cachedCodeBlock.codeType())
2016 
2017     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
2018     , m_age(0)
2019 
2020     , m_features(cachedCodeBlock.features())
2021     , m_parseMode(cachedCodeBlock.parseMode())
2022     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())
2023 
2024     , m_lineCount(cachedCodeBlock.lineCount())
2025     , m_endColumn(cachedCodeBlock.endColumn())
2026     , m_numVars(cachedCodeBlock.numVars())
2027     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2028     , m_numParameters(cachedCodeBlock.numParameters())
2029 
2030     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2031     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2032 
2033     , m_metadata(cachedCodeBlock.metadata(decoder))
2034     , m_instructions(cachedCodeBlock.instructions(decoder))
2035 
2036     , m_rareData(cachedCodeBlock.rareData(decoder))
2037 {
2038 }
2039 
2040 template&lt;typename CodeBlockType&gt;
2041 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2042 {
2043     for (unsigned i = LinkTimeConstantCount; i--;)
2044         codeBlock.m_linkTimeConstants[i] = m_linkTimeConstants[i];
2045 
2046     m_propertyAccessInstructions.decode(decoder, codeBlock.m_propertyAccessInstructions);
2047     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
2048     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
2049     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
2050     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
2051     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
2052     m_identifiers.decode(decoder, codeBlock.m_identifiers);
2053     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
2054     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2055 }
2056 
2057 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2058     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2059 {
2060 }
2061 
2062 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2063     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2064 {
2065 }
2066 
2067 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
2068     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
2069 {
2070 }
2071 
2072 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
2073 {
2074     m_mutableMetadata.m_features = executable.m_features;
2075     m_mutableMetadata.m_hasCapturedVariables = executable.m_hasCapturedVariables;
2076 
2077     m_firstLineOffset = executable.m_firstLineOffset;
2078     m_lineCount = executable.m_lineCount;
2079     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
2080     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2081     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2082     m_startOffset = executable.m_startOffset;
2083     m_sourceLength = executable.m_sourceLength;
2084     m_parametersStartOffset = executable.m_parametersStartOffset;
2085     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2086     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2087     m_parameterCount = executable.m_parameterCount;
2088 
2089     m_sourceParseMode = executable.m_sourceParseMode;
2090 
2091     m_isInStrictContext = executable.m_isInStrictContext;
2092     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2093     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2094     m_constructAbility = executable.m_constructAbility;
2095     m_constructorKind = executable.m_constructorKind;
2096     m_functionMode = executable.m_functionMode;
2097     m_scriptMode = executable.m_scriptMode;
2098     m_superBinding = executable.m_superBinding;
2099     m_derivedContextType = executable.m_derivedContextType;
2100 
2101     m_rareData.encode(encoder, executable.m_rareData.get());
2102 
2103     m_name.encode(encoder, executable.name());
2104     m_ecmaName.encode(encoder, executable.ecmaName());
2105 
2106     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2107     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
2108 
2109     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)
2110         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));
2111 }
2112 
2113 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2114 {
2115     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);
2116     executable-&gt;finishCreation(decoder.vm());
2117     return executable;
2118 }
2119 
2120 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, const CachedFunctionExecutable&amp; cachedExecutable)
2121     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
2122     , m_firstLineOffset(cachedExecutable.firstLineOffset())
2123     , m_isInStrictContext(cachedExecutable.isInStrictContext())
2124     , m_lineCount(cachedExecutable.lineCount())
2125     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())
2126     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
2127     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())
2128     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
2129     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())
2130     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
2131     , m_constructAbility(cachedExecutable.constructAbility())
2132     , m_startOffset(cachedExecutable.startOffset())
2133     , m_scriptMode(cachedExecutable.scriptMode())
2134     , m_sourceLength(cachedExecutable.sourceLength())
2135     , m_superBinding(cachedExecutable.superBinding())
2136     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
2137     , m_isCached(false)
2138     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2139     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2140     , m_parameterCount(cachedExecutable.parameterCount())
2141     , m_features(cachedExecutable.features())
2142     , m_sourceParseMode(cachedExecutable.sourceParseMode())
2143     , m_constructorKind(cachedExecutable.constructorKind())
2144     , m_functionMode(cachedExecutable.functionMode())
2145     , m_derivedContextType(cachedExecutable.derivedContextType())
2146     , m_isGeneratedFromCache(true)
2147     , m_unlinkedCodeBlockForCall()
2148     , m_unlinkedCodeBlockForConstruct()
2149 
2150     , m_name(cachedExecutable.name(decoder))
2151     , m_ecmaName(cachedExecutable.ecmaName(decoder))
2152 
2153     , m_rareData(cachedExecutable.rareData(decoder))
2154 {
2155 
2156     uint32_t leafExecutables = 2;
2157     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {
2158         if (!cachedPtr.isEmpty()) {
2159             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);
2160             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {
2161                 codeBlockOffset = offset;
2162                 m_isCached = true;
2163                 leafExecutables--;
2164                 return;
2165             }
2166         }
2167 
2168         codeBlockOffset = 0;
2169     };
2170 
2171     if (!cachedExecutable.unlinkedCodeBlockForCall().isEmpty() || !cachedExecutable.unlinkedCodeBlockForConstruct().isEmpty()) {
2172         checkBounds(m_cachedCodeBlockForCallOffset, cachedExecutable.unlinkedCodeBlockForCall());
2173         checkBounds(m_cachedCodeBlockForConstructOffset, cachedExecutable.unlinkedCodeBlockForConstruct());
2174         if (m_isCached)
2175             m_decoder = &amp;decoder;
2176         else
2177             m_decoder = nullptr;
2178     }
2179 
2180     if (leafExecutables)
2181         decoder.addLeafExecutable(this, decoder.offsetOf(&amp;cachedExecutable));
2182 }
2183 
2184 template&lt;typename CodeBlockType&gt;
2185 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
2186 {
2187     m_thisRegister = codeBlock.m_thisRegister;
2188     m_scopeRegister = codeBlock.m_scopeRegister;
2189     m_usesEval = codeBlock.m_usesEval;
2190     m_isStrictMode = codeBlock.m_isStrictMode;
2191     m_isConstructor = codeBlock.m_isConstructor;
2192     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2193     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2194     m_superBinding = codeBlock.m_superBinding;
2195     m_scriptMode = codeBlock.m_scriptMode;
2196     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2197     m_isClassContext = codeBlock.m_isClassContext;
2198     m_hasTailCalls = codeBlock.m_hasTailCalls;
2199     m_constructorKind = codeBlock.m_constructorKind;
2200     m_derivedContextType = codeBlock.m_derivedContextType;
2201     m_evalContextType = codeBlock.m_evalContextType;
2202     m_lineCount = codeBlock.m_lineCount;
2203     m_endColumn = codeBlock.m_endColumn;
2204     m_numVars = codeBlock.m_numVars;
2205     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2206     m_numParameters = codeBlock.m_numParameters;
2207     m_features = codeBlock.m_features;
2208     m_parseMode = codeBlock.m_parseMode;
2209     m_codeGenerationMode = codeBlock.m_codeGenerationMode;
2210     m_codeType = codeBlock.m_codeType;
2211 
2212     for (unsigned i = LinkTimeConstantCount; i--;)
2213         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
2214 
2215     m_metadata.encode(encoder, codeBlock.m_metadata.get());
2216     m_rareData.encode(encoder, codeBlock.m_rareData.get());
2217 
2218     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2219     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
2220 
2221     m_instructions.encode(encoder, codeBlock.m_instructions.get());
2222     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);
2223     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2224     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2225     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2226     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2227     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2228 
2229     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2230     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2231     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2232 }
2233 
2234 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2235 public:
2236     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
2237     {
2238         m_sourceCode.encode(encoder, key.m_sourceCode);
2239         m_name.encode(encoder, key.m_name);
2240         m_flags = key.m_flags.m_flags;
2241         m_hash = key.hash();
2242         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
2243     }
2244 
2245     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
2246     {
2247         m_sourceCode.decode(decoder, key.m_sourceCode);
2248         m_name.decode(decoder, key.m_name);
2249         key.m_flags.m_flags = m_flags;
2250         key.m_hash = m_hash;
2251         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
2252     }
2253 
2254 private:
2255     CachedUnlinkedSourceCode m_sourceCode;
2256     CachedString m_name;
2257     unsigned m_flags;
2258     unsigned m_hash;
2259     int m_functionConstructorParametersEndPosition;
2260 };
2261 
2262 class GenericCacheEntry {
2263 public:
2264     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
2265     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;
2266 
2267 protected:
2268     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2269         : m_tag(tag)
2270     {
2271         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2272     }
2273 
2274     CachedCodeBlockTag tag() const { return m_tag; }
2275 
2276     bool isUpToDate(Decoder&amp; decoder) const
2277     {
2278         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)
2279             return false;
2280         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
2281             return false;
2282         return true;
2283     }
2284 
2285 private:
2286     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
2287     CachedString m_bootSessionUUID;
2288     CachedCodeBlockTag m_tag;
2289 };
2290 
2291 template&lt;typename UnlinkedCodeBlockType&gt;
2292 class CacheEntry : public GenericCacheEntry {
2293 public:
2294     CacheEntry(Encoder&amp; encoder)
2295         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2296     {
2297     }
2298 
2299     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2300     {
2301         m_key.encode(encoder, pair.first);
2302         m_codeBlock.encode(encoder, pair.second);
2303     }
2304 
2305 private:
2306     friend GenericCacheEntry;
2307 
2308     bool isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key) const
2309     {
2310         SourceCodeKey decodedKey;
2311         m_key.decode(decoder, decodedKey);
2312         return decodedKey == key;
2313     }
2314 
2315     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2316     {
2317         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2318         SourceCodeKey decodedKey;
2319         m_key.decode(decoder, decodedKey);
2320         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2321         return true;
2322     }
2323 
2324     CachedSourceCodeKey m_key;
2325     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2326 };
2327 
2328 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2329 {
2330     if (!isUpToDate(decoder))
2331         return false;
2332 
2333     switch (m_tag) {
2334     case CachedProgramCodeBlockTag:
2335         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));
2336     case CachedModuleCodeBlockTag:
2337         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));
2338     case CachedEvalCodeBlockTag:
2339         // We do not cache eval code blocks
2340         RELEASE_ASSERT_NOT_REACHED();
2341     }
2342     RELEASE_ASSERT_NOT_REACHED();
2343 #if COMPILER(MSVC)
2344     // Without this, MSVC will complain that this path does not return a value.
2345     return false;
2346 #endif
2347 }
2348 
2349 bool GenericCacheEntry::isStillValid(Decoder&amp; decoder, const SourceCodeKey&amp; key, CachedCodeBlockTag tag) const
2350 {
2351     if (!isUpToDate(decoder))
2352         return false;
2353 
2354     switch (tag) {
2355     case CachedProgramCodeBlockTag:
2356         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);
2357     case CachedModuleCodeBlockTag:
2358         return bitwise_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;isStillValid(decoder, key);
2359     case CachedEvalCodeBlockTag:
2360         // We do not cache eval code blocks
2361         RELEASE_ASSERT_NOT_REACHED();
2362     }
2363     RELEASE_ASSERT_NOT_REACHED();
2364     return false;
2365 }
2366 
2367 template&lt;typename UnlinkedCodeBlockType&gt;
2368 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2369 {
2370     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
2371     entry-&gt;encode(encoder, { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });
2372 }
2373 
2374 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error)
2375 {
2376     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2377 
2378     Encoder encoder(vm, fd);
2379     if (classInfo == UnlinkedProgramCodeBlock::info())
2380         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2381     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2382         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2383     else
2384         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2385 
2386     return encoder.release(error);
2387 }
2388 
2389 RefPtr&lt;CachedBytecode&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2390 {
2391     BytecodeCacheError error;
2392     return encodeCodeBlock(vm, key, codeBlock, FileSystem::invalidPlatformFileHandle, error);
2393 }
2394 
2395 RefPtr&lt;CachedBytecode&gt; encodeFunctionCodeBlock(VM&amp; vm, const UnlinkedFunctionCodeBlock* codeBlock, BytecodeCacheError&amp; error)
2396 {
2397     Encoder encoder(vm);
2398     encoder.malloc&lt;CachedFunctionCodeBlock&gt;()-&gt;encode(encoder, *codeBlock);
2399     return encoder.release(error);
2400 }
2401 
2402 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, Ref&lt;CachedBytecode&gt; cachedBytecode)
2403 {
2404     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(cachedBytecode-&gt;data());
2405     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode), &amp;key.source().provider());
2406     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2407     {
2408         DeferGC deferGC(vm.heap);
2409         if (!cachedEntry-&gt;decode(decoder.get(), entry))
2410             return nullptr;
2411     }
2412 
2413     if (entry.first != key)
2414         return nullptr;
2415     return entry.second;
2416 }
2417 
2418 bool isCachedBytecodeStillValid(VM&amp; vm, Ref&lt;CachedBytecode&gt; cachedBytecode, const SourceCodeKey&amp; key, SourceCodeType type)
2419 {
2420     const void* buffer = cachedBytecode-&gt;data();
2421     size_t size = cachedBytecode-&gt;size();
2422     if (!size)
2423         return false;
2424     const auto* cachedEntry = bitwise_cast&lt;const GenericCacheEntry*&gt;(buffer);
2425     Ref&lt;Decoder&gt; decoder = Decoder::create(vm, WTFMove(cachedBytecode));
2426     return cachedEntry-&gt;isStillValid(decoder.get(), key, tagFromSourceCodeType(type));
2427 }
2428 
2429 void decodeFunctionCodeBlock(Decoder&amp; decoder, int32_t cachedFunctionCodeBlockOffset, WriteBarrier&lt;UnlinkedFunctionCodeBlock&gt;&amp; codeBlock, const JSCell* owner)
2430 {
2431     ASSERT(decoder.vm().heap.isDeferred());
2432     auto* cachedCodeBlock = static_cast&lt;const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;*&gt;(decoder.ptrForOffsetFromBase(cachedFunctionCodeBlockOffset));
2433     cachedCodeBlock-&gt;decode(decoder, codeBlock, owner);
2434 }
2435 
2436 } // namespace JSC
    </pre>
  </body>
</html>