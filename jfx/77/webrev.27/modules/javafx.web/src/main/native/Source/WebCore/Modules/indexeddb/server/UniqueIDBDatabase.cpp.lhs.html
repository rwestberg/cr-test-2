<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;SerializedScriptValue.h&quot;
<a name="1" id="anc1"></a>
  44 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  45 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<a name="2" id="anc2"></a><span class="line-modified">  46 #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
  47 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<a name="3" id="anc3"></a><span class="line-removed">  48 #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  49 #include &lt;wtf/MainThread.h&gt;
  50 #include &lt;wtf/NeverDestroyed.h&gt;
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 
<a name="4" id="anc4"></a>


















































  57 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
  58     : m_server(server)
  59     , m_identifier(identifier)
  60     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
  61 {
  62     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
  63 }
  64 
  65 UniqueIDBDatabase::~UniqueIDBDatabase()
  66 {
  67     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
  68     ASSERT(isMainThread());
  69     ASSERT(!hasAnyPendingCallbacks());
  70     ASSERT(!hasUnfinishedTransactions());
  71     ASSERT(m_pendingTransactions.isEmpty());
  72     ASSERT(m_openDatabaseConnections.isEmpty());
  73     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());
  74     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());
  75 
  76     RELEASE_ASSERT(m_databaseQueue.isKilled());
  77     RELEASE_ASSERT(m_databaseReplyQueue.isKilled());
  78     RELEASE_ASSERT(!m_backingStore);
  79 }
  80 
  81 const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
  82 {
  83     RELEASE_ASSERT(m_databaseInfo);
  84     return *m_databaseInfo;
  85 }
  86 
  87 void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
  88 {
  89     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
  90     ASSERT(!m_hardClosedForUserDelete);
  91     ASSERT(isMainThread());
  92 
  93     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
  94 
  95     // An open operation is already in progress, so we can&#39;t possibly handle this one yet.
  96     if (m_isOpeningBackingStore)
  97         return;
  98 
  99     handleDatabaseOperations();
 100 }
 101 
 102 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const
 103 {
 104     return !m_errorCallbacks.isEmpty()
 105         || !m_keyDataCallbacks.isEmpty()
 106         || !m_getResultCallbacks.isEmpty()
 107         || !m_getAllResultsCallbacks.isEmpty()
 108         || !m_countCallbacks.isEmpty();
 109 }
 110 
 111 bool UniqueIDBDatabase::isVersionChangeInProgress()
 112 {
 113 #if !LOG_DISABLED
 114     if (m_versionChangeTransaction)
 115         ASSERT(m_versionChangeDatabaseConnection);
 116 #endif
 117 
 118     return m_versionChangeDatabaseConnection;
 119 }
 120 
<a name="5" id="anc5"></a>

































 121 void UniqueIDBDatabase::performCurrentOpenOperation()
 122 {
 123     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 124 
 125     ASSERT(m_currentOpenDBRequest);
 126     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 127 
 128     if (!m_databaseInfo) {
 129         if (!m_isOpeningBackingStore) {
 130             m_isOpeningBackingStore = true;
<a name="6" id="anc6"></a><span class="line-modified"> 131             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>




















 132         }
<a name="7" id="anc7"></a><span class="line-removed"> 133 </span>
 134         return;
 135     }
 136 
 137     // If we previously started a version change operation but were blocked by having open connections,
 138     // we might now be unblocked.
 139     if (m_versionChangeDatabaseConnection) {
 140         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 141             startVersionChangeTransaction();
 142         return;
 143     }
 144 
 145     // 3.3.1 Opening a database
 146     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 147     // or the current version of db otherwise.
 148     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 149     if (!requestedVersion)
 150         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 151 
 152     // 3.3.1 Opening a database
 153     // If the database version higher than the requested version, abort these steps and return a VersionError.
 154     if (requestedVersion &lt; m_databaseInfo-&gt;version()) {
 155         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError(VersionError));
 156         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 157         m_currentOpenDBRequest = nullptr;
 158 
 159         return;
 160     }
 161 
 162     if (!m_backingStoreOpenError.isNull()) {
 163         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), m_backingStoreOpenError);
 164         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 165         m_currentOpenDBRequest = nullptr;
 166 
 167         return;
 168     }
 169 
 170     Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
 171 
 172     if (requestedVersion == m_databaseInfo-&gt;version()) {
 173         auto* rawConnection = &amp;connection.get();
 174         addOpenDatabaseConnection(WTFMove(connection));
 175 
 176         auto result = IDBResultData::openDatabaseSuccess(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), *rawConnection);
 177         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);
 178         m_currentOpenDBRequest = nullptr;
 179 
 180         return;
 181     }
 182 
 183     ASSERT(!m_versionChangeDatabaseConnection);
 184     m_versionChangeDatabaseConnection = WTFMove(connection);
 185 
 186     // 3.3.7 &quot;versionchange&quot; transaction steps
 187     // If there&#39;s no other open connections to this database, the version change process can begin immediately.
 188     if (!hasAnyOpenConnections()) {
 189         startVersionChangeTransaction();
 190         return;
 191     }
 192 
 193     // Otherwise we have to notify all those open connections and wait for them to close.
 194     maybeNotifyConnectionsOfVersionChange();
 195 }
 196 
 197 void UniqueIDBDatabase::performCurrentDeleteOperation()
 198 {
 199     ASSERT(isMainThread());
 200     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.debugString().utf8().data());
 201 
 202     ASSERT(m_currentOpenDBRequest);
 203     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
 204 
 205     if (m_deleteBackingStoreInProgress)
 206         return;
 207 
 208     if (hasAnyOpenConnections()) {
 209         maybeNotifyConnectionsOfVersionChange();
 210         return;
 211     }
 212 
 213     if (hasUnfinishedTransactions())
 214         return;
 215 
 216     ASSERT(!hasAnyPendingCallbacks());
 217     ASSERT(m_pendingTransactions.isEmpty());
 218     ASSERT(m_openDatabaseConnections.isEmpty());
 219 
 220     // It&#39;s possible to have multiple delete requests queued up in a row.
 221     // In that scenario only the first request will actually have to delete the database.
 222     // Subsequent requests can immediately notify their completion.
 223 
 224     if (!m_deleteBackingStoreInProgress) {
 225         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 226             didDeleteBackingStore(0);
 227         else {
 228             m_deleteBackingStoreInProgress = true;
 229             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));
 230         }
 231     }
 232 }
 233 
 234 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 235 {
 236     ASSERT(!isMainThread());
 237     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);
 238 
 239     uint64_t deletedVersion = 0;
 240 
 241     if (m_backingStore) {
 242         m_backingStore-&gt;deleteBackingStore();
<a name="8" id="anc8"></a>

 243         m_backingStore = nullptr;
 244         m_backingStoreSupportsSimultaneousTransactions = false;
 245         m_backingStoreIsEphemeral = false;
 246     } else {
<a name="9" id="anc9"></a><span class="line-modified"> 247         auto backingStore = m_server.createBackingStore(identifier);</span>

 248 
 249         IDBDatabaseInfo databaseInfo;
 250         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 251         if (!error.isNull())
 252             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
 253 
 254         deletedVersion = databaseInfo.version();
 255         backingStore-&gt;deleteBackingStore();
<a name="10" id="anc10"></a>
 256     }
 257 
 258     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 259 }
 260 
 261 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()
 262 {
 263     ASSERT(!isMainThread());
 264     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);
 265 
 266     if (m_backingStore)
 267         m_backingStore-&gt;deleteBackingStore();
 268 
 269     shutdownForClose();
 270 }
 271 
 272 void UniqueIDBDatabase::scheduleShutdownForClose()
 273 {
 274     ASSERT(isMainThread());
 275 
 276     m_operationAndTransactionTimer.stop();
 277 
 278     RELEASE_ASSERT(!m_owningPointerForClose);
<a name="11" id="anc11"></a><span class="line-modified"> 279     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
 280 
 281     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 282 }
 283 
 284 void UniqueIDBDatabase::shutdownForClose()
 285 {
 286     ASSERT(!isMainThread());
 287     ASSERT(m_owningPointerForClose.get() == this);
 288 
 289     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
 290 
<a name="12" id="anc12"></a>




 291     m_backingStore = nullptr;
 292     m_backingStoreSupportsSimultaneousTransactions = false;
 293     m_backingStoreIsEphemeral = false;
 294 
 295     if (!m_databaseQueue.isEmpty()) {
 296         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 297         return;
 298     }
 299     m_databaseQueue.kill();
 300 
 301     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));
 302 }
 303 
 304 void UniqueIDBDatabase::didShutdownForClose()
 305 {
 306     ASSERT(m_databaseReplyQueue.isEmpty());
 307     m_databaseReplyQueue.kill();
<a name="13" id="anc13"></a>

 308 }
 309 
 310 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 311 {
 312     ASSERT(isMainThread());
 313     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);
 314 
 315     ASSERT(!hasAnyPendingCallbacks());
 316     ASSERT(!hasUnfinishedTransactions());
 317     ASSERT(m_pendingTransactions.isEmpty());
 318     ASSERT(m_openDatabaseConnections.isEmpty());
 319     ASSERT(!m_backingStore);
 320 
 321     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.
 322     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.
 323     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());
 324 
 325     if (m_databaseInfo)
 326         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 327 
 328     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 329     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 330     // passed in deletedVersion argument.
 331     if (!m_mostRecentDeletedDatabaseInfo)
<a name="14" id="anc14"></a><span class="line-modified"> 332         m_mostRecentDeletedDatabaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
 333 
 334     if (m_currentOpenDBRequest) {
 335         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 336         m_currentOpenDBRequest = nullptr;
 337     }
 338 
<a name="15" id="anc15"></a>

 339     m_deleteBackingStoreInProgress = false;
 340 
 341     if (m_hardClosedForUserDelete)
 342         return;
 343 
 344     invokeOperationAndTransactionTimer();
 345 }
 346 
 347 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 348 {
 349     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 350         m_pendingOpenDBRequests.removeFirst();
 351 }
 352 
 353 void UniqueIDBDatabase::handleDatabaseOperations()
 354 {
 355     ASSERT(isMainThread());
 356     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 357     ASSERT(!m_hardClosedForUserDelete);
 358 
<a name="16" id="anc16"></a><span class="line-modified"> 359     if (m_deleteBackingStoreInProgress)</span>
 360         return;
 361 
 362     clearStalePendingOpenDBRequests();
 363 
 364     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
 365         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 366         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
 367             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 368 
 369         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle
 370         if (m_currentOpenDBRequest)
 371             handleCurrentOperation();
 372 
 373         return;
 374     }
 375 
 376     if (m_pendingOpenDBRequests.isEmpty()) {
 377         m_currentOpenDBRequest = nullptr;
 378         return;
 379     }
 380 
 381     m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 382     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - Popped an operation, now there are %u pending&quot;, m_pendingOpenDBRequests.size());
 383 
 384     handleCurrentOperation();
 385 }
 386 
 387 void UniqueIDBDatabase::handleCurrentOperation()
 388 {
 389     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleCurrentOperation&quot;);
 390     ASSERT(!m_hardClosedForUserDelete);
 391     ASSERT(m_currentOpenDBRequest);
 392 
 393     if (m_currentOpenDBRequest-&gt;isOpenRequest())
 394         performCurrentOpenOperation();
 395     else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
 396         performCurrentDeleteOperation();
 397     else
 398         ASSERT_NOT_REACHED();
 399 
 400     if (!m_currentOpenDBRequest)
 401         invokeOperationAndTransactionTimer();
 402 }
 403 
 404 bool UniqueIDBDatabase::hasAnyOpenConnections() const
 405 {
 406     return !m_openDatabaseConnections.isEmpty();
 407 }
 408 
 409 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 410 {
 411     for (auto&amp; connection : m_openDatabaseConnections) {
 412         if (!connection-&gt;connectionIsClosing())
 413             return false;
 414     }
 415 
 416     return true;
 417 }
 418 
 419 static uint64_t generateUniqueCallbackIdentifier()
 420 {
 421     ASSERT(isMainThread());
 422     static uint64_t currentID = 0;
 423     return ++currentID;
 424 }
 425 
<a name="17" id="anc17"></a><span class="line-modified"> 426 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback)</span>
 427 {
 428     if (m_hardClosedForUserDelete) {
 429         callback(IDBError::userDeleteError());
 430         return 0;
 431     }
 432 
 433     uint64_t identifier = generateUniqueCallbackIdentifier();
 434     ASSERT(!m_errorCallbacks.contains(identifier));
 435     m_errorCallbacks.add(identifier, WTFMove(callback));
<a name="18" id="anc18"></a>





 436     m_callbackQueue.append(identifier);
 437     return identifier;
 438 }
 439 
<a name="19" id="anc19"></a><span class="line-modified"> 440 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback)</span>
 441 {
 442     if (m_hardClosedForUserDelete) {
 443         callback(IDBError::userDeleteError(), { });
 444         return 0;
 445     }
 446 
 447     uint64_t identifier = generateUniqueCallbackIdentifier();
 448     ASSERT(!m_keyDataCallbacks.contains(identifier));
 449     m_keyDataCallbacks.add(identifier, WTFMove(callback));
<a name="20" id="anc20"></a>





 450     m_callbackQueue.append(identifier);
 451     return identifier;
 452 }
 453 
 454 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
 455 {
 456     if (m_hardClosedForUserDelete) {
 457         callback(IDBError::userDeleteError(), { });
 458         return 0;
 459     }
 460 
 461     uint64_t identifier = generateUniqueCallbackIdentifier();
 462     ASSERT(!m_getResultCallbacks.contains(identifier));
 463     m_getResultCallbacks.add(identifier, WTFMove(callback));
 464     m_callbackQueue.append(identifier);
 465     return identifier;
 466 }
 467 
 468 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)
 469 {
 470     if (m_hardClosedForUserDelete) {
 471         callback(IDBError::userDeleteError(), { });
 472         return 0;
 473     }
 474 
 475     uint64_t identifier = generateUniqueCallbackIdentifier();
 476     ASSERT(!m_getAllResultsCallbacks.contains(identifier));
 477     m_getAllResultsCallbacks.add(identifier, WTFMove(callback));
 478     m_callbackQueue.append(identifier);
 479     return identifier;
 480 }
 481 
 482 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(CountCallback&amp;&amp; callback)
 483 {
 484     if (m_hardClosedForUserDelete) {
 485         callback(IDBError::userDeleteError(), 0);
 486         return 0;
 487     }
 488 
 489     uint64_t identifier = generateUniqueCallbackIdentifier();
 490     ASSERT(!m_countCallbacks.contains(identifier));
 491     m_countCallbacks.add(identifier, WTFMove(callback));
 492     m_callbackQueue.append(identifier);
 493     return identifier;
 494 }
 495 
 496 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 497 {
 498     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);
 499     ASSERT(!m_hardClosedForUserDelete);
 500 
 501     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 502     handleDatabaseOperations();
 503 }
 504 
 505 void UniqueIDBDatabase::startVersionChangeTransaction()
 506 {
 507     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 508 
 509     ASSERT(!m_versionChangeTransaction);
 510     ASSERT(m_currentOpenDBRequest);
 511     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 512     ASSERT(m_versionChangeDatabaseConnection);
 513 
<a name="21" id="anc21"></a><span class="line-modified"> 514     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516     uint64_t requestedVersion = operation-&gt;requestData().requestedVersion();</span>
 517     if (!requestedVersion)
 518         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 519 
<a name="22" id="anc22"></a><span class="line-removed"> 520     addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="line-removed"> 521 </span>
 522     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<a name="23" id="anc23"></a><span class="line-removed"> 523     m_databaseInfo-&gt;setVersion(requestedVersion);</span>
<span class="line-removed"> 524 </span>
 525     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);
<a name="24" id="anc24"></a><span class="line-removed"> 526     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::beginTransactionInBackingStore, m_versionChangeTransaction-&gt;info()));</span>
 527 
<a name="25" id="anc25"></a><span class="line-modified"> 528     auto result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="line-removed"> 529     operation-&gt;connection().didOpenDatabase(result);</span>
 530 }
 531 
<a name="26" id="anc26"></a><span class="line-modified"> 532 void UniqueIDBDatabase::beginTransactionInBackingStore(const IDBTransactionInfo&amp; info)</span>
 533 {
<a name="27" id="anc27"></a><span class="line-modified"> 534     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::beginTransactionInBackingStore&quot;);</span>
<span class="line-modified"> 535     m_backingStore-&gt;beginTransaction(info);</span>





























 536 }
 537 
 538 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 539 {
 540     ASSERT(m_currentOpenDBRequest);
 541 
 542     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 543         return;
 544 
 545     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 546     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 547 
 548     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 549 
 550     // 3.3.7 &quot;versionchange&quot; transaction steps
 551     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 552     // The event must not be fired on connections which has the closePending flag set.
 553     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 554     for (const auto&amp; connection : m_openDatabaseConnections) {
 555         if (connection-&gt;closePending())
 556             continue;
 557 
 558         connection-&gt;fireVersionChangeEvent(requestIdentifier, newVersion);
 559         connectionIdentifiers.add(connection-&gt;identifier());
 560     }
 561 
 562     if (!connectionIdentifiers.isEmpty())
 563         m_currentOpenDBRequest-&gt;notifiedConnectionsOfVersionChange(WTFMove(connectionIdentifiers));
 564     else
 565         m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 566 }
 567 
 568 void UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(uint64_t connectionIdentifier)
 569 {
 570     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent - %&quot; PRIu64, connectionIdentifier);
 571 
 572     ASSERT(m_currentOpenDBRequest);
 573 
 574     m_currentOpenDBRequest-&gt;connectionClosedOrFiredVersionChangeEvent(connectionIdentifier);
 575 
 576     if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
 577         return;
 578 
 579     if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
 580         invokeOperationAndTransactionTimer();
 581         return;
 582     }
 583 
 584     // Since all open connections have fired their version change events but not all of them have closed,
 585     // this request is officially blocked.
 586     m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
 587 }
 588 
 589 void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier)
 590 {
 591     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
 592 
 593     if (!m_currentOpenDBRequest)
 594         return;
 595 
 596     ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
 597 
 598     notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
 599 }
 600 
 601 void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
 602 {
 603     LOG(IndexedDB, &quot;UniqueIDBDatabase::openDBRequestCancelled - %s&quot;, requestIdentifier.loggingString().utf8().data());
 604 
 605     if (m_currentOpenDBRequest &amp;&amp; m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier)
 606         m_currentOpenDBRequest = nullptr;
 607 
 608     if (m_versionChangeDatabaseConnection &amp;&amp; m_versionChangeDatabaseConnection-&gt;openRequestIdentifier() == requestIdentifier) {
 609         ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;databaseConnection().openRequestIdentifier() == requestIdentifier);
 610         ASSERT(!m_versionChangeTransaction || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
 611 
 612         connectionClosedFromClient(*m_versionChangeDatabaseConnection);
 613     }
 614 
 615     for (auto&amp; request : m_pendingOpenDBRequests) {
 616         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 617             m_pendingOpenDBRequests.remove(request);
 618             return;
 619         }
 620     }
 621 }
 622 
 623 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 624 {
 625     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 626     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 627 }
 628 
 629 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 630 {
 631     ASSERT(!isMainThread());
 632     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
 633 
 634     ASSERT(!m_backingStore);
<a name="28" id="anc28"></a><span class="line-modified"> 635     m_backingStore = m_server.createBackingStore(identifier);</span>
 636     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
 637     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
 638 
<a name="29" id="anc29"></a>



 639     IDBDatabaseInfo databaseInfo;
 640     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 641 
 642     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 643 }
 644 
 645 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
 646 {
 647     ASSERT(isMainThread());
 648     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
 649 
<a name="30" id="anc30"></a><span class="line-modified"> 650     m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(info);</span>
 651     m_backingStoreOpenError = error;
 652 
 653     ASSERT(m_isOpeningBackingStore);
 654     m_isOpeningBackingStore = false;
 655 
<a name="31" id="anc31"></a>

 656     if (m_hardClosedForUserDelete)
 657         return;
 658 
 659     handleDatabaseOperations();
 660 }
 661 
 662 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 663 {
 664     ASSERT(isMainThread());
 665     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
 666 
<a name="32" id="anc32"></a><span class="line-modified"> 667     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 668     if (!callbackID)
 669         return;
 670 
 671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 672 }
 673 
 674 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 675 {
 676     ASSERT(!isMainThread());
 677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);
 678 
 679     ASSERT(m_backingStore);
 680     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);
 681 
 682     IDBError error;
 683     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));
 684 }
 685 
 686 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)
 687 {
 688     ASSERT(isMainThread());
 689     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);
 690 
 691     if (error.isNull())
 692         m_databaseInfo-&gt;addExistingObjectStore(info);
 693 
 694     performErrorCallback(callbackIdentifier, error);
 695 }
 696 
 697 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 698 {
 699     ASSERT(isMainThread());
 700     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
 701 
<a name="33" id="anc33"></a>














 702     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 703     if (!callbackID)
 704         return;
 705 
 706     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 707     if (!info) {
 708         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 709         return;
 710     }
 711 
 712     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));
 713 }
 714 
 715 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 716 {
 717     ASSERT(!isMainThread());
 718     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);
 719 
 720     ASSERT(m_backingStore);
 721     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);
 722 
 723     IDBError error;
 724     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));
 725 }
 726 
 727 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)
 728 {
 729     ASSERT(isMainThread());
 730     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);
 731 
 732     if (error.isNull())
 733         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
 734 
 735     performErrorCallback(callbackIdentifier, error);
 736 }
 737 
 738 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 739 {
 740     ASSERT(isMainThread());
 741     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
 742 
<a name="34" id="anc34"></a><span class="line-modified"> 743     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 744     if (!callbackID)
 745         return;
 746 
 747     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 748     if (!info) {
 749         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 750         return;
 751     }
 752 
 753     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));
 754 }
 755 
 756 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
 757 {
 758     ASSERT(!isMainThread());
 759     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);
 760 
 761     ASSERT(m_backingStore);
 762     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);
 763 
 764     IDBError error;
 765     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));
 766 }
 767 
 768 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)
 769 {
 770     ASSERT(isMainThread());
 771     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);
 772 
 773     if (error.isNull())
 774         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 775 
 776     performErrorCallback(callbackIdentifier, error);
 777 }
 778 
 779 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 780 {
 781     ASSERT(isMainThread());
 782     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
 783 
<a name="35" id="anc35"></a>














 784     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 785     if (!callbackID)
 786         return;
 787     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
 788 }
 789 
 790 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 791 {
 792     ASSERT(!isMainThread());
 793     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);
 794 
 795     ASSERT(m_backingStore);
 796     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);
 797 
 798     IDBError error;
 799     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));
 800 }
 801 
 802 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)
 803 {
 804     ASSERT(isMainThread());
 805     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);
 806 
 807     performErrorCallback(callbackIdentifier, error);
 808 }
 809 
 810 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
 811 {
 812     ASSERT(isMainThread());
 813     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
 814 
<a name="36" id="anc36"></a><span class="line-modified"> 815     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 816     if (!callbackID)
 817         return;
 818     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
 819 }
 820 
 821 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
 822 {
 823     ASSERT(!isMainThread());
 824     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
 825 
<a name="37" id="anc37"></a>
 826     ASSERT(m_backingStore);
<a name="38" id="anc38"></a><span class="line-modified"> 827     IDBError error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>





 828 
<a name="39" id="anc39"></a>
 829     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
 830 }
 831 
 832 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
 833 {
 834     ASSERT(isMainThread());
 835     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);
 836 
 837     if (error.isNull()) {
 838         ASSERT(m_databaseInfo);
 839         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
 840         ASSERT(objectStoreInfo);
 841         objectStoreInfo-&gt;addExistingIndex(info);
 842     }
 843 
 844     performErrorCallback(callbackIdentifier, error);
 845 }
 846 
 847 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
 848 {
 849     ASSERT(isMainThread());
 850     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
 851 
<a name="40" id="anc40"></a>














 852     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 853     if (!callbackID)
 854         return;
 855 
 856     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 857     if (!objectStoreInfo) {
 858         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
 859         return;
 860     }
 861 
 862     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
 863     if (!indexInfo) {
 864         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
 865         return;
 866     }
 867 
 868     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));
 869 }
 870 
 871 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)
 872 {
 873     ASSERT(!isMainThread());
 874     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteIndex&quot;);
 875 
 876     ASSERT(m_backingStore);
 877     m_backingStore-&gt;deleteIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier);
 878 
 879     IDBError error;
 880     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier));
 881 }
 882 
 883 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
 884 {
 885     ASSERT(isMainThread());
 886     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);
 887 
 888     if (error.isNull()) {
 889         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 890         if (objectStoreInfo)
 891             objectStoreInfo-&gt;deleteIndex(indexIdentifier);
 892     }
 893 
 894     performErrorCallback(callbackIdentifier, error);
 895 }
 896 
 897 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
 898 {
 899     ASSERT(isMainThread());
 900     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
 901 
<a name="41" id="anc41"></a><span class="line-modified"> 902     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 903     if (!callbackID)
 904         return;
 905 
 906     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 907     if (!objectStoreInfo) {
 908         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
 909         return;
 910     }
 911 
 912     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 913     if (!indexInfo) {
 914         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
 915         return;
 916     }
 917 
 918     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));
 919 }
 920 
 921 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
 922 {
 923     ASSERT(!isMainThread());
 924     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameIndex&quot;);
 925 
 926     ASSERT(m_backingStore);
 927     m_backingStore-&gt;renameIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier, newName);
 928 
 929     IDBError error;
 930     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier, newName));
 931 }
 932 
 933 void UniqueIDBDatabase::didPerformRenameIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
 934 {
 935     ASSERT(isMainThread());
 936     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);
 937 
 938     if (error.isNull()) {
 939         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 940         ASSERT(objectStoreInfo);
 941         if (objectStoreInfo) {
 942             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 943             ASSERT(indexInfo);
 944             indexInfo-&gt;rename(newName);
 945         }
 946     }
 947 
 948     performErrorCallback(callbackIdentifier, error);
 949 }
 950 
 951 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
 952 {
 953     ASSERT(isMainThread());
 954     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
 955 
<a name="42" id="anc42"></a><span class="line-modified"> 956     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-modified"> 957     if (!callbackID)</span>
<span class="line-modified"> 958         return;</span>
<span class="line-modified"> 959     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
<span class="line-modified"> 960 }</span>
<span class="line-modified"> 961 </span>
<span class="line-modified"> 962 VM&amp; UniqueIDBDatabase::databaseThreadVM()</span>
<span class="line-modified"> 963 {</span>
<span class="line-removed"> 964     ASSERT(!isMainThread());</span>
<span class="line-removed"> 965     static VM* vm = &amp;VM::create().leakRef();</span>
<span class="line-removed"> 966     return *vm;</span>
 967 }
 968 
<a name="43" id="anc43"></a><span class="line-modified"> 969 ExecState&amp; UniqueIDBDatabase::databaseThreadExecState()</span>
 970 {
<a name="44" id="anc44"></a><span class="line-modified"> 971     ASSERT(!isMainThread());</span>
<span class="line-modified"> 972 </span>
<span class="line-modified"> 973     static NeverDestroyed&lt;Strong&lt;JSGlobalObject&gt;&gt; globalObject(databaseThreadVM(), JSGlobalObject::create(databaseThreadVM(), JSGlobalObject::createStructure(databaseThreadVM(), jsNull())));</span>
<span class="line-modified"> 974 </span>
<span class="line-removed"> 975     RELEASE_ASSERT(globalObject.get()-&gt;globalExec());</span>
<span class="line-removed"> 976     return *globalObject.get()-&gt;globalExec();</span>
 977 }
 978 
 979 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
 980 {
 981     ASSERT(!isMainThread());
 982     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);
 983 
 984     ASSERT(m_backingStore);
 985     ASSERT(objectStoreIdentifier);
 986 
 987     IDBKeyData usedKey;
 988     IDBError error;
 989 
<a name="45" id="anc45"></a>






 990     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
 991     if (!objectStoreInfo) {
 992         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
 993         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
 994         return;
 995     }
 996 
 997     bool usedKeyIsGenerated = false;
 998     uint64_t keyNumber;
 999     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1000         if (usedKeyIsGenerated)
1001             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1002     });
1003     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1004         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1005         if (!error.isNull()) {
1006             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1007             return;
1008         }
1009 
1010         usedKey.setNumberValue(keyNumber);
1011         usedKeyIsGenerated = true;
1012     } else
1013         usedKey = keyData;
1014 
1015     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1016         bool keyExists;
1017         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1018         if (error.isNull() &amp;&amp; keyExists)
1019             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);
1020 
1021         if (!error.isNull()) {
1022             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1023             return;
1024         }
1025     }
1026 
<a name="46" id="anc46"></a><span class="line-removed">1027     // 3.4.1.2 Object Store Storage Operation</span>
<span class="line-removed">1028     // If ObjectStore has a key path and the key is autogenerated, then inject the key into the value</span>
<span class="line-removed">1029     // using steps to assign a key to a value using a key path.</span>
<span class="line-removed">1030     ThreadSafeDataBuffer injectedRecordValue;</span>
<span class="line-removed">1031     if (usedKeyIsGenerated &amp;&amp; objectStoreInfo-&gt;keyPath()) {</span>
<span class="line-removed">1032         VM&amp; vm = databaseThreadVM();</span>
<span class="line-removed">1033         JSLockHolder locker(vm);</span>
<span class="line-removed">1034         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1035 </span>
<span class="line-removed">1036         auto value = deserializeIDBValueToJSValue(databaseThreadExecState(), originalRecordValue.data());</span>
<span class="line-removed">1037         if (value.isUndefined()) {</span>
<span class="line-removed">1038             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to deserialize record value for record key injection&quot;_s), usedKey));</span>
<span class="line-removed">1039             return;</span>
<span class="line-removed">1040         }</span>
<span class="line-removed">1041 </span>
<span class="line-removed">1042         if (!injectIDBKeyIntoScriptValue(databaseThreadExecState(), usedKey, value, objectStoreInfo-&gt;keyPath().value())) {</span>
<span class="line-removed">1043             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to inject record key into record value&quot;_s), usedKey));</span>
<span class="line-removed">1044             return;</span>
<span class="line-removed">1045         }</span>
<span class="line-removed">1046 </span>
<span class="line-removed">1047         auto serializedValue = SerializedScriptValue::create(databaseThreadExecState(), value);</span>
<span class="line-removed">1048         if (UNLIKELY(scope.exception())) {</span>
<span class="line-removed">1049             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to serialize record value after injecting record key&quot;_s), usedKey));</span>
<span class="line-removed">1050             return;</span>
<span class="line-removed">1051         }</span>
<span class="line-removed">1052 </span>
<span class="line-removed">1053         injectedRecordValue = ThreadSafeDataBuffer::copyVector(serializedValue-&gt;data());</span>
<span class="line-removed">1054     }</span>
<span class="line-removed">1055 </span>
1056     // 3.4.1 Object Store Storage Operation
1057     // ...If a record already exists in store ...
1058     // then remove the record from store using the steps for deleting records from an object store...
1059     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1060     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1061     if (!error.isNull()) {
1062         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1063         return;
1064     }
1065 
<a name="47" id="anc47"></a><span class="line-modified">1066     if (injectedRecordValue.data())</span>
<span class="line-removed">1067         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, { injectedRecordValue, originalRecordValue.blobURLs(), originalRecordValue.sessionID(), originalRecordValue.blobFilePaths() });</span>
<span class="line-removed">1068     else</span>
<span class="line-removed">1069         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
1070 
1071     if (!error.isNull()) {
1072         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1073         return;
1074     }
1075 
1076     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1077         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1078 
1079     generatedKeyResetter.release();
1080     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1081 }
1082 
1083 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1084 {
1085     ASSERT(isMainThread());
1086     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);
1087 
1088     performKeyDataCallback(callbackIdentifier, error, resultKey);
1089 }
1090 
1091 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1092 {
1093     ASSERT(isMainThread());
1094     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
1095 
<a name="48" id="anc48"></a>










1096     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1097     if (!callbackID)
1098         return;
1099 
1100     if (uint64_t indexIdentifier = requestData.indexIdentifier())
1101         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));
1102     else
1103         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));
1104 }
1105 
1106 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1107 {
1108     ASSERT(isMainThread());
1109     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
1110 
<a name="49" id="anc49"></a>










1111     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1112     if (!callbackID)
1113         return;
1114 
1115     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
1116 }
1117 
1118 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)
1119 {
1120     ASSERT(!isMainThread());
1121     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);
1122 
1123     ASSERT(m_backingStore);
1124 
1125     IDBGetResult result;
1126     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);
1127 
1128     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1129 }
1130 
1131 void UniqueIDBDatabase::performGetIndexRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range)
1132 {
1133     ASSERT(!isMainThread());
1134     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetIndexRecord&quot;);
1135 
1136     ASSERT(m_backingStore);
1137 
1138     IDBGetResult result;
1139     IDBError error = m_backingStore-&gt;getIndexRecord(transactionIdentifier, objectStoreIdentifier, indexIdentifier, recordType, range, result);
1140 
1141     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1142 }
1143 
1144 void UniqueIDBDatabase::didPerformGetRecord(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1145 {
1146     ASSERT(isMainThread());
1147     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetRecord&quot;);
1148 
1149     performGetResultCallback(callbackIdentifier, error, result);
1150 }
1151 
1152 void UniqueIDBDatabase::performGetAllRecords(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData)
1153 {
1154     ASSERT(!isMainThread());
1155     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetAllRecords&quot;);
1156 
1157     ASSERT(m_backingStore);
1158 
1159     IDBGetAllResult result;
1160     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);
1161 
1162     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));
1163 }
1164 
1165 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)
1166 {
1167     ASSERT(isMainThread());
1168     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);
1169 
1170     performGetAllResultsCallback(callbackIdentifier, error, result);
1171 }
1172 
1173 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1174 {
1175     ASSERT(isMainThread());
1176     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
1177 
<a name="50" id="anc50"></a>










1178     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1179     if (!callbackID)
1180         return;
1181     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
1182 }
1183 
1184 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)
1185 {
1186     ASSERT(!isMainThread());
1187     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);
1188 
1189     ASSERT(m_backingStore);
1190     ASSERT(objectStoreIdentifier);
1191 
1192     uint64_t count;
1193     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);
1194 
1195     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));
1196 }
1197 
1198 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1199 {
1200     ASSERT(isMainThread());
1201     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);
1202 
1203     performCountCallback(callbackIdentifier, error, count);
1204 }
1205 
1206 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1207 {
1208     ASSERT(isMainThread());
1209     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
1210 
<a name="51" id="anc51"></a>










1211     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1212     if (!callbackID)
1213         return;
1214     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
1215 }
1216 
1217 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
1218 {
1219     ASSERT(!isMainThread());
1220     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);
1221 
1222     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);
1223 
1224     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));
1225 }
1226 
1227 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)
1228 {
1229     ASSERT(isMainThread());
1230     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);
1231 
1232     performErrorCallback(callbackIdentifier, error);
1233 }
1234 
1235 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1236 {
1237     ASSERT(isMainThread());
1238     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
1239 
<a name="52" id="anc52"></a>










1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1241     if (!callbackID)
1242         return;
1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
1244 }
1245 
1246 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)
1247 {
1248     ASSERT(!isMainThread());
1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);
1250 
1251     IDBGetResult result;
1252     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);
1253 
1254     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));
1255 }
1256 
1257 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1258 {
1259     ASSERT(isMainThread());
1260     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);
1261 
1262     performGetResultCallback(callbackIdentifier, error, result);
1263 }
1264 
1265 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1266 {
1267     ASSERT(isMainThread());
1268     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
1269 
<a name="53" id="anc53"></a>










1270     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1271     if (!callbackID)
1272         return;
1273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
1274 }
1275 
1276 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)
1277 {
1278     ASSERT(!isMainThread());
1279     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);
1280 
1281     IDBGetResult result;
1282     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
1283 
1284     if (error.isNull()) {
1285         auto addResult = m_cursorPrefetches.add(cursorIdentifier);
1286         if (addResult.isNewEntry)
1287             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1288     }
1289 
1290     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformIterateCursor, callbackIdentifier, error, result));
1291 }
1292 
1293 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
1294 {
1295     ASSERT(!isMainThread());
1296     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));
1297     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);
1298 
1299     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))
1300         m_cursorPrefetches.remove(cursorIdentifier);
1301     else
1302         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1303 }
1304 
1305 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1306 {
1307     ASSERT(isMainThread());
1308     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
1309 
1310     performGetResultCallback(callbackIdentifier, error, result);
1311 }
1312 
<a name="54" id="anc54"></a><span class="line-modified">1313 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction)</span>
1314 {
1315     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
1316     if (!takenTransaction)
1317         return false;
1318 
1319     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
<a name="55" id="anc55"></a>
1320     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
1321 
1322     return true;
1323 }
1324 
1325 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1326 {
1327     ASSERT(isMainThread());
1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1329 
1330     ASSERT(transaction.databaseConnection().database() == this);
1331 
<a name="56" id="anc56"></a>














1332     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1333     if (!callbackID)
1334         return;
1335 
<a name="57" id="anc57"></a><span class="line-modified">1336     if (!prepareToFinishTransaction(transaction)) {</span>
1337         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1338             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
1339             forgetErrorCallback(callbackID);
1340             return;
1341         }
1342 
1343         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });
1344         return;
1345     }
1346 
1347     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));
1348 }
1349 
1350 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1351 {
1352     ASSERT(!isMainThread());
1353     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1354 
1355     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);
1356     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));
1357 }
1358 
1359 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1360 {
1361     ASSERT(isMainThread());
1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1363 
<a name="58" id="anc58"></a><span class="line-modified">1364     performErrorCallback(callbackIdentifier, error);</span>
















1365 
1366     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
1367 }
1368 
<a name="59" id="anc59"></a><span class="line-modified">1369 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
1370 {
1371     ASSERT(isMainThread());
1372     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1373 
1374     ASSERT(transaction.databaseConnection().database() == this);
1375 
<a name="60" id="anc60"></a>














1376     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1377     if (!callbackID)
1378         return;
1379 
<a name="61" id="anc61"></a><span class="line-modified">1380     if (!prepareToFinishTransaction(transaction)) {</span>
1381         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1382             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
1383             forgetErrorCallback(callbackID);
1384             return;
1385         }
1386 
1387         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });
1388         return;
1389     }
1390 
1391     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));
1392 }
1393 
1394 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
1395 {
1396     ASSERT(isMainThread());
1397     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
1398 
1399     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
1400     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
1401 
1402     m_versionChangeTransaction = nullptr;
1403     m_versionChangeDatabaseConnection = nullptr;
1404 
1405     if (m_hardClosedForUserDelete) {
1406         maybeFinishHardClose();
1407         return;
1408     }
1409 
1410     invokeOperationAndTransactionTimer();
1411 }
1412 
1413 void UniqueIDBDatabase::performAbortTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1414 {
1415     ASSERT(!isMainThread());
1416     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1417 
1418     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
1419     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));
1420 }
1421 
1422 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1423 {
1424     ASSERT(isMainThread());
1425     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1426 
1427     auto transaction = m_finishingTransactions.take(transactionIdentifier);
1428     ASSERT(transaction);
1429 
1430     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
1431         ASSERT(m_versionChangeTransaction == transaction);
1432         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1433         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
<a name="62" id="anc62"></a><span class="line-modified">1434         m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
1435     }
1436 
<a name="63" id="anc63"></a><span class="line-modified">1437     performErrorCallback(callbackIdentifier, error);</span>

1438 
1439     transactionCompleted(WTFMove(transaction));
1440 }
1441 
1442 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
1443 {
1444     if (m_versionChangeTransaction == &amp;transaction)
1445         m_versionChangeTransaction = nullptr;
1446 }
1447 
1448 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1449 {
1450     ASSERT(isMainThread());
1451     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1452 
<a name="64" id="anc64"></a>






1453     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1454     m_openDatabaseConnections.remove(&amp;connection);
1455 
1456     if (m_versionChangeDatabaseConnection == &amp;connection) {
1457         if (m_versionChangeTransaction) {
1458             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));
1459 
1460             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();
1461             if (m_inProgressTransactions.contains(transactionIdentifier)) {
1462                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));
1463                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
1464             }
1465 
1466             return;
1467         }
1468 
1469         m_versionChangeDatabaseConnection = nullptr;
1470     }
1471 
1472     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
1473     while (!m_pendingTransactions.isEmpty()) {
1474         auto transaction = m_pendingTransactions.takeFirst();
1475         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)
1476             pendingTransactions.append(WTFMove(transaction));
1477     }
1478 
1479     if (!pendingTransactions.isEmpty())
1480         m_pendingTransactions.swap(pendingTransactions);
1481 
1482     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;
1483     for (auto&amp; transaction : m_inProgressTransactions.values()) {
1484         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)
1485             transactionsToAbort.append(transaction);
1486     }
1487 
1488     for (auto&amp; transaction : transactionsToAbort)
1489         transaction-&gt;abortWithoutCallback();
1490 
1491     if (m_currentOpenDBRequest)
1492         notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
1493 
1494     if (connection.hasNonFinishedTransactions()) {
1495         m_clientClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1496         return;
1497     }
1498 
1499     if (m_hardClosedForUserDelete) {
1500         maybeFinishHardClose();
1501         return;
1502     }
1503 
1504     // Now that a database connection has closed, previously blocked operations might be runnable.
1505     invokeOperationAndTransactionTimer();
1506 }
1507 
1508 void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
1509 {
1510     ASSERT(isMainThread());
1511     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1512 
1513     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {
1514         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));
1515         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));
1516         return;
1517     }
1518 
1519     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1520     m_openDatabaseConnections.remove(&amp;connection);
1521 
1522     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1523 
1524     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1525 }
1526 
1527 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
1528 {
1529     ASSERT(isMainThread());
1530     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1531 
<a name="65" id="anc65"></a>



1532     if (m_hardClosedForUserDelete)
1533         maybeFinishHardClose();
<a name="66" id="anc66"></a><span class="line-removed">1534     ASSERT(m_serverClosePendingDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">1535     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
1536 }
1537 
1538 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1539 {
1540     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
1541     ASSERT(!m_hardClosedForUserDelete);
1542 
1543     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1544 
1545     m_pendingTransactions.append(WTFMove(transaction));
1546 
1547     invokeOperationAndTransactionTimer();
1548 }
1549 
1550 bool UniqueIDBDatabase::isCurrentlyInUse() const
1551 {
1552     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;
1553 }
1554 
1555 bool UniqueIDBDatabase::hasUnfinishedTransactions() const
1556 {
1557     return !m_inProgressTransactions.isEmpty() || !m_finishingTransactions.isEmpty();
1558 }
1559 
1560 void UniqueIDBDatabase::invokeOperationAndTransactionTimer()
1561 {
1562     LOG(IndexedDB, &quot;UniqueIDBDatabase::invokeOperationAndTransactionTimer()&quot;);
1563     RELEASE_ASSERT(!m_hardClosedForUserDelete);
1564     RELEASE_ASSERT(!m_owningPointerForClose);
1565 
1566     if (!m_operationAndTransactionTimer.isActive())
1567         m_operationAndTransactionTimer.startOneShot(0_s);
1568 }
1569 
1570 void UniqueIDBDatabase::operationAndTransactionTimerFired()
1571 {
1572     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::operationAndTransactionTimerFired&quot;);
1573     ASSERT(!m_hardClosedForUserDelete);
1574     ASSERT(isMainThread());
1575 
1576     // This UniqueIDBDatabase might be no longer in use by any web page.
1577     // Assuming it is not ephemeral, the server should now close it to free up resources.
1578     if (!m_backingStoreIsEphemeral &amp;&amp; !isCurrentlyInUse()) {
1579         ASSERT(m_pendingTransactions.isEmpty());
1580         ASSERT(!hasUnfinishedTransactions());
1581 
1582         scheduleShutdownForClose();
1583         return;
1584     }
1585 
1586     // The current operation might require multiple attempts to handle, so try to
1587     // make further progress on it now.
1588     if (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())
1589         handleCurrentOperation();
1590     else
1591         handleDatabaseOperations();
1592 
1593     bool hadDeferredTransactions = false;
1594     auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
1595 
1596     if (transaction) {
1597         m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
1598         for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1599             m_objectStoreTransactionCounts.add(objectStore);
1600             if (!transaction-&gt;isReadOnly()) {
1601                 m_objectStoreWriteTransactions.add(objectStore);
1602                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
1603             }
1604         }
1605 
1606         activateTransactionInBackingStore(*transaction);
1607 
1608         // If no transactions were deferred, it&#39;s possible we can start another transaction right now.
1609         if (!hadDeferredTransactions)
1610             invokeOperationAndTransactionTimer();
1611     }
1612 }
1613 
1614 void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
1615 {
1616     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::activateTransactionInBackingStore&quot;);
1617     ASSERT(isMainThread());
1618 
1619     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; refTransaction(&amp;transaction);
1620 
1621     ErrorCallback callback = [refTransaction](const IDBError&amp; error) {
1622         refTransaction-&gt;didActivateInBackingStore(error);
1623     };
1624 
1625     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1626     if (!callbackID)
1627         return;
1628     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performActivateTransactionInBackingStore, callbackID, transaction.info()));
1629 }
1630 
1631 void UniqueIDBDatabase::performActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBTransactionInfo&amp; info)
1632 {
1633     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performActivateTransactionInBackingStore&quot;);
1634 
1635     IDBError error = m_backingStore-&gt;beginTransaction(info);
1636     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformActivateTransactionInBackingStore, callbackIdentifier, error));
1637 }
1638 
1639 void UniqueIDBDatabase::didPerformActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBError&amp; error)
1640 {
1641     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformActivateTransactionInBackingStore&quot;);
1642 
1643     if (m_hardClosedForUserDelete)
1644         return;
1645 
1646     invokeOperationAndTransactionTimer();
1647 
1648     performErrorCallback(callbackIdentifier, error);
1649 }
1650 
1651 template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
1652 {
1653     for (auto scope : bScopes) {
1654         if (aScopes.contains(scope))
1655             return true;
1656     }
1657 
1658     return false;
1659 }
1660 
1661 RefPtr&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabase::takeNextRunnableTransaction(bool&amp; hadDeferredTransactions)
1662 {
1663     hadDeferredTransactions = false;
1664 
1665     if (m_pendingTransactions.isEmpty())
1666         return nullptr;
1667 
1668     if (!m_backingStoreSupportsSimultaneousTransactions &amp;&amp; hasUnfinishedTransactions()) {
1669         LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
1670         return nullptr;
1671     }
1672 
1673     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
1674     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; currentTransaction;
1675 
1676     HashSet&lt;uint64_t&gt; deferredReadWriteScopes;
1677 
1678     while (!m_pendingTransactions.isEmpty()) {
1679         currentTransaction = m_pendingTransactions.takeFirst();
1680 
1681         switch (currentTransaction-&gt;info().mode()) {
1682         case IDBTransactionMode::Readonly: {
1683             bool hasOverlappingScopes = scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1684             hasOverlappingScopes |= scopesOverlap(m_objectStoreWriteTransactions, currentTransaction-&gt;objectStoreIdentifiers());
1685 
1686             if (hasOverlappingScopes)
1687                 deferredTransactions.append(WTFMove(currentTransaction));
1688 
1689             break;
1690         }
1691         case IDBTransactionMode::Readwrite: {
1692             bool hasOverlappingScopes = scopesOverlap(m_objectStoreTransactionCounts, currentTransaction-&gt;objectStoreIdentifiers());
1693             hasOverlappingScopes |= scopesOverlap(deferredReadWriteScopes, currentTransaction-&gt;objectStoreIdentifiers());
1694 
1695             if (hasOverlappingScopes) {
1696                 for (auto objectStore : currentTransaction-&gt;objectStoreIdentifiers())
1697                     deferredReadWriteScopes.add(objectStore);
1698                 deferredTransactions.append(WTFMove(currentTransaction));
1699             }
1700 
1701             break;
1702         }
1703         case IDBTransactionMode::Versionchange:
1704             // Version change transactions should never be scheduled in the traditional manner.
1705             RELEASE_ASSERT_NOT_REACHED();
1706         }
1707 
1708         // If we didn&#39;t defer the currentTransaction above, it can be run now.
1709         if (currentTransaction)
1710             break;
1711     }
1712 
1713     hadDeferredTransactions = !deferredTransactions.isEmpty();
1714     if (!hadDeferredTransactions)
1715         return currentTransaction;
1716 
1717     // Prepend the deferred transactions back on the beginning of the deque for future scheduling passes.
1718     while (!deferredTransactions.isEmpty())
1719         m_pendingTransactions.prepend(deferredTransactions.takeLast());
1720 
1721     return currentTransaction;
1722 }
1723 
1724 void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1725 {
1726     ASSERT(transaction);
1727     ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
1728     ASSERT(!m_finishingTransactions.contains(transaction-&gt;info().identifier()));
1729     ASSERT(isMainThread());
1730 
1731     for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
1732         if (!transaction-&gt;isReadOnly()) {
1733             m_objectStoreWriteTransactions.remove(objectStore);
1734             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);
1735         }
1736         m_objectStoreTransactionCounts.remove(objectStore);
1737     }
1738 
1739     if (!transaction-&gt;databaseConnection().hasNonFinishedTransactions())
1740         m_clientClosePendingDatabaseConnections.remove(&amp;transaction-&gt;databaseConnection());
1741 
1742     if (m_versionChangeTransaction == transaction)
1743         m_versionChangeTransaction = nullptr;
1744 
1745     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.
1746     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.
1747     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {
1748         scheduleShutdownForClose();
1749         return;
1750     }
1751 
1752     // Previously blocked operations might be runnable.
1753     if (!m_hardClosedForUserDelete)
1754         invokeOperationAndTransactionTimer();
1755     else
1756         maybeFinishHardClose();
1757 }
1758 
1759 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
1760 {
1761     m_databaseQueue.append(WTFMove(task));
<a name="67" id="anc67"></a><span class="line-modified">1762     m_server.postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
1763 }
1764 
1765 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
1766 {
<a name="68" id="anc68"></a>


1767     m_databaseReplyQueue.append(WTFMove(task));
<a name="69" id="anc69"></a><span class="line-modified">1768     m_server.postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
1769 }
1770 
1771 void UniqueIDBDatabase::executeNextDatabaseTask()
1772 {
1773     ASSERT(!isMainThread());
1774     ASSERT(!m_databaseQueue.isKilled());
1775 
1776     auto task = m_databaseQueue.tryGetMessage();
1777     ASSERT(task);
1778 
1779     task-&gt;performTask();
1780 }
1781 
1782 void UniqueIDBDatabase::executeNextDatabaseTaskReply()
1783 {
1784     ASSERT(isMainThread());
1785     ASSERT(!m_databaseReplyQueue.isKilled());
1786 
1787     auto task = m_databaseReplyQueue.tryGetMessage();
1788     ASSERT(task);
1789 
1790     task-&gt;performTask();
1791 
1792     // If this database was force closed (e.g. for a user delete) and there are no more
1793     // cleanup tasks left, delete this.
1794     maybeFinishHardClose();
1795 }
1796 
1797 void UniqueIDBDatabase::maybeFinishHardClose()
1798 {
1799     if (m_owningPointerForClose &amp;&amp; isDoneWithHardClose()) {
1800         if (m_owningPointerReleaseScheduled)
1801             return;
1802         m_owningPointerReleaseScheduled = true;
1803 
1804         callOnMainThread([this] {
1805             ASSERT(isDoneWithHardClose());
1806             m_owningPointerForClose = nullptr;
1807         });
1808     }
1809 }
1810 
1811 bool UniqueIDBDatabase::isDoneWithHardClose()
1812 {
1813     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();
1814 }
1815 
1816 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
1817 {
1818     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
1819     if (request.isOpenRequest())
1820         request.connection().didOpenDatabase(result);
1821     else
1822         request.connection().didDeleteDatabase(result);
1823 }
1824 
1825 void UniqueIDBDatabase::immediateCloseForUserDelete()
1826 {
1827     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
1828 
1829     ASSERT(isMainThread());
1830 
<a name="70" id="anc70"></a>


1831     // Error out all transactions
1832     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
1833         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
1834 
1835     ASSERT(m_inProgressTransactions.isEmpty());
1836 
1837     for (auto&amp; transaction : m_pendingTransactions)
1838         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
1839     m_pendingTransactions.clear();
1840     m_objectStoreTransactionCounts.clear();
1841     m_objectStoreWriteTransactions.clear();
1842 
1843     // Error out all pending callbacks
1844     IDBError error = IDBError::userDeleteError();
1845     IDBKeyData keyData;
1846     IDBGetResult getResult;
1847     IDBGetAllResult getAllResult;
1848 
1849     while (!m_callbackQueue.isEmpty()) {
1850         auto identifier = m_callbackQueue.first();
1851         if (m_errorCallbacks.contains(identifier))
1852             performErrorCallback(identifier, error);
1853         else if (m_keyDataCallbacks.contains(identifier))
1854             performKeyDataCallback(identifier, error, keyData);
1855         else if (m_getResultCallbacks.contains(identifier))
1856             performGetResultCallback(identifier, error, getResult);
1857         else if (m_countCallbacks.contains(identifier))
1858             performCountCallback(identifier, error, 0);
1859         else if (m_getAllResultsCallbacks.contains(identifier))
1860             performGetAllResultsCallback(identifier, error, getAllResult);
1861         else
1862             ASSERT_NOT_REACHED();
1863     }
1864 
1865     // Error out all IDBOpenDBRequests
1866     if (m_currentOpenDBRequest) {
1867         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
1868         m_currentOpenDBRequest = nullptr;
1869     }
1870 
1871     for (auto&amp; request : m_pendingOpenDBRequests)
1872         errorOpenDBRequestForUserDelete(*request);
1873 
1874     m_pendingOpenDBRequests.clear();
1875 
1876     // Close all open connections
1877     auto openDatabaseConnections = m_openDatabaseConnections;
1878     for (auto&amp; connection : openDatabaseConnections)
1879         connectionClosedFromServer(*connection);
1880 
<a name="71" id="anc71"></a>




1881     // Cancel the operation timer
1882     m_operationAndTransactionTimer.stop();
1883 
1884     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
1885     // database connections confirm that they have closed.
1886     m_hardClosedForUserDelete = true;
1887 
1888     // If this database already owns itself, it is already closing on the background thread.
1889     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;
1890     // which will also cover this database.
1891     if (m_owningPointerForClose)
1892         return;
1893 
1894     // Otherwise, this database is still potentially active.
1895     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
<a name="72" id="anc72"></a><span class="line-modified">1896     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
1897     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
1898 }
1899 
<a name="73" id="anc73"></a>






















1900 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
1901 {
<a name="74" id="anc74"></a>

1902     auto callback = m_errorCallbacks.take(callbackIdentifier);
1903     ASSERT(callback || m_hardClosedForUserDelete);
1904     if (callback) {
1905         callback(error);
1906         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1907         m_callbackQueue.removeFirst();
1908     }
1909 }
1910 
1911 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1912 {
<a name="75" id="anc75"></a>

1913     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
1914     ASSERT(callback || m_hardClosedForUserDelete);
1915     if (callback) {
1916         callback(error, resultKey);
1917         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1918         m_callbackQueue.removeFirst();
1919     }
1920 }
1921 
1922 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)
1923 {
1924     auto callback = m_getResultCallbacks.take(callbackIdentifier);
1925     ASSERT(callback || m_hardClosedForUserDelete);
1926     if (callback) {
1927         callback(error, resultData);
1928         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1929         m_callbackQueue.removeFirst();
1930     }
1931 }
1932 
1933 void UniqueIDBDatabase::performGetAllResultsCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; resultData)
1934 {
1935     auto callback = m_getAllResultsCallbacks.take(callbackIdentifier);
1936     ASSERT(callback || m_hardClosedForUserDelete);
1937     if (callback) {
1938         callback(error, resultData);
1939         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1940         m_callbackQueue.removeFirst();
1941     }
1942 }
1943 
1944 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1945 {
1946     auto callback = m_countCallbacks.take(callbackIdentifier);
1947     ASSERT(callback || m_hardClosedForUserDelete);
1948     if (callback) {
1949         callback(error, count);
1950         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1951         m_callbackQueue.removeFirst();
1952     }
1953 }
1954 
1955 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
1956 {
<a name="76" id="anc76"></a>

1957     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
1958     ASSERT(m_callbackQueue.last() == callbackIdentifier);
1959     m_callbackQueue.removeLast();
1960     m_errorCallbacks.remove(callbackIdentifier);
1961 }
1962 
<a name="77" id="anc77"></a><span class="line-modified">1963 void UniqueIDBDatabase::setQuota(uint64_t quota)</span>
1964 {
<a name="78" id="anc78"></a><span class="line-modified">1965     if (m_backingStore)</span>
<span class="line-modified">1966         m_backingStore-&gt;setQuota(quota);</span>



































1967 }
1968 
1969 } // namespace IDBServer
1970 } // namespace WebCore
1971 
1972 #endif // ENABLE(INDEXED_DATABASE)
<a name="79" id="anc79"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="79" type="hidden" />
</body>
</html>