<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext3D.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext3DAttributes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext3D.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 


  28 #include &quot;ANGLEWebKitBridge.h&quot;
  29 #include &quot;GraphicsContext3DAttributes.h&quot;
  30 #include &quot;GraphicsTypes3D.h&quot;
  31 #include &quot;Image.h&quot;
  32 #include &quot;IntRect.h&quot;
  33 #include &quot;PlatformLayer.h&quot;
  34 #include &lt;memory&gt;
  35 #include &lt;wtf/HashCountedSet.h&gt;
  36 #include &lt;wtf/HashMap.h&gt;
  37 #include &lt;wtf/ListHashSet.h&gt;
  38 #include &lt;wtf/RefCounted.h&gt;
  39 #include &lt;wtf/RetainPtr.h&gt;
  40 #include &lt;wtf/UniqueArray.h&gt;
  41 #include &lt;wtf/text/WTFString.h&gt;
  42 
  43 #if USE(CA)
  44 #include &quot;PlatformCALayer.h&quot;
  45 #endif
  46 
  47 // FIXME: Find a better way to avoid the name confliction for NO_ERROR.
  48 #if PLATFORM(WIN)
  49 #undef NO_ERROR
  50 #elif PLATFORM(GTK)
  51 // This define is from the X11 headers, but it&#39;s used below, so we must undefine it.
  52 #undef VERSION
  53 #endif
  54 
  55 #if PLATFORM(COCOA)
  56 
  57 #if USE(OPENGL_ES)
  58 #include &lt;OpenGLES/ES2/gl.h&gt;
  59 #ifdef __OBJC__
  60 #import &lt;OpenGLES/EAGL.h&gt;
  61 typedef EAGLContext* PlatformGraphicsContext3D;
  62 #else
  63 typedef void* PlatformGraphicsContext3D;
  64 #endif // __OBJC__
  65 #endif // USE(OPENGL_ES)
  66 
<span class="line-modified">  67 #if !USE(OPENGL_ES)</span>
  68 typedef struct _CGLContextObject *CGLContextObj;
  69 typedef CGLContextObj PlatformGraphicsContext3D;
<span class="line-modified">  70 #endif</span>







  71 
  72 OBJC_CLASS CALayer;
  73 OBJC_CLASS WebGLLayer;
  74 typedef struct __IOSurface* IOSurfaceRef;
  75 #endif // PLATFORM(COCOA)
  76 
  77 #if USE(NICOSIA)
  78 namespace Nicosia {
  79 class GC3DLayer;
  80 }
  81 #endif
  82 
  83 #if !PLATFORM(COCOA)
  84 typedef unsigned GLuint;
  85 typedef void* PlatformGraphicsContext3D;
  86 typedef void* PlatformGraphicsSurface3D;
  87 #endif // !PLATFORM(COCOA)
  88 
  89 // These are currently the same among all implementations.
  90 const PlatformGraphicsContext3D NullPlatformGraphicsContext3D = 0;
  91 const Platform3DObject NullPlatform3DObject = 0;
  92 
  93 namespace WebCore {
  94 class Extensions3D;
  95 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
  96 class Extensions3DOpenGLES;
<span class="line-modified">  97 #else</span>
  98 class Extensions3DOpenGL;


  99 #endif
 100 class HostWindow;
 101 class Image;
 102 class ImageBuffer;
 103 class ImageData;
 104 class IntRect;
 105 class IntSize;
 106 class WebGLRenderingContextBase;
 107 #if USE(TEXTURE_MAPPER)
 108 class TextureMapperGC3DPlatformLayer;
 109 #endif
 110 
 111 typedef WTF::HashMap&lt;CString, uint64_t&gt; ShaderNameHash;
 112 
 113 struct ActiveInfo {
 114     String name;
 115     GC3Denum type;
 116     GC3Dint size;
 117 };
 118 
 119 class GraphicsContext3DPrivate;
 120 
 121 class GraphicsContext3D : public RefCounted&lt;GraphicsContext3D&gt; {
 122 public:









 123     enum {
 124         // WebGL 1 constants
 125         DEPTH_BUFFER_BIT = 0x00000100,
 126         STENCIL_BUFFER_BIT = 0x00000400,
 127         COLOR_BUFFER_BIT = 0x00004000,
 128         POINTS = 0x0000,
 129         LINES = 0x0001,
 130         LINE_LOOP = 0x0002,
 131         LINE_STRIP = 0x0003,
 132         TRIANGLES = 0x0004,
 133         TRIANGLE_STRIP = 0x0005,
 134         TRIANGLE_FAN = 0x0006,
 135         ZERO = 0,
 136         ONE = 1,
 137         SRC_COLOR = 0x0300,
 138         ONE_MINUS_SRC_COLOR = 0x0301,
 139         SRC_ALPHA = 0x0302,
 140         ONE_MINUS_SRC_ALPHA = 0x0303,
 141         DST_ALPHA = 0x0304,
 142         ONE_MINUS_DST_ALPHA = 0x0305,
</pre>
<hr />
<pre>
 747     void setErrorMessageCallback(std::unique_ptr&lt;ErrorMessageCallback&gt;);
 748 
 749     static RefPtr&lt;GraphicsContext3D&gt; create(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen);
 750     ~GraphicsContext3D();
 751 
 752 #if PLATFORM(COCOA)
 753     static Ref&lt;GraphicsContext3D&gt; createShared(GraphicsContext3D&amp; sharedContext);
 754 #endif
 755 
 756 #if PLATFORM(COCOA)
 757     PlatformGraphicsContext3D platformGraphicsContext3D() const { return m_contextObj; }
 758     Platform3DObject platformTexture() const { return m_texture; }
 759     CALayer* platformLayer() const { return reinterpret_cast&lt;CALayer*&gt;(m_webGLLayer.get()); }
 760 #else
 761     PlatformGraphicsContext3D platformGraphicsContext3D();
 762     Platform3DObject platformTexture() const;
 763     PlatformLayer* platformLayer() const;
 764 #endif
 765 
 766     bool makeContextCurrent();
<span class="line-modified"> 767     void setWebGLContext(WebGLRenderingContextBase* base) { m_webglContext = base; }</span>


 768 
 769     // With multisampling on, blit from multisampleFBO to regular FBO.
 770     void prepareTexture();
 771 
 772     // Equivalent to ::glTexImage2D(). Allows pixels==0 with no allocation.
 773     void texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
 774 
 775     // Get an attribute location without checking the name -&gt; mangledname mapping.
 776     int getAttribLocationDirect(Platform3DObject program, const String&amp; name);
 777 
 778     // Compile a shader without going through ANGLE.
 779     void compileShaderDirect(Platform3DObject);
 780 
 781     // Helper to texImage2D with pixel==0 case: pixels are initialized to 0.
 782     // Return true if no GL error is synthesized.
 783     // By default, alignment is 4, the OpenGL default setting.
 784     bool texImage2DResourceSafe(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint alignment = 4);
 785 
 786     bool isGLES2Compliant() const;
 787 
</pre>
<hr />
<pre>
1020     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject);
1021     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject, GC3Dint level);
1022     void frontFace(GC3Denum mode);
1023     void generateMipmap(GC3Denum target);
1024 
1025     bool getActiveAttrib(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1026     bool getActiveAttribImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1027     bool getActiveUniform(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1028     bool getActiveUniformImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1029     void getAttachedShaders(Platform3DObject program, GC3Dsizei maxCount, GC3Dsizei* count, Platform3DObject* shaders);
1030     GC3Dint getAttribLocation(Platform3DObject, const String&amp; name);
1031     void getBooleanv(GC3Denum pname, GC3Dboolean* value);
1032     void getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1033     GraphicsContext3DAttributes getContextAttributes();
1034     GC3Denum getError();
1035     void getFloatv(GC3Denum pname, GC3Dfloat* value);
1036     void getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value);
1037     void getIntegerv(GC3Denum pname, GC3Dint* value);
1038     void getInteger64v(GC3Denum pname, GC3Dint64* value);
1039     void getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value);

1040     void getNonBuiltInActiveSymbolCount(Platform3DObject program, GC3Denum pname, GC3Dint* value);

1041     String getProgramInfoLog(Platform3DObject);
1042     String getUnmangledInfoLog(Platform3DObject[2], GC3Dsizei, const String&amp;);
1043     void getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1044     void getShaderiv(Platform3DObject, GC3Denum pname, GC3Dint* value);
1045     String getShaderInfoLog(Platform3DObject);
1046     void getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType, GC3Dint* range, GC3Dint* precision);

1047     String getShaderSource(Platform3DObject);

1048     String getString(GC3Denum name);
1049     void getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value);
1050     void getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1051     void getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value);
1052     void getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value);
1053     GC3Dint getUniformLocation(Platform3DObject, const String&amp; name);
1054     void getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value);
1055     void getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value);
1056     GC3Dsizeiptr getVertexAttribOffset(GC3Duint index, GC3Denum pname);
1057 
1058     void hint(GC3Denum target, GC3Denum mode);
1059     GC3Dboolean isBuffer(Platform3DObject);
1060     GC3Dboolean isEnabled(GC3Denum cap);
1061     GC3Dboolean isFramebuffer(Platform3DObject);
1062     GC3Dboolean isProgram(Platform3DObject);
1063     GC3Dboolean isRenderbuffer(Platform3DObject);
1064     GC3Dboolean isShader(Platform3DObject);
1065     GC3Dboolean isTexture(Platform3DObject);
1066     void lineWidth(GC3Dfloat);
1067     void linkProgram(Platform3DObject);
</pre>
<hr />
<pre>
1093     void uniform1i(GC3Dint location, GC3Dint x);
1094     void uniform1iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1095     void uniform2f(GC3Dint location, GC3Dfloat x, GC3Dfloat y);
1096     void uniform2fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1097     void uniform2i(GC3Dint location, GC3Dint x, GC3Dint y);
1098     void uniform2iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1099     void uniform3f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1100     void uniform3fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1101     void uniform3i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z);
1102     void uniform3iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1103     void uniform4f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1104     void uniform4fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1105     void uniform4i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);
1106     void uniform4iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1107     void uniformMatrix2fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1108     void uniformMatrix3fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1109     void uniformMatrix4fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1110 
1111     void useProgram(Platform3DObject);
1112     void validateProgram(Platform3DObject);

1113     bool checkVaryingsPacking(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
1114     bool precisionsMatch(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;

1115 
1116     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);
1117     void vertexAttrib1fv(GC3Duint index, const GC3Dfloat* values);
1118     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);
1119     void vertexAttrib2fv(GC3Duint index, const GC3Dfloat* values);
1120     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1121     void vertexAttrib3fv(GC3Duint index, const GC3Dfloat* values);
1122     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1123     void vertexAttrib4fv(GC3Duint index, const GC3Dfloat* values);
1124     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,
1125                              GC3Dsizei stride, GC3Dintptr offset);
1126 
1127     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1128 
1129     void reshape(int width, int height);
1130 
1131     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);
1132     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset, GC3Dsizei primcount);
1133     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);
1134 
</pre>
<hr />
<pre>
1152     void paintRenderingResultsToCanvas(ImageBuffer*);
1153     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
1154     bool paintCompositedResultsToCanvas(ImageBuffer*);
1155 
1156 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
1157     void primitiveRestartIndex(GC3Duint);
1158 #endif
1159 
1160 #if PLATFORM(COCOA)
1161     bool texImageIOSurface2D(GC3Denum target, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, IOSurfaceRef, GC3Duint plane);
1162 
1163 #if USE(OPENGL_ES)
1164     void presentRenderbuffer();
1165 #endif
1166 
1167 #if USE(OPENGL)
1168     void allocateIOSurfaceBackingStore(IntSize);
1169     void updateFramebufferTextureBackingStoreFromLayer();
1170     void updateCGLContext();
1171 #endif





1172 #endif // PLATFORM(COCOA)
1173 
1174     void setContextVisibility(bool);
1175 
1176     GraphicsContext3DPowerPreference powerPreferenceUsedForCreation() const { return m_powerPreferenceUsedForCreation; }
1177 
1178     // Support for buffer creation and deletion
1179     Platform3DObject createBuffer();
1180     Platform3DObject createFramebuffer();
1181     Platform3DObject createProgram();
1182     Platform3DObject createRenderbuffer();
1183     Platform3DObject createShader(GC3Denum);
1184     Platform3DObject createTexture();
1185 
1186     void deleteBuffer(Platform3DObject);
1187     void deleteFramebuffer(Platform3DObject);
1188     void deleteProgram(Platform3DObject);
1189     void deleteRenderbuffer(Platform3DObject);
1190     void deleteShader(Platform3DObject);
1191     void deleteTexture(Platform3DObject);
</pre>
<hr />
<pre>
1328     void readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels);
1329 
1330 #if PLATFORM(IOS_FAMILY)
1331     void setRenderbufferStorageFromDrawable(GC3Dsizei width, GC3Dsizei height);
1332 #endif
1333 
1334     bool reshapeFBOs(const IntSize&amp;);
1335     void resolveMultisamplingIfNecessary(const IntRect&amp; = IntRect());
1336     void attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height);
1337 
1338 #if PLATFORM(COCOA)
1339     bool allowOfflineRenderers() const;
1340 #endif
1341 
1342     int m_currentWidth { 0 };
1343     int m_currentHeight { 0 };
1344 
1345 #if PLATFORM(COCOA)
1346     RetainPtr&lt;WebGLLayer&gt; m_webGLLayer;
1347     PlatformGraphicsContext3D m_contextObj { nullptr };
<span class="line-modified">1348 #endif</span>



1349 
1350 #if PLATFORM(WIN) &amp;&amp; USE(CA)
1351     RefPtr&lt;PlatformCALayer&gt; m_webGLLayer;
1352 #endif
1353 
1354     typedef HashMap&lt;String, sh::ShaderVariable&gt; ShaderSymbolMap;
1355 
1356     struct ShaderSourceEntry {
1357         GC3Denum type;
1358         String source;
1359         String translatedSource;
1360         String log;
1361         bool isValid;
1362         ShaderSymbolMap attributeMap;
1363         ShaderSymbolMap uniformMap;
1364         ShaderSymbolMap varyingMap;
1365         ShaderSourceEntry()
1366             : type(VERTEX_SHADER)
1367             , isValid(false)
1368         {
1369         }
1370 
1371         ShaderSymbolMap&amp; symbolMap(enum ANGLEShaderSymbolType symbolType)
1372         {
1373             ASSERT(symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE || symbolType == SHADER_SYMBOL_TYPE_UNIFORM || symbolType == SHADER_SYMBOL_TYPE_VARYING);
1374             if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE)
1375                 return attributeMap;
1376             if (symbolType == SHADER_SYMBOL_TYPE_VARYING)
1377                 return varyingMap;
1378             return uniformMap;
1379         }
1380     };
1381 

1382     // FIXME: Shaders are never removed from this map, even if they and their program are deleted.
1383     // This is bad, and it also relies on the fact we never reuse Platform3DObject numbers.
1384     typedef HashMap&lt;Platform3DObject, ShaderSourceEntry&gt; ShaderSourceMap;
1385     ShaderSourceMap m_shaderSourceMap;
1386 
1387     typedef HashMap&lt;Platform3DObject, std::pair&lt;Platform3DObject, Platform3DObject&gt;&gt; LinkedShaderMap;
1388     LinkedShaderMap m_linkedShaderMap;
1389 
1390     struct ActiveShaderSymbolCounts {
1391         Vector&lt;GC3Dint&gt; filteredToActualAttributeIndexMap;
1392         Vector&lt;GC3Dint&gt; filteredToActualUniformIndexMap;
1393 
1394         ActiveShaderSymbolCounts()
1395         {
1396         }
1397 
1398         GC3Dint countForType(GC3Denum activeType)
1399         {
1400             ASSERT(activeType == ACTIVE_ATTRIBUTES || activeType == ACTIVE_UNIFORMS);
1401             if (activeType == ACTIVE_ATTRIBUTES)
1402                 return filteredToActualAttributeIndexMap.size();
1403 
1404             return filteredToActualUniformIndexMap.size();
1405         }
1406     };
1407     typedef HashMap&lt;Platform3DObject, ActiveShaderSymbolCounts&gt; ShaderProgramSymbolCountMap;
1408     ShaderProgramSymbolCountMap m_shaderProgramSymbolCountMap;
1409 
1410     typedef HashMap&lt;String, String&gt; HashedSymbolMap;
1411     HashedSymbolMap m_possiblyUnusedAttributeMap;
1412 
1413     String mappedSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1414     String mappedSymbolName(Platform3DObject shaders[2], size_t count, const String&amp; name);
1415     String originalSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1416     Optional&lt;String&gt; mappedSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1417     Optional&lt;String&gt; originalSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1418 
1419     std::unique_ptr&lt;ShaderNameHash&gt; nameHashMapForShaders;

1420 
1421 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
1422     friend class Extensions3DOpenGLES;

1423     std::unique_ptr&lt;Extensions3DOpenGLES&gt; m_extensions;
<span class="line-modified">1424 #else</span>
1425     friend class Extensions3DOpenGL;

1426     std::unique_ptr&lt;Extensions3DOpenGL&gt; m_extensions;



1427 #endif
<span class="line-removed">1428     friend class Extensions3DOpenGLCommon;</span>
1429 
1430     GraphicsContext3DAttributes m_attrs;
1431     GraphicsContext3DPowerPreference m_powerPreferenceUsedForCreation { GraphicsContext3DPowerPreference::Default };
1432     RenderStyle m_renderStyle;
1433     Vector&lt;Vector&lt;float&gt;&gt; m_vertexArray;
1434 

1435     ANGLEWebKitBridge m_compiler;

1436 
1437     GC3Duint m_texture { 0 };
1438     GC3Duint m_fbo { 0 };
1439 #if USE(COORDINATED_GRAPHICS)
1440     GC3Duint m_compositorTexture { 0 };
1441     GC3Duint m_intermediateTexture { 0 };
1442 #endif
1443 
1444     GC3Duint m_depthBuffer { 0 };
1445     GC3Duint m_stencilBuffer { 0 };
1446     GC3Duint m_depthStencilBuffer { 0 };
1447 
1448     bool m_layerComposited { false };
1449     GC3Duint m_internalColorFormat { 0 };
1450 




1451     struct GraphicsContext3DState {
1452         GC3Duint boundFBO { 0 };
1453         GC3Denum activeTextureUnit { GraphicsContext3D::TEXTURE0 };
1454 
1455         using BoundTextureMap = HashMap&lt;GC3Denum,
1456             std::pair&lt;GC3Duint, GC3Denum&gt;,
1457             WTF::IntHash&lt;GC3Denum&gt;,
1458             WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;,
1459             WTF::PairHashTraits&lt;WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;
1460         &gt;;
1461         BoundTextureMap boundTextureMap;
1462         GC3Duint currentBoundTexture() const { return boundTexture(activeTextureUnit); }
1463         GC3Duint boundTexture(GC3Denum textureUnit) const
1464         {
1465             auto iterator = boundTextureMap.find(textureUnit);
1466             if (iterator != boundTextureMap.end())
1467                 return iterator-&gt;value.first;
1468             return 0;
1469         }
1470 
</pre>
<hr />
<pre>
1490 
1491     // For multisampling
1492     GC3Duint m_multisampleFBO { 0 };
1493     GC3Duint m_multisampleDepthStencilBuffer { 0 };
1494     GC3Duint m_multisampleColorBuffer { 0 };
1495 
1496     // Errors raised by synthesizeGLError().
1497     ListHashSet&lt;GC3Denum&gt; m_syntheticErrors;
1498 
1499 #if USE(NICOSIA) &amp;&amp; USE(TEXTURE_MAPPER)
1500     friend class Nicosia::GC3DLayer;
1501     std::unique_ptr&lt;Nicosia::GC3DLayer&gt; m_nicosiaLayer;
1502 #elif USE(TEXTURE_MAPPER)
1503     friend class TextureMapperGC3DPlatformLayer;
1504     std::unique_ptr&lt;TextureMapperGC3DPlatformLayer&gt; m_texmapLayer;
1505 #else
1506     friend class GraphicsContext3DPrivate;
1507     std::unique_ptr&lt;GraphicsContext3DPrivate&gt; m_private;
1508 #endif
1509 
<span class="line-modified">1510     // FIXME: Layering violation.</span>
<span class="line-removed">1511     WebGLRenderingContextBase* m_webglContext { nullptr };</span>
1512 
1513     bool m_isForWebGL2 { false };
1514     bool m_usingCoreProfile { false };
1515 
1516     unsigned m_statusCheckCount { 0 };
1517     bool m_failNextStatusCheck { false };
1518 
1519 #if USE(CAIRO)
1520     Platform3DObject m_vao { 0 };
1521 #endif
1522 
1523 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL)
1524     bool m_hasSwitchedToHighPerformanceGPU { false };
1525 #endif
1526 };
1527 
1528 } // namespace WebCore


</pre>
</td>
<td>
<hr />
<pre>
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
<span class="line-added">  28 #if ENABLE(WEBGL)</span>
<span class="line-added">  29 </span>
  30 #include &quot;ANGLEWebKitBridge.h&quot;
  31 #include &quot;GraphicsContext3DAttributes.h&quot;
  32 #include &quot;GraphicsTypes3D.h&quot;
  33 #include &quot;Image.h&quot;
  34 #include &quot;IntRect.h&quot;
  35 #include &quot;PlatformLayer.h&quot;
  36 #include &lt;memory&gt;
  37 #include &lt;wtf/HashCountedSet.h&gt;
  38 #include &lt;wtf/HashMap.h&gt;
  39 #include &lt;wtf/ListHashSet.h&gt;
  40 #include &lt;wtf/RefCounted.h&gt;
  41 #include &lt;wtf/RetainPtr.h&gt;
  42 #include &lt;wtf/UniqueArray.h&gt;
  43 #include &lt;wtf/text/WTFString.h&gt;
  44 
  45 #if USE(CA)
  46 #include &quot;PlatformCALayer.h&quot;
  47 #endif
  48 
  49 // FIXME: Find a better way to avoid the name confliction for NO_ERROR.
  50 #if PLATFORM(WIN)
  51 #undef NO_ERROR
  52 #elif PLATFORM(GTK)
  53 // This define is from the X11 headers, but it&#39;s used below, so we must undefine it.
  54 #undef VERSION
  55 #endif
  56 
  57 #if PLATFORM(COCOA)
  58 
  59 #if USE(OPENGL_ES)
  60 #include &lt;OpenGLES/ES2/gl.h&gt;
  61 #ifdef __OBJC__
  62 #import &lt;OpenGLES/EAGL.h&gt;
  63 typedef EAGLContext* PlatformGraphicsContext3D;
  64 #else
  65 typedef void* PlatformGraphicsContext3D;
  66 #endif // __OBJC__
  67 #endif // USE(OPENGL_ES)
  68 
<span class="line-modified">  69 #if USE(OPENGL)</span>
  70 typedef struct _CGLContextObject *CGLContextObj;
  71 typedef CGLContextObj PlatformGraphicsContext3D;
<span class="line-modified">  72 #endif // USE(OPENGL)</span>
<span class="line-added">  73 </span>
<span class="line-added">  74 #if USE(ANGLE)</span>
<span class="line-added">  75 typedef void* PlatformGraphicsContext3D;</span>
<span class="line-added">  76 typedef void* PlatformGraphicsContext3DDisplay;</span>
<span class="line-added">  77 typedef void* PlatformGraphicsContext3DSurface;</span>
<span class="line-added">  78 typedef void* PlatformGraphicsContext3DConfig;</span>
<span class="line-added">  79 #endif // USE(ANGLE)</span>
  80 
  81 OBJC_CLASS CALayer;
  82 OBJC_CLASS WebGLLayer;
  83 typedef struct __IOSurface* IOSurfaceRef;
  84 #endif // PLATFORM(COCOA)
  85 
  86 #if USE(NICOSIA)
  87 namespace Nicosia {
  88 class GC3DLayer;
  89 }
  90 #endif
  91 
  92 #if !PLATFORM(COCOA)
  93 typedef unsigned GLuint;
  94 typedef void* PlatformGraphicsContext3D;
  95 typedef void* PlatformGraphicsSurface3D;
  96 #endif // !PLATFORM(COCOA)
  97 
  98 // These are currently the same among all implementations.
  99 const PlatformGraphicsContext3D NullPlatformGraphicsContext3D = 0;
 100 const Platform3DObject NullPlatform3DObject = 0;
 101 
 102 namespace WebCore {
 103 class Extensions3D;
 104 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 105 class Extensions3DOpenGLES;
<span class="line-modified"> 106 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))</span>
 107 class Extensions3DOpenGL;
<span class="line-added"> 108 #elif USE(ANGLE)</span>
<span class="line-added"> 109 class Extensions3DANGLE;</span>
 110 #endif
 111 class HostWindow;
 112 class Image;
 113 class ImageBuffer;
 114 class ImageData;
 115 class IntRect;
 116 class IntSize;
 117 class WebGLRenderingContextBase;
 118 #if USE(TEXTURE_MAPPER)
 119 class TextureMapperGC3DPlatformLayer;
 120 #endif
 121 
 122 typedef WTF::HashMap&lt;CString, uint64_t&gt; ShaderNameHash;
 123 
 124 struct ActiveInfo {
 125     String name;
 126     GC3Denum type;
 127     GC3Dint size;
 128 };
 129 
 130 class GraphicsContext3DPrivate;
 131 
 132 class GraphicsContext3D : public RefCounted&lt;GraphicsContext3D&gt; {
 133 public:
<span class="line-added"> 134     class Client {</span>
<span class="line-added"> 135     public:</span>
<span class="line-added"> 136         virtual ~Client() { }</span>
<span class="line-added"> 137         virtual void didComposite() = 0;</span>
<span class="line-added"> 138         virtual void forceContextLost() = 0;</span>
<span class="line-added"> 139         virtual void recycleContext() = 0;</span>
<span class="line-added"> 140         virtual void dispatchContextChangedNotification() = 0;</span>
<span class="line-added"> 141     };</span>
<span class="line-added"> 142 </span>
 143     enum {
 144         // WebGL 1 constants
 145         DEPTH_BUFFER_BIT = 0x00000100,
 146         STENCIL_BUFFER_BIT = 0x00000400,
 147         COLOR_BUFFER_BIT = 0x00004000,
 148         POINTS = 0x0000,
 149         LINES = 0x0001,
 150         LINE_LOOP = 0x0002,
 151         LINE_STRIP = 0x0003,
 152         TRIANGLES = 0x0004,
 153         TRIANGLE_STRIP = 0x0005,
 154         TRIANGLE_FAN = 0x0006,
 155         ZERO = 0,
 156         ONE = 1,
 157         SRC_COLOR = 0x0300,
 158         ONE_MINUS_SRC_COLOR = 0x0301,
 159         SRC_ALPHA = 0x0302,
 160         ONE_MINUS_SRC_ALPHA = 0x0303,
 161         DST_ALPHA = 0x0304,
 162         ONE_MINUS_DST_ALPHA = 0x0305,
</pre>
<hr />
<pre>
 767     void setErrorMessageCallback(std::unique_ptr&lt;ErrorMessageCallback&gt;);
 768 
 769     static RefPtr&lt;GraphicsContext3D&gt; create(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen);
 770     ~GraphicsContext3D();
 771 
 772 #if PLATFORM(COCOA)
 773     static Ref&lt;GraphicsContext3D&gt; createShared(GraphicsContext3D&amp; sharedContext);
 774 #endif
 775 
 776 #if PLATFORM(COCOA)
 777     PlatformGraphicsContext3D platformGraphicsContext3D() const { return m_contextObj; }
 778     Platform3DObject platformTexture() const { return m_texture; }
 779     CALayer* platformLayer() const { return reinterpret_cast&lt;CALayer*&gt;(m_webGLLayer.get()); }
 780 #else
 781     PlatformGraphicsContext3D platformGraphicsContext3D();
 782     Platform3DObject platformTexture() const;
 783     PlatformLayer* platformLayer() const;
 784 #endif
 785 
 786     bool makeContextCurrent();
<span class="line-modified"> 787 </span>
<span class="line-added"> 788     void addClient(Client&amp; client) { m_clients.add(&amp;client); }</span>
<span class="line-added"> 789     void removeClient(Client&amp; client) { m_clients.remove(&amp;client); }</span>
 790 
 791     // With multisampling on, blit from multisampleFBO to regular FBO.
 792     void prepareTexture();
 793 
 794     // Equivalent to ::glTexImage2D(). Allows pixels==0 with no allocation.
 795     void texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
 796 
 797     // Get an attribute location without checking the name -&gt; mangledname mapping.
 798     int getAttribLocationDirect(Platform3DObject program, const String&amp; name);
 799 
 800     // Compile a shader without going through ANGLE.
 801     void compileShaderDirect(Platform3DObject);
 802 
 803     // Helper to texImage2D with pixel==0 case: pixels are initialized to 0.
 804     // Return true if no GL error is synthesized.
 805     // By default, alignment is 4, the OpenGL default setting.
 806     bool texImage2DResourceSafe(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint alignment = 4);
 807 
 808     bool isGLES2Compliant() const;
 809 
</pre>
<hr />
<pre>
1042     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject);
1043     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject, GC3Dint level);
1044     void frontFace(GC3Denum mode);
1045     void generateMipmap(GC3Denum target);
1046 
1047     bool getActiveAttrib(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1048     bool getActiveAttribImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1049     bool getActiveUniform(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1050     bool getActiveUniformImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1051     void getAttachedShaders(Platform3DObject program, GC3Dsizei maxCount, GC3Dsizei* count, Platform3DObject* shaders);
1052     GC3Dint getAttribLocation(Platform3DObject, const String&amp; name);
1053     void getBooleanv(GC3Denum pname, GC3Dboolean* value);
1054     void getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1055     GraphicsContext3DAttributes getContextAttributes();
1056     GC3Denum getError();
1057     void getFloatv(GC3Denum pname, GC3Dfloat* value);
1058     void getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value);
1059     void getIntegerv(GC3Denum pname, GC3Dint* value);
1060     void getInteger64v(GC3Denum pname, GC3Dint64* value);
1061     void getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value);
<span class="line-added">1062 #if !USE(ANGLE)</span>
1063     void getNonBuiltInActiveSymbolCount(Platform3DObject program, GC3Denum pname, GC3Dint* value);
<span class="line-added">1064 #endif // !USE(ANGLE)</span>
1065     String getProgramInfoLog(Platform3DObject);
1066     String getUnmangledInfoLog(Platform3DObject[2], GC3Dsizei, const String&amp;);
1067     void getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1068     void getShaderiv(Platform3DObject, GC3Denum pname, GC3Dint* value);
1069     String getShaderInfoLog(Platform3DObject);
1070     void getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType, GC3Dint* range, GC3Dint* precision);
<span class="line-added">1071 #if !USE(ANGLE)</span>
1072     String getShaderSource(Platform3DObject);
<span class="line-added">1073 #endif // !USE(ANGLE)</span>
1074     String getString(GC3Denum name);
1075     void getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value);
1076     void getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1077     void getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value);
1078     void getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value);
1079     GC3Dint getUniformLocation(Platform3DObject, const String&amp; name);
1080     void getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value);
1081     void getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value);
1082     GC3Dsizeiptr getVertexAttribOffset(GC3Duint index, GC3Denum pname);
1083 
1084     void hint(GC3Denum target, GC3Denum mode);
1085     GC3Dboolean isBuffer(Platform3DObject);
1086     GC3Dboolean isEnabled(GC3Denum cap);
1087     GC3Dboolean isFramebuffer(Platform3DObject);
1088     GC3Dboolean isProgram(Platform3DObject);
1089     GC3Dboolean isRenderbuffer(Platform3DObject);
1090     GC3Dboolean isShader(Platform3DObject);
1091     GC3Dboolean isTexture(Platform3DObject);
1092     void lineWidth(GC3Dfloat);
1093     void linkProgram(Platform3DObject);
</pre>
<hr />
<pre>
1119     void uniform1i(GC3Dint location, GC3Dint x);
1120     void uniform1iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1121     void uniform2f(GC3Dint location, GC3Dfloat x, GC3Dfloat y);
1122     void uniform2fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1123     void uniform2i(GC3Dint location, GC3Dint x, GC3Dint y);
1124     void uniform2iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1125     void uniform3f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1126     void uniform3fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1127     void uniform3i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z);
1128     void uniform3iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1129     void uniform4f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1130     void uniform4fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1131     void uniform4i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);
1132     void uniform4iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1133     void uniformMatrix2fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1134     void uniformMatrix3fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1135     void uniformMatrix4fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1136 
1137     void useProgram(Platform3DObject);
1138     void validateProgram(Platform3DObject);
<span class="line-added">1139 #if !USE(ANGLE)</span>
1140     bool checkVaryingsPacking(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
1141     bool precisionsMatch(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
<span class="line-added">1142 #endif</span>
1143 
1144     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);
1145     void vertexAttrib1fv(GC3Duint index, const GC3Dfloat* values);
1146     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);
1147     void vertexAttrib2fv(GC3Duint index, const GC3Dfloat* values);
1148     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1149     void vertexAttrib3fv(GC3Duint index, const GC3Dfloat* values);
1150     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1151     void vertexAttrib4fv(GC3Duint index, const GC3Dfloat* values);
1152     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,
1153                              GC3Dsizei stride, GC3Dintptr offset);
1154 
1155     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1156 
1157     void reshape(int width, int height);
1158 
1159     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);
1160     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset, GC3Dsizei primcount);
1161     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);
1162 
</pre>
<hr />
<pre>
1180     void paintRenderingResultsToCanvas(ImageBuffer*);
1181     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
1182     bool paintCompositedResultsToCanvas(ImageBuffer*);
1183 
1184 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
1185     void primitiveRestartIndex(GC3Duint);
1186 #endif
1187 
1188 #if PLATFORM(COCOA)
1189     bool texImageIOSurface2D(GC3Denum target, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, IOSurfaceRef, GC3Duint plane);
1190 
1191 #if USE(OPENGL_ES)
1192     void presentRenderbuffer();
1193 #endif
1194 
1195 #if USE(OPENGL)
1196     void allocateIOSurfaceBackingStore(IntSize);
1197     void updateFramebufferTextureBackingStoreFromLayer();
1198     void updateCGLContext();
1199 #endif
<span class="line-added">1200 </span>
<span class="line-added">1201 #if USE(ANGLE) &amp;&amp; PLATFORM(MAC)</span>
<span class="line-added">1202     void allocateIOSurfaceBackingStore(IntSize);</span>
<span class="line-added">1203     void updateFramebufferTextureBackingStoreFromLayer();</span>
<span class="line-added">1204 #endif</span>
1205 #endif // PLATFORM(COCOA)
1206 
1207     void setContextVisibility(bool);
1208 
1209     GraphicsContext3DPowerPreference powerPreferenceUsedForCreation() const { return m_powerPreferenceUsedForCreation; }
1210 
1211     // Support for buffer creation and deletion
1212     Platform3DObject createBuffer();
1213     Platform3DObject createFramebuffer();
1214     Platform3DObject createProgram();
1215     Platform3DObject createRenderbuffer();
1216     Platform3DObject createShader(GC3Denum);
1217     Platform3DObject createTexture();
1218 
1219     void deleteBuffer(Platform3DObject);
1220     void deleteFramebuffer(Platform3DObject);
1221     void deleteProgram(Platform3DObject);
1222     void deleteRenderbuffer(Platform3DObject);
1223     void deleteShader(Platform3DObject);
1224     void deleteTexture(Platform3DObject);
</pre>
<hr />
<pre>
1361     void readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels);
1362 
1363 #if PLATFORM(IOS_FAMILY)
1364     void setRenderbufferStorageFromDrawable(GC3Dsizei width, GC3Dsizei height);
1365 #endif
1366 
1367     bool reshapeFBOs(const IntSize&amp;);
1368     void resolveMultisamplingIfNecessary(const IntRect&amp; = IntRect());
1369     void attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height);
1370 
1371 #if PLATFORM(COCOA)
1372     bool allowOfflineRenderers() const;
1373 #endif
1374 
1375     int m_currentWidth { 0 };
1376     int m_currentHeight { 0 };
1377 
1378 #if PLATFORM(COCOA)
1379     RetainPtr&lt;WebGLLayer&gt; m_webGLLayer;
1380     PlatformGraphicsContext3D m_contextObj { nullptr };
<span class="line-modified">1381 #if USE(ANGLE)</span>
<span class="line-added">1382     PlatformGraphicsContext3DDisplay m_displayObj { nullptr };</span>
<span class="line-added">1383 #endif // USE(ANGLE)</span>
<span class="line-added">1384 #endif // PLATFORM(COCOA)</span>
1385 
1386 #if PLATFORM(WIN) &amp;&amp; USE(CA)
1387     RefPtr&lt;PlatformCALayer&gt; m_webGLLayer;
1388 #endif
1389 
1390     typedef HashMap&lt;String, sh::ShaderVariable&gt; ShaderSymbolMap;
1391 
1392     struct ShaderSourceEntry {
1393         GC3Denum type;
1394         String source;
1395         String translatedSource;
1396         String log;
1397         bool isValid;
1398         ShaderSymbolMap attributeMap;
1399         ShaderSymbolMap uniformMap;
1400         ShaderSymbolMap varyingMap;
1401         ShaderSourceEntry()
1402             : type(VERTEX_SHADER)
1403             , isValid(false)
1404         {
1405         }
1406 
1407         ShaderSymbolMap&amp; symbolMap(enum ANGLEShaderSymbolType symbolType)
1408         {
1409             ASSERT(symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE || symbolType == SHADER_SYMBOL_TYPE_UNIFORM || symbolType == SHADER_SYMBOL_TYPE_VARYING);
1410             if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE)
1411                 return attributeMap;
1412             if (symbolType == SHADER_SYMBOL_TYPE_VARYING)
1413                 return varyingMap;
1414             return uniformMap;
1415         }
1416     };
1417 
<span class="line-added">1418 #if !USE(ANGLE)</span>
1419     // FIXME: Shaders are never removed from this map, even if they and their program are deleted.
1420     // This is bad, and it also relies on the fact we never reuse Platform3DObject numbers.
1421     typedef HashMap&lt;Platform3DObject, ShaderSourceEntry&gt; ShaderSourceMap;
1422     ShaderSourceMap m_shaderSourceMap;
1423 
1424     typedef HashMap&lt;Platform3DObject, std::pair&lt;Platform3DObject, Platform3DObject&gt;&gt; LinkedShaderMap;
1425     LinkedShaderMap m_linkedShaderMap;
1426 
1427     struct ActiveShaderSymbolCounts {
1428         Vector&lt;GC3Dint&gt; filteredToActualAttributeIndexMap;
1429         Vector&lt;GC3Dint&gt; filteredToActualUniformIndexMap;
1430 
1431         ActiveShaderSymbolCounts()
1432         {
1433         }
1434 
1435         GC3Dint countForType(GC3Denum activeType)
1436         {
1437             ASSERT(activeType == ACTIVE_ATTRIBUTES || activeType == ACTIVE_UNIFORMS);
1438             if (activeType == ACTIVE_ATTRIBUTES)
1439                 return filteredToActualAttributeIndexMap.size();
1440 
1441             return filteredToActualUniformIndexMap.size();
1442         }
1443     };
1444     typedef HashMap&lt;Platform3DObject, ActiveShaderSymbolCounts&gt; ShaderProgramSymbolCountMap;
1445     ShaderProgramSymbolCountMap m_shaderProgramSymbolCountMap;
1446 
1447     typedef HashMap&lt;String, String&gt; HashedSymbolMap;
1448     HashedSymbolMap m_possiblyUnusedAttributeMap;
1449 
1450     String mappedSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1451     String mappedSymbolName(Platform3DObject shaders[2], size_t count, const String&amp; name);
1452     String originalSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1453     Optional&lt;String&gt; mappedSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1454     Optional&lt;String&gt; originalSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1455 
1456     std::unique_ptr&lt;ShaderNameHash&gt; nameHashMapForShaders;
<span class="line-added">1457 #endif // !USE(ANGLE)</span>
1458 
1459 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
1460     friend class Extensions3DOpenGLES;
<span class="line-added">1461     friend class Extensions3DOpenGLCommon;</span>
1462     std::unique_ptr&lt;Extensions3DOpenGLES&gt; m_extensions;
<span class="line-modified">1463 #elif USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))</span>
1464     friend class Extensions3DOpenGL;
<span class="line-added">1465     friend class Extensions3DOpenGLCommon;</span>
1466     std::unique_ptr&lt;Extensions3DOpenGL&gt; m_extensions;
<span class="line-added">1467 #elif USE(ANGLE)</span>
<span class="line-added">1468     friend class Extensions3DANGLE;</span>
<span class="line-added">1469     std::unique_ptr&lt;Extensions3DANGLE&gt; m_extensions;</span>
1470 #endif

1471 
1472     GraphicsContext3DAttributes m_attrs;
1473     GraphicsContext3DPowerPreference m_powerPreferenceUsedForCreation { GraphicsContext3DPowerPreference::Default };
1474     RenderStyle m_renderStyle;
1475     Vector&lt;Vector&lt;float&gt;&gt; m_vertexArray;
1476 
<span class="line-added">1477 #if !USE(ANGLE)</span>
1478     ANGLEWebKitBridge m_compiler;
<span class="line-added">1479 #endif</span>
1480 
1481     GC3Duint m_texture { 0 };
1482     GC3Duint m_fbo { 0 };
1483 #if USE(COORDINATED_GRAPHICS)
1484     GC3Duint m_compositorTexture { 0 };
1485     GC3Duint m_intermediateTexture { 0 };
1486 #endif
1487 
1488     GC3Duint m_depthBuffer { 0 };
1489     GC3Duint m_stencilBuffer { 0 };
1490     GC3Duint m_depthStencilBuffer { 0 };
1491 
1492     bool m_layerComposited { false };
1493     GC3Duint m_internalColorFormat { 0 };
1494 
<span class="line-added">1495 #if USE(ANGLE)</span>
<span class="line-added">1496     PlatformGraphicsContext3DSurface m_pbuffer;</span>
<span class="line-added">1497 #endif</span>
<span class="line-added">1498 </span>
1499     struct GraphicsContext3DState {
1500         GC3Duint boundFBO { 0 };
1501         GC3Denum activeTextureUnit { GraphicsContext3D::TEXTURE0 };
1502 
1503         using BoundTextureMap = HashMap&lt;GC3Denum,
1504             std::pair&lt;GC3Duint, GC3Denum&gt;,
1505             WTF::IntHash&lt;GC3Denum&gt;,
1506             WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;,
1507             WTF::PairHashTraits&lt;WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;
1508         &gt;;
1509         BoundTextureMap boundTextureMap;
1510         GC3Duint currentBoundTexture() const { return boundTexture(activeTextureUnit); }
1511         GC3Duint boundTexture(GC3Denum textureUnit) const
1512         {
1513             auto iterator = boundTextureMap.find(textureUnit);
1514             if (iterator != boundTextureMap.end())
1515                 return iterator-&gt;value.first;
1516             return 0;
1517         }
1518 
</pre>
<hr />
<pre>
1538 
1539     // For multisampling
1540     GC3Duint m_multisampleFBO { 0 };
1541     GC3Duint m_multisampleDepthStencilBuffer { 0 };
1542     GC3Duint m_multisampleColorBuffer { 0 };
1543 
1544     // Errors raised by synthesizeGLError().
1545     ListHashSet&lt;GC3Denum&gt; m_syntheticErrors;
1546 
1547 #if USE(NICOSIA) &amp;&amp; USE(TEXTURE_MAPPER)
1548     friend class Nicosia::GC3DLayer;
1549     std::unique_ptr&lt;Nicosia::GC3DLayer&gt; m_nicosiaLayer;
1550 #elif USE(TEXTURE_MAPPER)
1551     friend class TextureMapperGC3DPlatformLayer;
1552     std::unique_ptr&lt;TextureMapperGC3DPlatformLayer&gt; m_texmapLayer;
1553 #else
1554     friend class GraphicsContext3DPrivate;
1555     std::unique_ptr&lt;GraphicsContext3DPrivate&gt; m_private;
1556 #endif
1557 
<span class="line-modified">1558     HashSet&lt;Client*&gt; m_clients;</span>

1559 
1560     bool m_isForWebGL2 { false };
1561     bool m_usingCoreProfile { false };
1562 
1563     unsigned m_statusCheckCount { 0 };
1564     bool m_failNextStatusCheck { false };
1565 
1566 #if USE(CAIRO)
1567     Platform3DObject m_vao { 0 };
1568 #endif
1569 
1570 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL)
1571     bool m_hasSwitchedToHighPerformanceGPU { false };
1572 #endif
1573 };
1574 
1575 } // namespace WebCore
<span class="line-added">1576 </span>
<span class="line-added">1577 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext3DAttributes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>