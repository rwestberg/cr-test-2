<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringView.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 #include &lt;wtf/Optional.h&gt;
  32 #include &lt;wtf/RetainPtr.h&gt;
  33 #include &lt;wtf/Vector.h&gt;
  34 #include &lt;wtf/text/CString.h&gt;
  35 #include &lt;wtf/text/ConversionMode.h&gt;
  36 #include &lt;wtf/text/LChar.h&gt;
  37 #include &lt;wtf/text/StringCommon.h&gt;
  38 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  39 
  40 // FIXME: Enabling the StringView lifetime checking causes the MSVC build to fail. Figure out why.
  41 #if defined(NDEBUG) || COMPILER(MSVC)
  42 #define CHECK_STRINGVIEW_LIFETIME 0
  43 #else
  44 #define CHECK_STRINGVIEW_LIFETIME 1
  45 #endif
  46 
  47 namespace WTF {
  48 
  49 // StringView is a non-owning reference to a string, similar to the proposed std::string_view.
  50 
<span class="line-modified">  51 class StringView {</span>

  52 public:
  53     StringView();
  54 #if CHECK_STRINGVIEW_LIFETIME
  55     ~StringView();
  56     StringView(StringView&amp;&amp;);
  57     StringView(const StringView&amp;);
  58     StringView&amp; operator=(StringView&amp;&amp;);
  59     StringView&amp; operator=(const StringView&amp;);
  60 #endif
  61 
<span class="line-modified">  62     StringView(const AtomicString&amp;);</span>
  63     StringView(const String&amp;);
  64     StringView(const StringImpl&amp;);
  65     StringView(const StringImpl*);
  66     StringView(const LChar*, unsigned length);
  67     StringView(const UChar*, unsigned length);
  68     StringView(const char*);

  69 
  70     static StringView empty();
  71 
  72     unsigned length() const;
  73     bool isEmpty() const;
  74 
  75     explicit operator bool() const;
  76     bool isNull() const;
  77 
  78     UChar operator[](unsigned index) const;
  79 
  80     class CodeUnits;
  81     CodeUnits codeUnits() const;
  82 
  83     class CodePoints;
  84     CodePoints codePoints() const;
  85 
  86     class GraphemeClusters;
  87     GraphemeClusters graphemeClusters() const;
  88 
  89     bool is8Bit() const;
  90     const LChar* characters8() const;
  91     const UChar* characters16() const;
  92 
  93     String toString() const;
  94     String toStringWithoutCopying() const;
<span class="line-modified">  95     AtomicString toAtomicString() const;</span>
<span class="line-modified">  96     RefPtr&lt;AtomicStringImpl&gt; toExistingAtomicString() const;</span>
  97 
  98 #if USE(CF)
<span class="line-modified">  99     // This function converts null strings to empty strings.</span>
 100     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFString() const;
 101     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFStringWithoutCopying() const;
 102 #endif
 103 
 104 #ifdef __OBJC__
 105     // These functions convert null strings to empty strings.
 106     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSString() const;
 107     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSStringWithoutCopying() const;
 108 #endif
 109 
 110     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 111     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 112 
 113     class UpconvertedCharacters;
 114     UpconvertedCharacters upconvertedCharacters() const;
 115 
 116     void getCharactersWithUpconvert(LChar*) const;
 117     void getCharactersWithUpconvert(UChar*) const;
 118 
 119     StringView substring(unsigned start, unsigned length = std::numeric_limits&lt;unsigned&gt;::max()) const;
<span class="line-modified"> 120     StringView left(unsigned len) const { return substring(0, len); }</span>
<span class="line-modified"> 121     StringView right(unsigned len) const { return substring(length() - len, len); }</span>
 122 
 123     template&lt;typename MatchedCharacterPredicate&gt;
 124     StringView stripLeadingAndTrailingMatchedCharacters(const MatchedCharacterPredicate&amp;);
 125 
 126     class SplitResult;
 127     SplitResult split(UChar) const;
 128     SplitResult splitAllowingEmptyEntries(UChar) const;
 129 
 130     size_t find(UChar, unsigned start = 0) const;
 131     size_t find(CodeUnitMatchFunction, unsigned start = 0) const;
 132 
 133     WTF_EXPORT_PRIVATE size_t find(StringView, unsigned start) const;
 134 
<span class="line-modified"> 135     size_t reverseFind(UChar, unsigned index = UINT_MAX) const;</span>
 136 
 137     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;) const;
 138     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 139 
 140     WTF_EXPORT_PRIVATE String convertToASCIILowercase() const;
 141     WTF_EXPORT_PRIVATE String convertToASCIIUppercase() const;
 142 
 143     bool contains(UChar) const;

 144     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;) const;
 145     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 146 

 147     WTF_EXPORT_PRIVATE bool startsWith(const StringView&amp;) const;
 148     WTF_EXPORT_PRIVATE bool startsWithIgnoringASCIICase(const StringView&amp;) const;
 149 
 150     WTF_EXPORT_PRIVATE bool endsWith(const StringView&amp;) const;
 151     WTF_EXPORT_PRIVATE bool endsWithIgnoringASCIICase(const StringView&amp;) const;
 152 
 153     int toInt() const;
 154     int toInt(bool&amp; isValid) const;
 155     int toIntStrict(bool&amp; isValid) const;
 156     Optional&lt;uint64_t&gt; toUInt64Strict() const;
 157     float toFloat(bool&amp; isValid) const;
 158 
 159     static void invalidate(const StringImpl&amp;);
 160 
 161     struct UnderlyingString;
 162 
 163 private:
 164     friend bool equal(StringView, StringView);
 165 
 166     void initialize(const LChar*, unsigned length);
 167     void initialize(const UChar*, unsigned length);
 168 
 169     template&lt;typename CharacterType, typename MatchedCharacterPredicate&gt;
 170     StringView stripLeadingAndTrailingMatchedCharacters(const CharacterType*, const MatchedCharacterPredicate&amp;);
 171 
 172 #if CHECK_STRINGVIEW_LIFETIME
 173     WTF_EXPORT_PRIVATE bool underlyingStringIsValid() const;
 174     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringImpl*);
 175     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringView&amp;);

 176 #else
 177     bool underlyingStringIsValid() const { return true; }
 178     void setUnderlyingString(const StringImpl*) { }
 179     void setUnderlyingString(const StringView&amp;) { }
 180 #endif
 181     void clear();
 182 
 183     const void* m_characters { nullptr };
 184     unsigned m_length { 0 };
 185     bool m_is8Bit { true };
 186 
 187 #if CHECK_STRINGVIEW_LIFETIME
<span class="line-removed"> 188     void adoptUnderlyingString(UnderlyingString*);</span>
 189     UnderlyingString* m_underlyingString { nullptr };
 190 #endif
 191 };
 192 
 193 template&lt;typename CharacterType, size_t inlineCapacity&gt; void append(Vector&lt;CharacterType, inlineCapacity&gt;&amp;, StringView);
 194 
 195 bool equal(StringView, StringView);
 196 bool equal(StringView, const LChar* b);
 197 
 198 bool equalIgnoringASCIICase(StringView, StringView);
 199 bool equalIgnoringASCIICase(StringView, const char*);
 200 
 201 template&lt;unsigned length&gt; bool equalLettersIgnoringASCIICase(StringView, const char (&amp;lowercaseLetters)[length]);
 202 
 203 inline bool operator==(StringView a, StringView b) { return equal(a, b); }
 204 inline bool operator==(StringView a, const LChar *b);
 205 inline bool operator==(StringView a, const char *b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 206 inline bool operator==(const char* a, StringView b) { return equal(b, a); }
 207 
 208 inline bool operator!=(StringView a, StringView b) { return !equal(a, b); }
 209 inline bool operator!=(StringView a, const LChar* b) { return !equal(a, b); }
 210 inline bool operator!=(StringView a, const char* b) { return !equal(a, b); }
 211 inline bool operator!=(const LChar*a, StringView b) { return !equal(b, a); }
 212 inline bool operator!=(const char*a, StringView b) { return !equal(b, a); }
 213 
 214 struct StringViewWithUnderlyingString;
 215 
 216 // This returns a StringView of the normalized result, and a String that is either
 217 // null, if the input was already normalized, or contains the normalized result
 218 // and needs to be kept around so the StringView remains valid. Typically the
 219 // easiest way to use it correctly is to put it into a local and use the StringView.
 220 WTF_EXPORT_PRIVATE StringViewWithUnderlyingString normalizedNFC(StringView);
 221 
 222 WTF_EXPORT_PRIVATE String normalizedNFC(const String&amp;);
 223 
 224 }
 225 
<span class="line-modified"> 226 #include &lt;wtf/text/AtomicString.h&gt;</span>
 227 #include &lt;wtf/text/WTFString.h&gt;
 228 
 229 namespace WTF {
 230 
 231 struct StringViewWithUnderlyingString {

 232     StringView view;
 233     String underlyingString;
 234 };
 235 
 236 inline StringView::StringView()
 237 {
 238 }
 239 
 240 #if CHECK_STRINGVIEW_LIFETIME
 241 
 242 inline StringView::~StringView()
 243 {
 244     setUnderlyingString(nullptr);
 245 }
 246 
 247 inline StringView::StringView(StringView&amp;&amp; other)
 248     : m_characters(other.m_characters)
 249     , m_length(other.m_length)
 250     , m_is8Bit(other.m_is8Bit)
 251 {
</pre>
<hr />
<pre>
 310     m_characters = characters;
 311     m_length = length;
 312     m_is8Bit = false;
 313 }
 314 
 315 inline StringView::StringView(const LChar* characters, unsigned length)
 316 {
 317     initialize(characters, length);
 318 }
 319 
 320 inline StringView::StringView(const UChar* characters, unsigned length)
 321 {
 322     initialize(characters, length);
 323 }
 324 
 325 inline StringView::StringView(const char* characters)
 326 {
 327     initialize(reinterpret_cast&lt;const LChar*&gt;(characters), strlen(characters));
 328 }
 329 





 330 inline StringView::StringView(const StringImpl&amp; string)
 331 {
 332     setUnderlyingString(&amp;string);
 333     if (string.is8Bit())
 334         initialize(string.characters8(), string.length());
 335     else
 336         initialize(string.characters16(), string.length());
 337 }
 338 
 339 inline StringView::StringView(const StringImpl* string)
 340 {
 341     if (!string)
 342         return;
 343 
 344     setUnderlyingString(string);
 345     if (string-&gt;is8Bit())
 346         initialize(string-&gt;characters8(), string-&gt;length());
 347     else
 348         initialize(string-&gt;characters16(), string-&gt;length());
 349 }
 350 
 351 inline StringView::StringView(const String&amp; string)
 352 {
 353     setUnderlyingString(string.impl());
 354     if (!string.impl()) {
 355         clear();
 356         return;
 357     }
 358     if (string.is8Bit()) {
 359         initialize(string.characters8(), string.length());
 360         return;
 361     }
 362     initialize(string.characters16(), string.length());
 363 }
 364 
<span class="line-modified"> 365 inline StringView::StringView(const AtomicString&amp; atomicString)</span>
<span class="line-modified"> 366     : StringView(atomicString.string())</span>
 367 {
 368 }
 369 
 370 inline void StringView::clear()
 371 {
 372     m_characters = nullptr;
 373     m_length = 0;
 374     m_is8Bit = true;
 375 }
 376 
 377 inline StringView StringView::empty()
 378 {
<span class="line-modified"> 379     return StringView(reinterpret_cast&lt;const LChar*&gt;(&quot;&quot;), 0);</span>
 380 }
 381 
 382 inline const LChar* StringView::characters8() const
 383 {
 384     ASSERT(is8Bit());
 385     ASSERT(underlyingStringIsValid());
 386     return static_cast&lt;const LChar*&gt;(m_characters);
 387 }
 388 
 389 inline const UChar* StringView::characters16() const
 390 {
 391     ASSERT(!is8Bit());
 392     ASSERT(underlyingStringIsValid());
 393     return static_cast&lt;const UChar*&gt;(m_characters);
 394 }
 395 
 396 class StringView::UpconvertedCharacters {

 397 public:
 398     explicit UpconvertedCharacters(const StringView&amp;);
 399     operator const UChar*() const { return m_characters; }
 400     const UChar* get() const { return m_characters; }
 401 private:
 402     Vector&lt;UChar, 32&gt; m_upconvertedCharacters;
 403     const UChar* m_characters;
 404 };
 405 
 406 inline StringView::UpconvertedCharacters StringView::upconvertedCharacters() const
 407 {
 408     return UpconvertedCharacters(*this);
 409 }
 410 
 411 inline bool StringView::isNull() const
 412 {
 413     return !m_characters;
 414 }
 415 
 416 inline bool StringView::isEmpty() const
</pre>
<hr />
<pre>
 451         return result;
 452     }
 453     StringView result(characters16() + start, length);
 454     result.setUnderlyingString(*this);
 455     return result;
 456 }
 457 
 458 inline UChar StringView::operator[](unsigned index) const
 459 {
 460     ASSERT(index &lt; length());
 461     if (is8Bit())
 462         return characters8()[index];
 463     return characters16()[index];
 464 }
 465 
 466 inline bool StringView::contains(UChar character) const
 467 {
 468     return find(character) != notFound;
 469 }
 470 





 471 inline void StringView::getCharactersWithUpconvert(LChar* destination) const
 472 {
 473     ASSERT(is8Bit());
 474     StringImpl::copyCharacters(destination, characters8(), m_length);
 475 }
 476 
 477 inline void StringView::getCharactersWithUpconvert(UChar* destination) const
 478 {
 479     if (is8Bit()) {
 480         StringImpl::copyCharacters(destination, characters8(), m_length);
 481         return;
 482     }
 483     StringImpl::copyCharacters(destination, characters16(), m_length);
 484 }
 485 
 486 inline StringView::UpconvertedCharacters::UpconvertedCharacters(const StringView&amp; string)
 487 {
 488     if (!string.is8Bit()) {
 489         m_characters = string.characters16();
 490         return;
 491     }
 492     const LChar* characters8 = string.characters8();
 493     unsigned length = string.m_length;
 494     m_upconvertedCharacters.reserveInitialCapacity(length);
 495     for (unsigned i = 0; i &lt; length; ++i)
 496         m_upconvertedCharacters.uncheckedAppend(characters8[i]);
 497     m_characters = m_upconvertedCharacters.data();
 498 }
 499 
 500 inline String StringView::toString() const
 501 {
 502     if (is8Bit())
 503         return String(characters8(), m_length);
 504     return String(characters16(), m_length);
 505 }
 506 
<span class="line-modified"> 507 inline AtomicString StringView::toAtomicString() const</span>
 508 {
 509     if (is8Bit())
<span class="line-modified"> 510         return AtomicString(characters8(), m_length);</span>
<span class="line-modified"> 511     return AtomicString(characters16(), m_length);</span>
 512 }
 513 
<span class="line-modified"> 514 inline RefPtr&lt;AtomicStringImpl&gt; StringView::toExistingAtomicString() const</span>
 515 {
 516     if (is8Bit())
<span class="line-modified"> 517         return AtomicStringImpl::lookUp(characters8(), m_length);</span>
<span class="line-modified"> 518     return AtomicStringImpl::lookUp(characters16(), m_length);</span>
 519 }
 520 
 521 inline float StringView::toFloat(bool&amp; isValid) const
 522 {
 523     if (is8Bit())
 524         return charactersToFloat(characters8(), m_length, &amp;isValid);
 525     return charactersToFloat(characters16(), m_length, &amp;isValid);
 526 }
 527 
 528 inline int StringView::toInt() const
 529 {
 530     bool isValid;
 531     return toInt(isValid);
 532 }
 533 
 534 inline int StringView::toInt(bool&amp; isValid) const
 535 {
 536     if (is8Bit())
 537         return charactersToInt(characters8(), m_length, &amp;isValid);
 538     return charactersToInt(characters16(), m_length, &amp;isValid);
</pre>
<hr />
<pre>
 630     unsigned aLength = a.length();
 631     if (aLength != strlen(reinterpret_cast&lt;const char*&gt;(b)))
 632         return false;
 633 
 634     if (a.is8Bit())
 635         return equal(a.characters8(), b, aLength);
 636     return equal(a.characters16(), b, aLength);
 637 }
 638 
 639 inline bool equalIgnoringASCIICase(StringView a, StringView b)
 640 {
 641     return equalIgnoringASCIICaseCommon(a, b);
 642 }
 643 
 644 inline bool equalIgnoringASCIICase(StringView a, const char* b)
 645 {
 646     return equalIgnoringASCIICaseCommon(a, b);
 647 }
 648 
 649 class StringView::SplitResult {

 650 public:
 651     SplitResult(StringView, UChar separator, bool allowEmptyEntries);
 652 
 653     class Iterator;
 654     Iterator begin() const;
 655     Iterator end() const;
 656 
 657 private:
 658     StringView m_string;
 659     UChar m_separator;
 660     bool m_allowEmptyEntries;
 661 };
 662 
 663 class StringView::GraphemeClusters {

 664 public:
 665     explicit GraphemeClusters(const StringView&amp;);
 666 
 667     class Iterator;
 668     Iterator begin() const;
 669     Iterator end() const;
 670 
 671 private:
 672     StringView m_stringView;
 673 };
 674 
 675 class StringView::CodePoints {

 676 public:
 677     explicit CodePoints(const StringView&amp;);
 678 
 679     class Iterator;
 680     Iterator begin() const;
 681     Iterator end() const;
 682 
 683 private:
 684     StringView m_stringView;
 685 };
 686 
 687 class StringView::CodeUnits {

 688 public:
 689     explicit CodeUnits(const StringView&amp;);
 690 
 691     class Iterator;
 692     Iterator begin() const;
 693     Iterator end() const;
 694 
 695 private:
 696     StringView m_stringView;
 697 };
 698 
 699 class StringView::SplitResult::Iterator {

 700 public:
 701     StringView operator*() const;
 702 
 703     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 704 
 705     bool operator==(const Iterator&amp;) const;
 706     bool operator!=(const Iterator&amp;) const;
 707 
 708 private:
 709     enum PositionTag { AtEnd };
 710     Iterator(const SplitResult&amp;);
 711     Iterator(const SplitResult&amp;, PositionTag);
 712 
 713     WTF_EXPORT_PRIVATE void findNextSubstring();
 714 
 715     friend SplitResult;
 716 
 717     const SplitResult&amp; m_result;
 718     unsigned m_position { 0 };
 719     unsigned m_length;
 720     bool m_isDone;
 721 };
 722 
 723 class StringView::GraphemeClusters::Iterator {

 724 public:
 725     Iterator() = delete;
 726     WTF_EXPORT_PRIVATE Iterator(const StringView&amp;, unsigned index);
 727     WTF_EXPORT_PRIVATE ~Iterator();
 728 
 729     Iterator(const Iterator&amp;) = delete;
 730     WTF_EXPORT_PRIVATE Iterator(Iterator&amp;&amp;);
 731     Iterator&amp; operator=(const Iterator&amp;) = delete;
 732     Iterator&amp; operator=(Iterator&amp;&amp;) = delete;
 733 
 734     WTF_EXPORT_PRIVATE StringView operator*() const;
 735     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 736 
 737     WTF_EXPORT_PRIVATE bool operator==(const Iterator&amp;) const;
 738     WTF_EXPORT_PRIVATE bool operator!=(const Iterator&amp;) const;
 739 
 740 private:
 741     class Impl;
 742 
 743     std::unique_ptr&lt;Impl&gt; m_impl;
 744 };
 745 
 746 class StringView::CodePoints::Iterator {

 747 public:
 748     Iterator(const StringView&amp;, unsigned index);
 749 
 750     UChar32 operator*() const;
 751     Iterator&amp; operator++();
 752 
 753     bool operator==(const Iterator&amp;) const;
 754     bool operator!=(const Iterator&amp;) const;
<span class="line-removed"> 755     Iterator&amp; operator=(const Iterator&amp;);</span>
 756 
 757 private:
 758     std::reference_wrapper&lt;const StringView&gt; m_stringView;
 759     Optional&lt;unsigned&gt; m_nextCodePointOffset;
 760     UChar32 m_codePoint;
 761 };
 762 
 763 class StringView::CodeUnits::Iterator {

 764 public:
 765     Iterator(const StringView&amp;, unsigned index);
 766 
 767     UChar operator*() const;
 768     Iterator&amp; operator++();
 769 
 770     bool operator==(const Iterator&amp;) const;
 771     bool operator!=(const Iterator&amp;) const;
 772 
 773 private:
 774     const StringView&amp; m_stringView;
 775     unsigned m_index;
 776 };
 777 
 778 inline auto StringView::graphemeClusters() const -&gt; GraphemeClusters
 779 {
 780     return GraphemeClusters(*this);
 781 }
 782 
 783 inline auto StringView::codePoints() const -&gt; CodePoints
</pre>
<hr />
<pre>
 815     , m_nextCodePointOffset(index)
 816 {
 817     operator++();
 818 }
 819 
 820 inline auto StringView::CodePoints::Iterator::operator++() -&gt; Iterator&amp;
 821 {
 822     ASSERT(m_nextCodePointOffset);
 823     if (m_nextCodePointOffset.value() == m_stringView.get().length()) {
 824         m_nextCodePointOffset = WTF::nullopt;
 825         return *this;
 826     }
 827     if (m_stringView.get().is8Bit())
 828         m_codePoint = m_stringView.get().characters8()[m_nextCodePointOffset.value()++];
 829     else
 830         U16_NEXT(m_stringView.get().characters16(), m_nextCodePointOffset.value(), m_stringView.get().length(), m_codePoint);
 831     ASSERT(m_nextCodePointOffset.value() &lt;= m_stringView.get().length());
 832     return *this;
 833 }
 834 
<span class="line-removed"> 835 inline auto StringView::CodePoints::Iterator::operator=(const Iterator&amp; other) -&gt; Iterator&amp;</span>
<span class="line-removed"> 836 {</span>
<span class="line-removed"> 837     m_stringView = other.m_stringView;</span>
<span class="line-removed"> 838     m_nextCodePointOffset = other.m_nextCodePointOffset;</span>
<span class="line-removed"> 839     m_codePoint = other.m_codePoint;</span>
<span class="line-removed"> 840     return *this;</span>
<span class="line-removed"> 841 }</span>
<span class="line-removed"> 842 </span>
 843 inline UChar32 StringView::CodePoints::Iterator::operator*() const
 844 {
 845     ASSERT(m_nextCodePointOffset);
 846     return m_codePoint;
 847 }
 848 
 849 inline bool StringView::CodePoints::Iterator::operator==(const Iterator&amp; other) const
 850 {
 851     ASSERT(&amp;m_stringView.get() == &amp;other.m_stringView.get());
 852     return m_nextCodePointOffset == other.m_nextCodePointOffset;
 853 }
 854 
 855 inline bool StringView::CodePoints::Iterator::operator!=(const Iterator&amp; other) const
 856 {
 857     return !(*this == other);
 858 }
 859 
 860 inline auto StringView::CodePoints::begin() const -&gt; Iterator
 861 {
 862     return Iterator(m_stringView, 0);
</pre>
</td>
<td>
<hr />
<pre>
  31 #include &lt;wtf/Optional.h&gt;
  32 #include &lt;wtf/RetainPtr.h&gt;
  33 #include &lt;wtf/Vector.h&gt;
  34 #include &lt;wtf/text/CString.h&gt;
  35 #include &lt;wtf/text/ConversionMode.h&gt;
  36 #include &lt;wtf/text/LChar.h&gt;
  37 #include &lt;wtf/text/StringCommon.h&gt;
  38 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  39 
  40 // FIXME: Enabling the StringView lifetime checking causes the MSVC build to fail. Figure out why.
  41 #if defined(NDEBUG) || COMPILER(MSVC)
  42 #define CHECK_STRINGVIEW_LIFETIME 0
  43 #else
  44 #define CHECK_STRINGVIEW_LIFETIME 1
  45 #endif
  46 
  47 namespace WTF {
  48 
  49 // StringView is a non-owning reference to a string, similar to the proposed std::string_view.
  50 
<span class="line-modified">  51 class StringView final {</span>
<span class="line-added">  52     WTF_MAKE_FAST_ALLOCATED;</span>
  53 public:
  54     StringView();
  55 #if CHECK_STRINGVIEW_LIFETIME
  56     ~StringView();
  57     StringView(StringView&amp;&amp;);
  58     StringView(const StringView&amp;);
  59     StringView&amp; operator=(StringView&amp;&amp;);
  60     StringView&amp; operator=(const StringView&amp;);
  61 #endif
  62 
<span class="line-modified">  63     StringView(const AtomString&amp;);</span>
  64     StringView(const String&amp;);
  65     StringView(const StringImpl&amp;);
  66     StringView(const StringImpl*);
  67     StringView(const LChar*, unsigned length);
  68     StringView(const UChar*, unsigned length);
  69     StringView(const char*);
<span class="line-added">  70     StringView(const char*, unsigned length);</span>
  71 
  72     static StringView empty();
  73 
  74     unsigned length() const;
  75     bool isEmpty() const;
  76 
  77     explicit operator bool() const;
  78     bool isNull() const;
  79 
  80     UChar operator[](unsigned index) const;
  81 
  82     class CodeUnits;
  83     CodeUnits codeUnits() const;
  84 
  85     class CodePoints;
  86     CodePoints codePoints() const;
  87 
  88     class GraphemeClusters;
  89     GraphemeClusters graphemeClusters() const;
  90 
  91     bool is8Bit() const;
  92     const LChar* characters8() const;
  93     const UChar* characters16() const;
  94 
  95     String toString() const;
  96     String toStringWithoutCopying() const;
<span class="line-modified">  97     AtomString toAtomString() const;</span>
<span class="line-modified">  98     RefPtr&lt;AtomStringImpl&gt; toExistingAtomString() const;</span>
  99 
 100 #if USE(CF)
<span class="line-modified"> 101     // These functions convert null strings to empty strings.</span>
 102     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFString() const;
 103     WTF_EXPORT_PRIVATE RetainPtr&lt;CFStringRef&gt; createCFStringWithoutCopying() const;
 104 #endif
 105 
 106 #ifdef __OBJC__
 107     // These functions convert null strings to empty strings.
 108     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSString() const;
 109     WTF_EXPORT_PRIVATE RetainPtr&lt;NSString&gt; createNSStringWithoutCopying() const;
 110 #endif
 111 
 112     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 113     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 114 
 115     class UpconvertedCharacters;
 116     UpconvertedCharacters upconvertedCharacters() const;
 117 
 118     void getCharactersWithUpconvert(LChar*) const;
 119     void getCharactersWithUpconvert(UChar*) const;
 120 
 121     StringView substring(unsigned start, unsigned length = std::numeric_limits&lt;unsigned&gt;::max()) const;
<span class="line-modified"> 122     StringView left(unsigned length) const { return substring(0, length); }</span>
<span class="line-modified"> 123     StringView right(unsigned length) const { return substring(this-&gt;length() - length, length); }</span>
 124 
 125     template&lt;typename MatchedCharacterPredicate&gt;
 126     StringView stripLeadingAndTrailingMatchedCharacters(const MatchedCharacterPredicate&amp;);
 127 
 128     class SplitResult;
 129     SplitResult split(UChar) const;
 130     SplitResult splitAllowingEmptyEntries(UChar) const;
 131 
 132     size_t find(UChar, unsigned start = 0) const;
 133     size_t find(CodeUnitMatchFunction, unsigned start = 0) const;
 134 
 135     WTF_EXPORT_PRIVATE size_t find(StringView, unsigned start) const;
 136 
<span class="line-modified"> 137     size_t reverseFind(UChar, unsigned index = std::numeric_limits&lt;unsigned&gt;::max()) const;</span>
 138 
 139     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;) const;
 140     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 141 
 142     WTF_EXPORT_PRIVATE String convertToASCIILowercase() const;
 143     WTF_EXPORT_PRIVATE String convertToASCIIUppercase() const;
 144 
 145     bool contains(UChar) const;
<span class="line-added"> 146     bool contains(CodeUnitMatchFunction) const;</span>
 147     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;) const;
 148     WTF_EXPORT_PRIVATE bool containsIgnoringASCIICase(const StringView&amp;, unsigned startOffset) const;
 149 
<span class="line-added"> 150     WTF_EXPORT_PRIVATE bool startsWith(UChar) const;</span>
 151     WTF_EXPORT_PRIVATE bool startsWith(const StringView&amp;) const;
 152     WTF_EXPORT_PRIVATE bool startsWithIgnoringASCIICase(const StringView&amp;) const;
 153 
 154     WTF_EXPORT_PRIVATE bool endsWith(const StringView&amp;) const;
 155     WTF_EXPORT_PRIVATE bool endsWithIgnoringASCIICase(const StringView&amp;) const;
 156 
 157     int toInt() const;
 158     int toInt(bool&amp; isValid) const;
 159     int toIntStrict(bool&amp; isValid) const;
 160     Optional&lt;uint64_t&gt; toUInt64Strict() const;
 161     float toFloat(bool&amp; isValid) const;
 162 
 163     static void invalidate(const StringImpl&amp;);
 164 
 165     struct UnderlyingString;
 166 
 167 private:
 168     friend bool equal(StringView, StringView);
 169 
 170     void initialize(const LChar*, unsigned length);
 171     void initialize(const UChar*, unsigned length);
 172 
 173     template&lt;typename CharacterType, typename MatchedCharacterPredicate&gt;
 174     StringView stripLeadingAndTrailingMatchedCharacters(const CharacterType*, const MatchedCharacterPredicate&amp;);
 175 
 176 #if CHECK_STRINGVIEW_LIFETIME
 177     WTF_EXPORT_PRIVATE bool underlyingStringIsValid() const;
 178     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringImpl*);
 179     WTF_EXPORT_PRIVATE void setUnderlyingString(const StringView&amp;);
<span class="line-added"> 180     void adoptUnderlyingString(UnderlyingString*);</span>
 181 #else
 182     bool underlyingStringIsValid() const { return true; }
 183     void setUnderlyingString(const StringImpl*) { }
 184     void setUnderlyingString(const StringView&amp;) { }
 185 #endif
 186     void clear();
 187 
 188     const void* m_characters { nullptr };
 189     unsigned m_length { 0 };
 190     bool m_is8Bit { true };
 191 
 192 #if CHECK_STRINGVIEW_LIFETIME

 193     UnderlyingString* m_underlyingString { nullptr };
 194 #endif
 195 };
 196 
 197 template&lt;typename CharacterType, size_t inlineCapacity&gt; void append(Vector&lt;CharacterType, inlineCapacity&gt;&amp;, StringView);
 198 
 199 bool equal(StringView, StringView);
 200 bool equal(StringView, const LChar* b);
 201 
 202 bool equalIgnoringASCIICase(StringView, StringView);
 203 bool equalIgnoringASCIICase(StringView, const char*);
 204 
 205 template&lt;unsigned length&gt; bool equalLettersIgnoringASCIICase(StringView, const char (&amp;lowercaseLetters)[length]);
 206 
 207 inline bool operator==(StringView a, StringView b) { return equal(a, b); }
 208 inline bool operator==(StringView a, const LChar *b);
 209 inline bool operator==(StringView a, const char *b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 210 inline bool operator==(const char* a, StringView b) { return equal(b, a); }
 211 
 212 inline bool operator!=(StringView a, StringView b) { return !equal(a, b); }
 213 inline bool operator!=(StringView a, const LChar* b) { return !equal(a, b); }
 214 inline bool operator!=(StringView a, const char* b) { return !equal(a, b); }
 215 inline bool operator!=(const LChar*a, StringView b) { return !equal(b, a); }
 216 inline bool operator!=(const char*a, StringView b) { return !equal(b, a); }
 217 
 218 struct StringViewWithUnderlyingString;
 219 
 220 // This returns a StringView of the normalized result, and a String that is either
 221 // null, if the input was already normalized, or contains the normalized result
 222 // and needs to be kept around so the StringView remains valid. Typically the
 223 // easiest way to use it correctly is to put it into a local and use the StringView.
 224 WTF_EXPORT_PRIVATE StringViewWithUnderlyingString normalizedNFC(StringView);
 225 
 226 WTF_EXPORT_PRIVATE String normalizedNFC(const String&amp;);
 227 
 228 }
 229 
<span class="line-modified"> 230 #include &lt;wtf/text/AtomString.h&gt;</span>
 231 #include &lt;wtf/text/WTFString.h&gt;
 232 
 233 namespace WTF {
 234 
 235 struct StringViewWithUnderlyingString {
<span class="line-added"> 236     WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
 237     StringView view;
 238     String underlyingString;
 239 };
 240 
 241 inline StringView::StringView()
 242 {
 243 }
 244 
 245 #if CHECK_STRINGVIEW_LIFETIME
 246 
 247 inline StringView::~StringView()
 248 {
 249     setUnderlyingString(nullptr);
 250 }
 251 
 252 inline StringView::StringView(StringView&amp;&amp; other)
 253     : m_characters(other.m_characters)
 254     , m_length(other.m_length)
 255     , m_is8Bit(other.m_is8Bit)
 256 {
</pre>
<hr />
<pre>
 315     m_characters = characters;
 316     m_length = length;
 317     m_is8Bit = false;
 318 }
 319 
 320 inline StringView::StringView(const LChar* characters, unsigned length)
 321 {
 322     initialize(characters, length);
 323 }
 324 
 325 inline StringView::StringView(const UChar* characters, unsigned length)
 326 {
 327     initialize(characters, length);
 328 }
 329 
 330 inline StringView::StringView(const char* characters)
 331 {
 332     initialize(reinterpret_cast&lt;const LChar*&gt;(characters), strlen(characters));
 333 }
 334 
<span class="line-added"> 335 inline StringView::StringView(const char* characters, unsigned length)</span>
<span class="line-added"> 336 {</span>
<span class="line-added"> 337     initialize(reinterpret_cast&lt;const LChar*&gt;(characters), length);</span>
<span class="line-added"> 338 }</span>
<span class="line-added"> 339 </span>
 340 inline StringView::StringView(const StringImpl&amp; string)
 341 {
 342     setUnderlyingString(&amp;string);
 343     if (string.is8Bit())
 344         initialize(string.characters8(), string.length());
 345     else
 346         initialize(string.characters16(), string.length());
 347 }
 348 
 349 inline StringView::StringView(const StringImpl* string)
 350 {
 351     if (!string)
 352         return;
 353 
 354     setUnderlyingString(string);
 355     if (string-&gt;is8Bit())
 356         initialize(string-&gt;characters8(), string-&gt;length());
 357     else
 358         initialize(string-&gt;characters16(), string-&gt;length());
 359 }
 360 
 361 inline StringView::StringView(const String&amp; string)
 362 {
 363     setUnderlyingString(string.impl());
 364     if (!string.impl()) {
 365         clear();
 366         return;
 367     }
 368     if (string.is8Bit()) {
 369         initialize(string.characters8(), string.length());
 370         return;
 371     }
 372     initialize(string.characters16(), string.length());
 373 }
 374 
<span class="line-modified"> 375 inline StringView::StringView(const AtomString&amp; atomString)</span>
<span class="line-modified"> 376     : StringView(atomString.string())</span>
 377 {
 378 }
 379 
 380 inline void StringView::clear()
 381 {
 382     m_characters = nullptr;
 383     m_length = 0;
 384     m_is8Bit = true;
 385 }
 386 
 387 inline StringView StringView::empty()
 388 {
<span class="line-modified"> 389     return StringView(&quot;&quot;, 0);</span>
 390 }
 391 
 392 inline const LChar* StringView::characters8() const
 393 {
 394     ASSERT(is8Bit());
 395     ASSERT(underlyingStringIsValid());
 396     return static_cast&lt;const LChar*&gt;(m_characters);
 397 }
 398 
 399 inline const UChar* StringView::characters16() const
 400 {
 401     ASSERT(!is8Bit());
 402     ASSERT(underlyingStringIsValid());
 403     return static_cast&lt;const UChar*&gt;(m_characters);
 404 }
 405 
 406 class StringView::UpconvertedCharacters {
<span class="line-added"> 407     WTF_MAKE_FAST_ALLOCATED;</span>
 408 public:
 409     explicit UpconvertedCharacters(const StringView&amp;);
 410     operator const UChar*() const { return m_characters; }
 411     const UChar* get() const { return m_characters; }
 412 private:
 413     Vector&lt;UChar, 32&gt; m_upconvertedCharacters;
 414     const UChar* m_characters;
 415 };
 416 
 417 inline StringView::UpconvertedCharacters StringView::upconvertedCharacters() const
 418 {
 419     return UpconvertedCharacters(*this);
 420 }
 421 
 422 inline bool StringView::isNull() const
 423 {
 424     return !m_characters;
 425 }
 426 
 427 inline bool StringView::isEmpty() const
</pre>
<hr />
<pre>
 462         return result;
 463     }
 464     StringView result(characters16() + start, length);
 465     result.setUnderlyingString(*this);
 466     return result;
 467 }
 468 
 469 inline UChar StringView::operator[](unsigned index) const
 470 {
 471     ASSERT(index &lt; length());
 472     if (is8Bit())
 473         return characters8()[index];
 474     return characters16()[index];
 475 }
 476 
 477 inline bool StringView::contains(UChar character) const
 478 {
 479     return find(character) != notFound;
 480 }
 481 
<span class="line-added"> 482 inline bool StringView::contains(CodeUnitMatchFunction function) const</span>
<span class="line-added"> 483 {</span>
<span class="line-added"> 484     return find(function) != notFound;</span>
<span class="line-added"> 485 }</span>
<span class="line-added"> 486 </span>
 487 inline void StringView::getCharactersWithUpconvert(LChar* destination) const
 488 {
 489     ASSERT(is8Bit());
 490     StringImpl::copyCharacters(destination, characters8(), m_length);
 491 }
 492 
 493 inline void StringView::getCharactersWithUpconvert(UChar* destination) const
 494 {
 495     if (is8Bit()) {
 496         StringImpl::copyCharacters(destination, characters8(), m_length);
 497         return;
 498     }
 499     StringImpl::copyCharacters(destination, characters16(), m_length);
 500 }
 501 
 502 inline StringView::UpconvertedCharacters::UpconvertedCharacters(const StringView&amp; string)
 503 {
 504     if (!string.is8Bit()) {
 505         m_characters = string.characters16();
 506         return;
 507     }
 508     const LChar* characters8 = string.characters8();
 509     unsigned length = string.m_length;
 510     m_upconvertedCharacters.reserveInitialCapacity(length);
 511     for (unsigned i = 0; i &lt; length; ++i)
 512         m_upconvertedCharacters.uncheckedAppend(characters8[i]);
 513     m_characters = m_upconvertedCharacters.data();
 514 }
 515 
 516 inline String StringView::toString() const
 517 {
 518     if (is8Bit())
 519         return String(characters8(), m_length);
 520     return String(characters16(), m_length);
 521 }
 522 
<span class="line-modified"> 523 inline AtomString StringView::toAtomString() const</span>
 524 {
 525     if (is8Bit())
<span class="line-modified"> 526         return AtomString(characters8(), m_length);</span>
<span class="line-modified"> 527     return AtomString(characters16(), m_length);</span>
 528 }
 529 
<span class="line-modified"> 530 inline RefPtr&lt;AtomStringImpl&gt; StringView::toExistingAtomString() const</span>
 531 {
 532     if (is8Bit())
<span class="line-modified"> 533         return AtomStringImpl::lookUp(characters8(), m_length);</span>
<span class="line-modified"> 534     return AtomStringImpl::lookUp(characters16(), m_length);</span>
 535 }
 536 
 537 inline float StringView::toFloat(bool&amp; isValid) const
 538 {
 539     if (is8Bit())
 540         return charactersToFloat(characters8(), m_length, &amp;isValid);
 541     return charactersToFloat(characters16(), m_length, &amp;isValid);
 542 }
 543 
 544 inline int StringView::toInt() const
 545 {
 546     bool isValid;
 547     return toInt(isValid);
 548 }
 549 
 550 inline int StringView::toInt(bool&amp; isValid) const
 551 {
 552     if (is8Bit())
 553         return charactersToInt(characters8(), m_length, &amp;isValid);
 554     return charactersToInt(characters16(), m_length, &amp;isValid);
</pre>
<hr />
<pre>
 646     unsigned aLength = a.length();
 647     if (aLength != strlen(reinterpret_cast&lt;const char*&gt;(b)))
 648         return false;
 649 
 650     if (a.is8Bit())
 651         return equal(a.characters8(), b, aLength);
 652     return equal(a.characters16(), b, aLength);
 653 }
 654 
 655 inline bool equalIgnoringASCIICase(StringView a, StringView b)
 656 {
 657     return equalIgnoringASCIICaseCommon(a, b);
 658 }
 659 
 660 inline bool equalIgnoringASCIICase(StringView a, const char* b)
 661 {
 662     return equalIgnoringASCIICaseCommon(a, b);
 663 }
 664 
 665 class StringView::SplitResult {
<span class="line-added"> 666     WTF_MAKE_FAST_ALLOCATED;</span>
 667 public:
 668     SplitResult(StringView, UChar separator, bool allowEmptyEntries);
 669 
 670     class Iterator;
 671     Iterator begin() const;
 672     Iterator end() const;
 673 
 674 private:
 675     StringView m_string;
 676     UChar m_separator;
 677     bool m_allowEmptyEntries;
 678 };
 679 
 680 class StringView::GraphemeClusters {
<span class="line-added"> 681     WTF_MAKE_FAST_ALLOCATED;</span>
 682 public:
 683     explicit GraphemeClusters(const StringView&amp;);
 684 
 685     class Iterator;
 686     Iterator begin() const;
 687     Iterator end() const;
 688 
 689 private:
 690     StringView m_stringView;
 691 };
 692 
 693 class StringView::CodePoints {
<span class="line-added"> 694     WTF_MAKE_FAST_ALLOCATED;</span>
 695 public:
 696     explicit CodePoints(const StringView&amp;);
 697 
 698     class Iterator;
 699     Iterator begin() const;
 700     Iterator end() const;
 701 
 702 private:
 703     StringView m_stringView;
 704 };
 705 
 706 class StringView::CodeUnits {
<span class="line-added"> 707     WTF_MAKE_FAST_ALLOCATED;</span>
 708 public:
 709     explicit CodeUnits(const StringView&amp;);
 710 
 711     class Iterator;
 712     Iterator begin() const;
 713     Iterator end() const;
 714 
 715 private:
 716     StringView m_stringView;
 717 };
 718 
 719 class StringView::SplitResult::Iterator {
<span class="line-added"> 720     WTF_MAKE_FAST_ALLOCATED;</span>
 721 public:
 722     StringView operator*() const;
 723 
 724     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 725 
 726     bool operator==(const Iterator&amp;) const;
 727     bool operator!=(const Iterator&amp;) const;
 728 
 729 private:
 730     enum PositionTag { AtEnd };
 731     Iterator(const SplitResult&amp;);
 732     Iterator(const SplitResult&amp;, PositionTag);
 733 
 734     WTF_EXPORT_PRIVATE void findNextSubstring();
 735 
 736     friend SplitResult;
 737 
 738     const SplitResult&amp; m_result;
 739     unsigned m_position { 0 };
 740     unsigned m_length;
 741     bool m_isDone;
 742 };
 743 
 744 class StringView::GraphemeClusters::Iterator {
<span class="line-added"> 745     WTF_MAKE_FAST_ALLOCATED;</span>
 746 public:
 747     Iterator() = delete;
 748     WTF_EXPORT_PRIVATE Iterator(const StringView&amp;, unsigned index);
 749     WTF_EXPORT_PRIVATE ~Iterator();
 750 
 751     Iterator(const Iterator&amp;) = delete;
 752     WTF_EXPORT_PRIVATE Iterator(Iterator&amp;&amp;);
 753     Iterator&amp; operator=(const Iterator&amp;) = delete;
 754     Iterator&amp; operator=(Iterator&amp;&amp;) = delete;
 755 
 756     WTF_EXPORT_PRIVATE StringView operator*() const;
 757     WTF_EXPORT_PRIVATE Iterator&amp; operator++();
 758 
 759     WTF_EXPORT_PRIVATE bool operator==(const Iterator&amp;) const;
 760     WTF_EXPORT_PRIVATE bool operator!=(const Iterator&amp;) const;
 761 
 762 private:
 763     class Impl;
 764 
 765     std::unique_ptr&lt;Impl&gt; m_impl;
 766 };
 767 
 768 class StringView::CodePoints::Iterator {
<span class="line-added"> 769     WTF_MAKE_FAST_ALLOCATED;</span>
 770 public:
 771     Iterator(const StringView&amp;, unsigned index);
 772 
 773     UChar32 operator*() const;
 774     Iterator&amp; operator++();
 775 
 776     bool operator==(const Iterator&amp;) const;
 777     bool operator!=(const Iterator&amp;) const;

 778 
 779 private:
 780     std::reference_wrapper&lt;const StringView&gt; m_stringView;
 781     Optional&lt;unsigned&gt; m_nextCodePointOffset;
 782     UChar32 m_codePoint;
 783 };
 784 
 785 class StringView::CodeUnits::Iterator {
<span class="line-added"> 786     WTF_MAKE_FAST_ALLOCATED;</span>
 787 public:
 788     Iterator(const StringView&amp;, unsigned index);
 789 
 790     UChar operator*() const;
 791     Iterator&amp; operator++();
 792 
 793     bool operator==(const Iterator&amp;) const;
 794     bool operator!=(const Iterator&amp;) const;
 795 
 796 private:
 797     const StringView&amp; m_stringView;
 798     unsigned m_index;
 799 };
 800 
 801 inline auto StringView::graphemeClusters() const -&gt; GraphemeClusters
 802 {
 803     return GraphemeClusters(*this);
 804 }
 805 
 806 inline auto StringView::codePoints() const -&gt; CodePoints
</pre>
<hr />
<pre>
 838     , m_nextCodePointOffset(index)
 839 {
 840     operator++();
 841 }
 842 
 843 inline auto StringView::CodePoints::Iterator::operator++() -&gt; Iterator&amp;
 844 {
 845     ASSERT(m_nextCodePointOffset);
 846     if (m_nextCodePointOffset.value() == m_stringView.get().length()) {
 847         m_nextCodePointOffset = WTF::nullopt;
 848         return *this;
 849     }
 850     if (m_stringView.get().is8Bit())
 851         m_codePoint = m_stringView.get().characters8()[m_nextCodePointOffset.value()++];
 852     else
 853         U16_NEXT(m_stringView.get().characters16(), m_nextCodePointOffset.value(), m_stringView.get().length(), m_codePoint);
 854     ASSERT(m_nextCodePointOffset.value() &lt;= m_stringView.get().length());
 855     return *this;
 856 }
 857 








 858 inline UChar32 StringView::CodePoints::Iterator::operator*() const
 859 {
 860     ASSERT(m_nextCodePointOffset);
 861     return m_codePoint;
 862 }
 863 
 864 inline bool StringView::CodePoints::Iterator::operator==(const Iterator&amp; other) const
 865 {
 866     ASSERT(&amp;m_stringView.get() == &amp;other.m_stringView.get());
 867     return m_nextCodePointOffset == other.m_nextCodePointOffset;
 868 }
 869 
 870 inline bool StringView::CodePoints::Iterator::operator!=(const Iterator&amp; other) const
 871 {
 872     return !(*this == other);
 873 }
 874 
 875 inline auto StringView::CodePoints::begin() const -&gt; Iterator
 876 {
 877     return Iterator(m_stringView, 0);
</pre>
</td>
</tr>
</table>
<center><a href="StringView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>