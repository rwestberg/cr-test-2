<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 # Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 require &quot;config&quot;
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 
  28 # The CLoop llint backend is initially based on the ARMv7 backend, and
  29 # then further enhanced with a few instructions from the x86 backend to
  30 # support building for X64 targets.  Hence, the shape of the generated
  31 # code and the usage convention of registers will look a lot like the
  32 # ARMv7 backend&#39;s.
  33 
  34 def cloopMapType(type)
  35     case type
<a name="2" id="anc2"></a><span class="line-modified">  36     when :intptr;         &quot;.i()&quot;</span>
<span class="line-modified">  37     when :uintptr;        &quot;.u()&quot;</span>
  38     when :int32;          &quot;.i32()&quot;
  39     when :uint32;         &quot;.u32()&quot;
  40     when :int64;          &quot;.i64()&quot;
  41     when :uint64;         &quot;.u64()&quot;
  42     when :int8;           &quot;.i8()&quot;
  43     when :uint8;          &quot;.u8()&quot;
  44     when :int8Ptr;        &quot;.i8p()&quot;
  45     when :voidPtr;        &quot;.vp()&quot;
  46     when :nativeFunc;     &quot;.nativeFunc()&quot;
  47     when :double;         &quot;.d()&quot;
  48     when :bitsAsDouble;   &quot;.bitsAsDouble()&quot;
  49     when :bitsAsInt64;    &quot;.bitsAsInt64()&quot;
  50     when :opcode;         &quot;.opcode()&quot;
  51     else;
  52         raise &quot;Unsupported type&quot;
  53     end
  54 end
  55 
  56 
  57 class SpecialRegister &lt; NoChildren
<a name="3" id="anc3"></a><span class="line-modified">  58     def clLValue(type=:intptr)</span>
  59         clDump
  60     end
  61     def clDump
  62         @name
  63     end
<a name="4" id="anc4"></a><span class="line-modified">  64     def clValue(type=:intptr)</span>
  65         @name + cloopMapType(type)
  66     end
  67 end
  68 
  69 C_LOOP_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
  70 
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
  85             &quot;pc&quot;
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
  91             &quot;tagTypeNumber&quot;
  92         when &quot;csr2&quot;
  93             &quot;tagMask&quot;
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
<a name="5" id="anc5"></a><span class="line-modified"> 106     def clLValue(type=:intptr)</span>
 107         clDump
 108     end
<a name="6" id="anc6"></a><span class="line-modified"> 109     def clValue(type=:intptr)</span>
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
 114 class FPRegisterID
 115     def clDump
 116         case name
 117         when &quot;ft0&quot;, &quot;fr&quot;
 118             &quot;d0&quot;
 119         when &quot;ft1&quot;
 120             &quot;d1&quot;
 121         when &quot;ft2&quot;
 122             &quot;d2&quot;
 123         when &quot;ft3&quot;
 124             &quot;d3&quot;
 125         when &quot;ft4&quot;
 126             &quot;d4&quot;
 127         when &quot;ft5&quot;
 128             &quot;d5&quot;
 129         else
 130             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 131         end
 132     end
<a name="7" id="anc7"></a><span class="line-modified"> 133     def clLValue(type=:intptr)</span>
 134         clDump
 135     end
<a name="8" id="anc8"></a><span class="line-modified"> 136     def clValue(type=:intptr)</span>
 137         clDump + cloopMapType(type)
 138     end
 139 end
 140 
 141 class Immediate
 142     def clDump
 143         &quot;#{value}&quot;
 144     end
<a name="9" id="anc9"></a><span class="line-modified"> 145     def clLValue(type=:intptr)</span>
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
<a name="10" id="anc10"></a><span class="line-modified"> 148     def clValue(type=:intptr)</span>
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
 163         when :int32;   &quot;int32_t(#{valueStr})&quot;
 164         when :int64;   &quot;int64_t(#{valueStr})&quot;
<a name="11" id="anc11"></a><span class="line-modified"> 165         when :intptr;  &quot;intptr_t(#{valueStr})&quot;</span>
 166         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 167         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 168         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
<a name="12" id="anc12"></a><span class="line-modified"> 169         when :uintptr; &quot;uintptr_t(#{valueStr})&quot;</span>
 170         else
 171             raise &quot;Not implemented immediate of type: #{type}&quot; 
 172         end
 173     end
 174 end
 175 
 176 class Address
 177     def clDump
 178         &quot;[#{base.clDump}, #{offset.value}]&quot;
 179     end
<a name="13" id="anc13"></a><span class="line-modified"> 180     def clLValue(type=:intptr)</span>
 181         clValue(type)
 182     end
<a name="14" id="anc14"></a><span class="line-modified"> 183     def clValue(type=:intptr)</span>
 184         case type
 185         when :int8;         int8MemRef
 186         when :int32;        int32MemRef
 187         when :int64;        int64MemRef
<a name="15" id="anc15"></a><span class="line-modified"> 188         when :intptr;       intptrMemRef</span>
 189         when :uint8;        uint8MemRef
 190         when :uint32;       uint32MemRef
 191         when :uint64;       uint64MemRef
<a name="16" id="anc16"></a><span class="line-modified"> 192         when :uintptr;      uintptrMemRef</span>
 193         when :opcode;       opcodeMemRef
 194         when :nativeFunc;   nativeFuncMemRef
 195         else
 196             raise &quot;Unexpected Address type: #{type}&quot;
 197         end
 198     end
 199     def pointerExpr
 200         if  offset.value == 0
 201             &quot;#{base.clValue(:int8Ptr)}&quot;
 202         elsif offset.value &gt; 0
 203             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 204         else
 205             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
 206         end
 207     end
 208     def int8MemRef
 209         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 210     end
 211     def int16MemRef
 212         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 213     end
 214     def int32MemRef
 215         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 216     end
 217     def int64MemRef
 218         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 219     end
<a name="17" id="anc17"></a><span class="line-modified"> 220     def intptrMemRef</span>
 221         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 222     end
 223     def uint8MemRef
 224         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 225     end
 226     def uint16MemRef
 227         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 228     end
 229     def uint32MemRef
 230         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 231     end
 232     def uint64MemRef
 233         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 234     end
<a name="18" id="anc18"></a><span class="line-modified"> 235     def uintptrMemRef</span>
 236         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 237     end
 238     def nativeFuncMemRef
 239         &quot;*CAST&lt;NativeFunction*&gt;(#{pointerExpr})&quot;
 240     end
 241     def opcodeMemRef
 242         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 243     end
 244     def dblMemRef
 245         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 246     end
 247 end
 248 
 249 class BaseIndex
 250     def clDump
 251         &quot;[#{base.clDump}, #{offset.clDump}, #{index.clDump} &lt;&lt; #{scaleShift}]&quot;
 252     end
<a name="19" id="anc19"></a><span class="line-modified"> 253     def clLValue(type=:intptr)</span>
 254         clValue(type)
 255     end
<a name="20" id="anc20"></a><span class="line-modified"> 256     def clValue(type=:intptr)</span>
 257         case type
 258         when :int8;       int8MemRef
 259         when :int32;      int32MemRef
 260         when :int64;      int64MemRef
<a name="21" id="anc21"></a><span class="line-modified"> 261         when :intptr;     intptrMemRef</span>
 262         when :uint8;      uint8MemRef
 263         when :uint32;     uint32MemRef
 264         when :uint64;     uint64MemRef
<a name="22" id="anc22"></a><span class="line-modified"> 265         when :uintptr;    uintptrMemRef</span>
 266         when :opcode;     opcodeMemRef
 267         else
 268             raise &quot;Unexpected BaseIndex type: #{type}&quot;
 269         end
 270     end
 271     def pointerExpr
 272         if offset.value == 0
 273             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift})&quot;
 274         else
 275             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift}) + #{offset.clValue}&quot;
 276         end
 277     end
 278     def int8MemRef
 279         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 280     end
 281     def int16MemRef
 282         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 283     end
 284     def int32MemRef
 285         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 286     end
 287     def int64MemRef
 288         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 289     end
<a name="23" id="anc23"></a><span class="line-modified"> 290     def intptrMemRef</span>
 291         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 292     end
 293     def uint8MemRef
 294         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 295     end
 296     def uint16MemRef
 297         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 298     end
 299     def uint32MemRef
 300         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 301     end
 302     def uint64MemRef
 303         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 304     end
<a name="24" id="anc24"></a><span class="line-modified"> 305     def uintptrMemRef</span>
 306         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 307     end
 308     def opcodeMemRef
 309         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 310     end
 311     def dblMemRef
 312         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 313     end
 314 end
 315 
 316 class AbsoluteAddress
 317     def clDump
 318         &quot;#{codeOriginString}&quot;
 319     end
<a name="25" id="anc25"></a><span class="line-modified"> 320     def clLValue(type=:intptr)</span>
 321         clValue(type)
 322     end
 323     def clValue
 324         clDump
 325     end
 326 end
 327 
 328 class LabelReference
<a name="26" id="anc26"></a><span class="line-modified"> 329     def intptrMemRef</span>
 330         &quot;*CAST&lt;intptr_t*&gt;(&amp;#{cLabel})&quot;
 331     end
 332     def cloopEmitLea(destination, type)
 333         $asm.putc &quot;#{destination.clLValue(:voidPtr)} = CAST&lt;void*&gt;(&amp;#{cLabel});&quot;
 334     end
 335 end
 336 
 337 
 338 #
 339 # Lea support.
 340 #
 341 
 342 class Address
 343     def cloopEmitLea(destination, type)
 344         if destination == base
 345             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} += #{offset.clValue(type)};&quot;
 346         else
 347             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + #{offset.clValue(type)};&quot;
 348         end
 349     end
 350 end
 351 
 352 class BaseIndex
 353     def cloopEmitLea(destination, type)
 354         raise &quot;Malformed BaseIndex, offset should be zero at #{codeOriginString}&quot; unless offset.value == 0
 355         $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift});&quot;
 356     end
 357 end
 358 
 359 #
 360 # Actual lowering code follows.
 361 #
 362 
 363 class Sequence
 364     def getModifiedListC_LOOP
 365         myList = @list
 366         
 367         # Verify that we will only see instructions and labels.
 368         myList.each {
 369             | node |
 370             unless node.is_a? Instruction or
 371                     node.is_a? Label or
 372                     node.is_a? LocalLabel or
 373                     node.is_a? Skip
 374                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 375             end
 376         }
 377         
 378         return myList
 379     end
 380 end
 381 
 382 def clOperands(operands)
 383     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 384 end
 385 
 386 
 387 def cloopEmitOperation(operands, type, operator)
<a name="27" id="anc27"></a><span class="line-modified"> 388     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \</span>
 389         type == :int64 || type == :uint64 || type == :double
 390     if operands.size == 3
 391         op1 = operands[0]
 392         op2 = operands[1]
 393         dst = operands[2]
 394     else
 395         raise unless operands.size == 2
 396         op1 = operands[1]
 397         op2 = operands[0]
 398         dst = operands[1]
 399     end
 400     raise unless not dst.is_a? Immediate
 401     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 402         truncationHeader = &quot;(uint32_t)(&quot;
 403         truncationFooter = &quot;)&quot;
 404     else
 405         truncationHeader = &quot;&quot;
 406         truncationFooter = &quot;&quot;
 407     end
 408     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 409 end
 410 
 411 def cloopEmitShiftOperation(operands, type, operator)
<a name="28" id="anc28"></a><span class="line-modified"> 412     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 413     if operands.size == 3
 414         op1 = operands[0]
 415         op2 = operands[1]
 416         dst = operands[2]
 417     else
 418         op1 = operands[1]
 419         op2 = operands[0]
 420         dst = operands[1]
 421     end
 422     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 423         truncationHeader = &quot;(uint32_t)(&quot;
 424         truncationFooter = &quot;)&quot;
 425     else
 426         truncationHeader = &quot;&quot;
 427         truncationFooter = &quot;&quot;
 428     end
<a name="29" id="anc29"></a><span class="line-modified"> 429     shiftMask = &quot;((sizeof(uintptr_t) == 8) ? 0x3f : 0x1f)&quot; if type == :intptr || type == :uintptr</span>
<span class="line-added"> 430     shiftMask = &quot;0x3f&quot; if type == :int64 || type == :uint64</span>
<span class="line-added"> 431     shiftMask = &quot;0x1f&quot; if type == :int32 || type == :uint32</span>
<span class="line-added"> 432     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operands[1].clValue(type)} #{operator} (#{operands[0].clValue(:intptr)} &amp; #{shiftMask})#{truncationFooter};&quot;</span>
 433 end
 434 
 435 def cloopEmitUnaryOperation(operands, type, operator)
<a name="30" id="anc30"></a><span class="line-modified"> 436     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64</span>
 437     raise unless operands.size == 1
 438     raise unless not operands[0].is_a? Immediate
 439     op = operands[0]
 440     dst = operands[0]
 441     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 442         truncationHeader = &quot;(uint32_t)(&quot;
 443         truncationFooter = &quot;)&quot;
 444     else
 445         truncationHeader = &quot;&quot;
 446         truncationFooter = &quot;&quot;
 447     end
 448     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operator}#{op.clValue(type)}#{truncationFooter};&quot;
 449 end
 450 
 451 def cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, condition)
 452     $asm.putc &quot;if (std::isnan(#{operands[0].clValue(:double)}) || std::isnan(#{operands[1].clValue(:double)})&quot;
 453     $asm.putc &quot;    || (#{operands[0].clValue(:double)} #{condition} #{operands[1].clValue(:double)}))&quot;
 454     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 455 end
 456 
 457 
 458 def cloopEmitCompareAndSet(operands, type, comparator)
 459     # The result is a boolean.  Hence, it doesn&#39;t need to be based on the type
 460     # of the arguments being compared.
 461     $asm.putc &quot;#{operands[2].clLValue(type)} = (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)});&quot;
 462 end
 463 
 464 
 465 def cloopEmitCompareAndBranch(operands, type, comparator)
 466     $asm.putc &quot;if (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)})&quot;
 467     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 468 end
 469 
 470 
 471 # conditionTest should contain a string that provides a comparator and a RHS
 472 # value e.g. &quot;&lt; 0&quot;.
 473 def cloopGenerateConditionExpression(operands, type, conditionTest)
 474     op1 = operands[0].clValue(type)
 475 
 476     # The operands must consist of 2 or 3 values.
 477     case operands.size
 478     when 2 # Just test op1 against the conditionTest.
 479         lhs = op1
 480     when 3 # Mask op1 with op2 before testing against the conditionTest.
 481         lhs = &quot;(#{op1} &amp; #{operands[1].clValue(type)})&quot;
 482     else
 483         raise &quot;Expected 2 or 3 operands but got #{operands.size} at #{codeOriginString}&quot;
 484     end
 485     
 486     &quot;#{lhs} #{conditionTest}&quot;
 487 end
 488 
 489 # conditionTest should contain a string that provides a comparator and a RHS
 490 # value e.g. &quot;&lt; 0&quot;.
 491 def cloopEmitTestAndBranchIf(operands, type, conditionTest, branchTarget)
 492     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 493     $asm.putc &quot;if (#{conditionExpr})&quot;
 494     $asm.putc &quot;    goto #{branchTarget};&quot;
 495 end
 496 
 497 def cloopEmitTestSet(operands, type, conditionTest)
 498     # The result is a boolean condition.  Hence, the result type is always an
 499     # int.  The passed in type is only used for the values being tested in
 500     # the condition test.
 501     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 502     $asm.putc &quot;#{operands[-1].clLValue} = (#{conditionExpr});&quot;
 503 end
 504 
 505 def cloopEmitOpAndBranch(operands, operator, type, conditionTest)
 506     case type
<a name="31" id="anc31"></a><span class="line-modified"> 507     when :intptr; tempType = &quot;intptr_t&quot;</span>
 508     when :int32; tempType = &quot;int32_t&quot;
 509     when :int64; tempType = &quot;int64_t&quot;
 510     else
 511         raise &quot;Unimplemented type&quot;
 512     end
 513 
 514     $asm.putc &quot;{&quot;
 515     $asm.putc &quot;    #{tempType} temp = #{operands[1].clValue(type)} #{operator} #{operands[0].clValue(type)};&quot;
 516     $asm.putc &quot;    #{operands[1].clLValue(type)} = temp;&quot;
 517     $asm.putc &quot;    if (temp #{conditionTest})&quot;
 518     $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 519     $asm.putc &quot;}&quot;
 520 end
 521 
 522 def cloopEmitOpAndBranchIfOverflow(operands, operator, type)
 523     case type
 524     when :int32
 525         tempType = &quot;int32_t&quot;
 526         truncationHeader = &quot;(uint32_t)(&quot;
 527         truncationFooter = &quot;)&quot;
 528     else
 529         raise &quot;Unimplemented type&quot;
 530     end
 531 
 532     $asm.putc &quot;{&quot;
 533 
 534     # Emit the overflow test based on the operands and the type:
 535     case operator
 536     when &quot;+&quot;; operation = &quot;add&quot;
 537     when &quot;-&quot;; operation = &quot;sub&quot;
 538     when &quot;*&quot;; operation = &quot;multiply&quot;
 539     else
 540         raise &quot;Unimplemented opeartor&quot;
 541     end
 542 
 543     $asm.putc &quot;    #{tempType} result;&quot;
 544     $asm.putc &quot;    bool success = WTF::ArithmeticOperations&lt;#{tempType}, #{tempType}, #{tempType}&gt;::#{operation}(#{operands[1].clValue(type)}, #{operands[0].clValue(type)}, result);&quot;
 545     $asm.putc &quot;    #{operands[1].clLValue(type)} = #{truncationHeader}result#{truncationFooter};&quot;
 546     $asm.putc &quot;    if (!success)&quot;
 547     $asm.putc &quot;        goto #{operands[2].cLabel};&quot;
 548     $asm.putc &quot;}&quot;
 549 end
 550 
 551 # operands: callTarget, currentFrame, currentPC
 552 def cloopEmitCallSlowPath(operands)
 553     $asm.putc &quot;{&quot;
 554     $asm.putc &quot;    cloopStack.setCurrentStackPointer(sp.vp());&quot;
 555     $asm.putc &quot;    SlowPathReturnType result = #{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 556     $asm.putc &quot;    decodeResult(result, t0, t1);&quot;
 557     $asm.putc &quot;}&quot;
 558 end
 559 
 560 def cloopEmitCallSlowPathVoid(operands)
 561     $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
 562     $asm.putc &quot;#{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 563 end
 564 
 565 class Instruction
 566     def lowerC_LOOP
 567         case opcode
 568         when &quot;addi&quot;
 569             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 570         when &quot;addq&quot;
 571             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 572         when &quot;addp&quot;
<a name="32" id="anc32"></a><span class="line-modified"> 573             cloopEmitOperation(operands, :intptr, &quot;+&quot;)</span>
 574 
 575         when &quot;andi&quot;
 576             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 577         when &quot;andq&quot;
 578             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 579         when &quot;andp&quot;
<a name="33" id="anc33"></a><span class="line-modified"> 580             cloopEmitOperation(operands, :intptr, &quot;&amp;&quot;)</span>
 581 
 582         when &quot;ori&quot;
 583             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 584         when &quot;orq&quot;
 585             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 586         when &quot;orp&quot;
<a name="34" id="anc34"></a><span class="line-modified"> 587             cloopEmitOperation(operands, :intptr, &quot;|&quot;)</span>
 588 
 589         when &quot;xori&quot;
 590             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 591         when &quot;xorq&quot;
 592             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 593         when &quot;xorp&quot;
<a name="35" id="anc35"></a><span class="line-modified"> 594             cloopEmitOperation(operands, :intptr, &quot;^&quot;)</span>
 595 
 596         when &quot;lshifti&quot;
 597             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 598         when &quot;lshiftq&quot;
 599             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 600         when &quot;lshiftp&quot;
<a name="36" id="anc36"></a><span class="line-modified"> 601             cloopEmitShiftOperation(operands, :intptr, &quot;&lt;&lt;&quot;)</span>
 602 
 603         when &quot;rshifti&quot;
 604             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 605         when &quot;rshiftq&quot;
 606             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 607         when &quot;rshiftp&quot;
<a name="37" id="anc37"></a><span class="line-modified"> 608             cloopEmitShiftOperation(operands, :intptr, &quot;&gt;&gt;&quot;)</span>
 609 
 610         when &quot;urshifti&quot;
 611             cloopEmitShiftOperation(operands, :uint32, &quot;&gt;&gt;&quot;)
 612         when &quot;urshiftq&quot;
 613             cloopEmitShiftOperation(operands, :uint64, &quot;&gt;&gt;&quot;)
 614         when &quot;urshiftp&quot;
<a name="38" id="anc38"></a><span class="line-modified"> 615             cloopEmitShiftOperation(operands, :uintptr, &quot;&gt;&gt;&quot;)</span>
 616 
 617         when &quot;muli&quot;
 618             cloopEmitOperation(operands, :int32, &quot;*&quot;)
 619         when &quot;mulq&quot;
 620             cloopEmitOperation(operands, :int64, &quot;*&quot;)
 621         when &quot;mulp&quot;
<a name="39" id="anc39"></a><span class="line-modified"> 622             cloopEmitOperation(operands, :intptr, &quot;*&quot;)</span>
 623 
 624         when &quot;subi&quot;
 625             cloopEmitOperation(operands, :int32, &quot;-&quot;)
 626         when &quot;subq&quot;
 627             cloopEmitOperation(operands, :int64, &quot;-&quot;)
 628         when &quot;subp&quot;
<a name="40" id="anc40"></a><span class="line-modified"> 629             cloopEmitOperation(operands, :intptr, &quot;-&quot;)</span>
 630 
 631         when &quot;negi&quot;
 632             cloopEmitUnaryOperation(operands, :int32, &quot;-&quot;)
 633         when &quot;negq&quot;
 634             cloopEmitUnaryOperation(operands, :int64, &quot;-&quot;)
 635         when &quot;negp&quot;
<a name="41" id="anc41"></a><span class="line-modified"> 636             cloopEmitUnaryOperation(operands, :intptr, &quot;-&quot;)</span>
 637 
 638         when &quot;noti&quot;
 639             cloopEmitUnaryOperation(operands, :int32, &quot;~&quot;)
 640 
 641         when &quot;loadi&quot;
 642             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = #{operands[0].uint32MemRef};&quot;
 643             # There&#39;s no need to call clearHighWord() here because the above will
 644             # automatically take care of 0 extension.
 645         when &quot;loadis&quot;
 646             $asm.putc &quot;#{operands[1].clLValue(:int32)} = #{operands[0].int32MemRef};&quot;
 647         when &quot;loadq&quot;
 648             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].int64MemRef};&quot;
 649         when &quot;loadp&quot;
<a name="42" id="anc42"></a><span class="line-modified"> 650             $asm.putc &quot;#{operands[1].clLValue} = #{operands[0].intptrMemRef};&quot;</span>
 651         when &quot;storei&quot;
 652             $asm.putc &quot;#{operands[1].int32MemRef} = #{operands[0].clValue(:int32)};&quot;
 653         when &quot;storeq&quot;
 654             $asm.putc &quot;#{operands[1].int64MemRef} = #{operands[0].clValue(:int64)};&quot;
 655         when &quot;storep&quot;
<a name="43" id="anc43"></a><span class="line-modified"> 656             $asm.putc &quot;#{operands[1].intptrMemRef} = #{operands[0].clValue(:intptr)};&quot;</span>
 657         when &quot;loadb&quot;
<a name="44" id="anc44"></a><span class="line-modified"> 658             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint8MemRef};&quot;</span>
<span class="line-modified"> 659         when &quot;loadbsi&quot;</span>
<span class="line-modified"> 660             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int8MemRef});&quot;</span>
<span class="line-modified"> 661         when &quot;loadbsq&quot;</span>
<span class="line-modified"> 662             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int8MemRef};&quot;</span>
 663         when &quot;storeb&quot;
 664             $asm.putc &quot;#{operands[1].uint8MemRef} = #{operands[0].clValue(:int8)};&quot;
 665         when &quot;loadh&quot;
<a name="45" id="anc45"></a><span class="line-modified"> 666             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint16MemRef};&quot;</span>
<span class="line-modified"> 667         when &quot;loadhsi&quot;</span>
<span class="line-modified"> 668             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int16MemRef});&quot;</span>
<span class="line-added"> 669         when &quot;loadhsq&quot;</span>
<span class="line-added"> 670             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int16MemRef};&quot;</span>
 671         when &quot;storeh&quot;
 672             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 673         when &quot;loadd&quot;
 674             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 675         when &quot;stored&quot;
 676             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 677 
 678         when &quot;addd&quot;
 679             cloopEmitOperation(operands, :double, &quot;+&quot;)
 680         when &quot;divd&quot;
 681             cloopEmitOperation(operands, :double, &quot;/&quot;)
 682         when &quot;subd&quot;
 683             cloopEmitOperation(operands, :double, &quot;-&quot;)
 684         when &quot;muld&quot;
 685             cloopEmitOperation(operands, :double, &quot;*&quot;)
 686 
 687         # Convert an int value to its double equivalent, and store it in a double register.
 688         when &quot;ci2d&quot;
 689             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;
 690 
 691         when &quot;bdeq&quot;
 692             cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
 693         when &quot;bdneq&quot;
 694             cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
 695         when &quot;bdgt&quot;
 696             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;&quot;);
 697         when &quot;bdgteq&quot;
 698             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 699         when &quot;bdlt&quot;
 700             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 701         when &quot;bdlteq&quot;
 702             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 703 
 704         when &quot;bdequn&quot;
 705             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 706         when &quot;bdnequn&quot;
 707             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 708         when &quot;bdgtun&quot;
 709             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
 710         when &quot;bdgtequn&quot;
 711             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;=&quot;)
 712         when &quot;bdltun&quot;
 713             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;&quot;)
 714         when &quot;bdltequn&quot;
 715             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;=&quot;)
 716 
 717         when &quot;td2i&quot;
<a name="46" id="anc46"></a><span class="line-modified"> 718             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = (uint32_t)(intptr_t)#{operands[0].clValue(:double)}; // td2i&quot;</span>
 719 
 720         when &quot;bcd2i&quot;  # operands: srcDbl dstInt slowPath
 721             $asm.putc &quot;{ // bcd2i&quot;
 722             $asm.putc &quot;    double d = #{operands[0].clValue(:double)};&quot;
 723             $asm.putc &quot;    const int32_t asInt32 = int32_t(d);&quot;
 724             $asm.putc &quot;    if (asInt32 != d || (!asInt32 &amp;&amp; std::signbit(d))) // true for -0.0&quot;
 725             $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 726             $asm.putc &quot;    #{operands[1].clLValue} = (uint32_t)asInt32;&quot;
 727             $asm.putc &quot;}&quot;
 728 
 729         when &quot;move&quot;
<a name="47" id="anc47"></a><span class="line-modified"> 730             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].clValue(:intptr)};&quot;</span>
 731         when &quot;sxi2q&quot;
 732             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:int32)};&quot;
 733         when &quot;zxi2q&quot;
 734             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = #{operands[0].clValue(:uint32)};&quot;
 735         when &quot;nop&quot;
 736             $asm.putc &quot;// nop&quot;
 737         when &quot;bbeq&quot;
 738             cloopEmitCompareAndBranch(operands, :int8, &quot;==&quot;)
 739         when &quot;bieq&quot;
 740             cloopEmitCompareAndBranch(operands, :int32, &quot;==&quot;)
 741         when &quot;bqeq&quot;
 742             cloopEmitCompareAndBranch(operands, :int64, &quot;==&quot;)
 743         when &quot;bpeq&quot;
<a name="48" id="anc48"></a><span class="line-modified"> 744             cloopEmitCompareAndBranch(operands, :intptr, &quot;==&quot;)</span>
 745 
 746         when &quot;bbneq&quot;
 747             cloopEmitCompareAndBranch(operands, :int8, &quot;!=&quot;)
 748         when &quot;bineq&quot;
 749             cloopEmitCompareAndBranch(operands, :int32, &quot;!=&quot;)
 750         when &quot;bqneq&quot;
 751             cloopEmitCompareAndBranch(operands, :int64, &quot;!=&quot;)
 752         when &quot;bpneq&quot;
<a name="49" id="anc49"></a><span class="line-modified"> 753             cloopEmitCompareAndBranch(operands, :intptr, &quot;!=&quot;)</span>
 754 
 755         when &quot;bba&quot;
 756             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;&quot;)
 757         when &quot;bia&quot;
 758             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;&quot;)
 759         when &quot;bqa&quot;
 760             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;&quot;)
 761         when &quot;bpa&quot;
<a name="50" id="anc50"></a><span class="line-modified"> 762             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;&quot;)</span>
 763 
 764         when &quot;bbaeq&quot;
 765             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;=&quot;)
 766         when &quot;biaeq&quot;
 767             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;=&quot;)
 768         when &quot;bqaeq&quot;
 769             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;=&quot;)
 770         when &quot;bpaeq&quot;
<a name="51" id="anc51"></a><span class="line-modified"> 771             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;=&quot;)</span>
 772 
 773         when &quot;bbb&quot;
 774             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;&quot;)
 775         when &quot;bib&quot;
 776             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;&quot;)
 777         when &quot;bqb&quot;
 778             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;&quot;)
 779         when &quot;bpb&quot;
<a name="52" id="anc52"></a><span class="line-modified"> 780             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;&quot;)</span>
 781 
 782         when &quot;bbbeq&quot;
 783             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;=&quot;)
 784         when &quot;bibeq&quot;
 785             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;=&quot;)
 786         when &quot;bqbeq&quot;
 787             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;=&quot;)
 788         when &quot;bpbeq&quot;
<a name="53" id="anc53"></a><span class="line-modified"> 789             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;=&quot;)</span>
 790 
 791         when &quot;bbgt&quot;
 792             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;&quot;)
 793         when &quot;bigt&quot;
 794             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;&quot;)
 795         when &quot;bqgt&quot;
 796             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;&quot;)
 797         when &quot;bpgt&quot;
<a name="54" id="anc54"></a><span class="line-modified"> 798             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;&quot;)</span>
 799 
 800         when &quot;bbgteq&quot;
 801             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;=&quot;)
 802         when &quot;bigteq&quot;
 803             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;=&quot;)
 804         when &quot;bqgteq&quot;
 805             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;=&quot;)
 806         when &quot;bpgteq&quot;
<a name="55" id="anc55"></a><span class="line-modified"> 807             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;=&quot;)</span>
 808 
 809         when &quot;bblt&quot;
 810             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;&quot;)
 811         when &quot;bilt&quot;
 812             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;&quot;)
 813         when &quot;bqlt&quot;
 814             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;&quot;)
 815         when &quot;bplt&quot;
<a name="56" id="anc56"></a><span class="line-modified"> 816             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;&quot;)</span>
 817 
 818         when &quot;bblteq&quot;
 819             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;=&quot;)
 820         when &quot;bilteq&quot;
 821             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;=&quot;)
 822         when &quot;bqlteq&quot;
 823             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;=&quot;)
 824         when &quot;bplteq&quot;
<a name="57" id="anc57"></a><span class="line-modified"> 825             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;=&quot;)</span>
 826 
 827         when &quot;btbz&quot;
 828             cloopEmitTestAndBranchIf(operands, :int8, &quot;== 0&quot;, operands[-1].cLabel)
 829         when &quot;btiz&quot;
 830             cloopEmitTestAndBranchIf(operands, :int32, &quot;== 0&quot;, operands[-1].cLabel)
 831         when &quot;btqz&quot;
 832             cloopEmitTestAndBranchIf(operands, :int64, &quot;== 0&quot;, operands[-1].cLabel)
 833         when &quot;btpz&quot;
<a name="58" id="anc58"></a><span class="line-modified"> 834             cloopEmitTestAndBranchIf(operands, :intptr, &quot;== 0&quot;, operands[-1].cLabel)</span>
 835 
 836         when &quot;btbnz&quot;
 837             cloopEmitTestAndBranchIf(operands, :int8, &quot;!= 0&quot;, operands[-1].cLabel)
 838         when &quot;btinz&quot;
 839             cloopEmitTestAndBranchIf(operands, :int32, &quot;!= 0&quot;, operands[-1].cLabel)
 840         when &quot;btqnz&quot;
 841             cloopEmitTestAndBranchIf(operands, :int64, &quot;!= 0&quot;, operands[-1].cLabel)
 842         when &quot;btpnz&quot;
<a name="59" id="anc59"></a><span class="line-modified"> 843             cloopEmitTestAndBranchIf(operands, :intptr, &quot;!= 0&quot;, operands[-1].cLabel)</span>
 844 
 845         when &quot;btbs&quot;
 846             cloopEmitTestAndBranchIf(operands, :int8, &quot;&lt; 0&quot;, operands[-1].cLabel)
 847         when &quot;btis&quot;
 848             cloopEmitTestAndBranchIf(operands, :int32, &quot;&lt; 0&quot;, operands[-1].cLabel)
 849         when &quot;btqs&quot;
 850             cloopEmitTestAndBranchIf(operands, :int64, &quot;&lt; 0&quot;, operands[-1].cLabel)
 851         when &quot;btps&quot;
<a name="60" id="anc60"></a><span class="line-modified"> 852             cloopEmitTestAndBranchIf(operands, :intptr, &quot;&lt; 0&quot;, operands[-1].cLabel)</span>
 853 
 854         # For jmp, we do not want to assume that we have COMPUTED_GOTO support.
 855         # Fortunately, the only times we should ever encounter indirect jmps is
 856         # when the jmp target is a CLoop opcode (by design).
 857         #
 858         # Hence, we check if the jmp target is a known label reference. If so,
 859         # we can emit a goto directly. If it is not a known target, then we set
 860         # the target in the opcode, and dispatch to it via whatever dispatch
 861         # mechanism is in used.
 862         when &quot;jmp&quot;
 863             if operands[0].is_a? LocalLabelReference or operands[0].is_a? LabelReference
 864                 # Handles jumps local or global labels.
 865                 $asm.putc &quot;goto #{operands[0].cLabel};&quot;
 866             else
 867                 # Handles jumps to some computed target.
 868                 # NOTE: must be an opcode handler or a llint glue helper.
 869                 $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
 870                 $asm.putc &quot;DISPATCH_OPCODE();&quot;
 871             end
 872 
 873         when &quot;call&quot;
 874             $asm.putc &quot;CRASH(); // generic call instruction not supported by design!&quot;
 875         when &quot;break&quot;
 876             $asm.putc &quot;CRASH(); // break instruction not implemented.&quot;
 877         when &quot;ret&quot;
 878             $asm.putc &quot;opcode = lr.opcode();&quot;
 879             $asm.putc &quot;DISPATCH_OPCODE();&quot;
 880 
 881         when &quot;cbeq&quot;
 882             cloopEmitCompareAndSet(operands, :uint8, &quot;==&quot;)
 883         when &quot;cieq&quot;
 884             cloopEmitCompareAndSet(operands, :uint32, &quot;==&quot;)
 885         when &quot;cqeq&quot;
 886             cloopEmitCompareAndSet(operands, :uint64, &quot;==&quot;)
 887         when &quot;cpeq&quot;
<a name="61" id="anc61"></a><span class="line-modified"> 888             cloopEmitCompareAndSet(operands, :uintptr, &quot;==&quot;)</span>
 889 
 890         when &quot;cbneq&quot;
 891             cloopEmitCompareAndSet(operands, :uint8, &quot;!=&quot;)
 892         when &quot;cineq&quot;
 893             cloopEmitCompareAndSet(operands, :uint32, &quot;!=&quot;)
 894         when &quot;cqneq&quot;
 895             cloopEmitCompareAndSet(operands, :uint64, &quot;!=&quot;)
 896         when &quot;cpneq&quot;
<a name="62" id="anc62"></a><span class="line-modified"> 897             cloopEmitCompareAndSet(operands, :uintptr, &quot;!=&quot;)</span>
 898 
 899         when &quot;cba&quot;
 900             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;&quot;)
 901         when &quot;cia&quot;
 902             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;&quot;)
 903         when &quot;cqa&quot;
 904             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;&quot;)
 905         when &quot;cpa&quot;
<a name="63" id="anc63"></a><span class="line-modified"> 906             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;&quot;)</span>
 907 
 908         when &quot;cbaeq&quot;
 909             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;=&quot;)
 910         when &quot;ciaeq&quot;
 911             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;=&quot;)
 912         when &quot;cqaeq&quot;
 913             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;=&quot;)
 914         when &quot;cpaeq&quot;
<a name="64" id="anc64"></a><span class="line-modified"> 915             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;=&quot;)</span>
 916 
 917         when &quot;cbb&quot;
 918             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;&quot;)
 919         when &quot;cib&quot;
 920             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;&quot;)
 921         when &quot;cqb&quot;
 922             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;&quot;)
 923         when &quot;cpb&quot;
<a name="65" id="anc65"></a><span class="line-modified"> 924             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;&quot;)</span>
 925 
 926         when &quot;cbbeq&quot;
 927             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;=&quot;)
 928         when &quot;cibeq&quot;
 929             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;=&quot;)
 930         when &quot;cqbeq&quot;
 931             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;=&quot;)
 932         when &quot;cpbeq&quot;
<a name="66" id="anc66"></a><span class="line-modified"> 933             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;=&quot;)</span>
 934 
 935         when &quot;cbgt&quot;
 936             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;&quot;)
 937         when &quot;cigt&quot;
 938             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;&quot;)
 939         when &quot;cqgt&quot;
 940             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;&quot;)
 941         when &quot;cpgt&quot;
<a name="67" id="anc67"></a><span class="line-modified"> 942             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;&quot;)</span>
 943 
 944         when &quot;cbgteq&quot;
 945             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;=&quot;)
 946         when &quot;cigteq&quot;
 947             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;=&quot;)
 948         when &quot;cqgteq&quot;
 949             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;=&quot;)
 950         when &quot;cpgteq&quot;
<a name="68" id="anc68"></a><span class="line-modified"> 951             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;=&quot;)</span>
 952 
 953         when &quot;cblt&quot;
 954             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;&quot;)
 955         when &quot;cilt&quot;
 956             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;&quot;)
 957         when &quot;cqlt&quot;
 958             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;&quot;)
 959         when &quot;cplt&quot;
<a name="69" id="anc69"></a><span class="line-modified"> 960             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;&quot;)</span>
 961 
 962         when &quot;cblteq&quot;
 963             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;=&quot;)
 964         when &quot;cilteq&quot;
 965             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;=&quot;)
 966         when &quot;cqlteq&quot;
 967             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;=&quot;)
 968         when &quot;cplteq&quot;
<a name="70" id="anc70"></a><span class="line-modified"> 969             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;=&quot;)</span>
 970 
 971         when &quot;tbs&quot;
 972             cloopEmitTestSet(operands, :int8, &quot;&lt; 0&quot;)
 973         when &quot;tis&quot;
 974             cloopEmitTestSet(operands, :int32, &quot;&lt; 0&quot;)
 975         when &quot;tqs&quot;
 976             cloopEmitTestSet(operands, :int64, &quot;&lt; 0&quot;)
 977         when &quot;tps&quot;
<a name="71" id="anc71"></a><span class="line-modified"> 978             cloopEmitTestSet(operands, :intptr, &quot;&lt; 0&quot;)</span>
 979 
 980         when &quot;tbz&quot;
 981             cloopEmitTestSet(operands, :int8, &quot;== 0&quot;)
 982         when &quot;tiz&quot;
 983             cloopEmitTestSet(operands, :int32, &quot;== 0&quot;)
 984         when &quot;tqz&quot;
 985             cloopEmitTestSet(operands, :int64, &quot;== 0&quot;)
 986         when &quot;tpz&quot;
<a name="72" id="anc72"></a><span class="line-modified"> 987             cloopEmitTestSet(operands, :intptr, &quot;== 0&quot;)</span>
 988 
 989         when &quot;tbnz&quot;
 990             cloopEmitTestSet(operands, :int8, &quot;!= 0&quot;)
 991         when &quot;tinz&quot;
 992             cloopEmitTestSet(operands, :int32, &quot;!= 0&quot;)
 993         when &quot;tqnz&quot;
 994             cloopEmitTestSet(operands, :int64, &quot;!= 0&quot;)
 995         when &quot;tpnz&quot;
<a name="73" id="anc73"></a><span class="line-modified"> 996             cloopEmitTestSet(operands, :intptr, &quot;!= 0&quot;)</span>
 997 
 998         # 64-bit instruction: cdqi (based on X64)
 999         # Sign extends the lower 32 bits of t0, but put the sign extension into
1000         # the lower 32 bits of t1. Leave the upper 32 bits of t0 and t1 unchanged.
1001         when &quot;cdqi&quot;
1002             $asm.putc &quot;{ // cdqi&quot;
1003             $asm.putc &quot;    int64_t temp = t0.i32(); // sign extend the low 32bit&quot;
1004             $asm.putc &quot;    t0 = (uint32_t)temp; // low word&quot;
1005             $asm.putc &quot;    t1 = (uint32_t)(temp &gt;&gt; 32); // high word&quot;
1006             $asm.putc &quot;}&quot;
1007 
1008         # 64-bit instruction: idivi op1 (based on X64)
1009         # Divide a 64-bit integer numerator by the specified denominator.
1010         # The numerator is specified in t0 and t1 as follows:
1011         #     1. low 32 bits of the numerator is in the low 32 bits of t0.
1012         #     2. high 32 bits of the numerator is in the low 32 bits of t1.
1013         #
1014         # The resultant quotient is a signed 32-bit int, and is to be stored
1015         # in the lower 32 bits of t0.
1016         # The resultant remainder is a signed 32-bit int, and is to be stored
1017         # in the lower 32 bits of t1.
1018         when &quot;idivi&quot;
1019             # Divide t1,t0 (EDX,EAX) by the specified arg, and store the remainder in t1,
1020             # and quotient in t0:
1021             $asm.putc &quot;{ // idivi&quot;
1022             $asm.putc &quot;    int64_t dividend = (int64_t(t1.u32()) &lt;&lt; 32) | t0.u32();&quot;
<a name="74" id="anc74"></a><span class="line-modified">1023             $asm.putc &quot;    int64_t divisor = #{operands[0].clValue(:intptr)};&quot;</span>
1024             $asm.putc &quot;    t1 = (uint32_t)(dividend % divisor); // remainder&quot;
1025             $asm.putc &quot;    t0 = (uint32_t)(dividend / divisor); // quotient&quot;
1026             $asm.putc &quot;}&quot;
1027 
1028         # 32-bit instruction: fii2d int32LoOp int32HiOp dblOp (based on ARMv7)
1029         # Decode 2 32-bit ints (low and high) into a 64-bit double.
1030         when &quot;fii2d&quot;
1031             $asm.putc &quot;#{operands[2].clLValue(:double)} = ints2Double(#{operands[0].clValue(:uint32)}, #{operands[1].clValue(:uint32)}); // fii2d&quot;
1032 
1033         # 32-bit instruction: f2dii dblOp int32LoOp int32HiOp (based on ARMv7)
1034         # Encode a 64-bit double into 2 32-bit ints (low and high).
1035         when &quot;fd2ii&quot;
1036             $asm.putc &quot;double2Ints(#{operands[0].clValue(:double)}, #{operands[1].clDump}, #{operands[2].clDump}); // fd2ii&quot;
1037 
1038         # 64-bit instruction: fq2d int64Op dblOp (based on X64)
1039         # Copy a bit-encoded double in a 64-bit int register to a double register.
1040         when &quot;fq2d&quot;
1041             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].clValue(:bitsAsDouble)}; // fq2d&quot;
1042 
1043         # 64-bit instruction: fd2q dblOp int64Op (based on X64 instruction set)
1044         # Copy a double as a bit-encoded double into a 64-bit int register.
1045         when &quot;fd2q&quot;
1046             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:bitsAsInt64)}; // fd2q&quot;
1047 
1048         when &quot;leai&quot;
1049             operands[0].cloopEmitLea(operands[1], :int32)
1050         when &quot;leap&quot;
<a name="75" id="anc75"></a><span class="line-modified">1051             operands[0].cloopEmitLea(operands[1], :intptr)</span>
1052 
1053         when &quot;baddio&quot;
1054             cloopEmitOpAndBranchIfOverflow(operands, &quot;+&quot;, :int32)
1055         when &quot;bsubio&quot;
1056             cloopEmitOpAndBranchIfOverflow(operands, &quot;-&quot;, :int32)
1057         when &quot;bmulio&quot;
1058             cloopEmitOpAndBranchIfOverflow(operands, &quot;*&quot;, :int32)
1059 
1060         when &quot;baddis&quot;
1061             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;&lt; 0&quot;)
1062         when &quot;baddiz&quot;
1063             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;== 0&quot;)
1064         when &quot;baddinz&quot;
1065             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;!= 0&quot;)
1066 
1067         when &quot;baddqs&quot;
1068             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;&lt; 0&quot;)
1069         when &quot;baddqz&quot;
1070             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;== 0&quot;)
1071         when &quot;baddqnz&quot;
1072             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;!= 0&quot;)
1073 
1074         when &quot;baddps&quot;
<a name="76" id="anc76"></a><span class="line-modified">1075             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;&lt; 0&quot;)</span>
1076         when &quot;baddpz&quot;
<a name="77" id="anc77"></a><span class="line-modified">1077             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;== 0&quot;)</span>
1078         when &quot;baddpnz&quot;
<a name="78" id="anc78"></a><span class="line-modified">1079             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;!= 0&quot;)</span>
1080 
1081         when &quot;bsubis&quot;
1082             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;&lt; 0&quot;)
1083         when &quot;bsubiz&quot;
1084             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;== 0&quot;)
1085         when &quot;bsubinz&quot;
1086             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;!= 0&quot;)
1087 
1088         when &quot;borris&quot;
1089             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;&lt; 0&quot;)
1090         when &quot;borriz&quot;
1091             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;== 0&quot;)
1092         when &quot;borrinz&quot;
1093             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;!= 0&quot;)
1094             
1095         when &quot;memfence&quot;
1096 
1097         when &quot;push&quot;
1098             operands.each {
1099                 | op |
1100                 $asm.putc &quot;PUSH(#{op.clDump});&quot;
1101             }
1102         when &quot;pop&quot;
1103             operands.each {
1104                 | op |
1105                 $asm.putc &quot;POP(#{op.clDump});&quot;
1106             }
1107 
1108 
1109         # A convenience and compact call to crash because we don&#39;t want to use
1110         # the generic llint crash mechanism which relies on the availability
1111         # of the call instruction (which cannot be implemented in a generic
1112         # way, and can be abused if we made it just work for this special case).
1113         # Using a special cloopCrash instruction is cleaner.
1114         when &quot;cloopCrash&quot;
1115             $asm.putc &quot;CRASH();&quot;
1116 
1117         # We can&#39;t rely on the llint JS call mechanism which actually makes
1118         # use of the call instruction. Instead, we just implement JS calls
1119         # as an opcode dispatch.
1120         when &quot;cloopCallJSFunction&quot;
1121             uid = $asm.newUID
1122             $asm.putc &quot;lr = getOpcode(llint_cloop_did_return_from_js_#{uid});&quot;
1123             $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
1124             $asm.putc &quot;DISPATCH_OPCODE();&quot;
1125             $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
1126 
1127         # We can&#39;t do generic function calls with an arbitrary set of args, but
1128         # fortunately we don&#39;t have to here. All native function calls always
1129         # have a fixed prototype of 1 args: the passed ExecState.
1130         when &quot;cloopCallNative&quot;
1131             $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
1132             $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
1133             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(t0.execState()));&quot;
1134             $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
1135             $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
1136             $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
1137             $asm.putc &quot;#else // USE_JSVALUE64)&quot;
1138             $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
1139             $asm.putc &quot;#endif // USE_JSVALUE64)&quot;
1140 
1141         # We can&#39;t do generic function calls with an arbitrary set of args, but
1142         # fortunately we don&#39;t have to here. All slow path function calls always
1143         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1144         when &quot;cloopCallSlowPath&quot;
1145             cloopEmitCallSlowPath(operands)
1146 
1147         when &quot;cloopCallSlowPathVoid&quot;
1148             cloopEmitCallSlowPathVoid(operands)
1149 
1150         # For debugging only. This is used to insert instrumentation into the
1151         # generated LLIntAssembly.h during llint development only. Do not use
1152         # for production code.
1153         when &quot;cloopDo&quot;
1154             $asm.putc &quot;#{annotation}&quot;
1155 
1156         else
1157             lowerDefault
1158         end
1159     end
1160 
<a name="79" id="anc79"></a><span class="line-added">1161     def lowerC_LOOP_WIN</span>
<span class="line-added">1162         lowerC_LOOP</span>
<span class="line-added">1163     end</span>
<span class="line-added">1164 </span>
1165     def recordMetaDataC_LOOP
1166         $asm.codeOrigin codeOriginString if $enableCodeOriginComments
1167         $asm.annotation annotation if $enableInstrAnnotations &amp;&amp; (opcode != &quot;cloopDo&quot;)
1168         $asm.debugAnnotation codeOrigin.debugDirective if $enableDebugAnnotations
1169     end
1170 end
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>