<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/DatabaseTracker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2008, 2012, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;DatabaseTracker.h&quot;
  31 
  32 #include &quot;Database.h&quot;
  33 #include &quot;DatabaseContext.h&quot;
  34 #include &quot;DatabaseManager.h&quot;
  35 #include &quot;DatabaseManagerClient.h&quot;
  36 #include &quot;DatabaseThread.h&quot;
  37 #include &quot;Logging.h&quot;
  38 #include &quot;OriginLock.h&quot;
  39 #include &quot;SecurityOrigin.h&quot;
  40 #include &quot;SecurityOriginData.h&quot;
  41 #include &quot;SecurityOriginHash.h&quot;
  42 #include &quot;SQLiteFileSystem.h&quot;
  43 #include &quot;SQLiteStatement.h&quot;
  44 #include &quot;SQLiteTransaction.h&quot;
  45 #include &lt;wtf/FileSystem.h&gt;
  46 #include &lt;wtf/MainThread.h&gt;
  47 #include &lt;wtf/NeverDestroyed.h&gt;
  48 #include &lt;wtf/StdLibExtras.h&gt;
  49 #include &lt;wtf/UUID.h&gt;
  50 #include &lt;wtf/text/CString.h&gt;
  51 #include &lt;wtf/text/StringBuilder.h&gt;
  52 
  53 #if PLATFORM(IOS_FAMILY)
  54 #include &quot;WebCoreThread.h&quot;
  55 #endif
  56 
  57 namespace WebCore {
  58 
  59 static Vector&lt;String&gt; isolatedCopy(const Vector&lt;String&gt;&amp; original)
  60 {
  61     Vector&lt;String&gt; copy;
  62     copy.reserveInitialCapacity(original.size());
  63     for (auto&amp; string : original)
  64         copy.uncheckedAppend(string.isolatedCopy());
  65     return copy;
  66 }
  67 
  68 std::unique_ptr&lt;DatabaseTracker&gt; DatabaseTracker::trackerWithDatabasePath(const String&amp; databasePath)
  69 {
  70     return std::unique_ptr&lt;DatabaseTracker&gt;(new DatabaseTracker(databasePath));
  71 }
  72 
  73 static DatabaseTracker* staticTracker = nullptr;
  74 
  75 void DatabaseTracker::initializeTracker(const String&amp; databasePath)
  76 {
  77     ASSERT(!staticTracker);
  78     if (staticTracker)
  79         return;
  80     staticTracker = new DatabaseTracker(databasePath);
  81 }
  82 
  83 bool DatabaseTracker::isInitialized()
  84 {
  85     return !!staticTracker;
  86 }
  87 
  88 DatabaseTracker&amp; DatabaseTracker::singleton()
  89 {
  90     if (!staticTracker)
  91         staticTracker = new DatabaseTracker(emptyString());
  92     return *staticTracker;
  93 }
  94 
  95 DatabaseTracker::DatabaseTracker(const String&amp; databasePath)
  96     : m_databaseDirectoryPath(databasePath.isolatedCopy())
  97 {
  98 }
  99 
 100 String DatabaseTracker::trackerDatabasePath() const
 101 {
 102     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), &quot;Databases.db&quot;);
 103 }
 104 
 105 void DatabaseTracker::openTrackerDatabase(TrackerCreationAction createAction)
 106 {
 107     ASSERT(!m_databaseGuard.tryLock());
 108 
 109     if (m_database.isOpen())
 110         return;
 111 
 112     // If createIfDoesNotExist is false, SQLiteFileSystem::ensureDatabaseFileExists()
 113     // will return false if the database file does not exist.
 114     // If createIfDoesNotExist is true, SQLiteFileSystem::ensureDatabaseFileExists()
 115     // will attempt to create the path to the database file if it does not
 116     // exists yet. It&#39;ll return true if the path already exists, or if it
 117     // successfully creates the path. Else, it will return false.
 118     String databasePath = trackerDatabasePath();
 119     if (!SQLiteFileSystem::ensureDatabaseFileExists(databasePath, createAction == CreateIfDoesNotExist))
 120         return;
 121 
 122     if (!m_database.open(databasePath)) {
 123         // FIXME: What do do here?
 124         LOG_ERROR(&quot;Failed to open databasePath %s.&quot;, databasePath.utf8().data());
 125         return;
 126     }
 127     m_database.disableThreadingChecks();
 128 
 129     if (!m_database.tableExists(&quot;Origins&quot;)) {
 130         if (!m_database.executeCommand(&quot;CREATE TABLE Origins (origin TEXT UNIQUE ON CONFLICT REPLACE, quota INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 131             // FIXME: and here
 132             LOG_ERROR(&quot;Failed to create Origins table&quot;);
 133         }
 134     }
 135 
 136     if (!m_database.tableExists(&quot;Databases&quot;)) {
 137         if (!m_database.executeCommand(&quot;CREATE TABLE Databases (guid INTEGER PRIMARY KEY AUTOINCREMENT, origin TEXT, name TEXT, displayName TEXT, estimatedSize INTEGER, path TEXT);&quot;)) {
 138             // FIXME: and here
 139             LOG_ERROR(&quot;Failed to create Databases table&quot;);
 140         }
 141     }
 142 }
 143 
 144 ExceptionOr&lt;void&gt; DatabaseTracker::hasAdequateQuotaForOrigin(const SecurityOriginData&amp; origin, unsigned long long estimatedSize)
 145 {
 146     ASSERT(!m_databaseGuard.tryLock());
 147     auto usage = this-&gt;usage(origin);
 148 
 149     // If the database will fit, allow its creation.
 150     auto requirement = usage + std::max&lt;unsigned long long&gt;(1, estimatedSize);
 151     if (requirement &lt; usage) {
 152         // The estimated size is so big it causes an overflow; don&#39;t allow creation.
 153         return Exception { SecurityError };
 154     }
 155     if (requirement &gt; quotaNoLock(origin))
 156         return Exception { QuotaExceededError };
 157     return { };
 158 }
 159 
 160 ExceptionOr&lt;void&gt; DatabaseTracker::canEstablishDatabase(DatabaseContext&amp; context, const String&amp; name, unsigned long long estimatedSize)
 161 {
 162     LockHolder lockDatabase(m_databaseGuard);
 163 
 164     // FIXME: What guarantees this context.securityOrigin() is non-null?
 165     auto origin = context.securityOrigin();
 166 
 167     if (isDeletingDatabaseOrOriginFor(origin, name))
 168         return Exception { SecurityError };
 169 
 170     recordCreatingDatabase(origin, name);
 171 
 172     // If a database already exists, ignore the passed-in estimated size and say it&#39;s OK.
 173     if (hasEntryForDatabase(origin, name))
 174         return { };
 175 
 176     auto result = hasAdequateQuotaForOrigin(origin, estimatedSize);
 177     if (!result.hasException())
 178         return { };
 179 
 180     // If we get here, then we do not have enough quota for one of the
 181     // following reasons as indicated by the set error:
 182     //
 183     // If the error is DatabaseSizeOverflowed, then this means the requested
 184     // estimatedSize if so unreasonably large that it can cause an overflow in
 185     // the usage budget computation. In that case, there&#39;s nothing more we can
 186     // do, and there&#39;s no need for a retry. Hence, we should indicate that
 187     // we&#39;re done with our attempt to create the database.
 188     //
 189     // If the error is DatabaseSizeExceededQuota, then we&#39;ll give the client
 190     // a chance to update the quota and call retryCanEstablishDatabase() to try
 191     // again. Hence, we don&#39;t call doneCreatingDatabase() yet in that case.
 192 
 193     auto exception = result.releaseException();
 194     if (exception.code() != QuotaExceededError)
 195         doneCreatingDatabase(origin, name);
 196 
 197     return exception;
 198 }
 199 
 200 // Note: a thought about performance: hasAdequateQuotaForOrigin() was also
 201 // called in canEstablishDatabase(), and hence, we&#39;re repeating some work within
 202 // hasAdequateQuotaForOrigin(). However, retryCanEstablishDatabase() should only
 203 // be called in the rare even if canEstablishDatabase() fails. Since it is rare,
 204 // we should not bother optimizing it. It is more beneficial to keep
 205 // hasAdequateQuotaForOrigin() simple and correct (i.e. bug free), and just
 206 // re-use it. Also note that the path for opening a database involves IO, and
 207 // hence should not be a performance critical path anyway.
 208 ExceptionOr&lt;void&gt; DatabaseTracker::retryCanEstablishDatabase(DatabaseContext&amp; context, const String&amp; name, unsigned long long estimatedSize)
 209 {
 210     LockHolder lockDatabase(m_databaseGuard);
 211 
 212     // FIXME: What guarantees context.securityOrigin() is non-null?
 213     auto origin = context.securityOrigin();
 214 
 215     // We have already eliminated other types of errors in canEstablishDatabase().
 216     // The only reason we&#39;re in retryCanEstablishDatabase() is because we gave
 217     // the client a chance to update the quota and are rechecking it here.
 218     // If we fail this check, the only possible reason this time should be due
 219     // to inadequate quota.
 220     auto result = hasAdequateQuotaForOrigin(origin, estimatedSize);
 221     if (!result.hasException())
 222         return { };
 223 
 224     auto exception = result.releaseException();
 225     ASSERT(exception.code() == QuotaExceededError);
 226     doneCreatingDatabase(origin, name);
 227 
 228     return exception;
 229 }
 230 
 231 bool DatabaseTracker::hasEntryForOriginNoLock(const SecurityOriginData&amp; origin)
 232 {
 233     ASSERT(!m_databaseGuard.tryLock());
 234     openTrackerDatabase(DontCreateIfDoesNotExist);
 235     if (!m_database.isOpen())
 236         return false;
 237 
 238     SQLiteStatement statement(m_database, &quot;SELECT origin FROM Origins where origin=?;&quot;);
 239     if (statement.prepare() != SQLITE_OK) {
 240         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 241         return false;
 242     }
 243 
 244     statement.bindText(1, origin.databaseIdentifier());
 245 
 246     return statement.step() == SQLITE_ROW;
 247 }
 248 
 249 bool DatabaseTracker::hasEntryForDatabase(const SecurityOriginData&amp; origin, const String&amp; databaseIdentifier)
 250 {
 251     ASSERT(!m_databaseGuard.tryLock());
 252     openTrackerDatabase(DontCreateIfDoesNotExist);
 253     if (!m_database.isOpen()) {
 254         // No &quot;tracker database&quot;. Hence, no entry for the database of interest.
 255         return false;
 256     }
 257 
 258     // We&#39;ve got a tracker database. Set up a query to ask for the db of interest:
 259     SQLiteStatement statement(m_database, &quot;SELECT guid FROM Databases WHERE origin=? AND name=?;&quot;);
 260 
 261     if (statement.prepare() != SQLITE_OK)
 262         return false;
 263 
 264     statement.bindText(1, origin.databaseIdentifier());
 265     statement.bindText(2, databaseIdentifier);
 266 
 267     return statement.step() == SQLITE_ROW;
 268 }
 269 
 270 unsigned long long DatabaseTracker::maximumSize(Database&amp; database)
 271 {
 272     // The maximum size for a database is the full quota for its origin, minus the current usage within the origin,
 273     // plus the current usage of the given database
 274     LockHolder lockDatabase(m_databaseGuard);
 275     auto origin = database.securityOrigin();
 276 
 277     unsigned long long quota = quotaNoLock(origin);
 278     unsigned long long diskUsage = usage(origin);
 279     unsigned long long databaseFileSize = SQLiteFileSystem::getDatabaseFileSize(database.fileNameIsolatedCopy());
 280     ASSERT(databaseFileSize &lt;= diskUsage);
 281 
 282     if (diskUsage &gt; quota)
 283         return databaseFileSize;
 284 
 285     // A previous error may have allowed the origin to exceed its quota, or may
 286     // have allowed this database to exceed our cached estimate of the origin
 287     // disk usage. Don&#39;t multiply that error through integer underflow, or the
 288     // effective quota will permanently become 2^64.
 289     unsigned long long maxSize = quota - diskUsage + databaseFileSize;
 290     if (maxSize &gt; quota)
 291         maxSize = databaseFileSize;
 292     return maxSize;
 293 }
 294 
 295 void DatabaseTracker::closeAllDatabases(CurrentQueryBehavior currentQueryBehavior)
 296 {
 297     for (auto&amp; database : openDatabases()) {
 298         if (currentQueryBehavior == CurrentQueryBehavior::Interrupt)
 299             database-&gt;interrupt();
 300         database-&gt;close();
 301     }
 302 }
 303 
 304 String DatabaseTracker::originPath(const SecurityOriginData&amp; origin) const
 305 {
 306     return SQLiteFileSystem::appendDatabaseFileNameToPath(m_databaseDirectoryPath.isolatedCopy(), origin.databaseIdentifier());
 307 }
 308 
 309 static String generateDatabaseFileName()
 310 {
 311     return makeString(createCanonicalUUIDString(), &quot;.db&quot;);
 312 }
 313 
 314 String DatabaseTracker::fullPathForDatabaseNoLock(const SecurityOriginData&amp; origin, const String&amp; name, bool createIfNotExists)
 315 {
 316     ASSERT(!m_databaseGuard.tryLock());
 317 
 318     String originIdentifier = origin.databaseIdentifier();
 319     String originPath = this-&gt;originPath(origin);
 320 
 321     // Make sure the path for this SecurityOrigin exists
 322     if (createIfNotExists &amp;&amp; !SQLiteFileSystem::ensureDatabaseDirectoryExists(originPath))
 323         return String();
 324 
 325     // See if we have a path for this database yet
 326     if (!m_database.isOpen())
 327         return String();
 328     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
 329 
 330     if (statement.prepare() != SQLITE_OK)
 331         return String();
 332 
 333     statement.bindText(1, originIdentifier);
 334     statement.bindText(2, name);
 335 
 336     int result = statement.step();
 337 
 338     if (result == SQLITE_ROW)
 339         return SQLiteFileSystem::appendDatabaseFileNameToPath(originPath, statement.getColumnText(0));
 340     if (!createIfNotExists)
 341         return String();
 342 
 343     if (result != SQLITE_DONE) {
 344         LOG_ERROR(&quot;Failed to retrieve filename from Database Tracker for origin %s, name %s&quot;, originIdentifier.utf8().data(), name.utf8().data());
 345         return String();
 346     }
 347     statement.finalize();
 348 
 349     String fileName = generateDatabaseFileName();
 350 
 351     if (!addDatabase(origin, name, fileName))
 352         return String();
 353 
 354     // If this origin&#39;s quota is being tracked (open handle to a database in this origin), add this new database
 355     // to the quota manager now
 356     String fullFilePath = SQLiteFileSystem::appendDatabaseFileNameToPath(originPath, fileName);
 357 
 358     return fullFilePath;
 359 }
 360 
 361 String DatabaseTracker::fullPathForDatabase(const SecurityOriginData&amp; origin, const String&amp; name, bool createIfNotExists)
 362 {
 363     LockHolder lockDatabase(m_databaseGuard);
 364     return fullPathForDatabaseNoLock(origin, name, createIfNotExists).isolatedCopy();
 365 }
 366 
 367 Vector&lt;SecurityOriginData&gt; DatabaseTracker::origins()
 368 {
 369     LockHolder lockDatabase(m_databaseGuard);
 370 
 371     openTrackerDatabase(DontCreateIfDoesNotExist);
 372     if (!m_database.isOpen())
 373         return { };
 374 
 375     SQLiteStatement statement(m_database, &quot;SELECT origin FROM Origins&quot;);
 376     if (statement.prepare() != SQLITE_OK) {
 377         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 378         return { };
 379     }
 380 
 381     Vector&lt;SecurityOriginData&gt; origins;
 382     int stepResult;
 383     while ((stepResult = statement.step()) == SQLITE_ROW)
 384         origins.append(SecurityOriginData::fromDatabaseIdentifier(statement.getColumnText(0))-&gt;isolatedCopy());
 385     origins.shrinkToFit();
 386 
 387     if (stepResult != SQLITE_DONE)
 388         LOG_ERROR(&quot;Failed to read in all origins from the database.&quot;);
 389 
 390     return origins;
 391 }
 392 
 393 Vector&lt;String&gt; DatabaseTracker::databaseNamesNoLock(const SecurityOriginData&amp; origin)
 394 {
 395     ASSERT(!m_databaseGuard.tryLock());
 396     openTrackerDatabase(DontCreateIfDoesNotExist);
 397     if (!m_database.isOpen())
 398         return { };
 399 
 400     SQLiteStatement statement(m_database, &quot;SELECT name FROM Databases where origin=?;&quot;);
 401     if (statement.prepare() != SQLITE_OK)
 402         return { };
 403 
 404     statement.bindText(1, origin.databaseIdentifier());
 405 
 406     Vector&lt;String&gt; names;
 407     int result;
 408     while ((result = statement.step()) == SQLITE_ROW)
 409         names.append(statement.getColumnText(0));
 410     names.shrinkToFit();
 411 
 412     if (result != SQLITE_DONE) {
 413         LOG_ERROR(&quot;Failed to retrieve all database names for origin %s&quot;, origin.databaseIdentifier().utf8().data());
 414         return { };
 415     }
 416 
 417     return names;
 418 }
 419 
 420 Vector&lt;String&gt; DatabaseTracker::databaseNames(const SecurityOriginData&amp; origin)
 421 {
 422     Vector&lt;String&gt; names;
 423     {
 424         LockHolder lockDatabase(m_databaseGuard);
 425         names = databaseNamesNoLock(origin);
 426     }
 427     return isolatedCopy(names);
 428 }
 429 
 430 DatabaseDetails DatabaseTracker::detailsForNameAndOrigin(const String&amp; name, const SecurityOriginData&amp; origin)
 431 {
 432     String originIdentifier = origin.databaseIdentifier();
 433     String displayName;
 434     int64_t expectedUsage;
 435 
 436     {
 437         LockHolder lockDatabase(m_databaseGuard);
 438 
 439         openTrackerDatabase(DontCreateIfDoesNotExist);
 440         if (!m_database.isOpen())
 441             return DatabaseDetails();
 442         SQLiteStatement statement(m_database, &quot;SELECT displayName, estimatedSize FROM Databases WHERE origin=? AND name=?&quot;);
 443         if (statement.prepare() != SQLITE_OK)
 444             return DatabaseDetails();
 445 
 446         statement.bindText(1, originIdentifier);
 447         statement.bindText(2, name);
 448 
 449         int result = statement.step();
 450         if (result == SQLITE_DONE)
 451             return DatabaseDetails();
 452 
 453         if (result != SQLITE_ROW) {
 454             LOG_ERROR(&quot;Error retrieving details for database %s in origin %s from tracker database&quot;, name.utf8().data(), originIdentifier.utf8().data());
 455             return DatabaseDetails();
 456         }
 457         displayName = statement.getColumnText(0);
 458         expectedUsage = statement.getColumnInt64(1);
 459     }
 460 
 461     String path = fullPathForDatabase(origin, name, false);
 462     if (path.isEmpty())
 463         return DatabaseDetails(name, displayName, expectedUsage, 0, WTF::nullopt, WTF::nullopt);
 464     return DatabaseDetails(name, displayName, expectedUsage, SQLiteFileSystem::getDatabaseFileSize(path), SQLiteFileSystem::databaseCreationTime(path), SQLiteFileSystem::databaseModificationTime(path));
 465 }
 466 
 467 void DatabaseTracker::setDatabaseDetails(const SecurityOriginData&amp; origin, const String&amp; name, const String&amp; displayName, unsigned long long estimatedSize)
 468 {
 469     String originIdentifier = origin.databaseIdentifier();
 470     int64_t guid = 0;
 471 
 472     LockHolder lockDatabase(m_databaseGuard);
 473 
 474     openTrackerDatabase(CreateIfDoesNotExist);
 475     if (!m_database.isOpen())
 476         return;
 477     SQLiteStatement statement(m_database, &quot;SELECT guid FROM Databases WHERE origin=? AND name=?&quot;);
 478     if (statement.prepare() != SQLITE_OK)
 479         return;
 480 
 481     statement.bindText(1, originIdentifier);
 482     statement.bindText(2, name);
 483 
 484     int result = statement.step();
 485     if (result == SQLITE_ROW)
 486         guid = statement.getColumnInt64(0);
 487     statement.finalize();
 488 
 489     if (guid == 0) {
 490         if (result != SQLITE_DONE)
 491             LOG_ERROR(&quot;Error to determing existence of database %s in origin %s in tracker database&quot;, name.utf8().data(), originIdentifier.utf8().data());
 492         else {
 493             // This case should never occur - we should never be setting database details for a database that doesn&#39;t already exist in the tracker
 494             // But since the tracker file is an external resource not under complete control of our code, it&#39;s somewhat invalid to make this an ASSERT case
 495             // So we&#39;ll print an error instead
 496             LOG_ERROR(&quot;Could not retrieve guid for database %s in origin %s from the tracker database - it is invalid to set database details on a database that doesn&#39;t already exist in the tracker&quot;, name.utf8().data(), originIdentifier.utf8().data());
 497         }
 498         return;
 499     }
 500 
 501     SQLiteStatement updateStatement(m_database, &quot;UPDATE Databases SET displayName=?, estimatedSize=? WHERE guid=?&quot;);
 502     if (updateStatement.prepare() != SQLITE_OK)
 503         return;
 504 
 505     updateStatement.bindText(1, displayName);
 506     updateStatement.bindInt64(2, estimatedSize);
 507     updateStatement.bindInt64(3, guid);
 508 
 509     if (updateStatement.step() != SQLITE_DONE) {
 510         LOG_ERROR(&quot;Failed to update details for database %s in origin %s&quot;, name.utf8().data(), originIdentifier.utf8().data());
 511         return;
 512     }
 513 
 514     if (m_client)
 515         m_client-&gt;dispatchDidModifyDatabase(origin, name);
 516 }
 517 
 518 void DatabaseTracker::doneCreatingDatabase(Database&amp; database)
 519 {
 520     LockHolder lockDatabase(m_databaseGuard);
 521     doneCreatingDatabase(database.securityOrigin(), database.stringIdentifierIsolatedCopy());
 522 }
 523 
 524 Vector&lt;Ref&lt;Database&gt;&gt; DatabaseTracker::openDatabases()
 525 {
 526     Vector&lt;Ref&lt;Database&gt;&gt; openDatabases;
 527     {
 528         LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 529 
 530         if (m_openDatabaseMap) {
 531             for (auto&amp; nameMap : m_openDatabaseMap-&gt;values()) {
 532                 for (auto&amp; set : nameMap-&gt;values()) {
 533                     for (auto&amp; database : *set)
 534                         openDatabases.append(*database);
 535                 }
 536             }
 537         }
 538     }
 539     return openDatabases;
 540 }
 541 
 542 void DatabaseTracker::addOpenDatabase(Database&amp; database)
 543 {
 544     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 545 
 546     if (!m_openDatabaseMap)
 547         m_openDatabaseMap = makeUnique&lt;DatabaseOriginMap&gt;();
 548 
 549     auto origin = database.securityOrigin();
 550 
 551     auto* nameMap = m_openDatabaseMap-&gt;get(origin);
 552     if (!nameMap) {
 553         nameMap = new DatabaseNameMap;
 554         m_openDatabaseMap-&gt;add(origin.isolatedCopy(), nameMap);
 555     }
 556 
 557     String name = database.stringIdentifierIsolatedCopy();
 558     auto* databaseSet = nameMap-&gt;get(name);
 559     if (!databaseSet) {
 560         databaseSet = new DatabaseSet;
 561         nameMap-&gt;set(name.isolatedCopy(), databaseSet);
 562     }
 563 
 564     databaseSet-&gt;add(&amp;database);
 565 
 566     LOG(StorageAPI, &quot;Added open Database %s (%p)\n&quot;, database.stringIdentifierIsolatedCopy().utf8().data(), &amp;database);
 567 }
 568 
 569 void DatabaseTracker::removeOpenDatabase(Database&amp; database)
 570 {
 571     LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
 572 
 573     if (!m_openDatabaseMap) {
 574         ASSERT_NOT_REACHED();
 575         return;
 576     }
 577 
 578     DatabaseNameMap* nameMap = m_openDatabaseMap-&gt;get(database.securityOrigin());
 579     if (!nameMap) {
 580         ASSERT_NOT_REACHED();
 581         return;
 582     }
 583 
 584     String name = database.stringIdentifierIsolatedCopy();
 585     auto* databaseSet = nameMap-&gt;get(name);
 586     if (!databaseSet) {
 587         ASSERT_NOT_REACHED();
 588         return;
 589     }
 590 
 591     databaseSet-&gt;remove(&amp;database);
 592 
 593     LOG(StorageAPI, &quot;Removed open Database %s (%p)\n&quot;, database.stringIdentifierIsolatedCopy().utf8().data(), &amp;database);
 594 
 595     if (!databaseSet-&gt;isEmpty())
 596         return;
 597 
 598     nameMap-&gt;remove(name);
 599     delete databaseSet;
 600 
 601     if (!nameMap-&gt;isEmpty())
 602         return;
 603 
 604     m_openDatabaseMap-&gt;remove(database.securityOrigin());
 605     delete nameMap;
 606 }
 607 
 608 RefPtr&lt;OriginLock&gt; DatabaseTracker::originLockFor(const SecurityOriginData&amp; origin)
 609 {
 610     LockHolder lockDatabase(m_databaseGuard);
 611     String databaseIdentifier = origin.databaseIdentifier();
 612 
 613     // The originLockMap is accessed from multiple DatabaseThreads since
 614     // different script contexts can be writing to different databases from
 615     // the same origin. Hence, the databaseIdentifier key needs to be an
 616     // isolated copy. An isolated copy gives us a value whose refCounting is
 617     // thread-safe, since our copy is guarded by the m_databaseGuard mutex.
 618     databaseIdentifier = databaseIdentifier.isolatedCopy();
 619 
 620     OriginLockMap::AddResult addResult =
 621         m_originLockMap.add(databaseIdentifier, RefPtr&lt;OriginLock&gt;());
 622     if (!addResult.isNewEntry)
 623         return addResult.iterator-&gt;value;
 624 
 625     String path = originPath(origin);
 626     RefPtr&lt;OriginLock&gt; lock = adoptRef(*new OriginLock(path));
 627     ASSERT(lock);
 628     addResult.iterator-&gt;value = lock;
 629 
 630     return lock;
 631 }
 632 
 633 void DatabaseTracker::deleteOriginLockFor(const SecurityOriginData&amp; origin)
 634 {
 635     ASSERT(!m_databaseGuard.tryLock());
 636 
 637     // There is not always an instance of an OriginLock associated with an origin.
 638     // For example, if the OriginLock lock file was created by a previous run of
 639     // the browser which has now terminated, and the current browser process
 640     // has not executed any database transactions from this origin that would
 641     // have created the OriginLock instance in memory. In this case, we will have
 642     // a lock file but not an OriginLock instance in memory.
 643 
 644     // This function is only called if we are already deleting all the database
 645     // files in this origin. We&#39;ll give the OriginLock one chance to do an
 646     // orderly clean up first when we remove its ref from the m_originLockMap.
 647     // This may or may not be possible depending on whether other threads are
 648     // also using the OriginLock at the same time. After that, we will delete the lock file.
 649 
 650     m_originLockMap.remove(origin.databaseIdentifier());
 651     OriginLock::deleteLockFile(originPath(origin));
 652 }
 653 
 654 unsigned long long DatabaseTracker::usage(const SecurityOriginData&amp; origin)
 655 {
 656     String originPath = this-&gt;originPath(origin);
 657     unsigned long long diskUsage = 0;
 658     for (auto&amp; fileName : FileSystem::listDirectory(originPath, &quot;*.db&quot;_s))
 659         diskUsage += SQLiteFileSystem::getDatabaseFileSize(fileName);
 660     return diskUsage;
 661 }
 662 
 663 unsigned long long DatabaseTracker::quotaNoLock(const SecurityOriginData&amp; origin)
 664 {
 665     ASSERT(!m_databaseGuard.tryLock());
 666     unsigned long long quota = 0;
 667 
 668     openTrackerDatabase(DontCreateIfDoesNotExist);
 669     if (!m_database.isOpen())
 670         return quota;
 671 
 672     SQLiteStatement statement(m_database, &quot;SELECT quota FROM Origins where origin=?;&quot;);
 673     if (statement.prepare() != SQLITE_OK) {
 674         LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 675         return quota;
 676     }
 677     statement.bindText(1, origin.databaseIdentifier());
 678 
 679     if (statement.step() == SQLITE_ROW)
 680         quota = statement.getColumnInt64(0);
 681 
 682     return quota;
 683 }
 684 
 685 unsigned long long DatabaseTracker::quota(const SecurityOriginData&amp; origin)
 686 {
 687     LockHolder lockDatabase(m_databaseGuard);
 688     return quotaNoLock(origin);
 689 }
 690 
 691 void DatabaseTracker::setQuota(const SecurityOriginData&amp; origin, unsigned long long quota)
 692 {
 693     LockHolder lockDatabase(m_databaseGuard);
 694 
 695     if (quotaNoLock(origin) == quota)
 696         return;
 697 
 698     openTrackerDatabase(CreateIfDoesNotExist);
 699     if (!m_database.isOpen())
 700         return;
 701 
 702     bool insertedNewOrigin = false;
 703 
 704     bool originEntryExists = hasEntryForOriginNoLock(origin);
 705     if (!originEntryExists) {
 706         SQLiteStatement statement(m_database, &quot;INSERT INTO Origins VALUES (?, ?)&quot;);
 707         if (statement.prepare() != SQLITE_OK) {
 708             LOG_ERROR(&quot;Unable to establish origin %s in the tracker&quot;, origin.databaseIdentifier().utf8().data());
 709         } else {
 710             statement.bindText(1, origin.databaseIdentifier());
 711             statement.bindInt64(2, quota);
 712 
 713             if (statement.step() != SQLITE_DONE)
 714                 LOG_ERROR(&quot;Unable to establish origin %s in the tracker&quot;, origin.databaseIdentifier().utf8().data());
 715             else
 716                 insertedNewOrigin = true;
 717         }
 718     } else {
 719         SQLiteStatement statement(m_database, &quot;UPDATE Origins SET quota=? WHERE origin=?&quot;);
 720         bool error = statement.prepare() != SQLITE_OK;
 721         if (!error) {
 722             statement.bindInt64(1, quota);
 723             statement.bindText(2, origin.databaseIdentifier());
 724 
 725             error = !statement.executeCommand();
 726         }
 727 
 728         if (error)
 729             LOG_ERROR(&quot;Failed to set quota %llu in tracker database for origin %s&quot;, quota, origin.databaseIdentifier().utf8().data());
 730     }
 731 
 732     if (m_client) {
 733         if (insertedNewOrigin)
 734             m_client-&gt;dispatchDidAddNewOrigin();
 735         m_client-&gt;dispatchDidModifyOrigin(origin);
 736     }
 737 }
 738 
 739 bool DatabaseTracker::addDatabase(const SecurityOriginData&amp; origin, const String&amp; name, const String&amp; path)
 740 {
 741     ASSERT(!m_databaseGuard.tryLock());
 742     openTrackerDatabase(CreateIfDoesNotExist);
 743     if (!m_database.isOpen())
 744         return false;
 745 
 746     // New database should never be added until the origin has been established
 747     ASSERT(hasEntryForOriginNoLock(origin));
 748 
 749     SQLiteStatement statement(m_database, &quot;INSERT INTO Databases (origin, name, path) VALUES (?, ?, ?);&quot;);
 750 
 751     if (statement.prepare() != SQLITE_OK)
 752         return false;
 753 
 754     statement.bindText(1, origin.databaseIdentifier());
 755     statement.bindText(2, name);
 756     statement.bindText(3, path);
 757 
 758     if (!statement.executeCommand()) {
 759         LOG_ERROR(&quot;Failed to add database %s to origin %s: %s\n&quot;, name.utf8().data(), origin.databaseIdentifier().utf8().data(), m_database.lastErrorMsg());
 760         return false;
 761     }
 762 
 763     if (m_client)
 764         m_client-&gt;dispatchDidModifyOrigin(origin);
 765 
 766     return true;
 767 }
 768 
 769 void DatabaseTracker::deleteAllDatabasesImmediately()
 770 {
 771     // This method is only intended for use by DumpRenderTree / WebKitTestRunner.
 772     // Actually deleting the databases is necessary to reset to a known state before running
 773     // each test case, but may be unsafe in deployment use cases (where multiple applications
 774     // may be accessing the same databases concurrently).
 775     for (auto&amp; origin : origins())
 776         deleteOrigin(origin, DeletionMode::Immediate);
 777 }
 778 
 779 void DatabaseTracker::deleteDatabasesModifiedSince(WallTime time)
 780 {
 781     for (auto&amp; origin : origins()) {
 782         Vector&lt;String&gt; databaseNames = this-&gt;databaseNames(origin);
 783         Vector&lt;String&gt; databaseNamesToDelete;
 784         databaseNamesToDelete.reserveInitialCapacity(databaseNames.size());
 785         for (const auto&amp; databaseName : databaseNames) {
 786             auto fullPath = fullPathForDatabase(origin, databaseName, false);
 787 
 788             // If the file doesn&#39;t exist, we previously deleted it but failed to remove the information
 789             // from the tracker database. We want to delete all of the information associated with this
 790             // database from the tracker database, so still add its name to databaseNamesToDelete.
 791             if (FileSystem::fileExists(fullPath)) {
 792                 auto modificationTime = FileSystem::getFileModificationTime(fullPath);
 793                 if (!modificationTime)
 794                     continue;
 795 
 796                 if (modificationTime.value() &lt; time)
 797                     continue;
 798             }
 799 
 800             databaseNamesToDelete.uncheckedAppend(databaseName);
 801         }
 802 
 803         if (databaseNames.size() == databaseNamesToDelete.size())
 804             deleteOrigin(origin);
 805         else {
 806             for (const auto&amp; databaseName : databaseNamesToDelete)
 807                 deleteDatabase(origin, databaseName);
 808         }
 809     }
 810 }
 811 
 812 // It is the caller&#39;s responsibility to make sure that nobody is trying to create, delete, open, or close databases in this origin while the deletion is
 813 // taking place.
 814 bool DatabaseTracker::deleteOrigin(const SecurityOriginData&amp; origin)
 815 {
 816     return deleteOrigin(origin, DeletionMode::Default);
 817 }
 818 
 819 bool DatabaseTracker::deleteOrigin(const SecurityOriginData&amp; origin, DeletionMode deletionMode)
 820 {
 821     Vector&lt;String&gt; databaseNames;
 822     {
 823         LockHolder lockDatabase(m_databaseGuard);
 824         openTrackerDatabase(DontCreateIfDoesNotExist);
 825         if (!m_database.isOpen())
 826             return false;
 827 
 828         databaseNames = databaseNamesNoLock(origin);
 829         if (databaseNames.isEmpty())
 830             LOG_ERROR(&quot;Unable to retrieve list of database names for origin %s&quot;, origin.databaseIdentifier().utf8().data());
 831 
 832         if (!canDeleteOrigin(origin)) {
 833             LOG_ERROR(&quot;Tried to delete an origin (%s) while either creating database in it or already deleting it&quot;, origin.databaseIdentifier().utf8().data());
 834             ASSERT_NOT_REACHED();
 835             return false;
 836         }
 837         recordDeletingOrigin(origin);
 838     }
 839 
 840     // We drop the lock here because holding locks during a call to deleteDatabaseFile will deadlock.
 841     bool failedToDeleteAnyDatabaseFile = false;
 842     for (auto&amp; name : databaseNames) {
 843         if (FileSystem::fileExists(fullPathForDatabase(origin, name, false)) &amp;&amp; !deleteDatabaseFile(origin, name, deletionMode)) {
 844             // Even if the file can&#39;t be deleted, we want to try and delete the rest, don&#39;t return early here.
 845             LOG_ERROR(&quot;Unable to delete file for database %s in origin %s&quot;, name.utf8().data(), origin.databaseIdentifier().utf8().data());
 846             failedToDeleteAnyDatabaseFile = true;
 847         }
 848     }
 849 
 850     // If databaseNames is empty, delete everything in the directory containing the databases for this origin.
 851     // This condition indicates that we previously tried to remove the origin but didn&#39;t get all of the way
 852     // through the deletion process. Because we have lost track of the databases for this origin,
 853     // we can assume that no other process is accessing them. This means it should be safe to delete them outright.
 854     if (databaseNames.isEmpty()) {
 855 #if PLATFORM(COCOA)
 856         RELEASE_LOG_ERROR(DatabaseTracker, &quot;Unable to retrieve list of database names for origin&quot;);
 857 #endif
 858         for (const auto&amp; file : FileSystem::listDirectory(originPath(origin), &quot;*&quot;)) {
 859             if (!FileSystem::deleteFile(file))
 860                 failedToDeleteAnyDatabaseFile = true;
 861         }
 862     }
 863 
 864     // If we failed to delete any database file, don&#39;t remove the origin from the tracker
 865     // database because we didn&#39;t successfully remove all of its data.
 866     if (failedToDeleteAnyDatabaseFile) {
 867 #if PLATFORM(COCOA)
 868         RELEASE_LOG_ERROR(DatabaseTracker, &quot;Failed to delete database for origin&quot;);
 869 #endif
 870         return false;
 871     }
 872 
 873     {
 874         LockHolder lockDatabase(m_databaseGuard);
 875         deleteOriginLockFor(origin);
 876         doneDeletingOrigin(origin);
 877 
 878         SQLiteTransaction transaction(m_database);
 879         transaction.begin();
 880 
 881         SQLiteStatement statement(m_database, &quot;DELETE FROM Databases WHERE origin=?&quot;);
 882         if (statement.prepare() != SQLITE_OK) {
 883             LOG_ERROR(&quot;Unable to prepare deletion of databases from origin %s from tracker&quot;, origin.databaseIdentifier().utf8().data());
 884             return false;
 885         }
 886 
 887         statement.bindText(1, origin.databaseIdentifier());
 888 
 889         if (!statement.executeCommand()) {
 890             LOG_ERROR(&quot;Unable to execute deletion of databases from origin %s from tracker&quot;, origin.databaseIdentifier().utf8().data());
 891             return false;
 892         }
 893 
 894         SQLiteStatement originStatement(m_database, &quot;DELETE FROM Origins WHERE origin=?&quot;);
 895         if (originStatement.prepare() != SQLITE_OK) {
 896             LOG_ERROR(&quot;Unable to prepare deletion of origin %s from tracker&quot;, origin.databaseIdentifier().utf8().data());
 897             return false;
 898         }
 899 
 900         originStatement.bindText(1, origin.databaseIdentifier());
 901 
 902         if (!originStatement.executeCommand()) {
 903             LOG_ERROR(&quot;Unable to execute deletion of databases from origin %s from tracker&quot;, origin.databaseIdentifier().utf8().data());
 904             return false;
 905         }
 906 
 907         transaction.commit();
 908 
 909         SQLiteFileSystem::deleteEmptyDatabaseDirectory(originPath(origin));
 910 
 911         bool isEmpty = true;
 912 
 913         openTrackerDatabase(DontCreateIfDoesNotExist);
 914         if (m_database.isOpen()) {
 915             SQLiteStatement statement(m_database, &quot;SELECT origin FROM Origins&quot;);
 916             if (statement.prepare() != SQLITE_OK)
 917                 LOG_ERROR(&quot;Failed to prepare statement.&quot;);
 918             else if (statement.step() == SQLITE_ROW)
 919                 isEmpty = false;
 920         }
 921 
 922         // If we removed the last origin, do some additional deletion.
 923         if (isEmpty) {
 924             if (m_database.isOpen())
 925                 m_database.close();
 926            SQLiteFileSystem::deleteDatabaseFile(trackerDatabasePath());
 927            SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectoryPath);
 928         }
 929 
 930         if (m_client) {
 931             m_client-&gt;dispatchDidModifyOrigin(origin);
 932             m_client-&gt;dispatchDidDeleteDatabaseOrigin();
 933             for (auto&amp; name : databaseNames)
 934                 m_client-&gt;dispatchDidModifyDatabase(origin, name);
 935         }
 936     }
 937     return true;
 938 }
 939 
 940 bool DatabaseTracker::isDeletingDatabaseOrOriginFor(const SecurityOriginData&amp; origin, const String&amp; name)
 941 {
 942     ASSERT(!m_databaseGuard.tryLock());
 943     // Can&#39;t create a database while someone else is deleting it; there&#39;s a risk of leaving untracked database debris on the disk.
 944     return isDeletingDatabase(origin, name) || isDeletingOrigin(origin);
 945 }
 946 
 947 void DatabaseTracker::recordCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 948 {
 949     ASSERT(!m_databaseGuard.tryLock());
 950 
 951     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 952     auto* nameSet = m_beingCreated.get(origin);
 953     if (!nameSet) {
 954         auto ownedSet = makeUnique&lt;HashCountedSet&lt;String&gt;&gt;();
 955         nameSet = ownedSet.get();
 956         m_beingCreated.add(origin.isolatedCopy(), WTFMove(ownedSet));
 957     }
 958     nameSet-&gt;add(name.isolatedCopy());
 959 }
 960 
 961 void DatabaseTracker::doneCreatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 962 {
 963     ASSERT(!m_databaseGuard.tryLock());
 964 
 965     ASSERT(m_beingCreated.contains(origin));
 966 
 967     auto iterator = m_beingCreated.find(origin);
 968     if (iterator == m_beingCreated.end())
 969         return;
 970 
 971     auto&amp; countedSet = *iterator-&gt;value;
 972     ASSERT(countedSet.contains(name));
 973 
 974     if (countedSet.remove(name) &amp;&amp; countedSet.isEmpty())
 975         m_beingCreated.remove(iterator);
 976 }
 977 
 978 bool DatabaseTracker::creatingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 979 {
 980     ASSERT(!m_databaseGuard.tryLock());
 981 
 982     auto iterator = m_beingCreated.find(origin);
 983     return iterator != m_beingCreated.end() &amp;&amp; iterator-&gt;value-&gt;contains(name);
 984 }
 985 
 986 bool DatabaseTracker::canDeleteDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 987 {
 988     ASSERT(!m_databaseGuard.tryLock());
 989     return !creatingDatabase(origin, name) &amp;&amp; !isDeletingDatabase(origin, name);
 990 }
 991 
 992 void DatabaseTracker::recordDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
 993 {
 994     ASSERT(!m_databaseGuard.tryLock());
 995     ASSERT(canDeleteDatabase(origin, name));
 996 
 997     // We don&#39;t use HashMap::ensure here to avoid making an isolated copy of the origin every time.
 998     auto* nameSet = m_beingDeleted.get(origin);
 999     if (!nameSet) {
1000         auto ownedSet = makeUnique&lt;HashSet&lt;String&gt;&gt;();
1001         nameSet = ownedSet.get();
1002         m_beingDeleted.add(origin.isolatedCopy(), WTFMove(ownedSet));
1003     }
1004     ASSERT(!nameSet-&gt;contains(name));
1005     nameSet-&gt;add(name.isolatedCopy());
1006 }
1007 
1008 void DatabaseTracker::doneDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
1009 {
1010     ASSERT(!m_databaseGuard.tryLock());
1011     ASSERT(m_beingDeleted.contains(origin));
1012 
1013     auto iterator = m_beingDeleted.find(origin);
1014     if (iterator == m_beingDeleted.end())
1015         return;
1016 
1017     ASSERT(iterator-&gt;value-&gt;contains(name));
1018     iterator-&gt;value-&gt;remove(name);
1019     if (iterator-&gt;value-&gt;isEmpty())
1020         m_beingDeleted.remove(iterator);
1021 }
1022 
1023 bool DatabaseTracker::isDeletingDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
1024 {
1025     ASSERT(!m_databaseGuard.tryLock());
1026     auto* nameSet = m_beingDeleted.get(origin);
1027     return nameSet &amp;&amp; nameSet-&gt;contains(name);
1028 }
1029 
1030 bool DatabaseTracker::canDeleteOrigin(const SecurityOriginData&amp; origin)
1031 {
1032     ASSERT(!m_databaseGuard.tryLock());
1033     return !(isDeletingOrigin(origin) || m_beingCreated.get(origin));
1034 }
1035 
1036 bool DatabaseTracker::isDeletingOrigin(const SecurityOriginData&amp; origin)
1037 {
1038     ASSERT(!m_databaseGuard.tryLock());
1039     return m_originsBeingDeleted.contains(origin);
1040 }
1041 
1042 void DatabaseTracker::recordDeletingOrigin(const SecurityOriginData&amp; origin)
1043 {
1044     ASSERT(!m_databaseGuard.tryLock());
1045     ASSERT(!isDeletingOrigin(origin));
1046     m_originsBeingDeleted.add(origin.isolatedCopy());
1047 }
1048 
1049 void DatabaseTracker::doneDeletingOrigin(const SecurityOriginData&amp; origin)
1050 {
1051     ASSERT(!m_databaseGuard.tryLock());
1052     ASSERT(isDeletingOrigin(origin));
1053     m_originsBeingDeleted.remove(origin);
1054 }
1055 
1056 bool DatabaseTracker::deleteDatabase(const SecurityOriginData&amp; origin, const String&amp; name)
1057 {
1058     {
1059         LockHolder lockDatabase(m_databaseGuard);
1060         openTrackerDatabase(DontCreateIfDoesNotExist);
1061         if (!m_database.isOpen())
1062             return false;
1063 
1064         if (!canDeleteDatabase(origin, name)) {
1065             ASSERT_NOT_REACHED();
1066             return false;
1067         }
1068         recordDeletingDatabase(origin, name);
1069     }
1070 
1071     // We drop the lock here because holding locks during a call to deleteDatabaseFile will deadlock.
1072     if (FileSystem::fileExists(fullPathForDatabase(origin, name, false)) &amp;&amp; !deleteDatabaseFile(origin, name, DeletionMode::Default)) {
1073         LOG_ERROR(&quot;Unable to delete file for database %s in origin %s&quot;, name.utf8().data(), origin.databaseIdentifier().utf8().data());
1074         LockHolder lockDatabase(m_databaseGuard);
1075         doneDeletingDatabase(origin, name);
1076         return false;
1077     }
1078 
1079     LockHolder lockDatabase(m_databaseGuard);
1080 
1081     SQLiteStatement statement(m_database, &quot;DELETE FROM Databases WHERE origin=? AND name=?&quot;);
1082     if (statement.prepare() != SQLITE_OK) {
1083         LOG_ERROR(&quot;Unable to prepare deletion of database %s from origin %s from tracker&quot;, name.utf8().data(), origin.databaseIdentifier().utf8().data());
1084         doneDeletingDatabase(origin, name);
1085         return false;
1086     }
1087 
1088     statement.bindText(1, origin.databaseIdentifier());
1089     statement.bindText(2, name);
1090 
1091     if (!statement.executeCommand()) {
1092         LOG_ERROR(&quot;Unable to execute deletion of database %s from origin %s from tracker&quot;, name.utf8().data(), origin.databaseIdentifier().utf8().data());
1093         doneDeletingDatabase(origin, name);
1094         return false;
1095     }
1096 
1097     if (m_client) {
1098         m_client-&gt;dispatchDidModifyOrigin(origin);
1099         m_client-&gt;dispatchDidModifyDatabase(origin, name);
1100         m_client-&gt;dispatchDidDeleteDatabase();
1101     }
1102     doneDeletingDatabase(origin, name);
1103 
1104     return true;
1105 }
1106 
1107 // deleteDatabaseFile has to release locks between looking up the list of databases to close and closing them.  While this is in progress, the caller
1108 // is responsible for making sure no new databases are opened in the file to be deleted.
1109 bool DatabaseTracker::deleteDatabaseFile(const SecurityOriginData&amp; origin, const String&amp; name, DeletionMode deletionMode)
1110 {
1111     String fullPath = fullPathForDatabase(origin, name, false);
1112     if (fullPath.isEmpty())
1113         return true;
1114 
1115 #ifndef NDEBUG
1116     {
1117         LockHolder lockDatabase(m_databaseGuard);
1118         ASSERT(isDeletingDatabaseOrOriginFor(origin, name));
1119     }
1120 #endif
1121 
1122     Vector&lt;Ref&lt;Database&gt;&gt; deletedDatabases;
1123 
1124     // Make sure not to hold the any locks when calling
1125     // Database::markAsDeletedAndClose(), since that can cause a deadlock
1126     // during the synchronous DatabaseThread call it triggers.
1127     {
1128         LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
1129         if (m_openDatabaseMap) {
1130             if (auto* nameMap = m_openDatabaseMap-&gt;get(origin)) {
1131                 if (auto* databaseSet = nameMap-&gt;get(name)) {
1132                     for (auto&amp; database : *databaseSet)
1133                         deletedDatabases.append(*database);
1134                 }
1135             }
1136         }
1137     }
1138 
1139     for (auto&amp; database : deletedDatabases)
1140         database-&gt;markAsDeletedAndClose();
1141 
1142 #if PLATFORM(IOS_FAMILY)
1143     if (deletionMode == DeletionMode::Deferred) {
1144         // Other background processes may still be accessing this database. Deleting the database directly
1145         // would nuke the POSIX file locks, potentially causing Safari/WebApp to corrupt the new db if it&#39;s running in the background.
1146         // We&#39;ll instead truncate the database file to 0 bytes. If another process is operating on this same database file after
1147         // the truncation, it should get an error since the database file is no longer valid. When Safari is launched
1148         // next time, it&#39;ll go through the database files and clean up any zero-bytes ones.
1149         SQLiteDatabase database;
1150         if (!database.open(fullPath))
1151             return false;
1152         return SQLiteFileSystem::truncateDatabaseFile(database.sqlite3Handle());
1153     }
1154 #else
1155     UNUSED_PARAM(deletionMode);
1156 #endif
1157 
1158     return SQLiteFileSystem::deleteDatabaseFile(fullPath);
1159 }
1160 
1161 #if PLATFORM(IOS_FAMILY)
1162 
1163 void DatabaseTracker::removeDeletedOpenedDatabases()
1164 {
1165     // This is called when another app has deleted a database.  Go through all opened databases in this
1166     // tracker and close any that&#39;s no longer being tracked in the database.
1167 
1168     {
1169         // Acquire the lock before calling openTrackerDatabase.
1170         LockHolder lockDatabase(m_databaseGuard);
1171         openTrackerDatabase(DontCreateIfDoesNotExist);
1172     }
1173 
1174     if (!m_database.isOpen())
1175         return;
1176 
1177     // Keep track of which opened databases have been deleted.
1178     Vector&lt;RefPtr&lt;Database&gt;&gt; deletedDatabases;
1179     Vector&lt;std::pair&lt;SecurityOriginData, Vector&lt;String&gt;&gt;&gt; deletedDatabaseNames;
1180 
1181     // Make sure not to hold the m_openDatabaseMapGuard mutex when calling
1182     // Database::markAsDeletedAndClose(), since that can cause a deadlock
1183     // during the synchronous DatabaseThread call it triggers.
1184     {
1185         LockHolder openDatabaseMapLock(m_openDatabaseMapGuard);
1186         if (m_openDatabaseMap) {
1187             for (auto&amp; openDatabase : *m_openDatabaseMap) {
1188                 auto&amp; origin = openDatabase.key;
1189                 DatabaseNameMap* databaseNameMap = openDatabase.value;
1190                 Vector&lt;String&gt; deletedDatabaseNamesForThisOrigin;
1191 
1192                 // Loop through all opened databases in this origin.  Get the current database file path of each database and see if
1193                 // it still matches the path stored in the opened database object.
1194                 for (auto&amp; databases : *databaseNameMap) {
1195                     String databaseName = databases.key;
1196                     String databaseFileName;
1197                     SQLiteStatement statement(m_database, &quot;SELECT path FROM Databases WHERE origin=? AND name=?;&quot;);
1198                     if (statement.prepare() == SQLITE_OK) {
1199                         statement.bindText(1, origin.databaseIdentifier());
1200                         statement.bindText(2, databaseName);
1201                         if (statement.step() == SQLITE_ROW)
1202                             databaseFileName = statement.getColumnText(0);
1203                         statement.finalize();
1204                     }
1205 
1206                     bool foundDeletedDatabase = false;
1207                     for (auto&amp; db : *databases.value) {
1208                         // We are done if this database has already been marked as deleted.
1209                         if (db-&gt;deleted())
1210                             continue;
1211 
1212                         // If this database has been deleted or if its database file no longer matches the current version, this database is no longer valid and it should be marked as deleted.
1213                         if (databaseFileName.isNull() || databaseFileName != FileSystem::pathGetFileName(db-&gt;fileNameIsolatedCopy())) {
1214                             deletedDatabases.append(db);
1215                             foundDeletedDatabase = true;
1216                         }
1217                     }
1218 
1219                     // If the database no longer exists, we should remember to send that information to the client later.
1220                     if (m_client &amp;&amp; foundDeletedDatabase &amp;&amp; databaseFileName.isNull())
1221                         deletedDatabaseNamesForThisOrigin.append(databaseName);
1222                 }
1223 
1224                 if (!deletedDatabaseNamesForThisOrigin.isEmpty())
1225                     deletedDatabaseNames.append({ origin, WTFMove(deletedDatabaseNamesForThisOrigin) });
1226             }
1227         }
1228     }
1229 
1230     for (auto&amp; deletedDatabase : deletedDatabases)
1231         deletedDatabase-&gt;markAsDeletedAndClose();
1232 
1233     for (auto&amp; deletedDatabase : deletedDatabaseNames) {
1234         auto&amp; origin = deletedDatabase.first;
1235         m_client-&gt;dispatchDidModifyOrigin(origin);
1236         for (auto&amp; databaseName : deletedDatabase.second)
1237             m_client-&gt;dispatchDidModifyDatabase(origin, databaseName);
1238     }
1239 }
1240 
1241 static bool isZeroByteFile(const String&amp; path)
1242 {
1243     long long size = 0;
1244     return FileSystem::getFileSize(path, size) &amp;&amp; !size;
1245 }
1246 
1247 bool DatabaseTracker::deleteDatabaseFileIfEmpty(const String&amp; path)
1248 {
1249     if (!isZeroByteFile(path))
1250         return false;
1251 
1252     SQLiteDatabase database;
1253     if (!database.open(path))
1254         return false;
1255 
1256     // Specify that we want the exclusive locking mode, so after the next write,
1257     // we&#39;ll be holding the lock to this database file.
1258     SQLiteStatement lockStatement(database, &quot;PRAGMA locking_mode=EXCLUSIVE;&quot;);
1259     if (lockStatement.prepare() != SQLITE_OK)
1260         return false;
1261     int result = lockStatement.step();
1262     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE)
1263         return false;
1264     lockStatement.finalize();
1265 
1266     if (!database.executeCommand(&quot;BEGIN EXCLUSIVE TRANSACTION;&quot;))
1267         return false;
1268 
1269     // At this point, we hold the exclusive lock to this file.
1270     // Check that the database doesn&#39;t contain any tables.
1271     if (!database.executeCommand(&quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;;&quot;))
1272         return false;
1273 
1274     database.executeCommand(&quot;COMMIT TRANSACTION;&quot;);
1275 
1276     database.close();
1277 
1278     return SQLiteFileSystem::deleteDatabaseFile(path);
1279 }
1280 
1281 static Lock openDatabaseLock;
1282 Lock&amp; DatabaseTracker::openDatabaseMutex()
1283 {
1284     return openDatabaseLock;
1285 }
1286 
1287 void DatabaseTracker::emptyDatabaseFilesRemovalTaskWillBeScheduled()
1288 {
1289     // Lock the database from opening any database until we are done with scanning the file system for
1290     // zero byte database files to remove.
1291     openDatabaseLock.lock();
1292 }
1293 
1294 void DatabaseTracker::emptyDatabaseFilesRemovalTaskDidFinish()
1295 {
1296     openDatabaseLock.unlock();
1297 }
1298 
1299 #endif
1300 
1301 void DatabaseTracker::setClient(DatabaseManagerClient* client)
1302 {
1303     m_client = client;
1304 }
1305 
1306 static Lock notificationLock;
1307 
1308 using NotificationQueue = Vector&lt;std::pair&lt;SecurityOriginData, String&gt;&gt;;
1309 
1310 static NotificationQueue&amp; notificationQueue()
1311 {
1312     static NeverDestroyed&lt;NotificationQueue&gt; queue;
1313     return queue;
1314 }
1315 
1316 void DatabaseTracker::scheduleNotifyDatabaseChanged(const SecurityOriginData&amp; origin, const String&amp; name)
1317 {
1318     auto locker = holdLock(notificationLock);
1319     notificationQueue().append(std::make_pair(origin.isolatedCopy(), name.isolatedCopy()));
1320     scheduleForNotification();
1321 }
1322 
1323 static bool notificationScheduled = false;
1324 
1325 void DatabaseTracker::scheduleForNotification()
1326 {
1327     ASSERT(!notificationLock.tryLock());
1328 
1329     if (!notificationScheduled) {
1330         callOnMainThread([] {
1331             notifyDatabasesChanged();
1332         });
1333         notificationScheduled = true;
1334     }
1335 }
1336 
1337 void DatabaseTracker::notifyDatabasesChanged()
1338 {
1339     // Note that if DatabaseTracker ever becomes non-singleton, we&#39;ll have to amend this notification
1340     // mechanism to include which tracker the notification goes out on as well.
1341     auto&amp; tracker = DatabaseTracker::singleton();
1342 
1343     NotificationQueue notifications;
1344     {
1345         auto locker = holdLock(notificationLock);
1346         notifications.swap(notificationQueue());
1347         notificationScheduled = false;
1348     }
1349 
1350     if (!tracker.m_client)
1351         return;
1352 
1353     for (auto&amp; notification : notifications)
1354         tracker.m_client-&gt;dispatchDidModifyDatabase(notification.first, notification.second);
1355 }
1356 
1357 
1358 } // namespace WebCore
    </pre>
  </body>
</html>