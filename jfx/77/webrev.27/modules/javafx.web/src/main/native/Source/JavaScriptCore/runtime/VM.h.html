<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
  41 #include &quot;FuzzerAgent.h&quot;
  42 #include &quot;Heap.h&quot;
  43 #include &quot;Intrinsic.h&quot;
  44 #include &quot;IsoCellSet.h&quot;
  45 #include &quot;IsoSubspace.h&quot;
  46 #include &quot;JITThunks.h&quot;
  47 #include &quot;JSCJSValue.h&quot;
  48 #include &quot;JSLock.h&quot;
  49 #include &quot;MacroAssemblerCodeRef.h&quot;
  50 #include &quot;Microtask.h&quot;
  51 #include &quot;NumericStrings.h&quot;
  52 #include &quot;SmallStrings.h&quot;
  53 #include &quot;Strong.h&quot;
  54 #include &quot;StructureCache.h&quot;
  55 #include &quot;SubspaceAccess.h&quot;
  56 #include &quot;VMTraps.h&quot;
  57 #include &quot;WasmContext.h&quot;
  58 #include &quot;Watchpoint.h&quot;
  59 #include &lt;wtf/BumpPointerAllocator.h&gt;
  60 #include &lt;wtf/CheckedArithmetic.h&gt;
  61 #include &lt;wtf/DateMath.h&gt;
  62 #include &lt;wtf/Deque.h&gt;
  63 #include &lt;wtf/DoublyLinkedList.h&gt;
  64 #include &lt;wtf/Forward.h&gt;
  65 #include &lt;wtf/Gigacage.h&gt;
  66 #include &lt;wtf/HashMap.h&gt;
  67 #include &lt;wtf/HashSet.h&gt;
  68 #include &lt;wtf/SetForScope.h&gt;
  69 #include &lt;wtf/StackBounds.h&gt;
  70 #include &lt;wtf/StackPointer.h&gt;
  71 #include &lt;wtf/Stopwatch.h&gt;
  72 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  73 #include &lt;wtf/ThreadSpecific.h&gt;
  74 #include &lt;wtf/UniqueArray.h&gt;
  75 #include &lt;wtf/text/SymbolRegistry.h&gt;
  76 #include &lt;wtf/text/WTFString.h&gt;
  77 #if ENABLE(REGEXP_TRACING)
  78 #include &lt;wtf/ListHashSet.h&gt;
  79 #endif
  80 
  81 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  82 #include &lt;wtf/StackTrace.h&gt;
  83 #endif
  84 
  85 // Enable the Objective-C API for platforms with a modern runtime. This has to match exactly what we
  86 // have in JSBase.h.
  87 #if !defined(JSC_OBJC_API_ENABLED)
  88 #if (defined(__clang__) &amp;&amp; defined(__APPLE__) &amp;&amp; ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; !defined(__i386__)) || (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE)))
  89 #define JSC_OBJC_API_ENABLED 1
  90 #else
  91 #define JSC_OBJC_API_ENABLED 0
  92 #endif
  93 #endif
  94 
  95 namespace WTF {
  96 class SimpleStats;
  97 } // namespace WTF
  98 using WTF::SimpleStats;
  99 
 100 namespace JSC {
 101 
 102 class BuiltinExecutables;
 103 class BytecodeIntrinsicRegistry;
 104 class CodeBlock;
 105 class CodeCache;
 106 class CommonIdentifiers;
 107 class CompactVariableMap;
 108 class CustomGetterSetter;
 109 class DOMAttributeGetterSetter;
 110 class ExecState;
 111 class Exception;
 112 class ExceptionScope;
 113 class FastMallocAlignedMemoryAllocator;
 114 class GigacageAlignedMemoryAllocator;
 115 class HandleStack;
 116 class TypeProfiler;
 117 class TypeProfilerLog;
 118 class HasOwnPropertyCache;
 119 class HeapProfiler;
 120 class Identifier;
 121 class Interpreter;
 122 class JSCustomGetterSetterFunction;
 123 class JSDestructibleObjectHeapCellType;
 124 class JSGlobalObject;
 125 class JSObject;
 126 class JSPromise;
 127 class JSPropertyNameEnumerator;
 128 class JSRunLoopTimer;
 129 class JSStringHeapCellType;
 130 class JSWebAssemblyCodeBlockHeapCellType;
 131 class JSWebAssemblyInstance;
 132 class LLIntOffsetsExtractor;
 133 class NativeExecutable;
 134 class PromiseDeferredTimer;
 135 class RegExp;
 136 class RegExpCache;
 137 class Register;
 138 class RegisterAtOffsetList;
 139 #if ENABLE(SAMPLING_PROFILER)
 140 class SamplingProfiler;
 141 #endif
 142 class ShadowChicken;
 143 class ScriptExecutable;
 144 class SourceProvider;
 145 class SourceProviderCache;
 146 class StackFrame;
 147 class Structure;
 148 #if ENABLE(REGEXP_TRACING)
 149 class RegExp;
 150 #endif
 151 class Symbol;
 152 class TypedArrayController;
 153 class UnlinkedCodeBlock;
 154 class UnlinkedEvalCodeBlock;
 155 class UnlinkedFunctionExecutable;
 156 class UnlinkedProgramCodeBlock;
 157 class UnlinkedModuleProgramCodeBlock;
 158 class VirtualRegister;
 159 class VMEntryScope;
 160 class Watchdog;
 161 class Watchpoint;
 162 class WatchpointSet;
 163 class WebAssemblyFunctionHeapCellType;
 164 
 165 #if ENABLE(FTL_JIT)
 166 namespace FTL {
 167 class Thunks;
 168 }
 169 #endif // ENABLE(FTL_JIT)
 170 namespace Profiler {
 171 class Database;
 172 }
 173 namespace DOMJIT {
 174 class Signature;
 175 }
 176 
 177 struct EntryFrame;
 178 struct HashTable;
 179 struct Instruction;
 180 struct ValueProfile;
 181 
 182 typedef ExecState CallFrame;
 183 
 184 struct LocalTimeOffsetCache {
 185     LocalTimeOffsetCache()
 186         : start(0.0)
 187         , end(-1.0)
 188         , increment(0.0)
 189     {
 190     }
 191 
 192     void reset()
 193     {
 194         offset = LocalTimeOffset();
 195         start = 0.0;
 196         end = -1.0;
 197         increment = 0.0;
 198     }
 199 
 200     LocalTimeOffset offset;
 201     double start;
 202     double end;
 203     double increment;
 204 };
 205 
 206 class QueuedTask {
 207     WTF_MAKE_NONCOPYABLE(QueuedTask);
 208     WTF_MAKE_FAST_ALLOCATED;
 209 public:
 210     void run();
 211 
 212     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 213         : m_globalObject(vm, globalObject)
 214         , m_microtask(WTFMove(microtask))
 215     {
 216     }
 217 
 218 private:
 219     Strong&lt;JSGlobalObject&gt; m_globalObject;
 220     Ref&lt;Microtask&gt; m_microtask;
 221 };
 222 
 223 class ConservativeRoots;
 224 
 225 #if COMPILER(MSVC)
 226 #pragma warning(push)
 227 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
 228 #endif
 229 struct ScratchBuffer {
 230     ScratchBuffer()
 231     {
 232         u.m_activeLength = 0;
 233     }
 234 
 235     static ScratchBuffer* create(size_t size)
 236     {
 237         ScratchBuffer* result = new (fastMalloc(ScratchBuffer::allocationSize(size))) ScratchBuffer;
 238 
 239         return result;
 240     }
 241 
 242     static size_t allocationSize(Checked&lt;size_t&gt; bufferSize) { return (sizeof(ScratchBuffer) + bufferSize).unsafeGet(); }
 243     void setActiveLength(size_t activeLength) { u.m_activeLength = activeLength; }
 244     size_t activeLength() const { return u.m_activeLength; };
 245     size_t* addressOfActiveLength() { return &amp;u.m_activeLength; };
 246     void* dataBuffer() { return m_buffer; }
 247 
 248     union {
 249         size_t m_activeLength;
 250         double pad; // Make sure m_buffer is double aligned.
 251     } u;
 252 #if CPU(MIPS) &amp;&amp; (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == 2)
 253     alignas(8) void* m_buffer[0];
 254 #else
 255     void* m_buffer[0];
 256 #endif
 257 };
 258 #if COMPILER(MSVC)
 259 #pragma warning(pop)
 260 #endif
 261 
 262 class VM : public ThreadSafeRefCounted&lt;VM&gt;, public DoublyLinkedListNode&lt;VM&gt; {
 263 public:
 264     // WebCore has a one-to-one mapping of threads to VMs;
 265     // create() should only be called once
 266     // on a thread, this is the &#39;default&#39; VM (it uses the
 267     // thread&#39;s default string uniquing table from Thread::current()).
 268     // API contexts created using the new context group aware interface
 269     // create APIContextGroup objects which require less locking of JSC
 270     // than the old singleton APIShared VM created for use by
 271     // the original API.
 272     enum VMType { Default, APIContextGroup, APIShared };
 273 
 274     struct ClientData {
 275         JS_EXPORT_PRIVATE virtual ~ClientData() = 0;
 276     };
 277 
 278     bool isSharedInstance() { return vmType == APIShared; }
 279     bool usingAPI() { return vmType != Default; }
 280     JS_EXPORT_PRIVATE static bool sharedInstanceExists();
 281     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 282 
 283     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 284     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 285     JS_EXPORT_PRIVATE ~VM();
 286 
 287     Watchdog&amp; ensureWatchdog();
 288     Watchdog* watchdog() { return m_watchdog.get(); }
 289 
 290     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 291     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 292 
 293 #if ENABLE(SAMPLING_PROFILER)
 294     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 295     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 296 #endif
 297 
 298     FuzzerAgent* fuzzerAgent() const { return m_fuzzerAgent.get(); }
 299     void setFuzzerAgent(std::unique_ptr&lt;FuzzerAgent&gt;&amp;&amp; fuzzerAgent)
 300     {
 301         m_fuzzerAgent = WTFMove(fuzzerAgent);
 302     }
 303 
 304     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 305     unsigned id() const { return m_id; }
 306     bool isEntered() const { return !!entryScope; }
 307 
 308     inline CallFrame* topJSCallFrame() const;
 309 
 310     // Global object in which execution began.
 311     JS_EXPORT_PRIVATE JSGlobalObject* vmEntryGlobalObject(const CallFrame*) const;
 312 
 313 private:
 314     unsigned nextID();
 315 
 316     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 317 
 318     unsigned m_id;
 319     RefPtr&lt;JSLock&gt; m_apiLock;
 320 #if USE(CF)
 321     // These need to be initialized before heap below.
 322     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 323 #endif
 324 
 325 public:
 326     Heap heap;
 327 
 328     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 329     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 330     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 331 
 332     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 333     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 334     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 335     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
 336     std::unique_ptr&lt;JSStringHeapCellType&gt; stringHeapCellType;
 337     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;
 338 #if ENABLE(WEBASSEMBLY)
 339     std::unique_ptr&lt;JSWebAssemblyCodeBlockHeapCellType&gt; webAssemblyCodeBlockHeapCellType;
 340     std::unique_ptr&lt;WebAssemblyFunctionHeapCellType&gt; webAssemblyFunctionHeapCellType;
 341 #endif
 342 
 343     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 344     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 345     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 346 
 347     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 348     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 349     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 350     // constant somewhere.
 351     // FIXME: Maybe it would be better if everyone abstracted this?
 352     // https://bugs.webkit.org/show_bug.cgi?id=175248
 353     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 354     {
 355         switch (kind) {
 356         case Gigacage::ReservedForFlagsAndNotABasePtr:
 357             RELEASE_ASSERT_NOT_REACHED();
 358         case Gigacage::Primitive:
 359             return primitiveGigacageAuxiliarySpace;
 360         case Gigacage::JSValue:
 361             return jsValueGigacageAuxiliarySpace;
 362         }
 363         RELEASE_ASSERT_NOT_REACHED();
 364         return primitiveGigacageAuxiliarySpace;
 365     }
 366 
 367     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 368     CompleteSubspace cellSpace;
 369     CompleteSubspace jsValueGigacageCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858
 370     CompleteSubspace destructibleCellSpace;
 371     CompleteSubspace stringSpace;
 372     CompleteSubspace destructibleObjectSpace;
 373     CompleteSubspace eagerlySweptDestructibleObjectSpace;
 374 
 375     IsoSubspace executableToCodeBlockEdgeSpace;
 376     IsoSubspace functionSpace;
 377     IsoSubspace internalFunctionSpace;
 378     IsoSubspace nativeExecutableSpace;
 379     IsoSubspace propertyTableSpace;
 380     IsoSubspace structureRareDataSpace;
 381     IsoSubspace structureSpace;
 382     IsoSubspace symbolTableSpace;
 383 
 384 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 385     template&lt;SubspaceAccess mode&gt; \
 386     IsoSubspace* name() \
 387     { \
 388         if (m_##name || mode == SubspaceAccess::Concurrently) \
 389             return m_##name.get(); \
 390         return name##Slow(); \
 391     } \
 392     IsoSubspace* name##Slow(); \
 393     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 394 
 395 
 396 #if JSC_OBJC_API_ENABLED
 397     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 398 #endif
 399     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
 400     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
 401     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
 402     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
 403     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
 404     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)
 405     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakObjectRefSpace)
 406     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 407     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
 408 #if ENABLE(WEBASSEMBLY)
 409     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 410     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
 411     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 412 #endif
 413 
 414 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 415 
 416     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 417     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 418 
 419 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 420     template&lt;SubspaceAccess mode&gt; \
 421     IsoSubspace* name() \
 422     { \
 423         if (auto* spaceAndSet = m_##name.get()) \
 424             return &amp;spaceAndSet-&gt;space; \
 425         if (mode == SubspaceAccess::Concurrently) \
 426             return nullptr; \
 427         return name##Slow(); \
 428     } \
 429     IsoSubspace* name##Slow(); \
 430     std::unique_ptr&lt;SpaceAndSet&gt; m_##name;
 431 
 432     struct SpaceAndSet {
 433         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 434 
 435         IsoSubspace space;
 436         IsoCellSet set;
 437 
 438         template&lt;typename... Arguments&gt;
 439         SpaceAndSet(Arguments&amp;&amp;... arguments)
 440             : space(std::forward&lt;Arguments&gt;(arguments)...)
 441             , set(space)
 442         {
 443         }
 444 
 445         static IsoCellSet&amp; setFor(Subspace&amp; space)
 446         {
 447             return *bitwise_cast&lt;IsoCellSet*&gt;(
 448                 bitwise_cast&lt;char*&gt;(&amp;space) -
 449                 OBJECT_OFFSETOF(SpaceAndSet, space) +
 450                 OBJECT_OFFSETOF(SpaceAndSet, set));
 451         }
 452     };
 453 
 454     SpaceAndSet codeBlockSpace;
 455 
 456     template&lt;typename Func&gt;
 457     void forEachCodeBlockSpace(const Func&amp; func)
 458     {
 459         // This should not include webAssemblyCodeBlockSpace because this is about subsclasses of
 460         // JSC::CodeBlock.
 461         func(codeBlockSpace);
 462     }
 463 
 464     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(evalExecutableSpace)
 465     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(moduleProgramExecutableSpace)
 466     SpaceAndSet functionExecutableSpace;
 467     SpaceAndSet programExecutableSpace;
 468 
 469     template&lt;typename Func&gt;
 470     void forEachScriptExecutableSpace(const Func&amp; func)
 471     {
 472         if (m_evalExecutableSpace)
 473             func(*m_evalExecutableSpace);
 474         func(functionExecutableSpace);
 475         if (m_moduleProgramExecutableSpace)
 476             func(*m_moduleProgramExecutableSpace);
 477         func(programExecutableSpace);
 478     }
 479 
 480     SpaceAndSet unlinkedFunctionExecutableSpace;
 481 
 482 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER
 483 
 484     VMType vmType;
 485     ClientData* clientData;
 486     EntryFrame* topEntryFrame;
 487     // NOTE: When throwing an exception while rolling back the call frame, this may be equal to
 488     // topEntryFrame.
 489     // FIXME: This should be a void*, because it might not point to a CallFrame.
 490     // https://bugs.webkit.org/show_bug.cgi?id=160441
 491     ExecState* topCallFrame { nullptr };
 492 #if ENABLE(WEBASSEMBLY)
 493     Wasm::Context wasmContext;
 494 #endif
 495     Strong&lt;Structure&gt; structureStructure;
 496     Strong&lt;Structure&gt; structureRareDataStructure;
 497     Strong&lt;Structure&gt; terminatedExecutionErrorStructure;
 498     Strong&lt;Structure&gt; stringStructure;
 499     Strong&lt;Structure&gt; propertyNameEnumeratorStructure;
 500     Strong&lt;Structure&gt; customGetterSetterStructure;
 501     Strong&lt;Structure&gt; domAttributeGetterSetterStructure;
 502     Strong&lt;Structure&gt; scopedArgumentsTableStructure;
 503     Strong&lt;Structure&gt; apiWrapperStructure;
 504     Strong&lt;Structure&gt; nativeExecutableStructure;
 505     Strong&lt;Structure&gt; evalExecutableStructure;
 506     Strong&lt;Structure&gt; programExecutableStructure;
 507     Strong&lt;Structure&gt; functionExecutableStructure;
 508 #if ENABLE(WEBASSEMBLY)
 509     Strong&lt;Structure&gt; webAssemblyCodeBlockStructure;
 510 #endif
 511     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 512     Strong&lt;Structure&gt; regExpStructure;
 513     Strong&lt;Structure&gt; symbolStructure;
 514     Strong&lt;Structure&gt; symbolTableStructure;
 515     Strong&lt;Structure&gt; fixedArrayStructure;
 516     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 517     Strong&lt;Structure&gt; sourceCodeStructure;
 518     Strong&lt;Structure&gt; scriptFetcherStructure;
 519     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 520     Strong&lt;Structure&gt; structureChainStructure;
 521     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 522     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
 523     Strong&lt;Structure&gt; arrayBufferNeuteringWatchpointStructure;
 524     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 525     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 526     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 527     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 528     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 529     Strong&lt;Structure&gt; propertyTableStructure;
 530     Strong&lt;Structure&gt; functionRareDataStructure;
 531     Strong&lt;Structure&gt; exceptionStructure;
 532     Strong&lt;Structure&gt; promiseDeferredStructure;
 533     Strong&lt;Structure&gt; internalPromiseDeferredStructure;
 534     Strong&lt;Structure&gt; nativeStdFunctionCellStructure;
 535     Strong&lt;Structure&gt; programCodeBlockStructure;
 536     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 537     Strong&lt;Structure&gt; evalCodeBlockStructure;
 538     Strong&lt;Structure&gt; functionCodeBlockStructure;
 539     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 540     Strong&lt;Structure&gt; hashMapBucketMapStructure;
 541     Strong&lt;Structure&gt; bigIntStructure;
 542     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 543 
 544     Strong&lt;Structure&gt; m_setIteratorStructure;
 545     Strong&lt;Structure&gt; m_mapIteratorStructure;
 546 
 547     Strong&lt;JSPropertyNameEnumerator&gt; m_emptyPropertyNameEnumerator;
 548 
 549     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 550     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 551 
 552     Ref&lt;PromiseDeferredTimer&gt; promiseDeferredTimer;
 553 
 554     JSCell* currentlyDestructingCallbackObject;
 555     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 556 
 557     AtomStringTable* m_atomStringTable;
 558     WTF::SymbolRegistry m_symbolRegistry;
 559     CommonIdentifiers* propertyNames;
 560     const ArgList* emptyList;
 561     SmallStrings smallStrings;
 562     NumericStrings numericStrings;
 563     DateInstanceCache dateInstanceCache;
 564     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 565     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 566     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 567     Strong&lt;JSString&gt; lastCachedString;
 568 
 569     AtomStringTable* atomStringTable() const { return m_atomStringTable; }
 570     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 571 
 572     Structure* setIteratorStructure()
 573     {
 574         if (LIKELY(m_setIteratorStructure))
 575             return m_setIteratorStructure.get();
 576         return setIteratorStructureSlow();
 577     }
 578 
 579     Structure* mapIteratorStructure()
 580     {
 581         if (LIKELY(m_mapIteratorStructure))
 582             return m_mapIteratorStructure.get();
 583         return mapIteratorStructureSlow();
 584     }
 585 
 586     JSCell* sentinelSetBucket()
 587     {
 588         if (LIKELY(m_sentinelSetBucket))
 589             return m_sentinelSetBucket.get();
 590         return sentinelSetBucketSlow();
 591     }
 592 
 593     JSCell* sentinelMapBucket()
 594     {
 595         if (LIKELY(m_sentinelMapBucket))
 596             return m_sentinelMapBucket.get();
 597         return sentinelMapBucketSlow();
 598     }
 599 
 600     JSPropertyNameEnumerator* emptyPropertyNameEnumerator()
 601     {
 602         if (LIKELY(m_emptyPropertyNameEnumerator))
 603             return m_emptyPropertyNameEnumerator.get();
 604         return emptyPropertyNameEnumeratorSlow();
 605     }
 606 
 607     WeakGCMap&lt;SymbolImpl*, Symbol, PtrHash&lt;SymbolImpl*&gt;&gt; symbolImplToSymbolMap;
 608 
 609     enum class DeletePropertyMode {
 610         // Default behaviour of deleteProperty, matching the spec.
 611         Default,
 612         // This setting causes deleteProperty to force deletion of all
 613         // properties including those that are non-configurable (DontDelete).
 614         IgnoreConfigurable
 615     };
 616 
 617     DeletePropertyMode deletePropertyMode()
 618     {
 619         return m_deletePropertyMode;
 620     }
 621 
 622     class DeletePropertyModeScope {
 623     public:
 624         DeletePropertyModeScope(VM&amp; vm, DeletePropertyMode mode)
 625             : m_vm(vm)
 626             , m_previousMode(vm.m_deletePropertyMode)
 627         {
 628             m_vm.m_deletePropertyMode = mode;
 629         }
 630 
 631         ~DeletePropertyModeScope()
 632         {
 633             m_vm.m_deletePropertyMode = m_previousMode;
 634         }
 635 
 636     private:
 637         VM&amp; m_vm;
 638         DeletePropertyMode m_previousMode;
 639     };
 640 
 641     static JS_EXPORT_PRIVATE bool canUseAssembler();
 642     static bool isInMiniMode()
 643     {
 644         return !canUseJIT() || Options::forceMiniVMMode();
 645     }
 646 
 647     static bool useUnlinkedCodeBlockJettisoning()
 648     {
 649         return Options::useUnlinkedCodeBlockJettisoning() || isInMiniMode();
 650     }
 651 
 652     static void computeCanUseJIT();
 653     ALWAYS_INLINE static bool canUseJIT()
 654     {
 655 #if ENABLE(JIT)
 656 #if !ASSERT_DISABLED
 657         RELEASE_ASSERT(s_canUseJITIsSet);
 658 #endif
 659         return s_canUseJIT;
 660 #else
 661         return false;
 662 #endif
 663     }
 664 
 665     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 666     void clearSourceProviderCaches();
 667 
 668     StructureCache structureCache;
 669 
 670     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 671     SourceProviderCacheMap sourceProviderCacheMap;
 672     Interpreter* interpreter;
 673 #if ENABLE(JIT)
 674     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 675     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 676     {
 677         return jitStubs-&gt;ctiStub(*this, generator);
 678     }
 679 
 680 #endif // ENABLE(JIT)
 681 #if ENABLE(FTL_JIT)
 682     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 683 #endif
 684     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 685     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 686 
 687     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 688 
 689     static ptrdiff_t exceptionOffset()
 690     {
 691         return OBJECT_OFFSETOF(VM, m_exception);
 692     }
 693 
 694     static ptrdiff_t callFrameForCatchOffset()
 695     {
 696         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 697     }
 698 
 699     static ptrdiff_t topEntryFrameOffset()
 700     {
 701         return OBJECT_OFFSETOF(VM, topEntryFrame);
 702     }
 703 
 704     static ptrdiff_t offsetOfHeapBarrierThreshold()
 705     {
 706         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_barrierThreshold);
 707     }
 708 
 709     static ptrdiff_t offsetOfHeapMutatorShouldBeFenced()
 710     {
 711         return OBJECT_OFFSETOF(VM, heap) + OBJECT_OFFSETOF(Heap, m_mutatorShouldBeFenced);
 712     }
 713 
 714     void restorePreviousException(Exception* exception) { setException(exception); }
 715 
 716     void clearLastException() { m_lastException = nullptr; }
 717 
 718     ExecState** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }
 719 
 720     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 721 
 722     Exception* lastException() const { return m_lastException; }
 723     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 724 
 725     // This should only be used for test or assertion code that wants to inspect
 726     // the pending exception without interfering with Throw/CatchScopes.
 727     Exception* exceptionForInspection() const { return m_exception; }
 728 
 729     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 730     bool getAndClearFailNextNewCodeBlock()
 731     {
 732         bool result = m_failNextNewCodeBlock;
 733         m_failNextNewCodeBlock = false;
 734         return result;
 735     }
 736 
 737     ALWAYS_INLINE Structure* getStructure(StructureID id)
 738     {
 739         return heap.structureIDTable().get(decontaminate(id));
 740     }
 741 
 742     void* stackPointerAtVMEntry() const { return m_stackPointerAtVMEntry; }
 743     void setStackPointerAtVMEntry(void*);
 744 
 745     size_t softReservedZoneSize() const { return m_currentSoftReservedZoneSize; }
 746     size_t updateSoftReservedZoneSize(size_t softReservedZoneSize);
 747 
 748     static size_t committedStackByteCount();
 749     inline bool ensureStackCapacityFor(Register* newTopOfStack);
 750 
 751     void* stackLimit() { return m_stackLimit; }
 752     void* softStackLimit() { return m_softStackLimit; }
 753     void** addressOfSoftStackLimit() { return &amp;m_softStackLimit; }
 754 #if ENABLE(C_LOOP)
 755     void* cloopStackLimit() { return m_cloopStackLimit; }
 756     void setCLoopStackLimit(void* limit) { m_cloopStackLimit = limit; }
 757     JS_EXPORT_PRIVATE void* currentCLoopStackPointer() const;
 758 #endif
 759 
 760     inline bool isSafeToRecurseSoft() const;
 761     bool isSafeToRecurse() const
 762     {
 763         return isSafeToRecurse(m_stackLimit);
 764     }
 765 
 766     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 767     void* lastStackTop() { return m_lastStackTop; }
 768     void setLastStackTop(void*);
 769 
 770     void firePrimitiveGigacageEnabledIfNecessary()
 771     {
 772         if (m_needToFirePrimitiveGigacageEnabled) {
 773             m_needToFirePrimitiveGigacageEnabled = false;
 774             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 775         }
 776     }
 777 
 778     JSValue hostCallReturnValue;
 779     unsigned varargsLength;
 780     ExecState* newCallFrameReturnValue;
 781     ExecState* callFrameForCatch;
 782     void* targetMachinePCForThrow;
 783     const Instruction* targetInterpreterPCForThrow;
 784     uint32_t osrExitIndex;
 785     void* osrExitJumpDestination;
 786     bool isExecutingInRegExpJIT { false };
 787 
 788     // The threading protocol here is as follows:
 789     // - You can call scratchBufferForSize from any thread.
 790     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 791     // - You can only write to entries in the ScratchBuffer from the main thread.
 792     ScratchBuffer* scratchBufferForSize(size_t size);
 793     void clearScratchBuffers();
 794 
 795     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 796     {
 797         ASSERT(Options::useExceptionFuzz());
 798         if (!m_exceptionFuzzBuffer)
 799             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue&gt;::malloc(size);
 800         return m_exceptionFuzzBuffer.get();
 801     }
 802 
 803     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 804 
 805     VMEntryScope* entryScope;
 806 
 807     JSObject* stringRecursionCheckFirstObject { nullptr };
 808     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 809 
 810     LocalTimeOffsetCache utcTimeOffsetCache;
 811     LocalTimeOffsetCache localTimeOffsetCache;
 812 
 813     String cachedDateString;
 814     double cachedDateStringValue;
 815 
 816     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 817     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 818     RegExpCache* m_regExpCache;
 819     BumpPointerAllocator m_regExpAllocator;
 820     ConcurrentJSLock m_regExpAllocatorLock;
 821 
 822 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 823     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 824     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
 825     Lock m_regExpPatternContextLock;
 826     char* acquireRegExpPatternContexBuffer();
 827     void releaseRegExpPatternContexBuffer();
 828 #else
 829     static constexpr size_t patternContextBufferSize = 0; // Space allocated to save nested parenthesis context
 830 #endif
 831 
 832     Ref&lt;CompactVariableMap&gt; m_compactVariableMap;
 833 
 834     std::unique_ptr&lt;HasOwnPropertyCache&gt; m_hasOwnPropertyCache;
 835     ALWAYS_INLINE HasOwnPropertyCache* hasOwnPropertyCache() { return m_hasOwnPropertyCache.get(); }
 836     HasOwnPropertyCache* ensureHasOwnPropertyCache();
 837 
 838 #if ENABLE(REGEXP_TRACING)
 839     typedef ListHashSet&lt;RegExp*&gt; RTTraceList;
 840     RTTraceList* m_rtTraceList;
 841 #endif
 842 
 843     JS_EXPORT_PRIVATE void resetDateCache();
 844 
 845     RegExpCache* regExpCache() { return m_regExpCache; }
 846 #if ENABLE(REGEXP_TRACING)
 847     void addRegExpToTrace(RegExp*);
 848 #endif
 849     JS_EXPORT_PRIVATE void dumpRegExpTrace();
 850 
 851     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
 852 
 853 #if ENABLE(GC_VALIDATION)
 854     bool isInitializingObject() const;
 855     void setInitializingObjectClass(const ClassInfo*);
 856 #endif
 857 
 858     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
 859 
 860     JSLock&amp; apiLock() { return *m_apiLock; }
 861     CodeCache* codeCache() { return m_codeCache.get(); }
 862 
 863     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
 864 
 865     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
 866     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
 867 
 868     void shrinkFootprintWhenIdle();
 869 
 870     WatchpointSet* ensureWatchpointSetForImpureProperty(const Identifier&amp;);
 871     void registerWatchpointForImpureProperty(const Identifier&amp;, Watchpoint*);
 872 
 873     // FIXME: Use AtomString once it got merged with Identifier.
 874     JS_EXPORT_PRIVATE void addImpureProperty(const String&amp;);
 875 
 876     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
 877 
 878     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
 879 
 880     bool enableTypeProfiler();
 881     bool disableTypeProfiler();
 882     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
 883     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
 884     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
 885 
 886     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
 887 
 888     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
 889     bool enableControlFlowProfiler();
 890     bool disableControlFlowProfiler();
 891 
 892     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 893     JS_EXPORT_PRIVATE void drainMicrotasks();
 894     void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }
 895     void finalizeSynchronousJSExecution() { ASSERT(currentThreadIsHoldingAPILock()); m_currentWeakRefVersion++; }
 896     uintptr_t currentWeakRefVersion() const { return m_currentWeakRefVersion; }
 897 
 898     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
 899     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
 900 
 901     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
 902     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
 903 
 904     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
 905 
 906     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
 907     void ensureShadowChicken();
 908 
 909     template&lt;typename Func&gt;
 910     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
 911 
 912     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
 913 
 914     VMTraps&amp; traps() { return m_traps; }
 915 
 916     void handleTraps(ExecState* exec, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(exec, mask); }
 917 
 918     bool needTrapHandling() { return m_traps.needTrapHandling(); }
 919     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
 920     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
 921 
 922     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
 923     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
 924     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
 925 
 926     void promiseRejected(JSPromise*);
 927 
 928 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 929     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
 930     Thread* throwingThread() const { return m_throwingThread.get(); }
 931     bool needExceptionCheck() const { return m_needExceptionCheck; }
 932 #endif
 933 
 934 #if USE(CF)
 935     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
 936     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
 937 #endif // USE(CF)
 938 
 939     static void setCrashOnVMCreation(bool);
 940 
 941     class DeferExceptionScope {
 942     public:
 943         DeferExceptionScope(VM&amp; vm)
 944             : m_savedException(vm.m_exception, nullptr)
 945             , m_savedLastException(vm.m_lastException, nullptr)
 946         {
 947         }
 948 
 949     private:
 950         SetForScope&lt;Exception*&gt; m_savedException;
 951         SetForScope&lt;Exception*&gt; m_savedLastException;
 952     };
 953 
 954 private:
 955     friend class LLIntOffsetsExtractor;
 956 
 957     VM(VMType, HeapType);
 958     static VM*&amp; sharedInstanceInternal();
 959     void createNativeThunk();
 960 
 961     JS_EXPORT_PRIVATE Structure* setIteratorStructureSlow();
 962     JS_EXPORT_PRIVATE Structure* mapIteratorStructureSlow();
 963     JSCell* sentinelSetBucketSlow();
 964     JSCell* sentinelMapBucketSlow();
 965     JSPropertyNameEnumerator* emptyPropertyNameEnumeratorSlow();
 966 
 967     void updateStackLimits();
 968 
 969     bool isSafeToRecurse(void* stackLimit) const
 970     {
 971         ASSERT(Thread::current().stack().isGrowingDownward());
 972         void* curr = currentStackPointer();
 973         return curr &gt;= stackLimit;
 974     }
 975 
 976     void setException(Exception* exception)
 977     {
 978         m_exception = exception;
 979         m_lastException = exception;
 980     }
 981     Exception* exception() const
 982     {
 983 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 984         m_needExceptionCheck = false;
 985 #endif
 986         return m_exception;
 987     }
 988     void clearException()
 989     {
 990 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 991         m_needExceptionCheck = false;
 992         m_nativeStackTraceOfLastThrow = nullptr;
 993         m_throwingThread = nullptr;
 994 #endif
 995         m_exception = nullptr;
 996     }
 997 
 998 #if ENABLE(C_LOOP)
 999     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
1000     bool isSafeToRecurseSoftCLoop() const;
1001 #endif // ENABLE(C_LOOP)
1002 
1003     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, Exception*);
1004     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSValue);
1005     JS_EXPORT_PRIVATE Exception* throwException(ExecState*, JSObject*);
1006 
1007 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1008     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
1009 #endif
1010 
1011     static void primitiveGigacageDisabledCallback(void*);
1012     void primitiveGigacageDisabled();
1013 
1014     void callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp;);
1015     void didExhaustMicrotaskQueue();
1016 
1017 #if ENABLE(GC_VALIDATION)
1018     const ClassInfo* m_initializingObjectClass;
1019 #endif
1020 
1021     void* m_stackPointerAtVMEntry;
1022     size_t m_currentSoftReservedZoneSize;
1023     void* m_stackLimit { nullptr };
1024     void* m_softStackLimit { nullptr };
1025 #if ENABLE(C_LOOP)
1026     void* m_cloopStackLimit { nullptr };
1027 #endif
1028     void* m_lastStackTop { nullptr };
1029 
1030     Exception* m_exception { nullptr };
1031     Exception* m_lastException { nullptr };
1032 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1033     ExceptionScope* m_topExceptionScope { nullptr };
1034     ExceptionEventLocation m_simulatedThrowPointLocation;
1035     unsigned m_simulatedThrowPointRecursionDepth { 0 };
1036     mutable bool m_needExceptionCheck { false };
1037     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastThrow;
1038     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastSimulatedThrow;
1039     RefPtr&lt;Thread&gt; m_throwingThread;
1040 #endif
1041 
1042     bool m_failNextNewCodeBlock { false };
1043     DeletePropertyMode m_deletePropertyMode { DeletePropertyMode::Default };
1044     bool m_globalConstRedeclarationShouldThrow { true };
1045     bool m_shouldBuildPCToCodeOriginMapping { false };
1046     std::unique_ptr&lt;CodeCache&gt; m_codeCache;
1047     std::unique_ptr&lt;BuiltinExecutables&gt; m_builtinExecutables;
1048     HashMap&lt;String, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;
1049     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
1050     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
1051     unsigned m_typeProfilerEnabledCount;
1052     bool m_needToFirePrimitiveGigacageEnabled { false };
1053     Lock m_scratchBufferLock;
1054     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
1055     size_t m_sizeOfLastScratchBuffer { 0 };
1056     InlineWatchpointSet m_primitiveGigacageEnabled;
1057     FunctionHasExecutedCache m_functionHasExecutedCache;
1058     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1059     unsigned m_controlFlowProfilerEnabledCount;
1060     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
1061     MallocPtr&lt;EncodedJSValue&gt; m_exceptionFuzzBuffer;
1062     VMTraps m_traps;
1063     RefPtr&lt;Watchdog&gt; m_watchdog;
1064     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1065 #if ENABLE(SAMPLING_PROFILER)
1066     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1067 #endif
1068     std::unique_ptr&lt;FuzzerAgent&gt; m_fuzzerAgent;
1069     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1070     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1071 
1072     // FIXME: We should remove handled promises from this list at GC flip. &lt;https://webkit.org/b/201005&gt;
1073     Vector&lt;Strong&lt;JSPromise&gt;&gt; m_aboutToBeNotifiedRejectedPromises;
1074 
1075     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
1076     uintptr_t m_currentWeakRefVersion { 0 };
1077 
1078 #if ENABLE(JIT)
1079 #if !ASSERT_DISABLED
1080     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1081 #endif
1082     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1083 #endif
1084 
1085     VM* m_prev; // Required by DoublyLinkedListNode.
1086     VM* m_next; // Required by DoublyLinkedListNode.
1087 
1088     // Friends for exception checking purpose only.
1089     friend class Heap;
1090     friend class CatchScope;
1091     friend class ExceptionScope;
1092     friend class ThrowScope;
1093     friend class VMTraps;
1094     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1095 };
1096 
1097 #if ENABLE(GC_VALIDATION)
1098 inline bool VM::isInitializingObject() const
1099 {
1100     return !!m_initializingObjectClass;
1101 }
1102 
1103 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1104 {
1105     m_initializingObjectClass = initializingObjectClass;
1106 }
1107 #endif
1108 
1109 inline Heap* WeakSet::heap() const
1110 {
1111     return &amp;m_vm.heap;
1112 }
1113 
1114 #if !ENABLE(C_LOOP)
1115 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1116 #endif
1117 
1118 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM&amp;);
1119 void logSanitizeStack(VM&amp;);
1120 
1121 } // namespace JSC
    </pre>
  </body>
</html>