<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005, 2006, 2007, 2008, 2011, 2012, 2015 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &lt;atomic&gt;
  25 #include &lt;iterator&gt;
  26 #include &lt;mutex&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;type_traits&gt;
  29 #include &lt;utility&gt;
  30 #include &lt;wtf/Assertions.h&gt;
  31 #include &lt;wtf/FastMalloc.h&gt;
  32 #include &lt;wtf/HashTraits.h&gt;
  33 #include &lt;wtf/Lock.h&gt;
  34 #include &lt;wtf/MathExtras.h&gt;
  35 #include &lt;wtf/RandomNumber.h&gt;
  36 #include &lt;wtf/StdLibExtras.h&gt;
  37 #include &lt;wtf/ValueCheck.h&gt;
  38 
  39 #define DUMP_HASHTABLE_STATS 0
  40 #define DUMP_HASHTABLE_STATS_PER_TABLE 0
  41 
  42 #if DUMP_HASHTABLE_STATS_PER_TABLE
  43 #include &lt;wtf/DataLog.h&gt;
  44 #endif
  45 
  46 namespace WTF {
  47 
  48 // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  49 #define CHECK_HASHTABLE_CONSISTENCY 0
  50 
  51 #ifdef NDEBUG
  52 #define CHECK_HASHTABLE_ITERATORS 0
  53 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
  54 #else
  55 #define CHECK_HASHTABLE_ITERATORS 1
  56 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 1
  57 #endif
  58 
  59 #if DUMP_HASHTABLE_STATS
  60 
  61     struct HashTableStats {
  62         // The following variables are all atomically incremented when modified.
  63         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numAccesses;
  64         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRehashes;
  65         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRemoves;
  66         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numReinserts;
  67 
  68         // The following variables are only modified in the recordCollisionAtCount method within a mutex.
  69         WTF_EXPORT_PRIVATE static unsigned maxCollisions;
  70         WTF_EXPORT_PRIVATE static unsigned numCollisions;
  71         WTF_EXPORT_PRIVATE static unsigned collisionGraph[4096];
  72 
  73         WTF_EXPORT_PRIVATE static void recordCollisionAtCount(unsigned count);
  74         WTF_EXPORT_PRIVATE static void dumpStats();
  75     };
  76 
  77 #endif
  78 
  79     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  80     class HashTable;
  81     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  82     class HashTableIterator;
  83     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  84     class HashTableConstIterator;
  85 
  86     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  87     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  88         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  89 
  90     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  91     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  92 
  93 #if !CHECK_HASHTABLE_ITERATORS
  94 
  95     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  96     inline void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  97         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
  98 
  99     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 100     inline void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 101 
 102 #endif
 103 
 104     typedef enum { HashItemKnownGood } HashItemKnownGoodTag;
 105 
 106     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 107     class HashTableConstIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, const Value*, const Value&amp;&gt; {
<a name="1" id="anc1"></a><span class="line-added"> 108         WTF_MAKE_FAST_ALLOCATED;</span>
 109     private:
 110         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 111         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 112         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 113         typedef Value ValueType;
 114         typedef const ValueType&amp; ReferenceType;
 115         typedef const ValueType* PointerType;
 116 
 117         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 118         friend class HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 119 
 120         void skipEmptyBuckets()
 121         {
 122             while (m_position != m_endPosition &amp;&amp; HashTableType::isEmptyOrDeletedBucket(*m_position))
 123                 ++m_position;
 124         }
 125 
 126         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
 127             : m_position(position), m_endPosition(endPosition)
 128         {
 129             addIterator(table, this);
 130             skipEmptyBuckets();
 131         }
 132 
 133         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
 134             : m_position(position), m_endPosition(endPosition)
 135         {
 136             addIterator(table, this);
 137         }
 138 
 139     public:
 140         HashTableConstIterator()
 141         {
 142             addIterator(static_cast&lt;const HashTableType*&gt;(0), this);
 143         }
 144 
 145         // default copy, assignment and destructor are OK if CHECK_HASHTABLE_ITERATORS is 0
 146 
 147 #if CHECK_HASHTABLE_ITERATORS
 148         ~HashTableConstIterator()
 149         {
 150             removeIterator(this);
 151         }
 152 
 153         HashTableConstIterator(const const_iterator&amp; other)
 154             : m_position(other.m_position), m_endPosition(other.m_endPosition)
 155         {
 156             addIterator(other.m_table, this);
 157         }
 158 
 159         const_iterator&amp; operator=(const const_iterator&amp; other)
 160         {
 161             m_position = other.m_position;
 162             m_endPosition = other.m_endPosition;
 163 
 164             removeIterator(this);
 165             addIterator(other.m_table, this);
 166 
 167             return *this;
 168         }
 169 #endif
 170 
 171         PointerType get() const
 172         {
 173             checkValidity();
 174             return m_position;
 175         }
 176         ReferenceType operator*() const { return *get(); }
 177         PointerType operator-&gt;() const { return get(); }
 178 
 179         const_iterator&amp; operator++()
 180         {
 181             checkValidity();
 182             ASSERT(m_position != m_endPosition);
 183             ++m_position;
 184             skipEmptyBuckets();
 185             return *this;
 186         }
 187 
 188         // postfix ++ intentionally omitted
 189 
 190         // Comparison.
 191         bool operator==(const const_iterator&amp; other) const
 192         {
 193             checkValidity(other);
 194             return m_position == other.m_position;
 195         }
 196         bool operator!=(const const_iterator&amp; other) const
 197         {
 198             checkValidity(other);
 199             return m_position != other.m_position;
 200         }
 201         bool operator==(const iterator&amp; other) const
 202         {
 203             return *this == static_cast&lt;const_iterator&gt;(other);
 204         }
 205         bool operator!=(const iterator&amp; other) const
 206         {
 207             return *this != static_cast&lt;const_iterator&gt;(other);
 208         }
 209 
 210     private:
 211         void checkValidity() const
 212         {
 213 #if CHECK_HASHTABLE_ITERATORS
 214             ASSERT(m_table);
 215 #endif
 216         }
 217 
 218 
 219 #if CHECK_HASHTABLE_ITERATORS
 220         void checkValidity(const const_iterator&amp; other) const
 221         {
 222             ASSERT(m_table);
 223             ASSERT_UNUSED(other, other.m_table);
 224             ASSERT(m_table == other.m_table);
 225         }
 226 #else
 227         void checkValidity(const const_iterator&amp;) const { }
 228 #endif
 229 
 230         PointerType m_position { nullptr };
 231         PointerType m_endPosition { nullptr };
 232 
 233 #if CHECK_HASHTABLE_ITERATORS
 234     public:
 235         // Any modifications of the m_next or m_previous of an iterator that is in a linked list of a HashTable::m_iterator,
 236         // should be guarded with m_table-&gt;m_mutex.
 237         mutable const HashTableType* m_table;
 238         mutable const_iterator* m_next;
 239         mutable const_iterator* m_previous;
 240 #endif
 241     };
 242 
 243     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 244     class HashTableIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, Value*, Value&amp;&gt; {
<a name="2" id="anc2"></a><span class="line-added"> 245         WTF_MAKE_FAST_ALLOCATED;</span>
 246     private:
 247         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 248         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 249         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 250         typedef Value ValueType;
 251         typedef ValueType&amp; ReferenceType;
 252         typedef ValueType* PointerType;
 253 
 254         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 255 
 256         HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
 257         HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }
 258 
 259     public:
 260         HashTableIterator() { }
 261 
 262         // default copy, assignment and destructor are OK
 263 
 264         PointerType get() const { return const_cast&lt;PointerType&gt;(m_iterator.get()); }
 265         ReferenceType operator*() const { return *get(); }
 266         PointerType operator-&gt;() const { return get(); }
 267 
 268         iterator&amp; operator++() { ++m_iterator; return *this; }
 269 
 270         // postfix ++ intentionally omitted
 271 
 272         // Comparison.
 273         bool operator==(const iterator&amp; other) const { return m_iterator == other.m_iterator; }
 274         bool operator!=(const iterator&amp; other) const { return m_iterator != other.m_iterator; }
 275         bool operator==(const const_iterator&amp; other) const { return m_iterator == other; }
 276         bool operator!=(const const_iterator&amp; other) const { return m_iterator != other; }
 277 
 278         operator const_iterator() const { return m_iterator; }
 279 
 280     private:
 281         const_iterator m_iterator;
 282     };
 283 
 284     template&lt;typename ValueTraits, typename HashFunctions&gt; class IdentityHashTranslator {
 285     public:
 286         template&lt;typename T&gt; static unsigned hash(const T&amp; key) { return HashFunctions::hash(key); }
 287         template&lt;typename T, typename U&gt; static bool equal(const T&amp; a, const U&amp; b) { return HashFunctions::equal(a, b); }
 288         template&lt;typename T, typename U, typename V&gt; static void translate(T&amp; location, const U&amp;, V&amp;&amp; value)
 289         {
 290             ValueTraits::assignToEmpty(location, std::forward&lt;V&gt;(value));
 291         }
 292     };
 293 
 294     template&lt;typename IteratorType&gt; struct HashTableAddResult {
 295         HashTableAddResult() : isNewEntry(false) { }
 296         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 297         IteratorType iterator;
 298         bool isNewEntry;
 299 
 300         explicit operator bool() const { return isNewEntry; }
 301     };
 302 
 303     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 304     class HashTable {
 305     public:
 306         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 307         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 308         typedef Traits ValueTraits;
 309         typedef Key KeyType;
 310         typedef Value ValueType;
 311         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 312         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 313 
 314 #if DUMP_HASHTABLE_STATS_PER_TABLE
 315         struct Stats {
<a name="3" id="anc3"></a><span class="line-added"> 316             WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
<span class="line-added"> 317 </span>
 318             Stats()
 319                 : numAccesses(0)
 320                 , numRehashes(0)
 321                 , numRemoves(0)
 322                 , numReinserts(0)
 323                 , maxCollisions(0)
 324                 , numCollisions(0)
 325                 , collisionGraph()
 326             {
 327             }
 328 
 329             unsigned numAccesses;
 330             unsigned numRehashes;
 331             unsigned numRemoves;
 332             unsigned numReinserts;
 333 
 334             unsigned maxCollisions;
 335             unsigned numCollisions;
 336             unsigned collisionGraph[4096];
 337 
 338             void recordCollisionAtCount(unsigned count)
 339             {
 340                 if (count &gt; maxCollisions)
 341                     maxCollisions = count;
 342                 numCollisions++;
 343                 collisionGraph[count]++;
 344             }
 345 
 346             void dumpStats()
 347             {
 348                 dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);
 349                 dataLogF(&quot;%d accesses\n&quot;, numAccesses);
 350                 dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses);
 351                 dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);
 352                 for (unsigned i = 1; i &lt;= maxCollisions; i++) {
 353                     dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses);
 354                 }
 355                 dataLogF(&quot;%d rehashes\n&quot;, numRehashes);
 356                 dataLogF(&quot;%d reinserts\n&quot;, numReinserts);
 357             }
 358         };
 359 #endif
 360 
 361         HashTable();
 362         ~HashTable()
 363         {
 364 
 365 #if PLATFORM(JAVA)
 366 #if CHECK_HASHTABLE_ITERATORS
 367             // does the same as invalidateIterators() but without
 368             // taking a lock since the destructor may be invoked
 369             // during atexit() handler which may lead to crash
 370             const_iterator* next;
 371             for (const_iterator* p = m_iterators; p; p = next) {
 372                 next = p-&gt;m_next;
 373                 p-&gt;m_table = 0;
 374                 p-&gt;m_next = 0;
 375                 p-&gt;m_previous = 0;
 376             }
 377             m_iterators = 0;
 378 #endif
 379 #else
 380             invalidateIterators();
 381 #endif
 382 
 383             if (m_table)
 384                 deallocateTable(m_table, m_tableSize);
 385 #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 386             m_table = (ValueType*)(uintptr_t)0xbbadbeef;
 387 #endif
 388         }
 389 
 390         HashTable(const HashTable&amp;);
 391         void swap(HashTable&amp;);
 392         HashTable&amp; operator=(const HashTable&amp;);
 393 
 394         HashTable(HashTable&amp;&amp;);
 395         HashTable&amp; operator=(HashTable&amp;&amp;);
 396 
 397         // When the hash table is empty, just return the same iterator for end as for begin.
 398         // This is more efficient because we don&#39;t have to skip all the empty and deleted
 399         // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
 400         iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
 401         iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); }
 402         const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
 403         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }
 404 
 405         iterator random()
 406         {
 407             if (isEmpty())
 408                 return end();
 409 
 410             while (1) {
 411                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];
 412                 if (!isEmptyOrDeletedBucket(bucket))
 413                     return makeKnownGoodIterator(&amp;bucket);
 414             };
 415         }
 416 
 417         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 418 
 419         unsigned size() const { return m_keyCount; }
 420         unsigned capacity() const { return m_tableSize; }
 421         bool isEmpty() const { return !m_keyCount; }
 422 
<a name="4" id="anc4"></a><span class="line-added"> 423         void reserveInitialCapacity(unsigned keyCount)</span>
<span class="line-added"> 424         {</span>
<span class="line-added"> 425             ASSERT(!m_table);</span>
<span class="line-added"> 426             ASSERT(!m_tableSize);</span>
<span class="line-added"> 427             ASSERT(!m_deletedCount);</span>
<span class="line-added"> 428 </span>
<span class="line-added"> 429             unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added"> 430             unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432             m_tableSize = newTableSize;</span>
<span class="line-added"> 433             m_tableSizeMask = newTableSize - 1;</span>
<span class="line-added"> 434             m_table = allocateTable(newTableSize);</span>
<span class="line-added"> 435         }</span>
<span class="line-added"> 436 </span>
 437         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 438         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 439 
 440         // A special version of add() that finds the object by hashing and comparing
 441         // with some other type, to avoid the cost of type conversion if the object is already
 442         // in the table.
 443         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 444         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 445 
 446         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 447         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 448         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 449 
 450         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 451         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 452         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 453 
 454         void remove(const KeyType&amp;);
 455         void remove(iterator);
 456         void removeWithoutEntryConsistencyCheck(iterator);
 457         void removeWithoutEntryConsistencyCheck(const_iterator);
 458         template&lt;typename Functor&gt;
 459         bool removeIf(const Functor&amp;);
 460         void clear();
 461 
 462         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
<a name="5" id="anc5"></a><span class="line-added"> 463         static bool isReleasedWeakBucket(const ValueType&amp; value) { return isHashTraitsReleasedWeakValue&lt;KeyTraits&gt;(Extractor::extract(value)); }</span>
 464         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 465         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 466 
 467         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 468         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 469         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 470 
 471 #if !ASSERT_DISABLED
 472         void checkTableConsistency() const;
 473 #else
 474         static void checkTableConsistency() { }
 475 #endif
 476 #if CHECK_HASHTABLE_CONSISTENCY
 477         void internalCheckTableConsistency() const { checkTableConsistency(); }
 478         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 479 #else
 480         static void internalCheckTableConsistencyExceptSize() { }
 481         static void internalCheckTableConsistency() { }
 482 #endif
 483 
 484     private:
 485         static ValueType* allocateTable(unsigned size);
 486         static void deallocateTable(ValueType* table, unsigned size);
 487 
 488         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 489         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 490 
 491         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 492         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 493         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 494 
 495         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 496 
 497         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 498 
 499         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 500         void removeAndInvalidate(ValueType*);
 501         void remove(ValueType*);
 502 
<a name="6" id="anc6"></a><span class="line-added"> 503         static constexpr unsigned computeBestTableSize(unsigned keyCount);</span>
 504         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }
 505         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }
 506         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }
 507         ValueType* expand(ValueType* entry = nullptr);
 508         void shrink() { rehash(m_tableSize / 2, nullptr); }
<a name="7" id="anc7"></a><span class="line-added"> 509         void shrinkToBestSize();</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511         void deleteReleasedWeakBuckets();</span>
 512 
 513         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 514         ValueType* reinsert(ValueType&amp;&amp;);
 515 
 516         static void initializeBucket(ValueType&amp; bucket);
 517         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 518 
 519         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 520             { return FullLookupType(LookupType(position, found), hash); }
 521 
 522         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }
 523         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }
 524         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 525         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 526 
 527 #if !ASSERT_DISABLED
 528         void checkTableConsistencyExceptSize() const;
 529 #else
 530         static void checkTableConsistencyExceptSize() { }
 531 #endif
 532 
 533 #if CHECK_HASHTABLE_ITERATORS
 534         void invalidateIterators();
 535 #else
 536         static void invalidateIterators() { }
 537 #endif
 538 
 539         static const unsigned m_maxLoad = 2;
 540         static const unsigned m_minLoad = 6;
 541 
 542         ValueType* m_table;
 543         unsigned m_tableSize;
 544         unsigned m_tableSizeMask;
 545         unsigned m_keyCount;
 546         unsigned m_deletedCount;
 547 
 548 #if CHECK_HASHTABLE_ITERATORS
 549     public:
 550         // All access to m_iterators should be guarded with m_mutex.
 551         mutable const_iterator* m_iterators;
 552         // Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
 553         mutable std::unique_ptr&lt;Lock&gt; m_mutex;
 554 #endif
 555 
 556 #if DUMP_HASHTABLE_STATS_PER_TABLE
 557     public:
 558         mutable std::unique_ptr&lt;Stats&gt; m_stats;
 559 #endif
 560     };
 561 
 562     // Set all the bits to one after the most significant bit: 00110101010 -&gt; 00111111111.
 563     template&lt;unsigned size&gt; struct OneifyLowBits;
 564     template&lt;&gt;
 565     struct OneifyLowBits&lt;0&gt; {
 566         static const unsigned value = 0;
 567     };
 568     template&lt;unsigned number&gt;
 569     struct OneifyLowBits {
 570         static const unsigned value = number | OneifyLowBits&lt;(number &gt;&gt; 1)&gt;::value;
 571     };
 572     // Compute the first power of two integer that is an upper bound of the parameter &#39;number&#39;.
 573     template&lt;unsigned number&gt;
 574     struct UpperPowerOfTwoBound {
 575         static const unsigned value = (OneifyLowBits&lt;number - 1&gt;::value + 1) * 2;
 576     };
 577 
 578     // Because power of two numbers are the limit of maxLoad, their capacity is twice the
 579     // UpperPowerOfTwoBound, or 4 times their values.
 580     template&lt;unsigned size, bool isPowerOfTwo&gt; struct HashTableCapacityForSizeSplitter;
 581     template&lt;unsigned size&gt;
 582     struct HashTableCapacityForSizeSplitter&lt;size, true&gt; {
 583         static const unsigned value = size * 4;
 584     };
 585     template&lt;unsigned size&gt;
 586     struct HashTableCapacityForSizeSplitter&lt;size, false&gt; {
 587         static const unsigned value = UpperPowerOfTwoBound&lt;size&gt;::value;
 588     };
 589 
 590     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.
 591     // This is done at compile time to initialize the HashTraits.
 592     template&lt;unsigned size&gt;
 593     struct HashTableCapacityForSize {
 594         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;
 595         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);
 596         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);
 597         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);
 598     };
 599 
 600     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 601     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
 602         : m_table(0)
 603         , m_tableSize(0)
 604         , m_tableSizeMask(0)
 605         , m_keyCount(0)
 606         , m_deletedCount(0)
 607 #if CHECK_HASHTABLE_ITERATORS
 608         , m_iterators(0)
<a name="8" id="anc8"></a><span class="line-modified"> 609         , m_mutex(makeUnique&lt;Lock&gt;())</span>
 610 #endif
 611 #if DUMP_HASHTABLE_STATS_PER_TABLE
<a name="9" id="anc9"></a><span class="line-modified"> 612         , m_stats(makeUnique&lt;Stats&gt;())</span>
 613 #endif
 614     {
 615     }
 616 
 617     inline unsigned doubleHash(unsigned key)
 618     {
 619         key = ~key + (key &gt;&gt; 23);
 620         key ^= (key &lt;&lt; 12);
 621         key ^= (key &gt;&gt; 7);
 622         key ^= (key &lt;&lt; 2);
 623         key ^= (key &gt;&gt; 20);
 624         return key;
 625     }
 626 
 627 #if ASSERT_DISABLED
 628 
 629     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 630     template&lt;typename HashTranslator, typename T&gt;
 631     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 632     {
 633     }
 634 
 635 #else
 636 
 637     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 638     template&lt;typename HashTranslator, typename T&gt;
 639     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
 640     {
 641         if (!HashFunctions::safeToCompareToEmptyOrDeleted)
 642             return;
 643         ASSERT(!HashTranslator::equal(KeyTraits::emptyValue(), key));
 644         typename std::aligned_storage&lt;sizeof(ValueType), std::alignment_of&lt;ValueType&gt;::value&gt;::type deletedValueBuffer;
 645         ValueType* deletedValuePtr = reinterpret_cast_ptr&lt;ValueType*&gt;(&amp;deletedValueBuffer);
 646         ValueType&amp; deletedValue = *deletedValuePtr;
 647         Traits::constructDeletedValue(deletedValue);
 648         ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
 649     }
 650 
 651 #endif
 652 
 653     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 654     template&lt;typename HashTranslator, typename T&gt;
 655     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
 656     {
 657         return inlineLookup&lt;HashTranslator&gt;(key);
 658     }
 659 
 660     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 661     template&lt;typename HashTranslator, typename T&gt;
 662     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
 663     {
 664         checkKey&lt;HashTranslator&gt;(key);
 665 
 666         unsigned k = 0;
 667         unsigned sizeMask = m_tableSizeMask;
 668         ValueType* table = m_table;
 669         unsigned h = HashTranslator::hash(key);
 670         unsigned i = h &amp; sizeMask;
 671 
 672         if (!table)
 673             return 0;
 674 
 675 #if DUMP_HASHTABLE_STATS
 676         ++HashTableStats::numAccesses;
 677         unsigned probeCount = 0;
 678 #endif
 679 
 680 #if DUMP_HASHTABLE_STATS_PER_TABLE
 681         ++m_stats-&gt;numAccesses;
 682 #endif
 683 
 684         while (1) {
 685             ValueType* entry = table + i;
 686 
 687             // we count on the compiler to optimize out this branch
 688             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 689                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 690                     return entry;
 691 
 692                 if (isEmptyBucket(*entry))
 693                     return 0;
 694             } else {
 695                 if (isEmptyBucket(*entry))
 696                     return 0;
 697 
 698                 if (!isDeletedBucket(*entry) &amp;&amp; HashTranslator::equal(Extractor::extract(*entry), key))
 699                     return entry;
 700             }
 701 #if DUMP_HASHTABLE_STATS
 702             ++probeCount;
 703             HashTableStats::recordCollisionAtCount(probeCount);
 704 #endif
 705 
 706 #if DUMP_HASHTABLE_STATS_PER_TABLE
 707             m_stats-&gt;recordCollisionAtCount(probeCount);
 708 #endif
 709 
 710             if (k == 0)
 711                 k = 1 | doubleHash(h);
 712             i = (i + k) &amp; sizeMask;
 713         }
 714     }
 715 
 716     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 717     template&lt;typename HashTranslator, typename T&gt;
 718     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookupForWriting(const T&amp; key) -&gt; LookupType
 719     {
 720         ASSERT(m_table);
 721         checkKey&lt;HashTranslator&gt;(key);
 722 
 723         unsigned k = 0;
 724         ValueType* table = m_table;
 725         unsigned sizeMask = m_tableSizeMask;
 726         unsigned h = HashTranslator::hash(key);
 727         unsigned i = h &amp; sizeMask;
 728 
 729 #if DUMP_HASHTABLE_STATS
 730         ++HashTableStats::numAccesses;
 731         unsigned probeCount = 0;
 732 #endif
 733 
 734 #if DUMP_HASHTABLE_STATS_PER_TABLE
 735         ++m_stats-&gt;numAccesses;
 736 #endif
 737 
 738         ValueType* deletedEntry = 0;
 739 
 740         while (1) {
 741             ValueType* entry = table + i;
 742 
 743             // we count on the compiler to optimize out this branch
 744             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 745                 if (isEmptyBucket(*entry))
 746                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 747 
 748                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 749                     return LookupType(entry, true);
 750 
 751                 if (isDeletedBucket(*entry))
 752                     deletedEntry = entry;
 753             } else {
 754                 if (isEmptyBucket(*entry))
 755                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 756 
 757                 if (isDeletedBucket(*entry))
 758                     deletedEntry = entry;
 759                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 760                     return LookupType(entry, true);
 761             }
 762 #if DUMP_HASHTABLE_STATS
 763             ++probeCount;
 764             HashTableStats::recordCollisionAtCount(probeCount);
 765 #endif
 766 
 767 #if DUMP_HASHTABLE_STATS_PER_TABLE
 768             m_stats-&gt;recordCollisionAtCount(probeCount);
 769 #endif
 770 
 771             if (k == 0)
 772                 k = 1 | doubleHash(h);
 773             i = (i + k) &amp; sizeMask;
 774         }
 775     }
 776 
 777     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 778     template&lt;typename HashTranslator, typename T&gt;
 779     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::fullLookupForWriting(const T&amp; key) -&gt; FullLookupType
 780     {
 781         ASSERT(m_table);
 782         checkKey&lt;HashTranslator&gt;(key);
 783 
 784         unsigned k = 0;
 785         ValueType* table = m_table;
 786         unsigned sizeMask = m_tableSizeMask;
 787         unsigned h = HashTranslator::hash(key);
 788         unsigned i = h &amp; sizeMask;
 789 
 790 #if DUMP_HASHTABLE_STATS
 791         ++HashTableStats::numAccesses;
 792         unsigned probeCount = 0;
 793 #endif
 794 
 795 #if DUMP_HASHTABLE_STATS_PER_TABLE
 796         ++m_stats-&gt;numAccesses;
 797 #endif
 798 
 799         ValueType* deletedEntry = 0;
 800 
 801         while (1) {
 802             ValueType* entry = table + i;
 803 
 804             // we count on the compiler to optimize out this branch
 805             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 806                 if (isEmptyBucket(*entry))
 807                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 808 
 809                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 810                     return makeLookupResult(entry, true, h);
 811 
 812                 if (isDeletedBucket(*entry))
 813                     deletedEntry = entry;
 814             } else {
 815                 if (isEmptyBucket(*entry))
 816                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 817 
 818                 if (isDeletedBucket(*entry))
 819                     deletedEntry = entry;
 820                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 821                     return makeLookupResult(entry, true, h);
 822             }
 823 #if DUMP_HASHTABLE_STATS
 824             ++probeCount;
 825             HashTableStats::recordCollisionAtCount(probeCount);
 826 #endif
 827 
 828 #if DUMP_HASHTABLE_STATS_PER_TABLE
 829             m_stats-&gt;recordCollisionAtCount(probeCount);
 830 #endif
 831 
 832             if (k == 0)
 833                 k = 1 | doubleHash(h);
 834             i = (i + k) &amp; sizeMask;
 835         }
 836     }
 837 
 838     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 839     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 840     ALWAYS_INLINE void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp; extra)
 841     {
 842         ASSERT(m_table);
 843 
 844         checkKey&lt;HashTranslator&gt;(key);
 845 
 846         invalidateIterators();
 847 
 848         internalCheckTableConsistency();
 849 
 850         unsigned k = 0;
 851         ValueType* table = m_table;
 852         unsigned sizeMask = m_tableSizeMask;
 853         unsigned h = HashTranslator::hash(key);
 854         unsigned i = h &amp; sizeMask;
 855 
 856 #if DUMP_HASHTABLE_STATS
 857         ++HashTableStats::numAccesses;
 858         unsigned probeCount = 0;
 859 #endif
 860 
 861 #if DUMP_HASHTABLE_STATS_PER_TABLE
 862         ++m_stats-&gt;numAccesses;
 863 #endif
 864 
 865         ValueType* entry;
 866         while (1) {
 867             entry = table + i;
 868 
 869             if (isEmptyBucket(*entry))
 870                 break;
 871 
 872 #if DUMP_HASHTABLE_STATS
 873             ++probeCount;
 874             HashTableStats::recordCollisionAtCount(probeCount);
 875 #endif
 876 
 877 #if DUMP_HASHTABLE_STATS_PER_TABLE
 878             m_stats-&gt;recordCollisionAtCount(probeCount);
 879 #endif
 880 
 881             if (k == 0)
 882                 k = 1 | doubleHash(h);
 883             i = (i + k) &amp; sizeMask;
 884         }
 885 
 886         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
 887 
 888         internalCheckTableConsistency();
 889     }
 890 
 891     template&lt;bool emptyValueIsZero&gt; struct HashTableBucketInitializer;
 892 
 893     template&lt;&gt; struct HashTableBucketInitializer&lt;false&gt; {
 894         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 895         {
 896             Traits::template constructEmptyValue&lt;Traits&gt;(bucket);
 897         }
 898     };
 899 
 900     template&lt;&gt; struct HashTableBucketInitializer&lt;true&gt; {
 901         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 902         {
 903             // This initializes the bucket without copying the empty value.
 904             // That makes it possible to use this with types that don&#39;t support copying.
 905             // The memset to 0 looks like a slow operation but is optimized by the compilers.
 906             memset(static_cast&lt;void*&gt;(std::addressof(bucket)), 0, sizeof(bucket));
 907         }
 908     };
 909 
 910     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 911     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::initializeBucket(ValueType&amp; bucket)
 912     {
 913         HashTableBucketInitializer&lt;Traits::emptyValueIsZero&gt;::template initialize&lt;Traits&gt;(bucket);
 914     }
 915 
 916     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 917     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 918     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::add(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 919     {
 920         checkKey&lt;HashTranslator&gt;(key);
 921 
 922         invalidateIterators();
 923 
 924         if (!m_table)
 925             expand(nullptr);
 926 
 927         internalCheckTableConsistency();
 928 
 929         ASSERT(m_table);
 930 
 931         unsigned k = 0;
 932         ValueType* table = m_table;
 933         unsigned sizeMask = m_tableSizeMask;
 934         unsigned h = HashTranslator::hash(key);
 935         unsigned i = h &amp; sizeMask;
 936 
 937 #if DUMP_HASHTABLE_STATS
 938         ++HashTableStats::numAccesses;
 939         unsigned probeCount = 0;
 940 #endif
 941 
 942 #if DUMP_HASHTABLE_STATS_PER_TABLE
 943         ++m_stats-&gt;numAccesses;
 944 #endif
 945 
 946         ValueType* deletedEntry = 0;
 947         ValueType* entry;
 948         while (1) {
 949             entry = table + i;
 950 
 951             // we count on the compiler to optimize out this branch
 952             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 953                 if (isEmptyBucket(*entry))
 954                     break;
 955 
 956                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 957                     return AddResult(makeKnownGoodIterator(entry), false);
 958 
 959                 if (isDeletedBucket(*entry))
 960                     deletedEntry = entry;
 961             } else {
 962                 if (isEmptyBucket(*entry))
 963                     break;
 964 
 965                 if (isDeletedBucket(*entry))
 966                     deletedEntry = entry;
 967                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 968                     return AddResult(makeKnownGoodIterator(entry), false);
 969             }
 970 #if DUMP_HASHTABLE_STATS
 971             ++probeCount;
 972             HashTableStats::recordCollisionAtCount(probeCount);
 973 #endif
 974 
 975 #if DUMP_HASHTABLE_STATS_PER_TABLE
 976             m_stats-&gt;recordCollisionAtCount(probeCount);
 977 #endif
 978 
 979             if (k == 0)
 980                 k = 1 | doubleHash(h);
 981             i = (i + k) &amp; sizeMask;
 982         }
 983 
 984         if (deletedEntry) {
 985             initializeBucket(*deletedEntry);
 986             entry = deletedEntry;
 987             --m_deletedCount;
 988         }
 989 
 990         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
 991         ++m_keyCount;
 992 
 993         if (shouldExpand())
 994             entry = expand(entry);
 995 
 996         internalCheckTableConsistency();
 997 
 998         return AddResult(makeKnownGoodIterator(entry), true);
 999     }
1000 
1001     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1002     template&lt;typename HashTranslator, typename T, typename Extra&gt;
1003     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
1004     {
1005         checkKey&lt;HashTranslator&gt;(key);
1006 
1007         invalidateIterators();
1008 
1009         if (!m_table)
1010             expand();
1011 
1012         internalCheckTableConsistency();
1013 
1014         FullLookupType lookupResult = fullLookupForWriting&lt;HashTranslator&gt;(key);
1015 
1016         ValueType* entry = lookupResult.first.first;
1017         bool found = lookupResult.first.second;
1018         unsigned h = lookupResult.second;
1019 
1020         if (found)
1021             return AddResult(makeKnownGoodIterator(entry), false);
1022 
1023         if (isDeletedBucket(*entry)) {
1024             initializeBucket(*entry);
1025             --m_deletedCount;
1026         }
1027 
1028         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
1029         ++m_keyCount;
1030 
1031         if (shouldExpand())
1032             entry = expand(entry);
1033 
1034         internalCheckTableConsistency();
1035 
1036         return AddResult(makeKnownGoodIterator(entry), true);
1037     }
1038 
1039     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1040     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::reinsert(ValueType&amp;&amp; entry) -&gt; ValueType*
1041     {
1042         ASSERT(m_table);
1043         ASSERT(!lookupForWriting(Extractor::extract(entry)).second);
1044         ASSERT(!isDeletedBucket(*(lookupForWriting(Extractor::extract(entry)).first)));
1045 #if DUMP_HASHTABLE_STATS
1046         ++HashTableStats::numReinserts;
1047 #endif
1048 #if DUMP_HASHTABLE_STATS_PER_TABLE
1049         ++m_stats-&gt;numReinserts;
1050 #endif
1051 
1052         Value* newEntry = lookupForWriting(Extractor::extract(entry)).first;
1053         newEntry-&gt;~Value();
1054         new (NotNull, newEntry) ValueType(WTFMove(entry));
1055 
1056         return newEntry;
1057     }
1058 
1059     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1060     template &lt;typename HashTranslator, typename T&gt;
1061     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) -&gt; iterator
1062     {
1063         if (!m_table)
1064             return end();
1065 
1066         ValueType* entry = lookup&lt;HashTranslator&gt;(key);
1067         if (!entry)
1068             return end();
1069 
1070         return makeKnownGoodIterator(entry);
1071     }
1072 
1073     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1074     template &lt;typename HashTranslator, typename T&gt;
1075     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) const -&gt; const_iterator
1076     {
1077         if (!m_table)
1078             return end();
1079 
1080         ValueType* entry = const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1081         if (!entry)
1082             return end();
1083 
1084         return makeKnownGoodConstIterator(entry);
1085     }
1086 
1087     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1088     template &lt;typename HashTranslator, typename T&gt;
1089     bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::contains(const T&amp; key) const
1090     {
1091         if (!m_table)
1092             return false;
1093 
1094         return const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1095     }
1096 
1097     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1098     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)
1099     {
1100         invalidateIterators();
1101         remove(pos);
1102     }
1103 
1104     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1105     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidate(ValueType* pos)
1106     {
1107         invalidateIterators();
1108         internalCheckTableConsistency();
1109         remove(pos);
1110     }
1111 
1112     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1113     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(ValueType* pos)
1114     {
1115 #if DUMP_HASHTABLE_STATS
1116         ++HashTableStats::numRemoves;
1117 #endif
1118 #if DUMP_HASHTABLE_STATS_PER_TABLE
1119         ++m_stats-&gt;numRemoves;
1120 #endif
1121 
1122         deleteBucket(*pos);
1123         ++m_deletedCount;
1124         --m_keyCount;
1125 
1126         if (shouldShrink())
1127             shrink();
1128 
1129         internalCheckTableConsistency();
1130     }
1131 
1132     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1133     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(iterator it)
1134     {
1135         if (it == end())
1136             return;
1137 
1138         removeAndInvalidate(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1139     }
1140 
1141     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1142     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(iterator it)
1143     {
1144         if (it == end())
1145             return;
1146 
1147         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1148     }
1149 
1150     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1151     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(const_iterator it)
1152     {
1153         if (it == end())
1154             return;
1155 
1156         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_position));
1157     }
1158 
1159     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1160     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(const KeyType&amp; key)
1161     {
1162         remove(find(key));
1163     }
1164 
1165     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1166     template&lt;typename Functor&gt;
1167     inline bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeIf(const Functor&amp; functor)
1168     {
1169         // We must use local copies in case &quot;functor&quot; or &quot;deleteBucket&quot;
1170         // make a function call, which prevents the compiler from keeping
1171         // the values in register.
1172         unsigned removedBucketCount = 0;
1173         ValueType* table = m_table;
1174 
1175         for (unsigned i = m_tableSize; i--;) {
1176             ValueType&amp; bucket = table[i];
1177             if (isEmptyOrDeletedBucket(bucket))
1178                 continue;
1179 
1180             if (!functor(bucket))
1181                 continue;
1182 
1183             deleteBucket(bucket);
1184             ++removedBucketCount;
1185         }
1186         m_deletedCount += removedBucketCount;
1187         m_keyCount -= removedBucketCount;
1188 
1189         if (shouldShrink())
<a name="10" id="anc10"></a><span class="line-modified">1190             shrinkToBestSize();</span>
1191 
1192         internalCheckTableConsistency();
1193         return removedBucketCount;
1194     }
1195 
1196     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1197     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1198     {
1199         // would use a template member function with explicit specializations here, but
1200         // gcc doesn&#39;t appear to support that
1201         if (Traits::emptyValueIsZero)
1202             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));
1203         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));
1204         for (unsigned i = 0; i &lt; size; i++)
1205             initializeBucket(result[i]);
1206         return result;
1207     }
1208 
1209     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1210     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)
1211     {
1212         for (unsigned i = 0; i &lt; size; ++i) {
1213             if (!isDeletedBucket(table[i]))
1214                 table[i].~ValueType();
1215         }
1216         fastFree(table);
1217     }
1218 
1219     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1220     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1221     {
<a name="11" id="anc11"></a><span class="line-added">1222         if (KeyTraits::hasIsReleasedWeakValueFunction)</span>
<span class="line-added">1223             deleteReleasedWeakBuckets();</span>
<span class="line-added">1224 </span>
1225         unsigned newSize;
1226         if (m_tableSize == 0)
1227             newSize = KeyTraits::minimumTableSize;
1228         else if (mustRehashInPlace())
1229             newSize = m_tableSize;
1230         else
1231             newSize = m_tableSize * 2;
1232 
1233         return rehash(newSize, entry);
1234     }
1235 
<a name="12" id="anc12"></a><span class="line-added">1236     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1237     constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)</span>
<span class="line-added">1238     {</span>
<span class="line-added">1239         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount) * 2;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.</span>
<span class="line-added">1242         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to</span>
<span class="line-added">1243         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).</span>
<span class="line-added">1244         bool aboveThreeQuarterLoad = keyCount * 12 &gt;= bestTableSize * 5;</span>
<span class="line-added">1245         if (aboveThreeQuarterLoad)</span>
<span class="line-added">1246             bestTableSize *= 2;</span>
<span class="line-added">1247 </span>
<span class="line-added">1248         unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added">1249         return std::max(bestTableSize, minimumTableSize);</span>
<span class="line-added">1250     }</span>
<span class="line-added">1251 </span>
<span class="line-added">1252     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1253     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()</span>
<span class="line-added">1254     {</span>
<span class="line-added">1255         unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added">1256         rehash(std::max(minimumTableSize, computeBestTableSize(m_keyCount)), nullptr);</span>
<span class="line-added">1257     }</span>
<span class="line-added">1258 </span>
<span class="line-added">1259     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1260     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()</span>
<span class="line-added">1261     {</span>
<span class="line-added">1262         for (unsigned i = 0; i &lt; m_tableSize; ++i) {</span>
<span class="line-added">1263             auto&amp; entry = m_table[i];</span>
<span class="line-added">1264             if (isReleasedWeakBucket(entry)) {</span>
<span class="line-added">1265                 deleteBucket(entry);</span>
<span class="line-added">1266                 ++m_deletedCount;</span>
<span class="line-added">1267                 --m_keyCount;</span>
<span class="line-added">1268             }</span>
<span class="line-added">1269         }</span>
<span class="line-added">1270     }</span>
<span class="line-added">1271 </span>
1272     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1273     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1274     {
1275         internalCheckTableConsistencyExceptSize();
1276 
1277         unsigned oldTableSize = m_tableSize;
1278         ValueType* oldTable = m_table;
1279 
1280 #if DUMP_HASHTABLE_STATS
1281         if (oldTableSize != 0)
1282             ++HashTableStats::numRehashes;
1283 #endif
1284 
1285 #if DUMP_HASHTABLE_STATS_PER_TABLE
1286         if (oldTableSize != 0)
1287             ++m_stats-&gt;numRehashes;
1288 #endif
1289 
1290         m_tableSize = newTableSize;
1291         m_tableSizeMask = newTableSize - 1;
1292         m_table = allocateTable(newTableSize);
1293 
1294         Value* newEntry = nullptr;
1295         for (unsigned i = 0; i != oldTableSize; ++i) {
<a name="13" id="anc13"></a><span class="line-modified">1296             auto&amp; oldEntry = oldTable[i];</span>
<span class="line-modified">1297             if (isDeletedBucket(oldEntry)) {</span>
<span class="line-added">1298                 ASSERT(std::addressof(oldEntry) != entry);</span>
1299                 continue;
1300             }
1301 
<a name="14" id="anc14"></a><span class="line-modified">1302             if (isEmptyBucket(oldEntry)) {</span>
<span class="line-modified">1303                 ASSERT(std::addressof(oldEntry) != entry);</span>
1304                 oldTable[i].~ValueType();
1305                 continue;
1306             }
1307 
<a name="15" id="anc15"></a><span class="line-modified">1308             if (isReleasedWeakBucket(oldEntry)) {</span>
<span class="line-modified">1309                 ASSERT(std::addressof(oldEntry) != entry);</span>
<span class="line-modified">1310                 oldEntry.~ValueType();</span>
<span class="line-added">1311                 --m_keyCount;</span>
<span class="line-added">1312                 continue;</span>
<span class="line-added">1313             }</span>
<span class="line-added">1314 </span>
<span class="line-added">1315             Value* reinsertedEntry = reinsert(WTFMove(oldEntry));</span>
<span class="line-added">1316             oldEntry.~ValueType();</span>
<span class="line-added">1317             if (std::addressof(oldEntry) == entry) {</span>
1318                 ASSERT(!newEntry);
1319                 newEntry = reinsertedEntry;
1320             }
1321         }
1322 
1323         m_deletedCount = 0;
1324 
1325         fastFree(oldTable);
1326 
1327         internalCheckTableConsistency();
1328         return newEntry;
1329     }
1330 
1331     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1332     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1333     {
1334         invalidateIterators();
1335         if (!m_table)
1336             return;
1337 
1338         deallocateTable(m_table, m_tableSize);
1339         m_table = 0;
1340         m_tableSize = 0;
1341         m_tableSizeMask = 0;
1342         m_keyCount = 0;
1343         m_deletedCount = 0;
1344     }
1345 
1346     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1347     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1348         : m_table(nullptr)
1349         , m_tableSize(0)
1350         , m_tableSizeMask(0)
1351         , m_keyCount(0)
1352         , m_deletedCount(0)
1353 #if CHECK_HASHTABLE_ITERATORS
1354         , m_iterators(nullptr)
<a name="16" id="anc16"></a><span class="line-modified">1355         , m_mutex(makeUnique&lt;Lock&gt;())</span>
1356 #endif
1357 #if DUMP_HASHTABLE_STATS_PER_TABLE
<a name="17" id="anc17"></a><span class="line-modified">1358         , m_stats(makeUnique&lt;Stats&gt;(*other.m_stats))</span>
1359 #endif
1360     {
1361         unsigned otherKeyCount = other.size();
1362         if (!otherKeyCount)
1363             return;
1364 
<a name="18" id="anc18"></a><span class="line-modified">1365         m_tableSize = computeBestTableSize(otherKeyCount);</span>










1366         m_tableSizeMask = m_tableSize - 1;
1367         m_keyCount = otherKeyCount;
1368         m_table = allocateTable(m_tableSize);
1369 
1370         for (const auto&amp; otherValue : other)
1371             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1372     }
1373 
1374     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1375     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1376     {
1377         invalidateIterators();
1378         other.invalidateIterators();
1379 
1380         std::swap(m_table, other.m_table);
1381         std::swap(m_tableSize, other.m_tableSize);
1382         std::swap(m_tableSizeMask, other.m_tableSizeMask);
1383         std::swap(m_keyCount, other.m_keyCount);
1384         std::swap(m_deletedCount, other.m_deletedCount);
1385 
1386 #if DUMP_HASHTABLE_STATS_PER_TABLE
1387         m_stats.swap(other.m_stats);
1388 #endif
1389     }
1390 
1391     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1392     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1393     {
1394         HashTable tmp(other);
1395         swap(tmp);
1396         return *this;
1397     }
1398 
1399     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1400     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1401 #if CHECK_HASHTABLE_ITERATORS
1402         : m_iterators(nullptr)
<a name="19" id="anc19"></a><span class="line-modified">1403         , m_mutex(makeUnique&lt;Lock&gt;())</span>
1404 #endif
1405     {
1406         other.invalidateIterators();
1407 
1408         m_table = other.m_table;
1409         m_tableSize = other.m_tableSize;
1410         m_tableSizeMask = other.m_tableSizeMask;
1411         m_keyCount = other.m_keyCount;
1412         m_deletedCount = other.m_deletedCount;
1413 
1414         other.m_table = nullptr;
1415         other.m_tableSize = 0;
1416         other.m_tableSizeMask = 0;
1417         other.m_keyCount = 0;
1418         other.m_deletedCount = 0;
1419 
1420 #if DUMP_HASHTABLE_STATS_PER_TABLE
1421         m_stats = WTFMove(other.m_stats);
1422         other.m_stats = nullptr;
1423 #endif
1424     }
1425 
1426     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1427     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(HashTable&amp;&amp; other) -&gt; HashTable&amp;
1428     {
1429         HashTable temp = WTFMove(other);
1430         swap(temp);
1431         return *this;
1432     }
1433 
1434 #if !ASSERT_DISABLED
1435 
1436     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1437     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
1438     {
1439         checkTableConsistencyExceptSize();
1440         ASSERT(!m_table || !shouldExpand());
1441         ASSERT(!shouldShrink());
1442     }
1443 
1444     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1445     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1446     {
1447         if (!m_table)
1448             return;
1449 
1450         unsigned count = 0;
1451         unsigned deletedCount = 0;
1452         for (unsigned j = 0; j &lt; m_tableSize; ++j) {
1453             ValueType* entry = m_table + j;
1454             if (isEmptyBucket(*entry))
1455                 continue;
1456 
1457             if (isDeletedBucket(*entry)) {
1458                 ++deletedCount;
1459                 continue;
1460             }
1461 
<a name="20" id="anc20"></a><span class="line-modified">1462             auto&amp; key = Extractor::extract(*entry);</span>
<span class="line-added">1463             const_iterator it = find(key);</span>
1464             ASSERT(entry == it.m_position);
1465             ++count;
1466 
<a name="21" id="anc21"></a><span class="line-modified">1467             ValueCheck&lt;Key&gt;::checkConsistency(key);</span>
1468         }
1469 
1470         ASSERT(count == m_keyCount);
1471         ASSERT(deletedCount == m_deletedCount);
1472         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);
1473         ASSERT(m_tableSizeMask);
1474         ASSERT(m_tableSize == m_tableSizeMask + 1);
1475     }
1476 
1477 #endif // ASSERT_DISABLED
1478 
1479 #if CHECK_HASHTABLE_ITERATORS
1480 
1481     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1482     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1483     {
1484         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1485         const_iterator* next;
1486         for (const_iterator* p = m_iterators; p; p = next) {
1487             next = p-&gt;m_next;
1488             p-&gt;m_table = 0;
1489             p-&gt;m_next = 0;
1490             p-&gt;m_previous = 0;
1491         }
1492         m_iterators = 0;
1493     }
1494 
1495     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1496     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* table,
1497         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1498     {
1499         it-&gt;m_table = table;
1500         it-&gt;m_previous = 0;
1501 
1502         // Insert iterator at head of doubly-linked list of iterators.
1503         if (!table) {
1504             it-&gt;m_next = 0;
1505         } else {
1506             std::lock_guard&lt;Lock&gt; lock(*table-&gt;m_mutex);
1507             ASSERT(table-&gt;m_iterators != it);
1508             it-&gt;m_next = table-&gt;m_iterators;
1509             table-&gt;m_iterators = it;
1510             if (it-&gt;m_next) {
1511                 ASSERT(!it-&gt;m_next-&gt;m_previous);
1512                 it-&gt;m_next-&gt;m_previous = it;
1513             }
1514         }
1515     }
1516 
1517     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1518     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1519     {
1520         // Delete iterator from doubly-linked list of iterators.
1521         if (!it-&gt;m_table) {
1522             ASSERT(!it-&gt;m_next);
1523             ASSERT(!it-&gt;m_previous);
1524         } else {
1525             std::lock_guard&lt;Lock&gt; lock(*it-&gt;m_table-&gt;m_mutex);
1526             if (it-&gt;m_next) {
1527                 ASSERT(it-&gt;m_next-&gt;m_previous == it);
1528                 it-&gt;m_next-&gt;m_previous = it-&gt;m_previous;
1529             }
1530             if (it-&gt;m_previous) {
1531                 ASSERT(it-&gt;m_table-&gt;m_iterators != it);
1532                 ASSERT(it-&gt;m_previous-&gt;m_next == it);
1533                 it-&gt;m_previous-&gt;m_next = it-&gt;m_next;
1534             } else {
1535                 ASSERT(it-&gt;m_table-&gt;m_iterators == it);
1536                 it-&gt;m_table-&gt;m_iterators = it-&gt;m_next;
1537             }
1538         }
1539 
1540         it-&gt;m_table = 0;
1541         it-&gt;m_next = 0;
1542         it-&gt;m_previous = 0;
1543     }
1544 
1545 #endif // CHECK_HASHTABLE_ITERATORS
1546 
1547     // iterator adapters
1548 
1549     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableConstIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, const ValueType*, const ValueType&amp;&gt; {
1550         HashTableConstIteratorAdapter() {}
1551         HashTableConstIteratorAdapter(const typename HashTableType::const_iterator&amp; impl) : m_impl(impl) {}
1552 
1553         const ValueType* get() const { return (const ValueType*)m_impl.get(); }
1554         const ValueType&amp; operator*() const { return *get(); }
1555         const ValueType* operator-&gt;() const { return get(); }
1556 
1557         HashTableConstIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1558         // postfix ++ intentionally omitted
1559 
1560         typename HashTableType::const_iterator m_impl;
1561     };
1562 
1563     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, ValueType*, ValueType&amp;&gt; {
1564         HashTableIteratorAdapter() {}
1565         HashTableIteratorAdapter(const typename HashTableType::iterator&amp; impl) : m_impl(impl) {}
1566 
1567         ValueType* get() const { return (ValueType*)m_impl.get(); }
1568         ValueType&amp; operator*() const { return *get(); }
1569         ValueType* operator-&gt;() const { return get(); }
1570 
1571         HashTableIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1572         // postfix ++ intentionally omitted
1573 
1574         operator HashTableConstIteratorAdapter&lt;HashTableType, ValueType&gt;() {
1575             typename HashTableType::const_iterator i = m_impl;
1576             return i;
1577         }
1578 
1579         typename HashTableType::iterator m_impl;
1580     };
1581 
1582     template&lt;typename T, typename U&gt;
1583     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1584     {
1585         return a.m_impl == b.m_impl;
1586     }
1587 
1588     template&lt;typename T, typename U&gt;
1589     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1590     {
1591         return a.m_impl != b.m_impl;
1592     }
1593 
1594     template&lt;typename T, typename U&gt;
1595     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1596     {
1597         return a.m_impl == b.m_impl;
1598     }
1599 
1600     template&lt;typename T, typename U&gt;
1601     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1602     {
1603         return a.m_impl != b.m_impl;
1604     }
1605 
1606     // All 4 combinations of ==, != and Const,non const.
1607     template&lt;typename T, typename U&gt;
1608     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1609     {
1610         return a.m_impl == b.m_impl;
1611     }
1612 
1613     template&lt;typename T, typename U&gt;
1614     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1615     {
1616         return a.m_impl != b.m_impl;
1617     }
1618 
1619     template&lt;typename T, typename U&gt;
1620     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1621     {
1622         return a.m_impl == b.m_impl;
1623     }
1624 
1625     template&lt;typename T, typename U&gt;
1626     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1627     {
1628         return a.m_impl != b.m_impl;
1629     }
1630 
1631 } // namespace WTF
1632 
1633 #include &lt;wtf/HashIterators.h&gt;
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>