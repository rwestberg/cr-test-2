<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPropertyResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPropertyResolver.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLArrayType.h&quot;
 32 #include &quot;WHLSLAssignmentExpression.h&quot;
 33 #include &quot;WHLSLCallExpression.h&quot;
 34 #include &quot;WHLSLCommaExpression.h&quot;
 35 #include &quot;WHLSLDereferenceExpression.h&quot;
 36 #include &quot;WHLSLDotExpression.h&quot;
 37 #include &quot;WHLSLFunctionDeclaration.h&quot;
 38 #include &quot;WHLSLFunctionDefinition.h&quot;
 39 #include &quot;WHLSLIndexExpression.h&quot;
 40 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
 41 #include &quot;WHLSLMakePointerExpression.h&quot;
 42 #include &quot;WHLSLPointerType.h&quot;
 43 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
 44 #include &quot;WHLSLReplaceWith.h&quot;
 45 #include &quot;WHLSLVariableDeclaration.h&quot;
 46 #include &quot;WHLSLVariableReference.h&quot;
 47 #include &quot;WHLSLVisitor.h&quot;
 48 
 49 namespace WebCore {
 50 
 51 namespace WHLSL {
 52 
 53 class PropertyResolver : public Visitor {
 54 public:
 55 private:
 56     void visit(AST::FunctionDefinition&amp;) override;
 57     void visit(AST::DotExpression&amp;) override;
 58     void visit(AST::IndexExpression&amp;) override;
 59     void visit(AST::AssignmentExpression&amp;) override;
 60     void visit(AST::ReadModifyWriteExpression&amp;) override;
 61 
 62     void simplifyRightValue(AST::PropertyAccessExpression&amp;);
 63     bool simplifyAbstractLeftValue(AST::AssignmentExpression&amp;, AST::DotExpression&amp;, UniqueRef&lt;AST::Expression&gt;&amp;&amp; right);
 64     void simplifyLeftValue(AST::Expression&amp;);
 65 
 66     AST::VariableDeclarations m_variableDeclarations;
 67 };
 68 
 69 void PropertyResolver::visit(AST::DotExpression&amp; dotExpression)
 70 {
 71     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.
 72     simplifyRightValue(dotExpression);
 73 }
 74 
 75 void PropertyResolver::visit(AST::IndexExpression&amp; indexExpression)
 76 {
 77     checkErrorAndVisit(indexExpression.indexExpression());
 78     // Unless we&#39;re inside an AssignmentExpression or a ReadModifyWriteExpression, we&#39;re a right value.
 79     simplifyRightValue(indexExpression);
 80 }
 81 
 82 void PropertyResolver::visit(AST::FunctionDefinition&amp; functionDefinition)
 83 {
 84     Visitor::visit(functionDefinition);
 85     if (!m_variableDeclarations.isEmpty())
 86         functionDefinition.block().statements().insert(0, makeUniqueRef&lt;AST::VariableDeclarationsStatement&gt;(functionDefinition.codeLocation(), WTFMove(m_variableDeclarations)));
 87 }
 88 
 89 enum class WhichAnder {
 90     ThreadAnder,
 91     Ander
 92 };
 93 
 94 struct AnderCallArgumentResult {
 95     UniqueRef&lt;AST::Expression&gt; expression;
 96     Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclaration;
 97     WhichAnder whichAnder;
 98 };
 99 
100 template &lt;typename ExpressionConstructor, typename TypeConstructor&gt;
101 static Optional&lt;AnderCallArgumentResult&gt; wrapAnderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, Ref&lt;AST::UnnamedType&gt; baseType, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)
102 {
103     auto functionEscapeMode = [] (AST::FunctionDeclaration&amp; functionDeclaration) {
104         if (functionDeclaration.isNativeFunctionDeclaration() || functionDeclaration.parsingMode() == ParsingMode::StandardLibrary)
105             return AST::AddressEscapeMode::DoesNotEscape;
106         return AST::AddressEscapeMode::Escapes;
107     };
108 
109     auto location = expression-&gt;codeLocation();
110     if (auto addressSpace = expression-&gt;typeAnnotation().leftAddressSpace()) {
111         if (!anderFunction)
112             return WTF::nullopt;
113         auto makeArrayReference = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(expression), functionEscapeMode(*anderFunction));
114         makeArrayReference-&gt;setType(TypeConstructor::create(location, *addressSpace, WTFMove(baseType)));
115         makeArrayReference-&gt;setTypeAnnotation(AST::RightValue());
116         return {{ WTFMove(makeArrayReference), WTF::nullopt, WhichAnder::Ander }};
117     }
118     if (threadAnderFunction) {
119         auto variableDeclaration = makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), baseType.copyRef(), String(), nullptr, nullptr);
120 
121         auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));
122         variableReference1-&gt;setType(baseType.copyRef());
123         variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
124 
125         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference1), WTFMove(expression));
126         assignmentExpression-&gt;setType(baseType.copyRef());
127         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
128 
129         auto variableReference2 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));
130         variableReference2-&gt;setType(baseType.copyRef());
131         variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
132 
133         auto expression = makeUniqueRef&lt;ExpressionConstructor&gt;(location, WTFMove(variableReference2), functionEscapeMode(*threadAnderFunction));
134         auto resultType = TypeConstructor::create(location, AST::AddressSpace::Thread, WTFMove(baseType));
135         expression-&gt;setType(resultType.copyRef());
136         expression-&gt;setTypeAnnotation(AST::RightValue());
137 
138         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
139         expressions.append(WTFMove(assignmentExpression));
140         expressions.append(WTFMove(expression));
141         auto commaExpression = makeUniqueRef&lt;AST::CommaExpression&gt;(location, WTFMove(expressions));
142         commaExpression-&gt;setType(WTFMove(resultType));
143         commaExpression-&gt;setTypeAnnotation(AST::RightValue());
144         return {{ WTFMove(commaExpression), { WTFMove(variableDeclaration) }, WhichAnder::ThreadAnder}};
145     }
146     return WTF::nullopt;
147 }
148 
149 static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(UniqueRef&lt;AST::Expression&gt;&amp; expression, AST::FunctionDeclaration* anderFunction, AST::FunctionDeclaration* threadAnderFunction)
150 {
151     if (!anderFunction &amp;&amp; !threadAnderFunction)
152         return WTF::nullopt;
153     auto&amp; unifyNode = expression-&gt;resolvedType().unifyNode();
154     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
155         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
156         ASSERT(!is&lt;AST::PointerType&gt;(unnamedType));
157         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))
158             return {{ WTFMove(expression), WTF::nullopt, WhichAnder::Ander }};
159         if (is&lt;AST::ArrayType&gt;(unnamedType))
160             return wrapAnderCallArgument&lt;AST::MakeArrayReferenceExpression, AST::ArrayReferenceType&gt;(expression, downcast&lt;AST::ArrayType&gt;(unnamedType).type(), anderFunction, threadAnderFunction);
161     }
162     return wrapAnderCallArgument&lt;AST::MakePointerExpression, AST::PointerType&gt;(expression, expression-&gt;resolvedType(), anderFunction, threadAnderFunction);
163 }
164 
165 static UniqueRef&lt;AST::Expression&gt; setterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, UniqueRef&lt;AST::Expression&gt;&amp;&amp; newValue, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)
166 {
167     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {
168         if (!indexVariable)
169             return;
170         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));
171         ASSERT(indexVariable-&gt;type());
172         variableReference-&gt;setType(*indexVariable-&gt;type());
173         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
174         arguments.append(WTFMove(variableReference));
175     };
176 
177     auto location = propertyAccessExpression.codeLocation();
178     if (relevantAnder) {
179         // *operator&amp;.foo(&amp;v) = newValue
180         auto leftValue = leftValueFactory();
181         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);
182         ASSERT(argument);
183         ASSERT(!argument-&gt;variableDeclaration);
184         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);
185         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
186         arguments.append(WTFMove(argument-&gt;expression));
187         maybeAddIndexArgument(arguments);
188 
189         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));
190         callExpression-&gt;setType(relevantAnder-&gt;type());
191         callExpression-&gt;setTypeAnnotation(AST::RightValue());
192         callExpression-&gt;setFunction(*relevantAnder);
193 
194         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));
195         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());
196         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
197 
198         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(newValue));
199         assignmentExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());
200         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
201 
202         return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));
203     }
204 
205     // v = operator.foo=(v, newValue)
206     ASSERT(propertyAccessExpression.setterFunction());
207 
208     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
209     arguments.append(leftValueFactory());
210     maybeAddIndexArgument(arguments);
211     arguments.append(WTFMove(newValue));
212 
213     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.setterFunction()-&gt;name()), WTFMove(arguments));
214     callExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());
215     callExpression-&gt;setTypeAnnotation(AST::RightValue());
216     callExpression-&gt;setFunction(*propertyAccessExpression.setterFunction());
217 
218     auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, leftValueFactory(), WTFMove(callExpression));
219     assignmentExpression-&gt;setType(propertyAccessExpression.setterFunction()-&gt;type());
220     assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
221 
222     return UniqueRef&lt;AST::Expression&gt;(WTFMove(assignmentExpression));
223 }
224 
225 static UniqueRef&lt;AST::Expression&gt; getterCall(AST::PropertyAccessExpression&amp; propertyAccessExpression, AST::FunctionDeclaration* relevantAnder, const std::function&lt;UniqueRef&lt;AST::Expression&gt;()&gt;&amp; leftValueFactory, AST::VariableDeclaration* indexVariable)
226 {
227     auto maybeAddIndexArgument = [&amp;](Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;&amp; arguments) {
228         if (!indexVariable)
229             return;
230         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));
231         ASSERT(indexVariable-&gt;type());
232         variableReference-&gt;setType(*indexVariable-&gt;type());
233         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
234         arguments.append(WTFMove(variableReference));
235     };
236 
237     auto location = propertyAccessExpression.codeLocation();
238 
239     if (relevantAnder) {
240         // *operator&amp;.foo(&amp;v)
241         auto leftValue = leftValueFactory();
242         auto argument = anderCallArgument(leftValue, relevantAnder, relevantAnder);
243         ASSERT(argument);
244         ASSERT(!argument-&gt;variableDeclaration);
245         ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);
246         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
247         arguments.append(WTFMove(argument-&gt;expression));
248         maybeAddIndexArgument(arguments);
249 
250         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(relevantAnder-&gt;name()), WTFMove(arguments));
251         callExpression-&gt;setType(relevantAnder-&gt;type());
252         callExpression-&gt;setTypeAnnotation(AST::RightValue());
253         callExpression-&gt;setFunction(*relevantAnder);
254 
255         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(callExpression));
256         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(relevantAnder-&gt;type()).elementType());
257         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread });
258 
259         return UniqueRef&lt;AST::Expression&gt;(WTFMove(dereferenceExpression));
260     }
261 
262     // operator.foo(v)
263     ASSERT(propertyAccessExpression.getterFunction());
264 
265     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
266     arguments.append(leftValueFactory());
267     maybeAddIndexArgument(arguments);
268 
269     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(propertyAccessExpression.getterFunction()-&gt;name()), WTFMove(arguments));
270     callExpression-&gt;setType(propertyAccessExpression.getterFunction()-&gt;type());
271     callExpression-&gt;setTypeAnnotation(AST::RightValue());
272     callExpression-&gt;setFunction(*propertyAccessExpression.getterFunction());
273 
274     return UniqueRef&lt;AST::Expression&gt;(WTFMove(callExpression));
275 }
276 
277 struct ModifyResult {
278     AST::Expression&amp; innerLeftValue;
279     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
280     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;
281 };
282 struct ModificationResult {
283     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
284     UniqueRef&lt;AST::Expression&gt; result;
285 };
286 static ModifyResult modify(AST::PropertyAccessExpression&amp; propertyAccessExpression, std::function&lt;ModificationResult(UniqueRef&lt;AST::Expression&gt;&amp;&amp;)&gt; modification)
287 {
288     // Consider a.b.c.d++;
289     // This would get transformed into:
290     //
291     // Step 1:
292     // p = &amp;a;
293     //
294     // Step 2:
295     // q = operator.b(*p);
296     // r = operator.c(q);
297     //
298     // Step 3:
299     // oldValue = operator.d(r);
300     // newValue = ...;
301     //
302     // Step 4:
303     // r = operator.d=(r, newValue);
304     // q = operator.c=(q, r);
305     //
306     // Step 5:
307     // *p = operator.b=(*p, q);
308 
309     // If the expression is a.b.c.d = e, Step 3 disappears and &quot;newValue&quot; in step 4 becomes &quot;e&quot;.
310 
311 
312     // Find the &quot;.b&quot; &quot;.c&quot; and &quot;.d&quot; expressions. They end up in the order [&quot;.d&quot;, &quot;.c&quot;, &quot;.b&quot;].
313     Vector&lt;std::reference_wrapper&lt;AST::PropertyAccessExpression&gt;&gt; chain;
314     AST::PropertyAccessExpression* iterator = &amp;propertyAccessExpression;
315     while (true) {
316         chain.append(*iterator);
317         if (iterator-&gt;base().typeAnnotation().leftAddressSpace())
318             break;
319         ASSERT(!iterator-&gt;base().typeAnnotation().isRightValue());
320         iterator = &amp;downcast&lt;AST::PropertyAccessExpression&gt;(iterator-&gt;base());
321     }
322     auto leftExpression = iterator-&gt;takeBase();
323     AST::Expression&amp; innerLeftExpression = leftExpression;
324 
325     // Create &quot;p&quot; variable.
326     auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftExpression-&gt;codeLocation(), AST::Qualifiers(), AST::PointerType::create(leftExpression-&gt;codeLocation(), *leftExpression-&gt;typeAnnotation().leftAddressSpace(), leftExpression-&gt;resolvedType()), String(), nullptr, nullptr);
327 
328     // Create &quot;q&quot; and &quot;r&quot; variables.
329     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; intermediateVariables;
330     intermediateVariables.reserveInitialCapacity(chain.size() - 1);
331     for (size_t i = 1; i &lt; chain.size(); ++i) {
332         auto&amp; propertyAccessExpression = static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(chain[i]);
333         intermediateVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;propertyAccessExpression.resolvedType(), String(), nullptr, nullptr));
334     }
335 
336     // Consider a[foo()][b] = c;
337     // Naively, This would get expanded to:
338     //
339     // temp = operator[](a, foo());
340     // temp = operator[]=(temp, b, c);
341     // a = operator[]=(a, foo(), temp);
342     //
343     // However, if we did this, we would have to run foo() twice, which would be incorrect.
344     // Instead, we need to save foo() and b into more temporary variables.
345     // These temporary variables are parallel to &quot;chain&quot; above, with nullopt referring to a DotExpression (which doesn&#39;t have an index value to save to a variable).
346     //
347     // Instead, this gets expanded to:
348     //
349     // p = &amp;a;
350     // temp = foo();
351     // q = operator[](*p, temp);
352     // temp2 = b;
353     // q = operator[]=(q, temp2, c);
354     // *p = operator[]=(*p, temp, q);
355 
356     Vector&lt;Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&gt; indexVariables;
357     indexVariables.reserveInitialCapacity(chain.size());
358     for (AST::PropertyAccessExpression&amp; propertyAccessExpression : chain) {
359         if (!is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {
360             indexVariables.append(WTF::nullopt);
361             continue;
362         }
363         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);
364         indexVariables.uncheckedAppend(makeUniqueRef&lt;AST::VariableDeclaration&gt;(propertyAccessExpression.codeLocation(), AST::Qualifiers(), &amp;indexExpression.indexExpression().resolvedType(), String(), nullptr, nullptr));
365     }
366 
367     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
368 
369     // Step 1:
370     {
371         auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(leftExpression), AST::AddressEscapeMode::DoesNotEscape);
372         makePointerExpression-&gt;setType(AST::PointerType::create(innerLeftExpression.codeLocation(), *innerLeftExpression.typeAnnotation().leftAddressSpace(), innerLeftExpression.resolvedType()));
373         makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());
374 
375         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
376         ASSERT(pointerVariable-&gt;type());
377         variableReference-&gt;setType(*pointerVariable-&gt;type());
378         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
379 
380         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(innerLeftExpression.codeLocation(), WTFMove(variableReference), WTFMove(makePointerExpression));
381         assignmentExpression-&gt;setType(*pointerVariable-&gt;type());
382         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
383 
384         expressions.append(WTFMove(assignmentExpression));
385     }
386 
387     // Step 2:
388     AST::VariableDeclaration* previous = nullptr;
389     auto previousLeftValue = [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {
390         if (previous) {
391             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*previous));
392             ASSERT(previous-&gt;type());
393             variableReference-&gt;setType(*previous-&gt;type());
394             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
395             return variableReference;
396         }
397 
398         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
399         ASSERT(pointerVariable-&gt;type());
400         variableReference-&gt;setType(*pointerVariable-&gt;type());
401         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
402 
403         auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));
404         ASSERT(pointerVariable-&gt;type());
405         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());
406         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });
407         return dereferenceExpression;
408     };
409     auto appendIndexAssignment = [&amp;](AST::PropertyAccessExpression&amp; propertyAccessExpression, Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable) {
410         if (!indexVariable)
411             return;
412 
413         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);
414 
415         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(*indexVariable));
416         ASSERT(indexVariable-&gt;get().type());
417         variableReference-&gt;setType(*indexVariable-&gt;get().type());
418         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
419 
420         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), indexExpression.takeIndex());
421         assignmentExpression-&gt;setType(*indexVariable-&gt;get().type());
422         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
423 
424         expressions.append(WTFMove(assignmentExpression));
425     };
426     for (size_t i = chain.size(); --i; ) {
427         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];
428         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i - 1];
429         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];
430 
431         appendIndexAssignment(propertyAccessExpression, indexVariable);
432 
433         AST::FunctionDeclaration* relevantAnder = i == chain.size() - 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();
434         auto callExpression = getterCall(propertyAccessExpression, relevantAnder, previousLeftValue, indexVariable ? &amp;*indexVariable : nullptr);
435 
436         auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));
437         ASSERT(variableDeclaration.type());
438         variableReference-&gt;setType(*variableDeclaration.type());
439         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
440 
441         auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference), WTFMove(callExpression));
442         assignmentExpression-&gt;setType(*variableDeclaration.type());
443         assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
444 
445         expressions.append(WTFMove(assignmentExpression));
446 
447         previous = &amp;variableDeclaration;
448     }
449     appendIndexAssignment(chain[0], indexVariables[0]);
450     AST::FunctionDeclaration* relevantAnder = chain.size() == 1 ? propertyAccessExpression.anderFunction() : propertyAccessExpression.threadAnderFunction();
451     auto lastGetterCallExpression = getterCall(chain[0], relevantAnder, previousLeftValue, indexVariables[0] ? &amp;*(indexVariables[0]) : nullptr);
452 
453     // Step 3:
454     auto modificationResult = modification(WTFMove(lastGetterCallExpression));
455     for (size_t i = 0; i &lt; modificationResult.expressions.size(); ++i)
456         expressions.append(WTFMove(modificationResult.expressions[i]));
457 
458     // Step 4:
459     UniqueRef&lt;AST::Expression&gt; rightValue = WTFMove(modificationResult.result);
460     for (size_t i = 0; i &lt; chain.size() - 1; ++i) {
461         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[i];
462         AST::VariableDeclaration&amp; variableDeclaration = intermediateVariables[i];
463         Optional&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt;&amp; indexVariable = indexVariables[i];
464 
465         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.threadAnderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {
466             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));
467             ASSERT(variableDeclaration.type());
468             variableReference-&gt;setType(*variableDeclaration.type());
469             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
470             return variableReference;
471         }, indexVariable ? &amp;*indexVariable : nullptr);
472 
473         expressions.append(WTFMove(assignmentExpression));
474 
475         rightValue = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(variableDeclaration));
476         ASSERT(variableDeclaration.type());
477         rightValue-&gt;setType(*variableDeclaration.type());
478         rightValue-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
479     }
480 
481     // Step 5:
482     {
483         AST::PropertyAccessExpression&amp; propertyAccessExpression = chain[chain.size() - 1];
484         auto assignmentExpression = setterCall(propertyAccessExpression, propertyAccessExpression.anderFunction(), WTFMove(rightValue), [&amp;]() -&gt; UniqueRef&lt;AST::Expression&gt; {
485             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
486             ASSERT(pointerVariable-&gt;type());
487             variableReference-&gt;setType(*pointerVariable-&gt;type());
488             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
489 
490             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(propertyAccessExpression.codeLocation(), WTFMove(variableReference));
491             ASSERT(pointerVariable-&gt;type());
492             dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).elementType());
493             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(*pointerVariable-&gt;type()).addressSpace() });
494             return dereferenceExpression;
495         }, indexVariables[indexVariables.size() - 1] ? &amp;*(indexVariables[indexVariables.size() - 1]) : nullptr);
496 
497         expressions.append(WTFMove(assignmentExpression));
498     }
499 
500     Vector&lt;UniqueRef&lt;AST::VariableDeclaration&gt;&gt; variableDeclarations;
501     variableDeclarations.append(WTFMove(pointerVariable));
502     for (auto&amp; intermediateVariable : intermediateVariables)
503         variableDeclarations.append(WTFMove(intermediateVariable));
504     for (auto&amp; indexVariable : indexVariables) {
505         if (indexVariable)
506             variableDeclarations.append(WTFMove(*indexVariable));
507     }
508 
509     return { innerLeftExpression, WTFMove(expressions), WTFMove(variableDeclarations) };
510 }
511 
512 void PropertyResolver::visit(AST::AssignmentExpression&amp; assignmentExpression)
513 {
514     if (assignmentExpression.left().typeAnnotation().leftAddressSpace()) {
515         simplifyLeftValue(assignmentExpression.left());
516         checkErrorAndVisit(assignmentExpression.right());
517         return;
518     }
519     ASSERT(!assignmentExpression.left().typeAnnotation().isRightValue());
520 
521     Ref&lt;AST::UnnamedType&gt; type = assignmentExpression.right().resolvedType();
522 
523     checkErrorAndVisit(assignmentExpression.right());
524 
525     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(assignmentExpression.left()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp;) -&gt; ModificationResult {
526         return { Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt;(), assignmentExpression.takeRight() };
527     });
528 
529     simplifyLeftValue(modifyResult.innerLeftValue);
530 
531     auto location = assignmentExpression.codeLocation();
532     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(assignmentExpression, location, WTFMove(modifyResult.expressions));
533     commaExpression-&gt;setType(WTFMove(type));
534     commaExpression-&gt;setTypeAnnotation(AST::RightValue());
535 
536     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)
537         m_variableDeclarations.append(WTFMove(variableDeclaration));
538 }
539 
540 void PropertyResolver::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
541 {
542     checkErrorAndVisit(readModifyWriteExpression.newValueExpression());
543     if (hasError())
544         return;
545 
546     auto location = readModifyWriteExpression.codeLocation();
547     auto leftValueLocation = readModifyWriteExpression.leftValue().codeLocation();
548 
549     if (readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace()) {
550         // Consider a++;
551         // This would get transformed into:
552         //
553         // p = &amp;a;
554         // oldValue = *p;
555         // newValue = ...;
556         // *p = newValue;
557 
558         simplifyLeftValue(readModifyWriteExpression.leftValue());
559 
560         Ref&lt;AST::UnnamedType&gt; baseType = readModifyWriteExpression.leftValue().resolvedType();
561         Ref&lt;AST::UnnamedType&gt; pointerType = AST::PointerType::create(leftValueLocation, *readModifyWriteExpression.leftValue().typeAnnotation().leftAddressSpace(), baseType.copyRef());
562 
563         auto pointerVariable = makeUniqueRef&lt;AST::VariableDeclaration&gt;(leftValueLocation, AST::Qualifiers(), pointerType.copyRef(), String(), nullptr, nullptr);
564 
565         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
566 
567         {
568             auto makePointerExpression = makeUniqueRef&lt;AST::MakePointerExpression&gt;(leftValueLocation, readModifyWriteExpression.takeLeftValue(), AST::AddressEscapeMode::DoesNotEscape);
569             makePointerExpression-&gt;setType(pointerType.copyRef());
570             makePointerExpression-&gt;setTypeAnnotation(AST::RightValue());
571 
572             auto variableReference = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
573             variableReference-&gt;setType(pointerType.copyRef());
574             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
575 
576             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(makePointerExpression));
577             assignmentExpression-&gt;setType(pointerType.copyRef());
578             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
579 
580             expressions.append(WTFMove(assignmentExpression));
581         }
582 
583         {
584             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
585             variableReference1-&gt;setType(pointerType.copyRef());
586             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
587 
588             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));
589             dereferenceExpression-&gt;setType(baseType.copyRef());
590             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
591 
592             auto variableReference2 = readModifyWriteExpression.oldVariableReference();
593             variableReference2-&gt;setType(baseType.copyRef());
594             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
595 
596             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference2), WTFMove(dereferenceExpression));
597             assignmentExpression-&gt;setType(baseType.copyRef());
598             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
599 
600             expressions.append(WTFMove(assignmentExpression));
601         }
602 
603         {
604             auto variableReference = readModifyWriteExpression.newVariableReference();
605             variableReference-&gt;setType(baseType.copyRef());
606             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
607 
608             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();
609             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(variableReference), WTFMove(newValueExpression));
610             assignmentExpression-&gt;setType(baseType.copyRef());
611             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
612 
613             expressions.append(WTFMove(assignmentExpression));
614         }
615 
616         {
617             auto variableReference1 = makeUniqueRef&lt;AST::VariableReference&gt;(AST::VariableReference::wrap(pointerVariable));
618             variableReference1-&gt;setType(pointerType.copyRef());
619             variableReference1-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
620 
621             auto dereferenceExpression = makeUniqueRef&lt;AST::DereferenceExpression&gt;(location, WTFMove(variableReference1));
622             dereferenceExpression-&gt;setType(baseType.copyRef());
623             dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
624 
625             auto variableReference2 = readModifyWriteExpression.newVariableReference();
626             variableReference2-&gt;setType(baseType.copyRef());
627             variableReference2-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
628 
629             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(location, WTFMove(dereferenceExpression), WTFMove(variableReference2));
630             assignmentExpression-&gt;setType(baseType.copyRef());
631             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
632 
633             expressions.append(WTFMove(assignmentExpression));
634         }
635 
636         auto resultExpression = readModifyWriteExpression.takeResultExpression();
637         Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();
638         expressions.append(WTFMove(resultExpression));
639 
640         UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();
641         UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();
642 
643         auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(expressions));
644         commaExpression-&gt;setType(WTFMove(type));
645         commaExpression-&gt;setTypeAnnotation(AST::RightValue());
646 
647         m_variableDeclarations.append(WTFMove(pointerVariable));
648         m_variableDeclarations.append(WTFMove(oldVariableDeclaration));
649         m_variableDeclarations.append(WTFMove(newVariableDeclaration));
650         return;
651     }
652 
653     ASSERT(!readModifyWriteExpression.leftValue().typeAnnotation().isRightValue());
654     if (!is&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue())) {
655         setError(Error(&quot;Base of read modify write expression is a right-value.&quot;, readModifyWriteExpression.leftValue().codeLocation()));
656         return;
657     }
658     auto modifyResult = modify(downcast&lt;AST::PropertyAccessExpression&gt;(readModifyWriteExpression.leftValue()), [&amp;](UniqueRef&lt;AST::Expression&gt;&amp;&amp; lastGetterCallExpression) -&gt; ModificationResult {
659         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; expressions;
660 
661         {
662             auto variableReference = readModifyWriteExpression.oldVariableReference();
663             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());
664             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
665 
666             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(lastGetterCallExpression));
667             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());
668             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
669 
670             expressions.append(WTFMove(assignmentExpression));
671         }
672 
673         {
674             auto variableReference = readModifyWriteExpression.newVariableReference();
675             variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());
676             variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
677 
678             auto newValueExpression = readModifyWriteExpression.takeNewValueExpression();
679             auto assignmentExpression = makeUniqueRef&lt;AST::AssignmentExpression&gt;(leftValueLocation, WTFMove(variableReference), WTFMove(newValueExpression));
680             assignmentExpression-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());
681             assignmentExpression-&gt;setTypeAnnotation(AST::RightValue());
682 
683             expressions.append(WTFMove(assignmentExpression));
684         }
685 
686         auto variableReference = readModifyWriteExpression.newVariableReference();
687         variableReference-&gt;setType(readModifyWriteExpression.leftValue().resolvedType());
688         variableReference-&gt;setTypeAnnotation(AST::LeftValue { AST::AddressSpace::Thread }); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198169 Is this right?
689 
690         return { WTFMove(expressions),  WTFMove(variableReference) };
691     });
692 
693     simplifyLeftValue(modifyResult.innerLeftValue);
694 
695     auto resultExpression = readModifyWriteExpression.takeResultExpression();
696     Ref&lt;AST::UnnamedType&gt; type = resultExpression-&gt;resolvedType();
697     modifyResult.expressions.append(WTFMove(resultExpression));
698 
699     UniqueRef&lt;AST::VariableDeclaration&gt; oldVariableDeclaration = readModifyWriteExpression.takeOldValue();
700     UniqueRef&lt;AST::VariableDeclaration&gt; newVariableDeclaration = readModifyWriteExpression.takeNewValue();
701 
702     auto* commaExpression = AST::replaceWith&lt;AST::CommaExpression&gt;(readModifyWriteExpression, location, WTFMove(modifyResult.expressions));
703     commaExpression-&gt;setType(WTFMove(type));
704     commaExpression-&gt;setTypeAnnotation(AST::RightValue());
705 
706     for (auto&amp; variableDeclaration : modifyResult.variableDeclarations)
707         m_variableDeclarations.append(WTFMove(variableDeclaration));
708     m_variableDeclarations.append(WTFMove(oldVariableDeclaration));
709     m_variableDeclarations.append(WTFMove(newVariableDeclaration));
710 }
711 
712 static Optional&lt;AnderCallArgumentResult&gt; anderCallArgument(AST::PropertyAccessExpression&amp; propertyAccessExpression)
713 {
714     return anderCallArgument(propertyAccessExpression.baseReference(), propertyAccessExpression.anderFunction(), propertyAccessExpression.threadAnderFunction());
715 }
716 
717 void PropertyResolver::simplifyRightValue(AST::PropertyAccessExpression&amp; propertyAccessExpression)
718 {
719     auto location = propertyAccessExpression.codeLocation();
720 
721     checkErrorAndVisit(propertyAccessExpression.base());
722 
723     if (auto argument = anderCallArgument(propertyAccessExpression)) {
724         auto* anderFunction = argument-&gt;whichAnder == WhichAnder::ThreadAnder ? propertyAccessExpression.threadAnderFunction() : propertyAccessExpression.anderFunction();
725         ASSERT(anderFunction);
726         Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
727         arguments.append(WTFMove(argument-&gt;expression));
728         if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))
729             arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());
730         auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));
731         callExpression-&gt;setType(anderFunction-&gt;type());
732         callExpression-&gt;setTypeAnnotation(AST::RightValue());
733         callExpression-&gt;setFunction(*anderFunction);
734 
735         auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));
736         dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());
737         dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });
738 
739         if (auto&amp; variableDeclaration = argument-&gt;variableDeclaration)
740             m_variableDeclarations.append(WTFMove(*variableDeclaration));
741 
742         return;
743     }
744 
745     ASSERT(propertyAccessExpression.getterFunction());
746     auto&amp; getterFunction = *propertyAccessExpression.getterFunction();
747     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
748     arguments.append(propertyAccessExpression.takeBase());
749     AST::CallExpression* callExpression;
750     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression)) {
751         auto&amp; indexExpression = downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression);
752         arguments.append(indexExpression.takeIndex());
753         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(indexExpression, location, String(getterFunction.name()), WTFMove(arguments));
754     } else {
755         ASSERT(is&lt;AST::DotExpression&gt;(propertyAccessExpression));
756         auto&amp; dotExpression = downcast&lt;AST::DotExpression&gt;(propertyAccessExpression);
757         callExpression = AST::replaceWith&lt;AST::CallExpression&gt;(dotExpression, location, String(getterFunction.name()), WTFMove(arguments));
758     }
759     callExpression-&gt;setFunction(getterFunction);
760     callExpression-&gt;setType(getterFunction.type());
761     callExpression-&gt;setTypeAnnotation(AST::RightValue());
762 }
763 
764 class LeftValueSimplifier : public Visitor {
765 private:
766     void visit(AST::DotExpression&amp;) override;
767     void visit(AST::IndexExpression&amp;) override;
768     void visit(AST::DereferenceExpression&amp;) override;
769 
770     void finishVisiting(AST::PropertyAccessExpression&amp;);
771 };
772 
773 void LeftValueSimplifier::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression)
774 {
775     ASSERT(propertyAccessExpression.base().typeAnnotation().leftAddressSpace());
776     ASSERT(propertyAccessExpression.anderFunction());
777 
778     Visitor::visit(propertyAccessExpression.base());
779 
780     auto location = propertyAccessExpression.codeLocation();
781     auto* anderFunction = propertyAccessExpression.anderFunction();
782 
783     auto argument = anderCallArgument(propertyAccessExpression);
784     ASSERT(argument);
785     ASSERT(!argument-&gt;variableDeclaration);
786     ASSERT(argument-&gt;whichAnder == WhichAnder::Ander);
787 
788     Vector&lt;UniqueRef&lt;AST::Expression&gt;&gt; arguments;
789     arguments.append(WTFMove(argument-&gt;expression));
790     if (is&lt;AST::IndexExpression&gt;(propertyAccessExpression))
791         arguments.append(downcast&lt;AST::IndexExpression&gt;(propertyAccessExpression).takeIndex());
792     auto callExpression = makeUniqueRef&lt;AST::CallExpression&gt;(location, String(anderFunction-&gt;name()), WTFMove(arguments));
793     callExpression-&gt;setType(anderFunction-&gt;type());
794     callExpression-&gt;setTypeAnnotation(AST::RightValue());
795     callExpression-&gt;setFunction(*anderFunction);
796 
797     auto* dereferenceExpression = AST::replaceWith&lt;AST::DereferenceExpression&gt;(propertyAccessExpression, location, WTFMove(callExpression));
798     dereferenceExpression-&gt;setType(downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType());
799     dereferenceExpression-&gt;setTypeAnnotation(AST::LeftValue { downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).addressSpace() });
800 }
801 
802 void LeftValueSimplifier::visit(AST::DotExpression&amp; dotExpression)
803 {
804     Visitor::visit(dotExpression);
805     finishVisiting(dotExpression);
806 }
807 
808 void LeftValueSimplifier::visit(AST::IndexExpression&amp; indexExpression)
809 {
810     PropertyResolver().Visitor::visit(indexExpression.indexExpression());
811     finishVisiting(indexExpression);
812 }
813 
814 void LeftValueSimplifier::visit(AST::DereferenceExpression&amp; dereferenceExpression)
815 {
816     // Dereference expressions are the only expressions where the children might be more-right than we are.
817     // For example, a dereference expression may be a left value but its child may be a call expression which is a right value.
818     // LeftValueSimplifier doesn&#39;t handle right values, so we instead need to use PropertyResolver.
819     PropertyResolver().Visitor::visit(dereferenceExpression);
820 }
821 
822 void PropertyResolver::simplifyLeftValue(AST::Expression&amp; expression)
823 {
824     LeftValueSimplifier().Visitor::visit(expression);
825 }
826 
827 void resolveProperties(Program&amp; program)
828 {
829     PropertyResolver().Visitor::visit(program);
830 }
831 
832 } // namespace WHLSL
833 
834 } // namespace WebCore
835 
836 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>