<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/URL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2004, 2007-2008, 2011-2013, 2015-2016 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2012 Research In Motion Limited. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &lt;wtf/URL.h&gt;
  29 
  30 #include &quot;URLParser.h&quot;
  31 #include &lt;stdio.h&gt;
  32 #include &lt;unicode/uidna.h&gt;
  33 #include &lt;wtf/HashMap.h&gt;
  34 #include &lt;wtf/NeverDestroyed.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/UUID.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  40 #include &lt;wtf/text/StringHash.h&gt;
  41 #include &lt;wtf/text/TextStream.h&gt;
  42 
<a name="2" id="anc2"></a><span class="line-removed">  43 // FIXME: This file makes too much use of the + operator on String.</span>
<span class="line-removed">  44 // We either have to optimize that operator so it doesn&#39;t involve</span>
<span class="line-removed">  45 // so many allocations, or change this to use StringBuffer instead.</span>
<span class="line-removed">  46 </span>
<span class="line-removed">  47 </span>
  48 namespace WTF {
  49 
  50 typedef Vector&lt;char, 512&gt; CharBuffer;
  51 typedef Vector&lt;UChar, 512&gt; UCharBuffer;
  52 
  53 static const unsigned invalidPortNumber = 0xFFFF;
  54 
  55 // Copies the source to the destination, assuming all the source characters are
  56 // ASCII. The destination buffer must be large enough. Null characters are allowed
  57 // in the source string, and no attempt is made to null-terminate the result.
  58 static void copyASCII(const String&amp; string, char* dest)
  59 {
  60     if (string.isEmpty())
  61         return;
  62 
  63     if (string.is8Bit())
  64         memcpy(dest, string.characters8(), string.length());
  65     else {
  66         const UChar* src = string.characters16();
  67         size_t length = string.length();
  68         for (size_t i = 0; i &lt; length; i++)
  69             dest[i] = static_cast&lt;char&gt;(src[i]);
  70     }
  71 }
  72 
  73 void URL::invalidate()
  74 {
  75     m_isValid = false;
  76     m_protocolIsInHTTPFamily = false;
  77     m_cannotBeABaseURL = false;
  78     m_schemeEnd = 0;
  79     m_userStart = 0;
  80     m_userEnd = 0;
  81     m_passwordEnd = 0;
  82     m_hostEnd = 0;
  83     m_portLength = 0;
  84     m_pathEnd = 0;
  85     m_pathAfterLastSlash = 0;
  86     m_queryEnd = 0;
  87 }
  88 
  89 URL::URL(const URL&amp; base, const String&amp; relative, const URLTextEncoding* encoding)
  90 {
  91     URLParser parser(relative, base, encoding);
  92     *this = parser.result();
  93 }
  94 
  95 static bool shouldTrimFromURL(UChar c)
  96 {
  97     // Browsers ignore leading/trailing whitespace and control
  98     // characters from URLs.  Note that c is an *unsigned* char here
  99     // so this comparison should only catch control characters.
 100     return c &lt;= &#39; &#39;;
 101 }
 102 
 103 URL URL::isolatedCopy() const
 104 {
 105     URL result = *this;
 106     result.m_string = result.m_string.isolatedCopy();
 107     return result;
 108 }
 109 
 110 String URL::lastPathComponent() const
 111 {
 112     if (!hasPath())
 113         return String();
 114 
 115     unsigned end = m_pathEnd - 1;
 116     if (m_string[end] == &#39;/&#39;)
 117         --end;
 118 
 119     size_t start = m_string.reverseFind(&#39;/&#39;, end);
 120     if (start &lt; static_cast&lt;unsigned&gt;(m_hostEnd + m_portLength))
 121         return String();
 122     ++start;
 123 
 124     return m_string.substring(start, end - start + 1);
 125 }
 126 
 127 StringView URL::protocol() const
 128 {
 129     return StringView(m_string).substring(0, m_schemeEnd);
 130 }
 131 
 132 StringView URL::host() const
 133 {
 134     unsigned start = hostStart();
 135     return StringView(m_string).substring(start, m_hostEnd - start);
 136 }
 137 
 138 Optional&lt;uint16_t&gt; URL::port() const
 139 {
 140     if (!m_portLength)
 141         return WTF::nullopt;
 142 
 143     bool ok = false;
 144     unsigned number;
 145     if (m_string.is8Bit())
 146         number = charactersToUIntStrict(m_string.characters8() + m_hostEnd + 1, m_portLength - 1, &amp;ok);
 147     else
 148         number = charactersToUIntStrict(m_string.characters16() + m_hostEnd + 1, m_portLength - 1, &amp;ok);
 149     if (!ok || number &gt; std::numeric_limits&lt;uint16_t&gt;::max())
 150         return WTF::nullopt;
 151     return number;
 152 }
 153 
 154 String URL::hostAndPort() const
 155 {
 156     if (auto port = this-&gt;port())
 157         return makeString(host(), &#39;:&#39;, static_cast&lt;unsigned&gt;(port.value()));
 158     return host().toString();
 159 }
 160 
 161 String URL::protocolHostAndPort() const
 162 {
 163     String result = m_string.substring(0, m_hostEnd + m_portLength);
 164 
 165     if (m_passwordEnd - m_userStart &gt; 0) {
 166         const int allowForTrailingAtSign = 1;
 167         result.remove(m_userStart, m_passwordEnd - m_userStart + allowForTrailingAtSign);
 168     }
 169 
 170     return result;
 171 }
 172 
 173 static String decodeEscapeSequencesFromParsedURL(StringView input)
 174 {
 175     auto inputLength = input.length();
 176     if (!inputLength)
 177         return emptyString();
 178     Vector&lt;LChar&gt; percentDecoded;
 179     percentDecoded.reserveInitialCapacity(inputLength);
 180     for (unsigned i = 0; i &lt; inputLength; ++i) {
 181         if (input[i] == &#39;%&#39;
 182             &amp;&amp; inputLength &gt; 2
 183             &amp;&amp; i &lt; inputLength - 2
 184             &amp;&amp; isASCIIHexDigit(input[i + 1])
 185             &amp;&amp; isASCIIHexDigit(input[i + 2])) {
 186             percentDecoded.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
 187             i += 2;
 188         } else
 189             percentDecoded.uncheckedAppend(input[i]);
 190     }
 191     return String::fromUTF8(percentDecoded.data(), percentDecoded.size());
 192 }
 193 
 194 String URL::user() const
 195 {
 196     return decodeEscapeSequencesFromParsedURL(StringView(m_string).substring(m_userStart, m_userEnd - m_userStart));
 197 }
 198 
 199 String URL::pass() const
 200 {
 201     if (m_passwordEnd == m_userEnd)
 202         return String();
 203 
 204     return decodeEscapeSequencesFromParsedURL(StringView(m_string).substring(m_userEnd + 1, m_passwordEnd - m_userEnd - 1));
 205 }
 206 
 207 String URL::encodedUser() const
 208 {
 209     return m_string.substring(m_userStart, m_userEnd - m_userStart);
 210 }
 211 
 212 String URL::encodedPass() const
 213 {
 214     if (m_passwordEnd == m_userEnd)
 215         return String();
 216 
 217     return m_string.substring(m_userEnd + 1, m_passwordEnd - m_userEnd - 1);
 218 }
 219 
 220 String URL::fragmentIdentifier() const
 221 {
 222     if (!hasFragmentIdentifier())
 223         return String();
 224 
 225     return m_string.substring(m_queryEnd + 1);
 226 }
 227 
 228 bool URL::hasFragmentIdentifier() const
 229 {
 230     return m_isValid &amp;&amp; m_string.length() != m_queryEnd;
 231 }
 232 
 233 String URL::baseAsString() const
 234 {
 235     return m_string.left(m_pathAfterLastSlash);
 236 }
 237 
 238 #if !USE(CF) || PLATFORM(JAVA)
 239 
 240 String URL::fileSystemPath() const
 241 {
 242     if (!isValid() || !isLocalFile())
 243         return String();
 244 
 245     return decodeEscapeSequencesFromParsedURL(StringView(path()));
 246 }
 247 
 248 #endif
 249 
 250 #ifdef NDEBUG
 251 
 252 static inline void assertProtocolIsGood(StringView)
 253 {
 254 }
 255 
 256 #else
 257 
 258 static void assertProtocolIsGood(StringView protocol)
 259 {
 260     // FIXME: We probably don&#39;t need this function any more.
 261     // The isASCIIAlphaCaselessEqual function asserts that passed-in characters
 262     // are ones it can handle; the older code did not and relied on these checks.
 263     for (auto character : protocol.codeUnits()) {
 264         ASSERT(isASCII(character));
 265         ASSERT(character &gt; &#39; &#39;);
 266         ASSERT(!isASCIIUpper(character));
 267         ASSERT(toASCIILowerUnchecked(character) == character);
 268     }
 269 }
 270 
 271 #endif
 272 
 273 static Lock defaultPortForProtocolMapForTestingLock;
 274 
 275 using DefaultPortForProtocolMapForTesting = HashMap&lt;String, uint16_t&gt;;
 276 static DefaultPortForProtocolMapForTesting*&amp; defaultPortForProtocolMapForTesting()
 277 {
 278     static DefaultPortForProtocolMapForTesting* defaultPortForProtocolMap;
 279     return defaultPortForProtocolMap;
 280 }
 281 
 282 static DefaultPortForProtocolMapForTesting&amp; ensureDefaultPortForProtocolMapForTesting()
 283 {
 284     DefaultPortForProtocolMapForTesting*&amp; defaultPortForProtocolMap = defaultPortForProtocolMapForTesting();
 285     if (!defaultPortForProtocolMap)
 286         defaultPortForProtocolMap = new DefaultPortForProtocolMapForTesting;
 287     return *defaultPortForProtocolMap;
 288 }
 289 
 290 void registerDefaultPortForProtocolForTesting(uint16_t port, const String&amp; protocol)
 291 {
 292     auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 293     ensureDefaultPortForProtocolMapForTesting().add(protocol, port);
 294 }
 295 
 296 void clearDefaultPortForProtocolMapForTesting()
 297 {
 298     auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 299     if (auto* map = defaultPortForProtocolMapForTesting())
 300         map-&gt;clear();
 301 }
 302 
 303 Optional&lt;uint16_t&gt; defaultPortForProtocol(StringView protocol)
 304 {
 305     if (auto* overrideMap = defaultPortForProtocolMapForTesting()) {
 306         auto locker = holdLock(defaultPortForProtocolMapForTestingLock);
 307         ASSERT(overrideMap); // No need to null check again here since overrideMap cannot become null after being non-null.
 308         auto iterator = overrideMap-&gt;find(protocol.toStringWithoutCopying());
 309         if (iterator != overrideMap-&gt;end())
 310             return iterator-&gt;value;
 311     }
 312     return URLParser::defaultPortForProtocol(protocol);
 313 }
 314 
 315 bool isDefaultPortForProtocol(uint16_t port, StringView protocol)
 316 {
 317     return defaultPortForProtocol(protocol) == port;
 318 }
 319 
 320 bool URL::protocolIs(const char* protocol) const
 321 {
<a name="3" id="anc3"></a><span class="line-modified"> 322     assertProtocolIsGood(StringView(reinterpret_cast&lt;const LChar*&gt;(protocol), strlen(protocol)));</span>
 323 
 324     // JavaScript URLs are &quot;valid&quot; and should be executed even if URL decides they are invalid.
 325     // The free function protocolIsJavaScript() should be used instead.
 326     ASSERT(!equalLettersIgnoringASCIICase(StringView(protocol), &quot;javascript&quot;));
 327 
 328     if (!m_isValid)
 329         return false;
 330 
 331     // Do the comparison without making a new string object.
 332     for (unsigned i = 0; i &lt; m_schemeEnd; ++i) {
 333         if (!protocol[i] || !isASCIIAlphaCaselessEqual(m_string[i], protocol[i]))
 334             return false;
 335     }
 336     return !protocol[m_schemeEnd]; // We should have consumed all characters in the argument.
 337 }
 338 
 339 bool URL::protocolIs(StringView protocol) const
 340 {
 341     assertProtocolIsGood(protocol);
 342 
 343     if (!m_isValid)
 344         return false;
 345 
 346     if (m_schemeEnd != protocol.length())
 347         return false;
 348 
 349     // Do the comparison without making a new string object.
 350     for (unsigned i = 0; i &lt; m_schemeEnd; ++i) {
 351         if (!isASCIIAlphaCaselessEqual(m_string[i], protocol[i]))
 352             return false;
 353     }
 354     return true;
 355 }
 356 
 357 String URL::query() const
 358 {
 359     if (m_queryEnd == m_pathEnd)
 360         return String();
 361 
 362     return m_string.substring(m_pathEnd + 1, m_queryEnd - (m_pathEnd + 1));
 363 }
 364 
 365 String URL::path() const
 366 {
 367     unsigned portEnd = m_hostEnd + m_portLength;
 368     return m_string.substring(portEnd, m_pathEnd - portEnd);
 369 }
 370 
 371 bool URL::setProtocol(const String&amp; s)
 372 {
 373     // Firefox and IE remove everything after the first &#39;:&#39;.
 374     size_t separatorPosition = s.find(&#39;:&#39;);
 375     String newProtocol = s.substring(0, separatorPosition);
 376     auto canonicalized = URLParser::maybeCanonicalizeScheme(newProtocol);
 377     if (!canonicalized)
 378         return false;
 379 
 380     if (!m_isValid) {
 381         URLParser parser(makeString(*canonicalized, &quot;:&quot;, m_string));
 382         *this = parser.result();
 383         return true;
 384     }
 385 
 386     URLParser parser(makeString(*canonicalized, m_string.substring(m_schemeEnd)));
 387     *this = parser.result();
 388     return true;
 389 }
 390 
 391 static bool isAllASCII(StringView string)
 392 {
 393     if (string.is8Bit())
 394         return charactersAreAllASCII(string.characters8(), string.length());
 395     return charactersAreAllASCII(string.characters16(), string.length());
 396 }
 397 
 398 // Appends the punycoded hostname identified by the given string and length to
 399 // the output buffer. The result will not be null terminated.
 400 // Return value of false means error in encoding.
 401 static bool appendEncodedHostname(UCharBuffer&amp; buffer, StringView string)
 402 {
 403     // Needs to be big enough to hold an IDN-encoded name.
 404     // For host names bigger than this, we won&#39;t do IDN encoding, which is almost certainly OK.
 405     const unsigned hostnameBufferLength = 2048;
 406 
 407     if (string.length() &gt; hostnameBufferLength || isAllASCII(string)) {
 408         append(buffer, string);
 409         return true;
 410     }
 411 
 412     UChar hostnameBuffer[hostnameBufferLength];
 413     UErrorCode error = U_ZERO_ERROR;
 414     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
 415     int32_t numCharactersConverted = uidna_nameToASCII(&amp;URLParser::internationalDomainNameTranscoder(),
 416         string.upconvertedCharacters(), string.length(), hostnameBuffer, hostnameBufferLength, &amp;processingDetails, &amp;error);
 417 
 418     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
 419         buffer.append(hostnameBuffer, numCharactersConverted);
 420         return true;
 421     }
 422     return false;
 423 }
 424 
 425 unsigned URL::hostStart() const
 426 {
 427     return (m_passwordEnd == m_userStart) ? m_passwordEnd : m_passwordEnd + 1;
 428 }
 429 
 430 void URL::setHost(const String&amp; s)
 431 {
 432     if (!m_isValid)
 433         return;
 434 
 435     auto colonIndex = s.find(&#39;:&#39;);
 436     if (colonIndex != notFound)
 437         return;
 438 
 439     UCharBuffer encodedHostName;
 440     if (!appendEncodedHostname(encodedHostName, s))
 441         return;
 442 
 443     bool slashSlashNeeded = m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1);
 444 
 445     StringBuilder builder;
 446     builder.append(m_string.left(hostStart()));
 447     if (slashSlashNeeded)
 448         builder.appendLiteral(&quot;//&quot;);
 449     builder.append(StringView(encodedHostName.data(), encodedHostName.size()));
 450     builder.append(m_string.substring(m_hostEnd));
 451 
 452     URLParser parser(builder.toString());
 453     *this = parser.result();
 454 }
 455 
 456 void URL::removePort()
 457 {
 458     if (!m_portLength)
 459         return;
 460     URLParser parser(makeString(StringView(m_string).left(m_hostEnd), StringView(m_string).substring(m_hostEnd + m_portLength)));
 461     *this = parser.result();
 462 }
 463 
 464 void URL::setPort(unsigned short i)
 465 {
 466     if (!m_isValid)
 467         return;
 468 
 469     bool colonNeeded = !m_portLength;
 470     unsigned portStart = (colonNeeded ? m_hostEnd : m_hostEnd + 1);
 471 
 472     URLParser parser(makeString(StringView(m_string).left(portStart), (colonNeeded ? &quot;:&quot; : &quot;&quot;), static_cast&lt;unsigned&gt;(i), StringView(m_string).substring(m_hostEnd + m_portLength)));
 473     *this = parser.result();
 474 }
 475 
 476 void URL::setHostAndPort(const String&amp; hostAndPort)
 477 {
 478     if (!m_isValid)
 479         return;
 480 
 481     StringView hostName(hostAndPort);
 482     StringView port;
 483 
 484     auto colonIndex = hostName.find(&#39;:&#39;);
 485     if (colonIndex != notFound) {
 486         port = hostName.substring(colonIndex + 1);
 487         bool ok;
 488         int portInt = port.toIntStrict(ok);
 489         if (!ok || portInt &lt; 0)
 490             return;
 491         hostName = hostName.substring(0, colonIndex);
 492     }
 493 
 494     if (hostName.isEmpty())
 495         return;
 496 
 497     UCharBuffer encodedHostName;
 498     if (!appendEncodedHostname(encodedHostName, hostName))
 499         return;
 500 
 501     bool slashSlashNeeded = m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1);
 502 
 503     StringBuilder builder;
 504     builder.append(m_string.left(hostStart()));
 505     if (slashSlashNeeded)
 506         builder.appendLiteral(&quot;//&quot;);
 507     builder.append(StringView(encodedHostName.data(), encodedHostName.size()));
 508     if (!port.isEmpty()) {
 509         builder.appendLiteral(&quot;:&quot;);
 510         builder.append(port);
 511     }
 512     builder.append(StringView(m_string).substring(m_hostEnd + m_portLength));
 513 
 514     URLParser parser(builder.toString());
 515     *this = parser.result();
 516 }
 517 
 518 static String percentEncodeCharacters(const String&amp; input, bool(*shouldEncode)(UChar))
 519 {
 520     auto encode = [shouldEncode] (const String&amp; input) {
 521         CString utf8 = input.utf8();
 522         auto* data = utf8.data();
 523         StringBuilder builder;
 524         auto length = utf8.length();
 525         for (unsigned j = 0; j &lt; length; j++) {
 526             auto c = data[j];
 527             if (shouldEncode(c)) {
 528                 builder.append(&#39;%&#39;);
 529                 builder.append(upperNibbleToASCIIHexDigit(c));
 530                 builder.append(lowerNibbleToASCIIHexDigit(c));
 531             } else
 532                 builder.append(c);
 533         }
 534         return builder.toString();
 535     };
 536 
 537     for (size_t i = 0; i &lt; input.length(); ++i) {
 538         if (UNLIKELY(shouldEncode(input[i])))
 539             return encode(input);
 540     }
 541     return input;
 542 }
 543 
 544 void URL::setUser(const String&amp; user)
 545 {
 546     if (!m_isValid)
 547         return;
 548 
 549     // FIXME: Non-ASCII characters must be encoded and escaped to match parse() expectations,
 550     // and to avoid changing more than just the user login.
 551 
 552     unsigned end = m_userEnd;
 553     if (!user.isEmpty()) {
 554         String u = percentEncodeCharacters(user, URLParser::isInUserInfoEncodeSet);
 555         if (m_userStart == static_cast&lt;unsigned&gt;(m_schemeEnd + 1))
 556             u = &quot;//&quot; + u;
 557         // Add &#39;@&#39; if we didn&#39;t have one before.
 558         if (end == m_hostEnd || (end == m_passwordEnd &amp;&amp; m_string[end] != &#39;@&#39;))
 559             u.append(&#39;@&#39;);
 560         URLParser parser(makeString(StringView(m_string).left(m_userStart), u, StringView(m_string).substring(end)));
 561         *this = parser.result();
 562     } else {
 563         // Remove &#39;@&#39; if we now have neither user nor password.
 564         if (m_userEnd == m_passwordEnd &amp;&amp; end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 565             end += 1;
 566         // We don&#39;t want to parse in the extremely common case where we are not going to make a change.
 567         if (m_userStart != end) {
 568             URLParser parser(makeString(StringView(m_string).left(m_userStart), StringView(m_string).substring(end)));
 569             *this = parser.result();
 570         }
 571     }
 572 }
 573 
 574 void URL::setPass(const String&amp; password)
 575 {
 576     if (!m_isValid)
 577         return;
 578 
 579     unsigned end = m_passwordEnd;
 580     if (!password.isEmpty()) {
 581         String p = &quot;:&quot; + percentEncodeCharacters(password, URLParser::isInUserInfoEncodeSet) + &quot;@&quot;;
 582         if (m_userEnd == static_cast&lt;unsigned&gt;(m_schemeEnd + 1))
 583             p = &quot;//&quot; + p;
 584         // Eat the existing &#39;@&#39; since we are going to add our own.
 585         if (end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 586             end += 1;
 587         URLParser parser(makeString(StringView(m_string).left(m_userEnd), p, StringView(m_string).substring(end)));
 588         *this = parser.result();
 589     } else {
 590         // Remove &#39;@&#39; if we now have neither user nor password.
 591         if (m_userStart == m_userEnd &amp;&amp; end != m_hostEnd &amp;&amp; m_string[end] == &#39;@&#39;)
 592             end += 1;
 593         // We don&#39;t want to parse in the extremely common case where we are not going to make a change.
 594         if (m_userEnd != end) {
 595             URLParser parser(makeString(StringView(m_string).left(m_userEnd), StringView(m_string).substring(end)));
 596             *this = parser.result();
 597         }
 598     }
 599 }
 600 
 601 void URL::setFragmentIdentifier(StringView identifier)
 602 {
 603     if (!m_isValid)
 604         return;
 605 
 606     // FIXME: Optimize the case where the identifier already happens to be equal to what was passed?
 607     // FIXME: Is it correct to do this without encoding and escaping non-ASCII characters?
 608     *this = URLParser { makeString(StringView { m_string }.substring(0, m_queryEnd), &#39;#&#39;, identifier) }.result();
 609 }
 610 
 611 void URL::removeFragmentIdentifier()
 612 {
 613     if (!m_isValid) {
 614         ASSERT(!m_queryEnd);
 615         return;
 616     }
 617     if (m_isValid &amp;&amp; m_string.length() &gt; m_queryEnd)
 618         m_string = m_string.left(m_queryEnd);
 619 }
 620 
 621 void URL::removeQueryAndFragmentIdentifier()
 622 {
 623     if (!m_isValid)
 624         return;
 625 
 626     m_string = m_string.left(m_pathEnd);
 627     m_queryEnd = m_pathEnd;
 628 }
 629 
 630 void URL::setQuery(const String&amp; query)
 631 {
 632     if (!m_isValid)
 633         return;
 634 
 635     // FIXME: &#39;#&#39; and non-ASCII characters must be encoded and escaped.
 636     // Usually, the query is encoded using document encoding, not UTF-8, but we don&#39;t have
 637     // access to the document in this function.
 638     // https://webkit.org/b/161176
 639     if ((query.isEmpty() || query[0] != &#39;?&#39;) &amp;&amp; !query.isNull()) {
 640         URLParser parser(makeString(StringView(m_string).left(m_pathEnd), &quot;?&quot;, query, StringView(m_string).substring(m_queryEnd)));
 641         *this = parser.result();
 642     } else {
 643         URLParser parser(makeString(StringView(m_string).left(m_pathEnd), query, StringView(m_string).substring(m_queryEnd)));
 644         *this = parser.result();
 645     }
 646 
 647 }
 648 
 649 void URL::setPath(const String&amp; s)
 650 {
 651     if (!m_isValid)
 652         return;
 653 
 654     String path = s;
 655     if (path.isEmpty() || path[0] != &#39;/&#39;)
 656         path = &quot;/&quot; + path;
 657 
 658     auto questionMarkOrNumberSign = [] (UChar character) {
 659         return character == &#39;?&#39; || character == &#39;#&#39;;
 660     };
 661     URLParser parser(makeString(StringView(m_string).left(m_hostEnd + m_portLength), percentEncodeCharacters(path, questionMarkOrNumberSign), StringView(m_string).substring(m_pathEnd)));
 662     *this = parser.result();
 663 }
 664 
 665 bool equalIgnoringFragmentIdentifier(const URL&amp; a, const URL&amp; b)
 666 {
 667     if (a.m_queryEnd != b.m_queryEnd)
 668         return false;
 669     unsigned queryLength = a.m_queryEnd;
 670     for (unsigned i = 0; i &lt; queryLength; ++i)
 671         if (a.string()[i] != b.string()[i])
 672             return false;
 673     return true;
 674 }
 675 
 676 bool equalIgnoringQueryAndFragment(const URL&amp; a, const URL&amp; b)
 677 {
 678     if (a.pathEnd() != b.pathEnd())
 679         return false;
 680     unsigned pathEnd = a.pathEnd();
 681     for (unsigned i = 0; i &lt; pathEnd; ++i) {
 682         if (a.string()[i] != b.string()[i])
 683             return false;
 684     }
 685     return true;
 686 }
 687 
 688 bool protocolHostAndPortAreEqual(const URL&amp; a, const URL&amp; b)
 689 {
 690     if (a.m_schemeEnd != b.m_schemeEnd)
 691         return false;
 692 
 693     unsigned hostStartA = a.hostStart();
 694     unsigned hostLengthA = a.m_hostEnd - hostStartA;
 695     unsigned hostStartB = b.hostStart();
 696     unsigned hostLengthB = b.m_hostEnd - b.hostStart();
 697     if (hostLengthA != hostLengthB)
 698         return false;
 699 
 700     // Check the scheme
 701     for (unsigned i = 0; i &lt; a.m_schemeEnd; ++i) {
 702         if (a.string()[i] != b.string()[i])
 703             return false;
 704     }
 705 
 706     // And the host
 707     for (unsigned i = 0; i &lt; hostLengthA; ++i) {
 708         if (a.string()[hostStartA + i] != b.string()[hostStartB + i])
 709             return false;
 710     }
 711 
 712     if (a.port() != b.port())
 713         return false;
 714 
 715     return true;
 716 }
 717 
 718 bool hostsAreEqual(const URL&amp; a, const URL&amp; b)
 719 {
 720     unsigned hostStartA = a.hostStart();
 721     unsigned hostLengthA = a.m_hostEnd - hostStartA;
 722     unsigned hostStartB = b.hostStart();
 723     unsigned hostLengthB = b.m_hostEnd - hostStartB;
 724     if (hostLengthA != hostLengthB)
 725         return false;
 726 
 727     for (unsigned i = 0; i &lt; hostLengthA; ++i) {
 728         if (a.string()[hostStartA + i] != b.string()[hostStartB + i])
 729             return false;
 730     }
 731 
 732     return true;
 733 }
 734 
 735 bool URL::isMatchingDomain(const String&amp; domain) const
 736 {
 737     if (isNull())
 738         return false;
 739 
 740     if (domain.isEmpty())
 741         return true;
 742 
 743     if (!protocolIsInHTTPFamily())
 744         return false;
 745 
 746     auto host = this-&gt;host();
 747     if (!host.endsWith(domain))
 748         return false;
 749 
 750     return host.length() == domain.length() || host[host.length() - domain.length() - 1] == &#39;.&#39;;
 751 }
 752 
 753 String encodeWithURLEscapeSequences(const String&amp; input)
 754 {
 755     return percentEncodeCharacters(input, URLParser::isInUserInfoEncodeSet);
 756 }
 757 
 758 bool URL::isHierarchical() const
 759 {
 760     if (!m_isValid)
 761         return false;
 762     ASSERT(m_string[m_schemeEnd] == &#39;:&#39;);
 763     return m_string[m_schemeEnd + 1] == &#39;/&#39;;
 764 }
 765 
 766 void URL::copyToBuffer(Vector&lt;char, 512&gt;&amp; buffer) const
 767 {
 768     // FIXME: This throws away the high bytes of all the characters in the string!
 769     // That&#39;s fine for a valid URL, which is all ASCII, but not for invalid URLs.
 770     buffer.resize(m_string.length());
 771     copyASCII(m_string, buffer.data());
 772 }
 773 
 774 template&lt;typename StringClass&gt;
 775 bool protocolIsInternal(const StringClass&amp; url, const char* protocol)
 776 {
 777     // Do the comparison without making a new string object.
<a name="4" id="anc4"></a><span class="line-modified"> 778     assertProtocolIsGood(StringView(reinterpret_cast&lt;const LChar*&gt;(protocol), strlen(protocol)));</span>
 779     bool isLeading = true;
 780     for (unsigned i = 0, j = 0; url[i]; ++i) {
 781         // Skip leading whitespace and control characters.
 782         if (isLeading &amp;&amp; shouldTrimFromURL(url[i]))
 783             continue;
 784         isLeading = false;
 785 
 786         // Skip any tabs and newlines.
 787         if (url[i] == &#39;\t&#39; || url[i] == &#39;\r&#39; || url[i] == &#39;\n&#39;)
 788             continue;
 789 
 790         if (!protocol[j])
 791             return url[i] == &#39;:&#39;;
 792         if (!isASCIIAlphaCaselessEqual(url[i], protocol[j]))
 793             return false;
 794 
 795         ++j;
 796     }
 797 
 798     return false;
 799 }
 800 
 801 bool protocolIs(const String&amp; url, const char* protocol)
 802 {
 803     return protocolIsInternal(url, protocol);
 804 }
 805 
 806 inline bool URL::protocolIs(const String&amp; string, const char* protocol)
 807 {
 808     return WTF::protocolIsInternal(string, protocol);
 809 }
 810 
 811 #ifndef NDEBUG
 812 
 813 void URL::print() const
 814 {
 815     printf(&quot;%s\n&quot;, m_string.utf8().data());
 816 }
 817 
 818 #endif
 819 
 820 String URL::strippedForUseAsReferrer() const
 821 {
 822     URL referrer(*this);
 823     referrer.setUser(String());
 824     referrer.setPass(String());
 825     referrer.removeFragmentIdentifier();
 826     return referrer.string();
 827 }
 828 
 829 bool URL::isLocalFile() const
 830 {
 831     // Including feed here might be a bad idea since drag and drop uses this check
 832     // and including feed would allow feeds to potentially let someone&#39;s blog
 833     // read the contents of the clipboard on a drag, even without a drop.
 834     // Likewise with using the FrameLoader::shouldTreatURLAsLocal() function.
 835     return protocolIs(&quot;file&quot;);
 836 }
 837 
 838 bool protocolIsJavaScript(const String&amp; url)
 839 {
 840     return protocolIsInternal(url, &quot;javascript&quot;);
 841 }
 842 
 843 bool protocolIsJavaScript(StringView url)
 844 {
 845     return protocolIsInternal(url, &quot;javascript&quot;);
 846 }
 847 
 848 bool protocolIsInHTTPFamily(const String&amp; url)
 849 {
 850     auto length = url.length();
 851     // Do the comparison without making a new string object.
 852     return length &gt;= 5
 853         &amp;&amp; isASCIIAlphaCaselessEqual(url[0], &#39;h&#39;)
 854         &amp;&amp; isASCIIAlphaCaselessEqual(url[1], &#39;t&#39;)
 855         &amp;&amp; isASCIIAlphaCaselessEqual(url[2], &#39;t&#39;)
 856         &amp;&amp; isASCIIAlphaCaselessEqual(url[3], &#39;p&#39;)
 857         &amp;&amp; (url[4] == &#39;:&#39; || (isASCIIAlphaCaselessEqual(url[4], &#39;s&#39;) &amp;&amp; length &gt;= 6 &amp;&amp; url[5] == &#39;:&#39;));
 858 }
 859 
 860 const URL&amp; blankURL()
 861 {
 862     static NeverDestroyed&lt;URL&gt; staticBlankURL(URL(), &quot;about:blank&quot;);
 863     return staticBlankURL;
 864 }
 865 
 866 bool URL::protocolIsAbout() const
 867 {
 868     return protocolIs(&quot;about&quot;);
 869 }
 870 
 871 bool portAllowed(const URL&amp; url)
 872 {
 873     Optional&lt;uint16_t&gt; port = url.port();
 874 
 875     // Since most URLs don&#39;t have a port, return early for the &quot;no port&quot; case.
 876     if (!port)
 877         return true;
 878 
 879     // This blocked port list matches the port blocking that Mozilla implements.
 880     // See http://www.mozilla.org/projects/netlib/PortBanning.html for more information.
 881     static const uint16_t blockedPortList[] = {
 882         1,    // tcpmux
 883         7,    // echo
 884         9,    // discard
 885         11,   // systat
 886         13,   // daytime
 887         15,   // netstat
 888         17,   // qotd
 889         19,   // chargen
 890         20,   // FTP-data
 891         21,   // FTP-control
 892         22,   // SSH
 893         23,   // telnet
 894         25,   // SMTP
 895         37,   // time
 896         42,   // name
 897         43,   // nicname
 898         53,   // domain
 899         77,   // priv-rjs
 900         79,   // finger
 901         87,   // ttylink
 902         95,   // supdup
 903         101,  // hostriame
 904         102,  // iso-tsap
 905         103,  // gppitnp
 906         104,  // acr-nema
 907         109,  // POP2
 908         110,  // POP3
 909         111,  // sunrpc
 910         113,  // auth
 911         115,  // SFTP
 912         117,  // uucp-path
 913         119,  // nntp
 914         123,  // NTP
 915         135,  // loc-srv / epmap
 916         139,  // netbios
 917         143,  // IMAP2
 918         179,  // BGP
 919         389,  // LDAP
 920         427,  // SLP (Also used by Apple Filing Protocol)
 921         465,  // SMTP+SSL
 922         512,  // print / exec
 923         513,  // login
 924         514,  // shell
 925         515,  // printer
 926         526,  // tempo
 927         530,  // courier
 928         531,  // Chat
 929         532,  // netnews
 930         540,  // UUCP
 931         548,  // afpovertcp [Apple addition]
 932         556,  // remotefs
 933         563,  // NNTP+SSL
 934         587,  // ESMTP
 935         601,  // syslog-conn
 936         636,  // LDAP+SSL
 937         993,  // IMAP+SSL
 938         995,  // POP3+SSL
 939         2049, // NFS
 940         3659, // apple-sasl / PasswordServer [Apple addition]
 941         4045, // lockd
 942         4190, // ManageSieve [Apple addition]
 943         6000, // X11
 944         6665, // Alternate IRC [Apple addition]
 945         6666, // Alternate IRC [Apple addition]
 946         6667, // Standard IRC [Apple addition]
 947         6668, // Alternate IRC [Apple addition]
 948         6669, // Alternate IRC [Apple addition]
 949         6679, // Alternate IRC SSL [Apple addition]
 950         6697, // IRC+SSL [Apple addition]
 951         invalidPortNumber, // Used to block all invalid port numbers
 952     };
 953 
 954     // If the port is not in the blocked port list, allow it.
 955     ASSERT(std::is_sorted(std::begin(blockedPortList), std::end(blockedPortList)));
 956     if (!std::binary_search(std::begin(blockedPortList), std::end(blockedPortList), port.value()))
 957         return true;
 958 
 959     // Allow ports 21 and 22 for FTP URLs, as Mozilla does.
 960     if ((port.value() == 21 || port.value() == 22) &amp;&amp; url.protocolIs(&quot;ftp&quot;))
 961         return true;
 962 
 963     // Allow any port number in a file URL, since the port number is ignored.
 964     if (url.protocolIs(&quot;file&quot;))
 965         return true;
 966 
 967     return false;
 968 }
 969 
 970 String mimeTypeFromDataURL(const String&amp; url)
 971 {
 972     ASSERT(protocolIsInternal(url, &quot;data&quot;));
 973 
 974     // FIXME: What&#39;s the right behavior when the URL has a comma first, but a semicolon later?
 975     // Currently this code will break at the semicolon in that case. Not sure that&#39;s correct.
 976     auto index = url.find(&#39;;&#39;, 5);
 977     if (index == notFound)
 978         index = url.find(&#39;,&#39;, 5);
 979     if (index == notFound) {
 980         // FIXME: There was an old comment here that made it sound like this should be returning text/plain.
 981         // But we have been returning empty string here for some time, so not changing its behavior at this time.
 982         return emptyString();
 983     }
 984     if (index == 5)
 985         return &quot;text/plain&quot;_s;
 986     ASSERT(index &gt;= 5);
 987     return url.substring(5, index - 5).convertToASCIILowercase();
 988 }
 989 
 990 String URL::stringCenterEllipsizedToLength(unsigned length) const
 991 {
 992     if (string().length() &lt;= length)
 993         return string();
 994 
 995     return string().left(length / 2 - 1) + &quot;...&quot; + string().right(length / 2 - 2);
 996 }
 997 
 998 URL URL::fakeURLWithRelativePart(const String&amp; relativePart)
 999 {
1000     return URL(URL(), &quot;webkit-fake-url://&quot; + createCanonicalUUIDString() + &#39;/&#39; + relativePart);
1001 }
1002 
1003 URL URL::fileURLWithFileSystemPath(const String&amp; filePath)
1004 {
1005     return URL(URL(), &quot;file:///&quot; + filePath);
1006 }
1007 
1008 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const URL&amp; url)
1009 {
1010     ts &lt;&lt; url.string();
1011     return ts;
1012 }
1013 
1014 #if !PLATFORM(COCOA) &amp;&amp; !USE(SOUP)
1015 static bool isIPv4Address(StringView string)
1016 {
1017     auto count = 0;
1018 
1019     for (const auto octet : string.splitAllowingEmptyEntries(&#39;.&#39;)) {
1020         if (count &gt;= 4)
1021             return false;
1022 
1023         const auto length = octet.length();
1024         if (!length || length &gt; 3)
1025             return false;
1026 
1027         auto value = 0;
1028         for (auto i = 0u; i &lt; length; ++i) {
1029             const auto digit = octet[i];
1030 
1031             // Prohibit leading zeroes.
1032             if (digit &gt; &#39;9&#39; || digit &lt; (!i &amp;&amp; length &gt; 1 ? &#39;1&#39; : &#39;0&#39;))
1033                 return false;
1034 
1035             value = 10 * value + (digit - &#39;0&#39;);
1036         }
1037 
1038         if (value &gt; 255)
1039             return false;
1040 
1041         count++;
1042     }
1043 
1044     return (count == 4);
1045 }
1046 
1047 static bool isIPv6Address(StringView string)
1048 {
1049     enum SkipState { None, WillSkip, Skipping, Skipped, Final };
1050     auto skipState = None;
1051     auto count = 0;
1052 
1053     for (const auto hextet : string.splitAllowingEmptyEntries(&#39;:&#39;)) {
1054         if (count &gt;= 8 || skipState == Final)
1055             return false;
1056 
1057         const auto length = hextet.length();
1058         if (!length) {
1059             // :: may be used anywhere to skip 1 to 8 hextets, but only once.
1060             if (skipState == Skipped)
1061                 return false;
1062 
1063             if (skipState == None)
1064                 skipState = !count ? WillSkip : Skipping;
1065             else if (skipState == WillSkip)
1066                 skipState = Skipping;
1067             else
1068                 skipState = Final;
1069             continue;
1070         }
1071 
1072         if (skipState == WillSkip)
1073             return false;
1074 
1075         if (skipState == Skipping)
1076             skipState = Skipped;
1077 
1078         if (length &gt; 4) {
1079             // An IPv4 address may be used in place of the final two hextets.
1080             if ((skipState == None &amp;&amp; count != 6) || (skipState == Skipped &amp;&amp; count &gt;= 6) || !isIPv4Address(hextet))
1081                 return false;
1082 
1083             skipState = Final;
1084             continue;
1085         }
1086 
1087         for (const auto codeUnit : hextet.codeUnits()) {
1088             // IPv6 allows leading zeroes.
1089             if (!isASCIIHexDigit(codeUnit))
1090                 return false;
1091         }
1092 
1093         count++;
1094     }
1095 
1096     return (count == 8 &amp;&amp; skipState == None) || skipState == Skipped || skipState == Final;
1097 }
1098 
1099 bool URL::hostIsIPAddress(StringView host)
1100 {
1101     if (host.find(&#39;:&#39;) == notFound)
1102         return isIPv4Address(host);
1103 
1104     return isIPv6Address(host);
1105 }
1106 #endif
1107 
1108 } // namespace WTF
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>