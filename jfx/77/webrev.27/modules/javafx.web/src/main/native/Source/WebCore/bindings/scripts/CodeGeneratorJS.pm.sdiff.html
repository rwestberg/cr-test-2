<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CodeGenerator.pm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
<span class="line-modified"> 603     push(@arguments, &quot;propertyNameToAtomicString(propertyName)&quot;);</span>
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
</pre>
<hr />
<pre>
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
<span class="line-modified"> 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);</span>
 731         $didGeneratePropertyName = 1;
 732     };
 733     



 734     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);
 735     push(@$outputArray, &quot;{\n&quot;);



 736     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 737     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 738     
<span class="line-removed"> 739     my $namedGetterOperation = GetNamedGetterOperation($interface);</span>
<span class="line-removed"> 740     my $indexedGetterOperation = GetIndexedGetterOperation($interface);</span>
<span class="line-removed"> 741     </span>
 742     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 743         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
 744     }
 745     
 746     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 747     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 748     
 749     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 750     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 751     
 752     # 1. If O supports indexed properties and P is an array index property name, then:
 753     if ($indexedGetterOperation) {
 754         # 1.1. Let index be the result of calling ToUint32(P).
 755         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 756         
 757         # 1.2. If index is a supported property index, then:
 758         # FIXME: This should support non-contiguous indices.
 759         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 760         
 761         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 762         
 763         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
</pre>
<hr />
<pre>
 819     }
 820 
 821     # 3. Return OrdinaryGetOwnProperty(O, P).
 822     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 823     
 824     push(@$outputArray, &quot;}\n\n&quot;);
 825 }
 826 
 827 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 828 sub GenerateGetOwnPropertyNames
 829 {
 830     my ($outputArray, $interface, $className) = @_;
 831     
 832     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 833     
 834     my $namedGetterOperation = GetNamedGetterOperation($interface);
 835     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 836     
 837     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 838     push(@$outputArray, &quot;{\n&quot;);



 839     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 840     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 841     
 842     # 1. If the object supports indexed properties, then the object’s supported
 843     #    property indices are enumerated first, in numerical order.
 844     # FIXME: This should support non-contiguous indices.
 845     if ($indexedGetterOperation) {
 846         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
<span class="line-modified"> 847         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(state, i));\n&quot;);</span>
 848     }
 849 
 850     # 2. If the object supports named properties and doesn’t implement an interface
 851     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 852     #    object’s supported property names that are visible according to the named
 853     #    property visibility algorithm are enumerated next, in the order given in
 854     #    the definition of the set of supported property names.
 855     if ($namedGetterOperation) {
 856         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 857             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<span class="line-modified"> 858             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(state, propertyName));\n&quot;);</span>
 859         } else {
 860             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 861             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<span class="line-modified"> 862             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(state, propertyName));\n&quot;);</span>
 863             push(@$outputArray, &quot;    }\n&quot;);
 864         }
 865     }
 866     
 867     # 3. Finally, any enumerable own properties or properties from the object’s
 868     #    prototype chain are then enumerated, in no defined order.
 869     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);
 870     push(@$outputArray, &quot;}\n\n&quot;);
 871 }
 872 
 873 # https://heycam.github.io/webidl/#invoke-indexed-setter
 874 sub GenerateInvokeIndexedPropertySetter
 875 {
 876     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 877     
 878     # The second argument of the indexed setter operation is the argument being converted.
 879     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 880     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 881     
 882     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
</pre>
<hr />
<pre>
 989     }
 990 
 991     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 992     push(@$outputArray, &quot;}\n\n&quot;);
 993 }
 994 
 995 sub GeneratePutByIndex
 996 {
 997     my ($outputArray, $interface, $className) = @_;
 998     
 999     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1000 
1001     my $namedSetterOperation = GetNamedSetterOperation($interface);
1002     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1003     
1004     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1005     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1006     
1007     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1008     push(@$outputArray, &quot;{\n&quot;);



1009     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1010     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1011 
1012     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1013         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1014     if ($namedSetterOperation) {
1015         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1016     }
1017     if ($indexedSetterOperation) {
1018         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1019     }
1020     
<span class="line-modified">1021     if ($indexedSetterOperation ) {</span>
1022         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1023         
1024         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1025         
1026         push(@$outputArray, &quot;        return true;\n&quot;);
1027         push(@$outputArray, &quot;    }\n\n&quot;);
1028     }
1029     
1030     if ($namedSetterOperation) {
<span class="line-modified">1031         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);</span>
1032                 
1033         my $additionalIndent = &quot;&quot;;
1034         if (!$overrideBuiltins) {
1035             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified">1036             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);</span>
1037             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
1038             $additionalIndent .= &quot;    &quot;;
1039         }
1040         
1041         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1042         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1043             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1044             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1045         }
1046         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1047         
1048         if (!$overrideBuiltins) {
1049             push(@$outputArray, &quot;    }\n\n&quot;);
1050         }
1051     }
1052 
1053     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1054     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1055         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified">1056         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);</span>
1057         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1058         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1059         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
1060         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1061     }
1062 
1063     if (!$ellidesCallsToBase) {
1064         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1065     }
1066     
1067     push(@$outputArray, &quot;}\n\n&quot;);
1068 }
1069 
1070 sub GenerateIsUnforgeablePropertyName
1071 {
1072     my ($outputArray, $interface) = @_;
1073     
1074     my @unforgeablePropertyNames = ();
1075     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1076         next if $property-&gt;isStatic;
</pre>
<hr />
<pre>
1324     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1325     # for the deletePropertyByIndex override hook.
1326 
1327     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);
1328     push(@$outputArray, &quot;{\n&quot;);
1329 
1330     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1331     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1332 
1333     # 1. If O supports indexed properties and P is an array index property name, then:
1334     #    1. Let index be the result of calling ToUint32(P).
1335     #    2. If index is not a supported property index, then return true.
1336     #    3. Return false.
1337 
1338     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1339     #       is all that needs to be done, no need to generate the .
1340 
1341     if (GetIndexedGetterOperation($interface)) {
1342         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1343     } else {
<span class="line-modified">1344         push(@$outputArray, &quot;    auto propertyName = Identifier::from(state, index);\n&quot;);</span>

1345 
1346         # GenerateDeletePropertyCommon implements step 2.
1347         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1348 
1349         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1350         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1351         
1352         # 3. If O has an own property with name P, then:
1353         #    1. If the property is not configurable, then return false.
1354         #    2. Otherwise, remove the property from O.
1355         # 3. Return true.
1356         
1357         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);
1358     }
1359 
1360     push(@$outputArray, &quot;}\n\n&quot;);
1361 }
1362 
1363 
1364 sub GenerateNamedDeleterDefinition
</pre>
<hr />
<pre>
1688         $interfaceExposures = [$interfaceExposures];
1689     }
1690 
1691     foreach my $interfaceExposure (@$interfaceExposures) {
1692         return 0 unless exists $contextExposureSet{$interfaceExposure};
1693     }
1694 
1695     return 1;
1696 }
1697 
1698 sub NeedsRuntimeCheck
1699 {
1700     my ($interface, $context) = @_;
1701 
1702     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1703         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1704         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1705     }
1706 
1707     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}

1708         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1709         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1710         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1711         || $context-&gt;extendedAttributes-&gt;{SecureContext}
<span class="line-modified">1712         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme};</span>

1713 }
1714 
1715 # https://heycam.github.io/webidl/#es-operations
1716 sub OperationShouldBeOnInstance
1717 {
1718     my ($interface, $operation) = @_;
1719 
1720     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1721 
1722     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1723     if (IsUnforgeable($interface, $operation)) {
1724         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1725         return 1;
1726     }
1727 
1728     return 0;
1729 }
1730 
1731 sub OperationHasForcedReturnValue
1732 {
</pre>
<hr />
<pre>
2170 
2171 sub GetDictionaryClassName
2172 {
2173     my ($type, $interface) = @_;
2174 
2175     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2176         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2177     }
2178 
2179     my $name = $type-&gt;name;
2180     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2181     return $name unless defined($interface);
2182     return GetNestedClassName($interface, $name);
2183 }
2184 
2185 sub GenerateDefaultValue
2186 {
2187     my ($typeScope, $context, $type, $defaultValue) = @_;
2188 
2189     if ($codeGenerator-&gt;IsStringType($type)) {
<span class="line-modified">2190         my $useAtomicString = $type-&gt;extendedAttributes-&gt;{AtomicString};</span>
2191         if ($defaultValue eq &quot;null&quot;) {
<span class="line-modified">2192             return $useAtomicString ? &quot;nullAtom()&quot; : &quot;String()&quot;;</span>
2193         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
<span class="line-modified">2194             return $useAtomicString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;</span>
2195         } else {
<span class="line-modified">2196             return $useAtomicString ? &quot;AtomicString(${defaultValue}, AtomicString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;</span>
2197         }
2198     }
2199 
2200     if ($codeGenerator-&gt;IsEnumType($type)) {
2201         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2202         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2203         if ($defaultValue eq &quot;null&quot;) {
2204             die if !$type-&gt;isNullable;
2205             return &quot;WTF::nullopt&quot;;
2206         }
2207         my $className = GetEnumerationClassName($type, $typeScope);
2208         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2209         return $className . &quot;::&quot; . $enumerationValueName;
2210     }
2211     if ($defaultValue eq &quot;null&quot;) {
2212         if ($type-&gt;isUnion) {
2213             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2214 
2215             my $IDLType = GetIDLType($typeScope, $type);
2216             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;
</pre>
<hr />
<pre>
2313         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2314         unshift(@dictionaries, $parentDictionary);
2315         $parentType = $parentDictionary-&gt;parentType;
2316     }
2317 
2318     my $arguments = &quot;&quot;;
2319     my $comma = &quot;&quot;;
2320 
2321     $result .= &quot;    $className result;\n&quot;;
2322 
2323     # 4. For each dictionary dictionary in dictionaries, in order:
2324     foreach my $dictionary (@dictionaries) {
2325         # For each dictionary member member declared on dictionary, in lexicographical order:
2326         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2327         foreach my $member (@sortedMembers) {
2328             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2329 
2330             my $type = $member-&gt;type;
2331             AddToImplIncludesForIDLType($type);
2332 






2333             # 4.1. Let key be the identifier of member.
2334             my $key = $member-&gt;name;
2335             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2336 
2337             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2338             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2339             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2340             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2341             $result .= &quot;    else {\n&quot;;
<span class="line-modified">2342             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(&amp;state, \&quot;${key}\&quot;));\n&quot;;</span>
2343             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2344             $result .= &quot;    }\n&quot;;
2345 
2346             my $IDLType = GetIDLType($typeScope, $type);
2347 
2348             # 4.3. If value is not undefined, then:
2349             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2350 
2351             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);
2352             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2353             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2354 
2355             # Value is undefined.
2356             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2357             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2358                 $result .= &quot;    } else\n&quot;;
2359                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2360             } elsif ($member-&gt;isRequired) {
2361                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2362                 $result .= &quot;    } else {\n&quot;;
2363                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2364                 $result .= &quot;        return { };\n&quot;;
2365                 $result .= &quot;    }\n&quot;;
2366             } else {
2367                 $result .= &quot;    }\n&quot;;
2368             }


2369         }
2370     }
2371 
2372     # 5. Return dict.
2373     $result .= &quot;    return result;\n&quot;;
2374     $result .= &quot;}\n\n&quot;;
2375 
2376     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2377         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2378         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2379 
2380         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2381         $result .= &quot;{\n&quot;;
2382         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;
2383 
2384         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2385         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;
2386 
2387         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2388         #    in order from least to most derived.
2389         #    NOTE: This was done above.
2390 
2391         # 3. For each dictionary dictionary in dictionaries, in order:
2392         foreach my $dictionary (@dictionaries) {
2393             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2394             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2395             foreach my $member (@sortedMembers) {
2396                 my $key = $member-&gt;name;
2397                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2398                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2399 






2400                 # 1. Let key be the identifier of member.
2401                 # 2. If the dictionary member named key is present in V, then:
2402                     # 1. Let idlValue be the value of member on V.
2403                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2404                     # 3. Perform ! CreateDataProperty(O, key, value).
2405 








2406                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2407                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2408                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2409 
<span class="line-modified">2410                     $result .= &quot;    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;</span>
<span class="line-modified">2411                     $result .= &quot;        auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2412                     $result .= &quot;        result-&gt;putDirect(vm, JSC::Identifier::fromString(&amp;vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>
<span class="line-modified">2413                     $result .= &quot;    }\n&quot;;</span>
2414                 } else {
2415                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2416 
<span class="line-modified">2417                     $result .= &quot;    auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2418                     $result .= &quot;    result-&gt;putDirect(vm, JSC::Identifier::fromString(&amp;vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>



2419                 }


2420             }
2421         }
2422 
2423         $result .= &quot;    return result;\n&quot;;
2424         $result .= &quot;}\n\n&quot;;
2425     }
2426 
2427     $result .= &quot;#endif\n\n&quot; if $conditional;
2428 
2429     return $result;
2430 }
2431 
2432 sub GenerateDictionariesImplementationContent
2433 {
2434     my ($typeScope, $allDictionaries) = @_;
2435 
2436     my $result = &quot;&quot;;
2437     foreach my $dictionary (@$allDictionaries) {
2438         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2439         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
</pre>
<hr />
<pre>
2482     my $interfaceName = $interface-&gt;type-&gt;name;
2483     my $className = &quot;JS$interfaceName&quot;;
2484     my %structureFlags = ();
2485 
2486     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2487     my $parentClassName = GetParentClassName($interface);
2488     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2489 
2490     # - Add default header template and header protection
2491     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2492 
2493     if ($hasParent) {
2494         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2495     } else {
2496         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2497         if ($interface-&gt;isException) {
2498             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2499         }
2500     }
2501 
<span class="line-removed">2502     $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};</span>
<span class="line-removed">2503 </span>
2504     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2505 
2506     my $implType = GetImplClassName($interface);
2507 
2508     my $numConstants = @{$interface-&gt;constants};
2509     my $numAttributes = @{$interface-&gt;attributes};
2510     my $numOperations = @{$interface-&gt;operations};
2511 
2512     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2513 
2514     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
<span class="line-modified">2515         $headerIncludes{&quot;$interfaceName.h&quot;} = 1;</span>


2516     } else {

2517         # Implementation class forward declaration
2518         if (IsDOMGlobalObject($interface)) {
2519             AddClassForwardIfNeeded($interface-&gt;type);
2520         }
2521     }
2522 
2523     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2524 
2525     my $exportMacro = GetExportMacroForJSClass($interface);
2526 
2527     # Class declaration
2528     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2529 
2530     # Static create methods
2531     push(@headerContent, &quot;public:\n&quot;);
2532     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2533     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2534 
2535     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2536         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
</pre>
<hr />
<pre>
2546         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2547         push(@headerContent, &quot;        return ptr;\n&quot;);
2548         push(@headerContent, &quot;    }\n\n&quot;);
2549     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2550         AddIncludesForImplementationTypeInHeader($implType);
2551         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2552         push(@headerContent, &quot;    {\n&quot;);
2553         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2554         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2555         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2556         push(@headerContent, &quot;        return ptr;\n&quot;);
2557         push(@headerContent, &quot;    }\n\n&quot;);
2558     } elsif (!NeedsImplementationClass($interface)) {
2559         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2560         push(@headerContent, &quot;    {\n&quot;);
2561         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2562         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2563         push(@headerContent, &quot;        return ptr;\n&quot;);
2564         push(@headerContent, &quot;    }\n\n&quot;);  
2565     } else {
<span class="line-modified">2566         AddIncludesForImplementationTypeInHeader($implType);</span>


2567         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2568         push(@headerContent, &quot;    {\n&quot;);
2569         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2570         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2571         push(@headerContent, &quot;        return ptr;\n&quot;);
2572         push(@headerContent, &quot;    }\n\n&quot;);
2573     }
2574 
2575     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);
2576 
2577     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2578     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2579     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2580     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2581     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2582         
2583     # Prototype
2584     unless (ShouldUseGlobalObjectPrototype($interface)) {
2585         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2586         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
</pre>
<hr />
<pre>
2606     my $namedGetterOperation = GetNamedGetterOperation($interface);
2607     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2608 
2609     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2610     if ($namedGetterOperation) {
2611         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2612             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2613         } else {
2614             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2615         }
2616     }
2617     
2618     # ClassInfo MethodTable declarations.
2619     
2620     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2621         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2622         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2623         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2624         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2625     }





2626     
2627     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2628         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2629         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2630     }
2631     
2632     if (InstanceOverridesPut($interface)) {
2633         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2634         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2635     }
2636     
2637     if (InstanceOverridesDefineOwnProperty($interface)) {
2638         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2639     }
2640 
2641     if (InstanceOverridesDeleteProperty($interface)) {
2642         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);
2643         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);
2644     }
2645 
</pre>
<hr />
<pre>
2746 
2747         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2748             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2749             # concurrent GC or in between eden GCs something may happen that would lead to this
2750             # logic behaving differently. Since this could mark objects or add opaque roots, this
2751             # means that after any increment of mutator resumption in a concurrent GC and at least
2752             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2753             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2754             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2755             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2756             # that the GC calls to ask an object is it would like to mark anything else after the
2757             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2758             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2759             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2760             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;
2761             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);
2762         }
2763     }
2764 
2765     if (NeedsImplementationClass($interface)) {
<span class="line-modified">2766         push(@headerContent, &quot;    static void heapSnapshot(JSCell*, JSC::HeapSnapshotBuilder&amp;);\n&quot;);</span>
2767     }
2768     
2769     if ($numCustomAttributes &gt; 0) {
2770         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2771 
2772         foreach my $attribute (@{$interface-&gt;attributes}) {
2773             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2774             if (HasCustomGetter($attribute)) {
2775                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2776                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2777                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);
2778                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2779             }
2780             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2781                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2782                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);
2783                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2784             }
2785         }
2786     }
</pre>
<hr />
<pre>
3713 
3714         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3715 
3716         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3717     }
3718 
3719     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3720         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3721 
3722         AddToImplIncludes(&quot;Document.h&quot;);
3723         AddToImplIncludes(&quot;Settings.h&quot;);
3724 
3725         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3726 
3727         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3728         foreach my $flag (@flags) {
3729             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3730         }
3731     }
3732 







3733     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3734         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3735 
3736         AddToImplIncludes(&quot;Document.h&quot;);
3737         AddToImplIncludes(&quot;Quirks.h&quot;);
3738 
3739         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3740 
3741         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3742         foreach my $flag (@flags) {
3743             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3744         }
3745     }
3746 
3747     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3748         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3749 
3750         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3751 
3752         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3753         foreach my $flag (@flags) {
3754             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3755         }
3756     }
3757 









3758     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3759     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3760     return $result;
3761 }
3762 
3763 sub GetCastingHelperForThisObject
3764 {
3765     my $interface = shift;
3766     my $interfaceName = $interface-&gt;type-&gt;name;
3767     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3768 }
3769 
3770 # http://heycam.github.io/webidl/#Unscopable
3771 sub addUnscopableProperties
3772 {
3773     my $interface = shift;
3774 
3775     my @unscopables;
3776     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3777         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3778     }
3779     return if scalar(@unscopables) == 0;
3780 
3781     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3782     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3783     foreach my $unscopable (@unscopables) {
<span class="line-modified">3784         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(&amp;vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);</span>
3785     }
3786     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3787 }
3788 
<span class="line-modified">3789 sub GetUnsafeArgumentType</span>
3790 {
3791     my ($interface, $type) = @_;
3792 
3793     my $IDLType = GetIDLType($interface, $type);
3794     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3795 }
3796 
3797 sub GetArgumentTypeFilter
3798 {
3799     my ($interface, $type) = @_;
3800 
3801     my $IDLType = GetIDLType($interface, $type);
3802     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3803 }
3804 
3805 sub GetResultTypeFilter
3806 {
3807     my ($interface, $type) = @_;
3808 
3809     my $IDLType = GetIDLType($interface, $type);
</pre>
<hr />
<pre>
3893             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3894             next if IsJSBuiltin($interface, $operation);
3895 
3896             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3897                 if (!$inAppleCopyright) {
3898                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
3899                     $inAppleCopyright = 1;
3900                 }
3901             } elsif ($inAppleCopyright) {
3902                 push(@implContent, $endAppleCopyright);
3903                 $inAppleCopyright = 0;
3904             }
3905 
3906             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
3907             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
3908             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3909             my $functionName = GetFunctionName($interface, $className, $operation);
3910             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
3911             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3912                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
<span class="line-modified">3913                 my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);</span>
<span class="line-modified">3914                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${unsafeFunctionName}(JSC::ExecState*, $className*&quot;;</span>
3915                 foreach my $argument (@{$operation-&gt;arguments}) {
3916                     my $type = $argument-&gt;type;
<span class="line-modified">3917                     my $argumentType = GetUnsafeArgumentType($interface, $type);</span>
3918                     $functionSignature .= &quot;, ${argumentType}&quot;;
3919                 }
3920                 push(@implContent, $functionSignature . &quot;);\n&quot;);
3921             }
3922             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3923         }
3924 
3925         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
3926         push(@implContent, &quot;\n&quot;);
3927     }
3928 
3929     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3930         push(@implContent, &quot;// Attributes\n\n&quot;);
3931 
3932         if (NeedsConstructorProperty($interface)) {
3933             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3934             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3935 
3936             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3937             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
</pre>
<hr />
<pre>
3956                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
3957             }
3958             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3959         }
3960 
3961         push(@implContent, &quot;\n&quot;);
3962     }
3963 
3964     if ($numOperations &gt; 0) {
3965         foreach my $operation (@operations) {
3966             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
3967             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
3968             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
3969 
3970             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
3971             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
3972             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
3973 
3974             my $interfaceName = $interface-&gt;type-&gt;name;
3975             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">3976             my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);</span>
3977             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
3978             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
3979             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
<span class="line-modified">3980             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}((uintptr_t)${unsafeFunctionName},&quot;;</span>
3981             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
3982             foreach my $argument (@{$operation-&gt;arguments}) {
3983                 my $type = $argument-&gt;type;
3984                 my $argumentType = GetArgumentTypeFilter($interface, $type);
3985                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
3986             }
3987             $domJITSignatureFooter .= &quot;);&quot;;
3988             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
3989             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3990             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
3991             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3992             push(@implContent, &quot;\n&quot;);
3993         }
3994     }
3995 
3996     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3997         foreach my $attribute (@attributes) {
3998             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3999             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4000 
</pre>
<hr />
<pre>
4190     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
4191         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4192         push(@implContent, &quot;{\n&quot;);
4193         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4194         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4195 
4196         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4197         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4198 
4199         if (@runtimeEnabledProperties) {
4200             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4201         }
4202 
4203         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4204             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4205             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4206             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4207             my $name = $operationOrAttribute-&gt;name;
4208             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4209             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
<span class="line-modified">4210             push(@implContent, &quot;        auto propertyName = Identifier::fromString(&amp;vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
4211             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4212             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);
4213             push(@implContent, &quot;    }\n&quot;);
4214             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4215         }
4216 
4217         if (@runtimeEnabledProperties) {
4218             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4219             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4220         }
4221 
4222         foreach my $operation (@{$interface-&gt;operations}) {
4223             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4224             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4225             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4226             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4227             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4228             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4229         }
4230 
</pre>
<hr />
<pre>
4429     if (InstanceOverridesDefineOwnProperty($interface)) {
4430         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4431     }
4432 
4433     if (InstanceOverridesDeleteProperty($interface)) {
4434         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4435     }
4436     
4437     if (InstanceOverridesGetCallData($interface)) {
4438         GenerateGetCallData(\@implContent, $interface, $className);
4439     }
4440     
4441     if ($numAttributes &gt; 0) {
4442         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4443 
4444         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4445         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4446         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4447             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4448             push(@implContent, &quot;{\n&quot;);

4449             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4450             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4451             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);
<span class="line-modified">4452             push(@implContent, &quot;    return $castingFunction(state.vm(), decodedThisValue);&quot;);</span>
4453             push(@implContent, &quot;}\n\n&quot;);
4454         } else {
4455             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4456             push(@implContent, &quot;{\n&quot;);
4457             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);
4458             push(@implContent, &quot;}\n\n&quot;);
4459         }
4460     }
4461 
4462     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4463         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4464 
4465         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4466         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4467         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;
4468         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);
4469         push(@implContent, &quot;{\n&quot;);
4470         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);
4471         push(@implContent, &quot;}\n\n&quot;);
4472     }
</pre>
<hr />
<pre>
4550         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4551             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4552             push(@implContent, &quot;{\n&quot;);
4553             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4554             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4555             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4556             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4557             push(@implContent, &quot;}\n\n&quot;);
4558         }
4559     }
4560 
4561     if (InstanceNeedsEstimatedSize($interface)) {
4562         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4563         push(@implContent, &quot;{\n&quot;);
4564         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4565         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4566         push(@implContent, &quot;}\n\n&quot;);
4567     }
4568 
4569     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
<span class="line-modified">4570         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapSnapshotBuilder.h&gt;&quot;);</span>
4571         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4572         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
<span class="line-modified">4573         push(@implContent, &quot;void ${className}::heapSnapshot(JSCell* cell, HeapSnapshotBuilder&amp; builder)\n&quot;);</span>
4574         push(@implContent, &quot;{\n&quot;);
4575         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
<span class="line-modified">4576         push(@implContent, &quot;    builder.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);</span>
4577         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
<span class="line-modified">4578         push(@implContent, &quot;        builder.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);</span>
<span class="line-modified">4579         push(@implContent, &quot;    Base::heapSnapshot(cell, builder);\n&quot;);</span>
4580         push(@implContent, &quot;}\n\n&quot;);
4581     }
4582 
4583     if ($indexedGetterOperation) {
4584         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4585         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4586             $implIncludes{&quot;JSNode.h&quot;} = 1;
4587             $implIncludes{&quot;Node.h&quot;} = 1;
4588         }
4589     }
4590 
4591     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4592         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4593         push(@implContent, &quot;{\n&quot;);
4594         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4595         # increment their C++ reference counts when hasPendingActivity() becomes
4596         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4597         # their pending activities complete. To wallpaper over this bug, JavaScript
4598         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4599         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
</pre>
<hr />
<pre>
4625                 $emittedJSCast = 1;
4626             }
4627             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4628             push(@implContent, &quot;        return true;\n&quot;);
4629         }
4630         if (GetGenerateIsReachable($interface)) {
4631             if (!$emittedJSCast) {
4632                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4633                 $emittedJSCast = 1;
4634             }
4635 
4636             my $rootString;
4637             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4638                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4639                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4640                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4641             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4642                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4643                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4644                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
<span class="line-modified">4645             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplFrame&quot;) {</span>
<span class="line-modified">4646                 $rootString  = &quot;    Frame* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().frame());\n&quot;;</span>
4647                 $rootString .= &quot;    if (!root)\n&quot;;
4648                 $rootString .= &quot;        return false;\n&quot;;
4649                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
<span class="line-modified">4650                 $rootString .= &quot;        *reason = \&quot;Reachable from Frame\&quot;;\n&quot;;</span>








4651             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4652                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4653                 $rootString .= &quot;    if (!root)\n&quot;;
4654                 $rootString .= &quot;        return false;\n&quot;;
4655                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4656                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4657             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4658                 $implIncludes{&quot;Element.h&quot;} = 1;
4659                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4660                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4661                 $rootString .= &quot;    if (!element)\n&quot;;
4662                 $rootString .= &quot;        return false;\n&quot;;
4663                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4664                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4665                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4666             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4667                 $implIncludes{&quot;Element.h&quot;} = 1;
4668                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4669                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4670                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4671                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4672             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4673                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4674                 $rootString .= &quot;    if (!root)\n&quot;;
4675                 $rootString .= &quot;        return false;\n&quot;;
4676                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4677                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4678             } else {
4679                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4680                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4681                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4682             }
4683 
4684             push(@implContent, $rootString);
<span class="line-modified">4685             push(@implContent, &quot;    return root &amp;&amp; visitor.containsOpaqueRoot(root);\n&quot;);</span>
4686         } else {
4687             if (!$emittedJSCast) {
4688                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4689             }
4690             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4691             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4692             push(@implContent, &quot;    return false;\n&quot;);
4693         }
4694         push(@implContent, &quot;}\n\n&quot;);
4695     }
4696 
4697     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4698         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4699         push(@implContent, &quot;{\n&quot;);
4700         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4701         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4702         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4703         push(@implContent, &quot;}\n\n&quot;);
4704     }
4705 
</pre>
<hr />
<pre>
4901     }
4902     
4903     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
4904     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
4905     
4906     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
4907 }
4908 
4909 sub GenerateAttributeSetterBodyDefinition
4910 {
4911     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
4912 
4913     my @signatureArguments = ();
4914     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4915     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4916     push(@signatureArguments, &quot;JSValue value&quot;);
4917     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4918     
4919     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4920     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">4921     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);</span>





4922 
4923     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);
4924 
4925     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
4926         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4927         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4928             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4929         } else {
4930             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4931         }
4932         push(@$outputArray, &quot;        return false;\n&quot;);
4933     }
4934     
4935     if (HasCustomSetter($attribute)) {
4936         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4937         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);
4938         push(@$outputArray, &quot;    return true;\n&quot;);
4939     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4940         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
4941         my $eventName = EventHandlerAttributeEventName($attribute);
</pre>
<hr />
<pre>
4945             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
4946         } else {
4947             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
4948             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
4949                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
4950                 : &quot;setEventHandlerAttribute&quot;;
4951             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
4952         }
4953         push(@$outputArray, &quot;    return true;\n&quot;);
4954     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4955         my $constructorType = $attribute-&gt;type-&gt;name;
4956         $constructorType =~ s/Constructor$//;
4957         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
4958         # We do not generate the header file for NamedConstructor of class XXXX,
4959         # since we generate the NamedConstructor declaration into the header file of class XXXX.
4960         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
4961             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4962         }
4963         my $id = $attribute-&gt;name;
4964         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
<span class="line-modified">4965         push(@$outputArray, &quot;    return thisObject.putDirect(state.vm(), Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
4966     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
4967         my $id = $attribute-&gt;name;
4968         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
4969         if (AttributeShouldBeOnInstance($interface, $attribute)) {
<span class="line-modified">4970             push(@$outputArray, &quot;    return replaceStaticPropertySlot(state.vm(), &amp;thisObject, Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
4971         } else {
<span class="line-modified">4972             push(@$outputArray, &quot;    return thisObject.putDirect(state.vm(), Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
4973         }
4974     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
4975         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
4976         
4977         # 3.5.9.1. Let Q be ? Get(O, id).
4978         my $id = $attribute-&gt;name;
<span class="line-modified">4979         push(@$outputArray, &quot;    auto id = Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);</span>
4980         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);
4981         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
4982         
4983         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
4984         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
4985         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);
4986         push(@$outputArray, &quot;        return false;\n&quot;);
4987         push(@$outputArray, &quot;    }\n&quot;);
4988         
4989         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
4990         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
<span class="line-modified">4991         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(&amp;state.vm(), reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);</span>
4992         
4993         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
4994         # FIXME: What should the second value to the PutPropertySlot be?
4995         # (https://github.com/heycam/webidl/issues/368)
4996         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<span class="line-modified">4997         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(state.vm())-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);</span>
4998         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
4999         
5000         push(@$outputArray, &quot;    return true;\n&quot;);
5001     } else {
5002         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5003        
5004         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5005             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5006             # the standard conversion, but rather silently fail on invalid enumeration values.
5007             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);
5008             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5009             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5010             push(@$outputArray, &quot;        return false;\n&quot;);
5011             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5012         } else {
5013             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
5014             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5015 
5016             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5017             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5018             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5019         }
5020 
5021         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5022 
5023         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5024 
5025         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5026         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
5027 
5028         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5029         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5030 
5031         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5032         if ($callTracingCallback) {
5033             my $indent = &quot;    &quot;;
<span class="line-modified">5034             my @callTracerArguments = ();</span>
<span class="line-removed">5035             push(@callTracerArguments, GenerateCallTracerParameter(&quot;nativeValue&quot;, $attribute-&gt;type, 0, $indent));</span>
5036             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5037         }
5038 
5039         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5040         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);
5041         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5042         push(@$outputArray, &quot;    });\n&quot;);
5043         push(@$outputArray, &quot;    return true;\n&quot;);
5044     }
5045     push(@$outputArray, &quot;}\n\n&quot;);
5046 }
5047 
5048 sub GenerateAttributeSetterTrampolineDefinition
5049 {
5050     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5051     
5052     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5053     
5054     my $callAttributeSetterName = &quot;set&quot;;
5055     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
</pre>
<hr />
<pre>
5242     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5243         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5244         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5245         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5246 
5247         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5248         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);
5249         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5250     
5251         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5252     }
5253 
5254 
5255     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5256         if ($conditional) {
5257             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5258             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5259         }
5260 
5261         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
<span class="line-modified">5262         my $unsafeFunctionName = &quot;unsafe&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);</span>
<span class="line-modified">5263         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${unsafeFunctionName}(JSC::ExecState* state, $className* castedThis&quot;);</span>
5264         foreach my $argument (@{$operation-&gt;arguments}) {
5265             my $type = $argument-&gt;type;
<span class="line-modified">5266             my $argumentType = GetUnsafeArgumentType($interface, $type);</span>
5267             my $name = $argument-&gt;name;
5268             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5269             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5270         }
5271         push(@$outputArray, &quot;)\n&quot;);
5272         push(@$outputArray, &quot;{\n&quot;);
5273         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5274         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
<span class="line-modified">5275         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(&amp;vm, state);\n&quot;);</span>
5276         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5277         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5278         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5279         
5280         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5281         
5282         my @arguments = ();
5283         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5284         
5285         foreach my $argument (@{$operation-&gt;arguments}) {
5286             my $value = &quot;&quot;;
5287             my $type = $argument-&gt;type;
5288             my $name = $argument-&gt;name;
5289             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5290             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5291 
<span class="line-modified">5292             my ($nativeValue, $mayThrowException) = UnsafeToNative($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});</span>
5293             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5294             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5295             $value = &quot;WTFMove($name)&quot;;
5296 
5297             if ($shouldPassByReference) {
5298                 $value = &quot;*$name&quot;;
5299             }
5300             push(@arguments, $value);
5301         }
5302         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5303         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5304         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5305         push(@$outputArray, &quot;}\n\n&quot;);
5306 
5307         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5308     }
5309 
5310     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5311 }
5312 
</pre>
<hr />
<pre>
5358         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5359         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);
5360     } else {
5361         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);
5362     }
5363     push(@implContent, &quot;\n&quot;);
5364 
5365     foreach my $attribute (@serializedAttributes) {
5366         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5367 
5368         my $name = $attribute-&gt;name;
5369         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5370         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);
5371         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5372 
5373         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5374             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5375             if ($attribute-&gt;type-&gt;isNullable) {
5376                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5377                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<span class="line-modified">5378                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5379                 push(@implContent, &quot;    } else\n&quot;);
<span class="line-modified">5380                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5381             } else {
5382                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<span class="line-modified">5383                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5384             }
5385         } else {
<span class="line-modified">5386             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(&amp;vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5387         }
5388 
5389         push(@implContent, &quot;\n&quot;);
5390     }
5391 
5392     push(@implContent, &quot;    return result;\n&quot;);
5393     push(@implContent, &quot;}\n&quot;);
5394     push(@implContent, &quot;\n&quot;);
5395 
5396     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5397     push(@implContent, &quot;{\n&quot;);
5398     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5399     push(@implContent, &quot;}\n&quot;);
5400     push(@implContent, &quot;\n&quot;);
5401     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);
5402     push(@implContent, &quot;{\n&quot;);
5403     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5404     push(@implContent, &quot;}\n&quot;);
5405     push(@implContent, &quot;\n&quot;);
5406 }
</pre>
<hr />
<pre>
6157             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6158             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6159 
6160             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);
6161 
6162             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6163             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6164 
6165             foreach my $argument (@{$operation-&gt;arguments}) {
6166                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6167             }
6168             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6169 
6170             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6171 
6172             my $callbackInvocation;
6173             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6174                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6175             } else {
6176                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
<span class="line-modified">6177                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(&amp;vm, \&quot;${functionName}\&quot;), returnedException)&quot;;</span>
6178             }
6179 
6180             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6181                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6182             } else {
6183                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6184             }
6185 
6186             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6187             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6188             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6189                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6190                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);
6191             } else {
6192                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);
6193             }
6194             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6195             push(@$contentRef, &quot;     }\n\n&quot;);
6196 
6197             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6198                 push(@$contentRef, &quot;    return { };\n&quot;);
6199             } else {
6200                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);
6201             
6202                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6203                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6204                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
<span class="line-modified">6205                 push(@$contentRef, &quot;    return WTFMove(returnValue);\n&quot;);</span>
6206             }
6207 
6208             push(@$contentRef, &quot;}\n\n&quot;);
6209         }
6210     }
6211 
6212     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6213         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6214         push(@$contentRef, &quot;{\n&quot;);
6215         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6216         push(@$contentRef, &quot;}\n\n&quot;);
6217     }
6218 
6219     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6220     push(@$contentRef, &quot;{\n&quot;);
6221     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6222     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6223     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6224     push(@$contentRef, &quot;}\n\n&quot;);
6225 }
6226 
6227 sub GenerateImplementationFunctionCall
6228 {
6229     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6230 
6231     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6232     if ($callTracingCallback) {
<span class="line-modified">6233         my @callTracerArguments = ();</span>
<span class="line-removed">6234         foreach my $argument (@{$operation-&gt;arguments}) {</span>
<span class="line-removed">6235             push(@callTracerArguments, GenerateCallTracerParameter($argument-&gt;name, $argument-&gt;type, $argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default), $indent));</span>
<span class="line-removed">6236         }</span>
6237         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6238     }
6239 
6240     if (OperationHasForcedReturnValue($operation)) {
6241         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6242         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6243     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6244         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6245         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6246     } else {
6247         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6248         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6249     }
6250 }
6251 
6252 sub GenerateImplementationCustomFunctionCall
6253 {
6254     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6255 
6256     my @customFunctionArguments = ();
</pre>
<hr />
<pre>
6400     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6401 
6402     my @idlUnionMemberTypes = ();
6403 
6404     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6405 
6406     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6407         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6408     }
6409 
6410     return @idlUnionMemberTypes;
6411 }
6412 
6413 sub IsAnnotatedType
6414 {
6415     my ($type) = @_;
6416 
6417     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6418     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6419     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<span class="line-modified">6420     return 1 if $type-&gt;extendedAttributes-&gt;{AtomicString};</span>
<span class="line-modified">6421     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomicString};</span>
6422 }
6423 
6424 sub GetAnnotatedIDLType
6425 {
6426     my ($type) = @_;
6427 
6428     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6429     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6430     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<span class="line-modified">6431     return &quot;IDLAtomicStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomicString};</span>
<span class="line-modified">6432     return &quot;IDLRequiresExistingAtomicStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomicString};</span>
6433 }
6434 
6435 sub GetBaseIDLType
6436 {
6437     my ($interface, $type) = @_;
6438 
6439     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6440         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6441     }
6442 
6443     my %IDLTypes = (
6444         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6445         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6446         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6447         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6448         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6449         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6450         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6451         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6452         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
</pre>
<hr />
<pre>
6564     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6565     $statePointer = &quot;state&quot; unless $statePointer;
6566     $stateReference = &quot;*state&quot; unless $stateReference;
6567     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6568 
6569     AddToImplIncludesForIDLType($type, $conditional);
6570     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6571 
6572     my $IDLType = GetIDLType($interface, $type);
6573 
6574     my @conversionArguments = ();
6575     push(@conversionArguments, $stateReference);
6576     push(@conversionArguments, $value);
6577     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6578     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6579     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6580 
6581     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6582 }
6583 
<span class="line-modified">6584 sub UnsafeToNative</span>
6585 {
6586     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;
6587 
6588     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6589 
6590     my $type = $context-&gt;type;
6591 
6592     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6593     $statePointer = &quot;state&quot; unless $statePointer;
6594     $stateReference = &quot;*state&quot; unless $stateReference;
6595     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6596 
6597     AddToImplIncludesForIDLType($type, $conditional);
6598 
6599     # FIXME: Support more types.
6600 
6601     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6602 
6603     my $IDLType = GetIDLType($interface, $type);
6604 
</pre>
<hr />
<pre>
7277         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7278         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7279     }
7280     push(@$outputArray, &quot;}\n\n&quot;);
7281 
7282 
7283     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7284     push(@$outputArray, &quot;{\n&quot;);
7285 
7286     # There must exist an interface prototype object for every non-callback interface defined, regardless
7287     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7288     # https://heycam.github.io/webidl/#interface-prototype-object
7289     if (ShouldUseGlobalObjectPrototype($interface)) {
7290         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7291     } elsif ($interface-&gt;isCallback) {
7292         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7293     } else {
7294         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7295     }
7296 
<span class="line-modified">7297     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(&amp;vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
7298     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;
7299 
7300     my $classForThis = &quot;${className}::info()&quot;;
7301     if ($interface-&gt;isCallback) {
7302         $classForThis = &quot;nullptr&quot;;
7303     }
7304     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7305 
7306     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7307 
7308     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7309         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7310         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7311         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);
7312         my $name = $operationOrAttribute-&gt;name;
7313         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
<span class="line-modified">7314         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(&amp;vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
7315         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7316         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);
7317         push(@$outputArray, &quot;    }\n&quot;);
7318         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7319     }
7320 
7321     push(@$outputArray, &quot;}\n\n&quot;);
7322 
7323     if (IsJSBuiltinConstructor($interface)) {
7324         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7325         push(@$outputArray, &quot;{\n&quot;);
7326         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7327         push(@$outputArray, &quot;}\n&quot;);
7328         push(@$outputArray, &quot;\n&quot;);
7329     }
7330     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7331 }
7332 
7333 sub HasCustomConstructor
7334 {
</pre>
<hr />
<pre>
7456 }
7457 
7458 sub AddJSBuiltinIncludesIfNeeded()
7459 {
7460     my $interface = shift;
7461 
7462     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7463         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7464         return;
7465     }
7466 
7467     foreach my $operation (@{$interface-&gt;operations}) {
7468         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7469     }
7470 
7471     foreach my $attribute (@{$interface-&gt;attributes}) {
7472         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7473     }
7474 }
7475 
<span class="line-removed">7476 sub GenerateCallTracerParameter()</span>
<span class="line-removed">7477 {</span>
<span class="line-removed">7478     my ($name, $type, $optional, $indent) = @_;</span>
<span class="line-removed">7479 </span>
<span class="line-removed">7480     my $result = &quot;&quot;;</span>
<span class="line-removed">7481 </span>
<span class="line-removed">7482     if ($optional || $type-&gt;isNullable) {</span>
<span class="line-removed">7483         $result .= $indent . &quot;    if (&quot; . $name . &quot;)\n&quot;;</span>
<span class="line-removed">7484         $result .= &quot;    &quot;;</span>
<span class="line-removed">7485     }</span>
<span class="line-removed">7486 </span>
<span class="line-removed">7487     $result .= $indent . &quot;    &quot;;</span>
<span class="line-removed">7488 </span>
<span class="line-removed">7489     if ($type-&gt;isUnion) {</span>
<span class="line-removed">7490         $result .= &quot;WTF::visit([&amp;] (auto&amp; value) { callTracerParameters.append(value); }, &quot;;</span>
<span class="line-removed">7491     } else {</span>
<span class="line-removed">7492         $result .= &quot;callTracerParameters.append(&quot;;</span>
<span class="line-removed">7493     }</span>
<span class="line-removed">7494 </span>
<span class="line-removed">7495     if ($optional || ($type-&gt;isUnion &amp;&amp; $type-&gt;isNullable)) {</span>
<span class="line-removed">7496         $result .= &quot;*&quot;;</span>
<span class="line-removed">7497     }</span>
<span class="line-removed">7498 </span>
<span class="line-removed">7499     $result .= $name . &quot;);&quot;;</span>
<span class="line-removed">7500 </span>
<span class="line-removed">7501     return $result;</span>
<span class="line-removed">7502 }</span>
<span class="line-removed">7503 </span>
7504 sub GenerateCallTracer()
7505 {
7506     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7507 
7508     AddToImplIncludes(&quot;CallTracer.h&quot;);
7509 
<span class="line-modified">7510     my $count = scalar(@$arguments);</span>
<span class="line-removed">7511 </span>
<span class="line-removed">7512     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))&quot;);</span>
<span class="line-removed">7513     if ($count) {</span>
<span class="line-removed">7514         push(@$outputArray, &quot; {\n&quot;);</span>
<span class="line-removed">7515         push(@$outputArray, $indent . &quot;    Vector&lt;&quot; . $codeGenerator-&gt;WK_ucfirst($callTracingCallback) . &quot;Variant&gt; callTracerParameters;\n&quot;);</span>
<span class="line-removed">7516         push(@$outputArray, join(&quot;\n&quot;, @$arguments));</span>
<span class="line-removed">7517     }</span>
<span class="line-removed">7518     push(@$outputArray, &quot;\n&quot;);</span>
7519     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
<span class="line-modified">7520     if ($count) {</span>
<span class="line-modified">7521         push(@$outputArray, &quot;, WTFMove(callTracerParameters)&quot;);</span>
7522     }
7523     push(@$outputArray, &quot;);\n&quot;);
<span class="line-removed">7524     if ($count) {</span>
<span class="line-removed">7525         push(@$outputArray, $indent . &quot;}\n&quot;)</span>
<span class="line-removed">7526     }</span>
7527 }
7528 
7529 sub GenerateCustomElementReactionsStackIfNeeded
7530 {
7531     my ($outputArray, $context, $stateVariable) = @_;
7532 
7533     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7534 
7535     return if !$CEReactions;
7536 
7537     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7538 
7539     if ($CEReactions eq &quot;NotNeeded&quot;) {
7540         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7541     } else {
7542         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7543     }
7544 }
7545 
7546 1;
</pre>
</td>
<td>
<hr />
<pre>
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
<span class="line-modified"> 603     push(@arguments, &quot;propertyNameToAtomString(propertyName)&quot;);</span>
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
</pre>
<hr />
<pre>
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
<span class="line-modified"> 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
 731         $didGeneratePropertyName = 1;
 732     };
 733     
<span class="line-added"> 734     my $namedGetterOperation = GetNamedGetterOperation($interface);</span>
<span class="line-added"> 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);</span>
<span class="line-added"> 736     </span>
 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);
 738     push(@$outputArray, &quot;{\n&quot;);
<span class="line-added"> 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {</span>
<span class="line-added"> 740         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added"> 741     }</span>
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     



 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);</span>
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
</pre>
<hr />
<pre>
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 841     push(@$outputArray, &quot;{\n&quot;);
<span class="line-added"> 842     if ($indexedGetterOperation || $namedGetterOperation) {</span>
<span class="line-added"> 843         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added"> 844     }</span>
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
<span class="line-modified"> 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);</span>
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<span class="line-modified"> 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);</span>
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<span class="line-modified"> 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);</span>
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 887     
 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
</pre>
<hr />
<pre>
 995     }
 996 
 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1014     push(@$outputArray, &quot;{\n&quot;);
<span class="line-added">1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {</span>
<span class="line-added">1016         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added">1017     }</span>
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1025     }
1026     if ($indexedSetterOperation) {
1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1028     }
1029     
<span class="line-modified">1030     if ($indexedSetterOperation) {</span>
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
<span class="line-modified">1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified">1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);</span>
1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified">1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
</pre>
<hr />
<pre>
1333     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1334     # for the deletePropertyByIndex override hook.
1335 
1336     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);
1337     push(@$outputArray, &quot;{\n&quot;);
1338 
1339     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1340     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1341 
1342     # 1. If O supports indexed properties and P is an array index property name, then:
1343     #    1. Let index be the result of calling ToUint32(P).
1344     #    2. If index is not a supported property index, then return true.
1345     #    3. Return false.
1346 
1347     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1348     #       is all that needs to be done, no need to generate the .
1349 
1350     if (GetIndexedGetterOperation($interface)) {
1351         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1352     } else {
<span class="line-modified">1353         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added">1354         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1355 
1356         # GenerateDeletePropertyCommon implements step 2.
1357         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1358 
1359         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1360         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1361         
1362         # 3. If O has an own property with name P, then:
1363         #    1. If the property is not configurable, then return false.
1364         #    2. Otherwise, remove the property from O.
1365         # 3. Return true.
1366         
1367         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);
1368     }
1369 
1370     push(@$outputArray, &quot;}\n\n&quot;);
1371 }
1372 
1373 
1374 sub GenerateNamedDeleterDefinition
</pre>
<hr />
<pre>
1698         $interfaceExposures = [$interfaceExposures];
1699     }
1700 
1701     foreach my $interfaceExposure (@$interfaceExposures) {
1702         return 0 unless exists $contextExposureSet{$interfaceExposure};
1703     }
1704 
1705     return 1;
1706 }
1707 
1708 sub NeedsRuntimeCheck
1709 {
1710     my ($interface, $context) = @_;
1711 
1712     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1713         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1714         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1715     }
1716 
1717     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
<span class="line-added">1718         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}</span>
1719         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1720         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1721         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1722         || $context-&gt;extendedAttributes-&gt;{SecureContext}
<span class="line-modified">1723         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}</span>
<span class="line-added">1724         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};</span>
1725 }
1726 
1727 # https://heycam.github.io/webidl/#es-operations
1728 sub OperationShouldBeOnInstance
1729 {
1730     my ($interface, $operation) = @_;
1731 
1732     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1733 
1734     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1735     if (IsUnforgeable($interface, $operation)) {
1736         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1737         return 1;
1738     }
1739 
1740     return 0;
1741 }
1742 
1743 sub OperationHasForcedReturnValue
1744 {
</pre>
<hr />
<pre>
2182 
2183 sub GetDictionaryClassName
2184 {
2185     my ($type, $interface) = @_;
2186 
2187     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2188         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2189     }
2190 
2191     my $name = $type-&gt;name;
2192     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2193     return $name unless defined($interface);
2194     return GetNestedClassName($interface, $name);
2195 }
2196 
2197 sub GenerateDefaultValue
2198 {
2199     my ($typeScope, $context, $type, $defaultValue) = @_;
2200 
2201     if ($codeGenerator-&gt;IsStringType($type)) {
<span class="line-modified">2202         my $useAtomString = $type-&gt;extendedAttributes-&gt;{AtomString};</span>
2203         if ($defaultValue eq &quot;null&quot;) {
<span class="line-modified">2204             return $useAtomString ? &quot;nullAtom()&quot; : &quot;String()&quot;;</span>
2205         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
<span class="line-modified">2206             return $useAtomString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;</span>
2207         } else {
<span class="line-modified">2208             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;</span>
2209         }
2210     }
2211 
2212     if ($codeGenerator-&gt;IsEnumType($type)) {
2213         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2214         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2215         if ($defaultValue eq &quot;null&quot;) {
2216             die if !$type-&gt;isNullable;
2217             return &quot;WTF::nullopt&quot;;
2218         }
2219         my $className = GetEnumerationClassName($type, $typeScope);
2220         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2221         return $className . &quot;::&quot; . $enumerationValueName;
2222     }
2223     if ($defaultValue eq &quot;null&quot;) {
2224         if ($type-&gt;isUnion) {
2225             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2226 
2227             my $IDLType = GetIDLType($typeScope, $type);
2228             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;
</pre>
<hr />
<pre>
2325         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2326         unshift(@dictionaries, $parentDictionary);
2327         $parentType = $parentDictionary-&gt;parentType;
2328     }
2329 
2330     my $arguments = &quot;&quot;;
2331     my $comma = &quot;&quot;;
2332 
2333     $result .= &quot;    $className result;\n&quot;;
2334 
2335     # 4. For each dictionary dictionary in dictionaries, in order:
2336     foreach my $dictionary (@dictionaries) {
2337         # For each dictionary member member declared on dictionary, in lexicographical order:
2338         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2339         foreach my $member (@sortedMembers) {
2340             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2341 
2342             my $type = $member-&gt;type;
2343             AddToImplIncludesForIDLType($type);
2344 
<span class="line-added">2345             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};</span>
<span class="line-added">2346             if ($conditional) {</span>
<span class="line-added">2347                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);</span>
<span class="line-added">2348                 $result .= &quot;#if ${conditionalString}\n&quot;;</span>
<span class="line-added">2349             }</span>
<span class="line-added">2350 </span>
2351             # 4.1. Let key be the identifier of member.
2352             my $key = $member-&gt;name;
2353             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2354 
2355             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2356             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2357             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2358             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2359             $result .= &quot;    else {\n&quot;;
<span class="line-modified">2360             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
2361             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2362             $result .= &quot;    }\n&quot;;
2363 
2364             my $IDLType = GetIDLType($typeScope, $type);
2365 
2366             # 4.3. If value is not undefined, then:
2367             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2368 
2369             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);
2370             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2371             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2372 
2373             # Value is undefined.
2374             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2375             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2376                 $result .= &quot;    } else\n&quot;;
2377                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2378             } elsif ($member-&gt;isRequired) {
2379                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2380                 $result .= &quot;    } else {\n&quot;;
2381                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2382                 $result .= &quot;        return { };\n&quot;;
2383                 $result .= &quot;    }\n&quot;;
2384             } else {
2385                 $result .= &quot;    }\n&quot;;
2386             }
<span class="line-added">2387 </span>
<span class="line-added">2388             $result .= &quot;#endif\n&quot; if $conditional;</span>
2389         }
2390     }
2391 
2392     # 5. Return dict.
2393     $result .= &quot;    return result;\n&quot;;
2394     $result .= &quot;}\n\n&quot;;
2395 
2396     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2397         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2398         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2399 
2400         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2401         $result .= &quot;{\n&quot;;
2402         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;
2403 
2404         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2405         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;
2406 
2407         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2408         #    in order from least to most derived.
2409         #    NOTE: This was done above.
2410 
2411         # 3. For each dictionary dictionary in dictionaries, in order:
2412         foreach my $dictionary (@dictionaries) {
2413             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2414             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2415             foreach my $member (@sortedMembers) {
2416                 my $key = $member-&gt;name;
2417                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2418                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2419 
<span class="line-added">2420                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};</span>
<span class="line-added">2421                 if ($conditional) {</span>
<span class="line-added">2422                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);</span>
<span class="line-added">2423                     $result .= &quot;#if ${conditionalString}\n&quot;;</span>
<span class="line-added">2424                 }</span>
<span class="line-added">2425 </span>
2426                 # 1. Let key be the identifier of member.
2427                 # 2. If the dictionary member named key is present in V, then:
2428                     # 1. Let idlValue be the value of member on V.
2429                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2430                     # 3. Perform ! CreateDataProperty(O, key, value).
2431 
<span class="line-added">2432                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);</span>
<span class="line-added">2433                 my $indent = &quot;&quot;;</span>
<span class="line-added">2434                 if ($needsRuntimeCheck) {</span>
<span class="line-added">2435                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;true&quot;);</span>
<span class="line-added">2436                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;</span>
<span class="line-added">2437                     $indent = &quot;    &quot;;</span>
<span class="line-added">2438                 }</span>
<span class="line-added">2439 </span>
2440                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2441                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2442                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2443 
<span class="line-modified">2444                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;</span>
<span class="line-modified">2445                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2446                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>
<span class="line-modified">2447                     $result .= &quot;${indent}    }\n&quot;;</span>
2448                 } else {
2449                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2450 
<span class="line-modified">2451                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2452                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>
<span class="line-added">2453                 }</span>
<span class="line-added">2454                 if ($needsRuntimeCheck) {</span>
<span class="line-added">2455                     $result .= &quot;    }\n&quot;;</span>
2456                 }
<span class="line-added">2457 </span>
<span class="line-added">2458                 $result .= &quot;#endif\n&quot; if $conditional;</span>
2459             }
2460         }
2461 
2462         $result .= &quot;    return result;\n&quot;;
2463         $result .= &quot;}\n\n&quot;;
2464     }
2465 
2466     $result .= &quot;#endif\n\n&quot; if $conditional;
2467 
2468     return $result;
2469 }
2470 
2471 sub GenerateDictionariesImplementationContent
2472 {
2473     my ($typeScope, $allDictionaries) = @_;
2474 
2475     my $result = &quot;&quot;;
2476     foreach my $dictionary (@$allDictionaries) {
2477         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2478         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
</pre>
<hr />
<pre>
2521     my $interfaceName = $interface-&gt;type-&gt;name;
2522     my $className = &quot;JS$interfaceName&quot;;
2523     my %structureFlags = ();
2524 
2525     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2526     my $parentClassName = GetParentClassName($interface);
2527     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2528 
2529     # - Add default header template and header protection
2530     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2531 
2532     if ($hasParent) {
2533         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2534     } else {
2535         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2536         if ($interface-&gt;isException) {
2537             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2538         }
2539     }
2540 


2541     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2542 
2543     my $implType = GetImplClassName($interface);
2544 
2545     my $numConstants = @{$interface-&gt;constants};
2546     my $numAttributes = @{$interface-&gt;attributes};
2547     my $numOperations = @{$interface-&gt;operations};
2548 
2549     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2550 
2551     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
<span class="line-modified">2552         $headerIncludes{&quot;SVGAnimatedPropertyImpl.h&quot;} = 1;</span>
<span class="line-added">2553     } elsif ($codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {</span>
<span class="line-added">2554         $headerIncludes{&quot;SVGPathSegImpl.h&quot;} = 1;</span>
2555     } else {
<span class="line-added">2556         $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};</span>
2557         # Implementation class forward declaration
2558         if (IsDOMGlobalObject($interface)) {
2559             AddClassForwardIfNeeded($interface-&gt;type);
2560         }
2561     }
2562 
2563     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2564 
2565     my $exportMacro = GetExportMacroForJSClass($interface);
2566 
2567     # Class declaration
2568     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2569 
2570     # Static create methods
2571     push(@headerContent, &quot;public:\n&quot;);
2572     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2573     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2574 
2575     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2576         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
</pre>
<hr />
<pre>
2586         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2587         push(@headerContent, &quot;        return ptr;\n&quot;);
2588         push(@headerContent, &quot;    }\n\n&quot;);
2589     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2590         AddIncludesForImplementationTypeInHeader($implType);
2591         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2592         push(@headerContent, &quot;    {\n&quot;);
2593         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2594         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2595         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2596         push(@headerContent, &quot;        return ptr;\n&quot;);
2597         push(@headerContent, &quot;    }\n\n&quot;);
2598     } elsif (!NeedsImplementationClass($interface)) {
2599         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2600         push(@headerContent, &quot;    {\n&quot;);
2601         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2602         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2603         push(@headerContent, &quot;        return ptr;\n&quot;);
2604         push(@headerContent, &quot;    }\n\n&quot;);  
2605     } else {
<span class="line-modified">2606         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {</span>
<span class="line-added">2607             AddIncludesForImplementationTypeInHeader($implType);</span>
<span class="line-added">2608         }</span>
2609         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2610         push(@headerContent, &quot;    {\n&quot;);
2611         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2612         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2613         push(@headerContent, &quot;        return ptr;\n&quot;);
2614         push(@headerContent, &quot;    }\n\n&quot;);
2615     }
2616 
2617     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);
2618 
2619     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2620     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2621     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2622     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2623     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2624         
2625     # Prototype
2626     unless (ShouldUseGlobalObjectPrototype($interface)) {
2627         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2628         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
</pre>
<hr />
<pre>
2648     my $namedGetterOperation = GetNamedGetterOperation($interface);
2649     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2650 
2651     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2652     if ($namedGetterOperation) {
2653         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2654             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2655         } else {
2656             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2657         }
2658     }
2659     
2660     # ClassInfo MethodTable declarations.
2661     
2662     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2663         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2664         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2665         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2666         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2667     }
<span class="line-added">2668 </span>
<span class="line-added">2669     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {</span>
<span class="line-added">2670         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="line-added">2671         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;</span>
<span class="line-added">2672     }</span>
2673     
2674     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2675         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2676         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2677     }
2678     
2679     if (InstanceOverridesPut($interface)) {
2680         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2681         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2682     }
2683     
2684     if (InstanceOverridesDefineOwnProperty($interface)) {
2685         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2686     }
2687 
2688     if (InstanceOverridesDeleteProperty($interface)) {
2689         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);
2690         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);
2691     }
2692 
</pre>
<hr />
<pre>
2793 
2794         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2795             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2796             # concurrent GC or in between eden GCs something may happen that would lead to this
2797             # logic behaving differently. Since this could mark objects or add opaque roots, this
2798             # means that after any increment of mutator resumption in a concurrent GC and at least
2799             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2800             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2801             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2802             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2803             # that the GC calls to ask an object is it would like to mark anything else after the
2804             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2805             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2806             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2807             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;
2808             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);
2809         }
2810     }
2811 
2812     if (NeedsImplementationClass($interface)) {
<span class="line-modified">2813         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);</span>
2814     }
2815     
2816     if ($numCustomAttributes &gt; 0) {
2817         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2818 
2819         foreach my $attribute (@{$interface-&gt;attributes}) {
2820             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2821             if (HasCustomGetter($attribute)) {
2822                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2823                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2824                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);
2825                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2826             }
2827             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2828                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2829                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);
2830                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2831             }
2832         }
2833     }
</pre>
<hr />
<pre>
3760 
3761         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3762 
3763         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3764     }
3765 
3766     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3767         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3768 
3769         AddToImplIncludes(&quot;Document.h&quot;);
3770         AddToImplIncludes(&quot;Settings.h&quot;);
3771 
3772         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3773 
3774         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3775         foreach my $flag (@flags) {
3776             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3777         }
3778     }
3779 
<span class="line-added">3780     if ($context-&gt;extendedAttributes-&gt;{CustomEnabled}) {</span>
<span class="line-added">3781         assert(&quot;CustomEnabled can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;</span>
<span class="line-added">3782 </span>
<span class="line-added">3783         my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;</span>
<span class="line-added">3784         push(@conjuncts, &quot;${className}&quot; . $codeGenerator-&gt;WK_ucfirst($context-&gt;name) . &quot;IsEnabled()&quot;);</span>
<span class="line-added">3785     }</span>
<span class="line-added">3786 </span>
3787     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3788         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3789 
3790         AddToImplIncludes(&quot;Document.h&quot;);
3791         AddToImplIncludes(&quot;Quirks.h&quot;);
3792 
3793         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3794 
3795         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3796         foreach my $flag (@flags) {
3797             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3798         }
3799     }
3800 
3801     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3802         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3803 
3804         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3805 
3806         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3807         foreach my $flag (@flags) {
3808             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3809         }
3810     }
3811 
<span class="line-added">3812     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {</span>
<span class="line-added">3813         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="line-added">3814         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);</span>
<span class="line-added">3815 </span>
<span class="line-added">3816         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;</span>
<span class="line-added">3817         my $name = $context-&gt;name;</span>
<span class="line-added">3818         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);</span>
<span class="line-added">3819     }</span>
<span class="line-added">3820 </span>
3821     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3822     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3823     return $result;
3824 }
3825 
3826 sub GetCastingHelperForThisObject
3827 {
3828     my $interface = shift;
3829     my $interfaceName = $interface-&gt;type-&gt;name;
3830     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3831 }
3832 
3833 # http://heycam.github.io/webidl/#Unscopable
3834 sub addUnscopableProperties
3835 {
3836     my $interface = shift;
3837 
3838     my @unscopables;
3839     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3840         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3841     }
3842     return if scalar(@unscopables) == 0;
3843 
3844     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3845     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3846     foreach my $unscopable (@unscopables) {
<span class="line-modified">3847         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);</span>
3848     }
3849     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3850 }
3851 
<span class="line-modified">3852 sub GetArgumentTypeForFunctionWithoutTypeCheck</span>
3853 {
3854     my ($interface, $type) = @_;
3855 
3856     my $IDLType = GetIDLType($interface, $type);
3857     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3858 }
3859 
3860 sub GetArgumentTypeFilter
3861 {
3862     my ($interface, $type) = @_;
3863 
3864     my $IDLType = GetIDLType($interface, $type);
3865     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3866 }
3867 
3868 sub GetResultTypeFilter
3869 {
3870     my ($interface, $type) = @_;
3871 
3872     my $IDLType = GetIDLType($interface, $type);
</pre>
<hr />
<pre>
3956             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3957             next if IsJSBuiltin($interface, $operation);
3958 
3959             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3960                 if (!$inAppleCopyright) {
3961                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
3962                     $inAppleCopyright = 1;
3963                 }
3964             } elsif ($inAppleCopyright) {
3965                 push(@implContent, $endAppleCopyright);
3966                 $inAppleCopyright = 0;
3967             }
3968 
3969             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
3970             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
3971             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3972             my $functionName = GetFunctionName($interface, $className, $operation);
3973             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
3974             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3975                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
<span class="line-modified">3976                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
<span class="line-modified">3977                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState*, $className*&quot;;</span>
3978                 foreach my $argument (@{$operation-&gt;arguments}) {
3979                     my $type = $argument-&gt;type;
<span class="line-modified">3980                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);</span>
3981                     $functionSignature .= &quot;, ${argumentType}&quot;;
3982                 }
3983                 push(@implContent, $functionSignature . &quot;);\n&quot;);
3984             }
3985             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3986         }
3987 
3988         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
3989         push(@implContent, &quot;\n&quot;);
3990     }
3991 
3992     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3993         push(@implContent, &quot;// Attributes\n\n&quot;);
3994 
3995         if (NeedsConstructorProperty($interface)) {
3996             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3997             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3998 
3999             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4000             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
</pre>
<hr />
<pre>
4019                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4020             }
4021             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4022         }
4023 
4024         push(@implContent, &quot;\n&quot;);
4025     }
4026 
4027     if ($numOperations &gt; 0) {
4028         foreach my $operation (@operations) {
4029             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4030             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4031             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4032 
4033             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4034             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4035             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4036 
4037             my $interfaceName = $interface-&gt;type-&gt;name;
4038             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">4039             my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
4040             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
4041             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
4042             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
<span class="line-modified">4043             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}(${nameOfFunctionWithoutTypeCheck},&quot;;</span>
4044             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
4045             foreach my $argument (@{$operation-&gt;arguments}) {
4046                 my $type = $argument-&gt;type;
4047                 my $argumentType = GetArgumentTypeFilter($interface, $type);
4048                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
4049             }
4050             $domJITSignatureFooter .= &quot;);&quot;;
4051             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4052             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4053             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
4054             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4055             push(@implContent, &quot;\n&quot;);
4056         }
4057     }
4058 
4059     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4060         foreach my $attribute (@attributes) {
4061             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4062             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4063 
</pre>
<hr />
<pre>
4253     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
4254         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4255         push(@implContent, &quot;{\n&quot;);
4256         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4257         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4258 
4259         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4260         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4261 
4262         if (@runtimeEnabledProperties) {
4263             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4264         }
4265 
4266         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4267             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4268             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4269             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4270             my $name = $operationOrAttribute-&gt;name;
4271             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4272             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
<span class="line-modified">4273             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
4274             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4275             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);
4276             push(@implContent, &quot;    }\n&quot;);
4277             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4278         }
4279 
4280         if (@runtimeEnabledProperties) {
4281             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4282             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4283         }
4284 
4285         foreach my $operation (@{$interface-&gt;operations}) {
4286             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4287             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4288             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4289             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4290             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4291             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4292         }
4293 
</pre>
<hr />
<pre>
4492     if (InstanceOverridesDefineOwnProperty($interface)) {
4493         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4494     }
4495 
4496     if (InstanceOverridesDeleteProperty($interface)) {
4497         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4498     }
4499     
4500     if (InstanceOverridesGetCallData($interface)) {
4501         GenerateGetCallData(\@implContent, $interface, $className);
4502     }
4503     
4504     if ($numAttributes &gt; 0) {
4505         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4506 
4507         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4508         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4509         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4510             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4511             push(@implContent, &quot;{\n&quot;);
<span class="line-added">4512             push(@implContent, &quot;    VM&amp; vm = state.vm();\n&quot;);</span>
4513             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4514             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4515             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);
<span class="line-modified">4516             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);&quot;);</span>
4517             push(@implContent, &quot;}\n\n&quot;);
4518         } else {
4519             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4520             push(@implContent, &quot;{\n&quot;);
4521             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);
4522             push(@implContent, &quot;}\n\n&quot;);
4523         }
4524     }
4525 
4526     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4527         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4528 
4529         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4530         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4531         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;
4532         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);
4533         push(@implContent, &quot;{\n&quot;);
4534         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);
4535         push(@implContent, &quot;}\n\n&quot;);
4536     }
</pre>
<hr />
<pre>
4614         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4615             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4616             push(@implContent, &quot;{\n&quot;);
4617             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4618             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4619             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4620             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4621             push(@implContent, &quot;}\n\n&quot;);
4622         }
4623     }
4624 
4625     if (InstanceNeedsEstimatedSize($interface)) {
4626         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4627         push(@implContent, &quot;{\n&quot;);
4628         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4629         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4630         push(@implContent, &quot;}\n\n&quot;);
4631     }
4632 
4633     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
<span class="line-modified">4634         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapAnalyzer.h&gt;&quot;);</span>
4635         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4636         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
<span class="line-modified">4637         push(@implContent, &quot;void ${className}::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)\n&quot;);</span>
4638         push(@implContent, &quot;{\n&quot;);
4639         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
<span class="line-modified">4640         push(@implContent, &quot;    analyzer.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);</span>
4641         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
<span class="line-modified">4642         push(@implContent, &quot;        analyzer.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);</span>
<span class="line-modified">4643         push(@implContent, &quot;    Base::analyzeHeap(cell, analyzer);\n&quot;);</span>
4644         push(@implContent, &quot;}\n\n&quot;);
4645     }
4646 
4647     if ($indexedGetterOperation) {
4648         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4649         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4650             $implIncludes{&quot;JSNode.h&quot;} = 1;
4651             $implIncludes{&quot;Node.h&quot;} = 1;
4652         }
4653     }
4654 
4655     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4656         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4657         push(@implContent, &quot;{\n&quot;);
4658         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4659         # increment their C++ reference counts when hasPendingActivity() becomes
4660         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4661         # their pending activities complete. To wallpaper over this bug, JavaScript
4662         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4663         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
</pre>
<hr />
<pre>
4689                 $emittedJSCast = 1;
4690             }
4691             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4692             push(@implContent, &quot;        return true;\n&quot;);
4693         }
4694         if (GetGenerateIsReachable($interface)) {
4695             if (!$emittedJSCast) {
4696                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4697                 $emittedJSCast = 1;
4698             }
4699 
4700             my $rootString;
4701             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4702                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4703                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4704                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4705             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4706                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4707                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4708                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
<span class="line-modified">4709             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromDOMWindow&quot;) {</span>
<span class="line-modified">4710                 $rootString  = &quot;    auto* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().window());\n&quot;;</span>
4711                 $rootString .= &quot;    if (!root)\n&quot;;
4712                 $rootString .= &quot;        return false;\n&quot;;
4713                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
<span class="line-modified">4714                 $rootString .= &quot;        *reason = \&quot;Reachable from Window\&quot;;\n&quot;;</span>
<span class="line-added">4715             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromNavigator&quot;) {</span>
<span class="line-added">4716                 $implIncludes{&quot;Navigator.h&quot;} = 1;</span>
<span class="line-added">4717                 $implIncludes{&quot;WorkerNavigator.h&quot;} = 1;</span>
<span class="line-added">4718                 $rootString  = &quot;    NavigatorBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().navigator());\n&quot;;</span>
<span class="line-added">4719                 $rootString .= &quot;    if (!root)\n&quot;;</span>
<span class="line-added">4720                 $rootString .= &quot;        return false;\n&quot;;</span>
<span class="line-added">4721                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;</span>
<span class="line-added">4722                 $rootString .= &quot;        *reason = \&quot;Reachable from Navigator\&quot;;\n&quot;;</span>
4723             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4724                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4725                 $rootString .= &quot;    if (!root)\n&quot;;
4726                 $rootString .= &quot;        return false;\n&quot;;
4727                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4728                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4729             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4730                 $implIncludes{&quot;Element.h&quot;} = 1;
4731                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4732                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4733                 $rootString .= &quot;    if (!element)\n&quot;;
4734                 $rootString .= &quot;        return false;\n&quot;;
4735                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4736                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4737                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4738             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4739                 $implIncludes{&quot;Element.h&quot;} = 1;
4740                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4741                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4742                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4743                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4744             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4745                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4746                 $rootString .= &quot;    if (!root)\n&quot;;
4747                 $rootString .= &quot;        return false;\n&quot;;
4748                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4749                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4750             } else {
4751                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4752                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4753                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4754             }
4755 
4756             push(@implContent, $rootString);
<span class="line-modified">4757             push(@implContent, &quot;    return visitor.containsOpaqueRoot(root);\n&quot;);</span>
4758         } else {
4759             if (!$emittedJSCast) {
4760                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4761             }
4762             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4763             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4764             push(@implContent, &quot;    return false;\n&quot;);
4765         }
4766         push(@implContent, &quot;}\n\n&quot;);
4767     }
4768 
4769     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4770         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4771         push(@implContent, &quot;{\n&quot;);
4772         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4773         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4774         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4775         push(@implContent, &quot;}\n\n&quot;);
4776     }
4777 
</pre>
<hr />
<pre>
4973     }
4974     
4975     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
4976     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
4977     
4978     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
4979 }
4980 
4981 sub GenerateAttributeSetterBodyDefinition
4982 {
4983     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
4984 
4985     my @signatureArguments = ();
4986     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4987     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4988     push(@signatureArguments, &quot;JSValue value&quot;);
4989     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4990     
4991     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4992     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">4993     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="line-added">4994     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {</span>
<span class="line-added">4995         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);</span>
<span class="line-added">4996     } else {</span>
<span class="line-added">4997         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);</span>
<span class="line-added">4998     }</span>
4999 
5000     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);
5001 
5002     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5003         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5004         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5005             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
5006         } else {
5007             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
5008         }
5009         push(@$outputArray, &quot;        return false;\n&quot;);
5010     }
5011     
5012     if (HasCustomSetter($attribute)) {
5013         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
5014         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);
5015         push(@$outputArray, &quot;    return true;\n&quot;);
5016     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5017         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5018         my $eventName = EventHandlerAttributeEventName($attribute);
</pre>
<hr />
<pre>
5022             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
5023         } else {
5024             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5025             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5026                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5027                 : &quot;setEventHandlerAttribute&quot;;
5028             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
5029         }
5030         push(@$outputArray, &quot;    return true;\n&quot;);
5031     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5032         my $constructorType = $attribute-&gt;type-&gt;name;
5033         $constructorType =~ s/Constructor$//;
5034         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5035         # We do not generate the header file for NamedConstructor of class XXXX,
5036         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5037         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5038             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5039         }
5040         my $id = $attribute-&gt;name;
5041         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
<span class="line-modified">5042         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5043     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5044         my $id = $attribute-&gt;name;
5045         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5046         if (AttributeShouldBeOnInstance($interface, $attribute)) {
<span class="line-modified">5047             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5048         } else {
<span class="line-modified">5049             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5050         }
5051     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5052         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5053         
5054         # 3.5.9.1. Let Q be ? Get(O, id).
5055         my $id = $attribute-&gt;name;
<span class="line-modified">5056         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);</span>
5057         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);
5058         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5059         
5060         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5061         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
5062         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);
5063         push(@$outputArray, &quot;        return false;\n&quot;);
5064         push(@$outputArray, &quot;    }\n&quot;);
5065         
5066         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5067         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
<span class="line-modified">5068         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);</span>
5069         
5070         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5071         # FIXME: What should the second value to the PutPropertySlot be?
5072         # (https://github.com/heycam/webidl/issues/368)
5073         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<span class="line-modified">5074         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);</span>
5075         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5076         
5077         push(@$outputArray, &quot;    return true;\n&quot;);
5078     } else {
5079         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5080        
5081         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5082             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5083             # the standard conversion, but rather silently fail on invalid enumeration values.
5084             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);
5085             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5086             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5087             push(@$outputArray, &quot;        return false;\n&quot;);
5088             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5089         } else {
5090             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
5091             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5092 
5093             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5094             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5095             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5096         }
5097 
5098         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5099 
5100         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5101 
5102         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5103         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
5104 
5105         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5106         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5107 
5108         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5109         if ($callTracingCallback) {
5110             my $indent = &quot;    &quot;;
<span class="line-modified">5111             my @callTracerArguments = (&quot;nativeValue&quot;);</span>

5112             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5113         }
5114 
5115         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5116         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);
5117         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5118         push(@$outputArray, &quot;    });\n&quot;);
5119         push(@$outputArray, &quot;    return true;\n&quot;);
5120     }
5121     push(@$outputArray, &quot;}\n\n&quot;);
5122 }
5123 
5124 sub GenerateAttributeSetterTrampolineDefinition
5125 {
5126     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5127     
5128     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5129     
5130     my $callAttributeSetterName = &quot;set&quot;;
5131     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
</pre>
<hr />
<pre>
5318     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5319         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5320         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5321         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5322 
5323         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5324         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);
5325         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5326     
5327         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5328     }
5329 
5330 
5331     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5332         if ($conditional) {
5333             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5334             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5335         }
5336 
5337         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
<span class="line-modified">5338         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
<span class="line-modified">5339         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState* state, $className* castedThis&quot;);</span>
5340         foreach my $argument (@{$operation-&gt;arguments}) {
5341             my $type = $argument-&gt;type;
<span class="line-modified">5342             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);</span>
5343             my $name = $argument-&gt;name;
5344             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5345             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5346         }
5347         push(@$outputArray, &quot;)\n&quot;);
5348         push(@$outputArray, &quot;{\n&quot;);
5349         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5350         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
<span class="line-modified">5351         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(vm, state);\n&quot;);</span>
5352         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5353         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5354         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5355         
5356         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5357         
5358         my @arguments = ();
5359         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5360         
5361         foreach my $argument (@{$operation-&gt;arguments}) {
5362             my $value = &quot;&quot;;
5363             my $type = $argument-&gt;type;
5364             my $name = $argument-&gt;name;
5365             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5366             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5367 
<span class="line-modified">5368             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});</span>
5369             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5370             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5371             $value = &quot;WTFMove($name)&quot;;
5372 
5373             if ($shouldPassByReference) {
5374                 $value = &quot;*$name&quot;;
5375             }
5376             push(@arguments, $value);
5377         }
5378         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5379         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5380         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5381         push(@$outputArray, &quot;}\n\n&quot;);
5382 
5383         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5384     }
5385 
5386     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5387 }
5388 
</pre>
<hr />
<pre>
5434         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5435         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);
5436     } else {
5437         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);
5438     }
5439     push(@implContent, &quot;\n&quot;);
5440 
5441     foreach my $attribute (@serializedAttributes) {
5442         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5443 
5444         my $name = $attribute-&gt;name;
5445         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5446         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);
5447         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5448 
5449         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5450             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5451             if ($attribute-&gt;type-&gt;isNullable) {
5452                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5453                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<span class="line-modified">5454                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5455                 push(@implContent, &quot;    } else\n&quot;);
<span class="line-modified">5456                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5457             } else {
5458                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<span class="line-modified">5459                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5460             }
5461         } else {
<span class="line-modified">5462             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5463         }
5464 
5465         push(@implContent, &quot;\n&quot;);
5466     }
5467 
5468     push(@implContent, &quot;    return result;\n&quot;);
5469     push(@implContent, &quot;}\n&quot;);
5470     push(@implContent, &quot;\n&quot;);
5471 
5472     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5473     push(@implContent, &quot;{\n&quot;);
5474     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5475     push(@implContent, &quot;}\n&quot;);
5476     push(@implContent, &quot;\n&quot;);
5477     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);
5478     push(@implContent, &quot;{\n&quot;);
5479     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5480     push(@implContent, &quot;}\n&quot;);
5481     push(@implContent, &quot;\n&quot;);
5482 }
</pre>
<hr />
<pre>
6233             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6234             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6235 
6236             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);
6237 
6238             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6239             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6240 
6241             foreach my $argument (@{$operation-&gt;arguments}) {
6242                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6243             }
6244             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6245 
6246             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6247 
6248             my $callbackInvocation;
6249             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6250                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6251             } else {
6252                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
<span class="line-modified">6253                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;</span>
6254             }
6255 
6256             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6257                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6258             } else {
6259                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6260             }
6261 
6262             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6263             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6264             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6265                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6266                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);
6267             } else {
6268                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);
6269             }
6270             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6271             push(@$contentRef, &quot;     }\n\n&quot;);
6272 
6273             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6274                 push(@$contentRef, &quot;    return { };\n&quot;);
6275             } else {
6276                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);
6277             
6278                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6279                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6280                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
<span class="line-modified">6281                 push(@$contentRef, &quot;    return returnValue;\n&quot;);</span>
6282             }
6283 
6284             push(@$contentRef, &quot;}\n\n&quot;);
6285         }
6286     }
6287 
6288     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6289         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6290         push(@$contentRef, &quot;{\n&quot;);
6291         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6292         push(@$contentRef, &quot;}\n\n&quot;);
6293     }
6294 
6295     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6296     push(@$contentRef, &quot;{\n&quot;);
6297     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6298     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6299     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6300     push(@$contentRef, &quot;}\n\n&quot;);
6301 }
6302 
6303 sub GenerateImplementationFunctionCall
6304 {
6305     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6306 
6307     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6308     if ($callTracingCallback) {
<span class="line-modified">6309         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};</span>



6310         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6311     }
6312 
6313     if (OperationHasForcedReturnValue($operation)) {
6314         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6315         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6316     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6317         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6318         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6319     } else {
6320         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6321         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6322     }
6323 }
6324 
6325 sub GenerateImplementationCustomFunctionCall
6326 {
6327     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6328 
6329     my @customFunctionArguments = ();
</pre>
<hr />
<pre>
6473     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6474 
6475     my @idlUnionMemberTypes = ();
6476 
6477     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6478 
6479     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6480         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6481     }
6482 
6483     return @idlUnionMemberTypes;
6484 }
6485 
6486 sub IsAnnotatedType
6487 {
6488     my ($type) = @_;
6489 
6490     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6491     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6492     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<span class="line-modified">6493     return 1 if $type-&gt;extendedAttributes-&gt;{AtomString};</span>
<span class="line-modified">6494     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};</span>
6495 }
6496 
6497 sub GetAnnotatedIDLType
6498 {
6499     my ($type) = @_;
6500 
6501     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6502     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6503     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<span class="line-modified">6504     return &quot;IDLAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomString};</span>
<span class="line-modified">6505     return &quot;IDLRequiresExistingAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};</span>
6506 }
6507 
6508 sub GetBaseIDLType
6509 {
6510     my ($interface, $type) = @_;
6511 
6512     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6513         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6514     }
6515 
6516     my %IDLTypes = (
6517         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6518         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6519         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6520         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6521         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6522         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6523         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6524         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6525         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
</pre>
<hr />
<pre>
6637     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6638     $statePointer = &quot;state&quot; unless $statePointer;
6639     $stateReference = &quot;*state&quot; unless $stateReference;
6640     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6641 
6642     AddToImplIncludesForIDLType($type, $conditional);
6643     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6644 
6645     my $IDLType = GetIDLType($interface, $type);
6646 
6647     my @conversionArguments = ();
6648     push(@conversionArguments, $stateReference);
6649     push(@conversionArguments, $value);
6650     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6651     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6652     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6653 
6654     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6655 }
6656 
<span class="line-modified">6657 sub ToNativeForFunctionWithoutTypeCheck</span>
6658 {
6659     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;
6660 
6661     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6662 
6663     my $type = $context-&gt;type;
6664 
6665     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6666     $statePointer = &quot;state&quot; unless $statePointer;
6667     $stateReference = &quot;*state&quot; unless $stateReference;
6668     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6669 
6670     AddToImplIncludesForIDLType($type, $conditional);
6671 
6672     # FIXME: Support more types.
6673 
6674     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6675 
6676     my $IDLType = GetIDLType($interface, $type);
6677 
</pre>
<hr />
<pre>
7350         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7351         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7352     }
7353     push(@$outputArray, &quot;}\n\n&quot;);
7354 
7355 
7356     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7357     push(@$outputArray, &quot;{\n&quot;);
7358 
7359     # There must exist an interface prototype object for every non-callback interface defined, regardless
7360     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7361     # https://heycam.github.io/webidl/#interface-prototype-object
7362     if (ShouldUseGlobalObjectPrototype($interface)) {
7363         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7364     } elsif ($interface-&gt;isCallback) {
7365         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7366     } else {
7367         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7368     }
7369 
<span class="line-modified">7370     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
7371     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;
7372 
7373     my $classForThis = &quot;${className}::info()&quot;;
7374     if ($interface-&gt;isCallback) {
7375         $classForThis = &quot;nullptr&quot;;
7376     }
7377     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7378 
7379     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7380 
7381     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7382         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7383         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7384         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);
7385         my $name = $operationOrAttribute-&gt;name;
7386         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
<span class="line-modified">7387         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
7388         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7389         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);
7390         push(@$outputArray, &quot;    }\n&quot;);
7391         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7392     }
7393 
7394     push(@$outputArray, &quot;}\n\n&quot;);
7395 
7396     if (IsJSBuiltinConstructor($interface)) {
7397         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7398         push(@$outputArray, &quot;{\n&quot;);
7399         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7400         push(@$outputArray, &quot;}\n&quot;);
7401         push(@$outputArray, &quot;\n&quot;);
7402     }
7403     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7404 }
7405 
7406 sub HasCustomConstructor
7407 {
</pre>
<hr />
<pre>
7529 }
7530 
7531 sub AddJSBuiltinIncludesIfNeeded()
7532 {
7533     my $interface = shift;
7534 
7535     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7536         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7537         return;
7538     }
7539 
7540     foreach my $operation (@{$interface-&gt;operations}) {
7541         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7542     }
7543 
7544     foreach my $attribute (@{$interface-&gt;attributes}) {
7545         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7546     }
7547 }
7548 




























7549 sub GenerateCallTracer()
7550 {
7551     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7552 
7553     AddToImplIncludes(&quot;CallTracer.h&quot;);
7554 
<span class="line-modified">7555     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))\n&quot;);</span>








7556     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
<span class="line-modified">7557     if (scalar(@$arguments)) {</span>
<span class="line-modified">7558         push(@$outputArray, &quot;, { &quot; . join(&quot;, &quot;, @$arguments) . &quot; }&quot;);</span>
7559     }
7560     push(@$outputArray, &quot;);\n&quot;);



7561 }
7562 
7563 sub GenerateCustomElementReactionsStackIfNeeded
7564 {
7565     my ($outputArray, $context, $stateVariable) = @_;
7566 
7567     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7568 
7569     return if !$CEReactions;
7570 
7571     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7572 
7573     if ($CEReactions eq &quot;NotNeeded&quot;) {
7574         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7575     } else {
7576         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7577     }
7578 }
7579 
7580 1;
</pre>
</td>
</tr>
</table>
<center><a href="CodeGenerator.pm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>