<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmAirIRGenerator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -45,21 +45,25 @@</span>
  #include &quot;B3ValueKey.h&quot;
  #include &quot;B3Variable.h&quot;
  #include &quot;B3VariableValue.h&quot;
  #include &quot;B3WasmAddressValue.h&quot;
  #include &quot;B3WasmBoundsCheckValue.h&quot;
<span class="udiff-line-added">+ #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
<span class="udiff-line-added">+ #include &quot;JSWebAssemblyInstance.h&quot;</span>
  #include &quot;ScratchRegisterAllocator.h&quot;
  #include &quot;VirtualRegister.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmContextInlines.h&quot;
  #include &quot;WasmExceptionType.h&quot;
  #include &quot;WasmFunctionParser.h&quot;
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmOMGPlan.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmOSREntryData.h&quot;</span>
  #include &quot;WasmOpcodeOrigin.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmOperations.h&quot;</span>
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmThunks.h&quot;
  #include &lt;limits&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,14 +157,117 @@</span>
          BasicBlock* special;
          ResultList result;
      };
  
      typedef Value* ExpressionType;
<span class="udiff-line-removed">-     typedef ControlData ControlType;</span>
      typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;
<span class="udiff-line-modified-removed">-     typedef ControlData::ResultList ResultList;</span>
<span class="udiff-line-modified-removed">-     typedef FunctionParser&lt;B3IRGenerator&gt;::ControlEntry ControlEntry;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     friend class Stack;</span>
<span class="udiff-line-added">+     class Stack {</span>
<span class="udiff-line-added">+     public:</span>
<span class="udiff-line-added">+         Stack(B3IRGenerator* generator)</span>
<span class="udiff-line-added">+             : m_generator(generator)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void append(ExpressionType expression)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="udiff-line-added">+                 Variable* variable = m_generator-&gt;m_proc.addVariable(expression-&gt;type());</span>
<span class="udiff-line-added">+                 m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, Set, m_generator-&gt;origin(), variable, expression);</span>
<span class="udiff-line-added">+                 m_stack.append(variable);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             m_data.append(expression);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ExpressionType takeLast()</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.takeLast());</span>
<span class="udiff-line-added">+             return m_data.takeLast();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ExpressionType last()</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.last());</span>
<span class="udiff-line-added">+             return m_data.last();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         unsigned size() const</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+                 return m_stack.size();</span>
<span class="udiff-line-added">+             return m_data.size();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         bool isEmpty() const { return size() == 0; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ExpressionList convertToExpressionList()</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="udiff-line-added">+                 ExpressionList results;</span>
<span class="udiff-line-added">+                 for (unsigned i = 0; i &lt; m_stack.size(); ++i)</span>
<span class="udiff-line-added">+                     results.append(at(i));</span>
<span class="udiff-line-added">+                 return results;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return m_data;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ExpressionType at(unsigned i) const</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.at(i));</span>
<span class="udiff-line-added">+             return m_data.at(i);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Variable* variableAt(unsigned i) const</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+                 return m_stack.at(i);</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void shrink(unsigned i)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="udiff-line-added">+                 m_stack.shrink(i);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             m_data.shrink(i);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void swap(Stack&amp; stack)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             std::swap(m_generator, stack.m_generator);</span>
<span class="udiff-line-added">+             m_data.swap(stack.m_data);</span>
<span class="udiff-line-added">+             m_stack.swap(stack.m_stack);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void dump() const</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="udiff-line-added">+             dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="udiff-line-added">+             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="udiff-line-added">+                 for (const auto&amp; variable : m_stack)</span>
<span class="udiff-line-added">+                     dataLog(comma, *variable);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (const auto&amp; expression : m_data)</span>
<span class="udiff-line-added">+                 dataLog(comma, *expression);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private:</span>
<span class="udiff-line-added">+         B3IRGenerator* m_generator { nullptr };</span>
<span class="udiff-line-added">+         ExpressionList m_data;</span>
<span class="udiff-line-added">+         Vector&lt;Variable*&gt; m_stack;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     Stack createStack() { return Stack(this); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     using ControlType = ControlData;</span>
<span class="udiff-line-added">+     using ResultList = ControlData::ResultList;</span>
<span class="udiff-line-added">+     using ControlEntry = FunctionParser&lt;B3IRGenerator&gt;::ControlEntry;</span>
  
      static constexpr ExpressionType emptyExpression() { return nullptr; }
  
      typedef String ErrorType;
      typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,16 +282,26 @@</span>
  #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
          if (UNLIKELY(condition))                  \
              return fail(__VA_ARGS__);             \
      } while (0)
  
<span class="udiff-line-modified-removed">-     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, MemoryMode, CompilationMode, unsigned functionIndex, TierUpCount*, ThrowWasmException);</span>
<span class="udiff-line-modified-added">+     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, unsigned&amp; osrEntryScratchBufferSize, MemoryMode, CompilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount*, ThrowWasmException);</span>
  
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
  
<span class="udiff-line-added">+     // References</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Tables</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="udiff-line-added">+     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
      // Globals
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,46 +322,48 @@</span>
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
      // Control flow
      ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
      ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="udiff-line-modified-removed">-     ControlData WARN_UNUSED_RETURN addLoop(Type signature);</span>
<span class="udiff-line-modified-added">+     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t);</span>
      PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const ExpressionList&amp;);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);</span>
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
      PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const ExpressionList&amp; returnValues);</span>
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const ExpressionList&amp; expressionStack);</span>
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, ExpressionList&amp; expressionStack);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);</span>
      PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
  
      // Calls
      PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="udiff-line-modified-removed">-     PartialResult WARN_UNUSED_RETURN addCallIndirect(const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
<span class="udiff-line-modified-added">+     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
  
<span class="udiff-line-modified-removed">-     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack);</span>
<span class="udiff-line-modified-added">+     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
  
      Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
      void insertConstants();
  
      ALWAYS_INLINE void didKill(ExpressionType) { }
  
  private:
      void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
  
<span class="udiff-line-modified-removed">-     void emitTierUpCheck(uint32_t decrementCount, Origin);</span>
<span class="udiff-line-modified-added">+     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="udiff-line-added">+     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
  
<span class="udiff-line-added">+     void emitWriteBarrierForJSWrapper();</span>
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      B3::Kind memoryKind(B3::Opcode memoryOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
      void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
  
      void unify(const ExpressionType phi, const ExpressionType source);
<span class="udiff-line-modified-removed">-     void unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; stack);</span>
<span class="udiff-line-modified-added">+     void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);</span>
  
      void emitChecksForModOrDiv(B3::Opcode, ExpressionType left, ExpressionType right);
  
      int32_t WARN_UNUSED_RETURN fixupPointerPlusOffset(ExpressionType&amp;, uint32_t);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,21 +371,32 @@</span>
      enum class RestoreCachedStackLimit { No, Yes };
      void restoreWebAssemblyGlobalState(RestoreCachedStackLimit, const MemoryInformation&amp;, Value* instance, Procedure&amp;, BasicBlock*);
  
      Origin origin();
  
<span class="udiff-line-added">+     uint32_t outerLoopIndex() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         if (m_outerLoops.isEmpty())</span>
<span class="udiff-line-added">+             return UINT32_MAX;</span>
<span class="udiff-line-added">+         return m_outerLoops.last();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      FunctionParser&lt;B3IRGenerator&gt;* m_parser { nullptr };
      const ModuleInformation&amp; m_info;
      const MemoryMode m_mode { MemoryMode::BoundsChecking };
      const CompilationMode m_compilationMode { CompilationMode::BBQMode };
      const unsigned m_functionIndex { UINT_MAX };
<span class="udiff-line-modified-removed">-     const TierUpCount* m_tierUp { nullptr };</span>
<span class="udiff-line-modified-added">+     const unsigned m_loopIndexForOSREntry { UINT_MAX };</span>
<span class="udiff-line-added">+     TierUpCount* m_tierUp { nullptr };</span>
  
      Procedure&amp; m_proc;
<span class="udiff-line-added">+     BasicBlock* m_rootBlock { nullptr };</span>
      BasicBlock* m_currentBlock { nullptr };
<span class="udiff-line-added">+     Vector&lt;uint32_t&gt; m_outerLoops;</span>
      Vector&lt;Variable*&gt; m_locals;
      Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.
<span class="udiff-line-added">+     unsigned&amp; m_osrEntryScratchBufferSize;</span>
      HashMap&lt;ValueKey, Value*&gt; m_constantPool;
      InsertionSet m_constantInsertionValues;
      GPRReg m_memoryBaseGPR { InvalidGPRReg };
      GPRReg m_memorySizeGPR { InvalidGPRReg };
      GPRReg m_wasmContextInstanceGPR { InvalidGPRReg };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,10 +409,11 @@</span>
          m_usesInstanceValue = true;
          return m_instanceValue;
      }
  
      uint32_t m_maxNumJSCallArguments { 0 };
<span class="udiff-line-added">+     unsigned m_numImportFunctions;</span>
  };
  
  // Memory accesses in WebAssembly have unsigned 32-bit offsets, whereas they have signed 32-bit offsets in B3.
  int32_t B3IRGenerator::fixupPointerPlusOffset(ExpressionType&amp; ptr, uint32_t offset)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -321,21 +452,25 @@</span>
      patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
          jit.move(param[0].gpr(), wasmContextInstanceGPR);
      });
  }
  
<span class="udiff-line-modified-removed">- B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
<span class="udiff-line-modified-added">+ B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
      : m_info(info)
      , m_mode(mode)
      , m_compilationMode(compilationMode)
      , m_functionIndex(functionIndex)
<span class="udiff-line-added">+     , m_loopIndexForOSREntry(loopIndexForOSREntry)</span>
      , m_tierUp(tierUp)
      , m_proc(procedure)
      , m_unlinkedWasmToWasmCalls(unlinkedWasmToWasmCalls)
<span class="udiff-line-added">+     , m_osrEntryScratchBufferSize(osrEntryScratchBufferSize)</span>
      , m_constantInsertionValues(m_proc)
<span class="udiff-line-added">+     , m_numImportFunctions(info.importFunctionCount())</span>
  {
<span class="udiff-line-modified-removed">-     m_currentBlock = m_proc.addBlock();</span>
<span class="udiff-line-modified-added">+     m_rootBlock = m_proc.addBlock();</span>
<span class="udiff-line-added">+     m_currentBlock = m_rootBlock;</span>
  
      // FIXME we don&#39;t really need to pin registers here if there&#39;s no memory. It makes wasm -&gt; wasm thunks simpler for now. https://bugs.webkit.org/show_bug.cgi?id=166623
      const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
  
      m_memoryBaseGPR = pinnedRegs.baseMemoryPointer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -344,14 +479,12 @@</span>
      m_wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
      if (!Context::useFastTLS())
          m_proc.pinRegister(m_wasmContextInstanceGPR);
  
      if (mode != MemoryMode::Signaling) {
<span class="udiff-line-modified-removed">-         ASSERT(!pinnedRegs.sizeRegisters[0].sizeOffset);</span>
<span class="udiff-line-modified-removed">-         m_memorySizeGPR = pinnedRegs.sizeRegisters[0].sizeRegister;</span>
<span class="udiff-line-removed">-         for (const PinnedSizeRegisterInfo&amp; regInfo : pinnedRegs.sizeRegisters)</span>
<span class="udiff-line-removed">-             m_proc.pinRegister(regInfo.sizeRegister);</span>
<span class="udiff-line-modified-added">+         m_memorySizeGPR = pinnedRegs.sizeRegister;</span>
<span class="udiff-line-modified-added">+         m_proc.pinRegister(m_memorySizeGPR);</span>
      }
  
      if (throwWasmException)
          Thunks::singleton().setThrowWasmException(throwWasmException);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,11 +527,11 @@</span>
          if (!Context::useFastTLS()) {
              // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
              // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
              stackOverflowCheck-&gt;effects.writesPinned = false;
              stackOverflowCheck-&gt;effects.readsPinned = true;
<span class="udiff-line-modified-removed">-             stackOverflowCheck-&gt;resultConstraint = ValueRep::reg(m_wasmContextInstanceGPR);</span>
<span class="udiff-line-modified-added">+             stackOverflowCheck-&gt;resultConstraints = { ValueRep::reg(m_wasmContextInstanceGPR) };</span>
          }
          stackOverflowCheck-&gt;numGPScratchRegisters = 2;
          stackOverflowCheck-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
              const Checked&lt;int32_t&gt; wasmFrameSize = params.proc().frameSize();
              const unsigned minimumParentCheckSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), 1024);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -449,11 +582,14 @@</span>
                  // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
              }
          });
      }
  
<span class="udiff-line-modified-removed">-     emitTierUpCheck(TierUpCount::functionEntryDecrement(), Origin());</span>
<span class="udiff-line-modified-added">+     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), Origin());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="udiff-line-added">+         m_currentBlock = m_proc.addBlock();</span>
  }
  
  void B3IRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, Value* instance, Procedure&amp; proc, BasicBlock* block)
  {
      restoreWasmContextInstance(proc, block, instance);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -467,31 +603,32 @@</span>
  
      if (!!memory) {
          const PinnedRegisterInfo* pinnedRegs = &amp;PinnedRegisterInfo::get();
          RegisterSet clobbers;
          clobbers.set(pinnedRegs-&gt;baseMemoryPointer);
<span class="udiff-line-modified-removed">-         for (auto info : pinnedRegs-&gt;sizeRegisters)</span>
<span class="udiff-line-modified-removed">-             clobbers.set(info.sizeRegister);</span>
<span class="udiff-line-modified-added">+         clobbers.set(pinnedRegs-&gt;sizeRegister);</span>
<span class="udiff-line-modified-added">+         if (!isARM64())</span>
<span class="udiff-line-added">+             clobbers.set(RegisterSet::macroScratchRegisters());</span>
  
          B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Void, origin());
          Effects effects = Effects::none();
          effects.writesPinned = true;
          effects.reads = B3::HeapRange::top();
          patchpoint-&gt;effects = effects;
          patchpoint-&gt;clobber(clobbers);
<span class="udiff-line-added">+         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
  
          patchpoint-&gt;append(instance, ValueRep::SomeRegister);
<span class="udiff-line-removed">- </span>
          patchpoint-&gt;setGenerator([pinnedRegs] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
<span class="udiff-line-added">+             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
              GPRReg baseMemory = pinnedRegs-&gt;baseMemoryPointer;
<span class="udiff-line-modified-removed">-             const auto&amp; sizeRegs = pinnedRegs-&gt;sizeRegisters;</span>
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs.size() &gt;= 1);</span>
<span class="udiff-line-modified-removed">-             ASSERT(!sizeRegs[0].sizeOffset); // The following code assumes we start at 0, and calculates subsequent size registers relative to 0.</span>
<span class="udiff-line-removed">-             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister);</span>
<span class="udiff-line-modified-added">+             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs-&gt;sizeRegister;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), pinnedRegs-&gt;sizeRegister);</span>
              jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemory()), baseMemory);
<span class="udiff-line-modified-removed">-             for (unsigned i = 1; i &lt; sizeRegs.size(); ++i)</span>
<span class="udiff-line-modified-removed">-                 jit.add64(CCallHelpers::TrustedImm32(-sizeRegs[i].sizeOffset), sizeRegs[0].sizeRegister, sizeRegs[i].sizeRegister);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs-&gt;sizeRegister, scratchOrSize);</span>
          });
      }
  }
  
  void B3IRGenerator::emitExceptionCheck(CCallHelpers&amp; jit, ExceptionType type)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -519,19 +656,20 @@</span>
      m_constantInsertionValues.execute(m_proc.at(0));
  }
  
  auto B3IRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
  {
<span class="udiff-line-modified-removed">-     Checked&lt;uint32_t, RecordOverflow&gt; totalBytesChecked = count;</span>
<span class="udiff-line-modified-removed">-     totalBytesChecked += m_locals.size();</span>
<span class="udiff-line-modified-removed">-     uint32_t totalBytes;</span>
<span class="udiff-line-modified-removed">-     WASM_COMPILE_FAIL_IF((totalBytesChecked.safeGet(totalBytes) == CheckedState::DidOverflow) || !m_locals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; locals&quot;);</span>
<span class="udiff-line-modified-added">+     size_t newSize = m_locals.size() + count;</span>
<span class="udiff-line-modified-added">+     ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());</span>
<span class="udiff-line-modified-added">+     ASSERT(newSize &lt;= maxFunctionLocals);</span>
<span class="udiff-line-modified-added">+     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(newSize), &quot;can&#39;t allocate memory for &quot;, newSize, &quot; locals&quot;);</span>
  
      for (uint32_t i = 0; i &lt; count; ++i) {
          Variable* local = m_proc.addVariable(toB3Type(type));
          m_locals.uncheckedAppend(local);
<span class="udiff-line-modified-removed">-         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, constant(toB3Type(type), 0, Origin()));</span>
<span class="udiff-line-modified-added">+         auto val = isSubtype(type, Anyref) ? JSValue::encode(jsNull()) : 0;</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, constant(toB3Type(type), val, Origin()));</span>
      }
      return { };
  }
  
  auto B3IRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -547,10 +685,106 @@</span>
              m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);
          });
      return { };
  }
  
<span class="udiff-line-added">+ auto B3IRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Equal, origin(), value, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), JSValue::encode(jsNull())));</span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(Anyref), origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;getWasmTableElement, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="udiff-line-added">+             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     auto shouldThrow = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int32, origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;setWasmTableElement, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index, value);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="udiff-line-added">+             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), shouldThrow, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int64, origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmRefFunc, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), addConstant(Type::I32, index));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="udiff-line-added">+     uint32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; uint32_t {</span>
<span class="udiff-line-added">+         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(doSize, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableGrow, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), fill, delta);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ auto B3IRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableFill, B3CCallPtrTag)),</span>
<span class="udiff-line-added">+         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), offset, fill, count);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="udiff-line-added">+             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return { };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  auto B3IRGenerator::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      ASSERT(m_locals[index]);
      result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin(), m_locals[index]);
      return { };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -630,13 +864,69 @@</span>
  auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
  {
      ASSERT(toB3Type(m_info.globals[index].type) == value-&gt;type());
      Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
      m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (isSubtype(m_info.globals[index].type, Anyref))</span>
<span class="udiff-line-added">+         emitWriteBarrierForJSWrapper();</span>
<span class="udiff-line-added">+ </span>
      return { };
  }
  
<span class="udiff-line-added">+ inline void B3IRGenerator::emitWriteBarrierForJSWrapper()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     Value* cell = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfOwner()));</span>
<span class="udiff-line-added">+     Value* cellState = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="udiff-line-added">+     Value* vm = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), cell, safeCast&lt;int32_t&gt;(JSWebAssemblyInstance::offsetOfVM()));</span>
<span class="udiff-line-added">+     Value* threshold = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapBarrierThreshold()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BasicBlock* fenceCheckPath = m_proc.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* fencePath = m_proc.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* doSlowPath = m_proc.addBlock();</span>
<span class="udiff-line-added">+     BasicBlock* continuation = m_proc.addBlock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellState, threshold),</span>
<span class="udiff-line-added">+         FrequentedBlock(continuation), FrequentedBlock(fenceCheckPath, FrequencyClass::Rare));</span>
<span class="udiff-line-added">+     fenceCheckPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     m_currentBlock = fenceCheckPath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value* shouldFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapMutatorShouldBeFenced()));</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="udiff-line-added">+         shouldFence,</span>
<span class="udiff-line-added">+         FrequentedBlock(fencePath), FrequentedBlock(doSlowPath));</span>
<span class="udiff-line-added">+     fencePath-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     m_currentBlock = fencePath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     B3::PatchpointValue* doFence = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());</span>
<span class="udiff-line-added">+     doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         jit.memoryFence();</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value* cellStateLoadAfterFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellStateLoadAfterFence, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), blackThreshold)),</span>
<span class="udiff-line-added">+         FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));</span>
<span class="udiff-line-added">+     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     m_currentBlock = doSlowPath;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="udiff-line-added">+         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(writeBarrier, B3CCallPtrTag));</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);</span>
<span class="udiff-line-added">+     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     m_currentBlock = continuation;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  inline Value* B3IRGenerator::emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOperation)
  {
      ASSERT(m_memoryBaseGPR);
  
      switch (m_mode) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -898,33 +1188,31 @@</span>
  B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
  {
      return constant(toB3Type(type), value);
  }
  
<span class="udiff-line-modified-removed">- void B3IRGenerator::emitTierUpCheck(uint32_t decrementCount, Origin origin)</span>
<span class="udiff-line-modified-added">+ void B3IRGenerator::emitEntryTierUpCheck(int32_t incrementCount, Origin origin)</span>
  {
      if (!m_tierUp)
          return;
  
      ASSERT(m_tierUp);
<span class="udiff-line-modified-removed">-     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(m_tierUp), origin);</span>
<span class="udiff-line-removed">-     Value* oldCountDown = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin, countDownLocation);</span>
<span class="udiff-line-removed">-     Value* newCountDown = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Sub, origin, oldCountDown, constant(Int32, decrementCount, origin));</span>
<span class="udiff-line-removed">-     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin, newCountDown, countDownLocation);</span>
<span class="udiff-line-modified-added">+     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>
  
      PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
      Effects effects = Effects::none();
      // FIXME: we should have a more precise heap range for the tier up count.
      effects.reads = B3::HeapRange::top();
      effects.writes = B3::HeapRange::top();
      patch-&gt;effects = effects;
<span class="udiff-line-added">+     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
  
<span class="udiff-line-modified-removed">-     patch-&gt;append(newCountDown, ValueRep::SomeRegister);</span>
<span class="udiff-line-removed">-     patch-&gt;append(oldCountDown, ValueRep::SomeRegister);</span>
<span class="udiff-line-modified-added">+     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<span class="udiff-line-modified-removed">-         MacroAssembler::Jump tierUp = jit.branch32(MacroAssembler::Above, params[0].gpr(), params[1].gpr());</span>
<span class="udiff-line-modified-removed">-         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="udiff-line-modified-added">+         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-modified-added">+         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="udiff-line-added">+         CCallHelpers::Label tierUpResume = jit.label();</span>
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
              const unsigned extraPaddingBytes = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -937,26 +1225,127 @@</span>
  
              ScratchRegisterAllocator::restoreRegistersFromStackForCall(jit, registersToSpill, RegisterSet(), numberOfStackBytesUsedForRegisterPreservation, extraPaddingBytes);
              jit.jump(tierUpResume);
  
              jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGTierUpThunkGenerator).code()));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGEntryTierUpThunkGenerator).code()));</span>
              });
          });
      });
  }
  
<span class="udiff-line-modified-removed">- B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature)</span>
<span class="udiff-line-modified-added">+ void B3IRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!m_tierUp)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(m_tierUp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);</span>
<span class="udiff-line-added">+     m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);</span>
<span class="udiff-line-added">+     m_tierUp-&gt;outerLoops().append(outerLoopIndex);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Vector&lt;ExpressionType&gt; stackmap;</span>
<span class="udiff-line-added">+     Vector&lt;B3::Type&gt; types;</span>
<span class="udiff-line-added">+     for (auto&amp; local : m_locals) {</span>
<span class="udiff-line-added">+         ExpressionType result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin, local);</span>
<span class="udiff-line-added">+         stackmap.append(result);</span>
<span class="udiff-line-added">+         types.append(result-&gt;type());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     for (unsigned i = 0; i &lt; expressionStack.size(); ++i) {</span>
<span class="udiff-line-added">+         ExpressionType result = expressionStack.at(i);</span>
<span class="udiff-line-added">+         stackmap.append(result);</span>
<span class="udiff-line-added">+         types.append(result-&gt;type());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);</span>
<span class="udiff-line-added">+     Effects effects = Effects::none();</span>
<span class="udiff-line-added">+     // FIXME: we should have a more precise heap range for the tier up count.</span>
<span class="udiff-line-added">+     effects.reads = B3::HeapRange::top();</span>
<span class="udiff-line-added">+     effects.writes = B3::HeapRange::top();</span>
<span class="udiff-line-added">+     effects.exitsSideways = true;</span>
<span class="udiff-line-added">+     patch-&gt;effects = effects;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="udiff-line-added">+     RegisterSet clobberLate;</span>
<span class="udiff-line-added">+     clobberLate.add(GPRInfo::argumentGPR0);</span>
<span class="udiff-line-added">+     patch-&gt;clobberLate(clobberLate);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>
<span class="udiff-line-added">+     patch-&gt;appendVectorWithRep(stackmap, ValueRep::ColdAny);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());</span>
<span class="udiff-line-added">+     static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);</span>
<span class="udiff-line-added">+     static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);</span>
<span class="udiff-line-added">+     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="udiff-line-added">+         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-added">+         CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));</span>
<span class="udiff-line-added">+         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="udiff-line-added">+         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);</span>
<span class="udiff-line-added">+         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="udiff-line-added">+             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
<span class="udiff-line-added">+         OSREntryData* osrEntryDataPtr = &amp;osrEntryData;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="udiff-line-added">+             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="udiff-line-added">+             forceOSREntry.link(&amp;jit);</span>
<span class="udiff-line-added">+             tierUp.link(&amp;jit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
<span class="udiff-line-added">+             jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);</span>
<span class="udiff-line-added">+             jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature, const Stack&amp; stack, uint32_t loopIndex)</span>
  {
      BasicBlock* body = m_proc.addBlock();
      BasicBlock* continuation = m_proc.addBlock();
  
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
<span class="udiff-line-added">+     if (loopIndex == m_loopIndexForOSREntry) {</span>
<span class="udiff-line-added">+         m_currentBlock = m_rootBlock;</span>
<span class="udiff-line-added">+         m_osrEntryScratchBufferSize = m_locals.size() + stack.size();</span>
<span class="udiff-line-added">+         Value* pointer = m_rootBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(m_proc, Origin(), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto loadFromScratchBuffer = [&amp;] (B3::Type type, unsigned index) {</span>
<span class="udiff-line-added">+             size_t offset = sizeof(uint64_t) * index;</span>
<span class="udiff-line-added">+             switch (type.kind()) {</span>
<span class="udiff-line-added">+             case B3::Int32:</span>
<span class="udiff-line-added">+                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), pointer, offset);</span>
<span class="udiff-line-added">+             case B3::Int64:</span>
<span class="udiff-line-added">+                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), pointer, offset);</span>
<span class="udiff-line-added">+             case B3::Float:</span>
<span class="udiff-line-added">+                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Float, origin(), pointer, offset);</span>
<span class="udiff-line-added">+             case B3::Double:</span>
<span class="udiff-line-added">+                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Double, origin(), pointer, offset);</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         unsigned indexInBuffer = 0;</span>
<span class="udiff-line-added">+         for (auto&amp; local : m_locals)</span>
<span class="udiff-line-added">+             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, loadFromScratchBuffer(local-&gt;type(), indexInBuffer++));</span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; stack.size(); ++i) {</span>
<span class="udiff-line-added">+             auto* variable = stack.variableAt(i);</span>
<span class="udiff-line-added">+             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), variable, loadFromScratchBuffer(variable-&gt;type(), indexInBuffer++));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);</span>
<span class="udiff-line-added">+         body-&gt;addPredecessor(m_currentBlock);</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-added">+     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="udiff-line-added">+     m_outerLoops.append(loopIndex);</span>
      m_currentBlock = body;
<span class="udiff-line-modified-removed">-     emitTierUpCheck(TierUpCount::loopDecrement(), origin());</span>
<span class="udiff-line-modified-added">+     emitLoopTierUpCheck(TierUpCount::loopIncrement(), stack, loopIndex, outerLoopIndex, origin());</span>
  
      return ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);
  }
  
  B3IRGenerator::ControlData B3IRGenerator::addTopLevel(Type signature)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -985,11 +1374,11 @@</span>
      m_currentBlock = taken;
      result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto B3IRGenerator::addElse(ControlData&amp; data, const ExpressionList&amp; currentStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto B3IRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult</span>
  {
      unifyValuesWithBlock(currentStack, data.result);
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      return addElseToUnreachable(data);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1010,11 +1399,11 @@</span>
      else
          m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin());
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const ExpressionList&amp; returnValues) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult</span>
  {
      unifyValuesWithBlock(returnValues, data.resultForBranch());
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1030,11 +1419,11 @@</span>
      }
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      for (size_t i = 0; i &lt; targets.size(); ++i)
          unifyValuesWithBlock(expressionStack, targets[i]-&gt;resultForBranch());
      unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1044,18 +1433,21 @@</span>
          switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto B3IRGenerator::endBlock(ControlEntry&amp; entry, ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto B3IRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
  
      unifyValuesWithBlock(expressionStack, data.result);
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      data.continuation-&gt;addPredecessor(m_currentBlock);
  
<span class="udiff-line-added">+     if (data.type() == BlockType::Loop)</span>
<span class="udiff-line-added">+         m_outerLoops.removeLast();</span>
<span class="udiff-line-added">+ </span>
      return addEndToUnreachable(entry);
  }
  
  
  auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1073,11 +1465,11 @@</span>
          entry.enclosedExpressionStack.append(result);
      }
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
      if (data.type() == BlockType::TopLevel)
<span class="udiff-line-modified-removed">-         return addReturn(entry.controlData, entry.enclosedExpressionStack);</span>
<span class="udiff-line-modified-added">+         return addReturn(entry.controlData, entry.enclosedExpressionStack.convertToExpressionList());</span>
  
      return { };
  }
  
  auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1174,11 +1566,11 @@</span>
      }
  
      return { };
  }
  
<span class="udiff-line-modified-removed">- auto B3IRGenerator::addCallIndirect(const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="udiff-line-modified-added">+ auto B3IRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1191,15 +1583,15 @@</span>
      ExpressionType instancesBuffer;
      ExpressionType callableFunctionBufferLength;
      ExpressionType mask;
      {
          ExpressionType table = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="udiff-line-modified-removed">-             instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTable()));</span>
<span class="udiff-line-modified-added">+             instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)));</span>
          callableFunctionBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="udiff-line-modified-removed">-             table, safeCast&lt;int32_t&gt;(Table::offsetOfFunctions()));</span>
<span class="udiff-line-modified-added">+             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfFunctions()));</span>
          instancesBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="udiff-line-modified-removed">-             table, safeCast&lt;int32_t&gt;(Table::offsetOfInstances()));</span>
<span class="udiff-line-modified-added">+             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfInstances()));</span>
          callableFunctionBufferLength = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
              table, safeCast&lt;int32_t&gt;(Table::offsetOfLength()));
          mask = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(),
              m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
                  table, safeCast&lt;int32_t&gt;(Table::offsetOfMask())));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1275,29 +1667,32 @@</span>
          // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
          patchpoint-&gt;clobber(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
          patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
          patchpoint-&gt;append(newContextInstance, ValueRep::SomeRegister);
          patchpoint-&gt;append(instanceValue(), ValueRep::SomeRegister);
<span class="udiff-line-added">+         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
<span class="udiff-line-added">+ </span>
          patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              GPRReg newContextInstance = params[0].gpr();
              GPRReg oldContextInstance = params[1].gpr();
              const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
<span class="udiff-line-removed">-             const auto&amp; sizeRegs = pinnedRegs.sizeRegisters;</span>
              GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
              ASSERT(newContextInstance != baseMemory);
              jit.loadPtr(CCallHelpers::Address(oldContextInstance, Instance::offsetOfCachedStackLimit()), baseMemory);
              jit.storePtr(baseMemory, CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedStackLimit()));
              jit.storeWasmContextInstance(newContextInstance);
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs[0].sizeRegister != baseMemory);</span>
<span class="udiff-line-modified-added">+             ASSERT(pinnedRegs.sizeRegister != baseMemory);</span>
              // FIXME: We should support more than one memory size register
              //   see: https://bugs.webkit.org/show_bug.cgi?id=162952
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs.size() == 1);</span>
<span class="udiff-line-modified-removed">-             ASSERT(sizeRegs[0].sizeRegister != newContextInstance);</span>
<span class="udiff-line-modified-removed">-             ASSERT(!sizeRegs[0].sizeOffset);</span>
<span class="udiff-line-modified-removed">-             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister); // Memory size.</span>
<span class="udiff-line-modified-added">+             ASSERT(pinnedRegs.sizeRegister != newContextInstance);</span>
<span class="udiff-line-modified-added">+             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs.sizeRegister;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister); // Memory size.</span>
              jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemory()), baseMemory); // Memory::void*.
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs.sizeRegister, scratchOrSize);</span>
          });
          doContextSwitch-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
          m_currentBlock = continuation;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1334,26 +1729,19 @@</span>
  void B3IRGenerator::unify(const ExpressionType phi, const ExpressionType source)
  {
      m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), source, phi);
  }
  
<span class="udiff-line-modified-removed">- void B3IRGenerator::unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; result)</span>
<span class="udiff-line-modified-added">+ void B3IRGenerator::unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; result)</span>
  {
      ASSERT(result.size() &lt;= resultStack.size());
  
      for (size_t i = 0; i &lt; result.size(); ++i)
<span class="udiff-line-modified-removed">-         unify(result[result.size() - 1 - i], resultStack[resultStack.size() - 1 - i]);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void dumpExpressionStack(const CommaPrinter&amp; comma, const B3IRGenerator::ExpressionList&amp; expressionStack)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="udiff-line-removed">-     for (const auto&amp; expression : expressionStack)</span>
<span class="udiff-line-removed">-         dataLog(comma, *expression);</span>
<span class="udiff-line-modified-added">+         unify(result[result.size() - 1 - i], resultStack.at(resultStack.size() - 1 - i));</span>
  }
  
<span class="udiff-line-modified-removed">- void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack)</span>
<span class="udiff-line-modified-added">+ void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack)</span>
  {
      dataLogLn(&quot;Constants:&quot;);
      for (const auto&amp; constant : m_constantPool)
          dataLogLn(deepDump(m_proc, constant.value));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1362,12 +1750,11 @@</span>
      dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
      dataLogLn(&quot;Control stack:&quot;);
      ASSERT(controlStack.size());
      for (size_t i = controlStack.size(); i--;) {
          dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<span class="udiff-line-modified-removed">-         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="udiff-line-removed">-         dumpExpressionStack(comma, *expressionStack);</span>
<span class="udiff-line-modified-added">+         expressionStack-&gt;dump();</span>
          expressionStack = &amp;controlStack[i].enclosedExpressionStack;
          dataLogLn();
      }
      dataLogLn();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,16 +1764,16 @@</span>
      OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
      ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
      return bitwise_cast&lt;Origin&gt;(origin);
  }
  
<span class="udiff-line-modified-removed">- Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
<span class="udiff-line-modified-added">+ Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, uint32_t loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
  {
<span class="udiff-line-modified-removed">-     auto result = std::make_unique&lt;InternalFunction&gt;();</span>
<span class="udiff-line-modified-added">+     auto result = makeUnique&lt;InternalFunction&gt;();</span>
  
<span class="udiff-line-modified-removed">-     compilationContext.embedderEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-removed">-     compilationContext.wasmEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-added">+     compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
<span class="udiff-line-modified-added">+     compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
  
      Procedure procedure;
  
      procedure.setOriginPrinter([] (PrintStream&amp; out, Origin origin) {
          if (origin.data())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1398,14 +1785,14 @@</span>
      // don&#39;t strictly need to run Air::reportUsedRegisters(), which saves a bit of CPU time at
      // optLevel=1.
      procedure.setNeedsUsedRegisters(false);
  
      procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
<span class="udiff-line-modified-removed">-         ? Options::webAssemblyBBQOptimizationLevel()</span>
<span class="udiff-line-modified-added">+         ? Options::webAssemblyBBQB3OptimizationLevel()</span>
          : Options::webAssemblyOMGOptimizationLevel());
  
<span class="udiff-line-modified-removed">-     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, mode, compilationMode, functionIndex, tierUp, throwWasmException);</span>
<span class="udiff-line-modified-added">+     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, mode, compilationMode, functionIndex, loopIndexForOSREntry, tierUp, throwWasmException);</span>
      FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
      irGenerator.insertConstants();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1422,11 +1809,11 @@</span>
          B3::generate(procedure, *compilationContext.wasmEntrypointJIT);
          compilationContext.wasmEntrypointByproducts = procedure.releaseByproducts();
          result-&gt;entrypoint.calleeSaveRegisters = procedure.calleeSaveRegisterAtOffsetList();
      }
  
<span class="udiff-line-modified-removed">-     return WTFMove(result);</span>
<span class="udiff-line-modified-added">+     return result;</span>
  }
  
  // Custom wasm ops. These are the ones too messy to do in wasm.json.
  
  void B3IRGenerator::emitChecksForModOrDiv(B3::Opcode operation, ExpressionType left, ExpressionType right)
</pre>
<center><a href="WasmAirIRGenerator.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>