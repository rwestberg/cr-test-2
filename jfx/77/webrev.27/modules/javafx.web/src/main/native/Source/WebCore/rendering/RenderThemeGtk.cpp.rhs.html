<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007 Apple Inc.
   3  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
   4  * Copyright (C) 2008 Collabora Ltd.
   5  * Copyright (C) 2009 Kenneth Rohde Christiansen
   6  * Copyright (C) 2010 Igalia S.L.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderThemeGtk.h&quot;
  27 
  28 #include &quot;CSSValueKeywords.h&quot;
  29 #include &quot;FileList.h&quot;
  30 #include &quot;FloatRoundedRect.h&quot;
  31 #include &quot;FontDescription.h&quot;
  32 #include &quot;GRefPtrGtk.h&quot;
  33 #include &quot;GUniquePtrGtk.h&quot;
  34 #include &quot;Gradient.h&quot;
  35 #include &quot;GraphicsContext.h&quot;
<a name="1" id="anc1"></a>
  36 #include &quot;HTMLInputElement.h&quot;
  37 #include &quot;HTMLMediaElement.h&quot;
  38 #include &quot;LocalizedStrings.h&quot;
  39 #include &quot;MediaControlElements.h&quot;
  40 #include &quot;Page.h&quot;
  41 #include &quot;PaintInfo.h&quot;
  42 #include &quot;PlatformContextCairo.h&quot;
  43 #include &quot;RenderBox.h&quot;
  44 #include &quot;RenderObject.h&quot;
  45 #include &quot;RenderProgress.h&quot;
  46 #include &quot;RenderThemeWidget.h&quot;
  47 #include &quot;ScrollbarThemeGtk.h&quot;
  48 #include &quot;StringTruncator.h&quot;
  49 #include &quot;TimeRanges.h&quot;
  50 #include &quot;UserAgentScripts.h&quot;
  51 #include &quot;UserAgentStyleSheets.h&quot;
  52 #include &lt;cmath&gt;
  53 #include &lt;gdk/gdk.h&gt;
  54 #include &lt;glib.h&gt;
  55 #include &lt;gtk/gtk.h&gt;
  56 #include &lt;wtf/FileSystem.h&gt;
  57 #include &lt;wtf/glib/GRefPtr.h&gt;
  58 #include &lt;wtf/glib/GUniquePtr.h&gt;
  59 #include &lt;wtf/text/CString.h&gt;
  60 #include &lt;wtf/text/StringBuilder.h&gt;
  61 
  62 namespace WebCore {
  63 
  64 RenderTheme&amp; RenderTheme::singleton()
  65 {
  66     static NeverDestroyed&lt;RenderThemeGtk&gt; theme;
  67     return theme;
  68 }
  69 
  70 static double getScreenDPI()
  71 {
  72     // FIXME: Really this should be the widget&#39;s screen.
  73     GdkScreen* screen = gdk_screen_get_default();
  74     if (!screen)
  75         return 96; // Default to 96 DPI.
  76 
  77     float dpi = gdk_screen_get_resolution(screen);
  78     if (dpi &lt;= 0)
  79         return 96;
  80     return dpi;
  81 }
  82 
  83 void RenderThemeGtk::updateCachedSystemFontDescription(CSSValueID, FontCascadeDescription&amp; fontDescription) const
  84 {
  85     GtkSettings* settings = gtk_settings_get_default();
  86     if (!settings)
  87         return;
  88 
  89     // This will be a font selection string like &quot;Sans 10&quot; so we cannot use it as the family name.
  90     GUniqueOutPtr&lt;gchar&gt; fontName;
  91     g_object_get(settings, &quot;gtk-font-name&quot;, &amp;fontName.outPtr(), nullptr);
  92     if (!fontName || !fontName.get()[0])
  93         return;
  94 
  95     PangoFontDescription* pangoDescription = pango_font_description_from_string(fontName.get());
  96     if (!pangoDescription)
  97         return;
  98 
  99     fontDescription.setOneFamily(pango_font_description_get_family(pangoDescription));
 100 
 101     int size = pango_font_description_get_size(pangoDescription) / PANGO_SCALE;
 102     // If the size of the font is in points, we need to convert it to pixels.
 103     if (!pango_font_description_get_size_is_absolute(pangoDescription))
 104         size = size * (getScreenDPI() / 72.0);
 105 
 106     fontDescription.setSpecifiedSize(size);
 107     fontDescription.setIsAbsoluteSize(true);
 108     fontDescription.setWeight(normalWeightValue());
 109     fontDescription.setItalic(FontSelectionValue());
 110     pango_font_description_free(pangoDescription);
 111 }
 112 
 113 #if ENABLE(DATALIST_ELEMENT)
 114 IntSize RenderThemeGtk::sliderTickSize() const
 115 {
 116     // FIXME: We need to set this to the size of one tick mark.
 117     return IntSize(0, 0);
 118 }
 119 
 120 int RenderThemeGtk::sliderTickOffsetFromTrackCenter() const
 121 {
 122     // FIXME: We need to set this to the position of the tick marks.
 123     return 0;
 124 }
 125 #endif
 126 
<a name="2" id="anc2"></a>

















 127 enum RenderThemePart {
 128     Entry,
 129     EntrySelection,
 130     EntryIconLeft,
 131     EntryIconRight,
 132     Button,
 133     CheckButton,
 134     RadioButton,
 135     ComboBox,
 136     ComboBoxButton,
 137     ComboBoxArrow,
 138     Scale,
 139     ScaleTrough,
 140     ScaleSlider,
 141     ProgressBar,
 142     ProgressBarTrough,
 143     ProgressBarProgress,
 144     ListBox,
 145     SpinButton,
 146     SpinButtonUpButton,
 147     SpinButtonDownButton,
 148 #if ENABLE(VIDEO)
 149     MediaButton,
 150 #endif
<a name="3" id="anc3"></a><span class="line-added"> 151     Window,</span>
 152 };
 153 
<a name="4" id="anc4"></a>





























































































































 154 #if ENABLE(VIDEO)
 155 static bool nodeHasPseudo(Node&amp; node, const char* pseudo)
 156 {
 157     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).pseudo() == pseudo;
 158 }
 159 
 160 static bool nodeHasClass(Node* node, const char* className)
 161 {
 162     if (!is&lt;Element&gt;(*node))
 163         return false;
 164 
 165     Element&amp; element = downcast&lt;Element&gt;(*node);
 166 
 167     if (!element.hasClass())
 168         return false;
 169 
 170     return element.classNames().contains(className);
 171 }
 172 #endif // ENABLE(VIDEO)
 173 
 174 RenderThemeGtk::~RenderThemeGtk() = default;
 175 
 176 static bool supportsFocus(ControlPart appearance)
 177 {
 178     switch (appearance) {
 179     case PushButtonPart:
 180     case ButtonPart:
 181     case TextFieldPart:
 182     case TextAreaPart:
 183     case SearchFieldPart:
 184     case MenulistPart:
 185     case RadioPart:
 186     case CheckboxPart:
 187     case SliderHorizontalPart:
 188     case SliderVerticalPart:
 189         return true;
 190     default:
 191         return false;
 192     }
 193 }
 194 
 195 bool RenderThemeGtk::supportsFocusRing(const RenderStyle&amp; style) const
 196 {
 197     return supportsFocus(style.appearance());
 198 }
 199 
 200 bool RenderThemeGtk::controlSupportsTints(const RenderObject&amp; o) const
 201 {
 202     return isEnabled(o);
 203 }
 204 
 205 int RenderThemeGtk::baselinePosition(const RenderBox&amp; box) const
 206 {
 207     // FIXME: This strategy is possibly incorrect for the GTK+ port.
 208     if (box.style().appearance() == CheckboxPart || box.style().appearance() == RadioPart)
 209         return box.marginTop() + box.height() - 2;
 210     return RenderTheme::baselinePosition(box);
 211 }
 212 
<a name="5" id="anc5"></a>
 213 void RenderThemeGtk::adjustRepaintRect(const RenderObject&amp;, FloatRect&amp;)
 214 {
 215 }
 216 static GtkStateFlags themePartStateFlags(const RenderThemeGtk&amp; theme, RenderThemePart themePart, const RenderObject&amp; renderObject)
 217 {
 218     unsigned stateFlags = 0;
 219     switch (renderObject.style().direction()) {
 220     case TextDirection::RTL:
 221         stateFlags |= GTK_STATE_FLAG_DIR_RTL;
 222         break;
 223     case TextDirection::LTR:
 224         stateFlags |= GTK_STATE_FLAG_DIR_LTR;
 225         break;
 226     }
 227 
 228     if (!theme.isEnabled(renderObject) || (themePart == Entry &amp;&amp; theme.isReadOnlyControl(renderObject)))
 229         stateFlags |= GTK_STATE_FLAG_INSENSITIVE;
 230     else {
 231         if (theme.isHovered(renderObject))
 232             stateFlags |= GTK_STATE_FLAG_PRELIGHT;
 233         if (theme.isFocused(renderObject))
 234             stateFlags |= GTK_STATE_FLAG_FOCUSED;
 235     }
 236 
 237     switch (themePart) {
 238     case CheckButton:
 239     case RadioButton:
 240         if (theme.isChecked(renderObject))
 241             stateFlags |= GTK_STATE_FLAG_CHECKED;
 242         if (theme.isIndeterminate(renderObject))
 243             stateFlags |= GTK_STATE_FLAG_INCONSISTENT;
 244         if (theme.isPressed(renderObject))
 245             stateFlags |= GTK_STATE_FLAG_SELECTED;
 246         break;
 247     case Button:
 248     case ComboBoxButton:
 249     case ScaleSlider:
 250     case EntryIconLeft:
 251     case EntryIconRight:
 252 #if ENABLE(VIDEO)
 253     case MediaButton:
 254 #endif
 255         if (theme.isPressed(renderObject))
 256             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 257         break;
 258     case SpinButtonUpButton:
 259         if (theme.isPressed(renderObject) &amp;&amp; theme.isSpinUpButtonPartPressed(renderObject))
 260             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 261         if (theme.isHovered(renderObject) &amp;&amp; !theme.isSpinUpButtonPartHovered(renderObject))
 262             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 263         break;
 264     case SpinButtonDownButton:
 265         if (theme.isPressed(renderObject) &amp;&amp; !theme.isSpinUpButtonPartPressed(renderObject))
 266             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 267         if (theme.isHovered(renderObject) &amp;&amp; theme.isSpinUpButtonPartHovered(renderObject))
 268             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 269         break;
 270     default:
 271         break;
 272     }
 273 
 274     return static_cast&lt;GtkStateFlags&gt;(stateFlags);
 275 }
<a name="6" id="anc6"></a>











































































 276 
 277 void RenderThemeGtk::adjustButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 278 {
 279     // Some layout tests check explicitly that buttons ignore line-height.
 280     if (style.appearance() == PushButtonPart)
 281         style.setLineHeight(RenderStyle::initialLineHeight());
 282 }
 283 
 284 static void shrinkToMinimumSizeAndCenterRectangle(FloatRect&amp; rect, const IntSize&amp; minSize)
 285 {
 286     if (rect.width() &gt; minSize.width()) {
 287         rect.inflateX(-(rect.width() - minSize.width()) / 2);
 288         rect.setWidth(minSize.width()); // In case rect.width() was equal to minSize.width() + 1.
 289     }
 290 
 291     if (rect.height() &gt; minSize.height()) {
 292         rect.inflateY(-(rect.height() - minSize.height()) / 2);
 293         rect.setHeight(minSize.height()); // In case rect.height() was equal to minSize.height() + 1.
 294     }
 295 }
 296 
<a name="7" id="anc7"></a>
 297 static void setToggleSize(RenderThemePart themePart, RenderStyle&amp; style)
 298 {
 299     ASSERT(themePart == CheckButton || themePart == RadioButton);
 300 
 301     // The width and height are both specified, so we shouldn&#39;t change them.
 302     if (!style.width().isIntrinsicOrAuto() &amp;&amp; !style.height().isAuto())
 303         return;
 304 
 305     auto&amp; toggleWidget = static_cast&lt;RenderThemeToggleButton&amp;&gt;(RenderThemeWidget::getOrCreate(themePart == CheckButton ? RenderThemeWidget::Type::CheckButton : RenderThemeWidget::Type::RadioButton));
 306     toggleWidget.button().setState(GTK_STATE_FLAG_NORMAL);
 307     toggleWidget.toggle().setState(GTK_STATE_FLAG_NORMAL);
 308     IntSize preferredSize = toggleWidget.button().preferredSize();
 309     preferredSize = preferredSize.expandedTo(toggleWidget.toggle().preferredSize());
 310 
 311     if (style.width().isIntrinsicOrAuto())
 312         style.setWidth(Length(preferredSize.width(), Fixed));
 313 
 314     if (style.height().isAuto())
 315         style.setHeight(Length(preferredSize.height(), Fixed));
 316 }
 317 
 318 static void paintToggle(const RenderThemeGtk* theme, RenderThemePart themePart, const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; fullRect)
 319 {
 320     ASSERT(themePart == CheckButton || themePart == RadioButton);
 321 
 322     auto&amp; toggleWidget = static_cast&lt;RenderThemeToggleButton&amp;&gt;(RenderThemeWidget::getOrCreate(themePart == CheckButton ? RenderThemeWidget::Type::CheckButton : RenderThemeWidget::Type::RadioButton));
 323     auto toggleState = themePartStateFlags(*theme, themePart, renderObject);
 324     toggleWidget.button().setState(toggleState);
 325     toggleWidget.toggle().setState(toggleState);
 326 
 327     FloatRect rect = fullRect;
 328     // Some themes do not render large toggle buttons properly, so we simply
 329     // shrink the rectangle back down to the default size and then center it
 330     // in the full toggle button region. The reason for not simply forcing toggle
 331     // buttons to be a smaller size is that we don&#39;t want to break site layouts.
 332     IntSize preferredSize = toggleWidget.button().preferredSize();
 333     preferredSize = preferredSize.expandedTo(toggleWidget.toggle().preferredSize());
 334     shrinkToMinimumSizeAndCenterRectangle(rect, preferredSize);
 335     toggleWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 336     toggleWidget.toggle().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 337 
 338     if (theme-&gt;isFocused(renderObject))
 339         toggleWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 340 }
<a name="8" id="anc8"></a>




































































 341 
 342 void RenderThemeGtk::setCheckboxSize(RenderStyle&amp; style) const
 343 {
 344     setToggleSize(CheckButton, style);
 345 }
 346 
 347 bool RenderThemeGtk::paintCheckbox(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 348 {
 349     paintToggle(this, CheckButton, renderObject, paintInfo, rect);
 350     return false;
 351 }
 352 
 353 void RenderThemeGtk::setRadioSize(RenderStyle&amp; style) const
 354 {
 355     setToggleSize(RadioButton, style);
 356 }
 357 
 358 bool RenderThemeGtk::paintRadio(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 359 {
 360     paintToggle(this, RadioButton, renderObject, paintInfo, rect);
 361     return false;
 362 }
 363 
<a name="9" id="anc9"></a>
 364 bool RenderThemeGtk::paintButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 365 {
 366     auto&amp; buttonWidget = static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(isDefault(renderObject) ? RenderThemeWidget::Type::ButtonDefault : RenderThemeWidget::Type::Button));
 367     buttonWidget.button().setState(themePartStateFlags(*this, Button, renderObject));
 368     buttonWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 369     if (isFocused(renderObject))
 370         buttonWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 371     return false;
 372 }
<a name="10" id="anc10"></a>










































































 373 
 374 static Color menuListColor(const Element* element)
 375 {
<a name="11" id="anc11"></a>
 376     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 377     GtkStateFlags state = element-&gt;isDisabledFormControl() ? GTK_STATE_FLAG_INSENSITIVE : GTK_STATE_FLAG_NORMAL;
 378     comboWidget.comboBox().setState(state);
 379     comboWidget.button().setState(state);
 380     return comboWidget.button().color();
<a name="12" id="anc12"></a>








 381 }
 382 
 383 void RenderThemeGtk::adjustMenuListStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const
 384 {
 385     // The tests check explicitly that select menu buttons ignore line height.
 386     style.setLineHeight(RenderStyle::initialLineHeight());
 387 
 388     // We cannot give a proper rendering when border radius is active, unfortunately.
 389     style.resetBorderRadius();
 390 
 391     if (element)
 392         style.setColor(menuListColor(element));
 393 }
 394 
 395 void RenderThemeGtk::adjustMenuListButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 396 {
 397     adjustMenuListStyle(styleResolver, style, e);
 398 }
 399 
<a name="13" id="anc13"></a>
 400 /*
 401  * GtkComboBox gadgets tree
 402  *
 403  * combobox
 404  * ├── box.linked
 405  * │   ╰── button.combo
 406  * │       ╰── box
 407  * │           ├── cellview
 408  * │           ╰── arrow
 409  * ╰── window.popup
 410  */
 411 LengthBox RenderThemeGtk::popupInternalPaddingBox(const RenderStyle&amp; style) const
 412 {
 413     if (style.appearance() == NoControlPart)
 414         return LengthBox(0);
 415 
 416     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 417     comboWidget.comboBox().setState(GTK_STATE_FLAG_NORMAL);
 418     comboWidget.button().setState(GTK_STATE_FLAG_NORMAL);
 419     comboWidget.arrow().setState(GTK_STATE_FLAG_NORMAL);
 420     GtkBorder comboContentsBox = comboWidget.comboBox().contentsBox();
 421     GtkBorder boxContentsBox = comboWidget.box().contentsBox();
 422     GtkBorder buttonContentsBox = comboWidget.button().contentsBox();
 423     GtkBorder buttonBoxContentsBox = comboWidget.buttonBox().contentsBox();
 424     GtkBorder padding;
 425     padding.left = comboContentsBox.left + boxContentsBox.left + buttonContentsBox.left + buttonBoxContentsBox.left;
 426     padding.right = comboContentsBox.right + boxContentsBox.right + buttonContentsBox.right + buttonBoxContentsBox.right;
 427     padding.top = comboContentsBox.top + boxContentsBox.top + buttonContentsBox.top + buttonBoxContentsBox.top;
 428     padding.bottom = comboContentsBox.bottom + boxContentsBox.bottom + buttonContentsBox.bottom + buttonBoxContentsBox.bottom;
 429 
 430     auto arrowSize = comboWidget.arrow().preferredSize();
 431     return LengthBox(padding.top, padding.right + (style.direction() == TextDirection::LTR ? arrowSize.width() : 0),
 432         padding.bottom, padding.left + (style.direction() == TextDirection::RTL ? arrowSize.width() : 0));
 433 }
 434 
 435 bool RenderThemeGtk::paintMenuList(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 436 {
 437     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 438     auto comboState = themePartStateFlags(*this, ComboBoxButton, renderObject);
 439     comboWidget.comboBox().setState(comboState);
 440     comboWidget.button().setState(comboState);
 441     comboWidget.arrow().setState(comboState);
 442 
 443     cairo_t* cr = paintInfo.context().platformContext()-&gt;cr();
 444     comboWidget.comboBox().render(cr, rect);
 445     comboWidget.box().render(cr, rect);
 446     FloatRect contentsRect;
 447     comboWidget.button().render(cr, rect, &amp;contentsRect);
 448     comboWidget.buttonBox().render(cr, contentsRect);
 449     comboWidget.arrow().render(cr, contentsRect);
 450     if (isFocused(renderObject))
 451         comboWidget.button().renderFocus(cr, rect);
 452 
 453     return false;
 454 }
<a name="14" id="anc14"></a>

























































































 455 
 456 bool RenderThemeGtk::paintMenuListButtonDecorations(const RenderBox&amp; object, const PaintInfo&amp; info, const FloatRect&amp; rect)
 457 {
 458     return paintMenuList(object, info, rect);
 459 }
 460 
<a name="15" id="anc15"></a>










 461 static IntSize spinButtonSize()
 462 {
 463     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 464     spinButtonWidget.spinButton().setState(GTK_STATE_FLAG_NORMAL);
 465     spinButtonWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 466     spinButtonWidget.up().setState(GTK_STATE_FLAG_NORMAL);
 467     spinButtonWidget.down().setState(GTK_STATE_FLAG_NORMAL);
 468 
 469     IntSize preferredSize = spinButtonWidget.spinButton().preferredSize();
 470     preferredSize = preferredSize.expandedTo(spinButtonWidget.entry().preferredSize());
 471     IntSize upPreferredSize = preferredSize.expandedTo(spinButtonWidget.up().preferredSize());
 472     IntSize downPreferredSize = preferredSize.expandedTo(spinButtonWidget.down().preferredSize());
 473 
 474     return IntSize(upPreferredSize.width() + downPreferredSize.width(), std::max(upPreferredSize.height(), downPreferredSize.height()));
 475 }
 476 
 477 
 478 void RenderThemeGtk::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const
 479 {
 480     if (!is&lt;HTMLInputElement&gt;(element) || !shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*element)))
 481         return;
 482 
 483     style.setMinHeight(Length(spinButtonSize().height(), Fixed));
 484 
 485     // The default theme for the GTK+ port uses very wide spin buttons (66px) compared to what other
 486     // browsers use (~13 px). And unfortunately, most of the web developers won&#39;t test how their site
<a name="16" id="anc16"></a><span class="line-modified"> 487     // renders on WebKitGTK. To ensure that spin buttons don&#39;t end up covering the values of the input</span>
 488     // field, we override the width of the input element and always increment it with the width needed
 489     // for the spinbutton (when drawing the spinbutton).
 490     int minimumWidth = style.width().intValue() + spinButtonSize().width();
 491     style.setMinWidth(Length(minimumWidth, Fixed));
 492 }
 493 
 494 bool RenderThemeGtk::paintTextField(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 495 {
 496     if (is&lt;HTMLInputElement&gt;(renderObject.node()) &amp;&amp; shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*renderObject.node()))) {
 497         auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 498         auto spinButtonState = themePartStateFlags(*this, Entry, renderObject);
 499         spinButtonWidget.spinButton().setState(spinButtonState);
 500         spinButtonWidget.entry().setState(spinButtonState);
 501         spinButtonWidget.spinButton().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 502         spinButtonWidget.entry().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 503     } else {
 504         auto&amp; entryWidget = static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Entry));
 505         entryWidget.entry().setState(themePartStateFlags(*this, Entry, renderObject));
 506         entryWidget.entry().render(paintInfo.context().platformContext()-&gt;cr(), rect);
<a name="17" id="anc17"></a>






 507 
<a name="18" id="anc18"></a><span class="line-modified"> 508 #if ENABLE(DATALIST_ELEMENT)</span>
<span class="line-modified"> 509         if (is&lt;HTMLInputElement&gt;(renderObject.generatingNode())) {</span>
<span class="line-modified"> 510             const auto&amp; input = downcast&lt;HTMLInputElement&gt;(*(renderObject.generatingNode()));</span>
<span class="line-modified"> 511             if (input.list())</span>
<span class="line-modified"> 512                 paintListButtonForInput(renderObject, paintInfo, rect);</span>


















 513         }
<a name="19" id="anc19"></a><span class="line-added"> 514 #endif</span>
 515     }
<a name="20" id="anc20"></a>
 516     return false;
 517 }
<a name="21" id="anc21"></a>
 518 
<a name="22" id="anc22"></a>
 519 static void adjustSearchFieldIconStyle(RenderThemePart themePart, RenderStyle&amp; style)
 520 {
 521     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 522     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 523     searchEntryWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 524     searchEntryWidget.leftIcon().setState(GTK_STATE_FLAG_NORMAL);
 525     searchEntryWidget.rightIcon().setState(GTK_STATE_FLAG_NORMAL);
 526 
 527     // Get the icon size based on the font size.
 528     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 529     icon.setIconSize(style.computedFontPixelSize());
 530     IntSize preferredSize = icon.preferredSize();
 531     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 532     if (themePart == EntryIconLeft)
 533         preferredSize.expand(contentsBox.left, contentsBox.top + contentsBox.bottom);
 534     else
 535         preferredSize.expand(contentsBox.right, contentsBox.top + contentsBox.bottom);
 536     style.setWidth(Length(preferredSize.width(), Fixed));
 537     style.setHeight(Length(preferredSize.height(), Fixed));
 538 }
<a name="23" id="anc23"></a>
















































 539 
 540 bool RenderThemeGtk::paintTextArea(const RenderObject&amp; o, const PaintInfo&amp; i, const FloatRect&amp; r)
 541 {
 542     return paintTextField(o, i, r);
 543 }
 544 
 545 void RenderThemeGtk::adjustSearchFieldResultsButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const
 546 {
 547     adjustSearchFieldCancelButtonStyle(styleResolver, style, e);
 548 }
 549 
 550 bool RenderThemeGtk::paintSearchFieldResultsButton(const RenderBox&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 551 {
 552     return paintSearchFieldResultsDecorationPart(o, i, rect);
 553 }
 554 
 555 void RenderThemeGtk::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 556 {
 557     adjustSearchFieldIconStyle(EntryIconLeft, style);
 558 }
 559 
 560 void RenderThemeGtk::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 561 {
 562     adjustSearchFieldIconStyle(EntryIconRight, style);
 563 }
 564 
<a name="24" id="anc24"></a>
 565 static bool paintSearchFieldIcon(RenderThemeGtk* theme, RenderThemePart themePart, const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 566 {
 567     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 568     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 569     searchEntryWidget.entry().setState(themePartStateFlags(*theme, Entry, renderObject));
 570     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 571     icon.setState(themePartStateFlags(*theme, themePart, renderObject));
 572     icon.setIconSize(renderObject.style().computedFontPixelSize());
 573     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 574     IntRect iconRect = rect;
 575     if (themePart == EntryIconLeft) {
 576         iconRect.move(contentsBox.left, contentsBox.top);
 577         iconRect.contract(contentsBox.left, contentsBox.top + contentsBox.bottom);
 578     } else
 579         iconRect.contract(contentsBox.right, contentsBox.top + contentsBox.bottom);
 580     return !icon.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 581 }
 582 bool RenderThemeGtk::paintSearchFieldResultsDecorationPart(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 583 {
 584     return paintSearchFieldIcon(this, EntryIconLeft, renderObject, paintInfo, rect);
 585 }
 586 
 587 bool RenderThemeGtk::paintSearchFieldCancelButton(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 588 {
 589     return paintSearchFieldIcon(this, EntryIconRight, renderObject, paintInfo, rect);
 590 }
<a name="25" id="anc25"></a>












































 591 
<a name="26" id="anc26"></a><span class="line-modified"> 592 #if ENABLE(DATALIST_ELEMENT)</span>
<span class="line-added"> 593 void RenderThemeGtk::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 594 {
<a name="27" id="anc27"></a><span class="line-modified"> 595     // Add a margin to place the button at end of the input field.</span>
<span class="line-modified"> 596     if (style.isLeftToRightDirection())</span>
<span class="line-modified"> 597         style.setMarginRight(Length(-4, Fixed));</span>
<span class="line-modified"> 598     else</span>
<span class="line-modified"> 599         style.setMarginLeft(Length(-4, Fixed));</span>

 600 }
 601 
<a name="28" id="anc28"></a><span class="line-modified"> 602 void RenderThemeGtk::paintListButtonForInput(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)</span>
 603 {
<a name="29" id="anc29"></a><span class="line-modified"> 604     // Use a combo box widget to render its arrow.</span>
<span class="line-modified"> 605     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));</span>
<span class="line-modified"> 606     comboWidget.arrow().setState(themePartStateFlags(*this, ComboBoxButton, renderObject));</span>
 607 
<a name="30" id="anc30"></a><span class="line-modified"> 608     // But a search entry widget to get the contents rect, since this is a text input field.</span>
<span class="line-modified"> 609     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));</span>
<span class="line-added"> 610     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(searchEntryWidget.rightIcon());</span>
<span class="line-added"> 611     icon.setIconSize(comboWidget.arrow().preferredSize().width());</span>
<span class="line-added"> 612     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();</span>
<span class="line-added"> 613     FloatRect adjustedRect(rect);</span>
<span class="line-added"> 614     adjustedRect.move(contentsBox.left, contentsBox.top);</span>
<span class="line-added"> 615     adjustedRect.contract(contentsBox.right + 1, contentsBox.top + contentsBox.bottom);</span>
<span class="line-added"> 616     comboWidget.arrow().render(paintInfo.context().platformContext()-&gt;cr(), adjustedRect);</span>
 617 }
<a name="31" id="anc31"></a><span class="line-modified"> 618 #endif</span>
 619 
 620 void RenderThemeGtk::adjustSearchFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 621 {
 622     // We cannot give a proper rendering when border radius is active, unfortunately.
 623     style.resetBorderRadius();
 624     style.setLineHeight(RenderStyle::initialLineHeight());
 625 }
 626 
 627 bool RenderThemeGtk::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 628 {
 629     return paintTextField(o, i, rect);
 630 }
 631 
 632 bool RenderThemeGtk::shouldHaveCapsLockIndicator(const HTMLInputElement&amp; element) const
 633 {
 634     return element.isPasswordField();
 635 }
 636 
 637 void RenderThemeGtk::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 638 {
 639     style.setBoxShadow(nullptr);
 640 }
 641 
 642 void RenderThemeGtk::adjustSliderThumbStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element) const
 643 {
 644     RenderTheme::adjustSliderThumbStyle(styleResolver, style, element);
 645     style.setBoxShadow(nullptr);
 646 }
 647 
<a name="32" id="anc32"></a>
 648 /*
 649  * GtkScale
 650  *
 651  * scale
 652  * ╰── contents
 653  *     ╰── trough
 654  *         ├── slider
 655  *         ╰── [highlight]
 656  */
 657 bool RenderThemeGtk::paintSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 658 {
 659     ControlPart part = renderObject.style().appearance();
 660     ASSERT(part == SliderHorizontalPart || part == SliderVerticalPart);
 661 
 662     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 663     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 664     auto&amp; scale = sliderWidget.scale();
 665     scale.setState(scaleState);
 666     auto&amp; contents = sliderWidget.contents();
 667     auto&amp; trough = sliderWidget.trough();
 668     trough.setState(scaleState);
 669     auto&amp; slider = sliderWidget.slider();
 670     auto&amp; highlight = sliderWidget.highlight();
 671 
 672     // The given rectangle is not calculated based on the scale size, but all the margins and paddings are based on it.
 673     IntSize preferredSize = scale.preferredSize();
 674     preferredSize = preferredSize.expandedTo(contents.preferredSize());
 675     preferredSize = preferredSize.expandedTo(trough.preferredSize());
 676     FloatRect trackRect = rect;
 677     if (part == SliderHorizontalPart) {
 678         trackRect.move(0, rect.height() / 2 - (preferredSize.height() / 2));
 679         trackRect.setHeight(preferredSize.height());
 680     } else {
 681         trackRect.move(rect.width() / 2 - (preferredSize.width() / 2), 0);
 682         trackRect.setWidth(preferredSize.width());
 683     }
 684 
 685     FloatRect contentsRect;
 686     scale.render(paintInfo.context().platformContext()-&gt;cr(), trackRect, &amp;contentsRect);
 687     contents.render(paintInfo.context().platformContext()-&gt;cr(), contentsRect, &amp;contentsRect);
 688     // Scale trough defines its size querying slider and highlight.
 689     if (part == SliderHorizontalPart)
 690         contentsRect.setHeight(trough.preferredSize().height() + std::max(slider.preferredSize().height(), highlight.preferredSize().height()));
 691     else
 692         contentsRect.setWidth(trough.preferredSize().width() + std::max(slider.preferredSize().width(), highlight.preferredSize().width()));
 693     FloatRect troughRect = contentsRect;
 694     trough.render(paintInfo.context().platformContext()-&gt;cr(), troughRect, &amp;contentsRect);
 695     if (isFocused(renderObject))
 696         trough.renderFocus(paintInfo.context().platformContext()-&gt;cr(), troughRect);
 697 
 698     LayoutPoint thumbLocation;
 699     if (is&lt;HTMLInputElement&gt;(renderObject.node())) {
 700         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*renderObject.node());
 701         if (auto* element = input.sliderThumbElement())
 702             thumbLocation = element-&gt;renderBox()-&gt;location();
 703     }
 704 
 705     if (part == SliderHorizontalPart) {
 706         if (renderObject.style().direction() == TextDirection::RTL) {
 707             contentsRect.move(thumbLocation.x(), 0);
 708             contentsRect.setWidth(contentsRect.width() - thumbLocation.x());
 709         } else
 710             contentsRect.setWidth(thumbLocation.x());
 711     } else
 712         contentsRect.setHeight(thumbLocation.y());
 713     highlight.render(paintInfo.context().platformContext()-&gt;cr(), contentsRect);
 714 
 715     return false;
 716 }
 717 
 718 void RenderThemeGtk::adjustSliderThumbSize(RenderStyle&amp; style, const Element*) const
 719 {
 720     ControlPart part = style.appearance();
 721     if (part != SliderThumbHorizontalPart &amp;&amp; part != SliderThumbVerticalPart)
 722         return;
 723 
 724     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderThumbHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 725     sliderWidget.scale().setState(GTK_STATE_FLAG_NORMAL);
 726     sliderWidget.trough().setState(GTK_STATE_FLAG_NORMAL);
 727 
 728     IntSize preferredSize = sliderWidget.scale().preferredSize();
 729     preferredSize = preferredSize.expandedTo(sliderWidget.contents().preferredSize());
 730     preferredSize = preferredSize.expandedTo(sliderWidget.trough().preferredSize());
 731     preferredSize = preferredSize.expandedTo(sliderWidget.slider().preferredSize());
 732     if (part == SliderThumbHorizontalPart) {
 733         style.setWidth(Length(preferredSize.width(), Fixed));
 734         style.setHeight(Length(preferredSize.height(), Fixed));
 735         return;
 736     }
 737     ASSERT(part == SliderThumbVerticalPart);
 738     style.setWidth(Length(preferredSize.height(), Fixed));
 739     style.setHeight(Length(preferredSize.width(), Fixed));
 740 }
 741 
 742 bool RenderThemeGtk::paintSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 743 {
 744     ControlPart part = renderObject.style().appearance();
 745     ASSERT(part == SliderThumbHorizontalPart || part == SliderThumbVerticalPart);
 746 
 747     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderThumbHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 748     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 749     auto&amp; scale = sliderWidget.scale();
 750     scale.setState(scaleState);
 751     auto&amp; contents = sliderWidget.contents();
 752     auto&amp; trough = sliderWidget.trough();
 753     trough.setState(scaleState);
 754     auto&amp; slider = sliderWidget.slider();
 755     slider.setState(themePartStateFlags(*this, ScaleSlider, renderObject));
 756     auto&amp; highlight = sliderWidget.highlight();
 757 
 758     GtkBorder scaleContentsBox = scale.contentsBox();
 759     GtkBorder contentsContentsBox = contents.contentsBox();
 760     GtkBorder troughContentsBox = trough.contentsBox();
 761     GtkBorder padding;
 762     padding.left = scaleContentsBox.left + contentsContentsBox.left + troughContentsBox.left;
 763     padding.right = scaleContentsBox.right + contentsContentsBox.right + troughContentsBox.right;
 764     padding.top = scaleContentsBox.top + contentsContentsBox.top + troughContentsBox.top;
 765     padding.bottom = scaleContentsBox.bottom + contentsContentsBox.bottom + troughContentsBox.bottom;
 766 
 767     // Scale trough defines its size querying slider and highlight.
 768     int troughHeight = trough.preferredSize().height() + std::max(slider.preferredSize().height(), highlight.preferredSize().height());
 769     IntRect sliderRect(rect.location(), IntSize(troughHeight, troughHeight));
 770     sliderRect.move(padding.left, padding.top);
 771     sliderRect.contract(padding.left + padding.right, padding.top + padding.bottom);
 772     slider.render(paintInfo.context().platformContext()-&gt;cr(), sliderRect);
 773     return false;
 774 }
<a name="33" id="anc33"></a>












 775 
<a name="34" id="anc34"></a>













































































 776 IntRect RenderThemeGtk::progressBarRectForBounds(const RenderObject&amp; renderObject, const IntRect&amp; bounds) const
 777 {
 778     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 779     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 780     IntSize preferredSize = progressBarWidget.progressBar().preferredSize();
 781     preferredSize = preferredSize.expandedTo(progressBarWidget.trough().preferredSize());
 782     preferredSize = preferredSize.expandedTo(progressBarWidget.progress().preferredSize());
 783     return IntRect(bounds.x(), bounds.y(), bounds.width(), preferredSize.height());
 784 }
 785 
 786 bool RenderThemeGtk::paintProgressBar(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 787 {
 788     if (!renderObject.isProgress())
 789         return true;
 790 
 791     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 792     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 793     progressBarWidget.progressBar().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 794     progressBarWidget.trough().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 795     progressBarWidget.progress().render(paintInfo.context().platformContext()-&gt;cr(), calculateProgressRect(renderObject, rect));
 796     return false;
 797 }
<a name="35" id="anc35"></a>









 798 
<a name="36" id="anc36"></a>































 799 RenderTheme::InnerSpinButtonLayout RenderThemeGtk::innerSpinButtonLayout(const RenderObject&amp; renderObject) const
 800 {
 801     return renderObject.style().direction() == TextDirection::RTL ? InnerSpinButtonLayout::HorizontalUpLeft : InnerSpinButtonLayout::HorizontalUpRight;
 802 }
 803 
 804 void RenderThemeGtk::adjustInnerSpinButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
 805 {
 806     style.setWidth(Length(spinButtonSize().width(), Fixed));
 807     style.setHeight(Length(spinButtonSize().height(), Fixed));
 808 }
 809 
 810 bool RenderThemeGtk::paintInnerSpinButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 811 {
 812     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 813     auto spinButtonState = themePartStateFlags(*this, SpinButton, renderObject);
 814     spinButtonWidget.spinButton().setState(spinButtonState);
 815     spinButtonWidget.entry().setState(spinButtonState);
 816     auto&amp; up = spinButtonWidget.up();
 817     up.setState(themePartStateFlags(*this, SpinButtonUpButton, renderObject));
 818     auto&amp; down = spinButtonWidget.down();
 819     down.setState(themePartStateFlags(*this, SpinButtonDownButton, renderObject));
 820 
 821     IntRect iconRect = rect;
 822     iconRect.setWidth(iconRect.width() / 2);
 823     if (renderObject.style().direction() == TextDirection::RTL)
 824         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 825     else
 826         down.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 827     iconRect.move(iconRect.width(), 0);
 828     if (renderObject.style().direction() == TextDirection::RTL)
 829         down.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 830     else
 831         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 832 
 833     return false;
 834 }
<a name="37" id="anc37"></a>











































































































 835 
 836 Seconds RenderThemeGtk::caretBlinkInterval() const
 837 {
 838     GtkSettings* settings = gtk_settings_get_default();
 839 
 840     gboolean shouldBlink;
 841     gint time;
 842 
 843     g_object_get(settings, &quot;gtk-cursor-blink&quot;, &amp;shouldBlink, &quot;gtk-cursor-blink-time&quot;, &amp;time, nullptr);
 844 
 845     if (!shouldBlink)
 846         return 0_s;
 847 
 848     return 500_us * time;
 849 }
 850 
 851 enum StyleColorType { StyleColorBackground, StyleColorForeground };
 852 
<a name="38" id="anc38"></a>
 853 static Color styleColor(RenderThemePart themePart, GtkStateFlags state, StyleColorType colorType)
 854 {
 855     RenderThemeGadget* gadget = nullptr;
 856     switch (themePart) {
 857     default:
 858         ASSERT_NOT_REACHED();
 859         FALLTHROUGH;
 860     case Entry:
 861         gadget = &amp;static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Entry)).entry();
 862         break;
 863     case EntrySelection:
 864         gadget = static_cast&lt;RenderThemeEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SelectedEntry)).selection();
 865         break;
 866     case ListBox:
 867         gadget = &amp;static_cast&lt;RenderThemeListView&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ListView)).treeview();
 868         break;
 869     case Button:
 870         gadget = &amp;static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Button)).button();
 871         break;
<a name="39" id="anc39"></a><span class="line-added"> 872     case Window:</span>
<span class="line-added"> 873         gadget = &amp;static_cast&lt;RenderThemeWindow&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Window)).window();</span>
<span class="line-added"> 874         break;</span>
 875     }
 876 
 877     ASSERT(gadget);
 878     gadget-&gt;setState(state);
 879     return colorType == StyleColorBackground ? gadget-&gt;backgroundColor() : gadget-&gt;color();
 880 }
<a name="40" id="anc40"></a>













 881 
 882 Color RenderThemeGtk::platformActiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 883 {
 884     return styleColor(EntrySelection, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorBackground);
 885 }
 886 
 887 Color RenderThemeGtk::platformInactiveSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 888 {
 889     return styleColor(EntrySelection, GTK_STATE_FLAG_SELECTED, StyleColorBackground);
 890 }
 891 
 892 Color RenderThemeGtk::platformActiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 893 {
 894     return styleColor(EntrySelection, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorForeground);
 895 }
 896 
 897 Color RenderThemeGtk::platformInactiveSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 898 {
 899     return styleColor(EntrySelection, GTK_STATE_FLAG_SELECTED, StyleColorForeground);
 900 }
 901 
 902 Color RenderThemeGtk::platformActiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 903 {
 904     return styleColor(ListBox, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorBackground);
 905 }
 906 
 907 Color RenderThemeGtk::platformInactiveListBoxSelectionBackgroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 908 {
 909     return styleColor(ListBox, GTK_STATE_FLAG_SELECTED, StyleColorBackground);
 910 }
 911 
 912 Color RenderThemeGtk::platformActiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 913 {
 914     return styleColor(ListBox, static_cast&lt;GtkStateFlags&gt;(GTK_STATE_FLAG_SELECTED | GTK_STATE_FLAG_FOCUSED), StyleColorForeground);
 915 }
 916 
 917 Color RenderThemeGtk::platformInactiveListBoxSelectionForegroundColor(OptionSet&lt;StyleColor::Options&gt;) const
 918 {
 919     return styleColor(ListBox, GTK_STATE_FLAG_SELECTED, StyleColorForeground);
 920 }
 921 
<a name="41" id="anc41"></a><span class="line-added"> 922 Color RenderThemeGtk::disabledTextColor(const Color&amp;, const Color&amp;) const</span>
<span class="line-added"> 923 {</span>
<span class="line-added"> 924     return styleColor(Entry, GTK_STATE_FLAG_INSENSITIVE, StyleColorForeground);</span>
<span class="line-added"> 925 }</span>
<span class="line-added"> 926 </span>
 927 Color RenderThemeGtk::systemColor(CSSValueID cssValueId, OptionSet&lt;StyleColor::Options&gt; options) const
 928 {
 929     switch (cssValueId) {
 930     case CSSValueButtontext:
 931         return styleColor(Button, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
 932     case CSSValueCaptiontext:
 933         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);
<a name="42" id="anc42"></a><span class="line-added"> 934     case CSSValueText:</span>
<span class="line-added"> 935         return styleColor(Entry, GTK_STATE_FLAG_ACTIVE, StyleColorForeground);</span>
<span class="line-added"> 936     case CSSValueGraytext:</span>
<span class="line-added"> 937         return styleColor(Entry, GTK_STATE_FLAG_INSENSITIVE, StyleColorForeground);</span>
 938     default:
<a name="43" id="anc43"></a><span class="line-modified"> 939         break;</span>
 940     }
<a name="44" id="anc44"></a><span class="line-added"> 941 </span>
<span class="line-added"> 942     return RenderTheme::systemColor(cssValueId, options);</span>
 943 }
 944 
 945 void RenderThemeGtk::platformColorsDidChange()
 946 {
 947     RenderTheme::platformColorsDidChange();
 948 }
 949 
 950 #if ENABLE(VIDEO)
 951 String RenderThemeGtk::extraMediaControlsStyleSheet()
 952 {
 953     return String(mediaControlsGtkUserAgentStyleSheet, sizeof(mediaControlsGtkUserAgentStyleSheet));
 954 }
 955 
 956 #if ENABLE(FULLSCREEN_API)
 957 String RenderThemeGtk::extraFullScreenStyleSheet()
 958 {
 959     return String();
 960 }
 961 #endif
 962 
<a name="45" id="anc45"></a>
 963 bool RenderThemeGtk::paintMediaButton(const RenderObject&amp; renderObject, GraphicsContext&amp; graphicsContext, const IntRect&amp; rect, const char* iconName)
 964 {
 965     auto&amp; iconWidget = static_cast&lt;RenderThemeIcon&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::Icon));
 966     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(iconWidget.icon());
 967     icon.setState(themePartStateFlags(*this, MediaButton, renderObject));
 968     icon.setIconSize(RenderThemeIconGadget::IconSizeGtk::Menu);
 969     icon.setIconName(iconName);
 970     return !icon.render(graphicsContext.platformContext()-&gt;cr(), rect);
 971 }
<a name="46" id="anc46"></a>










 972 
 973 bool RenderThemeGtk::hasOwnDisabledStateHandlingFor(ControlPart part) const
 974 {
 975     return (part != MediaMuteButtonPart);
 976 }
 977 
 978 bool RenderThemeGtk::paintMediaFullscreenButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 979 {
 980     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;view-fullscreen-symbolic&quot;);
 981 }
 982 
 983 bool RenderThemeGtk::paintMediaMuteButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 984 {
 985     Node* node = renderObject.node();
 986     if (!node)
 987         return true;
 988     Node* mediaNode = node-&gt;shadowHost();
 989     if (!is&lt;HTMLMediaElement&gt;(mediaNode))
 990         return true;
 991 
 992     HTMLMediaElement* mediaElement = downcast&lt;HTMLMediaElement&gt;(mediaNode);
 993     return paintMediaButton(renderObject, paintInfo.context(), rect, mediaElement-&gt;muted() ? &quot;audio-volume-muted-symbolic&quot; : &quot;audio-volume-high-symbolic&quot;);
 994 }
 995 
 996 bool RenderThemeGtk::paintMediaPlayButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 997 {
 998     Node* node = renderObject.node();
 999     if (!node)
1000         return true;
1001     if (!nodeHasPseudo(*node, &quot;-webkit-media-controls-play-button&quot;))
1002         return true;
1003 
1004     return paintMediaButton(renderObject, paintInfo.context(), rect, nodeHasClass(node, &quot;paused&quot;) ? &quot;media-playback-start-symbolic&quot; : &quot;media-playback-pause-symbolic&quot;);
1005 }
1006 
1007 bool RenderThemeGtk::paintMediaSeekBackButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1008 {
1009     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-seek-backward-symbolic&quot;);
1010 }
1011 
1012 bool RenderThemeGtk::paintMediaSeekForwardButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1013 {
1014     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-seek-forward-symbolic&quot;);
1015 }
1016 
1017 #if ENABLE(VIDEO_TRACK)
1018 bool RenderThemeGtk::paintMediaToggleClosedCaptionsButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1019 {
1020     return paintMediaButton(renderObject, paintInfo.context(), rect, &quot;media-view-subtitles-symbolic&quot;);
1021 }
1022 #endif
1023 
1024 static FloatRoundedRect::Radii borderRadiiFromStyle(const RenderStyle&amp; style)
1025 {
1026     return FloatRoundedRect::Radii(
1027         IntSize(style.borderTopLeftRadius().width.intValue(), style.borderTopLeftRadius().height.intValue()),
1028         IntSize(style.borderTopRightRadius().width.intValue(), style.borderTopRightRadius().height.intValue()),
1029         IntSize(style.borderBottomLeftRadius().width.intValue(), style.borderBottomLeftRadius().height.intValue()),
1030         IntSize(style.borderBottomRightRadius().width.intValue(), style.borderBottomRightRadius().height.intValue()));
1031 }
1032 
1033 bool RenderThemeGtk::paintMediaSliderTrack(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1034 {
1035     auto mediaElement = parentMediaElement(o);
1036     if (!mediaElement)
1037         return true;
1038 
1039     GraphicsContext&amp; context = paintInfo.context();
1040     context.save();
1041     context.setStrokeStyle(NoStroke);
1042 
1043     float mediaDuration = mediaElement-&gt;duration();
1044     float totalTrackWidth = r.width();
1045     auto&amp; style = o.style();
1046     RefPtr&lt;TimeRanges&gt; timeRanges = mediaElement-&gt;buffered();
1047     for (unsigned index = 0; index &lt; timeRanges-&gt;length(); ++index) {
1048         float start = timeRanges-&gt;start(index).releaseReturnValue();
1049         float end = timeRanges-&gt;end(index).releaseReturnValue();
1050         float startRatio = start / mediaDuration;
1051         float lengthRatio = (end - start) / mediaDuration;
1052         if (!lengthRatio)
1053             continue;
1054 
1055         IntRect rangeRect(r);
1056         rangeRect.setWidth(lengthRatio * totalTrackWidth);
1057         if (index)
1058             rangeRect.move(startRatio * totalTrackWidth, 0);
1059         context.fillRoundedRect(FloatRoundedRect(rangeRect, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1060     }
1061 
1062     context.restore();
1063     return false;
1064 }
1065 
1066 bool RenderThemeGtk::paintMediaSliderThumb(const RenderObject&amp; o, const PaintInfo&amp; paintInfo, const IntRect&amp; r)
1067 {
1068     auto&amp; style = o.style();
1069     paintInfo.context().fillRoundedRect(FloatRoundedRect(r, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1070     return false;
1071 }
1072 
1073 bool RenderThemeGtk::paintMediaVolumeSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1074 {
1075     auto mediaElement = parentMediaElement(renderObject);
1076     if (!mediaElement)
1077         return true;
1078 
1079     float volume = mediaElement-&gt;muted() ? 0.0f : mediaElement-&gt;volume();
1080     if (!volume)
1081         return true;
1082 
1083     GraphicsContext&amp; context = paintInfo.context();
1084     context.save();
1085     context.setStrokeStyle(NoStroke);
1086 
1087     int rectHeight = rect.height();
1088     float trackHeight = rectHeight * volume;
1089     auto&amp; style = renderObject.style();
1090     IntRect volumeRect(rect);
1091     volumeRect.move(0, rectHeight - trackHeight);
1092     volumeRect.setHeight(ceil(trackHeight));
1093 
1094     context.fillRoundedRect(FloatRoundedRect(volumeRect, borderRadiiFromStyle(style)), style.visitedDependentColor(CSSPropertyColor));
1095     context.restore();
1096 
1097     return false;
1098 }
1099 
1100 bool RenderThemeGtk::paintMediaVolumeSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1101 {
1102     return paintMediaSliderThumb(renderObject, paintInfo, rect);
1103 }
1104 
1105 String RenderThemeGtk::formatMediaControlsCurrentTime(float currentTime, float duration) const
1106 {
1107     return formatMediaControlsTime(currentTime) + &quot; / &quot; + formatMediaControlsTime(duration);
1108 }
1109 
1110 bool RenderThemeGtk::paintMediaCurrentTime(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1111 {
1112     return false;
1113 }
1114 #endif
1115 
1116 void RenderThemeGtk::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const
1117 {
1118     style.setBoxShadow(nullptr);
1119 }
1120 
1121 // These values have been copied from RenderThemeChromiumSkia.cpp
1122 static const int progressActivityBlocks = 5;
1123 static const int progressAnimationFrames = 10;
1124 static const Seconds progressAnimationInterval { 125_ms };
1125 Seconds RenderThemeGtk::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1126 {
1127     return progressAnimationInterval;
1128 }
1129 
1130 Seconds RenderThemeGtk::animationDurationForProgressBar(RenderProgress&amp;) const
1131 {
1132     return progressAnimationInterval * progressAnimationFrames * 2; // &quot;2&quot; for back and forth;
1133 }
1134 
1135 IntRect RenderThemeGtk::calculateProgressRect(const RenderObject&amp; renderObject, const IntRect&amp; fullBarRect)
1136 {
1137     IntRect progressRect(fullBarRect);
1138     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
1139     if (renderProgress.isDeterminate()) {
1140         int progressWidth = progressRect.width() * renderProgress.position();
1141         if (renderObject.style().direction() == TextDirection::RTL)
1142             progressRect.setX(progressRect.x() + progressRect.width() - progressWidth);
1143         progressRect.setWidth(progressWidth);
1144         return progressRect;
1145     }
1146 
1147     double animationProgress = renderProgress.animationProgress();
1148 
1149     // Never let the progress rect shrink smaller than 2 pixels.
1150     int newWidth = std::max(2, progressRect.width() / progressActivityBlocks);
1151     int movableWidth = progressRect.width() - newWidth;
1152     progressRect.setWidth(newWidth);
1153 
1154     // We want the first 0.5 units of the animation progress to represent the
1155     // forward motion and the second 0.5 units to represent the backward motion,
1156     // thus we multiply by two here to get the full sweep of the progress bar with
1157     // each direction.
1158     if (animationProgress &lt; 0.5)
1159         progressRect.setX(progressRect.x() + (animationProgress * 2 * movableWidth));
1160     else
1161         progressRect.setX(progressRect.x() + ((1.0 - animationProgress) * 2 * movableWidth));
1162     return progressRect;
1163 }
1164 
1165 String RenderThemeGtk::fileListNameForWidth(const FileList* fileList, const FontCascade&amp; font, int width, bool multipleFilesAllowed) const
1166 {
1167     if (width &lt;= 0)
1168         return String();
1169 
1170     if (fileList-&gt;length() &gt; 1)
1171         return StringTruncator::rightTruncate(multipleFileUploadText(fileList-&gt;length()), width, font);
1172 
1173     String string;
1174     if (fileList-&gt;length())
1175         string = FileSystem::pathGetFileName(fileList-&gt;item(0)-&gt;path());
1176     else if (multipleFilesAllowed)
1177         string = fileButtonNoFilesSelectedLabel();
1178     else
1179         string = fileButtonNoFileSelectedLabel();
1180 
1181     return StringTruncator::centerTruncate(string, width, font);
1182 }
1183 
1184 #if ENABLE(VIDEO)
1185 String RenderThemeGtk::mediaControlsScript()
1186 {
1187     StringBuilder scriptBuilder;
<a name="47" id="anc47"></a><span class="line-modified">1188     scriptBuilder.appendCharacters(mediaControlsLocalizedStringsJavaScript, sizeof(mediaControlsLocalizedStringsJavaScript));</span>
<span class="line-modified">1189     scriptBuilder.appendCharacters(mediaControlsBaseJavaScript, sizeof(mediaControlsBaseJavaScript));</span>
<span class="line-modified">1190     scriptBuilder.appendCharacters(mediaControlsGtkJavaScript, sizeof(mediaControlsGtkJavaScript));</span>
1191     return scriptBuilder.toString();
1192 }
1193 #endif // ENABLE(VIDEO)
<a name="48" id="anc48"></a>

1194 }
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>