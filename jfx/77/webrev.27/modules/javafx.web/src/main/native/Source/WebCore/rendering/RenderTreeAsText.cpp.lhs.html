<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
<a name="1" id="anc1"></a>
 38 #include &quot;Logging.h&quot;
 39 #include &quot;PrintContext.h&quot;
 40 #include &quot;PseudoElement.h&quot;
 41 #include &quot;RenderBlockFlow.h&quot;
 42 #include &quot;RenderCounter.h&quot;
 43 #include &quot;RenderDetailsMarker.h&quot;
 44 #include &quot;RenderFileUploadControl.h&quot;
 45 #include &quot;RenderFragmentContainer.h&quot;
 46 #include &quot;RenderInline.h&quot;
 47 #include &quot;RenderIterator.h&quot;
 48 #include &quot;RenderLayer.h&quot;
 49 #include &quot;RenderLayerBacking.h&quot;
 50 #include &quot;RenderLineBreak.h&quot;
 51 #include &quot;RenderListItem.h&quot;
 52 #include &quot;RenderListMarker.h&quot;
 53 #include &quot;RenderSVGContainer.h&quot;
 54 #include &quot;RenderSVGGradientStop.h&quot;
 55 #include &quot;RenderSVGImage.h&quot;
 56 #include &quot;RenderSVGInlineText.h&quot;
 57 #include &quot;RenderSVGPath.h&quot;
 58 #include &quot;RenderSVGResourceContainer.h&quot;
 59 #include &quot;RenderSVGRoot.h&quot;
 60 #include &quot;RenderSVGText.h&quot;
 61 #include &quot;RenderTableCell.h&quot;
 62 #include &quot;RenderView.h&quot;
 63 #include &quot;RenderWidget.h&quot;
 64 #include &quot;SVGRenderTreeAsText.h&quot;
 65 #include &quot;ShadowRoot.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 66 #include &quot;SimpleLineLayoutResolver.h&quot;</span>
 67 #include &quot;StyleProperties.h&quot;
 68 #include &lt;wtf/HexNumber.h&gt;
 69 #include &lt;wtf/Vector.h&gt;
 70 #include &lt;wtf/text/TextStream.h&gt;
 71 #include &lt;wtf/unicode/CharacterNames.h&gt;
 72 
 73 #if PLATFORM(MAC)
 74 #include &quot;ScrollbarThemeMac.h&quot;
 75 #endif
 76 
 77 namespace WebCore {
 78 
 79 using namespace HTMLNames;
 80 
<a name="3" id="anc3"></a><span class="line-modified"> 81 static void writeLayers(TextStream&amp;, const RenderLayer&amp; rootLayer, RenderLayer&amp;, const LayoutRect&amp; paintDirtyRect, RenderAsTextBehavior = RenderAsTextBehaviorNormal);</span>
 82 
 83 static void printBorderStyle(TextStream&amp; ts, const BorderStyle borderStyle)
 84 {
 85     switch (borderStyle) {
 86     case BorderStyle::None:
 87         ts &lt;&lt; &quot;none&quot;;
 88         break;
 89     case BorderStyle::Hidden:
 90         ts &lt;&lt; &quot;hidden&quot;;
 91         break;
 92     case BorderStyle::Inset:
 93         ts &lt;&lt; &quot;inset&quot;;
 94         break;
 95     case BorderStyle::Groove:
 96         ts &lt;&lt; &quot;groove&quot;;
 97         break;
 98     case BorderStyle::Ridge:
 99         ts &lt;&lt; &quot;ridge&quot;;
100         break;
101     case BorderStyle::Outset:
102         ts &lt;&lt; &quot;outset&quot;;
103         break;
104     case BorderStyle::Dotted:
105         ts &lt;&lt; &quot;dotted&quot;;
106         break;
107     case BorderStyle::Dashed:
108         ts &lt;&lt; &quot;dashed&quot;;
109         break;
110     case BorderStyle::Solid:
111         ts &lt;&lt; &quot;solid&quot;;
112         break;
113     case BorderStyle::Double:
114         ts &lt;&lt; &quot;double&quot;;
115         break;
116     }
117 
118     ts &lt;&lt; &quot; &quot;;
119 }
120 
121 static String getTagName(Node* n)
122 {
123     if (n-&gt;isDocumentNode())
124         return &quot;&quot;;
125     if (n-&gt;nodeType() == Node::COMMENT_NODE)
126         return &quot;COMMENT&quot;;
127     return n-&gt;nodeName();
128 }
129 
130 static bool isEmptyOrUnstyledAppleStyleSpan(const Node* node)
131 {
132     if (!is&lt;HTMLSpanElement&gt;(node))
133         return false;
134 
135     const HTMLElement&amp; element = downcast&lt;HTMLSpanElement&gt;(*node);
136     if (element.getAttribute(classAttr) != &quot;Apple-style-span&quot;)
137         return false;
138 
139     if (!node-&gt;hasChildNodes())
140         return true;
141 
142     const StyleProperties* inlineStyleDecl = element.inlineStyle();
143     return (!inlineStyleDecl || inlineStyleDecl-&gt;isEmpty());
144 }
145 
146 String quoteAndEscapeNonPrintables(StringView s)
147 {
148     StringBuilder result;
149     result.append(&#39;&quot;&#39;);
150     for (unsigned i = 0; i != s.length(); ++i) {
151         UChar c = s[i];
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
163                 appendUnsignedAsHex(c, result);
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
<a name="4" id="anc4"></a><span class="line-modified">172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, RenderAsTextBehavior behavior)</span>
173 {
174     ts &lt;&lt; o.renderName();
175 
<a name="5" id="anc5"></a><span class="line-modified">176     if (behavior &amp; RenderAsTextShowAddresses)</span>
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
179     if (o.style().zIndex())
180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().zIndex();
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<a name="6" id="anc6"></a><span class="line-modified">205         if (!text.firstTextBox() &amp;&amp; !text.simpleLineLayout())</span>

206             adjustForTableCells = false;
207     } else if (o.isBR()) {
208         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
209         IntRect linesBox = br.linesBoundingBox();
210         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
211         if (!br.inlineBoxWrapper())
212             adjustForTableCells = false;
213     } else if (is&lt;RenderInline&gt;(o)) {
214         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
215         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
216         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
217         adjustForTableCells = false;
218     } else if (is&lt;RenderTableCell&gt;(o)) {
219         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
220         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
221         // captured by the results.
222         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
223         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
224     } else if (is&lt;RenderBox&gt;(o))
225         r = downcast&lt;RenderBox&gt;(o).frameRect();
226 
227     // FIXME: Temporary in order to ensure compatibility with existing layout test results.
228     if (adjustForTableCells)
229         r.move(0_lu, -downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
230 
231     // FIXME: Convert layout test results to report sub-pixel values, in the meantime using enclosingIntRect
232     // for consistency with old results.
233     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
234 
235     if (!is&lt;RenderText&gt;(o)) {
236         if (is&lt;RenderFileUploadControl&gt;(o))
237             ts &lt;&lt; &quot; &quot; &lt;&lt; quoteAndEscapeNonPrintables(downcast&lt;RenderFileUploadControl&gt;(o).fileTextValue());
238 
239         if (o.parent()) {
240             Color color = o.style().visitedDependentColor(CSSPropertyColor);
241             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyColor).rgb() != color.rgb())
242                 ts &lt;&lt; &quot; [color=&quot; &lt;&lt; color.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
243 
244             // Do not dump invalid or transparent backgrounds, since that is the default.
245             Color backgroundColor = o.style().visitedDependentColor(CSSPropertyBackgroundColor);
246             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyBackgroundColor).rgb() != backgroundColor.rgb()
247                 &amp;&amp; backgroundColor.isValid() &amp;&amp; backgroundColor.rgb())
248                 ts &lt;&lt; &quot; [bgcolor=&quot; &lt;&lt; backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
249 
250             Color textFillColor = o.style().visitedDependentColor(CSSPropertyWebkitTextFillColor);
251             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextFillColor).rgb() != textFillColor.rgb()
252                 &amp;&amp; textFillColor.isValid() &amp;&amp; textFillColor.rgb() != color.rgb() &amp;&amp; textFillColor.rgb())
253                 ts &lt;&lt; &quot; [textFillColor=&quot; &lt;&lt; textFillColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
254 
255             Color textStrokeColor = o.style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor);
256             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor).rgb() != textStrokeColor.rgb()
257                 &amp;&amp; textStrokeColor.isValid() &amp;&amp; textStrokeColor.rgb() != color.rgb() &amp;&amp; textStrokeColor.rgb())
258                 ts &lt;&lt; &quot; [textStrokeColor=&quot; &lt;&lt; textStrokeColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
259 
260             if (o.parent()-&gt;style().textStrokeWidth() != o.style().textStrokeWidth() &amp;&amp; o.style().textStrokeWidth() &gt; 0)
261                 ts &lt;&lt; &quot; [textStrokeWidth=&quot; &lt;&lt; o.style().textStrokeWidth() &lt;&lt; &quot;]&quot;;
262         }
263 
264         if (!is&lt;RenderBoxModelObject&gt;(o) || is&lt;RenderLineBreak&gt;(o))
265             return;
266 
267         const RenderBoxModelObject&amp; box = downcast&lt;RenderBoxModelObject&gt;(o);
268         LayoutUnit borderTop = box.borderTop();
269         LayoutUnit borderRight = box.borderRight();
270         LayoutUnit borderBottom = box.borderBottom();
271         LayoutUnit borderLeft = box.borderLeft();
272         if (box.isFieldset()) {
273             const auto&amp; block = downcast&lt;RenderBlock&gt;(box);
274             if (o.style().writingMode() == TopToBottomWritingMode)
275                 borderTop -= block.intrinsicBorderForFieldset();
276             else if (o.style().writingMode() == BottomToTopWritingMode)
277                 borderBottom -= block.intrinsicBorderForFieldset();
278             else if (o.style().writingMode() == LeftToRightWritingMode)
279                 borderLeft -= block.intrinsicBorderForFieldset();
280             else if (o.style().writingMode() == RightToLeftWritingMode)
281                 borderRight -= block.intrinsicBorderForFieldset();
282 
283         }
284         if (borderTop || borderRight || borderBottom || borderLeft) {
285             ts &lt;&lt; &quot; [border:&quot;;
286 
287             BorderValue prevBorder = o.style().borderTop();
288             if (!borderTop)
289                 ts &lt;&lt; &quot; none&quot;;
290             else {
291                 ts &lt;&lt; &quot; (&quot; &lt;&lt; borderTop &lt;&lt; &quot;px &quot;;
292                 printBorderStyle(ts, o.style().borderTopStyle());
293                 Color col = o.style().borderTopColor();
294                 if (!col.isValid())
295                     col = o.style().color();
296                 ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
297             }
298 
299             if (o.style().borderRight() != prevBorder) {
300                 prevBorder = o.style().borderRight();
301                 if (!borderRight)
302                     ts &lt;&lt; &quot; none&quot;;
303                 else {
304                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderRight &lt;&lt; &quot;px &quot;;
305                     printBorderStyle(ts, o.style().borderRightStyle());
306                     Color col = o.style().borderRightColor();
307                     if (!col.isValid())
308                         col = o.style().color();
309                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
310                 }
311             }
312 
313             if (o.style().borderBottom() != prevBorder) {
314                 prevBorder = box.style().borderBottom();
315                 if (!borderBottom)
316                     ts &lt;&lt; &quot; none&quot;;
317                 else {
318                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderBottom &lt;&lt; &quot;px &quot;;
319                     printBorderStyle(ts, o.style().borderBottomStyle());
320                     Color col = o.style().borderBottomColor();
321                     if (!col.isValid())
322                         col = o.style().color();
323                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
324                 }
325             }
326 
327             if (o.style().borderLeft() != prevBorder) {
328                 prevBorder = o.style().borderLeft();
329                 if (!borderLeft)
330                     ts &lt;&lt; &quot; none&quot;;
331                 else {
332                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderLeft &lt;&lt; &quot;px &quot;;
333                     printBorderStyle(ts, o.style().borderLeftStyle());
334                     Color col = o.style().borderLeftColor();
335                     if (!col.isValid())
336                         col = o.style().color();
337                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
338                 }
339             }
340 
341             ts &lt;&lt; &quot;]&quot;;
342         }
343 
344 #if ENABLE(MATHML)
345         // We want to show any layout padding, both CSS padding and intrinsic padding, so we can&#39;t just check o.style().hasPadding().
346         if (o.isRenderMathMLBlock() &amp;&amp; (box.paddingTop() || box.paddingRight() || box.paddingBottom() || box.paddingLeft())) {
347             ts &lt;&lt; &quot; [&quot;;
348             LayoutUnit cssTop = box.computedCSSPaddingTop();
349             LayoutUnit cssRight = box.computedCSSPaddingRight();
350             LayoutUnit cssBottom = box.computedCSSPaddingBottom();
351             LayoutUnit cssLeft = box.computedCSSPaddingLeft();
352             if (box.paddingTop() != cssTop || box.paddingRight() != cssRight || box.paddingBottom() != cssBottom || box.paddingLeft() != cssLeft) {
353                 ts &lt;&lt; &quot;intrinsic &quot;;
354                 if (cssTop || cssRight || cssBottom || cssLeft)
355                     ts &lt;&lt; &quot;+ CSS &quot;;
356             }
357             ts &lt;&lt; &quot;padding: &quot; &lt;&lt; roundToInt(box.paddingTop()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingRight()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingBottom()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingLeft()) &lt;&lt; &quot;]&quot;;
358         }
359 #endif
360     }
361 
362     if (is&lt;RenderTableCell&gt;(o)) {
363         const RenderTableCell&amp; c = downcast&lt;RenderTableCell&gt;(o);
364         ts &lt;&lt; &quot; [r=&quot; &lt;&lt; c.rowIndex() &lt;&lt; &quot; c=&quot; &lt;&lt; c.col() &lt;&lt; &quot; rs=&quot; &lt;&lt; c.rowSpan() &lt;&lt; &quot; cs=&quot; &lt;&lt; c.colSpan() &lt;&lt; &quot;]&quot;;
365     }
366 
367     if (is&lt;RenderDetailsMarker&gt;(o)) {
368         ts &lt;&lt; &quot;: &quot;;
369         switch (downcast&lt;RenderDetailsMarker&gt;(o).orientation()) {
370         case RenderDetailsMarker::Left:
371             ts &lt;&lt; &quot;left&quot;;
372             break;
373         case RenderDetailsMarker::Right:
374             ts &lt;&lt; &quot;right&quot;;
375             break;
376         case RenderDetailsMarker::Up:
377             ts &lt;&lt; &quot;up&quot;;
378             break;
379         case RenderDetailsMarker::Down:
380             ts &lt;&lt; &quot;down&quot;;
381             break;
382         }
383     }
384 
385     if (is&lt;RenderListMarker&gt;(o)) {
386         String text = downcast&lt;RenderListMarker&gt;(o).text();
387         if (!text.isEmpty()) {
388             if (text.length() != 1)
389                 text = quoteAndEscapeNonPrintables(text);
390             else {
391                 switch (text[0]) {
392                     case bullet:
393                         text = &quot;bullet&quot;;
394                         break;
395                     case blackSquare:
396                         text = &quot;black square&quot;;
397                         break;
398                     case whiteBullet:
399                         text = &quot;white bullet&quot;;
400                         break;
401                     default:
402                         text = quoteAndEscapeNonPrintables(text);
403                 }
404             }
405             ts &lt;&lt; &quot;: &quot; &lt;&lt; text;
406         }
407     }
408 
409     writeDebugInfo(ts, o, behavior);
410 }
411 
<a name="7" id="anc7"></a><span class="line-modified">412 void writeDebugInfo(TextStream&amp; ts, const RenderObject&amp; object, RenderAsTextBehavior behavior)</span>
413 {
<a name="8" id="anc8"></a><span class="line-modified">414     if (behavior &amp; RenderAsTextShowIDAndClass) {</span>
415         if (Element* element = is&lt;Element&gt;(object.node()) ? downcast&lt;Element&gt;(object.node()) : nullptr) {
416             if (element-&gt;hasID())
417                 ts &lt;&lt; &quot; id=\&quot;&quot; + element-&gt;getIdAttribute() + &quot;\&quot;&quot;;
418 
419             if (element-&gt;hasClass()) {
420                 ts &lt;&lt; &quot; class=\&quot;&quot;;
421                 for (size_t i = 0; i &lt; element-&gt;classNames().size(); ++i) {
422                     if (i &gt; 0)
423                         ts &lt;&lt; &quot; &quot;;
424                     ts &lt;&lt; element-&gt;classNames()[i];
425                 }
426                 ts &lt;&lt; &quot;\&quot;&quot;;
427             }
428         }
429     }
430 
<a name="9" id="anc9"></a><span class="line-modified">431     if (behavior &amp; RenderAsTextShowLayoutState) {</span>
432         bool needsLayout = object.selfNeedsLayout() || object.needsPositionedMovementLayout() || object.posChildNeedsLayout() || object.normalChildNeedsLayout();
433         if (needsLayout)
434             ts &lt;&lt; &quot; (needs layout:&quot;;
435 
436         bool havePrevious = false;
437         if (object.selfNeedsLayout()) {
438             ts &lt;&lt; &quot; self&quot;;
439             havePrevious = true;
440         }
441 
442         if (object.needsPositionedMovementLayout()) {
443             if (havePrevious)
444                 ts &lt;&lt; &quot;,&quot;;
445             havePrevious = true;
446             ts &lt;&lt; &quot; positioned movement&quot;;
447         }
448 
449         if (object.normalChildNeedsLayout()) {
450             if (havePrevious)
451                 ts &lt;&lt; &quot;,&quot;;
452             havePrevious = true;
453             ts &lt;&lt; &quot; child&quot;;
454         }
455 
456         if (object.posChildNeedsLayout()) {
457             if (havePrevious)
458                 ts &lt;&lt; &quot;,&quot;;
459             ts &lt;&lt; &quot; positioned child&quot;;
460         }
461 
462         if (needsLayout)
463             ts &lt;&lt; &quot;)&quot;;
464     }
465 
<a name="10" id="anc10"></a><span class="line-modified">466     if (behavior &amp; RenderAsTextShowOverflow &amp;&amp; is&lt;RenderBox&gt;(object)) {</span>
467         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
468         if (box.hasRenderOverflow()) {
469             LayoutRect layoutOverflow = box.layoutOverflowRect();
470             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
471 
472             if (box.hasVisualOverflow()) {
473                 LayoutRect visualOverflow = box.visualOverflowRect();
474                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
475             }
476         }
477     }
478 }
479 
<a name="11" id="anc11"></a><span class="line-modified">480 static void writeTextRun(TextStream&amp; ts, const RenderText&amp; o, const InlineTextBox&amp; run)</span>
481 {
<a name="12" id="anc12"></a><span class="line-modified">482     // FIXME: For now use an &quot;enclosingIntRect&quot; model for x, y and logicalWidth, although this makes it harder</span>
<span class="line-modified">483     // to detect any changes caused by the conversion to floating point. :(</span>
<span class="line-modified">484     int x = run.x();</span>
<span class="line-modified">485     int y = run.y();</span>
<span class="line-modified">486     int logicalWidth = ceilf(run.left() + run.logicalWidth()) - x;</span>



487 
488     // FIXME: Table cell adjustment is temporary until results can be updated.
489     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
490         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
491 
492     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
<a name="13" id="anc13"></a><span class="line-modified">493     if (!run.isLeftToRightDirection() || run.dirOverride()) {</span>
<span class="line-modified">494         ts &lt;&lt; (!run.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);</span>
<span class="line-modified">495         if (run.dirOverride())</span>
496             ts &lt;&lt; &quot; override&quot;;
497     }
498     ts &lt;&lt; &quot;: &quot;
<a name="14" id="anc14"></a><span class="line-modified">499         &lt;&lt; quoteAndEscapeNonPrintables(String(o.text()).substring(run.start(), run.len()));</span>
<span class="line-modified">500     if (run.hasHyphen())</span>
501         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
502     ts &lt;&lt; &quot;\n&quot;;
503 }
504 
<a name="15" id="anc15"></a><span class="line-modified">505 static void writeSimpleLine(TextStream&amp; ts, const RenderText&amp; renderText, const SimpleLineLayout::RunResolver::Run&amp; run)</span>
<span class="line-removed">506 {</span>
<span class="line-removed">507     auto rect = run.rect();</span>
<span class="line-removed">508     int x = rect.x();</span>
<span class="line-removed">509     int y = rect.y();</span>
<span class="line-removed">510     int logicalWidth = ceilf(rect.x() + rect.width()) - x;</span>
<span class="line-removed">511 </span>
<span class="line-removed">512     if (is&lt;RenderTableCell&gt;(*renderText.containingBlock()))</span>
<span class="line-removed">513         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*renderText.containingBlock()).intrinsicPaddingBefore());</span>
<span class="line-removed">514 </span>
<span class="line-removed">515     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;</span>
<span class="line-removed">516     ts &lt;&lt; &quot;: &quot; &lt;&lt; quoteAndEscapeNonPrintables(run.text());</span>
<span class="line-removed">517     if (run.hasHyphen())</span>
<span class="line-removed">518         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(renderText.style().hyphenString().string());</span>
<span class="line-removed">519     ts &lt;&lt; &quot;\n&quot;;</span>
<span class="line-removed">520 }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522 void write(TextStream&amp; ts, const RenderObject&amp; o, RenderAsTextBehavior behavior)</span>
523 {
524     if (is&lt;RenderSVGShape&gt;(o)) {
525         write(ts, downcast&lt;RenderSVGShape&gt;(o), behavior);
526         return;
527     }
528     if (is&lt;RenderSVGGradientStop&gt;(o)) {
529         writeSVGGradientStop(ts, downcast&lt;RenderSVGGradientStop&gt;(o), behavior);
530         return;
531     }
532     if (is&lt;RenderSVGResourceContainer&gt;(o)) {
533         writeSVGResourceContainer(ts, downcast&lt;RenderSVGResourceContainer&gt;(o), behavior);
534         return;
535     }
536     if (is&lt;RenderSVGContainer&gt;(o)) {
537         writeSVGContainer(ts, downcast&lt;RenderSVGContainer&gt;(o), behavior);
538         return;
539     }
540     if (is&lt;RenderSVGRoot&gt;(o)) {
541         write(ts, downcast&lt;RenderSVGRoot&gt;(o), behavior);
542         return;
543     }
544     if (is&lt;RenderSVGText&gt;(o)) {
545         writeSVGText(ts, downcast&lt;RenderSVGText&gt;(o), behavior);
546         return;
547     }
548     if (is&lt;RenderSVGInlineText&gt;(o)) {
549         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
550         return;
551     }
552     if (is&lt;RenderSVGImage&gt;(o)) {
553         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
554         return;
555     }
556 
557     ts &lt;&lt; indent;
558 
559     RenderTreeAsText::writeRenderObject(ts, o, behavior);
560     ts &lt;&lt; &quot;\n&quot;;
561 
562     TextStream::IndentScope indentScope(ts);
563 
564     if (is&lt;RenderText&gt;(o)) {
565         auto&amp; text = downcast&lt;RenderText&gt;(o);
<a name="16" id="anc16"></a><span class="line-modified">566         if (auto layout = text.simpleLineLayout()) {</span>
<span class="line-modified">567             ASSERT(!text.firstTextBox());</span>
<span class="line-modified">568             auto resolver = runResolver(downcast&lt;RenderBlockFlow&gt;(*text.parent()), *layout);</span>
<span class="line-removed">569             for (auto run : resolver.rangeForRenderer(text)) {</span>
<span class="line-removed">570                 ts &lt;&lt; indent;</span>
<span class="line-removed">571                 writeSimpleLine(ts, text, run);</span>
<span class="line-removed">572             }</span>
<span class="line-removed">573         } else {</span>
<span class="line-removed">574             for (auto* box = text.firstTextBox(); box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">575                 ts &lt;&lt; indent;</span>
<span class="line-removed">576                 writeTextRun(ts, text, *box);</span>
<span class="line-removed">577             }</span>
578         }
<a name="17" id="anc17"></a><span class="line-removed">579 </span>
580     } else {
581         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
582             if (child.hasLayer())
583                 continue;
584             write(ts, child, behavior);
585         }
586     }
587 
588     if (is&lt;RenderWidget&gt;(o)) {
589         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
590         if (is&lt;FrameView&gt;(widget)) {
591             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
592             if (RenderView* root = view.frame().contentRenderer()) {
<a name="18" id="anc18"></a><span class="line-modified">593                 if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
594                     view.layoutContext().layout();
595                 if (RenderLayer* layer = root-&gt;layer())
596                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
597             }
598         }
599     }
600 }
601 
602 enum LayerPaintPhase {
603     LayerPaintPhaseAll = 0,
604     LayerPaintPhaseBackground = -1,
605     LayerPaintPhaseForeground = 1
606 };
607 
608 static void writeLayer(TextStream&amp; ts, const RenderLayer&amp; layer, const LayoutRect&amp; layerBounds, const LayoutRect&amp; backgroundClipRect, const LayoutRect&amp; clipRect,
<a name="19" id="anc19"></a><span class="line-modified">609     LayerPaintPhase paintPhase = LayerPaintPhaseAll, RenderAsTextBehavior behavior = RenderAsTextBehaviorNormal)</span>
610 {
611     IntRect adjustedLayoutBounds = snappedIntRect(layerBounds);
612     IntRect adjustedBackgroundClipRect = snappedIntRect(backgroundClipRect);
613     IntRect adjustedClipRect = snappedIntRect(clipRect);
614 
615     ts &lt;&lt; indent &lt;&lt; &quot;layer &quot;;
616 
<a name="20" id="anc20"></a><span class="line-modified">617     if (behavior &amp; RenderAsTextShowAddresses)</span>
618         ts &lt;&lt; static_cast&lt;const void*&gt;(&amp;layer) &lt;&lt; &quot; &quot;;
619 
620     ts &lt;&lt; adjustedLayoutBounds;
621 
622     if (!adjustedLayoutBounds.isEmpty()) {
623         if (!adjustedBackgroundClipRect.contains(adjustedLayoutBounds))
624             ts &lt;&lt; &quot; backgroundClip &quot; &lt;&lt; adjustedBackgroundClipRect;
625         if (!adjustedClipRect.contains(adjustedLayoutBounds))
626             ts &lt;&lt; &quot; clip &quot; &lt;&lt; adjustedClipRect;
627     }
628 
629     if (layer.renderer().hasOverflowClip()) {
630         if (layer.scrollOffset().x())
631             ts &lt;&lt; &quot; scrollX &quot; &lt;&lt; layer.scrollOffset().x();
632         if (layer.scrollOffset().y())
633             ts &lt;&lt; &quot; scrollY &quot; &lt;&lt; layer.scrollOffset().y();
634         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientWidth()) != layer.scrollWidth())
635             ts &lt;&lt; &quot; scrollWidth &quot; &lt;&lt; layer.scrollWidth();
636         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientHeight()) != layer.scrollHeight())
637             ts &lt;&lt; &quot; scrollHeight &quot; &lt;&lt; layer.scrollHeight();
638 #if PLATFORM(MAC)
639         ScrollbarTheme&amp; scrollbarTheme = ScrollbarTheme::theme();
640         if (!scrollbarTheme.isMockTheme() &amp;&amp; layer.hasVerticalScrollbar()) {
641             ScrollbarThemeMac&amp; macTheme = *static_cast&lt;ScrollbarThemeMac*&gt;(&amp;scrollbarTheme);
642             if (macTheme.isLayoutDirectionRTL(*layer.verticalScrollbar()))
643                 ts &lt;&lt; &quot; scrollbarHasRTLLayoutDirection&quot;;
644         }
645 #endif
646     }
647 
648     if (paintPhase == LayerPaintPhaseBackground)
649         ts &lt;&lt; &quot; layerType: background only&quot;;
650     else if (paintPhase == LayerPaintPhaseForeground)
651         ts &lt;&lt; &quot; layerType: foreground only&quot;;
652 
<a name="21" id="anc21"></a><span class="line-modified">653     if (behavior &amp; RenderAsTextShowCompositedLayers) {</span>
654         if (layer.isComposited()) {
655             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
656                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
<a name="22" id="anc22"></a><span class="line-modified">657         }</span>

658     }
659 
660 #if ENABLE(CSS_COMPOSITING)
661     if (layer.isolatesBlending())
662         ts &lt;&lt; &quot; isolatesBlending&quot;;
663     if (layer.hasBlendMode())
664         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, layer.blendMode());
665 #endif
666 
667     ts &lt;&lt; &quot;\n&quot;;
668 }
669 
<a name="23" id="anc23"></a><span class="line-modified">670 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, RenderAsTextBehavior behavior)</span>
671 {
672     if (paintPhase != LayerPaintPhaseBackground) {
673         TextStream::IndentScope indentScope(ts);
674         write(ts, layer.renderer(), behavior);
675     }
676 }
677 
678 static LayoutSize maxLayoutOverflow(const RenderBox* box)
679 {
680     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
681     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
682 }
683 
<a name="24" id="anc24"></a><span class="line-modified">684 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, RenderAsTextBehavior behavior)</span>
685 {
686     // FIXME: Apply overflow to the root layer to not break every test. Complete hack. Sigh.
687     LayoutRect paintDirtyRect(paintRect);
688     if (&amp;rootLayer == &amp;layer) {
689         paintDirtyRect.setWidth(std::max&lt;LayoutUnit&gt;(paintDirtyRect.width(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxX()));
690         paintDirtyRect.setHeight(std::max&lt;LayoutUnit&gt;(paintDirtyRect.height(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxY()));
691         layer.setSize(layer.size().expandedTo(snappedIntSize(maxLayoutOverflow(layer.renderBox()), LayoutPoint(0, 0))));
692     }
693 
694     // Calculate the clip rects we should use.
695     LayoutRect layerBounds;
696     ClipRect damageRect;
697     ClipRect clipRectToApply;
698     LayoutSize offsetFromRoot = layer.offsetFromAncestor(&amp;rootLayer);
699     layer.calculateRects(RenderLayer::ClipRectsContext(&amp;rootLayer, TemporaryClipRects), paintDirtyRect, layerBounds, damageRect, clipRectToApply, offsetFromRoot);
700 
701     // Ensure our lists are up-to-date.
702     layer.updateLayerListsIfNeeded();
703     layer.updateDescendantDependentFlags();
704 
<a name="25" id="anc25"></a><span class="line-modified">705     bool shouldPaint = (behavior &amp; RenderAsTextShowAllLayers) ? true : layer.intersectsDamageRect(layerBounds, damageRect.rect(), &amp;rootLayer, layer.offsetFromAncestor(&amp;rootLayer));</span>
706     auto negativeZOrderLayers = layer.negativeZOrderLayers();
707     bool paintsBackgroundSeparately = negativeZOrderLayers.size() &gt; 0;
708     if (shouldPaint &amp;&amp; paintsBackgroundSeparately) {
709         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), LayerPaintPhaseBackground, behavior);
710         writeLayerRenderers(ts, layer, LayerPaintPhaseBackground, behavior);
711     }
712 
713     if (negativeZOrderLayers.size()) {
<a name="26" id="anc26"></a><span class="line-modified">714         if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">715             ts &lt;&lt; indent &lt;&lt; &quot; negative z-order list(&quot; &lt;&lt; negativeZOrderLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
716             ts.increaseIndent();
717         }
718 
719         for (auto* currLayer : negativeZOrderLayers)
720             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
721 
<a name="27" id="anc27"></a><span class="line-modified">722         if (behavior &amp; RenderAsTextShowLayerNesting)</span>
723             ts.decreaseIndent();
724     }
725 
726     if (shouldPaint) {
727         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
728 
<a name="28" id="anc28"></a><span class="line-modified">729         if (behavior &amp; RenderAsTextShowLayerFragments) {</span>
730             LayerFragments layerFragments;
731             layer.collectFragments(layerFragments, &amp;rootLayer, paintDirtyRect, RenderLayer::PaginationInclusionMode::ExcludeCompositedPaginatedLayers, TemporaryClipRects, IgnoreOverlayScrollbarSize, RespectOverflowClip, offsetFromRoot);
732 
733             if (layerFragments.size() &gt; 1) {
734                 TextStream::IndentScope indentScope(ts, 2);
735                 for (unsigned i = 0; i &lt; layerFragments.size(); ++i) {
736                     const auto&amp; fragment = layerFragments[i];
737                     ts &lt;&lt; indent &lt;&lt; &quot; fragment &quot; &lt;&lt; i &lt;&lt; &quot;: bounds in layer &quot; &lt;&lt; fragment.layerBounds &lt;&lt; &quot; fragment bounds &quot; &lt;&lt; fragment.boundingBox &lt;&lt; &quot;\n&quot;;
738                 }
739             }
740         }
741 
742         writeLayerRenderers(ts, layer, paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
743     }
744 
745     auto normalFlowLayers = layer.normalFlowLayers();
746     if (normalFlowLayers.size()) {
<a name="29" id="anc29"></a><span class="line-modified">747         if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">748             ts &lt;&lt; indent &lt;&lt; &quot; normal flow list(&quot; &lt;&lt; normalFlowLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
749             ts.increaseIndent();
750         }
751 
752         for (auto* currLayer : normalFlowLayers)
753             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
754 
<a name="30" id="anc30"></a><span class="line-modified">755         if (behavior &amp; RenderAsTextShowLayerNesting)</span>
756             ts.decreaseIndent();
757     }
758 
759     auto positiveZOrderLayers = layer.positiveZOrderLayers();
760     if (positiveZOrderLayers.size()) {
761         size_t layerCount = positiveZOrderLayers.size();
762 
763         if (layerCount) {
<a name="31" id="anc31"></a><span class="line-modified">764             if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">765                 ts &lt;&lt; indent &lt;&lt; &quot; positive z-order list(&quot; &lt;&lt; layerCount &lt;&lt; &quot;)\n&quot;;</span>
766                 ts.increaseIndent();
767             }
768 
769             for (auto* currLayer : positiveZOrderLayers)
770                 writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
771 
<a name="32" id="anc32"></a><span class="line-modified">772             if (behavior &amp; RenderAsTextShowLayerNesting)</span>
773                 ts.decreaseIndent();
774         }
775     }
776 }
777 
778 static String nodePosition(Node* node)
779 {
780     StringBuilder result;
781 
782     auto* body = node-&gt;document().bodyOrFrameset();
783     Node* parent;
784     for (Node* n = node; n; n = parent) {
785         parent = n-&gt;parentOrShadowHostNode();
786         if (n != node)
787             result.appendLiteral(&quot; of &quot;);
788         if (parent) {
789             if (body &amp;&amp; n == body) {
790                 // We don&#39;t care what offset body may be in the document.
791                 result.appendLiteral(&quot;body&quot;);
792                 break;
793             }
794             if (n-&gt;isShadowRoot()) {
795                 result.append(&#39;{&#39;);
796                 result.append(getTagName(n));
797                 result.append(&#39;}&#39;);
798             } else {
799                 result.appendLiteral(&quot;child &quot;);
800                 result.appendNumber(n-&gt;computeNodeIndex());
801                 result.appendLiteral(&quot; {&quot;);
802                 result.append(getTagName(n));
803                 result.append(&#39;}&#39;);
804             }
805         } else
806             result.appendLiteral(&quot;document&quot;);
807     }
808 
809     return result.toString();
810 }
811 
812 static void writeSelection(TextStream&amp; ts, const RenderBox&amp; renderer)
813 {
814     if (!renderer.isRenderView())
815         return;
816 
817     Frame* frame = renderer.document().frame();
818     if (!frame)
819         return;
820 
821     VisibleSelection selection = frame-&gt;selection().selection();
822     if (selection.isCaret()) {
823         ts &lt;&lt; &quot;caret: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode());
824         if (selection.affinity() == UPSTREAM)
825             ts &lt;&lt; &quot; (upstream affinity)&quot;;
826         ts &lt;&lt; &quot;\n&quot;;
827     } else if (selection.isRange())
828         ts &lt;&lt; &quot;selection start: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode()) &lt;&lt; &quot;\n&quot;
829            &lt;&lt; &quot;selection end:   position &quot; &lt;&lt; selection.end().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.end().deprecatedNode()) &lt;&lt; &quot;\n&quot;;
830 }
831 
<a name="33" id="anc33"></a><span class="line-modified">832 static String externalRepresentation(RenderBox&amp; renderer, RenderAsTextBehavior behavior)</span>
833 {
834     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
835     if (!renderer.hasLayer())
836         return ts.release();
837 
838     LOG(Layout, &quot;externalRepresentation: dumping layer tree&quot;);
839 
840     RenderLayer&amp; layer = *renderer.layer();
841     writeLayers(ts, layer, layer, layer.rect(), behavior);
842     writeSelection(ts, renderer);
843     return ts.release();
844 }
845 
846 static void updateLayoutIgnoringPendingStylesheetsIncludingSubframes(Document&amp; document)
847 {
848     document.updateLayoutIgnorePendingStylesheets();
849     auto* frame = document.frame();
850     for (auto* subframe = frame; subframe; subframe = subframe-&gt;tree().traverseNext(frame)) {
851         if (auto* document = subframe-&gt;document())
852             document-&gt;updateLayoutIgnorePendingStylesheets();
853     }
854 }
855 
<a name="34" id="anc34"></a><span class="line-modified">856 String externalRepresentation(Frame* frame, RenderAsTextBehavior behavior)</span>
857 {
858     ASSERT(frame);
859     ASSERT(frame-&gt;document());
860 
<a name="35" id="anc35"></a><span class="line-modified">861     if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
862         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(*frame-&gt;document());
863 
864     auto* renderer = frame-&gt;contentRenderer();
865     if (!renderer)
866         return String();
867 
868     PrintContext printContext(frame);
<a name="36" id="anc36"></a><span class="line-modified">869     if (behavior &amp; RenderAsTextPrintingMode)</span>
870         printContext.begin(renderer-&gt;width());
871 
872     return externalRepresentation(*renderer, behavior);
873 }
874 
<a name="37" id="anc37"></a><span class="line-modified">875 String externalRepresentation(Element* element, RenderAsTextBehavior behavior)</span>
876 {
877     ASSERT(element);
878 
879     // This function doesn&#39;t support printing mode.
<a name="38" id="anc38"></a><span class="line-modified">880     ASSERT(!(behavior &amp; RenderAsTextPrintingMode));</span>
881 
<a name="39" id="anc39"></a><span class="line-modified">882     if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
883         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(element-&gt;document());
884 
885     auto* renderer = element-&gt;renderer();
886     if (!is&lt;RenderBox&gt;(renderer))
887         return String();
888 
<a name="40" id="anc40"></a><span class="line-modified">889     return externalRepresentation(downcast&lt;RenderBox&gt;(*renderer), behavior | RenderAsTextShowAllLayers);</span>
890 }
891 
892 static void writeCounterValuesFromChildren(TextStream&amp; stream, const RenderElement* parent, bool&amp; isFirstCounter)
893 {
894     if (!parent)
895         return;
896     for (auto&amp; counter : childrenOfType&lt;RenderCounter&gt;(*parent)) {
897         if (!isFirstCounter)
898             stream &lt;&lt; &quot; &quot;;
899         isFirstCounter = false;
900         String str(counter.text());
901         stream &lt;&lt; str;
902     }
903 }
904 
905 String counterValueForElement(Element* element)
906 {
907     // Make sure the element is not freed during the layout.
908     RefPtr&lt;Element&gt; elementRef(element);
909     element-&gt;document().updateLayout();
910     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
911     bool isFirstCounter = true;
912     // The counter renderers should be children of :before or :after pseudo-elements.
913     if (PseudoElement* before = element-&gt;beforePseudoElement())
914         writeCounterValuesFromChildren(stream, before-&gt;renderer(), isFirstCounter);
915     if (PseudoElement* after = element-&gt;afterPseudoElement())
916         writeCounterValuesFromChildren(stream, after-&gt;renderer(), isFirstCounter);
917     return stream.release();
918 }
919 
920 String markerTextForListItem(Element* element)
921 {
922     // Make sure the element is not freed during the layout.
923     RefPtr&lt;Element&gt; elementRef(element);
924     element-&gt;document().updateLayout();
925 
926     RenderElement* renderer = element-&gt;renderer();
927     if (!is&lt;RenderListItem&gt;(renderer))
928         return String();
929 
930     return downcast&lt;RenderListItem&gt;(*renderer).markerText();
931 }
932 
933 } // namespace WebCore
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>