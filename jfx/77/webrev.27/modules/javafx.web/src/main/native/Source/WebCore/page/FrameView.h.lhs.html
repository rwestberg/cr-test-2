<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2    Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3              (C) 1998 Waldo Bastian (bastian@kde.org)
  4              (C) 1998, 1999 Torben Weis (weis@kde.org)
  5              (C) 1999 Lars Knoll (knoll@kde.org)
  6              (C) 1999 Antti Koivisto (koivisto@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">  7    Copyright (C) 2004-2017 Apple Inc. All rights reserved.</span>
  8 
  9    This library is free software; you can redistribute it and/or
 10    modify it under the terms of the GNU Library General Public
 11    License as published by the Free Software Foundation; either
 12    version 2 of the License, or (at your option) any later version.
 13 
 14    This library is distributed in the hope that it will be useful,
 15    but WITHOUT ANY WARRANTY; without even the implied warranty of
 16    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17    Library General Public License for more details.
 18 
 19    You should have received a copy of the GNU Library General Public License
 20    along with this library; see the file COPYING.LIB.  If not, write to
 21    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22    Boston, MA 02110-1301, USA.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;AdjustViewSizeOrNot.h&quot;
 28 #include &quot;Color.h&quot;
 29 #include &quot;ContainerNode.h&quot;
 30 #include &quot;FrameViewLayoutContext.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;LayoutMilestone.h&quot;
 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;Pagination.h&quot;
 35 #include &quot;PaintPhase.h&quot;
 36 #include &quot;RenderPtr.h&quot;
 37 #include &quot;ScrollView.h&quot;
 38 #include &quot;StyleColor.h&quot;
 39 #include &quot;TiledBacking.h&quot;
 40 #include &lt;memory&gt;
 41 #include &lt;wtf/Forward.h&gt;
 42 #include &lt;wtf/Function.h&gt;
 43 #include &lt;wtf/HashSet.h&gt;
 44 #include &lt;wtf/IsoMalloc.h&gt;
 45 #include &lt;wtf/ListHashSet.h&gt;
 46 #include &lt;wtf/OptionSet.h&gt;
 47 #include &lt;wtf/text/WTFString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 class AXObjectCache;
 52 class Element;
 53 class FloatSize;
 54 class Frame;
 55 class HTMLFrameOwnerElement;
 56 class Page;
 57 class RenderBox;
 58 class RenderElement;
 59 class RenderEmbeddedObject;
 60 class RenderLayer;
 61 class RenderLayerModelObject;
 62 class RenderObject;
 63 class RenderScrollbarPart;
 64 class RenderStyle;
 65 class RenderView;
 66 class RenderWidget;
 67 
 68 enum class FrameFlattening;
 69 
 70 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp;);
 71 
 72 class FrameView final : public ScrollView {
 73     WTF_MAKE_ISO_ALLOCATED(FrameView);
 74 public:
 75     friend class RenderView;
 76     friend class Internals;
 77     friend class FrameViewLayoutContext;
 78 
 79     WEBCORE_EXPORT static Ref&lt;FrameView&gt; create(Frame&amp;);
 80     static Ref&lt;FrameView&gt; create(Frame&amp;, const IntSize&amp; initialSize);
 81 
 82     virtual ~FrameView();
 83 
 84     HostWindow* hostWindow() const final;
 85 
 86     WEBCORE_EXPORT void invalidateRect(const IntRect&amp;) final;
 87     void setFrameRect(const IntRect&amp;) final;
 88 
 89     bool scheduleAnimation() final;
 90 
 91     Frame&amp; frame() const { return m_frame; }
 92 
 93     WEBCORE_EXPORT RenderView* renderView() const;
 94 
 95     int mapFromLayoutToCSSUnits(LayoutUnit) const;
 96     LayoutUnit mapFromCSSToLayoutUnits(int) const;
 97 
<a name="2" id="anc2"></a><span class="line-removed"> 98     LayoutUnit marginWidth() const { return m_margins.width(); } // -1 means default</span>
<span class="line-removed"> 99     LayoutUnit marginHeight() const { return m_margins.height(); } // -1 means default</span>
<span class="line-removed">100     void setMarginWidth(LayoutUnit);</span>
<span class="line-removed">101     void setMarginHeight(LayoutUnit);</span>
<span class="line-removed">102 </span>
103     WEBCORE_EXPORT void setCanHaveScrollbars(bool) final;
104     WEBCORE_EXPORT void updateCanHaveScrollbars();
105 
106     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation) final;
107 
108     bool avoidScrollbarCreation() const final;
109 
110     void setContentsSize(const IntSize&amp;) final;
111     void updateContentsSize() final;
112 
113     const FrameViewLayoutContext&amp; layoutContext() const { return m_layoutContext; }
114     FrameViewLayoutContext&amp; layoutContext() { return m_layoutContext; }
115 
116     WEBCORE_EXPORT bool didFirstLayout() const;
117     void queuePostLayoutCallback(WTF::Function&lt;void ()&gt;&amp;&amp;);
118 
119     WEBCORE_EXPORT bool needsLayout() const;
120     WEBCORE_EXPORT void setNeedsLayoutAfterViewConfigurationChange();
121 
122     void setNeedsCompositingConfigurationUpdate();
123     void setNeedsCompositingGeometryUpdate();
124 
125     void setViewportConstrainedObjectsNeedLayout();
126 
127     WEBCORE_EXPORT bool renderedCharactersExceed(unsigned threshold);
128 
129     void scheduleSelectionUpdate();
130 
131 #if PLATFORM(IOS_FAMILY)
132     bool useCustomFixedPositionLayoutRect() const;
133     IntRect customFixedPositionLayoutRect() const { return m_customFixedPositionLayoutRect; }
134     WEBCORE_EXPORT void setCustomFixedPositionLayoutRect(const IntRect&amp;);
135     bool updateFixedPositionLayoutRect();
136 
137     IntSize customSizeForResizeEvent() const { return m_customSizeForResizeEvent; }
138     WEBCORE_EXPORT void setCustomSizeForResizeEvent(IntSize);
139 
<a name="3" id="anc3"></a><span class="line-modified">140     WEBCORE_EXPORT void setScrollVelocity(double horizontalVelocity, double verticalVelocity, double scaleChangeRate, MonotonicTime timestamp);</span>
141 #else
142     bool useCustomFixedPositionLayoutRect() const { return false; }
143 #endif
144 
145     void willRecalcStyle();
146     bool updateCompositingLayersAfterStyleChange();
147     void updateCompositingLayersAfterLayout();
148 
149     // Called when changes to the GraphicsLayer hierarchy have to be synchronized with
150     // content rendered via the normal painting path.
151     void setNeedsOneShotDrawingSynchronization();
152 
153     WEBCORE_EXPORT GraphicsLayer* graphicsLayerForPlatformWidget(PlatformWidget);
154     WEBCORE_EXPORT void scheduleLayerFlushAllowingThrottling();
155 
<a name="4" id="anc4"></a><span class="line-modified">156     WEBCORE_EXPORT TiledBacking* tiledBacking() const final;</span>
157 
158     ScrollingNodeID scrollingNodeID() const override;
159     ScrollableArea* scrollableAreaForScrollLayerID(uint64_t) const;
160     bool usesAsyncScrolling() const final;
161 
162     WEBCORE_EXPORT void enterCompositingMode();
163     WEBCORE_EXPORT bool isEnclosedInCompositingLayer() const;
164 
165     // Only used with accelerated compositing, but outside the #ifdef to make linkage easier.
166     // Returns true if the flush was completed.
167     WEBCORE_EXPORT bool flushCompositingStateIncludingSubframes();
168 
169     // Returns true when a paint with the PaintBehavior::FlattenCompositingLayers flag set gives
170     // a faithful representation of the content.
171     WEBCORE_EXPORT bool isSoftwareRenderable() const;
172 
173     void setIsInWindow(bool);
174 
175     void resetScrollbars();
176     void resetScrollbarsAndClearContentsSize();
177     void prepareForDetach();
178     void detachCustomScrollbars();
179     WEBCORE_EXPORT void recalculateScrollbarOverlayStyle();
180 #if ENABLE(DARK_MODE_CSS)
181     void recalculateBaseBackgroundColor();
182 #endif
183 
184     void clear();
185     void resetLayoutMilestones();
186 
187     WEBCORE_EXPORT bool isTransparent() const;
188     WEBCORE_EXPORT void setTransparent(bool isTransparent);
189 
190     // True if the FrameView is not transparent, and the base background color is opaque.
191     bool hasOpaqueBackground() const;
192 
193     WEBCORE_EXPORT Color baseBackgroundColor() const;
194     WEBCORE_EXPORT void setBaseBackgroundColor(const Color&amp;);
195     WEBCORE_EXPORT void updateBackgroundRecursively(const Optional&lt;Color&gt;&amp; backgroundColor);
196 
197     enum ExtendedBackgroundModeFlags {
198         ExtendedBackgroundModeNone          = 0,
199         ExtendedBackgroundModeVertical      = 1 &lt;&lt; 0,
200         ExtendedBackgroundModeHorizontal    = 1 &lt;&lt; 1,
201         ExtendedBackgroundModeAll           = ExtendedBackgroundModeVertical | ExtendedBackgroundModeHorizontal,
202     };
203     typedef unsigned ExtendedBackgroundMode;
204 
205     void updateExtendBackgroundIfNecessary();
206     void updateTilesForExtendedBackgroundMode(ExtendedBackgroundMode);
207     ExtendedBackgroundMode calculateExtendedBackgroundMode() const;
208 
209     bool hasExtendedBackgroundRectForPainting() const;
210     IntRect extendedBackgroundRectForPainting() const;
211 
212     bool shouldUpdateWhileOffscreen() const;
213     WEBCORE_EXPORT void setShouldUpdateWhileOffscreen(bool);
214     bool shouldUpdate() const;
215 
216     WEBCORE_EXPORT void adjustViewSize();
217 
218     WEBCORE_EXPORT void setViewportSizeForCSSViewportUnits(IntSize);
219     void clearViewportSizeOverrideForCSSViewportUnits();
220     IntSize viewportSizeForCSSViewportUnits() const;
221 
222     IntRect windowClipRect() const final;
223     WEBCORE_EXPORT IntRect windowClipRectForFrameOwner(const HTMLFrameOwnerElement*, bool clipToLayerContents) const;
224 
225     float visibleContentScaleFactor() const final;
226 
227 #if USE(COORDINATED_GRAPHICS)
228     WEBCORE_EXPORT void setFixedVisibleContentRect(const IntRect&amp;) final;
229 #endif
230     WEBCORE_EXPORT void setScrollPosition(const ScrollPosition&amp;) final;
231     void restoreScrollbar();
232     void scheduleScrollToFocusedElement(SelectionRevealMode);
233     void scrollToFocusedElementImmediatelyIfNeeded();
234     void updateLayerPositionsAfterScrolling() final;
235     void updateCompositingLayersAfterScrolling() final;
236     bool requestScrollPositionUpdate(const ScrollPosition&amp;) final;
237     bool isRubberBandInProgress() const final;
238     WEBCORE_EXPORT ScrollPosition minimumScrollPosition() const final;
239     WEBCORE_EXPORT ScrollPosition maximumScrollPosition() const final;
240 
241     // The scrollOrigin, scrollPosition, minimumScrollPosition and maximumScrollPosition are all affected by frame scale,
242     // but layoutViewport computations require unscaled scroll positions.
243     ScrollPosition unscaledMinimumScrollPosition() const;
244     ScrollPosition unscaledMaximumScrollPosition() const;
245 
246     IntPoint unscaledScrollOrigin() const;
247 
248     WEBCORE_EXPORT LayoutPoint minStableLayoutViewportOrigin() const;
249     WEBCORE_EXPORT LayoutPoint maxStableLayoutViewportOrigin() const;
250 
251     enum class TriggerLayoutOrNot {
252         No,
253         Yes
254     };
255     // This origin can be overridden by setLayoutViewportOverrideRect.
256     void setBaseLayoutViewportOrigin(LayoutPoint, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
257     // This size can be overridden by setLayoutViewportOverrideRect.
258     WEBCORE_EXPORT LayoutSize baseLayoutViewportSize() const;
259 
260     // If set, overrides the default &quot;m_layoutViewportOrigin, size of initial containing block&quot; rect.
261     // Used with delegated scrolling (i.e. iOS).
262     WEBCORE_EXPORT void setLayoutViewportOverrideRect(Optional&lt;LayoutRect&gt;, TriggerLayoutOrNot = TriggerLayoutOrNot::Yes);
<a name="5" id="anc5"></a>
263 
264     WEBCORE_EXPORT void setVisualViewportOverrideRect(Optional&lt;LayoutRect&gt;);
<a name="6" id="anc6"></a>
265 
266     // These are in document coordinates, unaffected by page scale (but affected by zooming).
267     WEBCORE_EXPORT LayoutRect layoutViewportRect() const;
268     WEBCORE_EXPORT LayoutRect visualViewportRect() const;
269 
270     static LayoutRect visibleDocumentRect(const FloatRect&amp; visibleContentRect, float headerHeight, float footerHeight, const FloatSize&amp; totalContentsSize, float pageScaleFactor);
271 
272     // This is different than visibleContentRect() in that it ignores negative (or overly positive)
273     // offsets from rubber-banding, and it takes zooming into account.
274     LayoutRect viewportConstrainedVisibleContentRect() const;
275 
<a name="7" id="anc7"></a>

276     LayoutRect rectForFixedPositionLayout() const;
277 
278     void viewportContentsChanged();
279     WEBCORE_EXPORT void resumeVisibleImageAnimationsIncludingSubframes();
280 
281     String mediaType() const;
282     WEBCORE_EXPORT void setMediaType(const String&amp;);
283     void adjustMediaTypeForPrinting(bool printing);
284 
285     void setCannotBlitToWindow();
286     void setIsOverlapped(bool);
287     void setContentIsOpaque(bool);
288 
289     void addSlowRepaintObject(RenderElement&amp;);
290     void removeSlowRepaintObject(RenderElement&amp;);
291     bool hasSlowRepaintObject(const RenderElement&amp; renderer) const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;contains(&amp;renderer); }
292     bool hasSlowRepaintObjects() const { return m_slowRepaintObjects &amp;&amp; m_slowRepaintObjects-&gt;size(); }
293 
294     // Includes fixed- and sticky-position objects.
295     typedef HashSet&lt;RenderLayerModelObject*&gt; ViewportConstrainedObjectSet;
296     void addViewportConstrainedObject(RenderLayerModelObject*);
297     void removeViewportConstrainedObject(RenderLayerModelObject*);
298     const ViewportConstrainedObjectSet* viewportConstrainedObjects() const { return m_viewportConstrainedObjects.get(); }
299     bool hasViewportConstrainedObjects() const { return m_viewportConstrainedObjects &amp;&amp; m_viewportConstrainedObjects-&gt;size() &gt; 0; }
300 
301     float frameScaleFactor() const;
302 
303     // Functions for querying the current scrolled position, negating the effects of overhang
304     // and adjusting for page scale.
305     LayoutPoint scrollPositionForFixedPosition() const;
306 
307     // Static function can be called from another thread.
<a name="8" id="anc8"></a><span class="line-modified">308     static LayoutPoint scrollPositionForFixedPosition(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements, int headerHeight, int footerHeight);</span>
309 
310     WEBCORE_EXPORT static LayoutSize expandedLayoutViewportSize(const LayoutSize&amp; baseLayoutViewportSize, const LayoutSize&amp; documentSize, double heightExpansionFactor);
311 
312     enum class LayoutViewportConstraint { ConstrainedToDocumentRect, Unconstrained };
313     WEBCORE_EXPORT static LayoutRect computeUpdatedLayoutViewportRect(const LayoutRect&amp; layoutViewport, const LayoutRect&amp; documentRect, const LayoutSize&amp; unobscuredContentSize, const LayoutRect&amp; unobscuredContentRect, const LayoutSize&amp; baseLayoutViewportSize, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, LayoutViewportConstraint);
314 
315     WEBCORE_EXPORT static LayoutPoint computeLayoutViewportOrigin(const LayoutRect&amp; visualViewport, const LayoutPoint&amp; stableLayoutViewportOriginMin, const LayoutPoint&amp; stableLayoutViewportOriginMax, const LayoutRect&amp; layoutViewport, ScrollBehaviorForFixedElements);
316 
317     // These layers are positioned differently when there is a topContentInset, a header, or a footer. These value need to be computed
318     // on both the main thread and the scrolling thread.
319     static float yPositionForInsetClipLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
320     WEBCORE_EXPORT static FloatPoint positionForRootContentLayer(const FloatPoint&amp; scrollPosition, const FloatPoint&amp; scrollOrigin, float topContentInset, float headerHeight);
321     WEBCORE_EXPORT FloatPoint positionForRootContentLayer() const;
322 
323     static float yPositionForHeaderLayer(const FloatPoint&amp; scrollPosition, float topContentInset);
324     static float yPositionForFooterLayer(const FloatPoint&amp; scrollPosition, float topContentInset, float totalContentsHeight, float footerHeight);
325 
326 #if PLATFORM(IOS_FAMILY)
327     WEBCORE_EXPORT LayoutRect viewportConstrainedObjectsRect() const;
328     // Static function can be called from another thread.
329     WEBCORE_EXPORT static LayoutRect rectForViewportConstrainedObjects(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, float frameScaleFactor, bool fixedElementsLayoutRelativeToFrame, ScrollBehaviorForFixedElements);
330 #endif
331 
<a name="9" id="anc9"></a><span class="line-modified">332     IntRect unobscuredContentRectExpandedByContentInsets() const;</span>
333 
334     bool fixedElementsLayoutRelativeToFrame() const;
335 
336     WEBCORE_EXPORT void disableLayerFlushThrottlingTemporarilyForInteraction();
337     bool speculativeTilingEnabled() const { return m_speculativeTilingEnabled; }
338     void loadProgressingStatusChanged();
339 
340     WEBCORE_EXPORT void updateControlTints();
341 
342     WEBCORE_EXPORT bool wasScrolledByUser() const;
343     WEBCORE_EXPORT void setWasScrolledByUser(bool);
344 
345     bool safeToPropagateScrollToParent() const;
346 
347     void addEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
348     void removeEmbeddedObjectToUpdate(RenderEmbeddedObject&amp;);
349 
350     WEBCORE_EXPORT void paintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin) final;
351 
352     struct PaintingState {
353         OptionSet&lt;PaintBehavior&gt; paintBehavior;
354         bool isTopLevelPainter;
355         bool isFlatteningPaintOfRootFrame;
356         PaintingState()
357             : paintBehavior()
358             , isTopLevelPainter(false)
359             , isFlatteningPaintOfRootFrame(false)
360         {
361         }
362     };
363 
364     void willPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
365     void didPaintContents(GraphicsContext&amp;, const IntRect&amp; dirtyRect, PaintingState&amp;);
366 
367 #if PLATFORM(IOS_FAMILY)
368     WEBCORE_EXPORT void didReplaceMultipartContent();
369 #endif
370 
371     WEBCORE_EXPORT void setPaintBehavior(OptionSet&lt;PaintBehavior&gt;);
372     WEBCORE_EXPORT OptionSet&lt;PaintBehavior&gt; paintBehavior() const;
373     bool isPainting() const;
374     bool hasEverPainted() const { return !!m_lastPaintTime; }
375     void setLastPaintTime(MonotonicTime lastPaintTime) { m_lastPaintTime = lastPaintTime; }
376     WEBCORE_EXPORT void setNodeToDraw(Node*);
377 
378     enum SelectionInSnapshot { IncludeSelection, ExcludeSelection };
379     enum CoordinateSpaceForSnapshot { DocumentCoordinates, ViewCoordinates };
380     WEBCORE_EXPORT void paintContentsForSnapshot(GraphicsContext&amp;, const IntRect&amp; imageRect, SelectionInSnapshot shouldPaintSelection, CoordinateSpaceForSnapshot);
381 
382     void paintOverhangAreas(GraphicsContext&amp;, const IntRect&amp; horizontalOverhangArea, const IntRect&amp; verticalOverhangArea, const IntRect&amp; dirtyRect) final;
383     void paintScrollCorner(GraphicsContext&amp;, const IntRect&amp; cornerRect) final;
384     void paintScrollbar(GraphicsContext&amp;, Scrollbar&amp;, const IntRect&amp;) final;
385 
386     WEBCORE_EXPORT Color documentBackgroundColor() const;
387 
388     bool isInChildFrameWithFrameFlattening() const;
389 
390     void startDisallowingLayout() { layoutContext().startDisallowingLayout(); }
391     void endDisallowingLayout() { layoutContext().endDisallowingLayout(); }
392 
393     static MonotonicTime currentPaintTimeStamp() { return sCurrentPaintTimeStamp; } // returns 0 if not painting
394 
395     WEBCORE_EXPORT void updateLayoutAndStyleIfNeededRecursive();
396 
397     void incrementVisuallyNonEmptyCharacterCount(const String&amp;);
398     void incrementVisuallyNonEmptyPixelCount(const IntSize&amp;);
399     void updateIsVisuallyNonEmpty();
400     void updateSignificantRenderedTextMilestoneIfNeeded();
401     bool isVisuallyNonEmpty() const { return m_isVisuallyNonEmpty; }
<a name="10" id="anc10"></a><span class="line-modified">402     WEBCORE_EXPORT void enableAutoSizeMode(bool enable, const IntSize&amp; minSize, const IntSize&amp; maxSize);</span>


403     WEBCORE_EXPORT void setAutoSizeFixedMinimumHeight(int);
<a name="11" id="anc11"></a>
404     IntSize autoSizingIntrinsicContentSize() const { return m_autoSizeContentSize; }
405 
406     WEBCORE_EXPORT void forceLayout(bool allowSubtreeLayout = false);
407     WEBCORE_EXPORT void forceLayoutForPagination(const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkFactor, AdjustViewSizeOrNot);
408 
409     // FIXME: This method is retained because of embedded WebViews in AppKit.  When a WebView is embedded inside
410     // some enclosing view with auto-pagination, no call happens to resize the view.  The new pagination model
411     // needs the view to resize as a result of the breaks, but that means that the enclosing view has to potentially
412     // resize around that view.  Auto-pagination uses the bounds of the actual view that&#39;s being printed to determine
413     // the edges of the print operation, so the resize is necessary if the enclosing view&#39;s bounds depend on the
414     // web document&#39;s bounds.
415     //
416     // This is already a problem if the view needs to be a different size because of printer fonts or because of print stylesheets.
417     // Mail/Dictionary work around this problem by using the _layoutForPrinting SPI
418     // to at least get print stylesheets and printer fonts into play, but since WebKit doesn&#39;t know about the page offset or
419     // page size, it can&#39;t actually paginate correctly during _layoutForPrinting.
420     //
421     // We can eventually move Mail to a newer SPI that would let them opt in to the layout-time pagination model,
422     // but that doesn&#39;t solve the general problem of how other AppKit views could opt in to the better model.
423     //
424     // NO OTHER PLATFORM BESIDES MAC SHOULD USE THIS METHOD.
425     WEBCORE_EXPORT void adjustPageHeightDeprecated(float* newBottom, float oldTop, float oldBottom, float bottomLimit);
426 
427     bool scrollToFragment(const URL&amp;);
428     bool scrollToAnchor(const String&amp;);
429     void maintainScrollPositionAtAnchor(ContainerNode*);
430     WEBCORE_EXPORT void scrollElementToRect(const Element&amp;, const IntRect&amp;);
431 
432     // Coordinate systems:
433     //
434     // &quot;View&quot;
435     //     Top left is top left of the FrameView/ScrollView/Widget. Size is Widget::boundsRect().size().
436     //
437     // &quot;TotalContents&quot;
438     //    Relative to ScrollView&#39;s scrolled contents, including headers and footers. Size is totalContentsSize().
439     //
440     // &quot;Contents&quot;
441     //    Relative to ScrollView&#39;s scrolled contents, excluding headers and footers, so top left is top left of the scroll view&#39;s
442     //    document, and size is contentsSize().
443     //
444     // &quot;Absolute&quot;
445     //    Relative to the document&#39;s scroll origin (non-zero for RTL documents), but affected by page zoom and page scale. Mostly used
446     //    in rendering code.
447     //
448     // &quot;Document&quot;
449     //    Relative to the document&#39;s scroll origin, but not affected by page zoom or page scale. Size is equivalent to CSS pixel dimensions.
450     //    FIXME: some uses are affected by page zoom (e.g. layout and visual viewports).
451     //
452     // &quot;Client&quot;
453     //    Relative to the visible part of the document (or, more strictly, the layout viewport rect), and with the same scaling
454     //    as Document coordinates, i.e. matching CSS pixels. Affected by scroll origin.
455     //
456     // &quot;LayoutViewport&quot;
457     //    Similar to client coordinates, but affected by page zoom (but not page scale).
458     //
459 
460     // Methods to convert points and rects between the coordinate space of the renderer, and this view.
461     WEBCORE_EXPORT IntRect convertFromRendererToContainingView(const RenderElement*, const IntRect&amp;) const;
462     WEBCORE_EXPORT IntRect convertFromContainingViewToRenderer(const RenderElement*, const IntRect&amp;) const;
463     WEBCORE_EXPORT FloatRect convertFromContainingViewToRenderer(const RenderElement*, const FloatRect&amp;) const;
464     WEBCORE_EXPORT IntPoint convertFromRendererToContainingView(const RenderElement*, const IntPoint&amp;) const;
465     WEBCORE_EXPORT IntPoint convertFromContainingViewToRenderer(const RenderElement*, const IntPoint&amp;) const;
466 
467     // Override ScrollView methods to do point conversion via renderers, in order to take transforms into account.
468     IntRect convertToContainingView(const IntRect&amp;) const final;
469     IntRect convertFromContainingView(const IntRect&amp;) const final;
470     FloatRect convertFromContainingView(const FloatRect&amp;) const final;
471     IntPoint convertToContainingView(const IntPoint&amp;) const final;
472     IntPoint convertFromContainingView(const IntPoint&amp;) const final;
473 
474     float documentToAbsoluteScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
475     float absoluteToDocumentScaleFactor(Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
476 
<a name="12" id="anc12"></a><span class="line-modified">477     FloatRect absoluteToDocumentRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
<span class="line-modified">478     FloatPoint absoluteToDocumentPoint(FloatPoint, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;</span>
479 
480     FloatRect absoluteToClientRect(FloatRect, Optional&lt;float&gt; effectiveZoom = WTF::nullopt) const;
481 
482     FloatSize documentToClientOffset() const;
<a name="13" id="anc13"></a><span class="line-modified">483     FloatRect documentToClientRect(FloatRect) const;</span>
484     FloatPoint documentToClientPoint(FloatPoint) const;
485     WEBCORE_EXPORT FloatRect clientToDocumentRect(FloatRect) const;
486     WEBCORE_EXPORT FloatPoint clientToDocumentPoint(FloatPoint) const;
487 
<a name="14" id="anc14"></a>
488     FloatPoint layoutViewportToAbsolutePoint(FloatPoint) const;
489 
<a name="15" id="anc15"></a>


490     // Unlike client coordinates, layout viewport coordinates are affected by page zoom.
491     WEBCORE_EXPORT FloatRect clientToLayoutViewportRect(FloatRect) const;
492     WEBCORE_EXPORT FloatPoint clientToLayoutViewportPoint(FloatPoint) const;
493 
494     bool isFrameViewScrollCorner(const RenderScrollbarPart&amp; scrollCorner) const { return m_scrollCorner.get() == &amp;scrollCorner; }
495 
496     // isScrollable() takes an optional Scrollability parameter that allows the caller to define what they mean by &#39;scrollable.&#39;
497     // Most callers are interested in the default value, Scrollability::Scrollable, which means that there is actually content
498     // to scroll to, and a scrollbar that will allow you to access it. In some cases, callers want to know if the FrameView is allowed
499     // to rubber-band, which the main frame might be allowed to do even if there is no content to scroll to. In that case,
500     // callers use Scrollability::ScrollableOrRubberbandable.
501     enum class Scrollability { Scrollable, ScrollableOrRubberbandable };
502     WEBCORE_EXPORT bool isScrollable(Scrollability definitionOfScrollable = Scrollability::Scrollable);
503 
504     bool isScrollableOrRubberbandable() final;
505     bool hasScrollableOrRubberbandableAncestor() final;
506 
507     enum ScrollbarModesCalculationStrategy { RulesFromWebContentOnly, AnyRule };
508     void calculateScrollbarModesForLayout(ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode, ScrollbarModesCalculationStrategy = AnyRule);
509 
510     IntPoint lastKnownMousePosition() const final;
511     bool isHandlingWheelEvent() const final;
512     bool shouldSetCursor() const;
513 
514     WEBCORE_EXPORT bool useDarkAppearance() const final;
515     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
516 
517     // FIXME: Remove this method once plugin loading is decoupled from layout.
518     void flushAnyPendingPostLayoutTasks();
519 
520     bool shouldSuspendScrollAnimations() const final;
521     void scrollbarStyleChanged(ScrollbarStyle, bool forceUpdate) override;
522 
523     RenderBox* embeddedContentBox() const;
524 
525     WEBCORE_EXPORT void setTracksRepaints(bool);
526     bool isTrackingRepaints() const { return m_isTrackingRepaints; }
527     WEBCORE_EXPORT void resetTrackedRepaints();
528     const Vector&lt;FloatRect&gt;&amp; trackedRepaintRects() const { return m_trackedRepaintRects; }
529     String trackedRepaintRectsAsText() const;
530 
531     typedef HashSet&lt;ScrollableArea*&gt; ScrollableAreaSet;
532     // Returns whether the scrollable area has just been newly added.
533     WEBCORE_EXPORT bool addScrollableArea(ScrollableArea*);
534     // Returns whether the scrollable area has just been removed.
535     WEBCORE_EXPORT bool removeScrollableArea(ScrollableArea*);
536     bool containsScrollableArea(ScrollableArea*) const;
537     const ScrollableAreaSet* scrollableAreas() const { return m_scrollableAreas.get(); }
538 
539     WEBCORE_EXPORT void addChild(Widget&amp;) final;
540     WEBCORE_EXPORT void removeChild(Widget&amp;) final;
541 
542     // This function exists for ports that need to handle wheel events manually.
543     // On Mac WebKit1 the underlying NSScrollView just does the scrolling, but on most other platforms
544     // we need this function in order to do the scroll ourselves.
545     bool wheelEvent(const PlatformWheelEvent&amp;);
546 
547     WEBCORE_EXPORT void setScrollingPerformanceLoggingEnabled(bool);
548 
549     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
550     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
551     // FrameViews in the page cache, but FrameView::pagination() only affects the current
552     // FrameView. FrameView::pagination() will return m_pagination if it has been set. Otherwise,
553     // it will return Page::pagination() since currently there are no callers that need to
554     // distinguish between the two.
555     const Pagination&amp; pagination() const;
556     void setPagination(const Pagination&amp;);
557 
<a name="16" id="anc16"></a><span class="line-removed">558     bool inProgrammaticScroll() const final { return m_inProgrammaticScroll; }</span>
<span class="line-removed">559     void setInProgrammaticScroll(bool programmaticScroll) { m_inProgrammaticScroll = programmaticScroll; }</span>
<span class="line-removed">560 </span>
561 #if ENABLE(CSS_DEVICE_ADAPTATION)
562     IntSize initialViewportSize() const { return m_initialViewportSize; }
563     void setInitialViewportSize(const IntSize&amp; size) { m_initialViewportSize = size; }
564 #endif
565 
566     bool isActive() const final;
567     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const final;
568 
569 #if ENABLE(RUBBER_BANDING)
570     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForTopOverHangArea(bool) const;
571     WEBCORE_EXPORT GraphicsLayer* setWantsLayerForBottomOverHangArea(bool) const;
572 #endif
573 
574     // This function &quot;smears&quot; the &quot;position:fixed&quot; uninflatedBounds for scrolling, returning a rect that is the union of
575     // all possible locations of the given rect under page scrolling.
576     LayoutRect fixedScrollableAreaBoundsInflatedForScrolling(const LayoutRect&amp; uninflatedBounds) const;
577 
578     LayoutPoint scrollPositionRespectingCustomFixedPosition() const;
579 
580     WEBCORE_EXPORT int headerHeight() const final;
581     WEBCORE_EXPORT int footerHeight() const final;
582 
583     WEBCORE_EXPORT float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const final;
584     void topContentInsetDidChange(float newTopContentInset);
585 
586     void topContentDirectionDidChange();
587 
588     WEBCORE_EXPORT void willStartLiveResize() final;
589     WEBCORE_EXPORT void willEndLiveResize() final;
590 
591     WEBCORE_EXPORT void availableContentSizeChanged(AvailableSizeChangeReason) final;
592 
593     void updateTiledBackingAdaptiveSizing();
594     TiledBacking::Scrollability computeScrollability() const;
595 
<a name="17" id="anc17"></a><span class="line-removed">596 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">597     WEBCORE_EXPORT void didUpdateViewportOverrideRects();</span>
<span class="line-removed">598 #endif</span>
<span class="line-removed">599 </span>
600     void addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt;);
601     void firePaintRelatedMilestonesIfNeeded();
602     void fireLayoutRelatedMilestonesIfNeeded();
603     OptionSet&lt;LayoutMilestone&gt; milestonesPendingPaint() const { return m_milestonesPendingPaint; }
604 
605     bool visualUpdatesAllowedByClient() const { return m_visualUpdatesAllowedByClient; }
606     WEBCORE_EXPORT void setVisualUpdatesAllowedByClient(bool);
607 
608     WEBCORE_EXPORT void setScrollPinningBehavior(ScrollPinningBehavior);
609 
610     ScrollBehaviorForFixedElements scrollBehaviorForFixedElements() const;
611 
612     bool hasFlippedBlockRenderers() const { return m_hasFlippedBlockRenderers; }
613     void setHasFlippedBlockRenderers(bool b) { m_hasFlippedBlockRenderers = b; }
614 
615     void updateWidgetPositions();
616     void scheduleUpdateWidgetPositions();
617 
618     void didAddWidgetToRenderTree(Widget&amp;);
619     void willRemoveWidgetFromRenderTree(Widget&amp;);
620 
621     const HashSet&lt;Widget*&gt;&amp; widgetsInRenderTree() const { return m_widgetsInRenderTree; }
622 
623     void addTrackedRepaintRect(const FloatRect&amp;);
624 
625     // exposedRect represents WebKit&#39;s understanding of what part
626     // of the view is actually exposed on screen (taking into account
627     // clipping by other UI elements), whereas visibleContentRect is
628     // internal to WebCore and doesn&#39;t respect those things.
629     WEBCORE_EXPORT void setViewExposedRect(Optional&lt;FloatRect&gt;);
630     Optional&lt;FloatRect&gt; viewExposedRect() const { return m_viewExposedRect; }
631 
632 #if ENABLE(CSS_SCROLL_SNAP)
633     void updateSnapOffsets() final;
634     bool isScrollSnapInProgress() const final;
635     void updateScrollingCoordinatorScrollSnapProperties() const;
636 #endif
637 
638     float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity) final;
639 
640     void didChangeScrollOffset();
641 
642     void show() final;
643     void hide() final;
644 
645     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final;
646 
647     void didRestoreFromPageCache();
648 
649     void willDestroyRenderTree();
650     void didDestroyRenderTree();
651 
652     void setSpeculativeTilingDelayDisabledForTesting(bool disabled) { m_speculativeTilingDelayDisabledForTesting = disabled; }
653 
654     WEBCORE_EXPORT FrameFlattening effectiveFrameFlattening() const;
655 
656     WEBCORE_EXPORT void traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons);
657     void invalidateControlTints() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingControlTints); }
658     void invalidateImagesWithAsyncDecodes() { traverseForPaintInvalidation(GraphicsContext::PaintInvalidationReasons::InvalidatingImagesWithAsyncDecodes); }
659 
660     GraphicsLayer* layerForHorizontalScrollbar() const final;
661     GraphicsLayer* layerForVerticalScrollbar() const final;
662 
663 protected:
664     bool scrollContentsFastPath(const IntSize&amp; scrollDelta, const IntRect&amp; rectToScroll, const IntRect&amp; clipRect) final;
665     void scrollContentsSlowPath(const IntRect&amp; updateRect) final;
666 
667     void repaintSlowRepaintObjects();
668 
669     bool isVerticalDocument() const final;
670     bool isFlippedDocument() const final;
671 
672 private:
673     explicit FrameView(Frame&amp;);
674 
675     void reset();
676     void init();
677 
678     enum LayoutPhase {
679         OutsideLayout,
680         InPreLayout,
681         InRenderTreeLayout,
682         InViewSizeAdjust,
683         InPostLayout
684     };
685 
686     bool isFrameView() const final { return true; }
687 
688     friend class RenderWidget;
689     bool useSlowRepaints(bool considerOverlap = true) const;
690     bool useSlowRepaintsIfNotOverlapped() const;
691     void updateCanBlitOnScrollRecursively();
692     bool shouldLayoutAfterContentsResized() const;
693 
694     bool shouldUpdateCompositingLayersAfterScrolling() const;
695     bool flushCompositingStateForThisFrame(const Frame&amp; rootFrameForFlush);
696 
697     bool shouldDeferScrollUpdateAfterContentSizeChange() final;
698 
699     void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset) final;
700 
701     void applyOverflowToViewport(const RenderElement&amp;, ScrollbarMode&amp; hMode, ScrollbarMode&amp; vMode);
702     void applyPaginationToViewport();
703 
704     void updateOverflowStatus(bool horizontalOverflow, bool verticalOverflow);
705 
706     void forceLayoutParentViewIfNeeded();
707     void flushPostLayoutTasksQueue();
708     void performPostLayoutTasks();
709     void autoSizeIfEnabled();
710 
711     void applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp;);
712     void resumeVisibleImageAnimations(const IntRect&amp; visibleRect);
713     void updateScriptedAnimationsAndTimersThrottlingState(const IntRect&amp; visibleRect);
714 
715     void updateLayerFlushThrottling();
716     WEBCORE_EXPORT void adjustTiledBackingCoverage();
717 
718     void repaintContentRectangle(const IntRect&amp;) final;
719     void addedOrRemovedScrollbar() final;
720 
721     void scrollToFocusedElementTimerFired();
722     void scrollToFocusedElementInternal();
723 
724     void delegatesScrollingDidChange() final;
725 
726     // ScrollableArea interface
727     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) final;
728     void scrollTo(const ScrollPosition&amp;) final;
729     void setVisibleScrollerThumbRect(const IntRect&amp;) final;
730     ScrollableArea* enclosingScrollableArea() const final;
731     IntRect scrollableAreaBoundingBox(bool* = nullptr) const final;
732     bool scrollAnimatorEnabled() const final;
733     GraphicsLayer* layerForScrollCorner() const final;
734 #if ENABLE(RUBBER_BANDING)
735     GraphicsLayer* layerForOverhangAreas() const final;
736 #endif
737     void contentsResized() final;
738 
739 #if PLATFORM(IOS_FAMILY)
740     void unobscuredContentSizeChanged() final;
741 #endif
742 
743 #if ENABLE(DARK_MODE_CSS)
<a name="18" id="anc18"></a><span class="line-modified">744     RenderObject* rendererForSupportedColorSchemes() const;</span>
745 #endif
746 
747     bool usesCompositedScrolling() const final;
748     bool usesMockScrollAnimator() const final;
749     void logMockScrollAnimatorMessage(const String&amp;) const final;
750 
751     // Override scrollbar notifications to update the AXObject cache.
752     void didAddScrollbar(Scrollbar*, ScrollbarOrientation) final;
753     void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation) final;
754 
755     IntSize sizeForResizeEvent() const;
756     void sendResizeEventIfNeeded();
757 
758     void adjustScrollbarsForLayout(bool firstLayout);
759 
760     void handleDeferredScrollbarsUpdateAfterDirectionChange();
761 
762     void updateScrollableAreaSet();
763     void updateLayoutViewport();
764 
765     void notifyPageThatContentAreaWillPaint() const final;
766 
767     void enableSpeculativeTilingIfNeeded();
768     void speculativeTilingEnableTimerFired();
769 
770     void updateEmbeddedObjectsTimerFired();
771     bool updateEmbeddedObjects();
772     void updateEmbeddedObject(RenderEmbeddedObject&amp;);
773 
774     void updateWidgetPositionsTimerFired();
775 
776     void scrollToAnchor();
777     void scrollPositionChanged(const ScrollPosition&amp; oldPosition, const ScrollPosition&amp; newPosition);
778     void scrollableAreaSetChanged();
779     void sendScrollEvent();
780     void resetScrollAnchor();
781 
782     bool hasCustomScrollbars() const;
783 
784     void updateScrollCorner() final;
785 
786     FrameView* parentFrameView() const;
787 
788     bool frameFlatteningEnabled() const;
789     bool isFrameFlatteningValidForThisFrame() const;
790 
791     void markRootOrBodyRendererDirty() const;
792 
<a name="19" id="anc19"></a><span class="line-removed">793     bool qualifiesAsVisuallyNonEmpty() const;</span>
794     bool qualifiesAsSignificantRenderedText() const;
795     void updateHasReachedSignificantRenderedTextThreshold();
796 
797     bool isViewForDocumentInFrame() const;
798 
799     AXObjectCache* axObjectCache() const;
800     void notifyWidgetsInAllFrames(WidgetNotification);
801     void removeFromAXObjectCache();
802     void notifyWidgets(WidgetNotification);
803 
804     RenderElement* viewportRenderer() const;
805 
806     void willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
807     void didLayout(WeakPtr&lt;RenderElement&gt; layoutRoot);
808 
809     struct OverrideViewportSize {
810         Optional&lt;int&gt; width;
811         Optional&lt;int&gt; height;
812 
813         bool operator==(const OverrideViewportSize&amp; rhs) const { return rhs.width == width &amp;&amp; rhs.height == height; }
814     };
815     void overrideViewportSizeForCSSViewportUnits(OverrideViewportSize);
816 
817     static MonotonicTime sCurrentPaintTimeStamp; // used for detecting decoded resource thrash in the cache
818 
819     const Ref&lt;Frame&gt; m_frame;
820     FrameViewLayoutContext m_layoutContext;
821 
822     HashSet&lt;Widget*&gt; m_widgetsInRenderTree;
823     std::unique_ptr&lt;ListHashSet&lt;RenderEmbeddedObject*&gt;&gt; m_embeddedObjectsToUpdate;
824     std::unique_ptr&lt;HashSet&lt;const RenderElement*&gt;&gt; m_slowRepaintObjects;
825 
826     RefPtr&lt;ContainerNode&gt; m_maintainScrollPositionAnchor;
827     RefPtr&lt;Node&gt; m_nodeToDraw;
828 
829     // Renderer to hold our custom scroll corner.
830     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
831 
832     Timer m_updateEmbeddedObjectsTimer;
833     Timer m_updateWidgetPositionsTimer;
834     Timer m_delayedScrollEventTimer;
835     Timer m_delayedScrollToFocusedElementTimer;
836     Timer m_speculativeTilingEnableTimer;
837 
838     MonotonicTime m_lastPaintTime;
839 
840     LayoutSize m_size;
<a name="20" id="anc20"></a><span class="line-removed">841     LayoutSize m_margins;</span>
842 
843     Color m_baseBackgroundColor { Color::white };
844     IntSize m_lastViewportSize;
845 
846     String m_mediaType { &quot;screen&quot;_s };
847     String m_mediaTypeWhenNotPrinting;
848 
849     Vector&lt;FloatRect&gt; m_trackedRepaintRects;
850 
851     IntRect* m_cachedWindowClipRect { nullptr };
852     Vector&lt;WTF::Function&lt;void ()&gt;&gt; m_postLayoutCallbackQueue;
853 
854     LayoutPoint m_layoutViewportOrigin;
855     Optional&lt;LayoutRect&gt; m_layoutViewportOverrideRect;
856     Optional&lt;LayoutRect&gt; m_visualViewportOverrideRect; // Used when the iOS keyboard is showing.
857 
858     Optional&lt;FloatRect&gt; m_viewExposedRect;
859 
860     OptionSet&lt;PaintBehavior&gt; m_paintBehavior;
861 
862     float m_lastZoomFactor { 1 };
863     unsigned m_visuallyNonEmptyCharacterCount { 0 };
864     unsigned m_visuallyNonEmptyPixelCount { 0 };
865     unsigned m_textRendererCountForVisuallyNonEmptyCharacters { 0 };
866     int m_headerHeight { 0 };
867     int m_footerHeight { 0 };
868 
869 #if PLATFORM(IOS_FAMILY)
870     bool m_useCustomFixedPositionLayoutRect { false };
871     bool m_useCustomSizeForResizeEvent { false };
872 
873     IntRect m_customFixedPositionLayoutRect;
874     IntSize m_customSizeForResizeEvent;
875 #endif
876 
877     Optional&lt;OverrideViewportSize&gt; m_overrideViewportSize;
878 
<a name="21" id="anc21"></a><span class="line-modified">879     // The lower bound on the size when autosizing.</span>
<span class="line-modified">880     IntSize m_minAutoSize;</span>
<span class="line-removed">881     // The upper bound on the size when autosizing.</span>
<span class="line-removed">882     IntSize m_maxAutoSize;</span>
883     // The fixed height to resize the view to after autosizing is complete.
884     int m_autoSizeFixedMinimumHeight { 0 };
885     // The intrinsic content size decided by autosizing.
886     IntSize m_autoSizeContentSize;
887 
888     std::unique_ptr&lt;ScrollableAreaSet&gt; m_scrollableAreas;
889     std::unique_ptr&lt;ViewportConstrainedObjectSet&gt; m_viewportConstrainedObjects;
890 
891     OptionSet&lt;LayoutMilestone&gt; m_milestonesPendingPaint;
892 
893     static const unsigned visualCharacterThreshold = 200;
894     static const unsigned visualPixelThreshold = 32 * 32;
895 
896 #if ENABLE(CSS_DEVICE_ADAPTATION)
897     // Size of viewport before any UA or author styles have overridden
898     // the viewport given by the window or viewing area of the UA.
899     IntSize m_initialViewportSize;
900 #endif
901 
902     Pagination m_pagination;
903 
904     enum class ViewportRendererType : uint8_t { None, Document, Body };
905     ViewportRendererType m_viewportRendererType { ViewportRendererType::None };
906     ScrollPinningBehavior m_scrollPinningBehavior { DoNotPin };
907     SelectionRevealMode m_selectionRevealModeForFocusedElement { SelectionRevealMode::DoNotReveal };
908 
909     bool m_shouldUpdateWhileOffscreen { true };
910     bool m_overflowStatusDirty { true };
911     bool m_horizontalOverflow { false };
912     bool m_verticalOverflow { false };
913     bool m_canHaveScrollbars { true };
914     bool m_cannotBlitToWindow { false };
915     bool m_isOverlapped { false };
916     bool m_contentIsOpaque { false };
917     bool m_firstLayoutCallbackPending { false };
918 
919     bool m_isTransparent { false };
920 #if ENABLE(DARK_MODE_CSS)
921     bool m_usesDarkAppearance { false };
922 #endif
923 
924     bool m_isTrackingRepaints { false }; // Used for testing.
925     bool m_wasScrolledByUser { false };
<a name="22" id="anc22"></a><span class="line-removed">926     bool m_inProgrammaticScroll { false };</span>
927     bool m_shouldScrollToFocusedElement { false };
928 
929     bool m_isPainting { false };
930 
931     bool m_isVisuallyNonEmpty { false };
932 
933     bool m_renderedSignificantAmountOfText { false };
934     bool m_hasReachedSignificantRenderedTextThreshold { false };
935 
936     bool m_needsDeferredScrollbarsUpdate { false };
937     bool m_speculativeTilingEnabled { false };
938     bool m_visualUpdatesAllowedByClient { true };
939     bool m_hasFlippedBlockRenderers { false };
940     bool m_speculativeTilingDelayDisabledForTesting { false };
941 
942     // If true, automatically resize the frame view around its content.
943     bool m_shouldAutoSize { false };
944     bool m_inAutoSize { false };
945     // True if autosize has been run since m_shouldAutoSize was set.
946     bool m_didRunAutosize { false };
947 };
948 
949 inline void FrameView::incrementVisuallyNonEmptyPixelCount(const IntSize&amp; size)
950 {
951     if (m_visuallyNonEmptyPixelCount &gt; visualPixelThreshold)
952         return;
953     m_visuallyNonEmptyPixelCount += size.width() * size.height();
954 }
955 
956 } // namespace WebCore
957 
958 SPECIALIZE_TYPE_TRAITS_WIDGET(FrameView, isFrameView())
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>