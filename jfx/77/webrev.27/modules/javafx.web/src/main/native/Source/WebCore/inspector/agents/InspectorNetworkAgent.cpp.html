<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
   3  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;InspectorNetworkAgent.h&quot;
  34 
  35 #include &quot;CachedCSSStyleSheet.h&quot;
  36 #include &quot;CachedRawResource.h&quot;
  37 #include &quot;CachedResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;CachedResourceRequestInitiators.h&quot;
  40 #include &quot;CachedScript.h&quot;
  41 #include &quot;CertificateInfo.h&quot;
  42 #include &quot;CustomHeaderFields.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentThreadableLoader.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;HTTPHeaderMap.h&quot;
  49 #include &quot;HTTPHeaderNames.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorTimelineAgent.h&quot;
  52 #include &quot;InstrumentingAgents.h&quot;
  53 #include &quot;JSExecState.h&quot;
  54 #include &quot;JSWebSocket.h&quot;
  55 #include &quot;LoaderStrategy.h&quot;
  56 #include &quot;MIMETypeRegistry.h&quot;
  57 #include &quot;MemoryCache.h&quot;
  58 #include &quot;NetworkResourcesData.h&quot;
  59 #include &quot;Page.h&quot;
  60 #include &quot;PlatformStrategies.h&quot;
  61 #include &quot;ProgressTracker.h&quot;
  62 #include &quot;ResourceError.h&quot;
  63 #include &quot;ResourceLoader.h&quot;
  64 #include &quot;ResourceRequest.h&quot;
  65 #include &quot;ResourceResponse.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;ScriptState.h&quot;
  68 #include &quot;ScriptableDocumentParser.h&quot;
  69 #include &quot;SubresourceLoader.h&quot;
  70 #include &quot;TextResourceDecoder.h&quot;
  71 #include &quot;ThreadableLoaderClient.h&quot;
  72 #include &lt;wtf/URL.h&gt;
  73 #include &quot;WebSocket.h&quot;
  74 #include &quot;WebSocketChannel.h&quot;
  75 #include &quot;WebSocketFrame.h&quot;
  76 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  77 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  78 #include &lt;JavaScriptCore/InjectedScript.h&gt;
  79 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
  80 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  81 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  82 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
  83 #include &lt;wtf/JSONValues.h&gt;
  84 #include &lt;wtf/Lock.h&gt;
  85 #include &lt;wtf/RefPtr.h&gt;
  86 #include &lt;wtf/Stopwatch.h&gt;
  87 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
  88 #include &lt;wtf/text/Base64.h&gt;
  89 #include &lt;wtf/text/StringBuilder.h&gt;
  90 
  91 typedef Inspector::NetworkBackendDispatcherHandler::LoadResourceCallback LoadResourceCallback;
  92 
  93 namespace WebCore {
  94 
  95 using namespace Inspector;
  96 
  97 namespace {
  98 
  99 class InspectorThreadableLoaderClient final : public ThreadableLoaderClient {
 100     WTF_MAKE_NONCOPYABLE(InspectorThreadableLoaderClient);
 101 public:
 102     InspectorThreadableLoaderClient(RefPtr&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 103         : m_callback(WTFMove(callback))
 104     {
 105     }
 106 
 107     virtual ~InspectorThreadableLoaderClient() = default;
 108 
 109     void didReceiveResponse(unsigned long, const ResourceResponse&amp; response) override
 110     {
 111         m_mimeType = response.mimeType();
 112         m_statusCode = response.httpStatusCode();
 113 
 114         // FIXME: This assumes text only responses. We should support non-text responses as well.
 115         TextEncoding textEncoding(response.textEncodingName());
 116         bool useDetector = false;
 117         if (!textEncoding.isValid()) {
 118             textEncoding = UTF8Encoding();
 119             useDetector = true;
 120         }
 121 
 122         m_decoder = TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncoding, useDetector);
 123     }
 124 
 125     void didReceiveData(const char* data, int dataLength) override
 126     {
 127         if (!dataLength)
 128             return;
 129 
 130         if (dataLength == -1)
 131             dataLength = strlen(data);
 132 
 133         m_responseText.append(m_decoder-&gt;decode(data, dataLength));
 134     }
 135 
 136     void didFinishLoading(unsigned long) override
 137     {
 138         if (m_decoder)
 139             m_responseText.append(m_decoder-&gt;flush());
 140 
 141         m_callback-&gt;sendSuccess(m_responseText.toString(), m_mimeType, m_statusCode);
 142         dispose();
 143     }
 144 
 145     void didFail(const ResourceError&amp; error) override
 146     {
 147         m_callback-&gt;sendFailure(error.isAccessControl() ? &quot;Loading resource for inspector failed access control check&quot;_s : &quot;Loading resource for inspector failed&quot;_s);
 148         dispose();
 149     }
 150 
 151     void setLoader(RefPtr&lt;ThreadableLoader&gt;&amp;&amp; loader)
 152     {
 153         m_loader = WTFMove(loader);
 154     }
 155 
 156 private:
 157     void dispose()
 158     {
 159         m_loader = nullptr;
 160         delete this;
 161     }
 162 
 163     RefPtr&lt;LoadResourceCallback&gt; m_callback;
 164     RefPtr&lt;ThreadableLoader&gt; m_loader;
 165     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
 166     String m_mimeType;
 167     StringBuilder m_responseText;
 168     int m_statusCode;
 169 };
 170 
 171 } // namespace
 172 
 173 InspectorNetworkAgent::InspectorNetworkAgent(WebAgentContext&amp; context)
 174     : InspectorAgentBase(&quot;Network&quot;_s, context)
 175     , m_frontendDispatcher(makeUnique&lt;Inspector::NetworkFrontendDispatcher&gt;(context.frontendRouter))
 176     , m_backendDispatcher(Inspector::NetworkBackendDispatcher::create(context.backendDispatcher, this))
 177     , m_injectedScriptManager(context.injectedScriptManager)
 178     , m_resourcesData(makeUnique&lt;NetworkResourcesData&gt;())
 179 {
 180 }
 181 
 182 InspectorNetworkAgent::~InspectorNetworkAgent() = default;
 183 
 184 void InspectorNetworkAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 185 {
 186 }
 187 
 188 void InspectorNetworkAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 189 {
 190     ErrorString ignored;
 191     disable(ignored);
 192 }
 193 
 194 static Ref&lt;JSON::Object&gt; buildObjectForHeaders(const HTTPHeaderMap&amp; headers)
 195 {
 196     Ref&lt;JSON::Object&gt; headersObject = JSON::Object::create();
 197 
 198     for (const auto&amp; header : headers)
 199         headersObject-&gt;setString(header.key, header.value);
 200     return headersObject;
 201 }
 202 
 203 Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; InspectorNetworkAgent::buildObjectForTiming(const NetworkLoadMetrics&amp; timing, ResourceLoader&amp; resourceLoader)
 204 {
 205     auto&amp; loadTiming = resourceLoader.loadTiming();
 206 
 207     auto elapsedTimeSince = [&amp;] (const MonotonicTime&amp; time) {
 208         return m_environment.executionStopwatch()-&gt;elapsedTimeSince(time).seconds();
 209     };
 210 
 211     return Inspector::Protocol::Network::ResourceTiming::create()
 212         .setStartTime(elapsedTimeSince(loadTiming.startTime()))
 213         .setRedirectStart(elapsedTimeSince(loadTiming.redirectStart()))
 214         .setRedirectEnd(elapsedTimeSince(loadTiming.redirectEnd()))
 215         .setFetchStart(elapsedTimeSince(loadTiming.fetchStart()))
 216         .setDomainLookupStart(timing.domainLookupStart.milliseconds())
 217         .setDomainLookupEnd(timing.domainLookupEnd.milliseconds())
 218         .setConnectStart(timing.connectStart.milliseconds())
 219         .setConnectEnd(timing.connectEnd.milliseconds())
 220         .setSecureConnectionStart(timing.secureConnectionStart.milliseconds())
 221         .setRequestStart(timing.requestStart.milliseconds())
 222         .setResponseStart(timing.responseStart.milliseconds())
 223         .setResponseEnd(timing.responseEnd.milliseconds())
 224         .release();
 225 }
 226 
 227 static Inspector::Protocol::Network::Metrics::Priority toProtocol(NetworkLoadPriority priority)
 228 {
 229     switch (priority) {
 230     case NetworkLoadPriority::Low:
 231         return Inspector::Protocol::Network::Metrics::Priority::Low;
 232     case NetworkLoadPriority::Medium:
 233         return Inspector::Protocol::Network::Metrics::Priority::Medium;
 234     case NetworkLoadPriority::High:
 235         return Inspector::Protocol::Network::Metrics::Priority::High;
 236     case NetworkLoadPriority::Unknown:
 237         break;
 238     }
 239 
 240     ASSERT_NOT_REACHED();
 241     return Inspector::Protocol::Network::Metrics::Priority::Medium;
 242 }
 243 
 244 Ref&lt;Inspector::Protocol::Network::Metrics&gt; InspectorNetworkAgent::buildObjectForMetrics(const NetworkLoadMetrics&amp; networkLoadMetrics)
 245 {
 246     auto metrics = Inspector::Protocol::Network::Metrics::create().release();
 247 
 248     if (!networkLoadMetrics.protocol.isNull())
 249         metrics-&gt;setProtocol(networkLoadMetrics.protocol);
 250     if (networkLoadMetrics.priority != NetworkLoadPriority::Unknown)
 251         metrics-&gt;setPriority(toProtocol(networkLoadMetrics.priority));
 252     if (!networkLoadMetrics.remoteAddress.isNull())
 253         metrics-&gt;setRemoteAddress(networkLoadMetrics.remoteAddress);
 254     if (!networkLoadMetrics.connectionIdentifier.isNull())
 255         metrics-&gt;setConnectionIdentifier(networkLoadMetrics.connectionIdentifier);
 256     if (!networkLoadMetrics.requestHeaders.isEmpty())
 257         metrics-&gt;setRequestHeaders(buildObjectForHeaders(networkLoadMetrics.requestHeaders));
 258 
 259     if (networkLoadMetrics.requestHeaderBytesSent != std::numeric_limits&lt;uint32_t&gt;::max())
 260         metrics-&gt;setRequestHeaderBytesSent(networkLoadMetrics.requestHeaderBytesSent);
 261     if (networkLoadMetrics.requestBodyBytesSent != std::numeric_limits&lt;uint64_t&gt;::max())
 262         metrics-&gt;setRequestBodyBytesSent(networkLoadMetrics.requestBodyBytesSent);
 263     if (networkLoadMetrics.responseHeaderBytesReceived != std::numeric_limits&lt;uint32_t&gt;::max())
 264         metrics-&gt;setResponseHeaderBytesReceived(networkLoadMetrics.responseHeaderBytesReceived);
 265     if (networkLoadMetrics.responseBodyBytesReceived != std::numeric_limits&lt;uint64_t&gt;::max())
 266         metrics-&gt;setResponseBodyBytesReceived(networkLoadMetrics.responseBodyBytesReceived);
 267     if (networkLoadMetrics.responseBodyDecodedSize != std::numeric_limits&lt;uint64_t&gt;::max())
 268         metrics-&gt;setResponseBodyDecodedSize(networkLoadMetrics.responseBodyDecodedSize);
 269 
 270     auto connectionPayload = Inspector::Protocol::Security::Connection::create()
 271         .release();
 272 
 273     if (!networkLoadMetrics.tlsProtocol.isEmpty())
 274         connectionPayload-&gt;setProtocol(networkLoadMetrics.tlsProtocol);
 275 
 276     if (!networkLoadMetrics.tlsCipher.isEmpty())
 277         connectionPayload-&gt;setCipher(networkLoadMetrics.tlsCipher);
 278 
 279     metrics-&gt;setSecurityConnection(WTFMove(connectionPayload));
 280 
 281     return metrics;
 282 }
 283 
 284 static Ref&lt;Inspector::Protocol::Network::Request&gt; buildObjectForResourceRequest(const ResourceRequest&amp; request)
 285 {
 286     auto requestObject = Inspector::Protocol::Network::Request::create()
 287         .setUrl(request.url().string())
 288         .setMethod(request.httpMethod())
 289         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 290         .release();
 291     if (request.httpBody() &amp;&amp; !request.httpBody()-&gt;isEmpty()) {
 292         auto bytes = request.httpBody()-&gt;flatten();
 293         requestObject-&gt;setPostData(String::fromUTF8WithLatin1Fallback(bytes.data(), bytes.size()));
 294     }
 295     return requestObject;
 296 }
 297 
 298 static Inspector::Protocol::Network::Response::Source responseSource(ResourceResponse::Source source)
 299 {
 300     switch (source) {
 301     case ResourceResponse::Source::ApplicationCache:
 302         // FIXME: Add support for ApplicationCache in inspector.
 303     case ResourceResponse::Source::Unknown:
 304         return Inspector::Protocol::Network::Response::Source::Unknown;
 305     case ResourceResponse::Source::Network:
 306         return Inspector::Protocol::Network::Response::Source::Network;
 307     case ResourceResponse::Source::MemoryCache:
 308     case ResourceResponse::Source::MemoryCacheAfterValidation:
 309         return Inspector::Protocol::Network::Response::Source::MemoryCache;
 310     case ResourceResponse::Source::DiskCache:
 311     case ResourceResponse::Source::DiskCacheAfterValidation:
 312         return Inspector::Protocol::Network::Response::Source::DiskCache;
 313     case ResourceResponse::Source::ServiceWorker:
 314         return Inspector::Protocol::Network::Response::Source::ServiceWorker;
 315     }
 316 
 317     ASSERT_NOT_REACHED();
 318     return Inspector::Protocol::Network::Response::Source::Unknown;
 319 }
 320 
 321 RefPtr&lt;Inspector::Protocol::Network::Response&gt; InspectorNetworkAgent::buildObjectForResourceResponse(const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 322 {
 323     if (response.isNull())
 324         return nullptr;
 325 
 326     Ref&lt;JSON::Object&gt; headers = buildObjectForHeaders(response.httpHeaderFields());
 327 
 328     auto responseObject = Inspector::Protocol::Network::Response::create()
 329         .setUrl(response.url().string())
 330         .setStatus(response.httpStatusCode())
 331         .setStatusText(response.httpStatusText())
 332         .setHeaders(WTFMove(headers))
 333         .setMimeType(response.mimeType())
 334         .setSource(responseSource(response.source()))
 335         .release();
 336 
 337     if (resourceLoader)
 338         responseObject-&gt;setTiming(buildObjectForTiming(response.deprecatedNetworkLoadMetrics(), *resourceLoader));
 339 
 340     if (auto&amp; certificateInfo = response.certificateInfo()) {
 341         auto securityPayload = Inspector::Protocol::Security::Security::create()
 342             .release();
 343 
 344         if (auto certificateSummaryInfo = certificateInfo.value().summaryInfo()) {
 345             auto certificatePayload = Inspector::Protocol::Security::Certificate::create()
 346                 .release();
 347 
 348             certificatePayload-&gt;setSubject(certificateSummaryInfo.value().subject);
 349 
 350             if (auto validFrom = certificateSummaryInfo.value().validFrom)
 351                 certificatePayload-&gt;setValidFrom(validFrom.seconds());
 352 
 353             if (auto validUntil = certificateSummaryInfo.value().validUntil)
 354                 certificatePayload-&gt;setValidUntil(validUntil.seconds());
 355 
 356             auto dnsNamesPayload = JSON::ArrayOf&lt;String&gt;::create();
 357             for (auto&amp; dnsName : certificateSummaryInfo.value().dnsNames)
 358                 dnsNamesPayload-&gt;addItem(dnsName);
 359             if (dnsNamesPayload-&gt;length())
 360                 certificatePayload-&gt;setDnsNames(WTFMove(dnsNamesPayload));
 361 
 362             auto ipAddressesPayload = JSON::ArrayOf&lt;String&gt;::create();
 363             for (auto&amp; ipAddress : certificateSummaryInfo.value().ipAddresses)
 364                 ipAddressesPayload-&gt;addItem(ipAddress);
 365             if (ipAddressesPayload-&gt;length())
 366                 certificatePayload-&gt;setIpAddresses(WTFMove(ipAddressesPayload));
 367 
 368             securityPayload-&gt;setCertificate(WTFMove(certificatePayload));
 369         }
 370 
 371         responseObject-&gt;setSecurity(WTFMove(securityPayload));
 372     }
 373 
 374     return responseObject;
 375 }
 376 
 377 Ref&lt;Inspector::Protocol::Network::CachedResource&gt; InspectorNetworkAgent::buildObjectForCachedResource(CachedResource* cachedResource)
 378 {
 379     auto resourceObject = Inspector::Protocol::Network::CachedResource::create()
 380         .setUrl(cachedResource-&gt;url())
 381         .setType(InspectorPageAgent::cachedResourceTypeJSON(*cachedResource))
 382         .setBodySize(cachedResource-&gt;encodedSize())
 383         .release();
 384 
 385     auto resourceResponse = buildObjectForResourceResponse(cachedResource-&gt;response(), cachedResource-&gt;loader());
 386     resourceObject-&gt;setResponse(WTFMove(resourceResponse));
 387 
 388     String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
 389     if (!sourceMappingURL.isEmpty())
 390         resourceObject-&gt;setSourceMapURL(sourceMappingURL);
 391 
 392     return resourceObject;
 393 }
 394 
 395 double InspectorNetworkAgent::timestamp()
 396 {
 397     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 398 }
 399 
 400 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType type)
 401 {
 402     if (request.hiddenFromInspector()) {
 403         m_hiddenRequestIdentifiers.add(identifier);
 404         return;
 405     }
 406 
 407     double sendTimestamp = timestamp();
 408     WallTime walltime = WallTime::now();
 409 
 410     String requestId = IdentifiersFactory::requestId(identifier);
 411     String frameId = frameIdentifier(loader);
 412     String loaderId = loaderIdentifier(loader);
 413     String targetId = request.initiatorIdentifier();
 414 
 415     if (type == InspectorPageAgent::OtherResource) {
 416         if (m_loadingXHRSynchronously)
 417             type = InspectorPageAgent::XHRResource;
 418         else if (loader &amp;&amp; equalIgnoringFragmentIdentifier(request.url(), loader-&gt;url()) &amp;&amp; !loader-&gt;isCommitted())
 419             type = InspectorPageAgent::DocumentResource;
 420         else if (loader) {
 421             for (auto&amp; linkIcon : loader-&gt;linkIcons()) {
 422                 if (equalIgnoringFragmentIdentifier(request.url(), linkIcon.url)) {
 423                     type = InspectorPageAgent::ImageResource;
 424                     break;
 425                 }
 426             }
 427         }
 428     }
 429 
 430     m_resourcesData-&gt;resourceCreated(requestId, loaderId, type);
 431 
 432     for (auto&amp; entry : m_extraRequestHeaders)
 433         request.setHTTPHeaderField(entry.key, entry.value);
 434 
 435     auto protocolResourceType = InspectorPageAgent::resourceTypeJSON(type);
 436 
 437     Document* document = loader &amp;&amp; loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr;
 438     auto initiatorObject = buildInitiatorObject(document, request);
 439 
 440     String url = loader ? loader-&gt;url().string() : request.url();
 441     m_frontendDispatcher-&gt;requestWillBeSent(requestId, frameId, loaderId, url, buildObjectForResourceRequest(request), sendTimestamp, walltime.secondsSinceEpoch().seconds(), initiatorObject, buildObjectForResourceResponse(redirectResponse, nullptr), type != InspectorPageAgent::OtherResource ? &amp;protocolResourceType : nullptr, targetId.isEmpty() ? nullptr : &amp;targetId);
 442 }
 443 
 444 static InspectorPageAgent::ResourceType resourceTypeForCachedResource(CachedResource* resource)
 445 {
 446     if (resource)
 447         return InspectorPageAgent::inspectorResourceType(*resource);
 448     return InspectorPageAgent::OtherResource;
 449 }
 450 
 451 static InspectorPageAgent::ResourceType resourceTypeForLoadType(InspectorInstrumentation::LoadType loadType)
 452 {
 453     switch (loadType) {
 454     case InspectorInstrumentation::LoadType::Ping:
 455         return InspectorPageAgent::PingResource;
 456     case InspectorInstrumentation::LoadType::Beacon:
 457         return InspectorPageAgent::BeaconResource;
 458     }
 459 
 460     ASSERT_NOT_REACHED();
 461     return InspectorPageAgent::OtherResource;
 462 }
 463 
 464 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
 465 {
 466     auto* cachedResource = loader ? InspectorPageAgent::cachedResource(loader-&gt;frame(), request.url()) : nullptr;
 467     willSendRequest(identifier, loader, request, redirectResponse, resourceTypeForCachedResource(cachedResource));
 468 }
 469 
 470 void InspectorNetworkAgent::willSendRequestOfType(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, InspectorInstrumentation::LoadType loadType)
 471 {
 472     willSendRequest(identifier, loader, request, ResourceResponse(), resourceTypeForLoadType(loadType));
 473 }
 474 
 475 void InspectorNetworkAgent::didReceiveResponse(unsigned long identifier, DocumentLoader* loader, const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 476 {
 477     if (m_hiddenRequestIdentifiers.contains(identifier))
 478         return;
 479 
 480     String requestId = IdentifiersFactory::requestId(identifier);
 481 
 482     Optional&lt;ResourceResponse&gt; realResponse;
 483     if (platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 484         callOnMainThreadAndWait([&amp;] {
 485             // We do not need to isolate response since it comes straight from IPC, but we might want to isolate it for extra safety.
 486             auto response = platformStrategies()-&gt;loaderStrategy()-&gt;responseFromResourceLoadIdentifier(identifier);
 487             if (!response.isNull())
 488                 realResponse = WTFMove(response);
 489         });
 490     }
 491 
 492     RefPtr&lt;Inspector::Protocol::Network::Response&gt; resourceResponse = buildObjectForResourceResponse(realResponse ? *realResponse : response, resourceLoader);
 493 
 494     bool isNotModified = response.httpStatusCode() == 304;
 495 
 496     CachedResource* cachedResource = nullptr;
 497     if (is&lt;SubresourceLoader&gt;(resourceLoader) &amp;&amp; !isNotModified)
 498         cachedResource = downcast&lt;SubresourceLoader&gt;(resourceLoader)-&gt;cachedResource();
 499     if (!cachedResource &amp;&amp; loader)
 500         cachedResource = InspectorPageAgent::cachedResource(loader-&gt;frame(), response.url());
 501 
 502     if (cachedResource) {
 503         // Use mime type from cached resource in case the one in response is empty.
 504         if (resourceResponse &amp;&amp; response.mimeType().isEmpty())
 505             resourceResponse-&gt;setString(Inspector::Protocol::Network::Response::MimeType, cachedResource-&gt;response().mimeType());
 506         m_resourcesData-&gt;addCachedResource(requestId, cachedResource);
 507     }
 508 
 509     InspectorPageAgent::ResourceType type = m_resourcesData-&gt;resourceType(requestId);
 510     InspectorPageAgent::ResourceType newType = cachedResource ? InspectorPageAgent::inspectorResourceType(*cachedResource) : type;
 511 
 512     // FIXME: XHRResource is returned for CachedResource::Type::RawResource, it should be OtherResource unless it truly is an XHR.
 513     // RawResource is used for loading worker scripts, and those should stay as ScriptResource and not change to XHRResource.
 514     if (type != newType &amp;&amp; newType != InspectorPageAgent::XHRResource &amp;&amp; newType != InspectorPageAgent::OtherResource)
 515         type = newType;
 516 
 517     String frameId = frameIdentifier(loader);
 518     String loaderId = loaderIdentifier(loader);
 519 
 520     m_resourcesData-&gt;responseReceived(requestId, frameId, response, type, shouldForceBufferingNetworkResourceData());
 521 
 522     m_frontendDispatcher-&gt;responseReceived(requestId, frameId, loaderId, timestamp(), InspectorPageAgent::resourceTypeJSON(type), resourceResponse);
 523 
 524     // If we revalidated the resource and got Not modified, send content length following didReceiveResponse
 525     // as there will be no calls to didReceiveData from the network stack.
 526     if (isNotModified &amp;&amp; cachedResource &amp;&amp; cachedResource-&gt;encodedSize())
 527         didReceiveData(identifier, nullptr, cachedResource-&gt;encodedSize(), 0);
 528 }
 529 
 530 void InspectorNetworkAgent::didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength)
 531 {
 532     if (m_hiddenRequestIdentifiers.contains(identifier))
 533         return;
 534 
 535     String requestId = IdentifiersFactory::requestId(identifier);
 536 
 537     if (data) {
 538         NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;maybeAddResourceData(requestId, data, dataLength);
 539 
 540         // For a synchronous XHR, if we didn&#39;t add data then we can apply it here as base64 encoded content.
 541         // Often the data is text and we would have a decoder, but for non-text we won&#39;t have a decoder.
 542         // Sync XHRs may not have a cached resource, while non-sync XHRs usually transfer data over on completion.
 543         if (m_loadingXHRSynchronously &amp;&amp; resourceData &amp;&amp; !resourceData-&gt;hasBufferedData() &amp;&amp; !resourceData-&gt;cachedResource())
 544             m_resourcesData-&gt;setResourceContent(requestId, base64Encode(data, dataLength), true);
 545     }
 546 
 547     m_frontendDispatcher-&gt;dataReceived(requestId, timestamp(), dataLength, encodedDataLength);
 548 }
 549 
 550 void InspectorNetworkAgent::didFinishLoading(unsigned long identifier, DocumentLoader* loader, const NetworkLoadMetrics&amp; networkLoadMetrics, ResourceLoader* resourceLoader)
 551 {
 552     if (m_hiddenRequestIdentifiers.remove(identifier))
 553         return;
 554 
 555     double elapsedFinishTime;
 556     if (resourceLoader &amp;&amp; networkLoadMetrics.isComplete()) {
 557         MonotonicTime fetchStart = resourceLoader-&gt;loadTiming().fetchStart();
 558         Seconds fetchStartInInspector = m_environment.executionStopwatch()-&gt;elapsedTimeSince(fetchStart);
 559         elapsedFinishTime = (fetchStartInInspector + networkLoadMetrics.responseEnd).seconds();
 560     } else
 561         elapsedFinishTime = timestamp();
 562 
 563     String requestId = IdentifiersFactory::requestId(identifier);
 564     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource)
 565         m_resourcesData-&gt;addResourceSharedBuffer(requestId, loader-&gt;frameLoader()-&gt;documentLoader()-&gt;mainResourceData(), loader-&gt;frame()-&gt;document()-&gt;encoding());
 566 
 567     m_resourcesData-&gt;maybeDecodeDataToContent(requestId);
 568 
 569     String sourceMappingURL;
 570     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 571     if (resourceData &amp;&amp; resourceData-&gt;cachedResource())
 572         sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(resourceData-&gt;cachedResource());
 573 
 574     Optional&lt;NetworkLoadMetrics&gt; realMetrics;
 575     if (platformStrategies()-&gt;loaderStrategy()-&gt;shouldPerformSecurityChecks() &amp;&amp; !networkLoadMetrics.isComplete()) {
 576         callOnMainThreadAndWait([&amp;] {
 577             realMetrics = platformStrategies()-&gt;loaderStrategy()-&gt;networkMetricsFromResourceLoadIdentifier(identifier).isolatedCopy();
 578         });
 579     }
 580     RefPtr&lt;Inspector::Protocol::Network::Metrics&gt; metrics = buildObjectForMetrics(realMetrics ? *realMetrics : networkLoadMetrics);
 581 
 582     m_frontendDispatcher-&gt;loadingFinished(requestId, elapsedFinishTime, !sourceMappingURL.isEmpty() ? &amp;sourceMappingURL : nullptr, metrics);
 583 }
 584 
 585 void InspectorNetworkAgent::didFailLoading(unsigned long identifier, DocumentLoader* loader, const ResourceError&amp; error)
 586 {
 587     if (m_hiddenRequestIdentifiers.remove(identifier))
 588         return;
 589 
 590     String requestId = IdentifiersFactory::requestId(identifier);
 591 
 592     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource) {
 593         Frame* frame = loader-&gt;frame();
 594         if (frame &amp;&amp; frame-&gt;loader().documentLoader() &amp;&amp; frame-&gt;document()) {
 595             m_resourcesData-&gt;addResourceSharedBuffer(requestId,
 596                 frame-&gt;loader().documentLoader()-&gt;mainResourceData(),
 597                 frame-&gt;document()-&gt;encoding());
 598         }
 599     }
 600 
 601     bool canceled = error.isCancellation();
 602     m_frontendDispatcher-&gt;loadingFailed(requestId, timestamp(), error.localizedDescription(), canceled ? &amp;canceled : nullptr);
 603 }
 604 
 605 void InspectorNetworkAgent::didLoadResourceFromMemoryCache(DocumentLoader* loader, CachedResource&amp; resource)
 606 {
 607     ASSERT(loader);
 608     if (!loader)
 609         return;
 610 
 611     unsigned long identifier = loader-&gt;frame()-&gt;page()-&gt;progress().createUniqueIdentifier();
 612     String requestId = IdentifiersFactory::requestId(identifier);
 613     String loaderId = loaderIdentifier(loader);
 614     String frameId = frameIdentifier(loader);
 615 
 616     m_resourcesData-&gt;resourceCreated(requestId, loaderId, resource);
 617 
 618     auto initiatorObject = buildInitiatorObject(loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr, resource.resourceRequest());
 619 
 620     // FIXME: It would be ideal to generate the Network.Response with the MemoryCache source
 621     // instead of whatever ResourceResponse::Source the CachedResources&#39;s response has.
 622     // The frontend already knows for certain that this was served from the memory cache.
 623 
 624     m_frontendDispatcher-&gt;requestServedFromMemoryCache(requestId, frameId, loaderId, loader-&gt;url().string(), timestamp(), initiatorObject, buildObjectForCachedResource(&amp;resource));
 625 }
 626 
 627 void InspectorNetworkAgent::setInitialScriptContent(unsigned long identifier, const String&amp; sourceString)
 628 {
 629     m_resourcesData-&gt;setResourceContent(IdentifiersFactory::requestId(identifier), sourceString);
 630 }
 631 
 632 void InspectorNetworkAgent::didReceiveScriptResponse(unsigned long identifier)
 633 {
 634     m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::ScriptResource);
 635 }
 636 
 637 void InspectorNetworkAgent::didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp; documentThreadableLoader)
 638 {
 639     String initiator = documentThreadableLoader.options().initiator;
 640     if (initiator == cachedResourceRequestInitiators().fetch)
 641         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::FetchResource);
 642     else if (initiator == cachedResourceRequestInitiators().xmlhttprequest)
 643         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::XHRResource);
 644 }
 645 
 646 void InspectorNetworkAgent::willLoadXHRSynchronously()
 647 {
 648     m_loadingXHRSynchronously = true;
 649 }
 650 
 651 void InspectorNetworkAgent::didLoadXHRSynchronously()
 652 {
 653     m_loadingXHRSynchronously = false;
 654 }
 655 
 656 void InspectorNetworkAgent::willDestroyCachedResource(CachedResource&amp; cachedResource)
 657 {
 658     Vector&lt;String&gt; requestIds = m_resourcesData-&gt;removeCachedResource(&amp;cachedResource);
 659     if (!requestIds.size())
 660         return;
 661 
 662     String content;
 663     bool base64Encoded;
 664     if (!InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;content, &amp;base64Encoded))
 665         return;
 666 
 667     for (auto&amp; id : requestIds)
 668         m_resourcesData-&gt;setResourceContent(id, content, base64Encoded);
 669 }
 670 
 671 void InspectorNetworkAgent::willRecalculateStyle()
 672 {
 673     m_isRecalculatingStyle = true;
 674 }
 675 
 676 void InspectorNetworkAgent::didRecalculateStyle()
 677 {
 678     m_isRecalculatingStyle = false;
 679     m_styleRecalculationInitiator = nullptr;
 680 }
 681 
 682 void InspectorNetworkAgent::didScheduleStyleRecalculation(Document&amp; document)
 683 {
 684     if (!m_styleRecalculationInitiator)
 685         m_styleRecalculationInitiator = buildInitiatorObject(&amp;document);
 686 }
 687 
 688 RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; InspectorNetworkAgent::buildInitiatorObject(Document* document, Optional&lt;const ResourceRequest&amp;&gt; resourceRequest)
 689 {
 690     // FIXME: Worker support.
 691     if (!isMainThread()) {
 692         return Inspector::Protocol::Network::Initiator::create()
 693             .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 694             .release();
 695     }
 696 
 697     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; initiatorObject;
 698 
 699     Ref&lt;ScriptCallStack&gt; stackTrace = createScriptCallStack(JSExecState::currentState());
 700     if (stackTrace-&gt;size() &gt; 0) {
 701         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 702             .setType(Inspector::Protocol::Network::Initiator::Type::Script)
 703             .release();
 704         initiatorObject-&gt;setStackTrace(stackTrace-&gt;buildInspectorArray());
 705     } else if (document &amp;&amp; document-&gt;scriptableDocumentParser()) {
 706         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 707             .setType(Inspector::Protocol::Network::Initiator::Type::Parser)
 708             .release();
 709         initiatorObject-&gt;setUrl(document-&gt;url().string());
 710         initiatorObject-&gt;setLineNumber(document-&gt;scriptableDocumentParser()-&gt;textPosition().m_line.oneBasedInt());
 711     }
 712 
 713     auto domAgent = m_instrumentingAgents.inspectorDOMAgent();
 714     if (domAgent &amp;&amp; resourceRequest) {
 715         if (auto inspectorInitiatorNodeIdentifier = resourceRequest-&gt;inspectorInitiatorNodeIdentifier()) {
 716             if (!initiatorObject) {
 717                 initiatorObject = Inspector::Protocol::Network::Initiator::create()
 718                     .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 719                     .release();
 720             }
 721 
 722             initiatorObject-&gt;setNodeId(*inspectorInitiatorNodeIdentifier);
 723         }
 724     }
 725 
 726     if (initiatorObject)
 727         return initiatorObject;
 728 
 729     if (m_isRecalculatingStyle &amp;&amp; m_styleRecalculationInitiator)
 730         return m_styleRecalculationInitiator;
 731 
 732     return Inspector::Protocol::Network::Initiator::create()
 733         .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 734         .release();
 735 }
 736 
 737 void InspectorNetworkAgent::didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL)
 738 {
 739     m_frontendDispatcher-&gt;webSocketCreated(IdentifiersFactory::requestId(identifier), requestURL.string());
 740 }
 741 
 742 void InspectorNetworkAgent::willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp; request)
 743 {
 744     auto requestObject = Inspector::Protocol::Network::WebSocketRequest::create()
 745         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 746         .release();
 747     m_frontendDispatcher-&gt;webSocketWillSendHandshakeRequest(IdentifiersFactory::requestId(identifier), timestamp(), WallTime::now().secondsSinceEpoch().seconds(), WTFMove(requestObject));
 748 }
 749 
 750 void InspectorNetworkAgent::didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp; response)
 751 {
 752     auto responseObject = Inspector::Protocol::Network::WebSocketResponse::create()
 753         .setStatus(response.httpStatusCode())
 754         .setStatusText(response.httpStatusText())
 755         .setHeaders(buildObjectForHeaders(response.httpHeaderFields()))
 756         .release();
 757     m_frontendDispatcher-&gt;webSocketHandshakeResponseReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(responseObject));
 758 }
 759 
 760 void InspectorNetworkAgent::didCloseWebSocket(unsigned long identifier)
 761 {
 762     m_frontendDispatcher-&gt;webSocketClosed(IdentifiersFactory::requestId(identifier), timestamp());
 763 }
 764 
 765 void InspectorNetworkAgent::didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 766 {
 767     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 768         .setOpcode(frame.opCode)
 769         .setMask(frame.masked)
 770         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 771         .setPayloadLength(frame.payloadLength)
 772         .release();
 773     m_frontendDispatcher-&gt;webSocketFrameReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 774 }
 775 
 776 void InspectorNetworkAgent::didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 777 {
 778     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 779         .setOpcode(frame.opCode)
 780         .setMask(frame.masked)
 781         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 782         .setPayloadLength(frame.payloadLength)
 783         .release();
 784     m_frontendDispatcher-&gt;webSocketFrameSent(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 785 }
 786 
 787 void InspectorNetworkAgent::didReceiveWebSocketFrameError(unsigned long identifier, const String&amp; errorMessage)
 788 {
 789     m_frontendDispatcher-&gt;webSocketFrameError(IdentifiersFactory::requestId(identifier), timestamp(), errorMessage);
 790 }
 791 
 792 void InspectorNetworkAgent::enable(ErrorString&amp;)
 793 {
 794     enable();
 795 }
 796 
 797 void InspectorNetworkAgent::enable()
 798 {
 799     m_enabled = true;
 800     m_instrumentingAgents.setInspectorNetworkAgent(this);
 801 
 802     {
 803         LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 804 
 805         for (WebSocket* webSocket : activeWebSockets(lock)) {
 806             ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 807             WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 808 
 809             unsigned identifier = channel-&gt;identifier();
 810             didCreateWebSocket(identifier, webSocket-&gt;url());
 811             auto cookieRequestHeaderFieldValue = [document = makeWeakPtr(channel-&gt;document())] (const URL&amp; url) -&gt; String {
 812                 if (!document || !document-&gt;page())
 813                     return { };
 814                 return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);
 815             };
 816             willSendWebSocketHandshakeRequest(identifier, channel-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));
 817 
 818             if (channel-&gt;handshakeMode() == WebSocketHandshake::Connected)
 819                 didReceiveWebSocketHandshakeResponse(identifier, channel-&gt;serverHandshakeResponse());
 820 
 821             if (webSocket-&gt;readyState() == WebSocket::CLOSED)
 822                 didCloseWebSocket(identifier);
 823         }
 824     }
 825 }
 826 
 827 void InspectorNetworkAgent::disable(ErrorString&amp;)
 828 {
 829     m_enabled = false;
 830     m_instrumentingAgents.setInspectorNetworkAgent(nullptr);
 831     m_resourcesData-&gt;clear();
 832     m_extraRequestHeaders.clear();
 833 
 834     setResourceCachingDisabled(false);
 835 }
 836 
 837 void InspectorNetworkAgent::setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers)
 838 {
 839     for (auto&amp; entry : headers) {
 840         String stringValue;
 841         if (entry.value-&gt;asString(stringValue))
 842             m_extraRequestHeaders.set(entry.key, stringValue);
 843     }
 844 }
 845 
 846 void InspectorNetworkAgent::getResponseBody(ErrorString&amp; errorString, const String&amp; requestId, String* content, bool* base64Encoded)
 847 {
 848     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 849     if (!resourceData) {
 850         errorString = &quot;Missing resource for given requestId&quot;_s;
 851         return;
 852     }
 853 
 854     if (resourceData-&gt;hasContent()) {
 855         *base64Encoded = resourceData-&gt;base64Encoded();
 856         *content = resourceData-&gt;content();
 857         return;
 858     }
 859 
 860     if (resourceData-&gt;isContentEvicted()) {
 861         errorString = &quot;Resource content was evicted from inspector cache&quot;_s;
 862         return;
 863     }
 864 
 865     if (resourceData-&gt;buffer() &amp;&amp; !resourceData-&gt;textEncodingName().isNull()) {
 866         *base64Encoded = false;
 867         if (InspectorPageAgent::sharedBufferContent(resourceData-&gt;buffer(), resourceData-&gt;textEncodingName(), *base64Encoded, content))
 868             return;
 869     }
 870 
 871     if (resourceData-&gt;cachedResource()) {
 872         if (InspectorNetworkAgent::cachedResourceContent(*resourceData-&gt;cachedResource(), content, base64Encoded))
 873             return;
 874     }
 875 
 876     errorString = &quot;Missing content of resource for given requestId&quot;_s;
 877 }
 878 
 879 void InspectorNetworkAgent::setResourceCachingDisabled(ErrorString&amp;, bool disabled)
 880 {
 881     setResourceCachingDisabled(disabled);
 882 }
 883 
 884 void InspectorNetworkAgent::loadResource(const String&amp; frameId, const String&amp; urlString, Ref&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 885 {
 886     ErrorString errorString;
 887     auto* context = scriptExecutionContext(errorString, frameId);
 888     if (!context) {
 889         callback-&gt;sendFailure(errorString);
 890         return;
 891     }
 892 
 893     URL url = context-&gt;completeURL(urlString);
 894     ResourceRequest request(url);
 895     request.setHTTPMethod(&quot;GET&quot;_s);
 896     request.setHiddenFromInspector(true);
 897 
 898     ThreadableLoaderOptions options;
 899     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks; // So we remove this from m_hiddenRequestIdentifiers on completion.
 900     options.defersLoadingPolicy = DefersLoadingPolicy::DisallowDefersLoading; // So the request is never deferred.
 901     options.mode = FetchOptions::Mode::NoCors;
 902     options.credentials = FetchOptions::Credentials::SameOrigin;
 903     options.contentSecurityPolicyEnforcement = ContentSecurityPolicyEnforcement::DoNotEnforce;
 904 
 905     // InspectorThreadableLoaderClient deletes itself when the load completes or fails.
 906     InspectorThreadableLoaderClient* inspectorThreadableLoaderClient = new InspectorThreadableLoaderClient(callback.copyRef());
 907     auto loader = ThreadableLoader::create(*context, *inspectorThreadableLoaderClient, WTFMove(request), options);
 908     if (!loader) {
 909         callback-&gt;sendFailure(&quot;Could not load requested resource.&quot;_s);
 910         return;
 911     }
 912 
 913     // If the load already completed, inspectorThreadableLoaderClient will have been deleted and we will have already called the callback.
 914     if (!callback-&gt;isActive())
 915         return;
 916 
 917     inspectorThreadableLoaderClient-&gt;setLoader(WTFMove(loader));
 918 }
 919 
 920 void InspectorNetworkAgent::getSerializedCertificate(ErrorString&amp; errorString, const String&amp; requestId, String* serializedCertificate)
 921 {
 922     auto* resourceData = m_resourcesData-&gt;data(requestId);
 923     if (!resourceData) {
 924         errorString = &quot;Missing resource for given requestId&quot;_s;
 925         return;
 926     }
 927 
 928     auto&amp; certificate = resourceData-&gt;certificateInfo();
 929     if (!certificate || certificate.value().isEmpty()) {
 930         errorString = &quot;Missing certificate of resource for given requestId&quot;_s;
 931         return;
 932     }
 933 
 934     WTF::Persistence::Encoder encoder;
 935     encoder &lt;&lt; certificate.value();
 936     *serializedCertificate = base64Encode(encoder.buffer(), encoder.bufferSize());
 937 }
 938 
 939 WebSocket* InspectorNetworkAgent::webSocketForRequestId(const String&amp; requestId)
 940 {
 941     LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 942 
 943     for (WebSocket* webSocket : activeWebSockets(lock)) {
 944         ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 945         WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 946         if (IdentifiersFactory::requestId(channel-&gt;identifier()) == requestId)
 947             return webSocket;
 948     }
 949 
 950     return nullptr;
 951 }
 952 
 953 static JSC::JSValue webSocketAsScriptValue(JSC::ExecState&amp; state, WebSocket* webSocket)
 954 {
 955     JSC::JSLockHolder lock(&amp;state);
 956     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), webSocket);
 957 }
 958 
 959 void InspectorNetworkAgent::resolveWebSocket(ErrorString&amp; errorString, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
 960 {
 961     WebSocket* webSocket = webSocketForRequestId(requestId);
 962     if (!webSocket) {
 963         errorString = &quot;Missing web socket for given requestId&quot;_s;
 964         return;
 965     }
 966 
 967     // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s and worker&#39;s WebSockets
 968     if (!is&lt;Document&gt;(webSocket-&gt;scriptExecutionContext()))
 969         return;
 970 
 971     auto* document = downcast&lt;Document&gt;(webSocket-&gt;scriptExecutionContext());
 972     auto* frame = document-&gt;frame();
 973     if (!frame) {
 974         errorString = &quot;Missing frame of web socket for given requestId&quot;_s;
 975         return;
 976     }
 977 
 978     auto&amp; state = *mainWorldExecState(frame);
 979     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
 980     ASSERT(!injectedScript.hasNoValue());
 981 
 982     String objectGroupName = objectGroup ? *objectGroup : String();
 983     result = injectedScript.wrapObject(webSocketAsScriptValue(state, webSocket), objectGroupName);
 984 }
 985 
 986 bool InspectorNetworkAgent::shouldTreatAsText(const String&amp; mimeType)
 987 {
 988     return startsWithLettersIgnoringASCIICase(mimeType, &quot;text/&quot;)
 989         || MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType)
 990         || MIMETypeRegistry::isSupportedJSONMIMEType(mimeType)
 991         || MIMETypeRegistry::isXMLMIMEType(mimeType)
 992         || MIMETypeRegistry::isTextMediaPlaylistMIMEType(mimeType);
 993 }
 994 
 995 Ref&lt;TextResourceDecoder&gt; InspectorNetworkAgent::createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName)
 996 {
 997     if (!textEncodingName.isEmpty())
 998         return TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncodingName);
 999 
1000     if (MIMETypeRegistry::isTextMIMEType(mimeType))
1001         return TextResourceDecoder::create(mimeType, &quot;UTF-8&quot;);
1002     if (MIMETypeRegistry::isXMLMIMEType(mimeType)) {
1003         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;_s);
1004         decoder-&gt;useLenientXMLDecoding();
1005         return decoder;
1006     }
1007 
1008     return TextResourceDecoder::create(&quot;text/plain&quot;_s, &quot;UTF-8&quot;);
1009 }
1010 
1011 Optional&lt;String&gt; InspectorNetworkAgent::textContentForCachedResource(CachedResource&amp; cachedResource)
1012 {
1013     if (!InspectorNetworkAgent::shouldTreatAsText(cachedResource.mimeType()))
1014         return WTF::nullopt;
1015 
1016     String result;
1017     bool base64Encoded;
1018     if (InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;result, &amp;base64Encoded)) {
1019         ASSERT(!base64Encoded);
1020         return result;
1021     }
1022 
1023     return WTF::nullopt;
1024 }
1025 
1026 bool InspectorNetworkAgent::cachedResourceContent(CachedResource&amp; resource, String* result, bool* base64Encoded)
1027 {
1028     ASSERT(result);
1029     ASSERT(base64Encoded);
1030 
1031     if (!resource.encodedSize()) {
1032         *base64Encoded = false;
1033         *result = String();
1034         return true;
1035     }
1036 
1037     switch (resource.type()) {
1038     case CachedResource::Type::CSSStyleSheet:
1039         *base64Encoded = false;
1040         *result = downcast&lt;CachedCSSStyleSheet&gt;(resource).sheetText();
1041         // The above can return a null String if the MIME type is invalid.
1042         return !result-&gt;isNull();
1043     case CachedResource::Type::Script:
1044         *base64Encoded = false;
1045         *result = downcast&lt;CachedScript&gt;(resource).script().toString();
1046         return true;
1047     default:
1048         auto* buffer = resource.resourceBuffer();
1049         if (!buffer)
1050             return false;
1051 
1052         if (InspectorNetworkAgent::shouldTreatAsText(resource.mimeType())) {
1053             auto decoder = InspectorNetworkAgent::createTextDecoder(resource.mimeType(), resource.response().textEncodingName());
1054             *base64Encoded = false;
1055             *result = decoder-&gt;decodeAndFlush(buffer-&gt;data(), buffer-&gt;size());
1056             return true;
1057         }
1058 
1059         *base64Encoded = true;
1060         *result = base64Encode(buffer-&gt;data(), buffer-&gt;size());
1061         return true;
1062     }
1063 }
1064 
1065 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; requestId, const String&amp; frameId, const String&amp; url, int matchesCount)
1066 {
1067     auto searchResult = Inspector::Protocol::Page::SearchResult::create()
1068         .setUrl(url)
1069         .setFrameId(frameId)
1070         .setMatchesCount(matchesCount)
1071         .release();
1072     searchResult-&gt;setRequestId(requestId);
1073     return searchResult;
1074 }
1075 
1076 static Optional&lt;String&gt; textContentForResourceData(const NetworkResourcesData::ResourceData&amp; resourceData)
1077 {
1078     if (resourceData.hasContent() &amp;&amp; !resourceData.base64Encoded())
1079         return resourceData.content();
1080 
1081     if (resourceData.cachedResource())
1082         return InspectorNetworkAgent::textContentForCachedResource(*resourceData.cachedResource());
1083 
1084     return WTF::nullopt;
1085 }
1086 
1087 void InspectorNetworkAgent::searchOtherRequests(const JSC::Yarr::RegularExpression&amp; regex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
1088 {
1089     Vector&lt;NetworkResourcesData::ResourceData*&gt; resources = m_resourcesData-&gt;resources();
1090     for (auto* resourceData : resources) {
1091         if (auto textContent = textContentForResourceData(*resourceData)) {
1092             int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, resourceData-&gt;content());
1093             if (matchesCount)
1094                 result-&gt;addItem(buildObjectForSearchResult(resourceData-&gt;requestId(), resourceData-&gt;frameId(), resourceData-&gt;url(), matchesCount));
1095         }
1096     }
1097 }
1098 
1099 void InspectorNetworkAgent::searchInRequest(ErrorString&amp; errorString, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
1100 {
1101     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
1102     if (!resourceData) {
1103         errorString = &quot;Missing resource for given requestId&quot;_s;
1104         return;
1105     }
1106 
1107     if (!resourceData-&gt;hasContent()) {
1108         errorString = &quot;Missing content of resource for given requestId&quot;_s;
1109         return;
1110     }
1111 
1112     results = ContentSearchUtilities::searchInTextByLines(resourceData-&gt;content(), query, caseSensitive, isRegex);
1113 }
1114 
1115 void InspectorNetworkAgent::mainFrameNavigated(DocumentLoader&amp; loader)
1116 {
1117     m_resourcesData-&gt;clear(loaderIdentifier(&amp;loader));
1118 }
1119 
1120 } // namespace WebCore
    </pre>
  </body>
</html>