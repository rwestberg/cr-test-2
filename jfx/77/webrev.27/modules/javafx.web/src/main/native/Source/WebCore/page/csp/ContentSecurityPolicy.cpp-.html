<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/csp/ContentSecurityPolicy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google, Inc. All rights reserved.
  3  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;ContentSecurityPolicy.h&quot;
 29 
 30 #include &quot;ContentSecurityPolicyClient.h&quot;
 31 #include &quot;ContentSecurityPolicyDirective.h&quot;
 32 #include &quot;ContentSecurityPolicyDirectiveList.h&quot;
 33 #include &quot;ContentSecurityPolicyDirectiveNames.h&quot;
 34 #include &quot;ContentSecurityPolicyHash.h&quot;
 35 #include &quot;ContentSecurityPolicySource.h&quot;
 36 #include &quot;ContentSecurityPolicySourceList.h&quot;
 37 #include &quot;DOMStringList.h&quot;
 38 #include &quot;Document.h&quot;
 39 #include &quot;DocumentLoader.h&quot;
 40 #include &quot;EventNames.h&quot;
 41 #include &quot;FormData.h&quot;
 42 #include &quot;Frame.h&quot;
 43 #include &quot;HTMLParserIdioms.h&quot;
 44 #include &quot;InspectorInstrumentation.h&quot;
 45 #include &quot;JSExecState.h&quot;
 46 #include &quot;JSWindowProxy.h&quot;
 47 #include &quot;ParsingUtilities.h&quot;
 48 #include &quot;PingLoader.h&quot;
 49 #include &quot;ResourceRequest.h&quot;
 50 #include &quot;RuntimeEnabledFeatures.h&quot;
 51 #include &quot;SchemeRegistry.h&quot;
 52 #include &quot;SecurityOrigin.h&quot;
 53 #include &quot;SecurityPolicyViolationEvent.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;TextEncoding.h&quot;
 56 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 58 #include &lt;pal/crypto/CryptoDigest.h&gt;
 59 #include &lt;wtf/JSONValues.h&gt;
 60 #include &lt;wtf/SetForScope.h&gt;
 61 #include &lt;wtf/text/StringBuilder.h&gt;
 62 #include &lt;wtf/text/TextPosition.h&gt;
 63 
 64 
 65 namespace WebCore {
 66 using namespace Inspector;
 67 
 68 static String consoleMessageForViolation(const char* effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const char* prefix, const char* subject = &quot;it&quot;)
 69 {
 70     StringBuilder result;
 71     if (violatedDirective.directiveList().isReportOnly())
 72         result.appendLiteral(&quot;[Report Only] &quot;);
 73     result.append(prefix);
 74     if (!blockedURL.isEmpty()) {
 75         result.append(&#39; &#39;);
 76         result.append(blockedURL.stringCenterEllipsizedToLength());
 77     }
 78     result.appendLiteral(&quot; because &quot;);
 79     result.append(subject);
 80     if (violatedDirective.isDefaultSrc()) {
 81         result.appendLiteral(&quot; appears in neither the &quot;);
 82         result.append(effectiveViolatedDirective);
 83         result.appendLiteral(&quot; directive nor the default-src directive of the Content Security Policy.&quot;);
 84     } else {
 85         result.appendLiteral(&quot; does not appear in the &quot;);
 86         result.append(effectiveViolatedDirective);
 87         result.appendLiteral(&quot; directive of the Content Security Policy.&quot;);
 88     }
 89     return result.toString();
 90 }
 91 
 92 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ContentSecurityPolicyClient* client)
 93     : m_client { client }
 94     , m_protectedURL { WTFMove(protectedURL) }
 95 {
 96     updateSourceSelf(SecurityOrigin::create(m_protectedURL).get());
 97 }
 98 
 99 ContentSecurityPolicy::ContentSecurityPolicy(URL&amp;&amp; protectedURL, ScriptExecutionContext&amp; scriptExecutionContext)
100     : m_scriptExecutionContext(&amp;scriptExecutionContext)
101     , m_protectedURL { WTFMove(protectedURL) }
102 {
103     ASSERT(scriptExecutionContext.securityOrigin());
104     updateSourceSelf(*scriptExecutionContext.securityOrigin());
105 }
106 
107 ContentSecurityPolicy::~ContentSecurityPolicy() = default;
108 
109 void ContentSecurityPolicy::copyStateFrom(const ContentSecurityPolicy* other)
110 {
111     if (m_hasAPIPolicy)
112         return;
113     ASSERT(m_policies.isEmpty());
114     for (auto&amp; policy : other-&gt;m_policies)
115         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::Inherited, String { });
116     m_referrer = other-&gt;m_referrer;
117     m_httpStatusCode = other-&gt;m_httpStatusCode;
118 }
119 
120 void ContentSecurityPolicy::createPolicyForPluginDocumentFrom(const ContentSecurityPolicy&amp; other)
121 {
122     if (m_hasAPIPolicy)
123         return;
124     ASSERT(m_policies.isEmpty());
125     for (auto&amp; policy : other.m_policies)
126         didReceiveHeader(policy-&gt;header(), policy-&gt;headerType(), ContentSecurityPolicy::PolicyFrom::InheritedForPluginDocument, String { });
127     m_referrer = other.m_referrer;
128     m_httpStatusCode = other.m_httpStatusCode;
129 }
130 
131 void ContentSecurityPolicy::copyUpgradeInsecureRequestStateFrom(const ContentSecurityPolicy&amp; other)
132 {
133     m_upgradeInsecureRequests = other.m_upgradeInsecureRequests;
134     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
135 }
136 
137 bool ContentSecurityPolicy::allowRunningOrDisplayingInsecureContent(const URL&amp; url)
138 {
139     bool allow = true;
140     bool isReportOnly = false;
141     for (auto&amp; policy : m_policies) {
142         if (!policy-&gt;hasBlockAllMixedContentDirective())
143             continue;
144 
145         isReportOnly = policy-&gt;isReportOnly();
146 
147         StringBuilder consoleMessage;
148         if (isReportOnly)
149             consoleMessage.appendLiteral(&quot;[Report Only] &quot;);
150         consoleMessage.append(&quot;Blocked mixed content &quot;);
151         consoleMessage.append(url.stringCenterEllipsizedToLength());
152         consoleMessage.appendLiteral(&quot; because &quot;);
153         consoleMessage.append(&quot;&#39;block-all-mixed-content&#39; appears in the Content Security Policy.&quot;);
154         reportViolation(ContentSecurityPolicyDirectiveNames::blockAllMixedContent, ContentSecurityPolicyDirectiveNames::blockAllMixedContent, *policy, url, consoleMessage.toString());
155 
156         if (!isReportOnly)
157             allow = false;
158     }
159     return allow;
160 }
161 
162 void ContentSecurityPolicy::didCreateWindowProxy(JSWindowProxy&amp; windowProxy) const
163 {
164     auto* window = windowProxy.window();
165     ASSERT(window);
166     ASSERT(window-&gt;scriptExecutionContext());
167     ASSERT(window-&gt;scriptExecutionContext()-&gt;contentSecurityPolicy() == this);
168     if (!windowProxy.world().isNormal()) {
169         window-&gt;setEvalEnabled(true);
170         return;
171     }
172     window-&gt;setEvalEnabled(m_lastPolicyEvalDisabledErrorMessage.isNull(), m_lastPolicyEvalDisabledErrorMessage);
173     window-&gt;setWebAssemblyEnabled(m_lastPolicyWebAssemblyDisabledErrorMessage.isNull(), m_lastPolicyWebAssemblyDisabledErrorMessage);
174 }
175 
176 ContentSecurityPolicyResponseHeaders ContentSecurityPolicy::responseHeaders() const
177 {
178     if (!m_cachedResponseHeaders) {
179         ContentSecurityPolicyResponseHeaders result;
180         result.m_headers.reserveInitialCapacity(m_policies.size());
181         for (auto&amp; policy : m_policies)
182             result.m_headers.uncheckedAppend({ policy-&gt;header(), policy-&gt;headerType() });
183         result.m_httpStatusCode = m_httpStatusCode;
184         m_cachedResponseHeaders = WTFMove(result);
185     }
186     return *m_cachedResponseHeaders;
187 }
188 
189 void ContentSecurityPolicy::didReceiveHeaders(const ContentSecurityPolicyResponseHeaders&amp; headers, String&amp;&amp; referrer, ReportParsingErrors reportParsingErrors)
190 {
191     SetForScope&lt;bool&gt; isReportingEnabled(m_isReportingEnabled, reportParsingErrors == ReportParsingErrors::Yes);
192     for (auto&amp; header : headers.m_headers)
193         didReceiveHeader(header.first, header.second, ContentSecurityPolicy::PolicyFrom::HTTPHeader, String { });
194     m_referrer = WTFMove(referrer);
195     m_httpStatusCode = headers.m_httpStatusCode;
196 }
197 
198 void ContentSecurityPolicy::didReceiveHeader(const String&amp; header, ContentSecurityPolicyHeaderType type, ContentSecurityPolicy::PolicyFrom policyFrom, String&amp;&amp; referrer, int httpStatusCode)
199 {
200     if (m_hasAPIPolicy)
201         return;
202 
203     m_referrer = WTFMove(referrer);
204     m_httpStatusCode = httpStatusCode;
205 
206     if (policyFrom == PolicyFrom::API) {
207         ASSERT(m_policies.isEmpty());
208         m_hasAPIPolicy = true;
209     }
210 
211     m_cachedResponseHeaders = WTF::nullopt;
212 
213     // RFC2616, section 4.2 specifies that headers appearing multiple times can
214     // be combined with a comma. Walk the header string, and parse each comma
215     // separated chunk as a separate header.
216     auto characters = StringView(header).upconvertedCharacters();
217     const UChar* begin = characters;
218     const UChar* position = begin;
219     const UChar* end = begin + header.length();
220     while (position &lt; end) {
221         skipUntil&lt;UChar&gt;(position, end, &#39;,&#39;);
222 
223         // header1,header2 OR header1
224         //        ^                  ^
225         m_policies.append(ContentSecurityPolicyDirectiveList::create(*this, String(begin, position - begin), type, policyFrom));
226 
227         // Skip the comma, and begin the next header from the current position.
228         ASSERT(position == end || *position == &#39;,&#39;);
229         skipExactly&lt;UChar&gt;(position, end, &#39;,&#39;);
230         begin = position;
231     }
232 
233     if (m_scriptExecutionContext)
234         applyPolicyToScriptExecutionContext();
235 }
236 
237 void ContentSecurityPolicy::updateSourceSelf(const SecurityOrigin&amp; securityOrigin)
238 {
239     m_selfSourceProtocol = securityOrigin.protocol();
240     m_selfSource = std::make_unique&lt;ContentSecurityPolicySource&gt;(*this, m_selfSourceProtocol, securityOrigin.host(), securityOrigin.port(), emptyString(), false, false);
241 }
242 
243 void ContentSecurityPolicy::applyPolicyToScriptExecutionContext()
244 {
245     ASSERT(m_scriptExecutionContext);
246 
247     // Update source self as the security origin may have changed between the time we were created and now.
248     // For instance, we may have been initially created for an about:blank iframe that later inherited the
249     // security origin of its owner document.
250     ASSERT(m_scriptExecutionContext-&gt;securityOrigin());
251     updateSourceSelf(*m_scriptExecutionContext-&gt;securityOrigin());
252 
253     bool enableStrictMixedContentMode = false;
254     for (auto&amp; policy : m_policies) {
255         const ContentSecurityPolicyDirective* violatedDirective = policy-&gt;violatedDirectiveForUnsafeEval();
256         if (violatedDirective &amp;&amp; !violatedDirective-&gt;directiveList().isReportOnly()) {
257             m_lastPolicyEvalDisabledErrorMessage = policy-&gt;evalDisabledErrorMessage();
258             m_lastPolicyWebAssemblyDisabledErrorMessage = policy-&gt;webAssemblyDisabledErrorMessage();
259         }
260         if (policy-&gt;hasBlockAllMixedContentDirective() &amp;&amp; !policy-&gt;isReportOnly())
261             enableStrictMixedContentMode = true;
262     }
263 
264     if (!m_lastPolicyEvalDisabledErrorMessage.isNull())
265         m_scriptExecutionContext-&gt;disableEval(m_lastPolicyEvalDisabledErrorMessage);
266     if (!m_lastPolicyWebAssemblyDisabledErrorMessage.isNull())
267         m_scriptExecutionContext-&gt;disableWebAssembly(m_lastPolicyWebAssemblyDisabledErrorMessage);
268     if (m_sandboxFlags != SandboxNone &amp;&amp; is&lt;Document&gt;(m_scriptExecutionContext))
269         m_scriptExecutionContext-&gt;enforceSandboxFlags(m_sandboxFlags);
270     if (enableStrictMixedContentMode)
271         m_scriptExecutionContext-&gt;setStrictMixedContentMode(true);
272 }
273 
274 void ContentSecurityPolicy::setOverrideAllowInlineStyle(bool value)
275 {
276     m_overrideInlineStyleAllowed = value;
277 }
278 
279 bool ContentSecurityPolicy::urlMatchesSelf(const URL&amp; url) const
280 {
281     return m_selfSource-&gt;matches(url);
282 }
283 
284 bool ContentSecurityPolicy::allowContentSecurityPolicySourceStarToMatchAnyProtocol() const
285 {
286     if (is&lt;Document&gt;(m_scriptExecutionContext))
287         return downcast&lt;Document&gt;(*m_scriptExecutionContext).settings().allowContentSecurityPolicySourceStarToMatchAnyProtocol();
288     return false;
289 }
290 
291 bool ContentSecurityPolicy::protocolMatchesSelf(const URL&amp; url) const
292 {
293     if (equalLettersIgnoringASCIICase(m_selfSourceProtocol, &quot;http&quot;))
294         return url.protocolIsInHTTPFamily();
295     return equalIgnoringASCIICase(url.protocol(), m_selfSourceProtocol);
296 }
297 
298 template&lt;typename Predicate, typename... Args&gt;
299 typename std::enable_if&lt;!std::is_convertible&lt;Predicate, ContentSecurityPolicy::ViolatedDirectiveCallback&gt;::value, bool&gt;::type ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
300 {
301     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
302     for (auto&amp; policy : m_policies) {
303         if (policy-&gt;isReportOnly() != isReportOnly)
304             continue;
305         if ((policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...))
306             return false;
307     }
308     return true;
309 }
310 
311 template&lt;typename Predicate, typename... Args&gt;
312 bool ContentSecurityPolicy::allPoliciesWithDispositionAllow(Disposition disposition, ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
313 {
314     bool isReportOnly = disposition == ContentSecurityPolicy::Disposition::ReportOnly;
315     bool isAllowed = true;
316     for (auto&amp; policy : m_policies) {
317         if (policy-&gt;isReportOnly() != isReportOnly)
318             continue;
319         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
320             isAllowed = false;
321             callback(*violatedDirective);
322         }
323     }
324     return isAllowed;
325 }
326 
327 template&lt;typename Predicate, typename... Args&gt;
328 bool ContentSecurityPolicy::allPoliciesAllow(ViolatedDirectiveCallback&amp;&amp; callback, Predicate&amp;&amp; predicate, Args&amp;&amp;... args) const
329 {
330     bool isAllowed = true;
331     for (auto&amp; policy : m_policies) {
332         if (const ContentSecurityPolicyDirective* violatedDirective = (policy.get()-&gt;*predicate)(std::forward&lt;Args&gt;(args)...)) {
333             if (!violatedDirective-&gt;directiveList().isReportOnly())
334                 isAllowed = false;
335             callback(*violatedDirective);
336         }
337     }
338     return isAllowed;
339 }
340 
341 template&lt;typename Predicate&gt;
342 ContentSecurityPolicy::HashInEnforcedAndReportOnlyPoliciesPair ContentSecurityPolicy::findHashOfContentInPolicies(Predicate&amp;&amp; predicate, const String&amp; content, OptionSet&lt;ContentSecurityPolicyHashAlgorithm&gt; algorithms) const
343 {
344     if (algorithms.isEmpty() || content.isEmpty())
345         return { false, false };
346 
347     // FIXME: We should compute the document encoding once and cache it instead of computing it on each invocation.
348     TextEncoding documentEncoding;
349     if (is&lt;Document&gt;(m_scriptExecutionContext))
350         documentEncoding = downcast&lt;Document&gt;(*m_scriptExecutionContext).textEncoding();
351     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
352 
353     // FIXME: Compute the digest with respect to the raw bytes received from the page.
354     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
355     auto encodedContent = encodingToUse.encode(content, UnencodableHandling::Entities);
356     bool foundHashInEnforcedPolicies = false;
357     bool foundHashInReportOnlyPolicies = false;
358     for (auto algorithm : algorithms) {
359         ContentSecurityPolicyHash hash = cryptographicDigestForBytes(algorithm, encodedContent.data(), encodedContent.size());
360         if (!foundHashInEnforcedPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, std::forward&lt;Predicate&gt;(predicate), hash))
361             foundHashInEnforcedPolicies = true;
362         if (!foundHashInReportOnlyPolicies &amp;&amp; allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, std::forward&lt;Predicate&gt;(predicate), hash))
363             foundHashInReportOnlyPolicies = true;
364         if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
365             break;
366     }
367     return { foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies };
368 }
369 
370 bool ContentSecurityPolicy::allowJavaScriptURLs(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
371 {
372     if (overrideContentSecurityPolicy)
373         return true;
374     bool didNotifyInspector = false;
375     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
376         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
377         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
378         if (!didNotifyInspector &amp;&amp; violatedDirective.directiveList().isReportOnly()) {
379             reportBlockedScriptExecutionToInspector(violatedDirective.text());
380             didNotifyInspector = true;
381         }
382     };
383     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
384 }
385 
386 bool ContentSecurityPolicy::allowInlineEventHandlers(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, bool overrideContentSecurityPolicy) const
387 {
388     if (overrideContentSecurityPolicy)
389         return true;
390     bool didNotifyInspector = false;
391     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
392         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script for an inline event handler&quot;, &quot;&#39;unsafe-inline&#39;&quot;);
393         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
394         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
395             reportBlockedScriptExecutionToInspector(violatedDirective.text());
396             didNotifyInspector = true;
397         }
398     };
399     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
400 }
401 
402 bool ContentSecurityPolicy::allowScriptWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
403 {
404     if (overrideContentSecurityPolicy)
405         return true;
406     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
407     if (strippedNonce.isEmpty())
408         return false;
409     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
410     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptNonce, strippedNonce);
411 }
412 
413 bool ContentSecurityPolicy::allowStyleWithNonce(const String&amp; nonce, bool overrideContentSecurityPolicy) const
414 {
415     if (overrideContentSecurityPolicy)
416         return true;
417     String strippedNonce = stripLeadingAndTrailingHTMLSpaces(nonce);
418     if (strippedNonce.isEmpty())
419         return false;
420     // FIXME: We need to report violations in report-only policies. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159830&gt;.
421     return allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleNonce, strippedNonce);
422 }
423 
424 bool ContentSecurityPolicy::allowInlineScript(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; scriptContent, bool overrideContentSecurityPolicy) const
425 {
426     if (overrideContentSecurityPolicy)
427         return true;
428     bool didNotifyInspector = false;
429     bool foundHashInEnforcedPolicies;
430     bool foundHashInReportOnlyPolicies;
431     std::tie(foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies) = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScriptHash, scriptContent, m_hashAlgorithmsForInlineScripts);
432     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
433         return true;
434     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
435         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
436         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
437         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
438             reportBlockedScriptExecutionToInspector(violatedDirective.text());
439             didNotifyInspector = true;
440         }
441     };
442     // FIXME: We should not report that the inline script violated a policy when its hash matched a source
443     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
444     if (!foundHashInReportOnlyPolicies)
445         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
446     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineScript);
447 }
448 
449 bool ContentSecurityPolicy::allowInlineStyle(const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, const String&amp; styleContent, bool overrideContentSecurityPolicy) const
450 {
451     if (overrideContentSecurityPolicy)
452         return true;
453     if (m_overrideInlineStyleAllowed)
454         return true;
455     bool foundHashInEnforcedPolicies;
456     bool foundHashInReportOnlyPolicies;
457     std::tie(foundHashInEnforcedPolicies, foundHashInReportOnlyPolicies) = findHashOfContentInPolicies(&amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyleHash, styleContent, m_hashAlgorithmsForInlineStylesheets);
458     if (foundHashInEnforcedPolicies &amp;&amp; foundHashInReportOnlyPolicies)
459         return true;
460     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
461         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), &quot;Refused to apply a stylesheet&quot;, &quot;its hash, its nonce, or &#39;unsafe-inline&#39;&quot;);
462         reportViolation(ContentSecurityPolicyDirectiveNames::styleSrc, violatedDirective, URL(), consoleMessage, contextURL, TextPosition(contextLine, WTF::OrdinalNumber()));
463     };
464     // FIXME: We should not report that the inline stylesheet violated a policy when its hash matched a source
465     // expression in the policy and the page has more than one policy. See &lt;https://bugs.webkit.org/show_bug.cgi?id=159832&gt;.
466     if (!foundHashInReportOnlyPolicies)
467         allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::ReportOnly, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
468     return foundHashInEnforcedPolicies || allPoliciesWithDispositionAllow(ContentSecurityPolicy::Disposition::Enforce, handleViolatedDirective, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeInlineStyle);
469 }
470 
471 bool ContentSecurityPolicy::allowEval(JSC::ExecState* state, bool overrideContentSecurityPolicy) const
472 {
473     if (overrideContentSecurityPolicy)
474         return true;
475     bool didNotifyInspector = false;
476     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
477         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), &quot;Refused to execute a script&quot;, &quot;&#39;unsafe-eval&#39;&quot;);
478         reportViolation(ContentSecurityPolicyDirectiveNames::scriptSrc, violatedDirective, URL(), consoleMessage, state);
479         if (!didNotifyInspector &amp;&amp; !violatedDirective.directiveList().isReportOnly()) {
480             reportBlockedScriptExecutionToInspector(violatedDirective.text());
481             didNotifyInspector = true;
482         }
483     };
484     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForUnsafeEval);
485 }
486 
487 bool ContentSecurityPolicy::allowFrameAncestors(const Frame&amp; frame, const URL&amp; url, bool overrideContentSecurityPolicy) const
488 {
489     if (overrideContentSecurityPolicy)
490         return true;
491     Frame&amp; topFrame = frame.tree().top();
492     if (&amp;frame == &amp;topFrame)
493         return true;
494     String sourceURL;
495     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
496     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
497         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
498         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
499     };
500     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestor, frame);
501 }
502 
503 bool ContentSecurityPolicy::allowFrameAncestors(const Vector&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; ancestorOrigins, const URL&amp; url, bool overrideContentSecurityPolicy) const
504 {
505     if (overrideContentSecurityPolicy)
506         return true;
507     bool isTopLevelFrame = ancestorOrigins.isEmpty();
508     if (isTopLevelFrame)
509         return true;
510     String sourceURL;
511     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
512     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
513         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, &quot;Refused to load&quot;);
514         reportViolation(ContentSecurityPolicyDirectiveNames::frameAncestors, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
515     };
516     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrameAncestorOrigins, ancestorOrigins);
517 }
518 
519 bool ContentSecurityPolicy::allowPluginType(const String&amp; type, const String&amp; typeAttribute, const URL&amp; url, bool overrideContentSecurityPolicy) const
520 {
521     if (overrideContentSecurityPolicy)
522         return true;
523     String sourceURL;
524     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
525     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
526         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, &quot;Refused to load&quot;, &quot;its MIME type&quot;);
527         reportViolation(ContentSecurityPolicyDirectiveNames::pluginTypes, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
528     };
529     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForPluginType, type, typeAttribute);
530 }
531 
532 bool ContentSecurityPolicy::allowObjectFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
533 {
534     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
535         return true;
536     // As per section object-src of the Content Security Policy Level 3 spec., &lt;http://w3c.github.io/webappsec-csp&gt; (Editor&#39;s Draft, 29 February 2016),
537     // &quot;If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based
538     // on the specified type), it MUST be blocked if object-src&#39;s value is &#39;none&#39;, but will otherwise be allowed&quot;.
539     String sourceURL;
540     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
541     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
542         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, &quot;Refused to load&quot;);
543         reportViolation(ContentSecurityPolicyDirectiveNames::objectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
544     };
545     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForObjectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes, ContentSecurityPolicySourceListDirective::ShouldAllowEmptyURLIfSourceListIsNotNone::Yes);
546 }
547 
548 bool ContentSecurityPolicy::allowChildFrameFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
549 {
550     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
551         return true;
552     String sourceURL;
553     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
554     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
555         const char* effectiveViolatedDirective = violatedDirective.name() == ContentSecurityPolicyDirectiveNames::frameSrc ? ContentSecurityPolicyDirectiveNames::frameSrc : ContentSecurityPolicyDirectiveNames::childSrc;
556         String consoleMessage = consoleMessageForViolation(effectiveViolatedDirective, violatedDirective, url, &quot;Refused to load&quot;);
557         reportViolation(effectiveViolatedDirective, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
558     };
559     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFrame, url, redirectResponseReceived == RedirectResponseReceived::Yes);
560 }
561 
562 bool ContentSecurityPolicy::allowResourceFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const
563 {
564     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
565         return true;
566     String sourceURL;
567     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
568     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
569         String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, &quot;Refused to load&quot;);
570         reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
571     };
572     return allPoliciesAllow(WTFMove(handleViolatedDirective), resourcePredicate, url, redirectResponseReceived == RedirectResponseReceived::Yes);
573 }
574 
575 bool ContentSecurityPolicy::allowChildContextFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
576 {
577     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);
578 }
579 
580 bool ContentSecurityPolicy::allowScriptFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
581 {
582     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);
583 }
584 
585 bool ContentSecurityPolicy::allowImageFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
586 {
587     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::imgSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForImage);
588 }
589 
590 bool ContentSecurityPolicy::allowStyleFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
591 {
592     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::styleSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForStyle);
593 }
594 
595 bool ContentSecurityPolicy::allowFontFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
596 {
597     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);
598 }
599 
600 #if ENABLE(APPLICATION_MANIFEST)
601 bool ContentSecurityPolicy::allowManifestFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
602 {
603     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);
604 }
605 #endif // ENABLE(APPLICATION_MANIFEST)
606 
607 bool ContentSecurityPolicy::allowMediaFromSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
608 {
609     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);
610 }
611 
612 bool ContentSecurityPolicy::allowConnectToSource(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
613 {
614     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
615         return true;
616     String sourceURL;
617     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
618     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
619         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, &quot;Refused to connect to&quot;);
620         reportViolation(ContentSecurityPolicyDirectiveNames::connectSrc, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
621     };
622     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForConnectSource, url, redirectResponseReceived == RedirectResponseReceived::Yes);
623 }
624 
625 bool ContentSecurityPolicy::allowFormAction(const URL&amp; url, RedirectResponseReceived redirectResponseReceived) const
626 {
627     return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);
628 }
629 
630 bool ContentSecurityPolicy::allowBaseURI(const URL&amp; url, bool overrideContentSecurityPolicy) const
631 {
632     if (overrideContentSecurityPolicy)
633         return true;
634     if (SchemeRegistry::schemeShouldBypassContentSecurityPolicy(url.protocol().toStringWithoutCopying()))
635         return true;
636     String sourceURL;
637     TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());
638     auto handleViolatedDirective = [&amp;] (const ContentSecurityPolicyDirective&amp; violatedDirective) {
639         String consoleMessage = consoleMessageForViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, &quot;Refused to change the document base URL to&quot;);
640         reportViolation(ContentSecurityPolicyDirectiveNames::baseURI, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);
641     };
642     return allPoliciesAllow(WTFMove(handleViolatedDirective), &amp;ContentSecurityPolicyDirectiveList::violatedDirectiveForBaseURI, url);
643 }
644 
645 String ContentSecurityPolicy::deprecatedURLForReporting(const URL&amp; url) const
646 {
647     if (!url.isValid())
648         return { };
649     if (!url.isHierarchical() || url.protocolIs(&quot;file&quot;))
650         return url.protocol().toString();
651     return static_cast&lt;SecurityOriginData&gt;(*m_selfSource).securityOrigin()-&gt;canRequest(url) ? url.strippedForUseAsReferrer() : SecurityOrigin::create(url)-&gt;toString();
652 }
653 
654 void ContentSecurityPolicy::reportViolation(const String&amp; violatedDirective, const ContentSecurityPolicyDirective&amp; effectiveViolatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const
655 {
656     // FIXME: Extract source file and source position from JSC::ExecState.
657     return reportViolation(violatedDirective, effectiveViolatedDirective.text(), effectiveViolatedDirective.directiveList(), blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
658 }
659 
660 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, JSC::ExecState* state) const
661 {
662     // FIXME: Extract source file and source position from JSC::ExecState.
663     return reportViolation(effectiveViolatedDirective, violatedDirective, violatedDirectiveList, blockedURL, consoleMessage, String(), TextPosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber::beforeFirst()), state);
664 }
665 
666 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const ContentSecurityPolicyDirective&amp; violatedDirective, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const
667 {
668     return reportViolation(effectiveViolatedDirective, violatedDirective.text(), violatedDirective.directiveList(), blockedURL, consoleMessage, sourceURL, sourcePosition, state);
669 }
670 
671 void ContentSecurityPolicy::reportViolation(const String&amp; effectiveViolatedDirective, const String&amp; violatedDirective, const ContentSecurityPolicyDirectiveList&amp; violatedDirectiveList, const URL&amp; blockedURL, const String&amp; consoleMessage, const String&amp; sourceURL, const TextPosition&amp; sourcePosition, JSC::ExecState* state) const
672 {
673     logToConsole(consoleMessage, sourceURL, sourcePosition.m_line, state);
674 
675     if (!m_isReportingEnabled)
676         return;
677 
678     // FIXME: Support sending reports from worker.
679     CSPInfo info;
680     info.documentURI = blockedURL;
681     if (m_client)
682         m_client-&gt;willSendCSPViolationReport(info);
683     else {
684         if (!is&lt;Document&gt;(m_scriptExecutionContext))
685             return;
686 
687         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
688         auto* frame = document.frame();
689         if (!frame)
690             return;
691 
692         info.documentURI = document.url().strippedForUseAsReferrer();
693 
694         auto stack = createScriptCallStack(JSExecState::currentState(), 2);
695         auto* callFrame = stack-&gt;firstNonNativeCallFrame();
696         if (callFrame &amp;&amp; callFrame-&gt;lineNumber()) {
697             info.sourceFile = deprecatedURLForReporting(URL { URL { }, callFrame-&gt;sourceURL() });
698             info.lineNumber = callFrame-&gt;lineNumber();
699             info.columnNumber = callFrame-&gt;columnNumber();
700         }
701     }
702     ASSERT(m_client || is&lt;Document&gt;(m_scriptExecutionContext));
703 
704     String blockedURI = deprecatedURLForReporting(blockedURL);
705     // FIXME: Is it policy to not use the status code for HTTPS, or is that a bug?
706     unsigned short httpStatusCode = m_selfSourceProtocol == &quot;http&quot; ? m_httpStatusCode : 0;
707 
708     // 1. Dispatch violation event.
709     SecurityPolicyViolationEvent::Init violationEventInit;
710     violationEventInit.documentURI = info.documentURI;
711     violationEventInit.referrer = m_referrer;
712     violationEventInit.blockedURI = blockedURI;
713     violationEventInit.violatedDirective = violatedDirective;
714     violationEventInit.effectiveDirective = effectiveViolatedDirective;
715     violationEventInit.originalPolicy = violatedDirectiveList.header();
716     violationEventInit.sourceFile = info.sourceFile;
717     violationEventInit.statusCode = httpStatusCode;
718     violationEventInit.lineNumber =  info.lineNumber;
719     violationEventInit.columnNumber = info.columnNumber;
720     if (m_client)
721         m_client-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
722     else
723         downcast&lt;Document&gt;(*m_scriptExecutionContext).enqueueSecurityPolicyViolationEvent(WTFMove(violationEventInit));
724 
725     // 2. Send violation report (if applicable).
726     auto&amp; reportURIs = violatedDirectiveList.reportURIs();
727     if (reportURIs.isEmpty())
728         return;
729 
730     // We need to be careful here when deciding what information to send to the
731     // report-uri. Currently, we send only the current document&#39;s URL and the
732     // directive that was violated. The document&#39;s URL is safe to send because
733     // it&#39;s the document itself that&#39;s requesting that it be sent. You could
734     // make an argument that we shouldn&#39;t send HTTPS document URLs to HTTP
735     // report-uris (for the same reasons that we suppress the Referer in that
736     // case), but the Referer is sent implicitly whereas this request is only
737     // sent explicitly. As for which directive was violated, that&#39;s pretty
738     // harmless information.
739 
740     auto cspReport = JSON::Object::create();
741     cspReport-&gt;setString(&quot;document-uri&quot;_s, info.documentURI);
742     cspReport-&gt;setString(&quot;referrer&quot;_s, m_referrer);
743     cspReport-&gt;setString(&quot;violated-directive&quot;_s, violatedDirective);
744     cspReport-&gt;setString(&quot;effective-directive&quot;_s, effectiveViolatedDirective);
745     cspReport-&gt;setString(&quot;original-policy&quot;_s, violatedDirectiveList.header());
746     cspReport-&gt;setString(&quot;blocked-uri&quot;_s, blockedURI);
747     cspReport-&gt;setInteger(&quot;status-code&quot;_s, httpStatusCode);
748     if (!info.sourceFile.isNull()) {
749         cspReport-&gt;setString(&quot;source-file&quot;_s, info.sourceFile);
750         cspReport-&gt;setInteger(&quot;line-number&quot;_s, info.lineNumber);
751         cspReport-&gt;setInteger(&quot;column-number&quot;_s, info.columnNumber);
752     }
753 
754     auto reportObject = JSON::Object::create();
755     reportObject-&gt;setObject(&quot;csp-report&quot;_s, WTFMove(cspReport));
756 
757     auto report = FormData::create(reportObject-&gt;toJSONString().utf8());
758 
759     if (m_client) {
760         for (const auto&amp; url : reportURIs)
761             m_client-&gt;sendCSPViolationReport(URL { m_protectedURL, url }, report.copyRef());
762     } else {
763         auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
764         for (const auto&amp; url : reportURIs)
765             PingLoader::sendViolationReport(*document.frame(), URL { m_protectedURL, url }, report.copyRef(), ViolationReportType::ContentSecurityPolicy);
766     }
767 }
768 
769 void ContentSecurityPolicy::reportUnsupportedDirective(const String&amp; name) const
770 {
771     String message;
772     if (equalLettersIgnoringASCIICase(name, &quot;allow&quot;))
773         message = &quot;The &#39;allow&#39; directive has been replaced with &#39;default-src&#39;. Please use that directive instead, as &#39;allow&#39; has no effect.&quot;_s;
774     else if (equalLettersIgnoringASCIICase(name, &quot;options&quot;))
775         message = &quot;The &#39;options&#39; directive has been replaced with &#39;unsafe-inline&#39; and &#39;unsafe-eval&#39; source expressions for the &#39;script-src&#39; and &#39;style-src&#39; directives. Please use those directives instead, as &#39;options&#39; has no effect.&quot;_s;
776     else if (equalLettersIgnoringASCIICase(name, &quot;policy-uri&quot;))
777         message = &quot;The &#39;policy-uri&#39; directive has been removed from the specification. Please specify a complete policy via the Content-Security-Policy header.&quot;_s;
778     else
779         message = makeString(&quot;Unrecognized Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;); // FIXME: Why does this include a newline?
780 
781     logToConsole(message);
782 }
783 
784 void ContentSecurityPolicy::reportDirectiveAsSourceExpression(const String&amp; directiveName, const String&amp; sourceExpression) const
785 {
786     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; contains &#39;&quot; + sourceExpression + &quot;&#39; as a source expression. Did you mean &#39;&quot; + directiveName + &quot; ...; &quot; + sourceExpression + &quot;...&#39; (note the semicolon)?&quot;);
787 }
788 
789 void ContentSecurityPolicy::reportDuplicateDirective(const String&amp; name) const
790 {
791     logToConsole(makeString(&quot;Ignoring duplicate Content-Security-Policy directive &#39;&quot;, name, &quot;&#39;.\n&quot;));
792 }
793 
794 void ContentSecurityPolicy::reportInvalidPluginTypes(const String&amp; pluginType) const
795 {
796     String message;
797     if (pluginType.isNull())
798         message = &quot;&#39;plugin-types&#39; Content Security Policy directive is empty; all plugins will be blocked.\n&quot;;
799     else
800         message = makeString(&quot;Invalid plugin type in &#39;plugin-types&#39; Content Security Policy directive: &#39;&quot;, pluginType, &quot;&#39;.\n&quot;);
801     logToConsole(message);
802 }
803 
804 void ContentSecurityPolicy::reportInvalidSandboxFlags(const String&amp; invalidFlags) const
805 {
806     logToConsole(&quot;Error while parsing the &#39;sandbox&#39; Content Security Policy directive: &quot; + invalidFlags);
807 }
808 
809 void ContentSecurityPolicy::reportInvalidDirectiveInReportOnlyMode(const String&amp; directiveName) const
810 {
811     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered in a report-only policy.&quot;);
812 }
813 
814 void ContentSecurityPolicy::reportInvalidDirectiveInHTTPEquivMeta(const String&amp; directiveName) const
815 {
816     logToConsole(&quot;The Content Security Policy directive &#39;&quot; + directiveName + &quot;&#39; is ignored when delivered via an HTML meta element.&quot;);
817 }
818 
819 void ContentSecurityPolicy::reportInvalidDirectiveValueCharacter(const String&amp; directiveName, const String&amp; value) const
820 {
821     String message = makeString(&quot;The value for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid character: &#39;&quot;, value, &quot;&#39;. Non-whitespace characters outside ASCII 0x21-0x7E must be percent-encoded, as described in RFC 3986, section 2.1: http://tools.ietf.org/html/rfc3986#section-2.1.&quot;);
822     logToConsole(message);
823 }
824 
825 void ContentSecurityPolicy::reportInvalidPathCharacter(const String&amp; directiveName, const String&amp; value, const char invalidChar) const
826 {
827     ASSERT(invalidChar == &#39;#&#39; || invalidChar == &#39;?&#39;);
828 
829     String ignoring;
830     if (invalidChar == &#39;?&#39;)
831         ignoring = &quot;The query component, including the &#39;?&#39;, will be ignored.&quot;;
832     else
833         ignoring = &quot;The fragment identifier, including the &#39;#&#39;, will be ignored.&quot;;
834 
835     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains a source with an invalid path: &#39;&quot;, value, &quot;&#39;. &quot;, ignoring);
836     logToConsole(message);
837 }
838 
839 void ContentSecurityPolicy::reportInvalidSourceExpression(const String&amp; directiveName, const String&amp; source) const
840 {
841     String message = makeString(&quot;The source list for Content Security Policy directive &#39;&quot;, directiveName, &quot;&#39; contains an invalid source: &#39;&quot;, source, &quot;&#39;. It will be ignored.&quot;);
842     if (equalLettersIgnoringASCIICase(source, &quot;&#39;none&#39;&quot;))
843         message = makeString(message, &quot; Note that &#39;none&#39; has no effect unless it is the only expression in the source list.&quot;);
844     logToConsole(message);
845 }
846 
847 void ContentSecurityPolicy::reportMissingReportURI(const String&amp; policy) const
848 {
849     logToConsole(&quot;The Content Security Policy &#39;&quot; + policy + &quot;&#39; was delivered in report-only mode, but does not specify a &#39;report-uri&#39;; the policy will have no effect. Please either add a &#39;report-uri&#39; directive, or deliver the policy via the &#39;Content-Security-Policy&#39; header.&quot;);
850 }
851 
852 void ContentSecurityPolicy::logToConsole(const String&amp; message, const String&amp; contextURL, const WTF::OrdinalNumber&amp; contextLine, JSC::ExecState* state) const
853 {
854     if (!m_isReportingEnabled)
855         return;
856 
857     // FIXME: &lt;http://webkit.org/b/114317&gt; ContentSecurityPolicy::logToConsole should include a column number
858     if (m_client)
859         m_client-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, 0);
860     else if (m_scriptExecutionContext)
861         m_scriptExecutionContext-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, contextURL, contextLine.oneBasedInt(), 0, state);
862 }
863 
864 void ContentSecurityPolicy::reportBlockedScriptExecutionToInspector(const String&amp; directiveText) const
865 {
866     if (m_scriptExecutionContext)
867         InspectorInstrumentation::scriptExecutionBlockedByCSP(m_scriptExecutionContext, directiveText);
868 }
869 
870 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(ResourceRequest&amp; request, InsecureRequestType requestType) const
871 {
872     URL url = request.url();
873     upgradeInsecureRequestIfNeeded(url, requestType);
874     request.setURL(url);
875 }
876 
877 void ContentSecurityPolicy::upgradeInsecureRequestIfNeeded(URL&amp; url, InsecureRequestType requestType) const
878 {
879     if (!url.protocolIs(&quot;http&quot;) &amp;&amp; !url.protocolIs(&quot;ws&quot;))
880         return;
881 
882     bool upgradeRequest = m_insecureNavigationRequestsToUpgrade.contains(SecurityOriginData::fromURL(url));
883     if (requestType == InsecureRequestType::Load || requestType == InsecureRequestType::FormSubmission)
884         upgradeRequest |= m_upgradeInsecureRequests;
885 
886     if (!upgradeRequest)
887         return;
888 
889     if (url.protocolIs(&quot;http&quot;))
890         url.setProtocol(&quot;https&quot;);
891     else {
892         ASSERT(url.protocolIs(&quot;ws&quot;));
893         url.setProtocol(&quot;wss&quot;);
894     }
895 
896     if (url.port() &amp;&amp; url.port().value() == 80)
897         url.setPort(443);
898 }
899 
900 void ContentSecurityPolicy::setUpgradeInsecureRequests(bool upgradeInsecureRequests)
901 {
902     m_upgradeInsecureRequests = upgradeInsecureRequests;
903     if (!m_upgradeInsecureRequests)
904         return;
905 
906     if (!m_scriptExecutionContext)
907         return;
908 
909     // Store the upgrade domain as an &#39;insecure&#39; protocol so we can quickly identify
910     // origins we should upgrade.
911     URL upgradeURL = m_scriptExecutionContext-&gt;url();
912     if (upgradeURL.protocolIs(&quot;https&quot;))
913         upgradeURL.setProtocol(&quot;http&quot;);
914     else if (upgradeURL.protocolIs(&quot;wss&quot;))
915         upgradeURL.setProtocol(&quot;ws&quot;);
916 
917     m_insecureNavigationRequestsToUpgrade.add(SecurityOriginData::fromURL(upgradeURL));
918 }
919 
920 void ContentSecurityPolicy::inheritInsecureNavigationRequestsToUpgradeFromOpener(const ContentSecurityPolicy&amp; other)
921 {
922     m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());
923 }
924 
925 HashSet&lt;SecurityOriginData&gt; ContentSecurityPolicy::takeNavigationRequestsToUpgrade()
926 {
927     return WTFMove(m_insecureNavigationRequestsToUpgrade);
928 }
929 
930 void ContentSecurityPolicy::setInsecureNavigationRequestsToUpgrade(HashSet&lt;SecurityOriginData&gt;&amp;&amp; insecureNavigationRequests)
931 {
932     m_insecureNavigationRequestsToUpgrade = WTFMove(insecureNavigationRequests);
933 }
934 
935 }
    </pre>
  </body>
</html>