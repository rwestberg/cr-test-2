<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2000 Peter Kelly &lt;pmk@post.com&gt;
   3  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   5  * Copyright (C) 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   7  * Copyright (C) 2008 Holger Hans Peter Freyther
   8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  * Copyright (C) 2010 Patrick Gansterer &lt;paroga@paroga.com&gt;
  10  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;XMLDocumentParser.h&quot;
  30 
  31 #include &quot;CDATASection.h&quot;
  32 #include &quot;Comment.h&quot;
  33 #include &quot;CachedResourceLoader.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;DocumentType.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameLoader.h&quot;
  39 #include &quot;HTMLEntityParser.h&quot;
  40 #include &quot;HTMLHtmlElement.h&quot;
  41 #include &quot;HTMLTemplateElement.h&quot;
  42 #include &quot;InlineClassicScript.h&quot;
  43 #include &quot;PendingScript.h&quot;
  44 #include &quot;ProcessingInstruction.h&quot;
  45 #include &quot;ResourceError.h&quot;
  46 #include &quot;ResourceResponse.h&quot;
  47 #include &quot;ScriptElement.h&quot;
  48 #include &quot;ScriptSourceCode.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SharedBuffer.h&quot;
  51 #include &quot;StyleScope.h&quot;
  52 #include &quot;TransformSource.h&quot;
  53 #include &quot;XMLNSNames.h&quot;
  54 #include &quot;XMLDocumentParserScope.h&quot;
  55 #include &lt;libxml/parserInternals.h&gt;
  56 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  57 
  58 #if ENABLE(XSLT)
  59 #include &quot;XMLTreeViewer.h&quot;
  60 #include &lt;libxslt/xslt.h&gt;
  61 #endif
  62 
  63 namespace WebCore {
  64 
  65 #if ENABLE(XSLT)
  66 
  67 static inline bool shouldRenderInXMLTreeViewerMode(Document&amp; document)
  68 {
  69     if (document.sawElementsInKnownNamespaces())
  70         return false;
  71 
  72     if (document.transformSourceDocument())
  73         return false;
  74 
  75     auto* frame = document.frame();
  76     if (!frame)
  77         return false;
  78 
  79     if (!frame-&gt;settings().developerExtrasEnabled())
  80         return false;
  81 
  82     if (frame-&gt;tree().parent())
  83         return false; // This document is not in a top frame
  84 
  85     return true;
  86 }
  87 
  88 #endif
  89 
  90 class PendingCallbacks {
  91     WTF_MAKE_FAST_ALLOCATED;
  92 public:
  93     void appendStartElementNSCallback(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** attributes)
  94     {
<a name="1" id="anc1"></a><span class="line-modified">  95         auto callback = makeUnique&lt;PendingStartElementNSCallback&gt;();</span>
  96 
  97         callback-&gt;xmlLocalName = xmlStrdup(xmlLocalName);
  98         callback-&gt;xmlPrefix = xmlStrdup(xmlPrefix);
  99         callback-&gt;xmlURI = xmlStrdup(xmlURI);
 100         callback-&gt;numNamespaces = numNamespaces;
 101         callback-&gt;namespaces = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numNamespaces * 2));
 102         for (int i = 0; i &lt; numNamespaces * 2 ; i++)
 103             callback-&gt;namespaces[i] = xmlStrdup(namespaces[i]);
 104         callback-&gt;numAttributes = numAttributes;
 105         callback-&gt;numDefaulted = numDefaulted;
 106         callback-&gt;attributes = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numAttributes * 5));
 107         for (int i = 0; i &lt; numAttributes; i++) {
 108             // Each attribute has 5 elements in the array:
 109             // name, prefix, uri, value and an end pointer.
 110 
 111             for (int j = 0; j &lt; 3; j++)
 112                 callback-&gt;attributes[i * 5 + j] = xmlStrdup(attributes[i * 5 + j]);
 113 
 114             int len = attributes[i * 5 + 4] - attributes[i * 5 + 3];
 115 
 116             callback-&gt;attributes[i * 5 + 3] = xmlStrndup(attributes[i * 5 + 3], len);
 117             callback-&gt;attributes[i * 5 + 4] = callback-&gt;attributes[i * 5 + 3] + len;
 118         }
 119 
 120         m_callbacks.append(WTFMove(callback));
 121     }
 122 
 123     void appendEndElementNSCallback()
 124     {
<a name="2" id="anc2"></a><span class="line-modified"> 125         m_callbacks.append(makeUnique&lt;PendingEndElementNSCallback&gt;());</span>
 126     }
 127 
 128     void appendCharactersCallback(const xmlChar* s, int len)
 129     {
<a name="3" id="anc3"></a><span class="line-modified"> 130         auto callback = makeUnique&lt;PendingCharactersCallback&gt;();</span>
 131 
 132         callback-&gt;s = xmlStrndup(s, len);
 133         callback-&gt;len = len;
 134 
 135         m_callbacks.append(WTFMove(callback));
 136     }
 137 
 138     void appendProcessingInstructionCallback(const xmlChar* target, const xmlChar* data)
 139     {
<a name="4" id="anc4"></a><span class="line-modified"> 140         auto callback = makeUnique&lt;PendingProcessingInstructionCallback&gt;();</span>
 141 
 142         callback-&gt;target = xmlStrdup(target);
 143         callback-&gt;data = xmlStrdup(data);
 144 
 145         m_callbacks.append(WTFMove(callback));
 146     }
 147 
 148     void appendCDATABlockCallback(const xmlChar* s, int len)
 149     {
<a name="5" id="anc5"></a><span class="line-modified"> 150         auto callback = makeUnique&lt;PendingCDATABlockCallback&gt;();</span>
 151 
 152         callback-&gt;s = xmlStrndup(s, len);
 153         callback-&gt;len = len;
 154 
 155         m_callbacks.append(WTFMove(callback));
 156     }
 157 
 158     void appendCommentCallback(const xmlChar* s)
 159     {
<a name="6" id="anc6"></a><span class="line-modified"> 160         auto callback = makeUnique&lt;PendingCommentCallback&gt;();</span>
 161 
 162         callback-&gt;s = xmlStrdup(s);
 163 
 164         m_callbacks.append(WTFMove(callback));
 165     }
 166 
 167     void appendInternalSubsetCallback(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
 168     {
<a name="7" id="anc7"></a><span class="line-modified"> 169         auto callback = makeUnique&lt;PendingInternalSubsetCallback&gt;();</span>
 170 
 171         callback-&gt;name = xmlStrdup(name);
 172         callback-&gt;externalID = xmlStrdup(externalID);
 173         callback-&gt;systemID = xmlStrdup(systemID);
 174 
 175         m_callbacks.append(WTFMove(callback));
 176     }
 177 
 178     void appendErrorCallback(XMLErrors::ErrorType type, const xmlChar* message, OrdinalNumber lineNumber, OrdinalNumber columnNumber)
 179     {
<a name="8" id="anc8"></a><span class="line-modified"> 180         auto callback = makeUnique&lt;PendingErrorCallback&gt;();</span>
 181 
 182         callback-&gt;message = xmlStrdup(message);
 183         callback-&gt;type = type;
 184         callback-&gt;lineNumber = lineNumber;
 185         callback-&gt;columnNumber = columnNumber;
 186 
 187         m_callbacks.append(WTFMove(callback));
 188     }
 189 
 190     void callAndRemoveFirstCallback(XMLDocumentParser* parser)
 191     {
 192         std::unique_ptr&lt;PendingCallback&gt; callback = m_callbacks.takeFirst();
 193         callback-&gt;call(parser);
 194     }
 195 
 196     bool isEmpty() const { return m_callbacks.isEmpty(); }
 197 
 198 private:
 199     struct PendingCallback {
<a name="9" id="anc9"></a><span class="line-added"> 200         WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
 201         virtual ~PendingCallback() = default;
 202         virtual void call(XMLDocumentParser* parser) = 0;
 203     };
 204 
 205     struct PendingStartElementNSCallback : public PendingCallback {
 206         virtual ~PendingStartElementNSCallback()
 207         {
 208             xmlFree(xmlLocalName);
 209             xmlFree(xmlPrefix);
 210             xmlFree(xmlURI);
 211             for (int i = 0; i &lt; numNamespaces * 2; i++)
 212                 xmlFree(namespaces[i]);
 213             xmlFree(namespaces);
 214             for (int i = 0; i &lt; numAttributes; i++) {
 215                 for (int j = 0; j &lt; 4; j++)
 216                     xmlFree(attributes[i * 5 + j]);
 217             }
 218             xmlFree(attributes);
 219         }
 220 
 221         void call(XMLDocumentParser* parser) override
 222         {
 223             parser-&gt;startElementNs(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, const_cast&lt;const xmlChar**&gt;(namespaces), numAttributes, numDefaulted, const_cast&lt;const xmlChar**&gt;(attributes));
 224         }
 225 
 226         xmlChar* xmlLocalName;
 227         xmlChar* xmlPrefix;
 228         xmlChar* xmlURI;
 229         int numNamespaces;
 230         xmlChar** namespaces;
 231         int numAttributes;
 232         int numDefaulted;
 233         xmlChar** attributes;
 234     };
 235 
 236     struct PendingEndElementNSCallback : public PendingCallback {
 237         void call(XMLDocumentParser* parser) override
 238         {
 239             parser-&gt;endElementNs();
 240         }
 241     };
 242 
 243     struct PendingCharactersCallback : public PendingCallback {
 244         virtual ~PendingCharactersCallback()
 245         {
 246             xmlFree(s);
 247         }
 248 
 249         void call(XMLDocumentParser* parser) override
 250         {
 251             parser-&gt;characters(s, len);
 252         }
 253 
 254         xmlChar* s;
 255         int len;
 256     };
 257 
 258     struct PendingProcessingInstructionCallback : public PendingCallback {
 259         virtual ~PendingProcessingInstructionCallback()
 260         {
 261             xmlFree(target);
 262             xmlFree(data);
 263         }
 264 
 265         void call(XMLDocumentParser* parser) override
 266         {
 267             parser-&gt;processingInstruction(target, data);
 268         }
 269 
 270         xmlChar* target;
 271         xmlChar* data;
 272     };
 273 
 274     struct PendingCDATABlockCallback : public PendingCallback {
 275         virtual ~PendingCDATABlockCallback()
 276         {
 277             xmlFree(s);
 278         }
 279 
 280         void call(XMLDocumentParser* parser) override
 281         {
 282             parser-&gt;cdataBlock(s, len);
 283         }
 284 
 285         xmlChar* s;
 286         int len;
 287     };
 288 
 289     struct PendingCommentCallback : public PendingCallback {
 290         virtual ~PendingCommentCallback()
 291         {
 292             xmlFree(s);
 293         }
 294 
 295         void call(XMLDocumentParser* parser) override
 296         {
 297             parser-&gt;comment(s);
 298         }
 299 
 300         xmlChar* s;
 301     };
 302 
 303     struct PendingInternalSubsetCallback : public PendingCallback {
 304         virtual ~PendingInternalSubsetCallback()
 305         {
 306             xmlFree(name);
 307             xmlFree(externalID);
 308             xmlFree(systemID);
 309         }
 310 
 311         void call(XMLDocumentParser* parser) override
 312         {
 313             parser-&gt;internalSubset(name, externalID, systemID);
 314         }
 315 
 316         xmlChar* name;
 317         xmlChar* externalID;
 318         xmlChar* systemID;
 319     };
 320 
 321     struct PendingErrorCallback: public PendingCallback {
 322         virtual ~PendingErrorCallback()
 323         {
 324             xmlFree(message);
 325         }
 326 
 327         void call(XMLDocumentParser* parser) override
 328         {
 329             parser-&gt;handleError(type, reinterpret_cast&lt;char*&gt;(message), TextPosition(lineNumber, columnNumber));
 330         }
 331 
 332         XMLErrors::ErrorType type;
 333         xmlChar* message;
 334         OrdinalNumber lineNumber;
 335         OrdinalNumber columnNumber;
 336     };
 337 
 338     Deque&lt;std::unique_ptr&lt;PendingCallback&gt;&gt; m_callbacks;
 339 };
 340 // --------------------------------
 341 
 342 static int globalDescriptor = 0;
 343 static Thread* libxmlLoaderThread { nullptr };
 344 
 345 static int matchFunc(const char*)
 346 {
 347     // Only match loads initiated due to uses of libxml2 from within XMLDocumentParser to avoid
 348     // interfering with client applications that also use libxml2.  http://bugs.webkit.org/show_bug.cgi?id=17353
 349     return XMLDocumentParserScope::currentCachedResourceLoader &amp;&amp; libxmlLoaderThread == &amp;Thread::current();
 350 }
 351 
 352 class OffsetBuffer {
 353     WTF_MAKE_FAST_ALLOCATED;
 354 public:
 355     OffsetBuffer(Vector&lt;char&gt; buffer)
 356         : m_buffer(WTFMove(buffer))
 357         , m_currentOffset(0)
 358     {
 359     }
 360 
 361     int readOutBytes(char* outputBuffer, unsigned askedToRead)
 362     {
 363         unsigned bytesLeft = m_buffer.size() - m_currentOffset;
 364         unsigned lenToCopy = std::min(askedToRead, bytesLeft);
 365         if (lenToCopy) {
 366             memcpy(outputBuffer, m_buffer.data() + m_currentOffset, lenToCopy);
 367             m_currentOffset += lenToCopy;
 368         }
 369         return lenToCopy;
 370     }
 371 
 372 private:
 373     Vector&lt;char&gt; m_buffer;
 374     unsigned m_currentOffset;
 375 };
 376 
 377 static inline void setAttributes(Element* element, Vector&lt;Attribute&gt;&amp; attributeVector, ParserContentPolicy parserContentPolicy)
 378 {
 379     if (!scriptingContentIsAllowed(parserContentPolicy))
 380         element-&gt;stripScriptingAttributes(attributeVector);
 381     element-&gt;parserSetAttributes(attributeVector);
 382 }
 383 
 384 static void switchToUTF16(xmlParserCtxtPtr ctxt)
 385 {
 386     // Hack around libxml2&#39;s lack of encoding overide support by manually
 387     // resetting the encoding to UTF-16 before every chunk.  Otherwise libxml
 388     // will detect &lt;?xml version=&quot;1.0&quot; encoding=&quot;&lt;encoding name&gt;&quot;?&gt; blocks
 389     // and switch encodings, causing the parse to fail.
 390 
 391     // FIXME: Can we just use XML_PARSE_IGNORE_ENC now?
 392 
 393     const UChar BOM = 0xFEFF;
 394     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
 395     xmlSwitchEncoding(ctxt, BOMHighByte == 0xFF ? XML_CHAR_ENCODING_UTF16LE : XML_CHAR_ENCODING_UTF16BE);
 396 }
 397 
 398 static bool shouldAllowExternalLoad(const URL&amp; url)
 399 {
 400     String urlString = url.string();
 401 
 402     // On non-Windows platforms libxml asks for this URL, the &quot;XML_XML_DEFAULT_CATALOG&quot;, on initialization.
 403     if (urlString == &quot;file:///etc/xml/catalog&quot;)
 404         return false;
 405 
 406     // On Windows, libxml computes a URL relative to where its DLL resides.
 407     if (startsWithLettersIgnoringASCIICase(urlString, &quot;file:///&quot;) &amp;&amp; urlString.endsWithIgnoringASCIICase(&quot;/etc/catalog&quot;))
 408         return false;
 409 
 410     // The most common DTD. There isn&#39;t much point in hammering www.w3c.org by requesting this for every XHTML document.
 411     if (startsWithLettersIgnoringASCIICase(urlString, &quot;http://www.w3.org/tr/xhtml&quot;))
 412         return false;
 413 
 414     // Similarly, there isn&#39;t much point in requesting the SVG DTD.
 415     if (startsWithLettersIgnoringASCIICase(urlString, &quot;http://www.w3.org/graphics/svg&quot;))
 416         return false;
 417 
 418     // The libxml doesn&#39;t give us a lot of context for deciding whether to
 419     // allow this request.  In the worst case, this load could be for an
 420     // external entity and the resulting document could simply read the
 421     // retrieved content.  If we had more context, we could potentially allow
 422     // the parser to load a DTD.  As things stand, we take the conservative
 423     // route and allow same-origin requests only.
 424     if (!XMLDocumentParserScope::currentCachedResourceLoader-&gt;document()-&gt;securityOrigin().canRequest(url)) {
 425         XMLDocumentParserScope::currentCachedResourceLoader-&gt;printAccessDeniedMessage(url);
 426         return false;
 427     }
 428 
 429     return true;
 430 }
 431 
 432 static void* openFunc(const char* uri)
 433 {
 434     ASSERT(XMLDocumentParserScope::currentCachedResourceLoader);
 435     ASSERT(libxmlLoaderThread == &amp;Thread::current());
 436 
 437     URL url(URL(), uri);
 438 
 439     if (!shouldAllowExternalLoad(url))
 440         return &amp;globalDescriptor;
 441 
 442     ResourceError error;
 443     ResourceResponse response;
 444     RefPtr&lt;SharedBuffer&gt; data;
 445 
 446 
 447     {
 448         CachedResourceLoader* cachedResourceLoader = XMLDocumentParserScope::currentCachedResourceLoader;
 449         XMLDocumentParserScope scope(nullptr);
 450         // FIXME: We should restore the original global error handler as well.
 451 
 452         if (cachedResourceLoader-&gt;frame()) {
 453             FetchOptions options;
 454             options.mode = FetchOptions::Mode::SameOrigin;
 455             options.credentials = FetchOptions::Credentials::Include;
 456             cachedResourceLoader-&gt;frame()-&gt;loader().loadResourceSynchronously(url, ClientCredentialPolicy::MayAskClientForCredentials, options, { }, error, response, data);
 457         }
 458     }
 459 
 460     // We have to check the URL again after the load to catch redirects.
 461     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=21963&gt;.
 462     if (!shouldAllowExternalLoad(response.url()))
 463         return &amp;globalDescriptor;
 464     Vector&lt;char&gt; buffer;
 465     if (data)
 466         buffer.append(data-&gt;data(), data-&gt;size());
 467     return new OffsetBuffer(WTFMove(buffer));
 468 }
 469 
 470 static int readFunc(void* context, char* buffer, int len)
 471 {
 472     // Do 0-byte reads in case of a null descriptor
 473     if (context == &amp;globalDescriptor)
 474         return 0;
 475 
 476     OffsetBuffer* data = static_cast&lt;OffsetBuffer*&gt;(context);
 477     return data-&gt;readOutBytes(buffer, len);
 478 }
 479 
 480 static int writeFunc(void*, const char*, int)
 481 {
 482     // Always just do 0-byte writes
 483     return 0;
 484 }
 485 
 486 static int closeFunc(void* context)
 487 {
 488     if (context != &amp;globalDescriptor) {
 489         OffsetBuffer* data = static_cast&lt;OffsetBuffer*&gt;(context);
 490         delete data;
 491     }
 492     return 0;
 493 }
 494 
 495 #if ENABLE(XSLT)
 496 static void errorFunc(void*, const char*, ...)
 497 {
 498     // FIXME: It would be nice to display error messages somewhere.
 499 }
 500 #endif
 501 
 502 static void initializeXMLParser()
 503 {
 504     static std::once_flag flag;
 505     std::call_once(flag, [&amp;] {
 506         xmlInitParser();
 507         xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);
 508         xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);
 509         libxmlLoaderThread = &amp;Thread::current();
 510     });
 511 }
 512 
 513 Ref&lt;XMLParserContext&gt; XMLParserContext::createStringParser(xmlSAXHandlerPtr handlers, void* userData)
 514 {
 515     initializeXMLParser();
 516 
 517     xmlParserCtxtPtr parser = xmlCreatePushParserCtxt(handlers, 0, 0, 0, 0);
 518     parser-&gt;_private = userData;
 519 
 520     // Substitute entities.
 521     xmlCtxtUseOptions(parser, XML_PARSE_NOENT | XML_PARSE_HUGE);
 522 
 523     switchToUTF16(parser);
 524 
 525     return adoptRef(*new XMLParserContext(parser));
 526 }
 527 
 528 
 529 // Chunk should be encoded in UTF-8
 530 RefPtr&lt;XMLParserContext&gt; XMLParserContext::createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const CString&amp; chunk)
 531 {
 532     initializeXMLParser();
 533 
 534     // appendFragmentSource() checks that the length doesn&#39;t overflow an int.
 535     xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk.data(), chunk.length());
 536 
 537     if (!parser)
 538         return 0;
 539 
 540     memcpy(parser-&gt;sax, handlers, sizeof(xmlSAXHandler));
 541 
 542     // Substitute entities.
 543     // FIXME: Why is XML_PARSE_NODICT needed? This is different from what createStringParser does.
 544     xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT | XML_PARSE_HUGE);
 545 
 546     // Internal initialization
 547     parser-&gt;sax2 = 1;
 548     parser-&gt;instate = XML_PARSER_CONTENT; // We are parsing a CONTENT
 549     parser-&gt;depth = 0;
 550     parser-&gt;str_xml = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xml&quot;)), 3);
 551     parser-&gt;str_xmlns = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xmlns&quot;)), 5);
 552     parser-&gt;str_xml_ns = xmlDictLookup(parser-&gt;dict, XML_XML_NAMESPACE, 36);
 553     parser-&gt;_private = userData;
 554 
 555     return adoptRef(*new XMLParserContext(parser));
 556 }
 557 
 558 // --------------------------------
 559 
 560 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 561 {
 562     return version == &quot;1.0&quot;;
 563 }
 564 
 565 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 566     : ScriptableDocumentParser(document)
 567     , m_view(frameView)
<a name="10" id="anc10"></a><span class="line-modified"> 568     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())</span>
 569     , m_currentNode(&amp;document)
 570     , m_scriptStartPosition(TextPosition::belowRangePosition())
 571 {
 572 }
 573 
 574 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, Element* parentElement, ParserContentPolicy parserContentPolicy)
 575     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
<a name="11" id="anc11"></a><span class="line-modified"> 576     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())</span>
 577     , m_currentNode(&amp;fragment)
 578     , m_scriptStartPosition(TextPosition::belowRangePosition())
 579     , m_parsingFragment(true)
 580 {
 581     fragment.ref();
 582 
 583     // Add namespaces based on the parent node
 584     Vector&lt;Element*&gt; elemStack;
 585     while (parentElement) {
 586         elemStack.append(parentElement);
 587 
 588         ContainerNode* node = parentElement-&gt;parentNode();
 589         if (!is&lt;Element&gt;(node))
 590             break;
 591         parentElement = downcast&lt;Element&gt;(node);
 592     }
 593 
 594     if (elemStack.isEmpty())
 595         return;
 596 
 597     // FIXME: Share code with isDefaultNamespace() per http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#parsing-xhtml-fragments
 598     for (; !elemStack.isEmpty(); elemStack.removeLast()) {
 599         Element* element = elemStack.last();
 600         if (element-&gt;hasAttributes()) {
 601             for (const Attribute&amp; attribute : element-&gt;attributesIterator()) {
 602                 if (attribute.localName() == xmlnsAtom())
 603                     m_defaultNamespaceURI = attribute.value();
 604                 else if (attribute.prefix() == xmlnsAtom())
 605                     m_prefixToNamespaceMap.set(attribute.localName(), attribute.value());
 606             }
 607         }
 608     }
 609 
 610     if (m_defaultNamespaceURI.isNull())
 611         m_defaultNamespaceURI = parentElement-&gt;namespaceURI();
 612 }
 613 
 614 XMLParserContext::~XMLParserContext()
 615 {
 616     if (m_context-&gt;myDoc)
 617         xmlFreeDoc(m_context-&gt;myDoc);
 618     xmlFreeParserCtxt(m_context);
 619 }
 620 
 621 XMLDocumentParser::~XMLDocumentParser()
 622 {
 623     // The XMLDocumentParser will always be detached before being destroyed.
 624     ASSERT(m_currentNodeStack.isEmpty());
 625     ASSERT(!m_currentNode);
 626 
 627     // FIXME: m_pendingScript handling should be moved into XMLDocumentParser.cpp!
 628     if (m_pendingScript)
 629         m_pendingScript-&gt;clearClient();
 630 }
 631 
 632 void XMLDocumentParser::doWrite(const String&amp; parseString)
 633 {
 634     ASSERT(!isDetached());
 635     if (!m_context)
 636         initializeParserContext();
 637 
 638     // Protect the libxml context from deletion during a callback
 639     RefPtr&lt;XMLParserContext&gt; context = m_context;
 640 
 641     // libXML throws an error if you try to switch the encoding for an empty string.
 642     if (parseString.length()) {
 643         // JavaScript may cause the parser to detach during xmlParseChunk
 644         // keep this alive until this function is done.
 645         Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
 646 
 647         XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
 648 
 649         // FIXME: Can we parse 8-bit strings directly as Latin-1 instead of upconverting to UTF-16?
 650         switchToUTF16(context-&gt;context());
 651         xmlParseChunk(context-&gt;context(), reinterpret_cast&lt;const char*&gt;(StringView(parseString).upconvertedCharacters().get()), sizeof(UChar) * parseString.length(), 0);
 652 
 653         // JavaScript (which may be run under the xmlParseChunk callstack) may
 654         // cause the parser to be stopped or detached.
 655         if (isStopped())
 656             return;
 657     }
 658 
 659     // FIXME: Why is this here?  And why is it after we process the passed source?
 660     if (document()-&gt;decoder() &amp;&amp; document()-&gt;decoder()-&gt;sawError()) {
 661         // If the decoder saw an error, report it as fatal (stops parsing)
 662         TextPosition position(OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;line), OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;col));
 663         handleError(XMLErrors::fatal, &quot;Encoding error&quot;, position);
 664     }
 665 }
 666 
 667 static inline String toString(const xmlChar* string, size_t size)
 668 {
 669     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);
 670 }
 671 
 672 static inline String toString(const xmlChar* string)
 673 {
 674     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));
 675 }
 676 
<a name="12" id="anc12"></a><span class="line-modified"> 677 static inline AtomString toAtomString(const xmlChar* string, size_t size)</span>
 678 {
<a name="13" id="anc13"></a><span class="line-modified"> 679     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);</span>
 680 }
 681 
<a name="14" id="anc14"></a><span class="line-modified"> 682 static inline AtomString toAtomString(const xmlChar* string)</span>
 683 {
<a name="15" id="anc15"></a><span class="line-modified"> 684     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));</span>
 685 }
 686 
 687 struct _xmlSAX2Namespace {
 688     const xmlChar* prefix;
 689     const xmlChar* uri;
 690 };
 691 typedef struct _xmlSAX2Namespace xmlSAX2Namespace;
 692 
 693 static inline bool handleNamespaceAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlNamespaces, int numNamespaces)
 694 {
 695     xmlSAX2Namespace* namespaces = reinterpret_cast&lt;xmlSAX2Namespace*&gt;(libxmlNamespaces);
 696     for (int i = 0; i &lt; numNamespaces; i++) {
<a name="16" id="anc16"></a><span class="line-modified"> 697         AtomString namespaceQName = xmlnsAtom();</span>
<span class="line-modified"> 698         AtomString namespaceURI = toAtomString(namespaces[i].uri);</span>
 699         if (namespaces[i].prefix)
 700             namespaceQName = &quot;xmlns:&quot; + toString(namespaces[i].prefix);
 701 
 702         auto result = Element::parseAttributeName(XMLNSNames::xmlnsNamespaceURI, namespaceQName);
 703         if (result.hasException())
 704             return false;
 705 
 706         prefixedAttributes.append(Attribute(result.releaseReturnValue(), namespaceURI));
 707     }
 708     return true;
 709 }
 710 
 711 struct _xmlSAX2Attributes {
 712     const xmlChar* localname;
 713     const xmlChar* prefix;
 714     const xmlChar* uri;
 715     const xmlChar* value;
 716     const xmlChar* end;
 717 };
 718 typedef struct _xmlSAX2Attributes xmlSAX2Attributes;
 719 
 720 static inline bool handleElementAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlAttributes, int numAttributes)
 721 {
 722     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
 723     for (int i = 0; i &lt; numAttributes; i++) {
 724         int valueLength = static_cast&lt;int&gt;(attributes[i].end - attributes[i].value);
<a name="17" id="anc17"></a><span class="line-modified"> 725         AtomString attrValue = toAtomString(attributes[i].value, valueLength);</span>
 726         String attrPrefix = toString(attributes[i].prefix);
<a name="18" id="anc18"></a><span class="line-modified"> 727         AtomString attrURI = attrPrefix.isEmpty() ? nullAtom() : toAtomString(attributes[i].uri);</span>
<span class="line-modified"> 728         AtomString attrQName = attrPrefix.isEmpty() ? toAtomString(attributes[i].localname) : attrPrefix + &quot;:&quot; + toString(attributes[i].localname);</span>
 729 
 730         auto result = Element::parseAttributeName(attrURI, attrQName);
 731         if (result.hasException())
 732             return false;
 733 
 734         prefixedAttributes.append(Attribute(result.releaseReturnValue(), attrValue));
 735     }
 736     return true;
 737 }
 738 
 739 // This is a hack around https://bugzilla.gnome.org/show_bug.cgi?id=502960
 740 // Otherwise libxml doesn&#39;t include namespace for parsed entities, breaking entity
 741 // expansion for all entities containing elements.
 742 static inline bool hackAroundLibXMLEntityParsingBug()
 743 {
 744 #if LIBXML_VERSION &gt;= 20704
 745     // This bug has been fixed in libxml 2.7.4.
 746     return false;
 747 #else
 748     return true;
 749 #endif
 750 }
 751 
 752 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 753 {
 754     if (isStopped())
 755         return;
 756 
 757     if (m_parserPaused) {
 758         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 759         return;
 760     }
 761 
 762     if (!updateLeafTextNode())
 763         return;
 764 
<a name="19" id="anc19"></a><span class="line-modified"> 765     AtomString localName = toAtomString(xmlLocalName);</span>
<span class="line-modified"> 766     AtomString uri = toAtomString(xmlURI);</span>
<span class="line-modified"> 767     AtomString prefix = toAtomString(xmlPrefix);</span>
 768 
 769     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 770         if (!prefix.isNull())
 771             uri = m_prefixToNamespaceMap.get(prefix);
 772         else
 773             uri = m_defaultNamespaceURI;
 774     }
 775 
 776     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 777     // if we&#39;re currently expanding elements which originate from an entity declaration.
 778     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 779         uri = m_currentNode-&gt;namespaceURI();
 780 
 781     bool isFirstElement = !m_sawFirstElement;
 782     m_sawFirstElement = true;
 783 
 784     QualifiedName qName(prefix, localName, uri);
 785     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 786 
 787     Vector&lt;Attribute&gt; prefixedAttributes;
 788     if (!handleNamespaceAttributes(prefixedAttributes, libxmlNamespaces, numNamespaces)) {
 789         setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 790         stopParsing();
 791         return;
 792     }
 793 
 794     bool success = handleElementAttributes(prefixedAttributes, libxmlAttributes, numAttributes);
 795     setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 796     if (!success) {
 797         stopParsing();
 798         return;
 799     }
 800 
 801     newElement-&gt;beginParsingChildren();
 802 
 803     if (isScriptElement(newElement.get()))
 804         m_scriptStartPosition = textPosition();
 805 
 806     m_currentNode-&gt;parserAppendChild(newElement);
 807     if (!m_currentNode) // Synchronous DOM events may have removed the current node.
 808         return;
 809 
 810     if (is&lt;HTMLTemplateElement&gt;(newElement))
 811         pushCurrentNode(&amp;downcast&lt;HTMLTemplateElement&gt;(newElement.get()).content());
 812     else
 813         pushCurrentNode(newElement.ptr());
 814 
 815     if (is&lt;HTMLHtmlElement&gt;(newElement))
 816         downcast&lt;HTMLHtmlElement&gt;(newElement.get()).insertedByParser();
 817 
 818     if (!m_parsingFragment &amp;&amp; isFirstElement &amp;&amp; document()-&gt;frame())
 819         document()-&gt;frame()-&gt;injectUserScripts(InjectAtDocumentStart);
 820 }
 821 
 822 void XMLDocumentParser::endElementNs()
 823 {
 824     if (isStopped())
 825         return;
 826 
 827     if (m_parserPaused) {
 828         m_pendingCallbacks-&gt;appendEndElementNSCallback();
 829         return;
 830     }
 831 
 832     // JavaScript can detach the parser.  Make sure this is not released
 833     // before the end of this method.
 834     Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
 835 
 836     if (!updateLeafTextNode())
 837         return;
 838 
 839     RefPtr&lt;ContainerNode&gt; node = m_currentNode;
 840     node-&gt;finishParsingChildren();
 841 
 842     // Once we reach the depth again where entity expansion started, stop executing the work-around.
 843     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; context()-&gt;depth &lt;= depthTriggeringEntityExpansion())
 844         setDepthTriggeringEntityExpansion(-1);
 845 
 846     if (!scriptingContentIsAllowed(parserContentPolicy()) &amp;&amp; is&lt;Element&gt;(*node) &amp;&amp; isScriptElement(downcast&lt;Element&gt;(*node))) {
 847         popCurrentNode();
 848         node-&gt;remove();
 849         return;
 850     }
 851 
 852     if (!node-&gt;isElementNode() || !m_view) {
 853         popCurrentNode();
 854         return;
 855     }
 856 
 857     auto&amp; element = downcast&lt;Element&gt;(*node);
 858 
 859     // The element&#39;s parent may have already been removed from document.
 860     // Parsing continues in this case, but scripts aren&#39;t executed.
 861     if (!element.isConnected()) {
 862         popCurrentNode();
 863         return;
 864     }
 865 
 866     if (!isScriptElement(element)) {
 867         popCurrentNode();
 868         return;
 869     }
 870 
 871     // Don&#39;t load external scripts for standalone documents (for now).
 872     ASSERT(!m_pendingScript);
 873     m_requestingScript = true;
 874 
 875     auto&amp; scriptElement = downcastScriptElement(element);
 876     if (scriptElement.prepareScript(m_scriptStartPosition, ScriptElement::AllowLegacyTypeInTypeAttribute)) {
 877         // FIXME: Script execution should be shared between
 878         // the libxml2 and Qt XMLDocumentParser implementations.
 879 
 880         if (scriptElement.readyToBeParserExecuted())
 881             scriptElement.executeClassicScript(ScriptSourceCode(scriptElement.scriptContent(), URL(document()-&gt;url()), m_scriptStartPosition, JSC::SourceProviderSourceType::Program, InlineClassicScript::create(scriptElement)));
 882         else if (scriptElement.willBeParserExecuted() &amp;&amp; scriptElement.loadableScript()) {
 883             m_pendingScript = PendingScript::create(scriptElement, *scriptElement.loadableScript());
 884             m_pendingScript-&gt;setClient(*this);
 885 
 886             // m_pendingScript will be nullptr if script was already loaded and setClient() executed it.
 887             if (m_pendingScript)
 888                 pauseParsing();
 889         }
 890 
 891         // JavaScript may have detached the parser
 892         if (isDetached())
 893             return;
 894     }
 895     m_requestingScript = false;
 896     popCurrentNode();
 897 }
 898 
 899 void XMLDocumentParser::characters(const xmlChar* characters, int length)
 900 {
 901     if (isStopped())
 902         return;
 903 
 904     if (m_parserPaused) {
 905         m_pendingCallbacks-&gt;appendCharactersCallback(characters, length);
 906         return;
 907     }
 908 
 909     if (!m_leafTextNode)
 910         createLeafTextNode();
 911     m_bufferedText.append(characters, length);
 912 }
 913 
 914 void XMLDocumentParser::error(XMLErrors::ErrorType type, const char* message, va_list args)
 915 {
 916     if (isStopped())
 917         return;
 918 
 919     va_list preflightArgs;
 920     va_copy(preflightArgs, args);
 921     size_t stringLength = vsnprintf(nullptr, 0, message, preflightArgs);
 922     va_end(preflightArgs);
 923 
 924     Vector&lt;char, 1024&gt; buffer(stringLength + 1);
 925     vsnprintf(buffer.data(), stringLength + 1, message, args);
 926 
 927     TextPosition position = textPosition();
 928     if (m_parserPaused)
 929         m_pendingCallbacks-&gt;appendErrorCallback(type, reinterpret_cast&lt;const xmlChar*&gt;(buffer.data()), position.m_line, position.m_column);
 930     else
 931         handleError(type, buffer.data(), textPosition());
 932 }
 933 
 934 void XMLDocumentParser::processingInstruction(const xmlChar* target, const xmlChar* data)
 935 {
 936     if (isStopped())
 937         return;
 938 
 939     if (m_parserPaused) {
 940         m_pendingCallbacks-&gt;appendProcessingInstructionCallback(target, data);
 941         return;
 942     }
 943 
 944     if (!updateLeafTextNode())
 945         return;
 946 
 947     auto result = m_currentNode-&gt;document().createProcessingInstruction(toString(target), toString(data));
 948     if (result.hasException())
 949         return;
 950     auto pi = result.releaseReturnValue();
 951 
 952     pi-&gt;setCreatedByParser(true);
 953 
 954     m_currentNode-&gt;parserAppendChild(pi);
 955 
 956     pi-&gt;finishParsingChildren();
 957 
 958     if (pi-&gt;isCSS())
 959         m_sawCSS = true;
 960 
 961 #if ENABLE(XSLT)
 962     m_sawXSLTransform = !m_sawFirstElement &amp;&amp; pi-&gt;isXSL();
 963     if (m_sawXSLTransform &amp;&amp; !document()-&gt;transformSourceDocument())
 964         stopParsing();
 965 #endif
 966 }
 967 
 968 void XMLDocumentParser::cdataBlock(const xmlChar* s, int len)
 969 {
 970     if (isStopped())
 971         return;
 972 
 973     if (m_parserPaused) {
 974         m_pendingCallbacks-&gt;appendCDATABlockCallback(s, len);
 975         return;
 976     }
 977 
 978     if (!updateLeafTextNode())
 979         return;
 980 
 981     m_currentNode-&gt;parserAppendChild(CDATASection::create(m_currentNode-&gt;document(), toString(s, len)));
 982 }
 983 
 984 void XMLDocumentParser::comment(const xmlChar* s)
 985 {
 986     if (isStopped())
 987         return;
 988 
 989     if (m_parserPaused) {
 990         m_pendingCallbacks-&gt;appendCommentCallback(s);
 991         return;
 992     }
 993 
 994     if (!updateLeafTextNode())
 995         return;
 996 
 997     m_currentNode-&gt;parserAppendChild(Comment::create(m_currentNode-&gt;document(), toString(s)));
 998 }
 999 
1000 enum StandaloneInfo {
1001     StandaloneUnspecified = -2,
1002     NoXMlDeclaration,
1003     StandaloneNo,
1004     StandaloneYes
1005 };
1006 
1007 void XMLDocumentParser::startDocument(const xmlChar* version, const xmlChar* encoding, int standalone)
1008 {
1009     StandaloneInfo standaloneInfo = (StandaloneInfo)standalone;
1010     if (standaloneInfo == NoXMlDeclaration) {
1011         document()-&gt;setHasXMLDeclaration(false);
1012         return;
1013     }
1014 
1015     if (version)
1016         document()-&gt;setXMLVersion(toString(version));
1017     if (standalone != StandaloneUnspecified)
1018         document()-&gt;setXMLStandalone(standaloneInfo == StandaloneYes);
1019     if (encoding)
1020         document()-&gt;setXMLEncoding(toString(encoding));
1021     document()-&gt;setHasXMLDeclaration(true);
1022 }
1023 
1024 void XMLDocumentParser::endDocument()
1025 {
1026     updateLeafTextNode();
1027 }
1028 
1029 void XMLDocumentParser::internalSubset(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
1030 {
1031     if (isStopped())
1032         return;
1033 
1034     if (m_parserPaused) {
1035         m_pendingCallbacks-&gt;appendInternalSubsetCallback(name, externalID, systemID);
1036         return;
1037     }
1038 
1039     if (document())
1040         document()-&gt;parserAppendChild(DocumentType::create(*document(), toString(name), toString(externalID), toString(systemID)));
1041 }
1042 
1043 static inline XMLDocumentParser* getParser(void* closure)
1044 {
1045     xmlParserCtxtPtr ctxt = static_cast&lt;xmlParserCtxtPtr&gt;(closure);
1046     return static_cast&lt;XMLDocumentParser*&gt;(ctxt-&gt;_private);
1047 }
1048 
1049 // This is a hack around http://bugzilla.gnome.org/show_bug.cgi?id=159219
1050 // Otherwise libxml seems to call all the SAX callbacks twice for any replaced entity.
1051 static inline bool hackAroundLibXMLEntityBug(void* closure)
1052 {
1053 #if LIBXML_VERSION &gt;= 20627
1054     // This bug has been fixed in libxml 2.6.27.
1055     UNUSED_PARAM(closure);
1056     return false;
1057 #else
1058     return static_cast&lt;xmlParserCtxtPtr&gt;(closure)-&gt;node;
1059 #endif
1060 }
1061 
1062 static void startElementNsHandler(void* closure, const xmlChar* localname, const xmlChar* prefix, const xmlChar* uri, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
1063 {
1064     if (hackAroundLibXMLEntityBug(closure))
1065         return;
1066 
1067     getParser(closure)-&gt;startElementNs(localname, prefix, uri, numNamespaces, namespaces, numAttributes, numDefaulted, libxmlAttributes);
1068 }
1069 
1070 static void endElementNsHandler(void* closure, const xmlChar*, const xmlChar*, const xmlChar*)
1071 {
1072     if (hackAroundLibXMLEntityBug(closure))
1073         return;
1074 
1075     getParser(closure)-&gt;endElementNs();
1076 }
1077 
1078 static void charactersHandler(void* closure, const xmlChar* s, int len)
1079 {
1080     if (hackAroundLibXMLEntityBug(closure))
1081         return;
1082 
1083     getParser(closure)-&gt;characters(s, len);
1084 }
1085 
1086 static void processingInstructionHandler(void* closure, const xmlChar* target, const xmlChar* data)
1087 {
1088     if (hackAroundLibXMLEntityBug(closure))
1089         return;
1090 
1091     getParser(closure)-&gt;processingInstruction(target, data);
1092 }
1093 
1094 static void cdataBlockHandler(void* closure, const xmlChar* s, int len)
1095 {
1096     if (hackAroundLibXMLEntityBug(closure))
1097         return;
1098 
1099     getParser(closure)-&gt;cdataBlock(s, len);
1100 }
1101 
1102 static void commentHandler(void* closure, const xmlChar* comment)
1103 {
1104     if (hackAroundLibXMLEntityBug(closure))
1105         return;
1106 
1107     getParser(closure)-&gt;comment(comment);
1108 }
1109 
1110 WTF_ATTRIBUTE_PRINTF(2, 3)
1111 static void warningHandler(void* closure, const char* message, ...)
1112 {
1113     va_list args;
1114     va_start(args, message);
1115     getParser(closure)-&gt;error(XMLErrors::warning, message, args);
1116     va_end(args);
1117 }
1118 
1119 WTF_ATTRIBUTE_PRINTF(2, 3)
1120 static void fatalErrorHandler(void* closure, const char* message, ...)
1121 {
1122     va_list args;
1123     va_start(args, message);
1124     getParser(closure)-&gt;error(XMLErrors::fatal, message, args);
1125     va_end(args);
1126 }
1127 
1128 WTF_ATTRIBUTE_PRINTF(2, 3)
1129 static void normalErrorHandler(void* closure, const char* message, ...)
1130 {
1131     va_list args;
1132     va_start(args, message);
1133     getParser(closure)-&gt;error(XMLErrors::nonFatal, message, args);
1134     va_end(args);
1135 }
1136 
1137 // Using a static entity and marking it XML_INTERNAL_PREDEFINED_ENTITY is
1138 // a hack to avoid malloc/free. Using a global variable like this could cause trouble
1139 // if libxml implementation details were to change
1140 static xmlChar sharedXHTMLEntityResult[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
1141 
1142 static xmlEntityPtr sharedXHTMLEntity()
1143 {
1144     static xmlEntity entity;
1145     if (!entity.type) {
1146         entity.type = XML_ENTITY_DECL;
1147         entity.orig = sharedXHTMLEntityResult;
1148         entity.content = sharedXHTMLEntityResult;
1149         entity.etype = XML_INTERNAL_PREDEFINED_ENTITY;
1150     }
1151     return &amp;entity;
1152 }
1153 
1154 static size_t convertUTF16EntityToUTF8(const UChar* utf16Entity, size_t numberOfCodeUnits, char* target, size_t targetSize)
1155 {
1156     const char* originalTarget = target;
1157     auto conversionResult = WTF::Unicode::convertUTF16ToUTF8(&amp;utf16Entity, utf16Entity + numberOfCodeUnits, &amp;target, target + targetSize);
<a name="20" id="anc20"></a><span class="line-modified">1158     if (conversionResult != WTF::Unicode::ConversionOK)</span>
1159         return 0;
1160 
1161     // Even though we must pass the length, libxml expects the entity string to be null terminated.
1162     ASSERT(target &gt;= originalTarget + 1);
1163     *target = &#39;\0&#39;;
1164     return target - originalTarget;
1165 }
1166 
1167 static xmlEntityPtr getXHTMLEntity(const xmlChar* name)
1168 {
1169     UChar utf16DecodedEntity[4];
1170     size_t numberOfCodeUnits = decodeNamedEntityToUCharArray(reinterpret_cast&lt;const char*&gt;(name), utf16DecodedEntity);
1171     if (!numberOfCodeUnits)
1172         return 0;
1173 
1174     ASSERT(numberOfCodeUnits &lt;= 4);
1175     size_t entityLengthInUTF8 = convertUTF16EntityToUTF8(utf16DecodedEntity, numberOfCodeUnits,
1176         reinterpret_cast&lt;char*&gt;(sharedXHTMLEntityResult), WTF_ARRAY_LENGTH(sharedXHTMLEntityResult));
1177     if (!entityLengthInUTF8)
1178         return 0;
1179 
1180     xmlEntityPtr entity = sharedXHTMLEntity();
1181     entity-&gt;length = entityLengthInUTF8;
1182     entity-&gt;name = name;
1183     return entity;
1184 }
1185 
1186 static void entityDeclarationHandler(void* closure, const xmlChar* name, int type, const xmlChar* publicId, const xmlChar* systemId, xmlChar* content)
1187 {
1188     // Prevent the next call to getEntityHandler() to record the entity expansion depth.
1189     // We&#39;re parsing the entity declaration, so there&#39;s no need to record anything.
1190     // We only need to record the depth, if we&#39;re actually expanding the entity, when it&#39;s referenced.
1191     if (hackAroundLibXMLEntityParsingBug())
1192         getParser(closure)-&gt;setIsParsingEntityDeclaration(true);
1193     xmlSAX2EntityDecl(closure, name, type, publicId, systemId, content);
1194 }
1195 
1196 static xmlEntityPtr getEntityHandler(void* closure, const xmlChar* name)
1197 {
1198     xmlParserCtxtPtr ctxt = static_cast&lt;xmlParserCtxtPtr&gt;(closure);
1199 
1200     XMLDocumentParser* parser = getParser(closure);
1201     if (hackAroundLibXMLEntityParsingBug()) {
1202         if (parser-&gt;isParsingEntityDeclaration()) {
1203             // We&#39;re parsing the entity declarations (not an entity reference), no need to do anything special.
1204             parser-&gt;setIsParsingEntityDeclaration(false);
1205             ASSERT(parser-&gt;depthTriggeringEntityExpansion() == -1);
1206         } else {
1207             // The entity will be used and eventually expanded. Record the current parser depth
1208             // so the next call to startElementNs() knows that the new element originates from
1209             // an entity declaration.
1210             parser-&gt;setDepthTriggeringEntityExpansion(ctxt-&gt;depth);
1211         }
1212     }
1213 
1214     xmlEntityPtr ent = xmlGetPredefinedEntity(name);
1215     if (ent) {
1216         ent-&gt;etype = XML_INTERNAL_PREDEFINED_ENTITY;
1217         return ent;
1218     }
1219 
1220     ent = xmlGetDocEntity(ctxt-&gt;myDoc, name);
1221     if (!ent &amp;&amp; parser-&gt;isXHTMLDocument()) {
1222         ent = getXHTMLEntity(name);
1223         if (ent)
1224             ent-&gt;etype = XML_INTERNAL_GENERAL_ENTITY;
1225     }
1226 
1227     return ent;
1228 }
1229 
1230 static void startDocumentHandler(void* closure)
1231 {
1232     xmlParserCtxt* ctxt = static_cast&lt;xmlParserCtxt*&gt;(closure);
1233     switchToUTF16(ctxt);
1234     getParser(closure)-&gt;startDocument(ctxt-&gt;version, ctxt-&gt;encoding, ctxt-&gt;standalone);
1235     xmlSAX2StartDocument(closure);
1236 }
1237 
1238 static void endDocumentHandler(void* closure)
1239 {
1240     getParser(closure)-&gt;endDocument();
1241     xmlSAX2EndDocument(closure);
1242 }
1243 
1244 static void internalSubsetHandler(void* closure, const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
1245 {
1246     getParser(closure)-&gt;internalSubset(name, externalID, systemID);
1247     xmlSAX2InternalSubset(closure, name, externalID, systemID);
1248 }
1249 
1250 static void externalSubsetHandler(void* closure, const xmlChar*, const xmlChar* externalId, const xmlChar*)
1251 {
1252     String extId = toString(externalId);
1253     if ((extId == &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;)
1254         || (extId == &quot;-//W3C//DTD XHTML 1.1//EN&quot;)
1255         || (extId == &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;)
1256         || (extId == &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;)
1257         || (extId == &quot;-//W3C//DTD XHTML Basic 1.0//EN&quot;)
1258         || (extId == &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN&quot;)
1259         || (extId == &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN&quot;)
1260         || (extId == &quot;-//W3C//DTD MathML 2.0//EN&quot;)
1261         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.0//EN&quot;)
1262         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.1//EN&quot;)
1263         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.2//EN&quot;))
1264         getParser(closure)-&gt;setIsXHTMLDocument(true); // controls if we replace entities or not.
1265 }
1266 
1267 static void ignorableWhitespaceHandler(void*, const xmlChar*, int)
1268 {
1269     // nothing to do, but we need this to work around a crasher
1270     // http://bugzilla.gnome.org/show_bug.cgi?id=172255
1271     // http://bugs.webkit.org/show_bug.cgi?id=5792
1272 }
1273 
1274 void XMLDocumentParser::initializeParserContext(const CString&amp; chunk)
1275 {
1276     xmlSAXHandler sax;
1277     memset(&amp;sax, 0, sizeof(sax));
1278 
1279     sax.error = normalErrorHandler;
1280     sax.fatalError = fatalErrorHandler;
1281     sax.characters = charactersHandler;
1282     sax.processingInstruction = processingInstructionHandler;
1283     sax.cdataBlock = cdataBlockHandler;
1284     sax.comment = commentHandler;
1285     sax.warning = warningHandler;
1286     sax.startElementNs = startElementNsHandler;
1287     sax.endElementNs = endElementNsHandler;
1288     sax.getEntity = getEntityHandler;
1289     sax.startDocument = startDocumentHandler;
1290     sax.endDocument = endDocumentHandler;
1291     sax.internalSubset = internalSubsetHandler;
1292     sax.externalSubset = externalSubsetHandler;
1293     sax.ignorableWhitespace = ignorableWhitespaceHandler;
1294     sax.entityDecl = entityDeclarationHandler;
1295     sax.initialized = XML_SAX2_MAGIC;
1296     DocumentParser::startParsing();
1297     m_sawError = false;
1298     m_sawCSS = false;
1299     m_sawXSLTransform = false;
1300     m_sawFirstElement = false;
1301 
1302     XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1303     if (m_parsingFragment)
1304         m_context = XMLParserContext::createMemoryParser(&amp;sax, this, chunk);
1305     else {
1306         ASSERT(!chunk.data());
1307         m_context = XMLParserContext::createStringParser(&amp;sax, this);
1308     }
1309 }
1310 
1311 void XMLDocumentParser::doEnd()
1312 {
1313     if (!isStopped()) {
1314         if (m_context) {
1315             // Tell libxml we&#39;re done.
1316             {
1317                 XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1318                 xmlParseChunk(context(), 0, 0, 1);
1319             }
1320 
1321             m_context = nullptr;
1322         }
1323     }
1324 
1325 #if ENABLE(XSLT)
1326     bool xmlViewerMode = !m_sawError &amp;&amp; !m_sawCSS &amp;&amp; !m_sawXSLTransform &amp;&amp; shouldRenderInXMLTreeViewerMode(*document());
1327     if (xmlViewerMode) {
1328         XMLTreeViewer xmlTreeViewer(*document());
1329         xmlTreeViewer.transformDocumentToTreeView();
1330     } else if (m_sawXSLTransform) {
1331         xmlDocPtr doc = xmlDocPtrForString(document()-&gt;cachedResourceLoader(), m_originalSourceForTransform.toString(), document()-&gt;url().string());
<a name="21" id="anc21"></a><span class="line-modified">1332         document()-&gt;setTransformSource(makeUnique&lt;TransformSource&gt;(doc));</span>
1333 
1334         document()-&gt;setParsing(false); // Make the document think it&#39;s done, so it will apply XSL stylesheets.
1335         document()-&gt;applyPendingXSLTransformsNowIfScheduled();
1336 
1337         // styleResolverChanged() call can detach the parser and null out its document.
1338         // In that case, we just bail out.
1339         if (isDetached())
1340             return;
1341 
1342         document()-&gt;setParsing(true);
1343         DocumentParser::stopParsing();
1344     }
1345 #endif
1346 }
1347 
1348 #if ENABLE(XSLT)
1349 static inline const char* nativeEndianUTF16Encoding()
1350 {
1351     const UChar BOM = 0xFEFF;
1352     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
1353     return BOMHighByte == 0xFF ? &quot;UTF-16LE&quot; : &quot;UTF-16BE&quot;;
1354 }
1355 
1356 xmlDocPtr xmlDocPtrForString(CachedResourceLoader&amp; cachedResourceLoader, const String&amp; source, const String&amp; url)
1357 {
1358     if (source.isEmpty())
1359         return nullptr;
1360 
1361     // Parse in a single chunk into an xmlDocPtr
1362     // FIXME: Hook up error handlers so that a failure to parse the main document results in
1363     // good error messages.
1364 
1365     const bool is8Bit = source.is8Bit();
1366     const char* characters = is8Bit ? reinterpret_cast&lt;const char*&gt;(source.characters8()) : reinterpret_cast&lt;const char*&gt;(source.characters16());
1367     size_t sizeInBytes = source.length() * (is8Bit ? sizeof(LChar) : sizeof(UChar));
1368     const char* encoding = is8Bit ? &quot;iso-8859-1&quot; : nativeEndianUTF16Encoding();
1369 
1370     XMLDocumentParserScope scope(&amp;cachedResourceLoader, errorFunc);
1371     return xmlReadMemory(characters, sizeInBytes, url.latin1().data(), encoding, XSLT_PARSE_OPTIONS);
1372 }
1373 #endif
1374 
1375 TextPosition XMLDocumentParser::textPosition() const
1376 {
1377     xmlParserCtxtPtr context = this-&gt;context();
1378     if (!context)
1379         return TextPosition();
1380     return TextPosition(OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;line),
1381                         OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;col));
1382 }
1383 
1384 bool XMLDocumentParser::shouldAssociateConsoleMessagesWithTextPosition() const
1385 {
1386     return !m_parserPaused &amp;&amp; !m_requestingScript;
1387 }
1388 
1389 void XMLDocumentParser::stopParsing()
1390 {
<a name="22" id="anc22"></a><span class="line-added">1391     if (m_sawError)</span>
<span class="line-added">1392         insertErrorMessageBlock();</span>
<span class="line-added">1393 </span>
1394     DocumentParser::stopParsing();
1395     if (context())
1396         xmlStopParser(context());
1397 }
1398 
1399 void XMLDocumentParser::resumeParsing()
1400 {
1401     ASSERT(!isDetached());
1402     ASSERT(m_parserPaused);
1403 
1404     m_parserPaused = false;
1405 
1406     // First, execute any pending callbacks
1407     while (!m_pendingCallbacks-&gt;isEmpty()) {
1408         m_pendingCallbacks-&gt;callAndRemoveFirstCallback(this);
1409 
1410         // A callback paused the parser
1411         if (m_parserPaused)
1412             return;
1413     }
1414 
1415     // There is normally only one string left, so toString() shouldn&#39;t copy.
1416     // In any case, the XML parser runs on the main thread and it&#39;s OK if
1417     // the passed string has more than one reference.
1418     auto rest = m_pendingSrc.toString();
1419     m_pendingSrc.clear();
1420     append(rest.impl());
1421 
1422     // Finally, if finish() has been called and write() didn&#39;t result
1423     // in any further callbacks being queued, call end()
1424     if (m_finishCalled &amp;&amp; m_pendingCallbacks-&gt;isEmpty())
1425         end();
1426 }
1427 
1428 bool XMLDocumentParser::appendFragmentSource(const String&amp; chunk)
1429 {
1430     ASSERT(!m_context);
1431     ASSERT(m_parsingFragment);
1432 
1433     CString chunkAsUtf8 = chunk.utf8();
1434 
1435     // libxml2 takes an int for a length, and therefore can&#39;t handle XML chunks larger than 2 GiB.
1436     if (chunkAsUtf8.length() &gt; INT_MAX)
1437         return false;
1438 
1439     initializeParserContext(chunkAsUtf8);
1440     xmlParseContent(context());
1441     endDocument(); // Close any open text nodes.
1442 
1443     // FIXME: If this code is actually needed, it should probably move to finish()
1444     // XMLDocumentParserQt has a similar check (m_stream.error() == QXmlStreamReader::PrematureEndOfDocumentError) in doEnd().
1445     // Check if all the chunk has been processed.
1446     long bytesProcessed = xmlByteConsumed(context());
1447     if (bytesProcessed == -1 || ((unsigned long)bytesProcessed) != chunkAsUtf8.length()) {
1448         // FIXME: I don&#39;t believe we can hit this case without also having seen an error or a null byte.
1449         // If we hit this ASSERT, we&#39;ve found a test case which demonstrates the need for this code.
1450         ASSERT(m_sawError || (bytesProcessed &gt;= 0 &amp;&amp; !chunkAsUtf8.data()[bytesProcessed]));
1451         return false;
1452     }
1453 
1454     // No error if the chunk is well formed or it is not but we have no error.
1455     return context()-&gt;wellFormed || !xmlCtxtGetLastError(context());
1456 }
1457 
1458 // --------------------------------
1459 
1460 using AttributeParseState = Optional&lt;HashMap&lt;String, String&gt;&gt;;
1461 
1462 static void attributesStartElementNsHandler(void* closure, const xmlChar* xmlLocalName, const xmlChar* /*xmlPrefix*/, const xmlChar* /*xmlURI*/, int /*numNamespaces*/, const xmlChar** /*namespaces*/, int numAttributes, int /*numDefaulted*/, const xmlChar** libxmlAttributes)
1463 {
1464     if (strcmp(reinterpret_cast&lt;const char*&gt;(xmlLocalName), &quot;attrs&quot;) != 0)
1465         return;
1466 
1467     auto&amp; state = *static_cast&lt;AttributeParseState*&gt;(static_cast&lt;xmlParserCtxtPtr&gt;(closure)-&gt;_private);
1468 
1469     state = HashMap&lt;String, String&gt; { };
1470 
1471     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
1472     for (int i = 0; i &lt; numAttributes; i++) {
1473         String attrLocalName = toString(attributes[i].localname);
1474         int valueLength = (int) (attributes[i].end - attributes[i].value);
1475         String attrValue = toString(attributes[i].value, valueLength);
1476         String attrPrefix = toString(attributes[i].prefix);
1477         String attrQName = attrPrefix.isEmpty() ? attrLocalName : attrPrefix + &quot;:&quot; + attrLocalName;
1478 
1479         state-&gt;set(attrQName, attrValue);
1480     }
1481 }
1482 
1483 Optional&lt;HashMap&lt;String, String&gt;&gt; parseAttributes(const String&amp; string)
1484 {
1485     String parseString = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;attrs &quot; + string + &quot; /&gt;&quot;;
1486 
1487     AttributeParseState attributes;
1488 
1489     xmlSAXHandler sax;
1490     memset(&amp;sax, 0, sizeof(sax));
1491     sax.startElementNs = attributesStartElementNsHandler;
1492     sax.initialized = XML_SAX2_MAGIC;
1493 
1494     auto parser = XMLParserContext::createStringParser(&amp;sax, &amp;attributes);
1495 
1496     // FIXME: Can we parse 8-bit strings directly as Latin-1 instead of upconverting to UTF-16?
1497     xmlParseChunk(parser-&gt;context(), reinterpret_cast&lt;const char*&gt;(StringView(parseString).upconvertedCharacters().get()), parseString.length() * sizeof(UChar), 1);
1498 
1499     return attributes;
1500 }
1501 
1502 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>