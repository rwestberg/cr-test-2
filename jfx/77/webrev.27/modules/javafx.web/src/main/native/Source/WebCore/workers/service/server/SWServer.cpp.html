<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServer.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExceptionCode.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;RegistrationStore.h&quot;
 35 #include &quot;SWOriginStore.h&quot;
 36 #include &quot;SWServerJobQueue.h&quot;
 37 #include &quot;SWServerRegistration.h&quot;
 38 #include &quot;SWServerToContextConnection.h&quot;
 39 #include &quot;SWServerWorker.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;ServiceWorkerClientType.h&quot;
 42 #include &quot;ServiceWorkerContextData.h&quot;
 43 #include &quot;ServiceWorkerFetchResult.h&quot;
 44 #include &quot;ServiceWorkerJobData.h&quot;
 45 #include &lt;wtf/CompletionHandler.h&gt;
 46 #include &lt;wtf/NeverDestroyed.h&gt;
 47 #include &lt;wtf/text/WTFString.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 static Seconds terminationDelay { 10_s };
 52 
 53 SWServer::Connection::Connection(SWServer&amp; server)
 54     : m_server(server)
 55     , m_identifier(SWServerConnectionIdentifier::generate())
 56 {
 57 }
 58 
 59 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
 60 {
 61     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
 62     return servers;
 63 }
 64 
 65 SWServer::~SWServer()
 66 {
 67     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
 68     // to the server and since they try to unregister clients from the server in their destructor.
 69     auto connections = WTFMove(m_connections);
 70     connections.clear();
 71 
 72     Vector&lt;SWServerWorker*&gt; runningWorkers;
 73     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
 74         if (worker-&gt;isRunning())
 75             runningWorkers.append(worker.ptr());
 76     }
 77     for (auto&amp; runningWorker : runningWorkers)
 78         terminateWorker(*runningWorker);
 79 
 80     allServers().remove(this);
 81 }
 82 
 83 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
 84 {
 85     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
 86     ASSERT(!worker || worker-&gt;server() == this);
 87     return worker;
 88 }
 89 
 90 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
 91 {
 92     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 93     if (iterator == m_clientIdentifiersPerOrigin.end())
 94         return WTF::nullopt;
 95 
 96     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 97         return WTF::nullopt;
 98 
 99     auto clientIterator = m_clientsById.find(clientIdentifier);
100     ASSERT(clientIterator != m_clientsById.end());
101     return clientIterator-&gt;value;
102 }
103 
104 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
105 {
106     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
107     if (iterator == m_clientIdentifiersPerOrigin.end())
108         return String();
109     return iterator-&gt;value.userAgent;
110 }
111 
112 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
113 {
114     auto* registration = m_registrationsByID.get(identifier);
115     return registration ? registration-&gt;activeWorker() : nullptr;
116 }
117 
118 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
119 {
120     return m_registrations.get(registrationKey);
121 }
122 
123 void SWServer::registrationStoreImportComplete()
124 {
125     ASSERT(!m_importCompleted);
126     m_importCompleted = true;
127     m_originStore-&gt;importComplete();
128 
129     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
130     for (auto&amp; callback : clearCallbacks)
131         callback();
132 
133     performGetOriginsWithRegistrationsCallbacks();
134 }
135 
136 void SWServer::registrationStoreDatabaseFailedToOpen()
137 {
138     if (!m_importCompleted)
139         registrationStoreImportComplete();
140 }
141 
142 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
143 {
144     // Pages should not have been able to make a new registration to this key while the import was still taking place.
145     ASSERT(!m_registrations.contains(data.registration.key));
146 
147     auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
148     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
149     auto registrationPtr = registration.get();
150     addRegistration(WTFMove(registration));
151 
152     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, WTFMove(data.scriptResourceMap));
153     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
154     worker-&gt;setState(ServiceWorkerState::Activated);
155 }
156 
157 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
158 {
159     auto key = registration-&gt;key();
160     auto* registrationPtr = registration.get();
161     auto addResult1 = m_registrations.add(key, WTFMove(registration));
162     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
163 
164     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);
165     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);
166 
167     m_originStore-&gt;add(key.topOrigin());
168 }
169 
170 void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)
171 {
172     auto topOrigin = key.topOrigin();
173     auto registration = m_registrations.take(key);
174     ASSERT(registration);
175     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());
176     ASSERT_UNUSED(wasRemoved, wasRemoved);
177 
178     m_originStore-&gt;remove(topOrigin);
179     if (m_registrationStore)
180         m_registrationStore-&gt;removeRegistration(key);
181 }
182 
183 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
184 {
185     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
186     for (auto&amp; item : m_registrations) {
187         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))
188             matchingRegistrations.append(item.value.get());
189     }
190     // The specification mandates that registrations are returned in the insertion order.
191     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
192         return a-&gt;creationTime() &lt; b-&gt;creationTime();
193     });
194     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
195     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
196     for (auto* registration : matchingRegistrations)
197         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
198     return matchingRegistrationDatas;
199 }
200 
201 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
202 {
203     if (!m_importCompleted) {
204         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
205             ASSERT(m_importCompleted);
206             clearAll(WTFMove(completionHandler));
207         });
208         return;
209     }
210 
211     m_jobQueues.clear();
212     while (!m_registrations.isEmpty())
213         m_registrations.begin()-&gt;value-&gt;clear();
214     ASSERT(m_registrationsByID.isEmpty());
215     m_pendingContextDatas.clear();
216     m_originStore-&gt;clearAll();
217     if (m_registrationStore)
218         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
219 }
220 
221 void SWServer::startSuspension(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
222 {
223     if (!m_registrationStore) {
224         completionHandler();
225         return;
226     }
227     m_registrationStore-&gt;startSuspension(WTFMove(completionHandler));
228 }
229 
230 void SWServer::endSuspension()
231 {
232     if (m_registrationStore)
233         m_registrationStore-&gt;endSuspension();
234 }
235 
236 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
237 {
238     if (!m_importCompleted) {
239         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
240             ASSERT(m_importCompleted);
241             clear(securityOrigin, WTFMove(completionHandler));
242         });
243         return;
244     }
245 
246     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
247         return keyAndValue.key.relatesToOrigin(securityOrigin);
248     });
249 
250     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
251     for (auto&amp; keyAndValue : m_registrations) {
252         if (keyAndValue.key.relatesToOrigin(securityOrigin))
253             registrationsToRemove.append(keyAndValue.value.get());
254     }
255 
256     for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
257         contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
258             return contextData.registration.key.relatesToOrigin(securityOrigin);
259         });
260     }
261 
262     if (registrationsToRemove.isEmpty()) {
263         completionHandler();
264         return;
265     }
266 
267     // Calling SWServerRegistration::clear() takes care of updating m_registrations, m_originStore and m_registrationStore.
268     for (auto* registration : registrationsToRemove)
269         registration-&gt;clear();
270 
271     if (m_registrationStore)
272         m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
273 }
274 
275 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
276 {
277     m_server.scriptFetchFinished(*this, result);
278 }
279 
280 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
281 {
282     m_server.didResolveRegistrationPromise(*this, key);
283 }
284 
285 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
286 {
287     m_server.addClientServiceWorkerRegistration(*this, identifier);
288 }
289 
290 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
291 {
292     m_server.removeClientServiceWorkerRegistration(*this, identifier);
293 }
294 
295 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
296 {
297     if (auto* worker = m_server.workerByID(identifier))
298         m_server.syncTerminateWorker(*worker);
299 }
300 
301 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)
302     : m_originStore(WTFMove(originStore))
303     , m_sessionID(sessionID)
304 {
305     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());
306     if (!m_sessionID.isEphemeral())
307         m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
308     else
309         registrationStoreImportComplete();
310 
311     UNUSED_PARAM(registrationDatabaseDirectory);
312     allServers().add(this);
313 }
314 
315 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
316 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
317 {
318     ASSERT(m_connections.contains(jobData.connectionIdentifier()));
319 
320     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
321     // If it is, stack it along with that job.
322 
323     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
324         return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
325     }).iterator-&gt;value;
326 
327     jobQueue.enqueueJob(jobData);
328     if (jobQueue.size() == 1)
329         jobQueue.runNextJob();
330 }
331 
332 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
333 {
334     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
335     auto* connection = m_connections.get(jobData.connectionIdentifier());
336     if (!connection)
337         return;
338 
339     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
340 }
341 
342 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
343 {
344     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
345     auto* connection = m_connections.get(jobData.connectionIdentifier());
346     if (!connection)
347         return;
348 
349     connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
350 }
351 
352 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
353 {
354     auto* connection = m_connections.get(jobData.connectionIdentifier());
355     if (!connection)
356         return;
357 
358     connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
359 }
360 
361 void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, FetchOptions::Cache cachePolicy)
362 {
363     LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
364     auto* connection = m_connections.get(jobData.connectionIdentifier());
365     ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
366     if (connection)
367         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), cachePolicy);
368 }
369 
370 void SWServer::scriptFetchFinished(Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)
371 {
372     LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
373 
374     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier));
375 
376     auto jobQueue = m_jobQueues.get(result.registrationKey);
377     if (!jobQueue)
378         return;
379 
380     jobQueue-&gt;scriptFetchFinished(connection, result);
381 }
382 
383 void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
384 {
385     if (!jobDataIdentifier)
386         return;
387 
388     RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::scriptContextFailedToStart: Failed to start SW for job %s, error: %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data(), message.utf8().data());
389 
390     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
391     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
392         // The job which started this worker has been canceled, terminate this worker.
393         terminatePreinstallationWorker(worker);
394         return;
395     }
396     jobQueue-&gt;scriptContextFailedToStart(*jobDataIdentifier, worker.identifier(), message);
397 }
398 
399 void SWServer::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker)
400 {
401     if (!jobDataIdentifier)
402         return;
403 
404     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
405     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
406         // The job which started this worker has been canceled, terminate this worker.
407         terminatePreinstallationWorker(worker);
408         return;
409     }
410     jobQueue-&gt;scriptContextStarted(*jobDataIdentifier, worker.identifier());
411 }
412 
413 void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
414 {
415     worker.terminate();
416     auto* registration = getRegistration(worker.registrationKey());
417     if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
418         registration-&gt;setPreInstallationWorker(nullptr);
419 }
420 
421 void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
422 {
423     if (!jobDataIdentifier)
424         return;
425 
426     if (wasSuccessful)
427         RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
428     else
429         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
430 
431     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
432         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker.identifier(), wasSuccessful);
433 }
434 
435 void SWServer::didFinishActivation(SWServerWorker&amp; worker)
436 {
437     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
438 
439     auto* registration = getRegistration(worker.registrationKey());
440     if (!registration)
441         return;
442 
443     if (m_registrationStore)
444         m_registrationStore-&gt;updateRegistration(worker.contextData());
445     registration-&gt;didFinishActivation(worker.identifier());
446 }
447 
448 // https://w3c.github.io/ServiceWorker/#clients-getall
449 void SWServer::matchAll(SWServerWorker&amp; worker, const ServiceWorkerClientQueryOptions&amp; options, ServiceWorkerClientsMatchAllCallback&amp;&amp; callback)
450 {
451     // FIXME: Support reserved client filtering.
452     // FIXME: Support WindowClient additional properties.
453 
454     Vector&lt;ServiceWorkerClientData&gt; matchingClients;
455     forEachClientForOrigin(worker.origin(), [&amp;](auto&amp; clientData) {
456         if (!options.includeUncontrolled) {
457             auto registrationIdentifier = m_clientToControllingRegistration.get(clientData.identifier);
458             if (worker.data().registrationIdentifier != registrationIdentifier)
459                 return;
460             if (&amp;worker != this-&gt;activeWorkerFromRegistrationID(registrationIdentifier))
461                 return;
462         }
463         if (options.type != ServiceWorkerClientType::All &amp;&amp; options.type != clientData.type)
464             return;
465         matchingClients.append(clientData);
466     });
467     callback(WTFMove(matchingClients));
468 }
469 
470 void SWServer::forEachClientForOrigin(const ClientOrigin&amp; origin, const WTF::Function&lt;void(ServiceWorkerClientData&amp;)&gt;&amp; apply)
471 {
472     auto iterator = m_clientIdentifiersPerOrigin.find(origin);
473     if (iterator == m_clientIdentifiersPerOrigin.end())
474         return;
475 
476     for (auto&amp; clientIdentifier : iterator-&gt;value.identifiers) {
477         auto clientIterator = m_clientsById.find(clientIdentifier);
478         ASSERT(clientIterator != m_clientsById.end());
479         apply(clientIterator-&gt;value);
480     }
481 }
482 
483 void SWServer::claim(SWServerWorker&amp; worker)
484 {
485     auto&amp; origin = worker.origin();
486     forEachClientForOrigin(origin, [&amp;](auto&amp; clientData) {
487         auto* registration = this-&gt;doRegistrationMatching(origin.topOrigin, clientData.url);
488         if (!(registration &amp;&amp; registration-&gt;key() == worker.registrationKey()))
489             return;
490 
491         auto result = m_clientToControllingRegistration.add(clientData.identifier, registration-&gt;identifier());
492         if (!result.isNewEntry) {
493             auto previousIdentifier = result.iterator-&gt;value;
494             if (previousIdentifier == registration-&gt;identifier())
495                 return;
496             result.iterator-&gt;value = registration-&gt;identifier();
497             if (auto* controllingRegistration = m_registrationsByID.get(previousIdentifier))
498                 controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
499         }
500         registration-&gt;controlClient(clientData.identifier);
501     });
502 }
503 
504 void SWServer::didResolveRegistrationPromise(Connection&amp; connection, const ServiceWorkerRegistrationKey&amp; registrationKey)
505 {
506     ASSERT_UNUSED(connection, m_connections.contains(connection.identifier()));
507 
508     if (auto* jobQueue = m_jobQueues.get(registrationKey))
509         jobQueue-&gt;didResolveRegistrationPromise();
510 }
511 
512 void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
513 {
514     auto* registration = m_registrationsByID.get(identifier);
515     if (!registration) {
516         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
517         return;
518     }
519 
520     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
521 }
522 
523 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
524 {
525     if (auto* registration = m_registrationsByID.get(identifier))
526         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
527 }
528 
529 void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
530 {
531     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });
532 }
533 
534 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
535 {
536     RegistrableDomain registrableDomain(data.scriptURL);
537     auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain);
538     if (!connection) {
539         m_pendingContextDatas.ensure(WTFMove(registrableDomain), [] {
540             return Vector&lt;ServiceWorkerContextData&gt; { };
541         }).iterator-&gt;value.append(WTFMove(data));
542         return;
543     }
544 
545     installContextData(data);
546 }
547 
548 void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)
549 {
550     for (auto&amp; connection : m_connections.values())
551         connection-&gt;serverToContextConnectionCreated(contextConnection);
552 
553     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
554     for (auto&amp; data : pendingContextDatas)
555         installContextData(data);
556 
557     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.registrableDomain());
558     for (auto&amp; item : serviceWorkerRunRequests) {
559         bool success = runServiceWorker(item.key);
560         for (auto&amp; callback : item.value)
561             callback(success ? &amp;contextConnection : nullptr);
562     }
563 }
564 
565 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
566 {
567     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
568 
569     if (data.jobDataIdentifier) {
570         // Abort if the job that scheduled this has been cancelled.
571         auto* jobQueue = m_jobQueues.get(data.registration.key);
572         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
573             return;
574     }
575 
576     auto* registration = m_registrations.get(data.registration.key);
577     RELEASE_ASSERT(registration);
578 
579     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
580 
581     auto* connection = worker-&gt;contextConnection();
582     ASSERT(connection);
583 
584     registration-&gt;setPreInstallationWorker(worker.ptr());
585     worker-&gt;setState(SWServerWorker::State::Running);
586     auto userAgent = worker-&gt;userAgent();
587     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
588     ASSERT_UNUSED(result, result.isNewEntry);
589 
590     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);
591 }
592 
593 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
594 {
595     auto* worker = workerByID(identifier);
596     if (!worker) {
597         callback(nullptr);
598         return;
599     }
600 
601     auto* contextConnection = worker-&gt;contextConnection();
602     if (worker-&gt;isRunning()) {
603         ASSERT(contextConnection);
604         callback(contextConnection);
605         return;
606     }
607 
608     if (!contextConnection) {
609         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {
610             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
611         }).iterator-&gt;value;
612         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
613             return Vector&lt;RunServiceWorkerCallback&gt; { };
614         }).iterator-&gt;value.append(WTFMove(callback));
615         return;
616     }
617 
618     bool success = runServiceWorker(identifier);
619     callback(success ? contextConnection : nullptr);
620 }
621 
622 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
623 {
624     auto* worker = workerByID(identifier);
625     if (!worker)
626         return false;
627 
628     // If the registration for a working has been removed then the request to run
629     // the worker is moot.
630     if (!getRegistration(worker-&gt;registrationKey()))
631         return false;
632 
633     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
634     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
635 
636     worker-&gt;setState(SWServerWorker::State::Running);
637 
638     auto* contextConnection = worker-&gt;contextConnection();
639     ASSERT(contextConnection);
640 
641     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), m_sessionID, worker-&gt;userAgent());
642 
643     return true;
644 }
645 
646 void SWServer::terminateWorker(SWServerWorker&amp; worker)
647 {
648     terminateWorkerInternal(worker, Asynchronous);
649 }
650 
651 void SWServer::syncTerminateWorker(SWServerWorker&amp; worker)
652 {
653     terminateWorkerInternal(worker, Synchronous);
654 }
655 
656 void SWServer::terminateWorkerInternal(SWServerWorker&amp; worker, TerminationMode mode)
657 {
658     ASSERT(m_runningOrTerminatingWorkers.get(worker.identifier()) == &amp;worker);
659     ASSERT(worker.isRunning());
660 
661     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::terminateWorkerInternal: Terminating service worker %llu&quot;, this, worker.identifier().toUInt64());
662 
663     worker.setState(SWServerWorker::State::Terminating);
664 
665     auto* contextConnection = worker.contextConnection();
666     ASSERT(contextConnection);
667     if (!contextConnection) {
668         LOG_ERROR(&quot;Request to terminate a worker whose context connection does not exist&quot;);
669         workerContextTerminated(worker);
670         return;
671     }
672 
673     switch (mode) {
674     case Asynchronous:
675         contextConnection-&gt;terminateWorker(worker.identifier());
676         break;
677     case Synchronous:
678         contextConnection-&gt;syncTerminateWorker(worker.identifier());
679         break;
680     };
681 }
682 
683 void SWServer::markAllWorkersForRegistrableDomainAsTerminated(const RegistrableDomain&amp; registrableDomain)
684 {
685     Vector&lt;SWServerWorker*&gt; terminatedWorkers;
686     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
687         if (worker-&gt;registrableDomain() == registrableDomain)
688             terminatedWorkers.append(worker.ptr());
689     }
690     for (auto&amp; terminatedWorker : terminatedWorkers)
691         workerContextTerminated(*terminatedWorker);
692 }
693 
694 void SWServer::workerContextTerminated(SWServerWorker&amp; worker)
695 {
696     worker.setState(SWServerWorker::State::NotRunning);
697 
698     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
699         jobQueue-&gt;cancelJobsFromServiceWorker(worker.identifier());
700 
701     // At this point if no registrations are referencing the worker then it will be destroyed,
702     // removing itself from the m_workersByID map.
703     auto result = m_runningOrTerminatingWorkers.take(worker.identifier());
704     ASSERT_UNUSED(result, result &amp;&amp; result-&gt;ptr() == &amp;worker);
705 }
706 
707 void SWServer::fireInstallEvent(SWServerWorker&amp; worker)
708 {
709     auto* contextConnection = worker.contextConnection();
710     if (!contextConnection) {
711         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
712         return;
713     }
714 
715     contextConnection-&gt;fireInstallEvent(worker.identifier());
716 }
717 
718 void SWServer::fireActivateEvent(SWServerWorker&amp; worker)
719 {
720     auto* contextConnection = worker.contextConnection();
721     if (!contextConnection) {
722         LOG_ERROR(&quot;Request to fire install event on a worker whose context connection does not exist&quot;);
723         return;
724     }
725 
726     contextConnection-&gt;fireActivateEvent(worker.identifier());
727 }
728 
729 void SWServer::addConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
730 {
731     auto identifier = connection-&gt;identifier();
732     ASSERT(!m_connections.contains(identifier));
733     m_connections.add(identifier, WTFMove(connection));
734 }
735 
736 void SWServer::removeConnection(SWServerConnectionIdentifier connectionIdentifier)
737 {
738     ASSERT(m_connections.contains(connectionIdentifier));
739     m_connections.remove(connectionIdentifier);
740 
741     for (auto&amp; registration : m_registrations.values())
742         registration-&gt;unregisterServerConnection(connectionIdentifier);
743 
744     for (auto&amp; jobQueue : m_jobQueues.values())
745         jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
746 }
747 
748 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
749 {
750     SWServerRegistration* selectedRegistration = nullptr;
751     for (auto&amp; registration : m_registrations.values()) {
752         if (!registration-&gt;key().isMatching(topOrigin, clientURL))
753             continue;
754         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; registration-&gt;key().scopeLength())
755             selectedRegistration = registration.get();
756     }
757 
758     return (selectedRegistration &amp;&amp; !selectedRegistration-&gt;isUninstalling()) ? selectedRegistration : nullptr;
759 }
760 
761 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
762 {
763     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
764     if (iterator == m_runningOrTerminatingWorkers.end())
765         return nullptr;
766 
767     return m_registrations.get(iterator-&gt;value-&gt;registrationKey());
768 }
769 
770 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
771 {
772     auto clientIdentifier = data.identifier;
773 
774     ASSERT(!m_clientsById.contains(clientIdentifier));
775     m_clientsById.add(clientIdentifier, WTFMove(data));
776 
777     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
778         return Clients { };
779     }).iterator-&gt;value;
780 
781     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
782     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
783 
784     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
785         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
786     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
787 
788     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
789 
790     m_clientsByRegistrableDomain.ensure(clientOrigin.clientRegistrableDomain(), [] {
791         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
792     }).iterator-&gt;value.add(clientIdentifier);
793 
794     if (!controllingServiceWorkerRegistrationIdentifier)
795         return;
796 
797     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);
798     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
799         return;
800 
801     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
802     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
803     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
804 }
805 
806 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
807 {
808     auto clientRegistrableDomain = clientOrigin.clientRegistrableDomain();
809 
810     bool wasRemoved = m_clientsById.remove(clientIdentifier);
811     ASSERT_UNUSED(wasRemoved, wasRemoved);
812 
813     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
814     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
815 
816     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
817     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
818         return clientIdentifier == identifier;
819     });
820 
821     if (clientIdentifiers.isEmpty()) {
822         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
823         iterator-&gt;value.terminateServiceWorkersTimer = makeUnique&lt;Timer&gt;([clientOrigin, clientRegistrableDomain, this] {
824             Vector&lt;SWServerWorker*&gt; workersToTerminate;
825             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
826                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
827                     workersToTerminate.append(worker.ptr());
828             }
829             for (auto* worker : workersToTerminate)
830                 terminateWorker(*worker);
831 
832             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
833                 if (auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(clientRegistrableDomain))
834                     connection-&gt;connectionMayNoLongerBeNeeded();
835             }
836 
837             m_clientIdentifiersPerOrigin.remove(clientOrigin);
838         });
839         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);
840     }
841 
842     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
843     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
844     auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
845     clientsForRegistrableDomain.remove(clientIdentifier);
846     if (clientsForRegistrableDomain.isEmpty())
847         m_clientsByRegistrableDomain.remove(clientsByRegistrableDomainIterator);
848 
849     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
850     if (registrationIterator == m_clientToControllingRegistration.end())
851         return;
852 
853     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))
854         registration-&gt;removeClientUsingRegistration(clientIdentifier);
855 
856     m_clientToControllingRegistration.remove(registrationIterator);
857 }
858 
859 bool SWServer::needsServerToContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const
860 {
861     return m_clientsByRegistrableDomain.contains(registrableDomain);
862 }
863 
864 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
865 {
866     for (auto&amp; connection : m_connections.values())
867         connection-&gt;resolveRegistrationReadyRequests(registration);
868 }
869 
870 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
871 {
872     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
873         if (registration-&gt;activeWorker()) {
874             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
875             return;
876         }
877     }
878     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
879 }
880 
881 void SWServer::Connection::storeRegistrationsOnDisk(CompletionHandler&lt;void()&gt;&amp;&amp; callback)
882 {
883     if (!m_server.m_registrationStore) {
884         callback();
885         return;
886     }
887     m_server.m_registrationStore-&gt;closeDatabase(WTFMove(callback));
888 }
889 
890 void SWServer::Connection::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
891 {
892     m_registrationReadyRequests.removeAllMatching([&amp;](auto&amp; request) {
893         if (!registration.key().isMatching(request.topOrigin, request.clientURL))
894             return false;
895 
896         this-&gt;registrationReady(request.identifier, registration.data());
897         return true;
898     });
899 }
900 
901 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
902 {
903     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
904 
905     if (m_importCompleted)
906         performGetOriginsWithRegistrationsCallbacks();
907 }
908 
909 void SWServer::performGetOriginsWithRegistrationsCallbacks()
910 {
911     ASSERT(isMainThread());
912     ASSERT(m_importCompleted);
913 
914     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
915         return;
916 
917     HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
918     for (auto&amp; key : m_registrations.keys()) {
919         originsWithRegistrations.add(key.topOrigin());
920         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
921     }
922 
923     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
924     for (auto&amp; callback : callbacks)
925         callback(originsWithRegistrations);
926 }
927 
928 } // namespace WebCore
929 
930 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>