<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
   3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
   4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
   5     Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6     Copyright (C) 2009 Torch Mobile Inc. http://www.torchmobile.com/
   7 
   8     This library is free software; you can redistribute it and/or
   9     modify it under the terms of the GNU Library General Public
  10     License as published by the Free Software Foundation; either
  11     version 2 of the License, or (at your option) any later version.
  12 
  13     This library is distributed in the hope that it will be useful,
  14     but WITHOUT ANY WARRANTY; without even the implied warranty of
  15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16     Library General Public License for more details.
  17 
  18     You should have received a copy of the GNU Library General Public License
  19     along with this library; see the file COPYING.LIB.  If not, write to
  20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21     Boston, MA 02110-1301, USA.
  22 
  23     This class provides all functionality needed for loading images, style sheets and html
  24     pages from the web. It has a memory cache for these objects.
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
  43 #include &quot;ContentSecurityPolicy.h&quot;
  44 #include &quot;CrossOriginAccessControl.h&quot;
  45 #include &quot;DOMWindow.h&quot;
  46 #include &quot;DiagnosticLoggingClient.h&quot;
  47 #include &quot;DiagnosticLoggingKeys.h&quot;
  48 #include &quot;Document.h&quot;
  49 #include &quot;DocumentLoader.h&quot;
  50 #include &quot;Frame.h&quot;
  51 #include &quot;FrameLoader.h&quot;
  52 #include &quot;FrameLoaderClient.h&quot;
  53 #include &quot;HTMLElement.h&quot;
  54 #include &quot;HTMLFrameOwnerElement.h&quot;
  55 #include &quot;HTTPHeaderField.h&quot;
  56 #include &quot;LoaderStrategy.h&quot;
  57 #include &quot;LocalizedStrings.h&quot;
  58 #include &quot;Logging.h&quot;
  59 #include &quot;MemoryCache.h&quot;
  60 #include &quot;Page.h&quot;
  61 #include &quot;PingLoader.h&quot;
  62 #include &quot;PlatformStrategies.h&quot;
  63 #include &quot;RenderElement.h&quot;
  64 #include &quot;ResourceLoadInfo.h&quot;
  65 #include &quot;ResourceTiming.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;ScriptController.h&quot;
  68 #include &quot;SecurityOrigin.h&quot;
  69 #include &quot;SecurityPolicy.h&quot;
  70 #include &quot;ServiceWorker.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;StyleSheetContents.h&quot;
  73 #include &quot;SubresourceLoader.h&quot;
  74 #include &quot;UserContentController.h&quot;
  75 #include &quot;UserStyleSheet.h&quot;
  76 #include &lt;pal/SessionID.h&gt;
  77 #include &lt;wtf/text/CString.h&gt;
  78 #include &lt;wtf/text/WTFString.h&gt;
  79 
  80 #if ENABLE(APPLICATION_MANIFEST)
  81 #include &quot;CachedApplicationManifest.h&quot;
  82 #endif
  83 
  84 #if ENABLE(VIDEO_TRACK)
  85 #include &quot;CachedTextTrack.h&quot;
  86 #endif
  87 
  88 #undef RELEASE_LOG_IF_ALLOWED
  89 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
  90 
  91 namespace WebCore {
  92 
  93 // Timeout for link preloads to be used after window.onload
  94 static const Seconds unusedPreloadTimeout { 3_s };
  95 
  96 template &lt;typename T, typename U&gt;
  97 static inline ResourceErrorOr&lt;CachedResourceHandle&lt;T&gt;&gt; castCachedResourceTo(ResourceErrorOr&lt;CachedResourceHandle&lt;U&gt;&gt;&amp;&amp; cachedResource)
  98 {
  99     if (cachedResource)
 100         return CachedResourceHandle&lt;T&gt; { static_cast&lt;T*&gt;(cachedResource.value().get()) };
 101     return makeUnexpected(cachedResource.error());
 102 }
 103 
 104 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 105 {
 106     switch (type) {
 107     case CachedResource::Type::ImageResource:
 108         return new CachedImage(WTFMove(request), sessionID, cookieJar);
 109     case CachedResource::Type::CSSStyleSheet:
 110         return new CachedCSSStyleSheet(WTFMove(request), sessionID, cookieJar);
 111     case CachedResource::Type::Script:
 112         return new CachedScript(WTFMove(request), sessionID, cookieJar);
 113     case CachedResource::Type::SVGDocumentResource:
 114         return new CachedSVGDocument(WTFMove(request), sessionID, cookieJar);
 115 #if ENABLE(SVG_FONTS)
 116     case CachedResource::Type::SVGFontResource:
 117         return new CachedSVGFont(WTFMove(request), sessionID, cookieJar);
 118 #endif
 119     case CachedResource::Type::FontResource:
 120         return new CachedFont(WTFMove(request), sessionID, cookieJar);
 121     case CachedResource::Type::Beacon:
 122     case CachedResource::Type::MediaResource:
 123     case CachedResource::Type::RawResource:
 124     case CachedResource::Type::Icon:
 125     case CachedResource::Type::MainResource:
 126         return new CachedRawResource(WTFMove(request), type, sessionID, cookieJar);
 127 #if ENABLE(XSLT)
 128     case CachedResource::Type::XSLStyleSheet:
 129         return new CachedXSLStyleSheet(WTFMove(request), sessionID, cookieJar);
 130 #endif
 131     case CachedResource::Type::LinkPrefetch:
 132         return new CachedResource(WTFMove(request), CachedResource::Type::LinkPrefetch, sessionID, cookieJar);
 133 #if ENABLE(VIDEO_TRACK)
 134     case CachedResource::Type::TextTrackResource:
 135         return new CachedTextTrack(WTFMove(request), sessionID, cookieJar);
 136 #endif
 137 #if ENABLE(APPLICATION_MANIFEST)
 138     case CachedResource::Type::ApplicationManifest:
 139         return new CachedApplicationManifest(WTFMove(request), sessionID, cookieJar);
 140 #endif
 141     }
 142     ASSERT_NOT_REACHED();
 143     return nullptr;
 144 }
 145 
 146 CachedResourceLoader::CachedResourceLoader(DocumentLoader* documentLoader)
 147     : m_document(nullptr)
 148     , m_documentLoader(documentLoader)
 149     , m_requestCount(0)
 150     , m_unusedPreloadsTimer(*this, &amp;CachedResourceLoader::warnUnusedPreloads)
 151     , m_garbageCollectDocumentResourcesTimer(*this, &amp;CachedResourceLoader::garbageCollectDocumentResources)
 152     , m_autoLoadImages(true)
 153     , m_imagesEnabled(true)
 154     , m_allowStaleResources(false)
 155 {
 156 }
 157 
 158 CachedResourceLoader::~CachedResourceLoader()
 159 {
 160     m_documentLoader = nullptr;
 161     m_document = nullptr;
 162 
 163     clearPreloads(ClearPreloadsMode::ClearAllPreloads);
 164 
 165     // Make sure no requests still point to this CachedResourceLoader
 166     ASSERT(m_requestCount == 0);
 167     m_unusedPreloadsTimer.stop();
 168 }
 169 
 170 CachedResource* CachedResourceLoader::cachedResource(const String&amp; resourceURL) const
 171 {
 172     ASSERT(!resourceURL.isNull());
 173     return cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(m_document-&gt;completeURL(resourceURL)));
 174 }
 175 
 176 CachedResource* CachedResourceLoader::cachedResource(const URL&amp; url) const
 177 {
 178     ASSERT(!MemoryCache::shouldRemoveFragmentIdentifier(url));
 179     return m_documentResources.get(url).get();
 180 }
 181 
 182 Frame* CachedResourceLoader::frame() const
 183 {
 184     return m_documentLoader ? m_documentLoader-&gt;frame() : nullptr;
 185 }
 186 
 187 PAL::SessionID CachedResourceLoader::sessionID() const
 188 {
 189     auto sessionID = PAL::SessionID::defaultSessionID();
 190     if (auto* frame = this-&gt;frame()) {
 191         if (auto* page = frame-&gt;page())
 192             sessionID = page-&gt;sessionID();
 193     }
 194     return sessionID;
 195 }
 196 
 197 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedImage&gt;&gt; CachedResourceLoader::requestImage(CachedResourceRequest&amp;&amp; request)
 198 {
 199     if (Frame* frame = this-&gt;frame()) {
 200         if (frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None) {
 201             if (Document* document = frame-&gt;document())
 202                 request.upgradeInsecureRequestIfNeeded(*document);
 203             URL requestURL = request.resourceRequest().url();
 204             if (requestURL.isValid() &amp;&amp; canRequest(CachedResource::Type::ImageResource, requestURL, request, ForPreload::No))
 205                 PingLoader::loadImage(*frame, requestURL);
 206             return CachedResourceHandle&lt;CachedImage&gt; { };
 207         }
 208     }
 209 
 210     auto defer = clientDefersImage(request.resourceRequest().url()) ? DeferOption::DeferredByClient : DeferOption::NoDefer;
 211     return castCachedResourceTo&lt;CachedImage&gt;(requestResource(CachedResource::Type::ImageResource, WTFMove(request), ForPreload::No, defer));
 212 }
 213 
 214 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; CachedResourceLoader::requestFont(CachedResourceRequest&amp;&amp; request, bool isSVG)
 215 {
 216 #if ENABLE(SVG_FONTS)
 217     if (isSVG)
 218         return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::SVGFontResource, WTFMove(request)));
 219 #else
 220     UNUSED_PARAM(isSVG);
 221 #endif
 222     return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::FontResource, WTFMove(request)));
 223 }
 224 
 225 #if ENABLE(VIDEO_TRACK)
 226 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedTextTrack&gt;&gt; CachedResourceLoader::requestTextTrack(CachedResourceRequest&amp;&amp; request)
 227 {
 228     return castCachedResourceTo&lt;CachedTextTrack&gt;(requestResource(CachedResource::Type::TextTrackResource, WTFMove(request)));
 229 }
 230 #endif
 231 
 232 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedCSSStyleSheet&gt;&gt; CachedResourceLoader::requestCSSStyleSheet(CachedResourceRequest&amp;&amp; request)
 233 {
 234     return castCachedResourceTo&lt;CachedCSSStyleSheet&gt;(requestResource(CachedResource::Type::CSSStyleSheet, WTFMove(request)));
 235 }
 236 
 237 CachedResourceHandle&lt;CachedCSSStyleSheet&gt; CachedResourceLoader::requestUserCSSStyleSheet(Page&amp; page, CachedResourceRequest&amp;&amp; request)
 238 {
 239     request.setDestinationIfNotSet(FetchOptions::Destination::Style);
 240 
 241     ASSERT(document());
 242     request.setDomainForCachePartition(*document());
 243 
 244     auto&amp; memoryCache = MemoryCache::singleton();
 245     if (request.allowsCaching()) {
 246         if (CachedResource* existing = memoryCache.resourceForRequest(request.resourceRequest(), sessionID())) {
 247             if (is&lt;CachedCSSStyleSheet&gt;(*existing))
 248                 return downcast&lt;CachedCSSStyleSheet&gt;(existing);
 249             memoryCache.remove(*existing);
 250         }
 251     }
 252 
 253     request.removeFragmentIdentifierIfNeeded();
 254 
 255     CachedResourceHandle&lt;CachedCSSStyleSheet&gt; userSheet = new CachedCSSStyleSheet(WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 256 
 257     if (userSheet-&gt;allowsCaching())
 258         memoryCache.add(*userSheet);
 259 
 260     userSheet-&gt;load(*this);
 261     return userSheet;
 262 }
 263 
 264 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedScript&gt;&gt; CachedResourceLoader::requestScript(CachedResourceRequest&amp;&amp; request)
 265 {
 266     return castCachedResourceTo&lt;CachedScript&gt;(requestResource(CachedResource::Type::Script, WTFMove(request)));
 267 }
 268 
 269 #if ENABLE(XSLT)
 270 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedXSLStyleSheet&gt;&gt; CachedResourceLoader::requestXSLStyleSheet(CachedResourceRequest&amp;&amp; request)
 271 {
 272     return castCachedResourceTo&lt;CachedXSLStyleSheet&gt;(requestResource(CachedResource::Type::XSLStyleSheet, WTFMove(request)));
 273 }
 274 #endif
 275 
 276 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedSVGDocument&gt;&gt; CachedResourceLoader::requestSVGDocument(CachedResourceRequest&amp;&amp; request)
 277 {
 278     return castCachedResourceTo&lt;CachedSVGDocument&gt;(requestResource(CachedResource::Type::SVGDocumentResource, WTFMove(request)));
 279 }
 280 
 281 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestLinkResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
 282 {
 283     ASSERT(frame());
 284     ASSERT(type == CachedResource::Type::LinkPrefetch);
 285     return requestResource(type, WTFMove(request));
 286 }
 287 
 288 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMedia(CachedResourceRequest&amp;&amp; request)
 289 {
 290     // FIXME: Assert request.options().destination is FetchOptions::Destination::{Audio, Video}.
 291     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MediaResource, WTFMove(request)));
 292 }
 293 
 294 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestIcon(CachedResourceRequest&amp;&amp; request)
 295 {
 296     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Icon, WTFMove(request)));
 297 }
 298 
 299 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestRawResource(CachedResourceRequest&amp;&amp; request)
 300 {
 301     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::RawResource, WTFMove(request)));
 302 }
 303 
 304 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestBeaconResource(CachedResourceRequest&amp;&amp; request)
 305 {
 306     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 307     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Beacon, WTFMove(request)));
 308 }
 309 
 310 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp;&amp; request)
 311 {
 312     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MainResource, WTFMove(request)));
 313 }
 314 
 315 #if ENABLE(APPLICATION_MANIFEST)
 316 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedApplicationManifest&gt;&gt; CachedResourceLoader::requestApplicationManifest(CachedResourceRequest&amp;&amp; request)
 317 {
 318     return castCachedResourceTo&lt;CachedApplicationManifest&gt;(requestResource(CachedResource::Type::ApplicationManifest, WTFMove(request)));
 319 }
 320 #endif // ENABLE(APPLICATION_MANIFEST)
 321 
 322 static MixedContentChecker::ContentType contentTypeFromResourceType(CachedResource::Type type)
 323 {
 324     switch (type) {
 325     // https://w3c.github.io/webappsec-mixed-content/#category-optionally-blockable
 326     // Editor&#39;s Draft, 11 February 2016
 327     // 3.1. Optionally-blockable Content
 328     case CachedResource::Type::ImageResource:
 329     case CachedResource::Type::MediaResource:
 330             return MixedContentChecker::ContentType::ActiveCanWarn;
 331 
 332     case CachedResource::Type::CSSStyleSheet:
 333     case CachedResource::Type::Script:
 334     case CachedResource::Type::FontResource:
 335         return MixedContentChecker::ContentType::Active;
 336 
 337 #if ENABLE(SVG_FONTS)
 338     case CachedResource::Type::SVGFontResource:
 339         return MixedContentChecker::ContentType::Active;
 340 #endif
 341 
 342     case CachedResource::Type::Beacon:
 343     case CachedResource::Type::RawResource:
 344     case CachedResource::Type::Icon:
 345     case CachedResource::Type::SVGDocumentResource:
 346         return MixedContentChecker::ContentType::Active;
 347 #if ENABLE(XSLT)
 348     case CachedResource::Type::XSLStyleSheet:
 349         return MixedContentChecker::ContentType::Active;
 350 #endif
 351 
 352     case CachedResource::Type::LinkPrefetch:
 353         return MixedContentChecker::ContentType::Active;
 354 
 355 #if ENABLE(VIDEO_TRACK)
 356     case CachedResource::Type::TextTrackResource:
 357         return MixedContentChecker::ContentType::Active;
 358 #endif
 359 #if ENABLE(APPLICATION_MANIFEST)
 360     case CachedResource::Type::ApplicationManifest:
 361         return MixedContentChecker::ContentType::Active;
 362 #endif
 363     default:
 364         ASSERT_NOT_REACHED();
 365         return MixedContentChecker::ContentType::Active;
 366     }
 367 }
 368 
 369 bool CachedResourceLoader::checkInsecureContent(CachedResource::Type type, const URL&amp; url) const
 370 {
 371     if (!canRequestInContentDispositionAttachmentSandbox(type, url))
 372         return false;
 373 
 374     switch (type) {
 375     case CachedResource::Type::Script:
 376 #if ENABLE(XSLT)
 377     case CachedResource::Type::XSLStyleSheet:
 378 #endif
 379     case CachedResource::Type::SVGDocumentResource:
 380     case CachedResource::Type::CSSStyleSheet:
 381         // These resource can inject script into the current document (Script,
 382         // XSL) or exfiltrate the content of the current document (CSS).
 383         if (Frame* frame = this-&gt;frame()) {
 384             if (!frame-&gt;loader().mixedContentChecker().canRunInsecureContent(m_document-&gt;securityOrigin(), url))
 385                 return false;
 386             Frame&amp; top = frame-&gt;tree().top();
 387             if (&amp;top != frame &amp;&amp; !top.loader().mixedContentChecker().canRunInsecureContent(top.document()-&gt;securityOrigin(), url))
 388                 return false;
 389         }
 390         break;
 391 #if ENABLE(VIDEO_TRACK)
 392     case CachedResource::Type::TextTrackResource:
 393 #endif
 394     case CachedResource::Type::MediaResource:
 395     case CachedResource::Type::RawResource:
 396     case CachedResource::Type::Icon:
 397     case CachedResource::Type::ImageResource:
 398 #if ENABLE(SVG_FONTS)
 399     case CachedResource::Type::SVGFontResource:
 400 #endif
 401     case CachedResource::Type::FontResource: {
 402         // These resources can corrupt only the frame&#39;s pixels.
 403         if (Frame* frame = this-&gt;frame()) {
 404             if (!frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_document-&gt;securityOrigin(), contentTypeFromResourceType(type), url, MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes))
 405                 return false;
 406             Frame&amp; topFrame = frame-&gt;tree().top();
 407             if (!topFrame.loader().mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), contentTypeFromResourceType(type), url))
 408                 return false;
 409         }
 410         break;
 411     }
 412     case CachedResource::Type::MainResource:
 413     case CachedResource::Type::Beacon:
 414     case CachedResource::Type::LinkPrefetch:
 415         // Prefetch cannot affect the current document.
 416 #if ENABLE(APPLICATION_MANIFEST)
 417     case CachedResource::Type::ApplicationManifest:
 418 #endif
 419         break;
 420     }
 421     return true;
 422 }
 423 
 424 bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const
 425 {
 426     if (options.contentSecurityPolicyImposition == ContentSecurityPolicyImposition::SkipPolicyCheck)
 427         return true;
 428 
 429     ASSERT(m_document);
 430     ASSERT(m_document-&gt;contentSecurityPolicy());
 431 
 432     switch (type) {
 433 #if ENABLE(XSLT)
 434     case CachedResource::Type::XSLStyleSheet:
 435 #endif
 436     case CachedResource::Type::Script:
 437         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowScriptFromSource(url, redirectResponseReceived))
 438             return false;
 439         break;
 440     case CachedResource::Type::CSSStyleSheet:
 441         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowStyleFromSource(url, redirectResponseReceived))
 442             return false;
 443         break;
 444     case CachedResource::Type::SVGDocumentResource:
 445     case CachedResource::Type::Icon:
 446     case CachedResource::Type::ImageResource:
 447         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowImageFromSource(url, redirectResponseReceived))
 448             return false;
 449         break;
 450 #if ENABLE(SVG_FONTS)
 451     case CachedResource::Type::SVGFontResource:
 452 #endif
 453     case CachedResource::Type::FontResource:
 454         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowFontFromSource(url, redirectResponseReceived))
 455             return false;
 456         break;
 457     case CachedResource::Type::MediaResource:
 458 #if ENABLE(VIDEO_TRACK)
 459     case CachedResource::Type::TextTrackResource:
 460 #endif
 461         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowMediaFromSource(url, redirectResponseReceived))
 462             return false;
 463         break;
 464     case CachedResource::Type::Beacon:
 465     case CachedResource::Type::RawResource:
 466         return true;
 467 #if ENABLE(APPLICATION_MANIFEST)
 468     case CachedResource::Type::ApplicationManifest:
 469         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowManifestFromSource(url, redirectResponseReceived))
 470             return false;
 471         break;
 472 #endif
 473     default:
 474         ASSERT_NOT_REACHED();
 475     }
 476 
 477     return true;
 478 }
 479 
 480 static inline bool isSameOriginDataURL(const URL&amp; url, const ResourceLoaderOptions&amp; options)
 481 {
 482     // FIXME: Remove same-origin data URL flag since it was removed from fetch spec (https://github.com/whatwg/fetch/issues/381).
 483     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 484 }
 485 
 486 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 487 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 488 {
 489     auto&amp; options = request.options();
 490 
 491     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 492         if (forPreload == ForPreload::No)
 493             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 494         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 495         return false;
 496     }
 497 
 498     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 499         printAccessDeniedMessage(url);
 500         return false;
 501     }
 502 
 503     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; options.redirect != FetchOptions::Redirect::Follow) {
 504         ASSERT(type != CachedResource::Type::MainResource);
 505         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 506         return false;
 507     }
 508 
 509     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 510         return false;
 511 
 512     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 513     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 514         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 515             return false;
 516     }
 517 
 518     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 519     // They&#39;ll still get a warning in the console about CSP blocking the load.
 520 
 521     // FIXME: Should we consider whether the request is for preload here?
 522     if (!checkInsecureContent(type, url))
 523         return false;
 524 
 525     return true;
 526 }
 527 
 528 // FIXME: Should we find a way to know whether the redirection is for a preload request like we do for CachedResourceLoader::canRequest?
 529 bool CachedResourceLoader::canRequestAfterRedirection(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options) const
 530 {
 531     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 532         FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 533         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 534         return false;
 535     }
 536 
 537     // FIXME: According to https://fetch.spec.whatwg.org/#http-redirect-fetch, we should check that the URL is HTTP(s) except if in navigation mode.
 538     // But we currently allow at least data URLs to be loaded.
 539 
 540     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url)) {
 541         printAccessDeniedMessage(url);
 542         return false;
 543     }
 544 
 545     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::Yes))
 546         return false;
 547 
 548     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 549     // They&#39;ll still get a warning in the console about CSP blocking the load.
 550     if (!checkInsecureContent(type, url))
 551         return false;
 552 
 553     return true;
 554 }
 555 
 556 bool CachedResourceLoader::updateRequestAfterRedirection(CachedResource::Type type, ResourceRequest&amp; request, const ResourceLoaderOptions&amp; options)
 557 {
 558     ASSERT(m_documentLoader);
 559     if (auto* document = m_documentLoader-&gt;cachedResourceLoader().document())
 560         upgradeInsecureResourceRequestIfNeeded(request, *document);
 561 
 562     // FIXME: We might want to align the checks done here with the ones done in CachedResourceLoader::requestResource, content extensions blocking in particular.
 563 
 564     return canRequestAfterRedirection(type, request.url(), options);
 565 }
 566 
 567 bool CachedResourceLoader::canRequestInContentDispositionAttachmentSandbox(CachedResource::Type type, const URL&amp; url) const
 568 {
 569     Document* document;
 570 
 571     // FIXME: Do we want to expand this to all resource types that the mixed content checker would consider active content?
 572     switch (type) {
 573     case CachedResource::Type::MainResource:
 574         if (auto ownerElement = frame() ? frame()-&gt;ownerElement() : nullptr) {
 575             document = &amp;ownerElement-&gt;document();
 576             break;
 577         }
 578         return true;
 579     case CachedResource::Type::CSSStyleSheet:
 580         document = m_document;
 581         break;
 582     default:
 583         return true;
 584     }
 585 
 586     if (!document-&gt;shouldEnforceContentDispositionAttachmentSandbox() || document-&gt;securityOrigin().canRequest(url))
 587         return true;
 588 
 589     String message = &quot;Unsafe attempt to load URL &quot; + url.stringCenterEllipsizedToLength() + &quot; from document with Content-Disposition: attachment at URL &quot; + document-&gt;url().stringCenterEllipsizedToLength() + &quot;.&quot;;
 590     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 591     return false;
 592 }
 593 
 594 bool CachedResourceLoader::shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp; request, CachedResource&amp; resource, ResourceError&amp; error)
 595 {
 596     if (!frame() || resource.status() != CachedResource::Cached)
 597         return true;
 598 
 599     ResourceRequest newRequest = ResourceRequest(resource.url());
 600     newRequest.setInitiatorIdentifier(request.resourceRequest().initiatorIdentifier());
 601     if (auto inspectorInitiatorNodeIdentifier = request.resourceRequest().inspectorInitiatorNodeIdentifier())
 602         newRequest.setInspectorInitiatorNodeIdentifier(*inspectorInitiatorNodeIdentifier);
 603     if (request.resourceRequest().hiddenFromInspector())
 604         newRequest.setHiddenFromInspector(true);
 605     frame()-&gt;loader().loadedResourceFromMemoryCache(resource, newRequest, error);
 606 
 607     // FIXME &lt;http://webkit.org/b/113251&gt;: If the delegate modifies the request&#39;s
 608     // URL, it is no longer appropriate to use this CachedResource.
 609     return !newRequest.isNull();
 610 }
 611 
 612 bool CachedResourceLoader::shouldUpdateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 613 {
 614     // WebKit is not supporting CORS for fonts (https://bugs.webkit.org/show_bug.cgi?id=86817), no need to update the resource before reusing it.
 615     if (resource.type() == CachedResource::Type::FontResource)
 616         return false;
 617 
 618 #if ENABLE(SVG_FONTS)
 619     if (resource.type() == CachedResource::Type::SVGFontResource)
 620         return false;
 621 #endif
 622 
 623 #if ENABLE(XSLT)
 624     // Load is same-origin, we do not check for CORS.
 625     if (resource.type() == CachedResource::Type::XSLStyleSheet)
 626         return false;
 627 #endif
 628 
 629     // FIXME: We should enable resource reuse for these resource types
 630     switch (resource.type()) {
 631     case CachedResource::Type::SVGDocumentResource:
 632         return false;
 633     case CachedResource::Type::MainResource:
 634         return false;
 635     case CachedResource::Type::LinkPrefetch:
 636         return false;
 637     default:
 638         break;
 639     }
 640 
 641     if (resource.options().mode != request.options().mode || !originsMatch(request.origin(), resource.origin()))
 642         return true;
 643 
 644     if (resource.options().redirect != request.options().redirect &amp;&amp; resource.hasRedirections())
 645         return true;
 646 
 647     return false;
 648 }
 649 
 650 static inline bool isResourceSuitableForDirectReuse(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 651 {
 652     // FIXME: For being loaded requests, the response tainting may not be correctly computed if the fetch mode is not the same.
 653     // Even if the fetch mode is the same, we are not sure that the resource can be reused (Vary: Origin header for instance).
 654     // We should find a way to improve this.
 655     if (resource.status() != CachedResource::Cached)
 656         return false;
 657 
 658     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 659     // Let&#39;s make sure the memory cache has no such resource.
 660     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 661 
 662     // We could support redirect modes other than Follow in case of a redirected resource.
 663     // This case is rare and is not worth optimizing currently.
 664     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 665         return false;
 666 
 667     // FIXME: Implement reuse of cached raw resources.
 668     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 669         return false;
 670 
 671     if (resource.type() == CachedResource::Type::Beacon)
 672         return false;
 673 
 674     return true;
 675 }
 676 
 677 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 678 {
 679     if (!isResourceSuitableForDirectReuse(resource, request)) {
 680         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 681         return loadResource(resource.type(), WTFMove(request), cookieJar);
 682     }
 683 
 684     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, cookieJar);
 685     resourceHandle-&gt;loadFrom(resource);
 686     return resourceHandle;
 687 }
 688 
 689 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 690 {
 691     if (!frame || !frame-&gt;page())
 692         return;
 693     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(key, description, ShouldSample::Yes);
 694 }
 695 
 696 void CachedResourceLoader::prepareFetch(CachedResource::Type type, CachedResourceRequest&amp; request)
 697 {
 698     // Implementing step 1 to 7 of https://fetch.spec.whatwg.org/#fetching
 699     auto* document = this-&gt;document();
 700 
 701     if (document) {
 702         if (!request.origin())
 703             request.setOrigin(document-&gt;securityOrigin());
 704 #if ENABLE(SERVICE_WORKER)
 705         request.setClientIdentifierIfNeeded(document-&gt;identifier());
 706         if (auto* activeServiceWorker = document-&gt;activeServiceWorker())
 707             request.setSelectedServiceWorkerRegistrationIdentifierIfNeeded(activeServiceWorker-&gt;registrationIdentifier());
 708 #endif
 709     }
 710 
 711     request.setAcceptHeaderIfNone(type);
 712 
 713     // Accept-Language value is handled in underlying port-specific code.
 714     // FIXME: Decide whether to support client hints
 715 }
 716 
 717 void CachedResourceLoader::updateHTTPRequestHeaders(CachedResource::Type type, CachedResourceRequest&amp; request)
 718 {
 719     // Implementing steps 7 to 12 of https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
 720 
 721     // FIXME: We should reconcile handling of MainResource with other resources.
 722     if (type != CachedResource::Type::MainResource) {
 723         // In some cases we may try to load resources in frameless documents. Such loads always fail.
 724         // FIXME: We shouldn&#39;t need to do the check on frame.
 725         if (auto* frame = this-&gt;frame())
 726             request.updateReferrerOriginAndUserAgentHeaders(frame-&gt;loader());
 727     }
 728 
 729     request.updateAccordingCacheMode();
 730     request.updateAcceptEncodingHeader();
 731 }
 732 
 733 static FetchOptions::Destination destinationForType(CachedResource::Type type)
 734 {
 735     switch (type) {
 736     case CachedResource::Type::MainResource:
 737     case CachedResource::Type::SVGDocumentResource:
 738         return FetchOptions::Destination::Document;
 739     case CachedResource::Type::ImageResource:
 740     case CachedResource::Type::Icon:
 741         return FetchOptions::Destination::Image;
 742     case CachedResource::Type::CSSStyleSheet:
 743         return FetchOptions::Destination::Style;
 744     case CachedResource::Type::Script:
 745         return FetchOptions::Destination::Script;
 746     case CachedResource::Type::FontResource:
 747 #if ENABLE(SVG_FONTS)
 748     case CachedResource::Type::SVGFontResource:
 749 #endif
 750         return FetchOptions::Destination::Font;
 751 #if ENABLE(XSLT)
 752     case CachedResource::Type::XSLStyleSheet:
 753         return FetchOptions::Destination::Xslt;
 754 #endif
 755 #if ENABLE(VIDEO_TRACK)
 756     case CachedResource::Type::TextTrackResource:
 757         return FetchOptions::Destination::Track;
 758 #endif
 759 #if ENABLE(APPLICATION_MANIFEST)
 760     case CachedResource::Type::ApplicationManifest:
 761         return FetchOptions::Destination::Manifest;
 762 #endif
 763     case CachedResource::Type::Beacon:
 764     case CachedResource::Type::LinkPrefetch:
 765     case CachedResource::Type::RawResource:
 766     case CachedResource::Type::MediaResource:
 767         // The caller is responsible for setting the appropriate destination.
 768         return FetchOptions::Destination::EmptyString;
 769     }
 770     ASSERT_NOT_REACHED();
 771     return FetchOptions::Destination::EmptyString;
 772 }
 773 
 774 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 775 {
 776     request.setDestinationIfNotSet(destinationForType(type));
 777 
 778     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 779     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 780     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
 781         originalRequest = std::make_unique&lt;ResourceRequest&gt;(request.resourceRequest());
 782         originalRequest-&gt;clearHTTPReferrer();
 783         originalRequest-&gt;clearHTTPOrigin();
 784     }
 785 
 786     if (Document* document = this-&gt;document())
 787         request.upgradeInsecureRequestIfNeeded(*document);
 788 
 789     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 790     URL url = request.resourceRequest().url();
 791 
 792     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 793 
 794     if (!url.isValid()) {
 795         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, frame());
 796         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 797     }
 798 
 799     prepareFetch(type, request);
 800 
 801     // We are passing url as well as request, as request url may contain a fragment identifier.
 802     if (!canRequest(type, url, request, forPreload)) {
 803         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, frame());
 804         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 805     }
 806 
 807 #if ENABLE(CONTENT_EXTENSIONS)
 808     if (frame() &amp;&amp; frame()-&gt;page() &amp;&amp; m_documentLoader) {
 809         const auto&amp; resourceRequest = request.resourceRequest();
 810         auto* page = frame()-&gt;page();
 811         auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(resourceRequest.url(), toResourceType(type), *m_documentLoader);
 812         request.applyBlockedStatus(blockedStatus, page);
 813         if (blockedStatus.blockedLoad) {
 814             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, frame());
 815             if (type == CachedResource::Type::MainResource) {
 816                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
 817                 ASSERT(resource);
 818                 resource-&gt;error(CachedResource::Status::LoadError);
 819                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
 820                 return WTFMove(resource);
 821             }
 822             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 823         }
 824         if (blockedStatus.madeHTTPS
 825             &amp;&amp; type == CachedResource::Type::MainResource
 826             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 827             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 828             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 829         }
 830         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 831         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 832     }
 833 #endif
 834 
 835     if (frame() &amp;&amp; m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {
 836         bool sameOriginRequest = false;
 837         auto requestedOrigin = SecurityOrigin::create(url);
 838         if (type == CachedResource::Type::MainResource) {
 839             if (frame()-&gt;isMainFrame())
 840                 sameOriginRequest = true;
 841             else if (auto* topDocument = frame()-&gt;mainFrame().document())
 842                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 843         } else if (document()) {
 844             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 845                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 846         }
 847         if (sameOriginRequest) {
 848             for (auto&amp; field : m_documentLoader-&gt;customHeaderFields())
 849                 request.resourceRequest().setHTTPHeaderField(field.name(), field.value());
 850         }
 851     }
 852 
 853     LoadTiming loadTiming;
 854     loadTiming.markStartTimeAndFetchStart();
 855     InitiatorContext initiatorContext = request.options().initiatorContext;
 856 
 857     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 858         updateHTTPRequestHeaders(type, request);
 859 
 860     auto&amp; memoryCache = MemoryCache::singleton();
 861     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 862         m_documentResources.remove(url.string());
 863 
 864     // See if we can use an existing resource from the cache.
 865     CachedResourceHandle&lt;CachedResource&gt; resource;
 866     if (document())
 867         request.setDomainForCachePartition(*document());
 868 
 869     if (request.allowsCaching())
 870         resource = memoryCache.resourceForRequest(request.resourceRequest(), sessionID());
 871 
 872     if (resource &amp;&amp; request.isLinkPreload() &amp;&amp; !resource-&gt;isLinkPreload())
 873         resource-&gt;setLinkPreload();
 874 
 875     logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheUsageKey(), resource ? DiagnosticLoggingKeys::inMemoryCacheKey() : DiagnosticLoggingKeys::notInMemoryCacheKey());
 876 
 877     auto* cookieJar = document() &amp;&amp; document()-&gt;page() ? &amp;document()-&gt;page()-&gt;cookieJar() : nullptr;
 878 
 879     RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
 880     switch (policy) {
 881     case Reload:
 882         memoryCache.remove(*resource);
 883         FALLTHROUGH;
 884     case Load:
 885         if (resource)
 886             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());
 887         resource = loadResource(type, WTFMove(request), cookieJar);
 888         break;
 889     case Revalidate:
 890         if (resource)
 891             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());
 892         resource = revalidateResource(WTFMove(request), *resource);
 893         break;
 894     case Use:
 895         ASSERT(resource);
 896         if (request.options().mode == FetchOptions::Mode::NoCors) {
 897             if (auto error = validateCrossOriginResourcePolicy(*request.origin(), request.resourceRequest().url(), resource-&gt;response()))
 898                 return makeUnexpected(WTFMove(*error));
 899         }
 900         if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) {
 901             resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request), document()-&gt;page()-&gt;sessionID(), cookieJar);
 902             if (resource-&gt;status() != CachedResource::Status::Cached)
 903                 policy = Load;
 904         } else {
 905             ResourceError error;
 906             if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
 907                 return makeUnexpected(WTFMove(error));
 908             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());
 909             loadTiming.setResponseEnd(MonotonicTime::now());
 910 
 911             memoryCache.resourceAccessed(*resource);
 912 
 913             if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) {
 914                 auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
 915                 if (initiatorContext == InitiatorContext::Worker) {
 916                     ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
 917                     downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
 918                 } else {
 919                     ASSERT(initiatorContext == InitiatorContext::Document);
 920                     m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());
 921                     m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
 922                 }
 923             }
 924 
 925             if (forPreload == ForPreload::No)
 926                 resource-&gt;setLoadPriority(request.priority());
 927         }
 928         break;
 929     }
 930     ASSERT(resource);
 931     resource-&gt;setOriginalRequest(WTFMove(originalRequest));
 932 
 933     if (forPreload == ForPreload::No &amp;&amp; resource-&gt;loader() &amp;&amp; resource-&gt;ignoreForRequestCount()) {
 934         resource-&gt;setIgnoreForRequestCount(false);
 935         incrementRequestCount(*resource);
 936     }
 937 
 938     if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; defer == DeferOption::NoDefer) {
 939         resource-&gt;load(*this);
 940 
 941         // We don&#39;t support immediate loads, but we do support immediate failure.
 942         if (resource-&gt;errorOccurred()) {
 943             if (resource-&gt;allowsCaching() &amp;&amp; resource-&gt;inCache())
 944                 memoryCache.remove(*resource);
 945 
 946             auto resourceError = resource-&gt;resourceError();
 947             // Synchronous cancellations are likely due to access control.
 948             if (resourceError.isNull() || resourceError.isCancellation())
 949                 return makeUnexpected(ResourceError { String(), 0, url, String(), ResourceError::Type::AccessControl });
 950             return makeUnexpected(resourceError);
 951         }
 952     }
 953 
 954     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; !resource-&gt;resourceRequest().url().protocolIsData())
 955         m_validatedURLs.add(resource-&gt;resourceRequest().url());
 956 
 957     ASSERT(resource-&gt;url() == url.string());
 958     m_documentResources.set(resource-&gt;url(), resource);
 959     return WTFMove(resource);
 960 }
 961 
 962 void CachedResourceLoader::documentDidFinishLoadEvent()
 963 {
 964     m_validatedURLs.clear();
 965 
 966     // If m_preloads is not empty here, it&#39;s full of link preloads,
 967     // as speculative preloads were cleared at DCL.
 968     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 969         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 970 }
 971 
 972 void CachedResourceLoader::stopUnusedPreloadsTimer()
 973 {
 974     m_unusedPreloadsTimer.stop();
 975 }
 976 
 977 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
 978 {
 979     ASSERT(resource.inCache());
 980     auto&amp; memoryCache = MemoryCache::singleton();
 981     ASSERT(!memoryCache.disabled());
 982     ASSERT(resource.canUseCacheValidator());
 983     ASSERT(!resource.resourceToRevalidate());
 984     ASSERT(resource.sessionID() == sessionID());
 985     ASSERT(resource.allowsCaching());
 986 
 987     CachedResourceHandle&lt;CachedResource&gt; newResource = createResource(resource.type(), WTFMove(request), resource.sessionID(), resource.cookieJar());
 988 
 989     LOG(ResourceLoading, &quot;Resource %p created to revalidate %p&quot;, newResource.get(), &amp;resource);
 990     newResource-&gt;setResourceToRevalidate(&amp;resource);
 991 
 992     memoryCache.remove(resource);
 993     memoryCache.add(*newResource);
 994 
 995     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
 996         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(newResource, newResource-&gt;initiatorName(), frame());
 997 
 998     return newResource;
 999 }
1000 
1001 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::loadResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const CookieJar* cookieJar)
1002 {
1003     auto&amp; memoryCache = MemoryCache::singleton();
1004     ASSERT(!request.allowsCaching() || !memoryCache.resourceForRequest(request.resourceRequest(), sessionID())
1005         || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData);
1006 
1007     LOG(ResourceLoading, &quot;Loading CachedResource for &#39;%s&#39;.&quot;, request.resourceRequest().url().stringCenterEllipsizedToLength().latin1().data());
1008 
1009     CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), sessionID(), cookieJar);
1010 
1011     if (resource-&gt;allowsCaching())
1012         memoryCache.add(*resource);
1013 
1014     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1015         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, resource-&gt;initiatorName(), frame());
1016 
1017     return resource;
1018 }
1019 
1020 static void logRevalidation(const String&amp; reason, DiagnosticLoggingClient&amp; logClient)
1021 {
1022     logClient.logDiagnosticMessage(DiagnosticLoggingKeys::cachedResourceRevalidationReasonKey(), reason, ShouldSample::Yes);
1023 }
1024 
1025 static void logResourceRevalidationDecision(CachedResource::RevalidationDecision reason, const Frame* frame)
1026 {
1027     if (!frame || !frame-&gt;page())
1028         return;
1029     auto&amp; logClient = frame-&gt;page()-&gt;diagnosticLoggingClient();
1030     switch (reason) {
1031     case CachedResource::RevalidationDecision::No:
1032         break;
1033     case CachedResource::RevalidationDecision::YesDueToExpired:
1034         logRevalidation(DiagnosticLoggingKeys::isExpiredKey(), logClient);
1035         break;
1036     case CachedResource::RevalidationDecision::YesDueToNoStore:
1037         logRevalidation(DiagnosticLoggingKeys::noStoreKey(), logClient);
1038         break;
1039     case CachedResource::RevalidationDecision::YesDueToNoCache:
1040         logRevalidation(DiagnosticLoggingKeys::noCacheKey(), logClient);
1041         break;
1042     case CachedResource::RevalidationDecision::YesDueToCachePolicy:
1043         logRevalidation(DiagnosticLoggingKeys::reloadKey(), logClient);
1044         break;
1045     }
1046 }
1047 
1048 CachedResourceLoader::RevalidationPolicy CachedResourceLoader::determineRevalidationPolicy(CachedResource::Type type, CachedResourceRequest&amp; cachedResourceRequest, CachedResource* existingResource, ForPreload forPreload, DeferOption defer) const
1049 {
1050     auto&amp; request = cachedResourceRequest.resourceRequest();
1051 
1052     if (!existingResource)
1053         return Load;
1054 
1055     if (request.cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1056         return Load;
1057 
1058     if (request.cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData)
1059         return Reload;
1060 
1061 #if ENABLE(SERVICE_WORKER)
1062     // FIXME: We should validate/specify this behavior.
1063     if (cachedResourceRequest.options().serviceWorkerRegistrationIdentifier != existingResource-&gt;options().serviceWorkerRegistrationIdentifier) {
1064         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading because selected service worker differs&quot;);
1065         return Reload;
1066     }
1067 #endif
1068 
1069     // We already have a preload going for this URL.
1070     if (forPreload == ForPreload::Yes &amp;&amp; existingResource-&gt;isPreloaded())
1071         return Use;
1072 
1073     // If the same URL has been loaded as a different type, we need to reload.
1074     if (existingResource-&gt;type() != type) {
1075         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to type mismatch.&quot;);
1076         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonTypeMismatchKey());
1077         return Reload;
1078     }
1079 
1080     if (!existingResource-&gt;varyHeaderValuesMatch(request))
1081         return Reload;
1082 
1083     auto* textDecoder = existingResource-&gt;textResourceDecoder();
1084     if (textDecoder &amp;&amp; !textDecoder-&gt;hasEqualEncodingForCharset(cachedResourceRequest.charset())) {
1085         if (!existingResource-&gt;hasUnknownEncoding())
1086             return Reload;
1087         existingResource-&gt;setHasUnknownEncoding(false);
1088         existingResource-&gt;setEncoding(cachedResourceRequest.charset());
1089     }
1090 
1091     // FIXME: We should use the same cache policy for all resource types. The raw resource policy is overly strict
1092     //        while the normal subresource policy is too loose.
1093     if (existingResource-&gt;isMainOrMediaOrIconOrRawResource() &amp;&amp; frame()) {
1094         bool strictPolicyDisabled = frame()-&gt;loader().isStrictRawResourceValidationPolicyDisabledForTesting();
1095         bool canReuseRawResource = strictPolicyDisabled || downcast&lt;CachedRawResource&gt;(*existingResource).canReuse(request);
1096         if (!canReuseRawResource)
1097             return Reload;
1098     }
1099 
1100     // Conditional requests should have failed canReuse check.
1101     ASSERT(!request.isConditional());
1102 
1103     // Do not load from cache if images are not enabled. The load for this image will be blocked in CachedImage::load.
1104     if (defer == DeferOption::DeferredByClient)
1105         return Reload;
1106 
1107     // Don&#39;t reload resources while pasting or if cache mode allows stale resources.
1108     if (m_allowStaleResources || cachedResourceRequest.options().cache == FetchOptions::Cache::ForceCache || cachedResourceRequest.options().cache == FetchOptions::Cache::OnlyIfCached)
1109         return Use;
1110 
1111     ASSERT(cachedResourceRequest.options().cache == FetchOptions::Cache::Default || cachedResourceRequest.options().cache == FetchOptions::Cache::NoCache);
1112 
1113     // Always use preloads.
1114     if (existingResource-&gt;isPreloaded())
1115         return Use;
1116 
1117     // We can find resources that are being validated from cache only when validation is just successfully completing.
1118     if (existingResource-&gt;validationCompleting())
1119         return Use;
1120     ASSERT(!existingResource-&gt;validationInProgress());
1121 
1122     auto cachePolicy = this-&gt;cachePolicy(type, request.url());
1123 
1124     // Validate the redirect chain.
1125     bool cachePolicyIsHistoryBuffer = cachePolicy == CachePolicyHistoryBuffer;
1126     if (!existingResource-&gt;redirectChainAllowsReuse(cachePolicyIsHistoryBuffer ? ReuseExpiredRedirection : DoNotReuseExpiredRedirection)) {
1127         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to not cached or expired redirections.&quot;);
1128         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonRedirectChainKey());
1129         return Reload;
1130     }
1131 
1132     // CachePolicyHistoryBuffer uses the cache except if this is a main resource with &quot;cache-control: no-store&quot;.
1133     if (cachePolicyIsHistoryBuffer) {
1134         // FIXME: Ignoring &quot;cache-control: no-cache&quot; for sub-resources on history navigation but not the main
1135         // resource is inconsistent. We should probably harmonize this.
1136         if (!existingResource-&gt;response().cacheControlContainsNoStore() || type != CachedResource::Type::MainResource)
1137             return Use;
1138     }
1139 
1140     // Don&#39;t reuse resources with Cache-control: no-store.
1141     if (existingResource-&gt;response().cacheControlContainsNoStore()) {
1142         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to Cache-control: no-store.&quot;);
1143         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonNoStoreKey());
1144         return Reload;
1145     }
1146 
1147     // If credentials were sent with the previous request and won&#39;t be
1148     // with this one, or vice versa, re-fetch the resource.
1149     //
1150     // This helps with the case where the server sends back
1151     // &quot;Access-Control-Allow-Origin: *&quot; all the time, but some of the
1152     // client&#39;s requests are made without CORS and some with.
1153     if (existingResource-&gt;resourceRequest().allowCookies() != request.allowCookies() || existingResource-&gt;options().credentials != cachedResourceRequest.options().credentials) {
1154         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to difference in credentials settings.&quot;);
1155         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonCredentialSettingsKey());
1156         return Reload;
1157     }
1158 
1159     // During the initial load, avoid loading the same resource multiple times for a single document, even if the cache policies would tell us to.
1160     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; m_validatedURLs.contains(existingResource-&gt;url()))
1161         return Use;
1162 
1163     // CachePolicyReload always reloads
1164     if (cachePolicy == CachePolicyReload) {
1165         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to CachePolicyReload.&quot;);
1166         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonReloadKey());
1167         return Reload;
1168     }
1169 
1170     // We&#39;ll try to reload the resource if it failed last time.
1171     if (existingResource-&gt;errorOccurred()) {
1172         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicye reloading due to resource being in the error state&quot;);
1173         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonErrorKey());
1174         return Reload;
1175     }
1176 
1177     if (existingResource-&gt;isLoading()) {
1178         // Do not use cached main resources that are still loading because sharing
1179         // loading CachedResources in this case causes issues with regards to cancellation.
1180         // If one of the DocumentLoader clients decides to cancel the load, then the load
1181         // would be cancelled for all other DocumentLoaders as well.
1182         if (type == CachedResource::Type::MainResource)
1183             return Reload;
1184         // For cached subresources that are still loading we ignore the cache policy.
1185         return Use;
1186     }
1187 
1188     auto revalidationDecision = existingResource-&gt;makeRevalidationDecision(cachePolicy);
1189     logResourceRevalidationDecision(revalidationDecision, frame());
1190 
1191     // Check if the cache headers requires us to revalidate (cache expiration for example).
1192     if (revalidationDecision != CachedResource::RevalidationDecision::No) {
1193         // See if the resource has usable ETag or Last-modified headers.
1194         if (existingResource-&gt;canUseCacheValidator())
1195             return Revalidate;
1196 
1197         // No, must reload.
1198         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.&quot;);
1199         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());
1200         return Reload;
1201     }
1202 
1203     return Use;
1204 }
1205 
1206 void CachedResourceLoader::printAccessDeniedMessage(const URL&amp; url) const
1207 {
1208     if (url.isNull())
1209         return;
1210 
1211     if (!frame())
1212         return;
1213 
1214     String message;
1215     if (!m_document || m_document-&gt;url().isNull())
1216         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &#39;.&#39;);
1217     else
1218         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &quot; from origin &quot;, m_document-&gt;origin(), &quot;. Domains, protocols and ports must match.\n&quot;);
1219 
1220     frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
1221 }
1222 
1223 void CachedResourceLoader::setAutoLoadImages(bool enable)
1224 {
1225     if (enable == m_autoLoadImages)
1226         return;
1227 
1228     m_autoLoadImages = enable;
1229 
1230     if (!m_autoLoadImages)
1231         return;
1232 
1233     reloadImagesIfNotDeferred();
1234 }
1235 
1236 void CachedResourceLoader::setImagesEnabled(bool enable)
1237 {
1238     if (enable == m_imagesEnabled)
1239         return;
1240 
1241     m_imagesEnabled = enable;
1242 
1243     if (!m_imagesEnabled)
1244         return;
1245 
1246     reloadImagesIfNotDeferred();
1247 }
1248 
1249 bool CachedResourceLoader::clientDefersImage(const URL&amp;) const
1250 {
1251     return !m_imagesEnabled;
1252 }
1253 
1254 bool CachedResourceLoader::shouldPerformImageLoad(const URL&amp; url) const
1255 {
1256     return m_autoLoadImages || url.protocolIsData();
1257 }
1258 
1259 bool CachedResourceLoader::shouldDeferImageLoad(const URL&amp; url) const
1260 {
1261     return clientDefersImage(url) || !shouldPerformImageLoad(url);
1262 }
1263 
1264 void CachedResourceLoader::reloadImagesIfNotDeferred()
1265 {
1266     for (auto&amp; resource : m_documentResources.values()) {
1267         if (is&lt;CachedImage&gt;(*resource) &amp;&amp; resource-&gt;stillNeedsLoad() &amp;&amp; !clientDefersImage(resource-&gt;url()))
1268             downcast&lt;CachedImage&gt;(*resource).load(*this);
1269     }
1270 }
1271 
1272 CachePolicy CachedResourceLoader::cachePolicy(CachedResource::Type type, const URL&amp; url) const
1273 {
1274     Frame* frame = this-&gt;frame();
1275     if (!frame)
1276         return CachePolicyVerify;
1277 
1278     if (type != CachedResource::Type::MainResource)
1279         return frame-&gt;loader().subresourceCachePolicy(url);
1280 
1281     if (Page* page = frame-&gt;page()) {
1282         if (page-&gt;isResourceCachingDisabled())
1283             return CachePolicyReload;
1284     }
1285 
1286     switch (frame-&gt;loader().loadType()) {
1287     case FrameLoadType::ReloadFromOrigin:
1288     case FrameLoadType::Reload:
1289         return CachePolicyReload;
1290     case FrameLoadType::Back:
1291     case FrameLoadType::Forward:
1292     case FrameLoadType::IndexedBackForward:
1293         // Do not revalidate cached main resource on back/forward navigation.
1294         return CachePolicyHistoryBuffer;
1295     default:
1296         return CachePolicyVerify;
1297     }
1298 }
1299 
1300 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1301 {
1302     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
1303     RefPtr&lt;Document&gt; protectDocument(m_document);
1304 
1305     ASSERT(shouldPerformPostLoadActions || type == LoadCompletionType::Cancel);
1306 
1307     if (frame())
1308         frame()-&gt;loader().loadDone(type);
1309 
1310     if (shouldPerformPostLoadActions)
1311         performPostLoadActions();
1312 
1313     if (!m_garbageCollectDocumentResourcesTimer.isActive())
1314         m_garbageCollectDocumentResourcesTimer.startOneShot(0_s);
1315 }
1316 
1317 // Garbage collecting m_documentResources is a workaround for the
1318 // CachedResourceHandles on the RHS being strong references. Ideally this
1319 // would be a weak map, however CachedResourceHandles perform additional
1320 // bookkeeping on CachedResources, so instead pseudo-GC them -- when the
1321 // reference count reaches 1, m_documentResources is the only reference, so
1322 // remove it from the map.
1323 void CachedResourceLoader::garbageCollectDocumentResources()
1324 {
1325     LOG(ResourceLoading, &quot;CachedResourceLoader %p garbageCollectDocumentResources&quot;, this);
1326 
1327     typedef Vector&lt;String, 10&gt; StringVector;
1328     StringVector resourcesToDelete;
1329 
1330     for (auto&amp; resource : m_documentResources) {
1331         LOG(ResourceLoading, &quot;  cached resource %p - hasOneHandle %d&quot;, resource.value.get(), resource.value-&gt;hasOneHandle());
1332 
1333         if (resource.value-&gt;hasOneHandle())
1334             resourcesToDelete.append(resource.key);
1335     }
1336 
1337     for (auto&amp; resource : resourcesToDelete)
1338         m_documentResources.remove(resource);
1339 }
1340 
1341 void CachedResourceLoader::performPostLoadActions()
1342 {
1343     platformStrategies()-&gt;loaderStrategy()-&gt;servePendingRequests();
1344 }
1345 
1346 void CachedResourceLoader::incrementRequestCount(const CachedResource&amp; resource)
1347 {
1348     if (resource.ignoreForRequestCount())
1349         return;
1350 
1351     ++m_requestCount;
1352 }
1353 
1354 void CachedResourceLoader::decrementRequestCount(const CachedResource&amp; resource)
1355 {
1356     if (resource.ignoreForRequestCount())
1357         return;
1358 
1359     --m_requestCount;
1360     ASSERT(m_requestCount &gt; -1);
1361 }
1362 
1363 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1364 {
1365     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1366         request.setCharset(m_document-&gt;charset());
1367 
1368     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1369     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1370         auto resourceValue = resource.value();
1371         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1372         if (type == CachedResource::Type::FontResource)
1373             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1374         resourceValue-&gt;increasePreloadCount();
1375 
1376         if (!m_preloads)
1377             m_preloads = std::make_unique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1378         m_preloads-&gt;add(resourceValue.get());
1379     }
1380     return resource;
1381 }
1382 
1383 void CachedResourceLoader::warnUnusedPreloads()
1384 {
1385     if (!m_preloads)
1386         return;
1387     for (const auto&amp; resource : *m_preloads) {
1388         if (resource &amp;&amp; resource-&gt;isLinkPreload() &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced &amp;&amp; document()) {
1389             document()-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Warning,
1390                 &quot;The resource &quot; + resource-&gt;url().string() +
1391                 &quot; was preloaded using link preload but not used within a few seconds from the window&#39;s load event. Please make sure it wasn&#39;t preloaded for nothing.&quot;);
1392         }
1393     }
1394 }
1395 
1396 bool CachedResourceLoader::isPreloaded(const String&amp; urlString) const
1397 {
1398     const URL&amp; url = m_document-&gt;completeURL(urlString);
1399 
1400     if (m_preloads) {
1401         for (auto&amp; resource : *m_preloads) {
1402             if (resource-&gt;url() == url)
1403                 return true;
1404         }
1405     }
1406     return false;
1407 }
1408 
1409 void CachedResourceLoader::clearPreloads(ClearPreloadsMode mode)
1410 {
1411     if (!m_preloads)
1412         return;
1413 
1414     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; remainingLinkPreloads;
1415     for (auto* resource : *m_preloads) {
1416         ASSERT(resource);
1417         if (mode == ClearPreloadsMode::ClearSpeculativePreloads &amp;&amp; resource-&gt;isLinkPreload()) {
1418             if (!remainingLinkPreloads)
1419                 remainingLinkPreloads = std::make_unique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1420             remainingLinkPreloads-&gt;add(resource);
1421             continue;
1422         }
1423         resource-&gt;decreasePreloadCount();
1424         bool deleted = resource-&gt;deleteIfPossible();
1425         if (!deleted &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced)
1426             MemoryCache::singleton().remove(*resource);
1427     }
1428     m_preloads = WTFMove(remainingLinkPreloads);
1429 }
1430 
1431 const ResourceLoaderOptions&amp; CachedResourceLoader::defaultCachedResourceOptions()
1432 {
1433     static NeverDestroyed&lt;ResourceLoaderOptions&gt; options(
1434         SendCallbackPolicy::SendCallbacks,
1435         ContentSniffingPolicy::SniffContent,
1436         DataBufferingPolicy::BufferData,
1437         StoredCredentialsPolicy::Use,
1438         ClientCredentialPolicy::MayAskClientForCredentials,
1439         FetchOptions::Credentials::Include,
1440         SecurityCheckPolicy::DoSecurityCheck,
1441         FetchOptions::Mode::NoCors,
1442         CertificateInfoPolicy::DoNotIncludeCertificateInfo,
1443         ContentSecurityPolicyImposition::DoPolicyCheck,
1444         DefersLoadingPolicy::AllowDefersLoading,
1445         CachingPolicy::AllowCaching);
1446     return options;
1447 }
1448 
1449 bool CachedResourceLoader::isAlwaysOnLoggingAllowed() const
1450 {
1451     return m_documentLoader ? m_documentLoader-&gt;isAlwaysOnLoggingAllowed() : true;
1452 }
1453 
1454 }
    </pre>
  </body>
</html>