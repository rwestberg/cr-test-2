<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeviceOrientationEvent.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">   6  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.</span>
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
</pre>
<hr />
<pre>
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSStyleDeclaration.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CachedCSSStyleSheet.h&quot;
  41 #include &quot;CachedFrame.h&quot;
  42 #include &quot;CachedResourceLoader.h&quot;
  43 #include &quot;CanvasRenderingContext2D.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;Comment.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ComposedTreeIterator.h&quot;
  49 #include &quot;CompositionEvent.h&quot;
  50 #include &quot;ConstantPropertyMap.h&quot;
  51 #include &quot;ContentSecurityPolicy.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;CustomElementReactionQueue.h&quot;
  54 #include &quot;CustomElementRegistry.h&quot;
  55 #include &quot;CustomEvent.h&quot;

  56 #include &quot;DOMImplementation.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DateComponents.h&quot;
  59 #include &quot;DebugPageOverlays.h&quot;
<span class="line-removed">  60 #include &quot;DocumentAnimationScheduler.h&quot;</span>
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;Editing.h&quot;
  67 #include &quot;Editor.h&quot;
  68 #include &quot;ElementIterator.h&quot;
  69 #include &quot;EventHandler.h&quot;
  70 #include &quot;ExtensionStyleSheets.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;FocusEvent.h&quot;
  73 #include &quot;FontFaceSet.h&quot;
  74 #include &quot;FormController.h&quot;
  75 #include &quot;Frame.h&quot;
  76 #include &quot;FrameLoader.h&quot;
  77 #include &quot;FrameLoaderClient.h&quot;
  78 #include &quot;FrameView.h&quot;

  79 #include &quot;GenericCachedHTMLCollection.h&quot;
  80 #include &quot;HTMLAllCollection.h&quot;
  81 #include &quot;HTMLAnchorElement.h&quot;
  82 #include &quot;HTMLAttachmentElement.h&quot;
  83 #include &quot;HTMLBaseElement.h&quot;
  84 #include &quot;HTMLBodyElement.h&quot;
  85 #include &quot;HTMLCanvasElement.h&quot;
  86 #include &quot;HTMLDocument.h&quot;
  87 #include &quot;HTMLElementFactory.h&quot;
  88 #include &quot;HTMLFormControlElement.h&quot;
  89 #include &quot;HTMLFrameOwnerElement.h&quot;
  90 #include &quot;HTMLFrameSetElement.h&quot;
  91 #include &quot;HTMLHeadElement.h&quot;
  92 #include &quot;HTMLHtmlElement.h&quot;
  93 #include &quot;HTMLImageElement.h&quot;
  94 #include &quot;HTMLInputElement.h&quot;
  95 #include &quot;HTMLLinkElement.h&quot;
  96 #include &quot;HTMLMediaElement.h&quot;
  97 #include &quot;HTMLNameCollection.h&quot;
  98 #include &quot;HTMLParserIdioms.h&quot;
  99 #include &quot;HTMLPictureElement.h&quot;
 100 #include &quot;HTMLPlugInElement.h&quot;
 101 #include &quot;HTMLScriptElement.h&quot;
 102 #include &quot;HTMLStyleElement.h&quot;
 103 #include &quot;HTMLTitleElement.h&quot;
 104 #include &quot;HTMLUnknownElement.h&quot;
 105 #include &quot;HTTPHeaderNames.h&quot;
 106 #include &quot;HTTPParsers.h&quot;
 107 #include &quot;HashChangeEvent.h&quot;
 108 #include &quot;History.h&quot;
 109 #include &quot;HitTestResult.h&quot;
 110 #include &quot;ImageBitmapRenderingContext.h&quot;
 111 #include &quot;ImageLoader.h&quot;
 112 #include &quot;InspectorInstrumentation.h&quot;
 113 #include &quot;IntersectionObserver.h&quot;
 114 #include &quot;JSCustomElementInterface.h&quot;
<span class="line-removed"> 115 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 116 #include &quot;JSLazyEventListener.h&quot;
 117 #include &quot;KeyboardEvent.h&quot;
 118 #include &quot;KeyframeEffect.h&quot;
 119 #include &quot;LayoutDisallowedScope.h&quot;
 120 #include &quot;LibWebRTCProvider.h&quot;
 121 #include &quot;LoaderStrategy.h&quot;
 122 #include &quot;Logging.h&quot;
 123 #include &quot;MediaCanStartListener.h&quot;
 124 #include &quot;MediaProducer.h&quot;
 125 #include &quot;MediaQueryList.h&quot;
 126 #include &quot;MediaQueryMatcher.h&quot;

 127 #include &quot;MessageEvent.h&quot;
 128 #include &quot;Microtasks.h&quot;
 129 #include &quot;MouseEventWithHitTestResults.h&quot;
 130 #include &quot;MutationEvent.h&quot;
 131 #include &quot;NameNodeList.h&quot;
 132 #include &quot;NavigationDisabler.h&quot;
 133 #include &quot;NavigationScheduler.h&quot;
 134 #include &quot;NestingLevelIncrementer.h&quot;
 135 #include &quot;NodeIterator.h&quot;
 136 #include &quot;NodeRareData.h&quot;
 137 #include &quot;NodeWithIndex.h&quot;
<span class="line-removed"> 138 #include &quot;OriginAccessEntry.h&quot;</span>
 139 #include &quot;OverflowEvent.h&quot;
 140 #include &quot;PageConsoleClient.h&quot;
 141 #include &quot;PageGroup.h&quot;
 142 #include &quot;PageTransitionEvent.h&quot;
 143 #include &quot;PaintWorkletGlobalScope.h&quot;
 144 #include &quot;PlatformLocale.h&quot;
 145 #include &quot;PlatformMediaSessionManager.h&quot;
 146 #include &quot;PlatformScreen.h&quot;
 147 #include &quot;PlatformStrategies.h&quot;
 148 #include &quot;PlugInsResources.h&quot;
 149 #include &quot;PluginDocument.h&quot;
 150 #include &quot;PointerLockController.h&quot;
 151 #include &quot;PolicyChecker.h&quot;
 152 #include &quot;PopStateEvent.h&quot;
 153 #include &quot;ProcessingInstruction.h&quot;
 154 #include &quot;PublicSuffix.h&quot;
 155 #include &quot;Quirks.h&quot;
 156 #include &quot;RealtimeMediaSourceCenter.h&quot;
 157 #include &quot;RenderChildIterator.h&quot;
 158 #include &quot;RenderInline.h&quot;
 159 #include &quot;RenderLayerCompositor.h&quot;
 160 #include &quot;RenderLineBreak.h&quot;
 161 #include &quot;RenderTreeUpdater.h&quot;
 162 #include &quot;RenderView.h&quot;
 163 #include &quot;RenderWidget.h&quot;
 164 #include &quot;RequestAnimationFrameCallback.h&quot;

 165 #include &quot;ResourceLoadObserver.h&quot;
 166 #include &quot;RuntimeApplicationChecks.h&quot;
 167 #include &quot;RuntimeEnabledFeatures.h&quot;
 168 #include &quot;SVGDocumentExtensions.h&quot;
 169 #include &quot;SVGElement.h&quot;
 170 #include &quot;SVGElementFactory.h&quot;
 171 #include &quot;SVGNames.h&quot;
 172 #include &quot;SVGSVGElement.h&quot;
 173 #include &quot;SVGTitleElement.h&quot;
 174 #include &quot;SVGUseElement.h&quot;
 175 #include &quot;SVGZoomEvent.h&quot;
 176 #include &quot;SWClientConnection.h&quot;
 177 #include &quot;SchemeRegistry.h&quot;
 178 #include &quot;ScopedEventQueue.h&quot;
 179 #include &quot;ScriptController.h&quot;
 180 #include &quot;ScriptDisallowedScope.h&quot;
 181 #include &quot;ScriptModuleLoader.h&quot;
 182 #include &quot;ScriptRunner.h&quot;
 183 #include &quot;ScriptSourceCode.h&quot;
 184 #include &quot;ScriptState.h&quot;
</pre>
<hr />
<pre>
 233 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 234 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 235 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 236 #include &lt;JavaScriptCore/VM.h&gt;
 237 #include &lt;ctime&gt;
 238 #include &lt;wtf/IsoMallocInlines.h&gt;
 239 #include &lt;wtf/Language.h&gt;
 240 #include &lt;wtf/NeverDestroyed.h&gt;
 241 #include &lt;wtf/SetForScope.h&gt;
 242 #include &lt;wtf/SystemTracing.h&gt;
 243 #include &lt;wtf/UUID.h&gt;
 244 #include &lt;wtf/text/StringBuffer.h&gt;
 245 #include &lt;wtf/text/TextStream.h&gt;
 246 
 247 #if PLATFORM(JAVA)
 248 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 249 #endif
 250 
 251 #if ENABLE(DEVICE_ORIENTATION)
 252 #include &quot;DeviceMotionEvent.h&quot;

 253 #include &quot;DeviceOrientationEvent.h&quot;
 254 #endif
 255 
 256 #if ENABLE(FULLSCREEN_API)
 257 #include &quot;RenderFullScreen.h&quot;
 258 #endif
 259 
 260 #if ENABLE(INDEXED_DATABASE)
 261 #include &quot;IDBConnectionProxy.h&quot;
 262 #include &quot;IDBOpenDBRequest.h&quot;
 263 #endif
 264 
 265 #if PLATFORM(IOS_FAMILY)

 266 #include &quot;CSSFontSelector.h&quot;

 267 #include &quot;DeviceMotionClientIOS.h&quot;
 268 #include &quot;DeviceMotionController.h&quot;
 269 #include &quot;DeviceOrientationClientIOS.h&quot;
 270 #include &quot;DeviceOrientationController.h&quot;
 271 #include &quot;Geolocation.h&quot;
 272 #include &quot;Navigator.h&quot;
 273 #include &quot;NavigatorGeolocation.h&quot;
<span class="line-removed"> 274 #include &quot;WKContentObservation.h&quot;</span>
<span class="line-removed"> 275 #include &quot;WKContentObservationInternal.h&quot;</span>
 276 #endif
 277 
 278 #if ENABLE(IOS_GESTURE_EVENTS)
 279 #include &quot;GestureEvent.h&quot;
 280 #endif
 281 
 282 #if ENABLE(MATHML)
 283 #include &quot;MathMLElement.h&quot;
 284 #include &quot;MathMLElementFactory.h&quot;
 285 #include &quot;MathMLNames.h&quot;
 286 #endif
 287 
 288 #if ENABLE(MEDIA_SESSION)
 289 #include &quot;MediaSession.h&quot;
 290 #endif
 291 
 292 #if USE(QUICK_LOOK)
 293 #include &quot;QuickLook.h&quot;
 294 #endif
 295 
 296 #if ENABLE(TOUCH_EVENTS)
 297 #include &quot;TouchEvent.h&quot;
 298 #endif
 299 
 300 #if ENABLE(VIDEO_TRACK)
 301 #include &quot;CaptionUserPreferences.h&quot;
 302 #endif
 303 
 304 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 305 #include &quot;MediaPlaybackTargetClient.h&quot;
 306 #endif
 307 
 308 #if ENABLE(XSLT)
 309 #include &quot;XSLTProcessor.h&quot;
 310 #endif
 311 
<span class="line-removed"> 312 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-removed"> 313 #include &quot;MediaStream.h&quot;</span>
<span class="line-removed"> 314 #include &quot;MediaStreamRegistry.h&quot;</span>
<span class="line-removed"> 315 #endif</span>
<span class="line-removed"> 316 </span>
 317 #if ENABLE(WEBGL)
 318 #include &quot;WebGLRenderingContext.h&quot;
 319 #endif
 320 #if ENABLE(WEBGL2)
 321 #include &quot;WebGL2RenderingContext.h&quot;
 322 #endif
 323 #if ENABLE(WEBGPU)
<span class="line-modified"> 324 #include &quot;WebGPURenderingContext.h&quot;</span>
 325 #endif
<span class="line-modified"> 326 #if ENABLE(WEBMETAL)</span>
<span class="line-modified"> 327 #include &quot;WebMetalRenderingContext.h&quot;</span>

 328 #endif
 329 
 330 namespace WebCore {
 331 
 332 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 333 
 334 using namespace HTMLNames;
 335 using namespace PAL;
 336 using namespace WTF::Unicode;
 337 
 338 static const unsigned cMaxWriteRecursionDepth = 21;
 339 bool Document::hasEverCreatedAnAXObjectCache = false;
<span class="line-modified"> 340 </span>
<span class="line-removed"> 341 unsigned ScriptDisallowedScope::LayoutAssertionDisableScope::s_layoutAssertionDisableCount = 0;</span>
 342 
 343 struct FrameFlatteningLayoutDisallower {
 344     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 345         : m_frameView(frameView)
 346         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 347     {
 348         if (m_disallowLayout)
 349             m_frameView.startDisallowingLayout();
 350     }
 351 
 352     ~FrameFlatteningLayoutDisallower()
 353     {
 354         if (m_disallowLayout)
 355             m_frameView.endDisallowingLayout();
 356     }
 357 
 358 private:
 359     FrameView&amp; m_frameView;
 360     bool m_disallowLayout { false };
 361 };
 362 




 363 // DOM Level 2 says (letters added):
 364 //
 365 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 366 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 367 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 368 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 369 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 370 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 371 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 372 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 373 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 374 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 375 //
 376 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 377 
 378 static inline bool isValidNameStart(UChar32 c)
 379 {
 380     // rule (e) above
 381     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 382         return true;
</pre>
<hr />
<pre>
 508     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 509     return documents;
 510 }
 511 
 512 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 513 {
 514     return allDocumentsMap().values();
 515 }
 516 
 517 static inline int currentOrientation(Frame* frame)
 518 {
 519 #if ENABLE(ORIENTATION_EVENTS)
 520     if (frame)
 521         return frame-&gt;orientation();
 522 #else
 523     UNUSED_PARAM(frame);
 524 #endif
 525     return 0;
 526 }
 527 
<span class="line-modified"> 528 Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
 529     : ContainerNode(*this, CreateDocument)
 530     , TreeScope(*this)
 531     , FrameDestructionObserver(frame)
 532 #if ENABLE(IOS_TOUCH_EVENTS)
 533     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 534 #endif
 535     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 536     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 537     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 538     , m_domTreeVersion(++s_globalTreeVersion)
<span class="line-modified"> 539     , m_styleScope(std::make_unique&lt;Style::Scope&gt;(*this))</span>
<span class="line-modified"> 540     , m_extensionStyleSheets(std::make_unique&lt;ExtensionStyleSheets&gt;(*this))</span>
<span class="line-modified"> 541     , m_visitedLinkState(std::make_unique&lt;VisitedLinkState&gt;(*this))</span>
<span class="line-modified"> 542     , m_markers(std::make_unique&lt;DocumentMarkerController&gt;(*this))</span>
 543     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 544     , m_documentCreationTime(MonotonicTime::now())
<span class="line-modified"> 545     , m_scriptRunner(std::make_unique&lt;ScriptRunner&gt;(*this))</span>
<span class="line-modified"> 546     , m_moduleLoader(std::make_unique&lt;ScriptModuleLoader&gt;(*this))</span>
 547 #if ENABLE(XSLT)
 548     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 549 #endif
 550     , m_xmlVersion(&quot;1.0&quot;_s)
<span class="line-modified"> 551     , m_constantPropertyMap(std::make_unique&lt;ConstantPropertyMap&gt;(*this))</span>
 552     , m_documentClasses(documentClasses)
 553     , m_eventQueue(*this)



 554 #if ENABLE(INTERSECTION_OBSERVER)
 555     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)

 556 #endif
 557     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 558 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified"> 559     , m_deviceMotionClient(std::make_unique&lt;DeviceMotionClientIOS&gt;())</span>
<span class="line-modified"> 560     , m_deviceMotionController(std::make_unique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))</span>
<span class="line-modified"> 561     , m_deviceOrientationClient(std::make_unique&lt;DeviceOrientationClientIOS&gt;())</span>
<span class="line-modified"> 562     , m_deviceOrientationController(std::make_unique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))</span>
 563 #endif
 564     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 565     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 566     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 567     , m_fontSelector(CSSFontSelector::create(*this))
 568     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 569     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 570     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 571     , m_isSynthesized(constructionFlags &amp; Synthesized)
 572     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 573     , m_orientationNotifier(currentOrientation(frame))

 574     , m_identifier(DocumentIdentifier::generate())
 575     , m_undoManager(UndoManager::create(*this))
 576 {


 577     auto addResult = allDocumentsMap().add(m_identifier, this);
 578     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 579 
 580     // We depend on the url getting immediately set in subframes, but we
 581     // also depend on the url NOT getting immediately set in opened windows.
 582     // See fast/dom/early-frame-url.html
 583     // and fast/dom/location-new-window-no-crash.html, respectively.
 584     // FIXME: Can/should we unify this behavior?
 585     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 586         setURL(url);
 587 
 588     m_cachedResourceLoader-&gt;setDocument(this);
 589 
 590     resetLinkColor();
 591     resetVisitedLinkColor();
 592     resetActiveLinkColor();
 593 
 594     initSecurityContext();
 595     initDNSPrefetch();
 596 
 597     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 598 
 599     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 600         nodeListAndCollectionCount = 0;
 601 
 602     InspectorInstrumentation::addEventListenersToNode(*this);
 603 }
 604 
<span class="line-removed"> 605 #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607 static bool isAttributeOnAllOwners(const WebCore::QualifiedName&amp; attribute, const WebCore::QualifiedName&amp; prefixedAttribute, const HTMLFrameOwnerElement* owner)</span>
<span class="line-removed"> 608 {</span>
<span class="line-removed"> 609     if (!owner)</span>
<span class="line-removed"> 610         return true;</span>
<span class="line-removed"> 611     do {</span>
<span class="line-removed"> 612         if (!(owner-&gt;hasAttribute(attribute) || owner-&gt;hasAttribute(prefixedAttribute)))</span>
<span class="line-removed"> 613             return false;</span>
<span class="line-removed"> 614     } while ((owner = owner-&gt;document().ownerElement()));</span>
<span class="line-removed"> 615     return true;</span>
<span class="line-removed"> 616 }</span>
<span class="line-removed"> 617 </span>
<span class="line-removed"> 618 #endif</span>
<span class="line-removed"> 619 </span>
 620 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 621 {
<span class="line-modified"> 622     auto document = adoptRef(*new Document(nullptr, URL()));</span>
 623     document-&gt;setContextDocument(contextDocument);
 624     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 625     return document;
 626 }
 627 





 628 Document::~Document()
 629 {
 630     if (m_logger)
 631         m_logger-&gt;removeObserver(*this);
 632 
 633     ASSERT(allDocumentsMap().contains(m_identifier));
 634     allDocumentsMap().remove(m_identifier);
 635     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 636     removeFromContextsMap();
 637 
 638     ASSERT(!renderView());
 639     ASSERT(m_pageCacheState != InPageCache);
 640     ASSERT(m_ranges.isEmpty());
 641     ASSERT(!m_parentTreeScope);
 642     ASSERT(!m_disabledFieldsetElementsCount);
 643     ASSERT(m_inDocumentShadowRoots.isEmpty());
 644 
 645 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 646     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 647     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
</pre>
<hr />
<pre>
 691     stopAllMediaPlayback();
 692 #endif
 693 
 694     // We must call clearRareData() here since a Document class inherits TreeScope
 695     // as well as Node. See a comment on TreeScope.h for the reason.
 696     if (hasRareData())
 697         clearRareData();
 698 
 699     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 700     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 701     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 702 
 703     for (unsigned count : m_nodeListAndCollectionCounts)
 704         ASSERT_UNUSED(count, !count);
 705 }
 706 
 707 void Document::removedLastRef()
 708 {
 709     ASSERT(!m_deletionHasBegun);
 710     if (m_referencingNodeCount) {




 711         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 712         // until after removeDetachedChildren returns, so we protect ourselves.
 713         incrementReferencingNodeCount();
 714 
 715         RELEASE_ASSERT(!hasLivingRenderTree());
 716         // We must make sure not to be retaining any of our children through
 717         // these extra pointers or we will create a reference cycle.
 718         m_focusedElement = nullptr;
 719         m_hoveredElement = nullptr;
 720         m_activeElement = nullptr;
 721         m_titleElement = nullptr;
 722         m_documentElement = nullptr;
 723         m_focusNavigationStartingNode = nullptr;
 724         m_userActionElements.clear();
 725 #if ENABLE(FULLSCREEN_API)
<span class="line-modified"> 726         m_fullScreenElement = nullptr;</span>
<span class="line-removed"> 727         m_fullScreenElementStack.clear();</span>
 728 #endif
 729         m_associatedFormControls.clear();
 730 
 731         m_fontSelector-&gt;clearDocument();
 732         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 733 
 734         detachParser();
 735 
 736         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 737         // so tear down scope information up front to avoid having
 738         // stale references in the map.
 739 
 740         destroyTreeScopeData();
 741         removeDetachedChildren();
 742         m_formController = nullptr;
 743 
 744         m_markers-&gt;detach();
 745 
 746         m_cssCanvasElements.clear();
 747 
 748         commonTeardown();
 749 
 750 #ifndef NDEBUG
 751         // We need to do this right now since selfOnlyDeref() can delete this.
 752         m_inRemovedLastRefFunction = false;
 753 #endif
 754         decrementReferencingNodeCount();
 755     } else {
 756 #ifndef NDEBUG
 757         m_inRemovedLastRefFunction = false;
 758         m_deletionHasBegun = true;
 759 #endif
<span class="line-removed"> 760         m_refCount = 1; // Avoid double destruction through use of RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)</span>
 761         delete this;
 762     }
 763 }
 764 
 765 void Document::commonTeardown()
 766 {
 767     if (svgExtensions())
 768         accessSVGExtensions().pauseAnimations();
 769 
 770     clearScriptedAnimationController();
 771 }
 772 
 773 Element* Document::elementForAccessKey(const String&amp; key)
 774 {
 775     if (key.isEmpty())
 776         return nullptr;
 777     if (!m_accessKeyCache)
 778         buildAccessKeyCache();
 779     return m_accessKeyCache-&gt;get(key);
 780 }
 781 
 782 void Document::buildAccessKeyCache()
 783 {
<span class="line-modified"> 784     m_accessKeyCache = std::make_unique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {</span>
 785         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 786         for (auto&amp; node : composedTreeDescendants(*this)) {
 787             if (!is&lt;Element&gt;(node))
 788                 continue;
 789             auto&amp; element = downcast&lt;Element&gt;(node);
 790             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 791             if (key.isEmpty())
 792                 continue;
 793             map.add(key, &amp;element);
<span class="line-modified"> 794     }</span>
 795         return map;
 796     }());
 797 }
 798 
 799 void Document::invalidateAccessKeyCacheSlowCase()
 800 {
 801     m_accessKeyCache = nullptr;
 802 }
 803 
 804 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 805 {
 806     if (selectorString.isEmpty())
 807         return Exception { SyntaxError };
 808     if (!m_selectorQueryCache)
<span class="line-modified"> 809         m_selectorQueryCache = std::make_unique&lt;SelectorQueryCache&gt;();</span>
 810     return m_selectorQueryCache-&gt;add(selectorString, *this);
 811 }
 812 
 813 void Document::clearSelectorQueryCache()
 814 {
 815     m_selectorQueryCache = nullptr;
 816 }
 817 
 818 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 819 {
 820     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 821     // the policy defined elsewhere.
 822     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 823         return;
 824 
 825     m_referrerPolicy = referrerPolicy;
 826 }
 827 
 828 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 829 {
</pre>
<hr />
<pre>
 854 }
 855 
 856 void Document::resetLinkColor()
 857 {
 858     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 859 }
 860 
 861 void Document::resetVisitedLinkColor()
 862 {
 863     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 864 }
 865 
 866 void Document::resetActiveLinkColor()
 867 {
 868     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 869 }
 870 
 871 DOMImplementation&amp; Document::implementation()
 872 {
 873     if (!m_implementation)
<span class="line-modified"> 874         m_implementation = std::make_unique&lt;DOMImplementation&gt;(*this);</span>
 875     return *m_implementation;
 876 }
 877 
 878 bool Document::hasManifest() const
 879 {
 880     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 881 }
 882 
 883 DocumentType* Document::doctype() const
 884 {
 885     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 886         if (is&lt;DocumentType&gt;(node))
 887             return downcast&lt;DocumentType&gt;(node);
 888     }
 889     return nullptr;
 890 }
 891 
 892 void Document::childrenChanged(const ChildChange&amp; change)
 893 {
 894     ContainerNode::childrenChanged(change);
</pre>
<hr />
<pre>
 901 
 902     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 903     if (newDocumentElement == m_documentElement)
 904         return;
 905     m_documentElement = newDocumentElement;
 906     // The root style used for media query matching depends on the document element.
 907     styleScope().clearResolver();
 908 }
 909 
 910 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 911 {
 912     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 913         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 914         return HTMLUnknownElement::create(name, document);
 915 
 916     auto element = HTMLElement::create(name, document);
 917     element-&gt;setIsCustomElementUpgradeCandidate();
 918     return element;
 919 }
 920 
<span class="line-modified"> 921 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomicString&amp; localName)</span>
 922 {
 923     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 924 }
 925 
<span class="line-modified"> 926 static inline bool isValidHTMLElementName(const AtomicString&amp; localName)</span>
 927 {
 928     return Document::isValidName(localName);
 929 }
 930 
 931 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 932 {
 933     return Document::isValidName(name.localName());
 934 }
 935 
 936 template&lt;typename NameType&gt;
 937 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 938 {
 939     auto element = HTMLElementFactory::createKnownElement(name, document);
 940     if (LIKELY(element))
 941         return Ref&lt;Element&gt; { element.releaseNonNull() };
 942 
 943     if (auto* window = document.domWindow()) {
 944         auto* registry = window-&gt;customElementRegistry();
 945         if (UNLIKELY(registry)) {
 946             if (auto* elementInterface = registry-&gt;findInterface(name))
 947                 return elementInterface-&gt;constructElementWithFallback(document, name);
 948         }
 949     }
 950 
 951     if (UNLIKELY(!isValidHTMLElementName(name)))
 952         return Exception { InvalidCharacterError };
 953 
 954     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 955 }
 956 
<span class="line-modified"> 957 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomicString&amp; name)</span>
 958 {
 959     if (isHTMLDocument())
 960         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 961 
 962     if (isXHTMLDocument())
 963         return createHTMLElementWithNameValidation(*this, name);
 964 
 965     if (!isValidName(name))
 966         return Exception { InvalidCharacterError };
 967 
 968     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
 969 }
 970 
 971 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
 972 {
 973     return DocumentFragment::create(document());
 974 }
 975 
 976 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
 977 {
</pre>
<hr />
<pre>
1009 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1010 {
1011     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1012     return propertySet-&gt;ensureCSSStyleDeclaration();
1013 }
1014 
1015 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1016 {
1017     switch (nodeToImport.nodeType()) {
1018     case DOCUMENT_FRAGMENT_NODE:
1019         if (nodeToImport.isShadowRoot())
1020             break;
1021         FALLTHROUGH;
1022     case ELEMENT_NODE:
1023     case TEXT_NODE:
1024     case CDATA_SECTION_NODE:
1025     case PROCESSING_INSTRUCTION_NODE:
1026     case COMMENT_NODE:
1027         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1028 
<span class="line-modified">1029     case ATTRIBUTE_NODE:</span>
<span class="line-modified">1030         // FIXME: This will &quot;Attr::normalize&quot; child nodes of Attr.</span>
<span class="line-modified">1031         return Ref&lt;Node&gt; { Attr::create(*this, QualifiedName(nullAtom(), downcast&lt;Attr&gt;(nodeToImport).name(), nullAtom()), downcast&lt;Attr&gt;(nodeToImport).value()) };</span>
<span class="line-modified">1032 </span>
1033     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1034     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1035         break;
1036     }
1037 
1038     return Exception { NotSupportedError };
1039 }
1040 
1041 
1042 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1043 {
1044     EventQueueScope scope;
1045 
1046     switch (source.nodeType()) {
1047     case DOCUMENT_NODE:
1048         return Exception { NotSupportedError };
1049     case ATTRIBUTE_NODE: {
1050         auto&amp; attr = downcast&lt;Attr&gt;(source);
1051         if (auto* element = attr.ownerElement()) {
1052             auto result = element-&gt;removeAttributeNode(attr);
</pre>
<hr />
<pre>
1182         { &#39;a&#39;, &#39;z&#39; },
1183         { 0xB7, 0xB7 },
1184         { 0xC0, 0xD6 },
1185         { 0xD8, 0xF6 },
1186         { 0xF8, 0x37D },
1187         { 0x37F, 0x1FFF },
1188         { 0x200C, 0x200D },
1189         { 0x203F, 0x2040 },
1190         { 0x2070, 0x218F },
1191         { 0x2C00, 0x2FEF },
1192         { 0x3001, 0xD7FF },
1193         { 0xF900, 0xFDCF },
1194         { 0xFDF0, 0xFFFD },
1195         { 0x10000, 0xEFFFF },
1196     };
1197 
1198     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1199     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1200 }
1201 
<span class="line-modified">1202 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomicString&amp; localName)</span>
1203 {
1204     if (!isASCIILower(localName[0]))
1205         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1206 
1207     bool containsHyphen = false;
1208     for (auto character : StringView(localName).codePoints()) {
1209         if (isASCIIUpper(character))
1210             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1211         if (!isPotentialCustomElementNameCharacter(character))
1212             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1213         if (character == &#39;-&#39;)
1214             containsHyphen = true;
1215     }
1216 
1217     if (!containsHyphen)
1218         return CustomElementNameValidationStatus::ContainsNoHyphen;
1219 
1220 #if ENABLE(MATHML)
1221     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1222 #else
<span class="line-modified">1223     static NeverDestroyed&lt;const AtomicString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomicString::ConstructFromLiteral);</span>
1224 #endif
1225 
1226     if (localName == SVGNames::color_profileTag-&gt;localName()
1227         || localName == SVGNames::font_faceTag-&gt;localName()
1228         || localName == SVGNames::font_face_formatTag-&gt;localName()
1229         || localName == SVGNames::font_face_nameTag-&gt;localName()
1230         || localName == SVGNames::font_face_srcTag-&gt;localName()
1231         || localName == SVGNames::font_face_uriTag-&gt;localName()
1232         || localName == SVGNames::missing_glyphTag-&gt;localName()
1233         || localName == annotationXmlLocalName)
1234         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1235 
1236     return CustomElementNameValidationStatus::Valid;
1237 }
1238 
<span class="line-modified">1239 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)</span>
1240 {
1241     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1242     if (parseResult.hasException())
1243         return parseResult.releaseException();
1244     QualifiedName parsedName { parseResult.releaseReturnValue() };
1245     if (!hasValidNamespaceForElements(parsedName))
1246         return Exception { NamespaceError };
1247 
1248     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1249         return createHTMLElementWithNameValidation(*this, parsedName);
1250 
1251     return createElement(parsedName, false);
1252 }
1253 
1254 void Document::setReadyState(ReadyState readyState)
1255 {
1256     if (readyState == m_readyState)
1257         return;
1258 
1259     switch (readyState) {
</pre>
<hr />
<pre>
1348 
1349     // If the client is extending the visual update suppression period explicitly, the
1350     // watchdog should not re-enable visual updates itself, but should wait for the client.
1351     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1352         return;
1353 
1354     setVisualUpdatesAllowed(true);
1355 }
1356 
1357 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1358 {
1359     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1360     // both of which we can determine by looking at the timer.
1361 
1362     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1363         setVisualUpdatesAllowed(true);
1364 }
1365 
1366 String Document::characterSetWithUTF8Fallback() const
1367 {
<span class="line-modified">1368     AtomicString name = encoding();</span>
1369     if (!name.isNull())
1370         return name;
1371     return UTF8Encoding().domName();
1372 }
1373 
1374 String Document::defaultCharsetForLegacyBindings() const
1375 {
1376     if (!frame())
1377         UTF8Encoding().domName();
1378     return settings().defaultTextEncodingName();
1379 }
1380 
1381 void Document::setCharset(const String&amp; charset)
1382 {
1383     if (!decoder())
1384         return;
1385     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1386 }
1387 
1388 void Document::setContentLanguage(const String&amp; language)
</pre>
<hr />
<pre>
1525         // 1. If the Document is in quirks mode, follow these substeps:
1526         if (inQuirksMode()) {
1527             auto* firstBody = body();
1528             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1529             // HTML body element and abort these steps.
1530             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1531                 return firstBody;
1532 
1533             // 2. Return null and abort these steps.
1534             return nullptr;
1535         }
1536 
1537         // 2. If there is a root element, return the root element and abort these steps.
1538         // 3. Return null.
1539         return documentElement();
1540     }
1541 
1542     return body();
1543 }
1544 
<span class="line-modified">1545 template&lt;typename CharacterType&gt; static inline String canonicalizedTitle(Document&amp; document, const String&amp; title)</span>
1546 {
<span class="line-modified">1547     // FIXME: Compiling a separate copy of this for LChar and UChar is likely unnecessary.</span>
<span class="line-modified">1548     // FIXME: Missing an optimized case for when title is fine as-is. This unnecessarily allocates</span>
<span class="line-modified">1549     // and keeps around a new copy, and it&#39;s even the less optimal type of StringImpl with a separate buffer.</span>
<span class="line-removed">1550     // Could probably just use StringBuilder instead.</span>
<span class="line-removed">1551 </span>
<span class="line-removed">1552     auto* characters = title.characters&lt;CharacterType&gt;();</span>
<span class="line-removed">1553     unsigned length = title.length();</span>
1554 
<span class="line-modified">1555     StringBuffer&lt;CharacterType&gt; buffer { length };</span>
<span class="line-removed">1556     unsigned bufferLength = 0;</span>
1557 
1558     auto* decoder = document.decoder();
1559     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1560 
<span class="line-removed">1561     // Collapse runs of HTML spaces into single space characters.</span>
<span class="line-removed">1562     // Strip leading and trailing spaces.</span>
<span class="line-removed">1563     // Replace backslashes with currency symbols.</span>
1564     bool previousCharacterWasHTMLSpace = false;
<span class="line-modified">1565     for (unsigned i = 0; i &lt; length; ++i) {</span>
<span class="line-removed">1566         auto character = characters[i];</span>
1567         if (isHTMLSpace(character))
1568             previousCharacterWasHTMLSpace = true;
1569         else {
1570             if (character == &#39;\\&#39;)
1571                 character = backslashAsCurrencySymbol;
<span class="line-modified">1572             if (previousCharacterWasHTMLSpace &amp;&amp; bufferLength)</span>
<span class="line-modified">1573                 buffer[bufferLength++] = &#39; &#39;;</span>
<span class="line-modified">1574             buffer[bufferLength++] = character;</span>
1575             previousCharacterWasHTMLSpace = false;
1576         }
1577     }
<span class="line-removed">1578     if (!bufferLength)</span>
<span class="line-removed">1579         return { };</span>
1580 
<span class="line-modified">1581     buffer.shrink(bufferLength);</span>
<span class="line-removed">1582     return String::adopt(WTFMove(buffer));</span>
1583 }
1584 
1585 void Document::updateTitle(const StringWithDirection&amp; title)
1586 {
1587     if (m_rawTitle == title)
1588         return;
1589 
1590     m_rawTitle = title;
<span class="line-removed">1591     m_title = title;</span>
1592 
<span class="line-modified">1593     if (!m_title.string.isEmpty()) {</span>
<span class="line-modified">1594         if (m_title.string.is8Bit())</span>
<span class="line-removed">1595             m_title.string = canonicalizedTitle&lt;LChar&gt;(*this, m_title.string);</span>
<span class="line-removed">1596         else</span>
<span class="line-removed">1597             m_title.string = canonicalizedTitle&lt;UChar&gt;(*this, m_title.string);</span>
<span class="line-removed">1598     }</span>
1599 
1600     if (auto* loader = this-&gt;loader())
1601         loader-&gt;setTitle(m_title);
1602 }
1603 
1604 void Document::updateTitleFromTitleElement()
1605 {
1606     if (!m_titleElement) {
1607         updateTitle({ });
1608         return;
1609     }
1610 
1611     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1612         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1613     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1614         // FIXME: Does the SVG title element have a text direction?
1615         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1616     }
1617 }
1618 
</pre>
<hr />
<pre>
1745 
1746 void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1747 {
1748     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);
1749 }
1750 
1751 void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1752 {
1753     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);
1754 }
1755 
1756 void Document::allowsMediaDocumentInlinePlaybackChanged()
1757 {
1758     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)
1759         element-&gt;allowsMediaDocumentInlinePlaybackChanged();
1760 }
1761 
1762 void Document::stopAllMediaPlayback()
1763 {
1764     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-modified">1765         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(this);</span>
1766 }
1767 
1768 void Document::suspendAllMediaPlayback()
1769 {
1770     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1771         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1772 }
1773 
1774 void Document::resumeAllMediaPlayback()
1775 {
1776     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1777         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1778 }












1779 #endif
1780 
1781 String Document::nodeName() const
1782 {
1783     return &quot;#document&quot;_s;
1784 }
1785 
1786 Node::NodeType Document::nodeType() const
1787 {
1788     return DOCUMENT_NODE;
1789 }
1790 
1791 FormController&amp; Document::formController()
1792 {
1793     if (!m_formController)
<span class="line-modified">1794         m_formController = std::make_unique&lt;FormController&gt;();</span>
1795     return *m_formController;
1796 }
1797 
1798 Vector&lt;String&gt; Document::formElementsState() const
1799 {
1800     if (!m_formController)
1801         return Vector&lt;String&gt;();
1802     return m_formController-&gt;formElementsState();
1803 }
1804 
1805 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1806 {
1807     if (!stateVector.size() &amp;&amp; !m_formController)
1808         return;
1809     formController().setStateForNewFormElements(stateVector);
1810 }
1811 
1812 FrameView* Document::view() const
1813 {
1814     return m_frame ? m_frame-&gt;view() : nullptr;
</pre>
<hr />
<pre>
1831 
1832 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1833 {
1834     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1835 }
1836 
1837 void Document::scheduleFullStyleRebuild()
1838 {
1839     m_needsFullStyleRebuild = true;
1840     scheduleStyleRecalc();
1841 }
1842 
1843 void Document::scheduleStyleRecalc()
1844 {
1845     ASSERT(!m_renderView || !inHitTesting());
1846 
1847     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)
1848         return;
1849 
1850     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
<span class="line-removed">1851 </span>
<span class="line-removed">1852 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">1853     if (WKIsObservingStyleRecalcScheduling()) {</span>
<span class="line-removed">1854         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: register this style recalc schedule and observe when it fires.&quot;);</span>
<span class="line-removed">1855         WKSetObservedContentChange(WKContentIndeterminateChange);</span>
<span class="line-removed">1856     }</span>
<span class="line-removed">1857 #endif</span>
<span class="line-removed">1858 </span>
1859     auto shouldThrottleStyleRecalc = [&amp;] {
1860         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1861             return false;
1862         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1863             return false;
1864         return true;
1865     };
1866 
1867     if (shouldThrottleStyleRecalc())
1868         return;
1869 
1870     m_styleRecalcTimer.startOneShot(0_s);
1871 
1872     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1873 }
1874 
1875 void Document::unscheduleStyleRecalc()
1876 {
1877     ASSERT(!childNeedsStyleRecalc());
1878 
</pre>
<hr />
<pre>
1903     if (frameView.isPainting())
1904         return;
1905 
1906     if (m_inStyleRecalc)
1907         return; // Guard against re-entrancy. -dwh
1908 
1909     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1910 
1911     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1912     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1913 
1914     // FIXME: Do this update per tree scope.
1915     {
1916         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1917         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1918         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1919         for (auto&amp; element : elements)
1920             element-&gt;updateShadowTree();
1921     }
1922 
<span class="line-modified">1923     // FIXME: We should update style on our ancestor chain before proceeding (especially for seamless),</span>
<span class="line-modified">1924     // however doing so currently causes several tests to crash, as Frame::setDocument calls Document::attach</span>
<span class="line-removed">1925     // before setting the DOMWindow on the Frame, or the SecurityOrigin on the document. The attach, in turn</span>
<span class="line-removed">1926     // resolves style (here) and then when we resolve style on the parent chain, we may end up</span>
<span class="line-removed">1927     // re-attaching our containing iframe, which when asked HTMLFrameElementBase::isURLAllowed</span>
<span class="line-removed">1928     // hits a null-dereference due to security code always assuming the document has a SecurityOrigin.</span>
1929 
1930     {
1931         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1932         styleScope().flushPendingUpdate();
1933         frameView.willRecalcStyle();
1934     }
1935 
1936     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);
1937 
1938     bool updatedCompositingLayers = false;
1939     {
1940         Style::PostResolutionCallbackDisabler disabler(*this);
1941         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1942         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1943 
1944         m_inStyleRecalc = true;
1945 
1946         if (m_needsFullStyleRebuild)
1947             type = ResolveStyleType::Rebuild;
1948 
</pre>
<hr />
<pre>
1975         clearChildNeedsStyleRecalc();
1976         unscheduleStyleRecalc();
1977 
1978         m_inStyleRecalc = false;
1979 
1980         if (styleUpdate) {
1981             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
1982 
1983             RenderTreeUpdater updater(*this);
1984             updater.commit(WTFMove(styleUpdate));
1985 
1986             frameView.styleDidChange();
1987         }
1988 
1989         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
1990 
1991         if (m_renderView-&gt;needsLayout())
1992             frameView.layoutContext().scheduleLayout();
1993 
1994         // Usually this is handled by post-layout.
<span class="line-modified">1995         if (!frameView.needsLayout()) {</span>
1996             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
<span class="line-removed">1997             if (m_needsForcedIntersectionObservationUpdate)</span>
<span class="line-removed">1998                 page()-&gt;scheduleForcedIntersectionObservationUpdate(*this);</span>
<span class="line-removed">1999         }</span>
2000 
2001         // As a result of the style recalculation, the currently hovered element might have been
2002         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
2003         // to check if any other elements ended up under the mouse pointer due to re-layout.
2004         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
2005             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
2006 
2007         ++m_styleRecalcCount;
2008         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
2009     }
2010 
2011     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.
2012     if (m_closeAfterStyleRecalc) {
2013         m_closeAfterStyleRecalc = false;
2014         implicitClose();
2015     }
2016 
2017     InspectorInstrumentation::didRecalculateStyle(cookie);
2018 
2019     // Some animated images may now be inside the viewport due to style recalc,
2020     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2021     // check if they need to be resumed after layout.
2022     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2023         frameView.viewportContentsChanged();
2024 
2025     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2026         frameView.scrollToFragment(m_url);
2027 }
2028 
2029 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2030 {
2031     ASSERT(!m_inRenderTreeUpdate);
2032     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2033 
<span class="line-modified">2034     auto textUpdate = std::make_unique&lt;Style::Update&gt;(*this);</span>
2035     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2036 
2037     RenderTreeUpdater renderTreeUpdater(*this);
2038     renderTreeUpdater.commit(WTFMove(textUpdate));
2039 }
2040 
2041 bool Document::needsStyleRecalc() const
2042 {
2043     if (pageCacheState() != NotInPageCache)
2044         return false;
2045 
2046     if (m_needsFullStyleRebuild)
2047         return true;
2048 
2049     if (childNeedsStyleRecalc())
2050         return true;
2051 
2052     if (styleScope().hasPendingUpdate())
2053         return true;
2054 
2055     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.
2056     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2057         return true;
2058 
2059     return false;
2060 }
2061 
2062 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2063 {
2064     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2065     auto* frameView = document.view();
2066     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
<span class="line-modified">2067     bool isAssertionDisabled = ScriptDisallowedScope::LayoutAssertionDisableScope::shouldDisable();</span>
<span class="line-removed">2068     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess() || isAssertionDisabled;</span>
2069 }
2070 
2071 bool Document::updateStyleIfNeeded()
2072 {
2073     RefPtr&lt;FrameView&gt; frameView = view();
2074     {
2075         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2076         ASSERT(isMainThread());
2077         ASSERT(!frameView || !frameView-&gt;isPainting());
2078 
2079         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2080             return false;
2081 
2082         styleScope().flushPendingUpdate();
2083 
2084         if (!needsStyleRecalc())
2085             return false;
2086     }
2087 
2088 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2089     auto observingContentChange = WKShouldObserveNextStyleRecalc();</span>
<span class="line-removed">2090     if (observingContentChange) {</span>
<span class="line-removed">2091         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: start observing content change.&quot;);</span>
<span class="line-removed">2092         WKSetShouldObserveNextStyleRecalc(false);</span>
<span class="line-removed">2093         WKStartObservingContentChanges();</span>
<span class="line-removed">2094     }</span>
2095 #endif
2096     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2097     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
<span class="line-removed">2098 </span>
2099     resolveStyle();
<span class="line-removed">2100 </span>
<span class="line-removed">2101 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">2102     if (observingContentChange) {</span>
<span class="line-removed">2103         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: stop observing content change.&quot;);</span>
<span class="line-removed">2104         WKStopObservingContentChanges();</span>
<span class="line-removed">2105 </span>
<span class="line-removed">2106         auto inDeterminedState = WKObservedContentChange() == WKContentVisibilityChange || !WebThreadCountOfObservedDOMTimers();</span>
<span class="line-removed">2107         if (inDeterminedState) {</span>
<span class="line-removed">2108             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: notify the pending synthetic click handler.&quot;);</span>
<span class="line-removed">2109             if (auto* page = this-&gt;page())</span>
<span class="line-removed">2110                 page-&gt;chrome().client().observedContentChange(*frame());</span>
<span class="line-removed">2111         } else {</span>
<span class="line-removed">2112             LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document(&quot; &lt;&lt; this &lt;&lt; &quot;)::scheduleStyleRecalc: can&#39;t decided it yet.&quot;);</span>
<span class="line-removed">2113         }</span>
<span class="line-removed">2114     }</span>
<span class="line-removed">2115 #endif</span>
2116     return true;
2117 }
2118 
2119 void Document::updateLayout()
2120 {
2121     ASSERT(isMainThread());
2122 
2123     RefPtr&lt;FrameView&gt; frameView = view();
2124     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2125         // View layout should not be re-entrant.
2126         ASSERT_NOT_REACHED();
2127         return;
2128     }
2129     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2130 
2131     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2132 
2133     if (HTMLFrameOwnerElement* owner = ownerElement())
2134         owner-&gt;document().updateLayout();
2135 
</pre>
<hr />
<pre>
2319         width = valueForLength(size.width, 0);
2320         height = valueForLength(size.height, 0);
2321         break;
2322     }
2323     default:
2324         ASSERT_NOT_REACHED();
2325     }
2326     pageSize = IntSize(width, height);
2327 
2328     // The percentage is calculated with respect to the width even for margin top and bottom.
2329     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2330     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2331     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2332     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2333     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2334 }
2335 
2336 StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
2337 {
2338     if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">2339         m_userAgentShadowTreeStyleResolver = std::make_unique&lt;StyleResolver&gt;(*this);</span>
2340     return *m_userAgentShadowTreeStyleResolver;
2341 }
2342 
2343 void Document::fontsNeedUpdate(FontSelector&amp;)
2344 {
2345     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2346 }
2347 
2348 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2349 {
2350     if (auto* resolver = styleScope().resolverIfExists())
2351         resolver-&gt;invalidateMatchedPropertiesCache();
2352     if (pageCacheState() != NotInPageCache || !renderView())
2353         return;
2354     scheduleFullStyleRebuild();
2355 }
2356 
2357 void Document::didClearStyleResolver()
2358 {
2359     m_userAgentShadowTreeStyleResolver = nullptr;
</pre>
<hr />
<pre>
2423                 timeline-&gt;resumeAnimations();
2424         } else
2425             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2426     }
2427 }
2428 
2429 void Document::frameDestroyed()
2430 {
2431     // detachFromFrame() must be called before destroying the Frame.
2432     RELEASE_ASSERT(!m_frame);
2433 
2434     if (auto* window = domWindow())
2435         window-&gt;frameDestroyed();
2436 
2437     FrameDestructionObserver::frameDestroyed();
2438 }
2439 
2440 void Document::willDetachPage()
2441 {
2442     FrameDestructionObserver::willDetachPage();
<span class="line-modified">2443 </span>


2444     if (domWindow() &amp;&amp; frame())
2445         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2446 }
2447 
2448 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2449 {
2450     RELEASE_ASSERT(cachedFrame.document() == this);
2451     ASSERT(cachedFrame.view());
2452     ASSERT(m_pageCacheState == Document::InPageCache);
2453     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2454 }
2455 
2456 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2457 {
2458     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2459     RELEASE_ASSERT(cachedFrame.document() == this);
2460     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2461     ASSERT(m_pageCacheState == Document::InPageCache);
2462     detachFromFrame();
2463 }
</pre>
<hr />
<pre>
2519 
2520 #if USE(LIBWEBRTC)
2521     // FIXME: This should be moved to Modules/mediastream.
2522     if (LibWebRTCProvider::webRTCAvailable()) {
2523         if (auto* page = this-&gt;page())
2524             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2525     }
2526 #endif
2527 
2528 #if ENABLE(SERVICE_WORKER)
2529     setActiveServiceWorker(nullptr);
2530     setServiceWorkerConnection(nullptr);
2531 #endif
2532 
2533 #if ENABLE(IOS_TOUCH_EVENTS)
2534     clearTouchEventHandlersAndListeners();
2535 #endif
2536 
2537     m_undoManager-&gt;removeAllItems();
2538 
<span class="line-modified">2539 #if HAVE(ACCESSIBILITY)</span>
2540     if (this != &amp;topDocument()) {
2541         // Let the ax cache know that this subframe goes out of scope.
2542         if (auto* cache = existingAXObjectCache())
2543             cache-&gt;prepareForDocumentDestruction(*this);
2544     }
2545 #endif
2546 
2547     {
2548         NavigationDisabler navigationDisabler(m_frame);
2549         disconnectDescendantFrames();
2550     }

2551 
2552     if (m_domWindow &amp;&amp; m_frame)
2553         m_domWindow-&gt;willDetachDocumentFromFrame();
2554 
2555     styleScope().clearResolver();
2556 
2557     if (hasLivingRenderTree())
2558         destroyRenderTree();
2559 
2560     if (is&lt;PluginDocument&gt;(*this))
2561         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2562 
2563 #if ENABLE(POINTER_LOCK)
2564     if (page())
2565         page()-&gt;pointerLockController().documentDetached(*this);
2566 #endif
2567 
2568     if (auto* page = this-&gt;page()) {
2569         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2570             validationMessageClient-&gt;documentDetached(*this);
2571     }
2572 
2573     InspectorInstrumentation::documentDetached(*this);
2574 
2575     stopActiveDOMObjects();
2576     m_eventQueue.close();
2577 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">2578     m_fullScreenChangeEventTargetQueue.clear();</span>
<span class="line-removed">2579     m_fullScreenErrorEventTargetQueue.clear();</span>
2580 #endif
2581 
2582     commonTeardown();
2583 
2584 #if ENABLE(TOUCH_EVENTS)
2585     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2586         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2587 #endif
2588 
2589     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2590         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2591 
2592     if (m_mediaQueryMatcher)
2593         m_mediaQueryMatcher-&gt;documentDestroyed();
2594 
2595 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2596     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2597         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2598             removePlaybackTargetPickerClient(*client);
2599     }
2600 #endif
2601 
2602     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2603 
2604     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2605         m_mediaState = MediaProducer::IsNotPlaying;
2606         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2607     }
2608 
2609     detachFromFrame();
2610 
2611     if (m_timeline) {
2612         m_timeline-&gt;detachFromDocument();
2613         m_timeline = nullptr;
2614     }
2615 
<span class="line-removed">2616 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">2617     if (m_animationScheduler) {</span>
<span class="line-removed">2618         m_animationScheduler-&gt;detachFromDocument();</span>
<span class="line-removed">2619         m_animationScheduler = nullptr;</span>
<span class="line-removed">2620     }</span>
<span class="line-removed">2621 #endif</span>
<span class="line-removed">2622 </span>
2623 #if ENABLE(CSS_PAINTING_API)
2624     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2625         scope-&gt;prepareForDestruction();
2626     m_paintWorkletGlobalScopes.clear();
2627 #endif
2628 
2629     m_hasPreparedForDestruction = true;
2630 
2631     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame
2632     // was removed in an onpagehide event handler fired when the top-level frame is
2633     // about to enter the page cache.
2634     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);
2635 }
2636 
2637 void Document::removeAllEventListeners()
2638 {
2639     EventTarget::removeAllEventListeners();
2640 
2641     if (m_domWindow)
2642         m_domWindow-&gt;removeAllEventListeners();
</pre>
<hr />
<pre>
2672         return;
2673     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2674 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2675     if (m_deviceMotionController)
2676         m_deviceMotionController-&gt;resumeUpdates();
2677     if (m_deviceOrientationController)
2678         m_deviceOrientationController-&gt;resumeUpdates();
2679 #endif
2680 }
2681 
2682 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2683 {
2684     // Bypass this policy when the world is known, and it not the normal world.
2685     auto&amp; callFrame = *commonVM().topCallFrame;
2686     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();
2687 }
2688 
2689 void Document::platformSuspendOrStopActiveDOMObjects()
2690 {
2691 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2692     if (WebThreadCountOfObservedDOMTimers() &gt; 0) {</span>
<span class="line-removed">2693         LOG_WITH_STREAM(ContentObservation, stream &lt;&lt; &quot;Document::platformSuspendOrStopActiveDOMObjects: remove registered timers.&quot;);</span>
<span class="line-removed">2694         if (auto* frame = this-&gt;frame()) {</span>
<span class="line-removed">2695             if (auto* page = frame-&gt;page())</span>
<span class="line-removed">2696                 page-&gt;chrome().client().clearContentChangeObservers(*frame);</span>
<span class="line-removed">2697         }</span>
<span class="line-removed">2698     }</span>
2699 #endif
2700 }
2701 
2702 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2703 {
2704     ScriptExecutionContext::suspendActiveDOMObjects(why);
2705     suspendDeviceMotionAndOrientationUpdates();
2706     platformSuspendOrStopActiveDOMObjects();
2707 }
2708 
2709 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2710 {
2711     ScriptExecutionContext::resumeActiveDOMObjects(why);
2712     resumeDeviceMotionAndOrientationUpdates();
2713     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2714 }
2715 
2716 void Document::stopActiveDOMObjects()
2717 {
2718     ScriptExecutionContext::stopActiveDOMObjects();
</pre>
<hr />
<pre>
2733     return topDocument().m_axObjectCache.get();
2734 }
2735 
2736 AXObjectCache* Document::axObjectCache() const
2737 {
2738     if (!AXObjectCache::accessibilityEnabled())
2739         return nullptr;
2740 
2741     // The only document that actually has a AXObjectCache is the top-level
2742     // document.  This is because we need to be able to get from any WebCoreAXObject
2743     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2744     // lookups across nested webareas (i.e. multiple documents).
2745     Document&amp; topDocument = this-&gt;topDocument();
2746 
2747     // If the document has already been detached, do not make a new axObjectCache.
2748     if (!topDocument.hasLivingRenderTree())
2749         return nullptr;
2750 
2751     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2752     if (!topDocument.m_axObjectCache) {
<span class="line-modified">2753         topDocument.m_axObjectCache = std::make_unique&lt;AXObjectCache&gt;(topDocument);</span>
2754         hasEverCreatedAnAXObjectCache = true;
2755     }
2756     return topDocument.m_axObjectCache.get();
2757 }
2758 
2759 void Document::setVisuallyOrdered()
2760 {
2761     m_visuallyOrdered = true;
2762     if (renderView())
2763         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2764 }
2765 
2766 Ref&lt;DocumentParser&gt; Document::createParser()
2767 {
2768     // FIXME: this should probably pass the frame instead
2769     return XMLDocumentParser::create(*this, view());
2770 }
2771 
2772 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2773 {
2774     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2775 }
2776 
<span class="line-modified">2777 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomicString&amp; name, const String&amp; features)</span>
2778 {
2779     if (!m_domWindow)
2780         return Exception { InvalidAccessError };
2781 
2782     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2783 }
2784 
2785 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2786 {
2787     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2788         return Exception { InvalidStateError };
2789 
2790     auto result = open(responsibleDocument);
2791     if (UNLIKELY(result.hasException()))
2792         return result.releaseException();
2793 
2794     return *this;
2795 }
2796 
2797 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
</pre>
<hr />
<pre>
2799     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2800         return Exception { SecurityError };
2801 
2802     if (m_ignoreOpensDuringUnloadCount)
2803         return { };
2804 
2805     if (m_frame) {
2806         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2807             if (parser-&gt;isParsing()) {
2808                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2809                 if (parser-&gt;isExecutingScript())
2810                     return { };
2811 
2812                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2813                     return { };
2814             }
2815         }
2816 
2817         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2818             m_frame-&gt;loader().policyChecker().stopCheck();
<span class="line-modified">2819         if (m_frame-&gt;loader().state() == FrameStateProvisional)</span>
2820             m_frame-&gt;loader().stopAllLoaders();
2821     }
2822 
2823     removeAllEventListeners();
2824 
2825     if (responsibleDocument &amp;&amp; isFullyActive()) {
2826         auto newURL = responsibleDocument-&gt;url();
2827         if (responsibleDocument != this)
2828             newURL.removeFragmentIdentifier();
2829         setURL(newURL);
2830         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2831         if (responsibleDocument != this)
2832             newCookieURL.removeFragmentIdentifier();
2833         setCookieURL(newCookieURL);
2834         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2835     }
2836 
2837     implicitOpen();
2838     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2839         parser-&gt;setWasCreatedByScript(true);
</pre>
<hr />
<pre>
3067         view()-&gt;layoutContext().unscheduleLayout();
3068         return;
3069     }
3070 
3071     frame()-&gt;loader().checkCallImplicitClose();
3072 
3073     // We used to force a synchronous display and flush here.  This really isn&#39;t
3074     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3075     // (if your platform is syncing flushes and limiting them to 60fps).
3076     m_overMinimumLayoutThreshold = true;
3077     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3078         updateStyleIfNeeded();
3079 
3080         // Always do a layout after loading if needed.
3081         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3082             view()-&gt;layoutContext().layout();
3083     }
3084 
3085     m_processingLoadEvent = false;
3086 



3087 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3088     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3089         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3090         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3091         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3092         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3093         //
3094         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3095         // catch new AND page history loads, and that uses AXLoadComplete
3096 
3097         axObjectCache()-&gt;getOrCreate(renderView());
3098         if (this == &amp;topDocument())
3099             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3100         else {
3101             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3102             // in an iframe that just finished loading, post AXLayoutComplete instead.
3103             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3104         }
3105     }
3106 #endif
3107 
3108     if (svgExtensions())
3109         accessSVGExtensions().startAnimations();
3110 }
3111 
3112 void Document::setParsing(bool b)
3113 {
3114     m_bParsing = b;
3115 
3116     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
<span class="line-modified">3117         m_sharedObjectPool = std::make_unique&lt;DocumentSharedObjectPool&gt;();</span>
3118 
3119     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3120         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3121 }
3122 
3123 bool Document::shouldScheduleLayout()
3124 {
3125     if (!documentElement())
3126         return false;
3127     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3128         return true;
3129     if (!bodyOrFrameset())
3130         return false;
3131     if (styleScope().hasPendingSheetsBeforeBody())
3132         return false;
3133     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3134         return false;
3135 
3136     return true;
3137 }
</pre>
<hr />
<pre>
3269 {
3270     URL oldBaseURL = m_baseURL;
3271     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3272     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3273     // from the Document interface otherwise.
3274     if (!m_baseElementURL.isEmpty())
3275         m_baseURL = m_baseElementURL;
3276     else if (!m_baseURLOverride.isEmpty())
3277         m_baseURL = m_baseURLOverride;
3278     else {
3279         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3280         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3281         // and DOM 3 Core does not specify how it should be resolved.
3282         m_baseURL = URL({ }, documentURI());
3283     }
3284 
3285     clearSelectorQueryCache();
3286 
3287     if (!m_baseURL.isValid())
3288         m_baseURL = URL();
<span class="line-removed">3289 </span>
<span class="line-removed">3290     if (!equalIgnoringFragmentIdentifier(oldBaseURL, m_baseURL)) {</span>
<span class="line-removed">3291         // Base URL change changes any relative visited links.</span>
<span class="line-removed">3292         // FIXME: There are other URLs in the tree that would need to be re-evaluated on dynamic base URL change. Style should be invalidated too.</span>
<span class="line-removed">3293         for (auto&amp; anchor : descendantsOfType&lt;HTMLAnchorElement&gt;(*this))</span>
<span class="line-removed">3294             anchor.invalidateCachedVisitedLinkHash();</span>
<span class="line-removed">3295     }</span>
3296 }
3297 
3298 void Document::setBaseURLOverride(const URL&amp; url)
3299 {
3300     m_baseURLOverride = url;
3301     updateBaseURL();
3302 }
3303 
3304 void Document::processBaseElement()
3305 {
3306     // Find the first href attribute in a base element and the first target attribute in a base element.
<span class="line-modified">3307     const AtomicString* href = nullptr;</span>
<span class="line-modified">3308     const AtomicString* target = nullptr;</span>
3309     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3310     for (auto&amp; base : baseDescendants) {
3311         if (!href) {
<span class="line-modified">3312             const AtomicString&amp; value = base.attributeWithoutSynchronization(hrefAttr);</span>
3313             if (!value.isNull()) {
3314                 href = &amp;value;
3315                 if (target)
3316                     break;
3317             }
3318         }
3319         if (!target) {
<span class="line-modified">3320             const AtomicString&amp; value = base.attributeWithoutSynchronization(targetAttr);</span>
3321             if (!value.isNull()) {
3322                 target = &amp;value;
3323                 if (href)
3324                     break;
3325             }
3326         }
3327     }
3328 
3329     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3330     URL baseElementURL;
3331     if (href) {
3332         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3333         if (!strippedHref.isEmpty())
3334             baseElementURL = URL(url(), strippedHref);
3335     }
3336     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3337         m_baseElementURL = baseElementURL;
3338         updateBaseURL();
3339     }
3340 
</pre>
<hr />
<pre>
3493 
3494     // Only prevent top frame navigations by subframes.
3495     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3496         return false;
3497 
3498     // Only prevent navigations by subframes that the user has not interacted with.
3499     if (m_frame-&gt;hasHadUserInteraction())
3500         return false;
3501 
3502     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3503     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3504     if (sandboxFlags() != SandboxNone)
3505         return false;
3506 
3507     // Only prevent navigations by third-party iframes.
3508     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3509         return false;
3510 
3511     // Only prevent cross-site navigations.
3512     auto* targetDocument = targetFrame.document();
<span class="line-modified">3513     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || registrableDomainsAreEqual(targetDocument-&gt;url(), destinationURL)))</span>
3514         return false;
3515 
3516     return true;
3517 }
3518 
3519 void Document::didRemoveAllPendingStylesheet()
3520 {
3521     if (auto* parser = scriptableDocumentParser())
3522         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3523 }
3524 
3525 bool Document::usesStyleBasedEditability() const
3526 {
3527     if (m_hasElementUsingStyleBasedEditability)
3528         return true;
3529 
3530     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3531     ASSERT(!m_inStyleRecalc);
3532 
3533     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
</pre>
<hr />
<pre>
3647 {
3648     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3649     if (m_disabledAdaptations == disabledAdaptations)
3650         return;
3651 
3652     m_disabledAdaptations = disabledAdaptations;
3653     dispatchDisabledAdaptationsDidChangeForMainFrame();
3654 }
3655 
3656 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3657 {
3658     if (!frame()-&gt;isMainFrame())
3659         return;
3660 
3661     if (!page())
3662         return;
3663 
3664     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3665 }
3666 
<span class="line-removed">3667 void Document::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)</span>
<span class="line-removed">3668 {</span>
<span class="line-removed">3669     if (viewportArguments == m_overrideViewportArguments)</span>
<span class="line-removed">3670         return;</span>
<span class="line-removed">3671 </span>
<span class="line-removed">3672     m_overrideViewportArguments = viewportArguments;</span>
<span class="line-removed">3673     updateViewportArguments();</span>
<span class="line-removed">3674 }</span>
<span class="line-removed">3675 </span>
3676 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3677 {
3678     ASSERT(!features.isNull());
3679 
3680     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3681 
3682     if (origin &lt; m_viewportArguments.type)
3683         return;
3684 
3685     m_viewportArguments = ViewportArguments(origin);
3686 
3687     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3688 
3689     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3690         setViewportFeature(m_viewportArguments, *this, key, value);
3691     });
3692 
3693     updateViewportArguments();
3694 }
3695 








3696 void Document::updateViewportArguments()
3697 {
3698     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3699 #ifndef NDEBUG
3700         m_didDispatchViewportPropertiesChanged = true;
3701 #endif
<span class="line-modified">3702         page()-&gt;chrome().dispatchViewportPropertiesDidChange(m_overrideViewportArguments ? m_overrideViewportArguments.value() : m_viewportArguments);</span>
3703         page()-&gt;chrome().didReceiveDocType(*frame());
3704     }
3705 }
3706 
3707 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">3708 static bool isColorSchemeSeparator(UChar character)</span>
3709 {
<span class="line-modified">3710     return isASCIISpace(character) || character == &#39;,&#39;;</span>
<span class="line-removed">3711 }</span>
<span class="line-removed">3712 </span>
<span class="line-removed">3713 static void processColorSchemes(StringView colorSchemes, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)</span>
<span class="line-removed">3714 {</span>
<span class="line-removed">3715     unsigned length = colorSchemes.length();</span>
3716     for (unsigned i = 0; i &lt; length; ) {
3717         // Skip to first non-separator.
<span class="line-modified">3718         while (i &lt; length &amp;&amp; isColorSchemeSeparator(colorSchemes[i]))</span>
3719             ++i;
3720         unsigned keyBegin = i;
3721 
3722         // Skip to first separator.
<span class="line-modified">3723         while (i &lt; length &amp;&amp; !isColorSchemeSeparator(colorSchemes[i]))</span>
3724             ++i;
3725         unsigned keyEnd = i;
3726 
3727         if (keyBegin == keyEnd)
3728             continue;
3729 
<span class="line-modified">3730         callback(colorSchemes.substring(keyBegin, keyEnd - keyBegin));</span>
3731     }
3732 }
3733 
<span class="line-modified">3734 void Document::processSupportedColorSchemes(const String&amp; colorSchemes)</span>
3735 {
<span class="line-modified">3736     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;</span>
3737     bool allowsTransformations = true;
3738     bool autoEncountered = false;
3739 
<span class="line-modified">3740     processColorSchemes(colorSchemes, [&amp;](StringView key) {</span>
3741         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
<span class="line-modified">3742             supportedColorSchemes = { };</span>
3743             allowsTransformations = true;
3744             autoEncountered = true;
3745             return;
3746         }
3747 
3748         if (autoEncountered)
3749             return;
3750 
3751         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
<span class="line-modified">3752             supportedColorSchemes.add(ColorSchemes::Light);</span>
3753         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
<span class="line-modified">3754             supportedColorSchemes.add(ColorSchemes::Dark);</span>
3755         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3756             allowsTransformations = false;
3757     });
3758 
3759     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified">3760     if (supportedColorSchemes.isEmpty() &amp;&amp; !allowsTransformations)</span>
<span class="line-modified">3761         supportedColorSchemes.add(ColorSchemes::Light);</span>
3762 
<span class="line-modified">3763     m_supportedColorSchemes = supportedColorSchemes;</span>
3764     m_allowsColorSchemeTransformations = allowsTransformations;
3765 
3766     if (auto* frameView = view())
3767         frameView-&gt;recalculateBaseBackgroundColor();
3768 
3769     if (auto* page = this-&gt;page())
3770         page-&gt;updateStyleAfterChangeInEnvironment();
3771 }
3772 #endif
3773 
3774 #if PLATFORM(IOS_FAMILY)
3775 
3776 void Document::processFormatDetection(const String&amp; features)
3777 {
3778     // FIXME: Find a better place for this function.
3779     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3780         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3781             m_isTelephoneNumberParsingAllowed = false;
3782     });
3783 }
</pre>
<hr />
<pre>
3804         return;
3805 #endif
3806 
3807     auto referrerPolicy = parseReferrerPolicy(policy, source);
3808     if (!referrerPolicy) {
3809         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3810         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3811         return;
3812     }
3813     setReferrerPolicy(referrerPolicy.value());
3814 }
3815 
3816 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3817 {
3818     if (!hasLivingRenderTree())
3819         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3820 
3821     HitTestResult result(documentPoint);
3822     hitTest(request, result);
3823 
<span class="line-modified">3824     if (!request.readOnly())</span>
<span class="line-modified">3825         updateHoverActiveState(request, result.targetElement());</span>





















3826 
3827     return MouseEventWithHitTestResults(event, result);
3828 }
3829 
3830 // DOM Section 1.1.1
3831 bool Document::childTypeAllowed(NodeType type) const
3832 {
3833     switch (type) {
3834     case ATTRIBUTE_NODE:
3835     case CDATA_SECTION_NODE:
3836     case DOCUMENT_FRAGMENT_NODE:
3837     case DOCUMENT_NODE:
3838     case TEXT_NODE:
3839         return false;
3840     case COMMENT_NODE:
3841     case PROCESSING_INSTRUCTION_NODE:
3842         return true;
3843     case DOCUMENT_TYPE_NODE:
3844     case ELEMENT_NODE:
3845         // Documents may contain no more than one of each of these.
</pre>
<hr />
<pre>
3915             }
3916         }
3917         break;
3918     }
3919     }
3920     return true;
3921 }
3922 
3923 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3924 {
3925     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3926     clone-&gt;cloneDataFromDocument(*this);
3927     switch (type) {
3928     case CloningOperation::OnlySelf:
3929     case CloningOperation::SelfWithTemplateContent:
3930         break;
3931     case CloningOperation::Everything:
3932         cloneChildNodes(clone);
3933         break;
3934     }
<span class="line-modified">3935     return WTFMove(clone);</span>
3936 }
3937 
3938 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
3939 {
3940     if (isXMLDocument()) {
3941         if (isXHTMLDocument())
<span class="line-modified">3942             return XMLDocument::createXHTML(nullptr, url());</span>
<span class="line-modified">3943         return XMLDocument::create(nullptr, url());</span>
3944     }
<span class="line-modified">3945     return create(url());</span>
3946 }
3947 
3948 void Document::cloneDataFromDocument(const Document&amp; other)
3949 {
3950     ASSERT(m_url == other.url());
3951     m_baseURL = other.baseURL();
3952     m_baseURLOverride = other.baseURLOverride();
3953     m_documentURI = other.documentURI();
3954 
3955     setCompatibilityMode(other.m_compatibilityMode);
3956     setContextDocument(other.contextDocument());
3957     setSecurityOriginPolicy(other.securityOriginPolicy());
3958     overrideMIMEType(other.contentType());
3959     setDecoder(other.decoder());
3960 }
3961 
3962 StyleSheetList&amp; Document::styleSheets()
3963 {
3964     if (!m_styleSheetList)
3965         m_styleSheetList = StyleSheetList::create(*this);
</pre>
<hr />
<pre>
3999         picture-&gt;sourcesChanged();
4000 }
4001 
4002 void Document::updateViewportUnitsOnResize()
4003 {
4004     if (!hasStyleWithViewportUnits())
4005         return;
4006 
4007     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();
4008 
4009     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
4010     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
4011         auto* renderer = element-&gt;renderer();
4012         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
4013             element-&gt;invalidateStyle();
4014     }
4015 }
4016 
4017 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
4018 {
<span class="line-modified">4019     m_audioProducers.add(&amp;audioProducer);</span>
4020     updateIsPlayingMedia();
4021 }
4022 
4023 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
4024 {
<span class="line-modified">4025     m_audioProducers.remove(&amp;audioProducer);</span>

4026     updateIsPlayingMedia();
4027 }
4028 
4029 void Document::noteUserInteractionWithMediaElement()
4030 {
4031     if (m_userHasInteractedWithMediaElement)
4032         return;
4033 
4034     if (!topDocument().userDidInteractWithPage())
4035         return;
4036 
4037     m_userHasInteractedWithMediaElement = true;
4038     updateIsPlayingMedia();
4039 }
4040 
4041 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4042 {

4043     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">4044     for (auto* audioProducer : m_audioProducers)</span>
<span class="line-modified">4045         state |= audioProducer-&gt;mediaState();</span>




4046 
4047 #if ENABLE(MEDIA_SESSION)
4048     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4049         if (sourceElement-&gt;isPlaying())
4050             state |= MediaProducer::IsSourceElementPlaying;
4051 
4052         if (auto* session = sourceElement-&gt;session()) {
4053             if (auto* controls = session-&gt;controls()) {
4054                 if (controls-&gt;previousTrackEnabled())
4055                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4056                 if (controls-&gt;nextTrackEnabled())
4057                     state |= MediaProducer::IsNextTrackControlEnabled;
4058             }
4059         }
4060     }
4061 #endif
4062 
4063     if (m_userHasInteractedWithMediaElement)
4064         state |= MediaProducer::HasUserInteractedWithMediaElement;
4065 
4066     if (state == m_mediaState)
4067         return;
4068 
4069 #if ENABLE(MEDIA_STREAM)
4070     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4071 #endif
4072 
4073     m_mediaState = state;
4074 
4075     if (page())
4076         page()-&gt;updateIsPlayingMedia(sourceElementID);
4077 
4078 #if ENABLE(MEDIA_STREAM)
4079     if (captureStateChanged)
4080         mediaStreamCaptureStateChanged();
4081 #endif
4082 }
4083 
4084 void Document::pageMutedStateDidChange()
4085 {
<span class="line-modified">4086     for (auto* audioProducer : m_audioProducers)</span>
<span class="line-modified">4087         audioProducer-&gt;pageMutedStateDidChange();</span>




4088 }
4089 
4090 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4091 {
4092     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4093         return node.isDescendantOf(container);
4094 
4095     return &amp;node == &amp;container || node.isDescendantOf(container);
4096 }
4097 
4098 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4099 {
4100     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.
4101         return;
4102 
4103     Element* focusedElement = node.treeScope().focusedElementInScope();
4104     if (!focusedElement)
4105         return;
4106 
4107     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
</pre>
<hr />
<pre>
4122     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4123         return;
4124 
4125     m_hoveredElement = element.parentElement();
4126     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4127         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4128     if (frame())
4129         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4130 }
4131 
4132 void Document::elementInActiveChainDidDetach(Element&amp; element)
4133 {
4134     if (!m_activeElement || &amp;element != m_activeElement)
4135         return;
4136 
4137     m_activeElement = element.parentElement();
4138     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4139         m_activeElement = m_activeElement-&gt;parentElement();
4140 }
4141 
<span class="line-modified">4142 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">4143 const Vector&lt;AnnotatedRegionValue&gt;&amp; Document::annotatedRegions() const</span>
<span class="line-removed">4144 {</span>
<span class="line-removed">4145     return m_annotatedRegions;</span>
<span class="line-removed">4146 }</span>
<span class="line-removed">4147 </span>
<span class="line-removed">4148 void Document::setAnnotatedRegions(const Vector&lt;AnnotatedRegionValue&gt;&amp; regions)</span>
<span class="line-removed">4149 {</span>
<span class="line-removed">4150     m_annotatedRegions = regions;</span>
<span class="line-removed">4151     setAnnotatedRegionsDirty(false);</span>
<span class="line-removed">4152 }</span>
<span class="line-removed">4153 </span>
<span class="line-removed">4154 void Document::updateAnnotatedRegions()</span>
<span class="line-removed">4155 {</span>
<span class="line-removed">4156     if (!hasAnnotatedRegions())</span>
<span class="line-removed">4157         return;</span>
<span class="line-removed">4158 </span>
<span class="line-removed">4159     Vector&lt;AnnotatedRegionValue&gt; newRegions;</span>
<span class="line-removed">4160     renderBox()-&gt;collectAnnotatedRegions(newRegions); // FIXME.</span>
<span class="line-removed">4161     if (newRegions == annotatedRegions())</span>
<span class="line-removed">4162         return;</span>
<span class="line-removed">4163 </span>
<span class="line-removed">4164     setAnnotatedRegions(newRegions);</span>
<span class="line-removed">4165 </span>
<span class="line-removed">4166     if (Page* page = this-&gt;page())</span>
<span class="line-removed">4167         page-&gt;chrome().client().annotatedRegionsChanged();</span>
<span class="line-removed">4168 }</span>
<span class="line-removed">4169 #endif</span>
<span class="line-removed">4170 </span>
<span class="line-removed">4171 void Document::invalidateRenderingDependentRegions(AnnotationsAction annotationsAction)</span>
4172 {
<span class="line-removed">4173 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">4174     // FIXME: we don&#39;t have a good invalidation/update policy for Dashboard regions. They get eagerly updated</span>
<span class="line-removed">4175     // on forced layouts, and don&#39;t need to be.</span>
<span class="line-removed">4176     if (annotationsAction == AnnotationsAction::Update)</span>
<span class="line-removed">4177         updateAnnotatedRegions();</span>
<span class="line-removed">4178     else</span>
<span class="line-removed">4179         setAnnotatedRegionsDirty();</span>
<span class="line-removed">4180 #else</span>
<span class="line-removed">4181     UNUSED_PARAM(annotationsAction);</span>
<span class="line-removed">4182 #endif</span>
<span class="line-removed">4183 </span>
4184 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4185     setTouchEventRegionsNeedUpdate();
4186 #endif
4187 
<span class="line-modified">4188 #if ENABLE(POINTER_EVENTS)</span>
4189     if (auto* page = this-&gt;page()) {
4190         if (auto* frameView = view()) {
4191             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4192                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4193         }
4194     }
4195 #endif
4196 }
4197 
<span class="line-removed">4198 void Document::invalidateScrollbarDependentRegions()</span>
<span class="line-removed">4199 {</span>
<span class="line-removed">4200 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">4201     if (hasAnnotatedRegions())</span>
<span class="line-removed">4202         setAnnotatedRegionsDirty();</span>
<span class="line-removed">4203 #endif</span>
<span class="line-removed">4204 }</span>
<span class="line-removed">4205 </span>
<span class="line-removed">4206 void Document::updateZOrderDependentRegions()</span>
<span class="line-removed">4207 {</span>
<span class="line-removed">4208 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">4209     if (annotatedRegionsDirty())</span>
<span class="line-removed">4210         updateAnnotatedRegions();</span>
<span class="line-removed">4211 #endif</span>
<span class="line-removed">4212 }</span>
<span class="line-removed">4213 </span>
4214 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4215 {
4216     RefPtr&lt;Element&gt; newFocusedElement = element;
4217     // Make sure newFocusedElement is actually in this document
4218     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4219         return true;
4220 
4221     if (m_focusedElement == newFocusedElement)
4222         return true;
4223 
4224     if (pageCacheState() != NotInPageCache)
4225         return false;
4226 
4227     bool focusChangeBlocked = false;
4228     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4229 
4230     // Remove focus from the existing focus node (if any)
4231     if (oldFocusedElement) {
4232         oldFocusedElement-&gt;setFocus(false);
4233         setFocusNavigationStartingNode(nullptr);
</pre>
<hr />
<pre>
4509             detachNodeIterator(*iterator);
4510             newDocument.attachNodeIterator(*iterator);
4511         }
4512     }
4513 }
4514 
4515 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4516 {
4517     for (auto* range : m_ranges)
4518         range-&gt;nodeChildrenChanged(container);
4519 }
4520 
4521 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4522 {
4523     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4524 
4525     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4526     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4527 
4528 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">4529     adjustFullScreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);</span>
4530 #endif
4531 
4532     for (auto* range : m_ranges)
4533         range-&gt;nodeChildrenWillBeRemoved(container);
4534 
4535     for (auto* it : m_nodeIterators) {
4536         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4537             it-&gt;nodeWillBeRemoved(*n);
4538     }
4539 
4540     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4541         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4542             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4543             frame-&gt;selection().nodeWillBeRemoved(*n);
4544             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4545         }
4546     }
4547 
4548     if (m_markers-&gt;hasMarkers()) {
4549         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4550             m_markers-&gt;removeMarkers(*textNode);
4551     }
4552 }
4553 
4554 void Document::nodeWillBeRemoved(Node&amp; node)
4555 {
4556     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4557 
4558     adjustFocusedNodeOnNodeRemoval(node);
4559     adjustFocusNavigationNodeOnNodeRemoval(node);
4560 
4561 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">4562     adjustFullScreenElementOnNodeRemoval(node);</span>
4563 #endif
4564 
4565     for (auto* it : m_nodeIterators)
4566         it-&gt;nodeWillBeRemoved(node);
4567 
4568     for (auto* range : m_ranges)
4569         range-&gt;nodeWillBeRemoved(node);
4570 
4571     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4572         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4573         frame-&gt;selection().nodeWillBeRemoved(node);
4574         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4575     }
4576 
4577     if (is&lt;Text&gt;(node))
4578         m_markers-&gt;removeMarkers(node);
<span class="line-removed">4579 </span>
<span class="line-removed">4580 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed">4581     if (m_touchActionElements &amp;&amp; is&lt;Element&gt;(node))</span>
<span class="line-removed">4582         m_touchActionElements-&gt;remove(&amp;downcast&lt;Element&gt;(node));</span>
<span class="line-removed">4583 #endif</span>
4584 }
4585 
4586 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4587 {
4588     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4589 }
4590 
4591 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4592 {
4593     if (!m_focusNavigationStartingNode)
4594         return;
4595 
4596     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4597         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4598         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4599         m_focusNavigationStartingNodeIsRemoved = true;
4600     }
4601 }
4602 
4603 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4604 {
4605     if (!m_ranges.isEmpty()) {
4606         for (auto* range : m_ranges)
4607             range-&gt;textInserted(text, offset, length);
4608     }
4609 
4610     // Update the markers for spelling and grammar checking.
4611     m_markers-&gt;shiftMarkers(text, offset, length);





4612 }
4613 
4614 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4615 {
4616     if (!m_ranges.isEmpty()) {
4617         for (auto* range : m_ranges)
4618             range-&gt;textRemoved(text, offset, length);
4619     }
4620 
4621     // Update the markers for spelling and grammar checking.
4622     m_markers-&gt;removeMarkers(text, offset, length);
4623     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4624 }
4625 
4626 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4627 {
4628     if (!m_ranges.isEmpty()) {
4629         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4630         for (auto* range : m_ranges)
4631             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
</pre>
<hr />
<pre>
4667     m_domWindow-&gt;didSecureTransitionTo(*this);
4668 
4669     ASSERT(m_domWindow-&gt;document() == this);
4670     ASSERT(m_domWindow-&gt;frame() == m_frame);
4671 }
4672 
4673 WindowProxy* Document::windowProxy() const
4674 {
4675     if (!m_frame)
4676         return nullptr;
4677     return &amp;m_frame-&gt;windowProxy();
4678 }
4679 
4680 Document&amp; Document::contextDocument() const
4681 {
4682     if (m_contextDocument)
4683         return *m_contextDocument.get();
4684     return const_cast&lt;Document&amp;&gt;(*this);
4685 }
4686 
<span class="line-modified">4687 void Document::setAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
4688 {
4689     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4690 }
4691 
<span class="line-modified">4692 void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)</span>
4693 {
4694     if (!m_domWindow)
4695         return;
4696     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4697 }
4698 
<span class="line-modified">4699 void Document::setWindowAttributeEventListener(const AtomicString&amp; eventType, const QualifiedName&amp; attributeName, const AtomicString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
4700 {
4701     if (!m_domWindow)
4702         return;
4703     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4704 }
4705 
<span class="line-modified">4706 EventListener* Document::getWindowAttributeEventListener(const AtomicString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)</span>
4707 {
4708     if (!m_domWindow)
4709         return nullptr;
4710     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4711 }
4712 
4713 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4714 {
4715     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4716     if (!m_domWindow)
4717         return;
4718     m_domWindow-&gt;dispatchEvent(event, target);
4719 }
4720 
4721 void Document::dispatchWindowLoadEvent()
4722 {
4723     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4724     if (!m_domWindow)
4725         return;
4726     m_domWindow-&gt;dispatchLoadEvent();
</pre>
<hr />
<pre>
4825 
4826     return Exception { NotSupportedError };
4827 }
4828 
4829 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4830 {
4831     switch (eventType) {
4832     case PlatformEvent::MouseForceChanged:
4833         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4834     case PlatformEvent::MouseForceDown:
4835         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4836     case PlatformEvent::MouseForceUp:
4837         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4838     case PlatformEvent::MouseScroll:
4839         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4840     default:
4841         return false;
4842     }
4843 }
4844 
<span class="line-modified">4845 void Document::addListenerTypeIfNeeded(const AtomicString&amp; eventType)</span>
4846 {
4847     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4848         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4849     else if (eventType == eventNames().DOMNodeInsertedEvent)
4850         addListenerType(DOMNODEINSERTED_LISTENER);
4851     else if (eventType == eventNames().DOMNodeRemovedEvent)
4852         addListenerType(DOMNODEREMOVED_LISTENER);
4853     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4854         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4855     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4856         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4857     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4858         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4859     else if (eventType == eventNames().overflowchangedEvent)
4860         addListenerType(OVERFLOWCHANGED_LISTENER);
4861     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4862         addListenerType(ANIMATIONSTART_LISTENER);
4863     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4864         addListenerType(ANIMATIONEND_LISTENER);
4865     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
</pre>
<hr />
<pre>
4934         return { };
4935 
4936     if (isCookieAverse())
4937         return { };
4938 
4939     if (!securityOrigin().canAccessCookies())
4940         return Exception { SecurityError };
4941 
4942     URL cookieURL = this-&gt;cookieURL();
4943     if (cookieURL.isEmpty())
4944         return { };
4945 
4946     invalidateDOMCookieCache();
4947     if (page())
4948         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
4949     return { };
4950 }
4951 
4952 String Document::referrer() const
4953 {




4954     if (frame())
4955         return frame()-&gt;loader().referrer();
4956     return String();
4957 }
4958 
4959 String Document::origin() const
4960 {
4961     return securityOrigin().toString();
4962 }
4963 
4964 String Document::domain() const
4965 {
4966     return securityOrigin().domain();
4967 }
4968 
<span class="line-removed">4969 bool Document::domainIsRegisterable(const String&amp; newDomain) const</span>
<span class="line-removed">4970 {</span>
<span class="line-removed">4971     if (newDomain.isEmpty())</span>
<span class="line-removed">4972         return false;</span>
<span class="line-removed">4973 </span>
<span class="line-removed">4974     const String&amp; effectiveDomain = domain();</span>
<span class="line-removed">4975 </span>
<span class="line-removed">4976     // If the new domain is the same as the old domain, return true so that</span>
<span class="line-removed">4977     // we still call securityOrigin().setDomainForDOM. This will change the</span>
<span class="line-removed">4978     // security check behavior. For example, if a page loaded on port 8000</span>
<span class="line-removed">4979     // assigns its current domain using document.domain, the page will</span>
<span class="line-removed">4980     // allow other pages loaded on different ports in the same domain that</span>
<span class="line-removed">4981     // have also assigned to access this page.</span>
<span class="line-removed">4982     if (equalIgnoringASCIICase(effectiveDomain, newDomain))</span>
<span class="line-removed">4983         return true;</span>
<span class="line-removed">4984 </span>
<span class="line-removed">4985     // e.g. newDomain = webkit.org (10) and domain() = www.webkit.org (14)</span>
<span class="line-removed">4986     unsigned oldLength = effectiveDomain.length();</span>
<span class="line-removed">4987     unsigned newLength = newDomain.length();</span>
<span class="line-removed">4988     if (newLength &gt;= oldLength)</span>
<span class="line-removed">4989         return false;</span>
<span class="line-removed">4990 </span>
<span class="line-removed">4991     auto ipAddressSetting = settings().treatIPAddressAsDomain() ? OriginAccessEntry::TreatIPAddressAsDomain : OriginAccessEntry::TreatIPAddressAsIPAddress;</span>
<span class="line-removed">4992     OriginAccessEntry accessEntry { securityOrigin().protocol(), newDomain, OriginAccessEntry::AllowSubdomains, ipAddressSetting };</span>
<span class="line-removed">4993     if (!accessEntry.matchesOrigin(securityOrigin()))</span>
<span class="line-removed">4994         return false;</span>
<span class="line-removed">4995 </span>
<span class="line-removed">4996     if (effectiveDomain[oldLength - newLength - 1] != &#39;.&#39;)</span>
<span class="line-removed">4997         return false;</span>
<span class="line-removed">4998     if (StringView { effectiveDomain }.substring(oldLength - newLength) != newDomain)</span>
<span class="line-removed">4999         return false;</span>
<span class="line-removed">5000 </span>
<span class="line-removed">5001     auto potentialPublicSuffix = newDomain;</span>
<span class="line-removed">5002     if (potentialPublicSuffix.startsWith(&#39;.&#39;))</span>
<span class="line-removed">5003         potentialPublicSuffix.remove(0, 1);</span>
<span class="line-removed">5004 </span>
<span class="line-removed">5005 #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
<span class="line-removed">5006     return !isPublicSuffix(potentialPublicSuffix);</span>
<span class="line-removed">5007 #else</span>
<span class="line-removed">5008     return true;</span>
<span class="line-removed">5009 #endif</span>
<span class="line-removed">5010 }</span>
<span class="line-removed">5011 </span>
5012 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
5013 {
5014     if (!frame())
5015         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
5016 
5017     if (isSandboxed(SandboxDocumentDomain))
5018         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
5019 
5020     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
5021         return Exception { SecurityError };
5022 
5023     // FIXME: We should add logging indicating why a domain was not allowed.
5024 
5025     const String&amp; effectiveDomain = domain();
5026     if (effectiveDomain.isEmpty())
5027         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
5028 
<span class="line-modified">5029     if (!domainIsRegisterable(newDomain))</span>
5030         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
5031 
5032     securityOrigin().setDomainFromDOM(newDomain);
5033     return { };
5034 }
5035 
5036 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
5037 {
5038     m_overrideLastModified = lastModified;
5039 }
5040 
5041 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
5042 String Document::lastModified() const
5043 {
5044     Optional&lt;WallTime&gt; dateTime;
5045     if (m_overrideLastModified)
5046         dateTime = m_overrideLastModified;
5047     else if (loader())
5048         dateTime = loader()-&gt;response().lastModified();
5049 
</pre>
<hr />
<pre>
5071 }
5072 
5073 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
5074 {
5075     if (!isValidNameStart(characters[0]))
5076         return false;
5077 
5078     for (unsigned i = 1; i &lt; length; ++i) {
5079         if (!isValidNamePart(characters[i]))
5080             return false;
5081     }
5082 
5083     return true;
5084 }
5085 
5086 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
5087 {
5088     unsigned i = 0;
5089 
5090     UChar32 c;
<span class="line-modified">5091     U16_NEXT(characters, i, length, c)</span>
5092     if (!isValidNameStart(c))
5093         return false;
5094 
5095     while (i &lt; length) {
<span class="line-modified">5096         U16_NEXT(characters, i, length, c)</span>
5097         if (!isValidNamePart(c))
5098             return false;
5099     }
5100 
5101     return true;
5102 }
5103 
5104 template&lt;typename CharType&gt;
5105 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
5106 {
5107     CharType c = characters[0];
5108     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
5109         return false;
5110 
5111     for (unsigned i = 1; i &lt; length; ++i) {
5112         c = characters[i];
5113         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
5114             return false;
5115     }
5116 
</pre>
<hr />
<pre>
5123     if (!length)
5124         return false;
5125 
5126     if (name.is8Bit()) {
5127         const LChar* characters = name.characters8();
5128 
5129         if (isValidNameASCII(characters, length))
5130             return true;
5131 
5132         return isValidNameNonASCII(characters, length);
5133     }
5134 
5135     const UChar* characters = name.characters16();
5136 
5137     if (isValidNameASCII(characters, length))
5138         return true;
5139 
5140     return isValidNameNonASCII(characters, length);
5141 }
5142 
<span class="line-modified">5143 ExceptionOr&lt;std::pair&lt;AtomicString, AtomicString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)</span>
5144 {
5145     unsigned length = qualifiedName.length();
5146 
5147     if (!length)
5148         return Exception { InvalidCharacterError };
5149 
5150     bool nameStart = true;
5151     bool sawColon = false;
5152     unsigned colonPosition = 0;
5153 
5154     for (unsigned i = 0; i &lt; length; ) {
5155         UChar32 c;
<span class="line-modified">5156         U16_NEXT(qualifiedName, i, length, c)</span>
5157         if (c == &#39;:&#39;) {
5158             if (sawColon)
5159                 return Exception { InvalidCharacterError };
5160             nameStart = true;
5161             sawColon = true;
5162             colonPosition = i - 1;
5163         } else if (nameStart) {
5164             if (!isValidNameStart(c))
5165                 return Exception { InvalidCharacterError };
5166             nameStart = false;
5167         } else {
5168             if (!isValidNamePart(c))
5169                 return Exception { InvalidCharacterError };
5170         }
5171     }
5172 
5173     if (!sawColon)
<span class="line-modified">5174         return std::pair&lt;AtomicString, AtomicString&gt; { { }, { qualifiedName } };</span>
5175 
5176     if (!colonPosition || length - colonPosition &lt;= 1)
5177         return Exception { InvalidCharacterError };
5178 
<span class="line-modified">5179     return std::pair&lt;AtomicString, AtomicString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomicString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomicString() };</span>
5180 }
5181 
<span class="line-modified">5182 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName)</span>
5183 {
5184     auto parseResult = parseQualifiedName(qualifiedName);
5185     if (parseResult.hasException())
5186         return parseResult.releaseException();
5187     auto parsedPieces = parseResult.releaseReturnValue();
5188     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5189 }
5190 
5191 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5192 {
5193     m_decoder = WTFMove(decoder);
5194 }
5195 
5196 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const
5197 {
5198     // Always return a null URL when passed a null string.
5199     // FIXME: Should we change the URL constructor to have this behavior?
5200     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5201     if (url.isNull())
5202         return URL();
5203     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5204     if (!m_decoder)
5205         return URL(baseURL, url);
5206     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5207 }
5208 
5209 URL Document::completeURL(const String&amp; url) const
5210 {
5211     return completeURL(url, m_baseURL);
5212 }
5213 
5214 PAL::SessionID Document::sessionID() const
5215 {
<span class="line-removed">5216     if (m_sessionID.isValid())</span>
<span class="line-removed">5217         return m_sessionID;</span>
<span class="line-removed">5218 </span>
<span class="line-removed">5219     if (auto* page = this-&gt;page())</span>
<span class="line-removed">5220         m_sessionID = page-&gt;sessionID();</span>
<span class="line-removed">5221 </span>
5222     return m_sessionID;
5223 }
5224 
5225 void Document::setPageCacheState(PageCacheState state)
5226 {
5227     if (m_pageCacheState == state)
5228         return;
5229 
5230     m_pageCacheState = state;
5231 
5232     FrameView* v = view();
5233     Page* page = this-&gt;page();
5234 
5235     switch (state) {
5236     case InPageCache:
5237         if (v) {
5238             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5239             // page cache and similar work that needs to occur when it comes out. This is where we do the work
5240             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5241             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
</pre>
<hr />
<pre>
5400     return settings().audioPlaybackRequiresUserGesture();
5401 }
5402 
5403 bool Document::videoPlaybackRequiresUserGesture() const
5404 {
5405     if (DocumentLoader* loader = this-&gt;loader()) {
5406         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5407         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5408         if (policy != AutoplayPolicy::Default)
5409             return policy == AutoplayPolicy::Deny;
5410     }
5411 
5412     return settings().videoPlaybackRequiresUserGesture();
5413 }
5414 
5415 void Document::storageBlockingStateDidChange()
5416 {
5417     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5418 }
5419 
<span class="line-modified">5420 void Document::privateBrowsingStateDidChange()</span>
5421 {
<span class="line-modified">5422     m_sessionID = SessionID::emptySessionID();</span>
5423     if (m_logger)
<span class="line-modified">5424         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());</span>
5425 
5426     for (auto* element : m_privateBrowsingStateChangedElements)
<span class="line-modified">5427         element-&gt;privateBrowsingStateDidChange();</span>
5428 
5429 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5430     ASSERT(sessionID().isValid());</span>
<span class="line-modified">5431     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection &amp;&amp; sessionID().isValid())</span>
<span class="line-removed">5432         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID()));</span>
5433 #endif
5434 }
5435 
5436 void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5437 {
5438     m_privateBrowsingStateChangedElements.add(&amp;element);
5439 }
5440 
5441 void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5442 {
5443     m_privateBrowsingStateChangedElements.remove(&amp;element);
5444 }
5445 
5446 #if ENABLE(VIDEO_TRACK)
5447 
5448 void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)
5449 {
5450     if (page())
5451         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5452 
</pre>
<hr />
<pre>
5499     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)
5500         mediaElement-&gt;userInterfaceLayoutDirectionChanged();
5501 }
5502 
5503 #endif
5504 
5505 void Document::setShouldCreateRenderers(bool f)
5506 {
5507     m_createRenderers = f;
5508 }
5509 
5510 bool Document::shouldCreateRenderers()
5511 {
5512     return m_createRenderers;
5513 }
5514 
5515 // Support for Javascript execCommand, and related methods
5516 
5517 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5518 {
<span class="line-modified">5519     RefPtr&lt;Frame&gt; frame = document-&gt;frame();</span>
<span class="line-removed">5520     if (!frame || frame-&gt;document() != document)</span>
<span class="line-removed">5521         return Editor::Command();</span>
5522 
5523     document-&gt;updateStyleIfNeeded();
5524 





5525     return frame-&gt;editor().command(commandName,
5526         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5527 }
5528 
5529 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5530 {
5531     EventQueueScope eventQueueScope;
5532     return command(this, commandName, userInterface).execute(value);
5533 }
5534 
5535 bool Document::queryCommandEnabled(const String&amp; commandName)
5536 {
5537     return command(this, commandName).isEnabled();
5538 }
5539 
5540 bool Document::queryCommandIndeterm(const String&amp; commandName)
5541 {
5542     return command(this, commandName).state() == MixedTriState;
5543 }
5544 
</pre>
<hr />
<pre>
5682     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5683     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5684         if (!m_frame)
5685             return const_cast&lt;Document&amp;&gt;(*this);
5686         // This should always be non-null.
5687         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5688         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5689     }
5690 
5691     Document* document = const_cast&lt;Document*&gt;(this);
5692     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5693         document = &amp;element-&gt;document();
5694     return *document;
5695 }
5696 
5697 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
5698 {
5699     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
5700 }
5701 
<span class="line-modified">5702 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomicString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)</span>
5703 {
5704     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5705     if (parseResult.hasException())
5706         return parseResult.releaseException();
5707     QualifiedName parsedName { parseResult.releaseReturnValue() };
5708     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5709         return Exception { NamespaceError };
5710     return Attr::create(*this, parsedName, emptyString());
5711 }
5712 
5713 const SVGDocumentExtensions* Document::svgExtensions()
5714 {
5715     return m_svgExtensions.get();
5716 }
5717 
5718 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5719 {
5720     if (!m_svgExtensions)
<span class="line-modified">5721         m_svgExtensions = std::make_unique&lt;SVGDocumentExtensions&gt;(*this);</span>
5722     return *m_svgExtensions;
5723 }
5724 
5725 void Document::addSVGUseElement(SVGUseElement&amp; element)
5726 {
5727     auto result = m_svgUseElements.add(&amp;element);
5728     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5729 }
5730 
5731 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5732 {
5733     m_svgUseElements.remove(&amp;element);
5734     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5735 }
5736 
5737 bool Document::hasSVGRootNode() const
5738 {
5739     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5740 }
5741 
</pre>
<hr />
<pre>
5774 Ref&lt;HTMLCollection&gt; Document::links()
5775 {
5776     return ensureCachedCollection&lt;DocLinks&gt;();
5777 }
5778 
5779 Ref&lt;HTMLCollection&gt; Document::forms()
5780 {
5781     return ensureCachedCollection&lt;DocForms&gt;();
5782 }
5783 
5784 Ref&lt;HTMLCollection&gt; Document::anchors()
5785 {
5786     return ensureCachedCollection&lt;DocAnchors&gt;();
5787 }
5788 
5789 Ref&lt;HTMLCollection&gt; Document::all()
5790 {
5791     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5792 }
5793 
<span class="line-modified">5794 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomicString&amp; name)</span>
5795 {
5796     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5797 }
5798 
<span class="line-modified">5799 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomicString&amp; name)</span>
5800 {
5801     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5802 }
5803 
<span class="line-modified">5804 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomicString&amp; name)</span>
5805 {
5806     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5807 }
5808 
5809 void Document::finishedParsing()
5810 {
5811     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5812     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5813     setParsing(false);
5814 
5815     Ref&lt;Document&gt; protectedThis(*this);
5816 
5817     scriptRunner().documentFinishedParsing();
5818 
5819     if (!m_documentTiming.domContentLoadedEventStart)
5820         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5821 
<span class="line-modified">5822     // FIXME: Schdule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-modified">5823     MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>


5824 
5825     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5826 
5827     if (!m_documentTiming.domContentLoadedEventEnd)
5828         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5829 
5830     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5831 #if ENABLE(XSLT)
5832         applyPendingXSLTransformsNowIfScheduled();
5833 #endif
5834 
5835         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5836         // resource loads are complete. HTMLObjectElements can start loading their resources from
5837         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5838         // tag and then reach the end of the document without updating styles, we might not have yet
5839         // started the resource load and might fire the window load event too early. To avoid this
5840         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5841         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5842         updateStyleIfNeeded();
5843 
</pre>
<hr />
<pre>
5861     m_sharedObjectPool = nullptr;
5862     m_sharedObjectPoolClearTimer.stop();
5863 }
5864 
5865 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5866 
5867 // FIXME: Find a better place for this code.
5868 
5869 bool Document::isTelephoneNumberParsingEnabled() const
5870 {
5871     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5872 }
5873 
5874 bool Document::isTelephoneNumberParsingAllowed() const
5875 {
5876     return m_isTelephoneNumberParsingAllowed;
5877 }
5878 
5879 #endif
5880 
<span class="line-modified">5881 String Document::originIdentifierForPasteboard()</span>
5882 {
5883     auto origin = securityOrigin().toString();
5884     if (origin != &quot;null&quot;)
5885         return origin;
5886     if (!m_uniqueIdentifier)
5887         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5888     return m_uniqueIdentifier;
5889 }
5890 
5891 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5892 {
5893     if (!m_xpathEvaluator)
5894         m_xpathEvaluator = XPathEvaluator::create();
5895     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5896 }
5897 
5898 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)
5899 {
5900     if (!m_xpathEvaluator)
5901         m_xpathEvaluator = XPathEvaluator::create();
</pre>
<hr />
<pre>
5904 
5905 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5906 {
5907     if (!m_xpathEvaluator)
5908         m_xpathEvaluator = XPathEvaluator::create();
5909     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5910 }
5911 
5912 void Document::initSecurityContext()
5913 {
5914     if (haveInitializedSecurityOrigin()) {
5915         ASSERT(SecurityContext::securityOrigin());
5916         return;
5917     }
5918 
5919     if (!m_frame) {
5920         // No source for a security context.
5921         // This can occur via document.implementation.createDocument().
5922         setCookieURL(URL({ }, emptyString()));
5923         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
<span class="line-modified">5924         setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));</span>
5925         return;
5926     }
5927 
5928     // In the common case, create the security context from the currently
5929     // loading URL with a fresh content security policy.
5930     setCookieURL(m_url);
5931     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5932     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5933 
5934     if (shouldEnforceContentDispositionAttachmentSandbox())
5935         applyContentDispositionAttachmentSandbox();
5936 
5937     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5938     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5939     if (!isSecurityOriginUnique)
5940         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5941 
5942     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
<span class="line-modified">5943     setContentSecurityPolicy(std::make_unique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>
<span class="line-removed">5944 </span>
<span class="line-removed">5945     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {</span>
<span class="line-removed">5946         // If this document was loaded with substituteData, then the document can</span>
<span class="line-removed">5947         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756</span>
<span class="line-removed">5948         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further</span>
<span class="line-removed">5949         // discussion.</span>
<span class="line-removed">5950 </span>
<span class="line-removed">5951         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead</span>
<span class="line-removed">5952         // of &quot;loader()&quot; as the latter returns NULL while the document is being</span>
<span class="line-removed">5953         // constructed</span>
<span class="line-removed">5954         // DocumentLoader* documentLoader = loader();</span>
<span class="line-removed">5955         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();</span>
<span class="line-removed">5956         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())</span>
<span class="line-removed">5957             securityOrigin().grantLoadLocalResources();</span>
<span class="line-removed">5958     }</span>
5959 
5960     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5961     if (!overrideContentSecurityPolicy.isNull())
5962         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5963 
5964 #if USE(QUICK_LOOK)
5965     if (shouldEnforceQuickLookSandbox())
5966         applyQuickLookSandbox();
5967 #endif
5968 
5969     if (shouldEnforceHTTP09Sandbox()) {
5970         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5971         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5972         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5973     }
5974 
5975     if (settings().needsStorageAccessFromFileURLsQuirk())
5976         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5977     if (!settings().webSecurityEnabled()) {
5978         // Web security is turned off. We should let this document access every other document. This is used primary by testing
</pre>
<hr />
<pre>
6055     Frame* openerFrame = m_frame-&gt;loader().opener();
6056     if (!openerFrame)
6057         return false;
6058     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());
6059 }
6060 
6061 void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)
6062 {
6063     // 1. Inherit Upgrade Insecure Requests
6064     Frame* parentFrame = m_frame-&gt;tree().parent();
6065     if (parentFrame)
6066         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6067 
6068     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).
6069     if (!shouldInheritContentSecurityPolicy())
6070         return;
6071     ContentSecurityPolicy* ownerPolicy = nullptr;
6072     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
6073         ownerPolicy = previousPolicy;
6074     if (!ownerPolicy) {
<span class="line-modified">6075     Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">6076     if (!ownerFrame)</span>
<span class="line-modified">6077         ownerFrame = m_frame-&gt;loader().opener();</span>
6078         if (ownerFrame)
6079             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
6080     }
6081     if (!ownerPolicy)
6082         return;
6083     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin
6084     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,
6085     // file, data) should inherit a policy.
6086     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())
6087         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);
6088     else
6089         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);
6090 }
6091 
6092 bool Document::isContextThread() const
6093 {
6094     return isMainThread();
6095 }
6096 
6097 bool Document::isSecureContext() const
6098 {
6099     if (!m_frame)
6100         return true;


6101     if (!securityOrigin().isPotentiallyTrustworthy())
6102         return false;
6103     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
6104         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
6105             return false;
6106     }
6107     return true;
6108 }
6109 
6110 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
6111 {
6112     Frame* f = frame();
6113     if (!f)
6114         return;
6115 
6116     setURL(url);
6117     f-&gt;loader().setOutgoingReferrer(url);
6118 
6119     if (DocumentLoader* documentLoader = loader())
6120         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
</pre>
<hr />
<pre>
6148 
6149 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6150 {
6151     HTMLCanvasElement* element = getCSSCanvasElement(name);
6152     if (!element)
6153         return WTF::nullopt;
6154     element-&gt;setSize({ width, height });
6155     auto context = element-&gt;getContext(type);
6156     if (!context)
6157         return WTF::nullopt;
6158 
6159 #if ENABLE(WEBGL)
6160     if (is&lt;WebGLRenderingContext&gt;(*context))
6161         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6162 #endif
6163 #if ENABLE(WEBGL2)
6164     if (is&lt;WebGL2RenderingContext&gt;(*context))
6165         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6166 #endif
6167 #if ENABLE(WEBGPU)
<span class="line-modified">6168     if (is&lt;WebGPURenderingContext&gt;(*context))</span>
<span class="line-modified">6169         return RenderingContext { RefPtr&lt;WebGPURenderingContext&gt; { &amp;downcast&lt;WebGPURenderingContext&gt;(*context) } };</span>
<span class="line-removed">6170 #endif</span>
<span class="line-removed">6171 #if ENABLE(WEBMETAL)</span>
<span class="line-removed">6172     if (is&lt;WebMetalRenderingContext&gt;(*context))</span>
<span class="line-removed">6173         return RenderingContext { RefPtr&lt;WebMetalRenderingContext&gt; { &amp;downcast&lt;WebMetalRenderingContext&gt;(*context) } };</span>
6174 #endif
6175 
6176     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6177 }
6178 
6179 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6180 {
6181     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6182     if (!element)
6183         element = HTMLCanvasElement::create(*this);
6184     return element.get();
6185 }
6186 
6187 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6188 {
6189     for (const auto&amp; entry : m_cssCanvasElements) {
6190         if (entry.value.get() == &amp;canvasElement)
6191             return entry.key;
6192     }
6193     return String();
6194 }
6195 
6196 #if ENABLE(TEXT_AUTOSIZING)
6197 TextAutoSizing&amp; Document::textAutoSizing()
6198 {
6199     if (!m_textAutoSizing)
<span class="line-modified">6200         m_textAutoSizing = std::make_unique&lt;TextAutoSizing&gt;();</span>
6201     return *m_textAutoSizing;
6202 }
6203 #endif // ENABLE(TEXT_AUTOSIZING)
6204 
6205 void Document::initDNSPrefetch()
6206 {
6207     m_haveExplicitlyDisabledDNSPrefetch = false;
6208     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6209 
6210     // Inherit DNS prefetch opt-out from parent frame
6211     if (Document* parent = parentDocument()) {
6212         if (!parent-&gt;isDNSPrefetchEnabled())
6213             m_isDNSPrefetchEnabled = false;
6214     }
6215 }
6216 
6217 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6218 {
6219     if (!settings().dnsPrefetchingEnabled())
6220         return;
6221 
6222     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6223         m_isDNSPrefetchEnabled = true;
6224         return;
6225     }
6226 
6227     m_isDNSPrefetchEnabled = false;
6228     m_haveExplicitlyDisabledDNSPrefetch = true;
6229 }
6230 




















6231 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6232 {
6233     if (!isContextThread()) {
6234         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6235         return;
6236     }
6237 
6238     if (Page* page = this-&gt;page())
6239         page-&gt;console().addMessage(WTFMove(consoleMessage));
6240 }
6241 
6242 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6243 {
6244     if (!isContextThread()) {
6245         postTask(AddConsoleMessageTask(source, level, message));
6246         return;
6247     }
6248 
6249     if (Page* page = this-&gt;page())
6250         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6251 
6252     if (m_consoleMessageListener)
6253         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6254 }
6255 
6256 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)
6257 {
6258     if (!isContextThread()) {
6259         postTask(AddConsoleMessageTask(source, level, message));
6260         return;
6261     }
6262 
6263     if (Page* page = this-&gt;page())
6264         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6265 }
6266 
6267 void Document::postTask(Task&amp;&amp; task)
6268 {
<span class="line-modified">6269     callOnMainThread([documentReference = makeWeakPtr(*this), task = WTFMove(task)]() mutable {</span>
6270         ASSERT(isMainThread());
6271 
<span class="line-modified">6272         Document* document = documentReference.get();</span>
6273         if (!document)
6274             return;
6275 
6276         Page* page = document-&gt;page();
6277         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6278             document-&gt;m_pendingTasks.append(WTFMove(task));
6279         else
6280             task.performTask(*document);
6281     });
6282 }
6283 
6284 void Document::pendingTasksTimerFired()
6285 {
6286     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6287     for (auto&amp; task : pendingTasks)
6288         task.performTask(*this);
6289 }
6290 
6291 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6292 {
</pre>
<hr />
<pre>
6336         m_pendingTasksTimer.startOneShot(0_s);
6337     scriptRunner().resume();
6338     resumeActiveDOMObjects(reason);
6339     resumeScriptedAnimationControllerCallbacks();
6340 
6341     m_scheduledTasksAreSuspended = false;
6342 }
6343 
6344 void Document::suspendScriptedAnimationControllerCallbacks()
6345 {
6346     if (m_scriptedAnimationController)
6347         m_scriptedAnimationController-&gt;suspend();
6348 }
6349 
6350 void Document::resumeScriptedAnimationControllerCallbacks()
6351 {
6352     if (m_scriptedAnimationController)
6353         m_scriptedAnimationController-&gt;resume();
6354 }
6355 
<span class="line-modified">6356 void Document::windowScreenDidChange(PlatformDisplayID displayID)</span>
6357 {
<span class="line-modified">6358 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">6359     if (m_animationScheduler)</span>
<span class="line-modified">6360         m_animationScheduler-&gt;windowScreenDidChange(displayID);</span>
<span class="line-modified">6361 #endif</span>





6362 


6363     if (RenderView* view = renderView()) {
6364         if (view-&gt;usesCompositing())
6365             view-&gt;compositor().windowScreenDidChange(displayID);
6366     }
6367 }
6368 
6369 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6370 {
6371     if (!m_decoder)
6372         return string;
6373     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6374 }
6375 
6376 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6377 {
6378     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6379     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6380 }
6381 
6382 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
</pre>
<hr />
<pre>
6414 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6415 
6416 DeviceMotionController&amp; Document::deviceMotionController() const
6417 {
6418     return *m_deviceMotionController;
6419 }
6420 
6421 DeviceOrientationController&amp; Document::deviceOrientationController() const
6422 {
6423     return *m_deviceOrientationController;
6424 }
6425 
6426 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6427 {
6428     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6429     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6430 }
6431 
6432 #endif
6433 
<span class="line-modified">6434 #if ENABLE(FULLSCREEN_API)</span>
6435 
<span class="line-modified">6436 bool Document::fullScreenIsAllowedForElement(Element&amp; element) const</span>
6437 {
<span class="line-modified">6438     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, element.document().ownerElement());</span>







6439 }
6440 
<span class="line-modified">6441 void Document::requestFullScreenForElement(Element* element, FullScreenCheckType checkType)</span>


6442 {
<span class="line-modified">6443     if (!element)</span>
<span class="line-modified">6444         element = documentElement();</span>
6445 
<span class="line-modified">6446     auto failedPreflights = [this](auto element) mutable {</span>
<span class="line-modified">6447         m_fullScreenErrorEventTargetQueue.append(WTFMove(element));</span>
<span class="line-modified">6448         m_fullScreenTaskQueue.enqueueTask([this] {</span>
<span class="line-removed">6449             dispatchFullScreenChangeEvents();</span>
<span class="line-removed">6450         });</span>
<span class="line-removed">6451     };</span>
6452 
<span class="line-modified">6453     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire</span>
<span class="line-modified">6454     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s</span>
<span class="line-modified">6455     // node document:</span>








6456 
<span class="line-modified">6457     // This algorithm is not allowed to show a pop-up:</span>
<span class="line-modified">6458     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:</span>
<span class="line-modified">6459     //   - an activation behavior is currently being processed whose click event was trusted, or</span>
<span class="line-modified">6460     //   - the event listener for a trusted click event is being handled.</span>
<span class="line-modified">6461     if (!UserGestureIndicator::processingUserGesture()) {</span>
<span class="line-removed">6462         failedPreflights(WTFMove(element));</span>
<span class="line-removed">6463         return;</span>
<span class="line-removed">6464     }</span>
6465 
<span class="line-modified">6466     // We do not allow pressing the Escape key as a user gesture to enter fullscreen since this is the key</span>
<span class="line-modified">6467     // to exit fullscreen.</span>
<span class="line-modified">6468     if (UserGestureIndicator::currentUserGesture()-&gt;gestureType() == UserGestureType::EscapeKey) {</span>
<span class="line-modified">6469         addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;The Escape key may not be used as a user gesture to enter fullscreen&quot;_s);</span>
<span class="line-modified">6470         failedPreflights(WTFMove(element));</span>
<span class="line-removed">6471         return;</span>
<span class="line-removed">6472     }</span>
6473 
<span class="line-modified">6474     // There is a previously-established user preference, security risk, or platform limitation.</span>
<span class="line-modified">6475     if (!page() || !page()-&gt;settings().fullScreenEnabled()) {</span>
<span class="line-removed">6476         failedPreflights(WTFMove(element));</span>
<span class="line-removed">6477         return;</span>
<span class="line-removed">6478     }</span>
6479 
<span class="line-modified">6480     bool hasKeyboardAccess = true;</span>
<span class="line-modified">6481     if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {</span>
<span class="line-modified">6482         // The new full screen API does not accept a &quot;flags&quot; parameter, so fall back to disallowing</span>
<span class="line-modified">6483         // keyboard input if the chrome client refuses to allow keyboard input.</span>
<span class="line-removed">6484         hasKeyboardAccess = false;</span>
6485 
<span class="line-modified">6486         if (!page()-&gt;chrome().client().supportsFullScreenForElement(*element, hasKeyboardAccess)) {</span>
<span class="line-modified">6487             failedPreflights(WTFMove(element));</span>
<span class="line-modified">6488             return;</span>
<span class="line-modified">6489         }</span>
<span class="line-modified">6490     }</span>
<span class="line-removed">6491 </span>
<span class="line-removed">6492     m_fullScreenTaskQueue.enqueueTask([this, element = makeRefPtr(element), checkType, hasKeyboardAccess, failedPreflights] () mutable {</span>
<span class="line-removed">6493         // Don&#39;t allow fullscreen if document is hidden.</span>
<span class="line-removed">6494         if (hidden()) {</span>
<span class="line-removed">6495             failedPreflights(WTFMove(element));</span>
<span class="line-removed">6496             return;</span>
<span class="line-removed">6497         }</span>
<span class="line-removed">6498 </span>
<span class="line-removed">6499         // The context object is not in a document.</span>
<span class="line-removed">6500         if (!element-&gt;isConnected()) {</span>
<span class="line-removed">6501             failedPreflights(WTFMove(element));</span>
<span class="line-removed">6502             return;</span>
<span class="line-removed">6503         }</span>
<span class="line-removed">6504 </span>
<span class="line-removed">6505         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have</span>
<span class="line-removed">6506         // the fullscreen enabled flag set.</span>
<span class="line-removed">6507         if (checkType == EnforceIFrameAllowFullScreenRequirement &amp;&amp; !fullScreenIsAllowedForElement(*element)) {</span>
<span class="line-removed">6508             failedPreflights(WTFMove(element));</span>
<span class="line-removed">6509             return;</span>
<span class="line-removed">6510         }</span>
<span class="line-removed">6511 </span>
<span class="line-removed">6512         // The context object&#39;s node document fullscreen element stack is not empty and its top element</span>
<span class="line-removed">6513         // is not an ancestor of the context object.</span>
<span class="line-removed">6514         if (!m_fullScreenElementStack.isEmpty() &amp;&amp; !m_fullScreenElementStack.last()-&gt;contains(element.get())) {</span>
<span class="line-removed">6515             failedPreflights(WTFMove(element));</span>
<span class="line-removed">6516             return;</span>
<span class="line-removed">6517         }</span>
<span class="line-removed">6518 </span>
<span class="line-removed">6519         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.</span>
<span class="line-removed">6520         bool descendentHasNonEmptyStack = false;</span>
<span class="line-removed">6521         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {</span>
<span class="line-removed">6522             if (descendant-&gt;document()-&gt;webkitFullscreenElement()) {</span>
<span class="line-removed">6523                 descendentHasNonEmptyStack = true;</span>
<span class="line-removed">6524                 break;</span>
<span class="line-removed">6525             }</span>
<span class="line-removed">6526         }</span>
<span class="line-removed">6527         if (descendentHasNonEmptyStack) {</span>
<span class="line-removed">6528             failedPreflights(WTFMove(element));</span>
<span class="line-removed">6529             return;</span>
<span class="line-removed">6530         }</span>
<span class="line-removed">6531 </span>
<span class="line-removed">6532         // 2. Let doc be element&#39;s node document. (i.e. &quot;this&quot;)</span>
<span class="line-removed">6533         Document* currentDoc = this;</span>
<span class="line-removed">6534 </span>
<span class="line-removed">6535         // 3. Let docs be all doc&#39;s ancestor browsing context&#39;s documents (if any) and doc.</span>
<span class="line-removed">6536         Deque&lt;Document*&gt; docs;</span>
<span class="line-removed">6537 </span>
<span class="line-removed">6538         do {</span>
<span class="line-removed">6539             docs.prepend(currentDoc);</span>
<span class="line-removed">6540             currentDoc = currentDoc-&gt;ownerElement() ? &amp;currentDoc-&gt;ownerElement()-&gt;document() : nullptr;</span>
<span class="line-removed">6541         } while (currentDoc);</span>
<span class="line-removed">6542 </span>
<span class="line-removed">6543         // 4. For each document in docs, run these substeps:</span>
<span class="line-removed">6544         Deque&lt;Document*&gt;::iterator current = docs.begin(), following = docs.begin();</span>
<span class="line-removed">6545 </span>
<span class="line-removed">6546         do {</span>
<span class="line-removed">6547             ++following;</span>
<span class="line-removed">6548 </span>
<span class="line-removed">6549             // 1. Let following document be the document after document in docs, or null if there is no</span>
<span class="line-removed">6550             // such document.</span>
<span class="line-removed">6551             Document* currentDoc = *current;</span>
<span class="line-removed">6552             Document* followingDoc = following != docs.end() ? *following : nullptr;</span>
<span class="line-removed">6553 </span>
<span class="line-removed">6554             // 2. If following document is null, push context object on document&#39;s fullscreen element</span>
<span class="line-removed">6555             // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute</span>
<span class="line-removed">6556             // set to true on the document.</span>
<span class="line-removed">6557             if (!followingDoc) {</span>
<span class="line-removed">6558                 currentDoc-&gt;pushFullscreenElementStack(*element);</span>
<span class="line-removed">6559                 addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">6560                 continue;</span>
<span class="line-removed">6561             }</span>
<span class="line-removed">6562 </span>
<span class="line-removed">6563             // 3. Otherwise, if document&#39;s fullscreen element stack is either empty or its top element</span>
<span class="line-removed">6564             // is not following document&#39;s browsing context container,</span>
<span class="line-removed">6565             Element* topElement = currentDoc-&gt;webkitFullscreenElement();</span>
<span class="line-removed">6566             if (!topElement || topElement != followingDoc-&gt;ownerElement()) {</span>
<span class="line-removed">6567                 // ...push following document&#39;s browsing context container on document&#39;s fullscreen element</span>
<span class="line-removed">6568                 // stack, and queue a task to fire an event named fullscreenchange with its bubbles attribute</span>
<span class="line-removed">6569                 // set to true on document.</span>
<span class="line-removed">6570                 currentDoc-&gt;pushFullscreenElementStack(*followingDoc-&gt;ownerElement());</span>
<span class="line-removed">6571                 addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">6572                 continue;</span>
<span class="line-removed">6573             }</span>
<span class="line-removed">6574 </span>
<span class="line-removed">6575             // 4. Otherwise, do nothing for this document. It stays the same.</span>
<span class="line-removed">6576         } while (++current != docs.end());</span>
<span class="line-removed">6577 </span>
<span class="line-removed">6578         // 5. Return, and run the remaining steps asynchronously.</span>
<span class="line-removed">6579         // 6. Optionally, perform some animation.</span>
<span class="line-removed">6580         m_areKeysEnabledInFullScreen = hasKeyboardAccess;</span>
<span class="line-removed">6581         m_fullScreenTaskQueue.enqueueTask([this, element = WTFMove(element)] {</span>
<span class="line-removed">6582             if (auto page = this-&gt;page())</span>
<span class="line-removed">6583                 page-&gt;chrome().client().enterFullScreenForElement(*element.get());</span>
<span class="line-removed">6584         });</span>
<span class="line-removed">6585 </span>
<span class="line-removed">6586         // 7. Optionally, display a message indicating how the user can exit displaying the context object fullscreen.</span>
<span class="line-removed">6587     });</span>
<span class="line-removed">6588 }</span>
<span class="line-removed">6589 </span>
<span class="line-removed">6590 void Document::webkitCancelFullScreen()</span>
<span class="line-removed">6591 {</span>
<span class="line-removed">6592     // The Mozilla &quot;cancelFullScreen()&quot; API behaves like the W3C &quot;fully exit fullscreen&quot; behavior, which</span>
<span class="line-removed">6593     // is defined as:</span>
<span class="line-removed">6594     // &quot;To fully exit fullscreen act as if the exitFullscreen() method was invoked on the top-level browsing</span>
<span class="line-removed">6595     // context&#39;s document and subsequently empty that document&#39;s fullscreen element stack.&quot;</span>
<span class="line-removed">6596     Document&amp; topDocument = this-&gt;topDocument();</span>
<span class="line-removed">6597     if (!topDocument.webkitFullscreenElement())</span>
<span class="line-removed">6598         return;</span>
<span class="line-removed">6599 </span>
<span class="line-removed">6600     // To achieve that aim, remove all the elements from the top document&#39;s stack except for the first before</span>
<span class="line-removed">6601     // calling webkitExitFullscreen():</span>
<span class="line-removed">6602     Vector&lt;RefPtr&lt;Element&gt;&gt; replacementFullscreenElementStack;</span>
<span class="line-removed">6603     replacementFullscreenElementStack.append(topDocument.webkitFullscreenElement());</span>
<span class="line-removed">6604     topDocument.m_fullScreenElementStack.swap(replacementFullscreenElementStack);</span>
<span class="line-removed">6605 </span>
<span class="line-removed">6606     topDocument.webkitExitFullscreen();</span>
<span class="line-removed">6607 }</span>
<span class="line-removed">6608 </span>
<span class="line-removed">6609 void Document::webkitExitFullscreen()</span>
<span class="line-removed">6610 {</span>
<span class="line-removed">6611     // The exitFullscreen() method must run these steps:</span>
<span class="line-removed">6612 </span>
<span class="line-removed">6613     // 1. Let doc be the context object. (i.e. &quot;this&quot;)</span>
<span class="line-removed">6614     Document* currentDoc = this;</span>
<span class="line-removed">6615 </span>
<span class="line-removed">6616     // 2. If doc&#39;s fullscreen element stack is empty, terminate these steps.</span>
<span class="line-removed">6617     if (m_fullScreenElementStack.isEmpty())</span>
<span class="line-removed">6618         return;</span>
<span class="line-removed">6619 </span>
<span class="line-removed">6620     // 3. Let descendants be all the doc&#39;s descendant browsing context&#39;s documents with a non-empty fullscreen</span>
<span class="line-removed">6621     // element stack (if any), ordered so that the child of the doc is last and the document furthest</span>
<span class="line-removed">6622     // away from the doc is first.</span>
<span class="line-removed">6623     Deque&lt;RefPtr&lt;Document&gt;&gt; descendants;</span>
<span class="line-removed">6624     for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {</span>
<span class="line-removed">6625         if (descendant-&gt;document()-&gt;webkitFullscreenElement())</span>
<span class="line-removed">6626             descendants.prepend(descendant-&gt;document());</span>
<span class="line-removed">6627     }</span>
<span class="line-removed">6628 </span>
<span class="line-removed">6629     // 4. For each descendant in descendants, empty descendant&#39;s fullscreen element stack, and queue a</span>
<span class="line-removed">6630     // task to fire an event named fullscreenchange with its bubbles attribute set to true on descendant.</span>
<span class="line-removed">6631     for (auto&amp; document : descendants) {</span>
<span class="line-removed">6632         document-&gt;clearFullscreenElementStack();</span>
<span class="line-removed">6633         addDocumentToFullScreenChangeEventQueue(*document);</span>
<span class="line-removed">6634     }</span>
<span class="line-removed">6635 </span>
<span class="line-removed">6636     // 5. While doc is not null, run these substeps:</span>
<span class="line-removed">6637     Element* newTop = nullptr;</span>
<span class="line-removed">6638     while (currentDoc) {</span>
<span class="line-removed">6639         // 1. Pop the top element of doc&#39;s fullscreen element stack.</span>
<span class="line-removed">6640         currentDoc-&gt;popFullscreenElementStack();</span>
<span class="line-removed">6641 </span>
<span class="line-removed">6642         //    If doc&#39;s fullscreen element stack is non-empty and the element now at the top is either</span>
<span class="line-removed">6643         //    not in a document or its node document is not doc, repeat this substep.</span>
<span class="line-removed">6644         newTop = currentDoc-&gt;webkitFullscreenElement();</span>
<span class="line-removed">6645         if (newTop &amp;&amp; (!newTop-&gt;isConnected() || &amp;newTop-&gt;document() != currentDoc))</span>
<span class="line-removed">6646             continue;</span>
<span class="line-removed">6647 </span>
<span class="line-removed">6648         // 2. Queue a task to fire an event named fullscreenchange with its bubbles attribute set to true</span>
<span class="line-removed">6649         // on doc.</span>
<span class="line-removed">6650         addDocumentToFullScreenChangeEventQueue(*currentDoc);</span>
<span class="line-removed">6651 </span>
<span class="line-removed">6652         // 3. If doc&#39;s fullscreen element stack is empty and doc&#39;s browsing context has a browsing context</span>
<span class="line-removed">6653         // container, set doc to that browsing context container&#39;s node document.</span>
<span class="line-removed">6654         if (!newTop &amp;&amp; currentDoc-&gt;ownerElement()) {</span>
<span class="line-removed">6655             currentDoc = &amp;currentDoc-&gt;ownerElement()-&gt;document();</span>
<span class="line-removed">6656             continue;</span>
<span class="line-removed">6657         }</span>
<span class="line-removed">6658 </span>
<span class="line-removed">6659         // 4. Otherwise, set doc to null.</span>
<span class="line-removed">6660         currentDoc = nullptr;</span>
<span class="line-removed">6661     }</span>
<span class="line-removed">6662 </span>
<span class="line-removed">6663     // 6. Return, and run the remaining steps asynchronously.</span>
<span class="line-removed">6664     // 7. Optionally, perform some animation.</span>
<span class="line-removed">6665     m_fullScreenTaskQueue.enqueueTask([this, newTop = makeRefPtr(newTop), fullScreenElement = m_fullScreenElement] {</span>
<span class="line-removed">6666         auto* page = this-&gt;page();</span>
<span class="line-removed">6667         if (!page)</span>
<span class="line-removed">6668             return;</span>
<span class="line-removed">6669 </span>
<span class="line-removed">6670         // Only exit out of full screen window mode if there are no remaining elements in the</span>
<span class="line-removed">6671         // full screen stack.</span>
<span class="line-removed">6672         if (!newTop) {</span>
<span class="line-removed">6673             page-&gt;chrome().client().exitFullScreenForElement(fullScreenElement.get());</span>
<span class="line-removed">6674             return;</span>
<span class="line-removed">6675         }</span>
<span class="line-removed">6676 </span>
<span class="line-removed">6677         // Otherwise, notify the chrome of the new full screen element.</span>
<span class="line-removed">6678         page-&gt;chrome().client().enterFullScreenForElement(*newTop);</span>
<span class="line-removed">6679     });</span>
<span class="line-removed">6680 }</span>
<span class="line-removed">6681 </span>
<span class="line-removed">6682 bool Document::webkitFullscreenEnabled() const</span>
<span class="line-removed">6683 {</span>
<span class="line-removed">6684     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor</span>
<span class="line-removed">6685     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.</span>
<span class="line-removed">6686 </span>
<span class="line-removed">6687     // Top-level browsing contexts are implied to have their allowFullScreen attribute set.</span>
<span class="line-removed">6688     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, ownerElement());</span>
<span class="line-removed">6689 }</span>
<span class="line-removed">6690 </span>
<span class="line-removed">6691 static void unwrapFullScreenRenderer(RenderFullScreen* fullScreenRenderer, Element* fullScreenElement)</span>
<span class="line-removed">6692 {</span>
<span class="line-removed">6693     if (!fullScreenRenderer)</span>
<span class="line-removed">6694         return;</span>
<span class="line-removed">6695     bool requiresRenderTreeRebuild;</span>
<span class="line-removed">6696     fullScreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);</span>
<span class="line-removed">6697 </span>
<span class="line-removed">6698     if (requiresRenderTreeRebuild &amp;&amp; fullScreenElement &amp;&amp; fullScreenElement-&gt;parentElement())</span>
<span class="line-removed">6699         fullScreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();</span>
<span class="line-removed">6700 }</span>
<span class="line-removed">6701 </span>
<span class="line-removed">6702 void Document::webkitWillEnterFullScreen(Element&amp; element)</span>
<span class="line-removed">6703 {</span>
<span class="line-removed">6704     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">6705         return;</span>
<span class="line-removed">6706 </span>
<span class="line-removed">6707     // Protect against being called after the document has been removed from the page.</span>
<span class="line-removed">6708     if (!page())</span>
<span class="line-removed">6709         return;</span>
<span class="line-removed">6710 </span>
<span class="line-removed">6711     ASSERT(page()-&gt;settings().fullScreenEnabled());</span>
<span class="line-removed">6712 </span>
<span class="line-removed">6713     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());</span>
<span class="line-removed">6714 </span>
<span class="line-removed">6715     element.willBecomeFullscreenElement();</span>
<span class="line-removed">6716 </span>
<span class="line-removed">6717     m_fullScreenElement = &amp;element;</span>
<span class="line-removed">6718 </span>
<span class="line-removed">6719 #if USE(NATIVE_FULLSCREEN_VIDEO)</span>
<span class="line-removed">6720     if (element.isMediaElement())</span>
<span class="line-removed">6721         return;</span>
<span class="line-removed">6722 #endif</span>
<span class="line-removed">6723 </span>
<span class="line-removed">6724     // Create a placeholder block for a the full-screen element, to keep the page from reflowing</span>
<span class="line-removed">6725     // when the element is removed from the normal flow.  Only do this for a RenderBox, as only</span>
<span class="line-removed">6726     // a box will have a frameRect.  The placeholder will be created in setFullScreenRenderer()</span>
<span class="line-removed">6727     // during layout.</span>
<span class="line-removed">6728     auto renderer = m_fullScreenElement-&gt;renderer();</span>
<span class="line-removed">6729     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);</span>
<span class="line-removed">6730     if (shouldCreatePlaceholder) {</span>
<span class="line-removed">6731         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();</span>
<span class="line-removed">6732         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());</span>
<span class="line-removed">6733     }</span>
<span class="line-removed">6734 </span>
<span class="line-removed">6735     if (m_fullScreenElement != documentElement() &amp;&amp; renderer)</span>
<span class="line-removed">6736         RenderFullScreen::wrapExistingRenderer(*renderer, *this);</span>
<span class="line-removed">6737 </span>
<span class="line-removed">6738     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);</span>
<span class="line-removed">6739 </span>
<span class="line-removed">6740     resolveStyle(ResolveStyleType::Rebuild);</span>
<span class="line-removed">6741     dispatchFullScreenChangeEvents();</span>
<span class="line-removed">6742 }</span>
<span class="line-removed">6743 </span>
<span class="line-removed">6744 void Document::webkitDidEnterFullScreen()</span>
<span class="line-removed">6745 {</span>
<span class="line-removed">6746     if (!m_fullScreenElement)</span>
<span class="line-removed">6747         return;</span>
<span class="line-removed">6748 </span>
<span class="line-removed">6749     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">6750         return;</span>
<span class="line-removed">6751 </span>
<span class="line-removed">6752     m_fullScreenElement-&gt;didBecomeFullscreenElement();</span>
<span class="line-removed">6753 }</span>
<span class="line-removed">6754 </span>
<span class="line-removed">6755 void Document::webkitWillExitFullScreen()</span>
<span class="line-removed">6756 {</span>
<span class="line-removed">6757     if (!m_fullScreenElement)</span>
<span class="line-removed">6758         return;</span>
<span class="line-removed">6759 </span>
<span class="line-removed">6760     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">6761         return;</span>
<span class="line-removed">6762 </span>
<span class="line-removed">6763     m_fullScreenElement-&gt;willStopBeingFullscreenElement();</span>
<span class="line-removed">6764 }</span>
<span class="line-removed">6765 </span>
<span class="line-removed">6766 void Document::webkitDidExitFullScreen()</span>
<span class="line-removed">6767 {</span>
<span class="line-removed">6768     if (!m_fullScreenElement)</span>
<span class="line-removed">6769         return;</span>
<span class="line-removed">6770 </span>
<span class="line-removed">6771     if (!hasLivingRenderTree() || pageCacheState() != NotInPageCache)</span>
<span class="line-removed">6772         return;</span>
<span class="line-removed">6773 </span>
<span class="line-removed">6774     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);</span>
<span class="line-removed">6775 </span>
<span class="line-removed">6776     m_areKeysEnabledInFullScreen = false;</span>
<span class="line-removed">6777 </span>
<span class="line-removed">6778     unwrapFullScreenRenderer(m_fullScreenRenderer.get(), m_fullScreenElement.get());</span>
<span class="line-removed">6779 </span>
<span class="line-removed">6780     m_fullScreenElement = nullptr;</span>
<span class="line-removed">6781     scheduleFullStyleRebuild();</span>
<span class="line-removed">6782 </span>
<span class="line-removed">6783     // When webkitCancelFullScreen is called, we call webkitExitFullScreen on the topDocument(). That</span>
<span class="line-removed">6784     // means that the events will be queued there. So if we have no events here, start the timer on</span>
<span class="line-removed">6785     // the exiting document.</span>
<span class="line-removed">6786     bool eventTargetQueuesEmpty = m_fullScreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullScreenErrorEventTargetQueue.isEmpty();</span>
<span class="line-removed">6787     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : *this;</span>
<span class="line-removed">6788 </span>
<span class="line-removed">6789     exitingDocument.dispatchFullScreenChangeEvents();</span>
<span class="line-removed">6790 }</span>
<span class="line-removed">6791 </span>
<span class="line-removed">6792 void Document::setFullScreenRenderer(RenderTreeBuilder&amp; builder, RenderFullScreen&amp; renderer)</span>
<span class="line-removed">6793 {</span>
<span class="line-removed">6794     if (&amp;renderer == m_fullScreenRenderer)</span>
<span class="line-removed">6795         return;</span>
<span class="line-removed">6796 </span>
<span class="line-removed">6797     if (m_savedPlaceholderRenderStyle)</span>
<span class="line-removed">6798         builder.createPlaceholderForFullScreen(renderer, WTFMove(m_savedPlaceholderRenderStyle), m_savedPlaceholderFrameRect);</span>
<span class="line-removed">6799     else if (m_fullScreenRenderer &amp;&amp; m_fullScreenRenderer-&gt;placeholder()) {</span>
<span class="line-removed">6800         auto* placeholder = m_fullScreenRenderer-&gt;placeholder();</span>
<span class="line-removed">6801         builder.createPlaceholderForFullScreen(renderer, RenderStyle::clonePtr(placeholder-&gt;style()), placeholder-&gt;frameRect());</span>
<span class="line-removed">6802     }</span>
<span class="line-removed">6803 </span>
<span class="line-removed">6804     if (m_fullScreenRenderer)</span>
<span class="line-removed">6805         builder.destroy(*m_fullScreenRenderer);</span>
<span class="line-removed">6806     ASSERT(!m_fullScreenRenderer);</span>
<span class="line-removed">6807 </span>
<span class="line-removed">6808     m_fullScreenRenderer = makeWeakPtr(renderer);</span>
<span class="line-removed">6809 }</span>
<span class="line-removed">6810 </span>
<span class="line-removed">6811 void Document::dispatchFullScreenChangeEvents()</span>
<span class="line-removed">6812 {</span>
<span class="line-removed">6813     // Since we dispatch events in this function, it&#39;s possible that the</span>
<span class="line-removed">6814     // document will be detached and GC&#39;d. We protect it here to make sure we</span>
<span class="line-removed">6815     // can finish the function successfully.</span>
<span class="line-removed">6816     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-removed">6817     Deque&lt;RefPtr&lt;Node&gt;&gt; changeQueue;</span>
<span class="line-removed">6818     m_fullScreenChangeEventTargetQueue.swap(changeQueue);</span>
<span class="line-removed">6819     Deque&lt;RefPtr&lt;Node&gt;&gt; errorQueue;</span>
<span class="line-removed">6820     m_fullScreenErrorEventTargetQueue.swap(errorQueue);</span>
<span class="line-removed">6821     dispatchFullScreenChangeOrErrorEvent(changeQueue, eventNames().webkitfullscreenchangeEvent, /* shouldNotifyMediaElement */ true);</span>
<span class="line-removed">6822     dispatchFullScreenChangeOrErrorEvent(errorQueue, eventNames().webkitfullscreenerrorEvent, /* shouldNotifyMediaElement */ false);</span>
<span class="line-removed">6823 }</span>
<span class="line-removed">6824 </span>
<span class="line-removed">6825 void Document::dispatchFullScreenChangeOrErrorEvent(Deque&lt;RefPtr&lt;Node&gt;&gt;&amp; queue, const AtomicString&amp; eventName, bool shouldNotifyMediaElement)</span>
<span class="line-removed">6826 {</span>
<span class="line-removed">6827     while (!queue.isEmpty()) {</span>
<span class="line-removed">6828         RefPtr&lt;Node&gt; node = queue.takeFirst();</span>
<span class="line-removed">6829         if (!node)</span>
<span class="line-removed">6830             node = documentElement();</span>
<span class="line-removed">6831         // The dispatchEvent below may have blown away our documentElement.</span>
<span class="line-removed">6832         if (!node)</span>
<span class="line-removed">6833             continue;</span>
<span class="line-removed">6834 </span>
<span class="line-removed">6835         // If the element was removed from our tree, also message the documentElement. Since we may</span>
<span class="line-removed">6836         // have a document hierarchy, check that node isn&#39;t in another document.</span>
<span class="line-removed">6837         if (!node-&gt;isConnected())</span>
<span class="line-removed">6838             queue.append(documentElement());</span>
<span class="line-removed">6839 </span>
<span class="line-removed">6840 #if ENABLE(VIDEO)</span>
<span class="line-removed">6841         if (shouldNotifyMediaElement &amp;&amp; is&lt;HTMLMediaElement&gt;(*node))</span>
<span class="line-removed">6842             downcast&lt;HTMLMediaElement&gt;(*node).enteredOrExitedFullscreen();</span>
<span class="line-removed">6843 #else</span>
<span class="line-removed">6844         UNUSED_PARAM(shouldNotifyMediaElement);</span>
<span class="line-removed">6845 #endif</span>
<span class="line-removed">6846         node-&gt;dispatchEvent(Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::No));</span>
<span class="line-removed">6847     }</span>
<span class="line-removed">6848 }</span>
<span class="line-removed">6849 </span>
<span class="line-removed">6850 void Document::fullScreenElementRemoved()</span>
<span class="line-removed">6851 {</span>
<span class="line-removed">6852     m_fullScreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);</span>
<span class="line-removed">6853     webkitCancelFullScreen();</span>
<span class="line-removed">6854 }</span>
<span class="line-removed">6855 </span>
<span class="line-removed">6856 void Document::adjustFullScreenElementOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)</span>
<span class="line-removed">6857 {</span>
<span class="line-removed">6858     if (!m_fullScreenElement)</span>
<span class="line-removed">6859         return;</span>
<span class="line-removed">6860 </span>
<span class="line-removed">6861     bool elementInSubtree = false;</span>
<span class="line-removed">6862     if (nodeRemoval == NodeRemoval::ChildrenOfNode)</span>
<span class="line-removed">6863         elementInSubtree = m_fullScreenElement-&gt;isDescendantOf(node);</span>
<span class="line-removed">6864     else</span>
<span class="line-removed">6865         elementInSubtree = (m_fullScreenElement == &amp;node) || m_fullScreenElement-&gt;isDescendantOf(node);</span>
<span class="line-removed">6866 </span>
<span class="line-removed">6867     if (elementInSubtree)</span>
<span class="line-removed">6868         fullScreenElementRemoved();</span>
<span class="line-removed">6869 }</span>
<span class="line-removed">6870 </span>
<span class="line-removed">6871 bool Document::isAnimatingFullScreen() const</span>
<span class="line-removed">6872 {</span>
<span class="line-removed">6873     return m_isAnimatingFullScreen;</span>
<span class="line-removed">6874 }</span>
<span class="line-removed">6875 </span>
<span class="line-removed">6876 void Document::setAnimatingFullScreen(bool flag)</span>
<span class="line-removed">6877 {</span>
<span class="line-removed">6878     if (m_isAnimatingFullScreen == flag)</span>
<span class="line-removed">6879         return;</span>
<span class="line-removed">6880     m_isAnimatingFullScreen = flag;</span>
<span class="line-removed">6881 </span>
<span class="line-removed">6882     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {</span>
<span class="line-removed">6883         m_fullScreenElement-&gt;invalidateStyleForSubtree();</span>
<span class="line-removed">6884         scheduleFullStyleRebuild();</span>
<span class="line-removed">6885     }</span>
<span class="line-removed">6886 }</span>
<span class="line-removed">6887 </span>
<span class="line-removed">6888 bool Document::areFullscreenControlsHidden() const</span>
<span class="line-removed">6889 {</span>
<span class="line-removed">6890     return m_areFullscreenControlsHidden;</span>
<span class="line-removed">6891 }</span>
<span class="line-removed">6892 </span>
<span class="line-removed">6893 void Document::setFullscreenControlsHidden(bool flag)</span>
<span class="line-removed">6894 {</span>
<span class="line-removed">6895     if (m_areFullscreenControlsHidden == flag)</span>
<span class="line-removed">6896         return;</span>
<span class="line-removed">6897     m_areFullscreenControlsHidden = flag;</span>
<span class="line-removed">6898 </span>
<span class="line-removed">6899     if (m_fullScreenElement &amp;&amp; m_fullScreenElement-&gt;isDescendantOf(*this)) {</span>
<span class="line-removed">6900         m_fullScreenElement-&gt;invalidateStyleForSubtree();</span>
<span class="line-removed">6901         scheduleFullStyleRebuild();</span>
<span class="line-removed">6902     }</span>
<span class="line-removed">6903 }</span>
<span class="line-removed">6904 </span>
<span class="line-removed">6905 void Document::clearFullscreenElementStack()</span>
<span class="line-removed">6906 {</span>
<span class="line-removed">6907     m_fullScreenElementStack.clear();</span>
<span class="line-removed">6908 }</span>
<span class="line-removed">6909 </span>
<span class="line-removed">6910 void Document::popFullscreenElementStack()</span>
<span class="line-removed">6911 {</span>
<span class="line-removed">6912     if (m_fullScreenElementStack.isEmpty())</span>
<span class="line-removed">6913         return;</span>
<span class="line-removed">6914 </span>
<span class="line-removed">6915     m_fullScreenElementStack.removeLast();</span>
<span class="line-removed">6916 }</span>
<span class="line-removed">6917 </span>
<span class="line-removed">6918 void Document::pushFullscreenElementStack(Element&amp; element)</span>
<span class="line-removed">6919 {</span>
<span class="line-removed">6920     m_fullScreenElementStack.append(&amp;element);</span>
<span class="line-removed">6921 }</span>
<span class="line-removed">6922 </span>
<span class="line-removed">6923 void Document::addDocumentToFullScreenChangeEventQueue(Document&amp; document)</span>
<span class="line-removed">6924 {</span>
<span class="line-removed">6925     Node* target = document.webkitFullscreenElement();</span>
<span class="line-removed">6926     if (!target)</span>
<span class="line-removed">6927         target = document.webkitCurrentFullScreenElement();</span>
<span class="line-removed">6928     if (!target)</span>
<span class="line-removed">6929         target = &amp;document;</span>
<span class="line-removed">6930     m_fullScreenChangeEventTargetQueue.append(target);</span>
<span class="line-removed">6931 }</span>
<span class="line-removed">6932 </span>
<span class="line-removed">6933 #endif</span>
<span class="line-removed">6934 </span>
<span class="line-removed">6935 #if ENABLE(POINTER_LOCK)</span>
<span class="line-removed">6936 </span>
<span class="line-removed">6937 void Document::exitPointerLock()</span>
<span class="line-removed">6938 {</span>
<span class="line-removed">6939     Page* page = this-&gt;page();</span>
<span class="line-removed">6940     if (!page)</span>
<span class="line-removed">6941         return;</span>
<span class="line-removed">6942     if (auto* target = page-&gt;pointerLockController().element()) {</span>
<span class="line-removed">6943         if (&amp;target-&gt;document() != this)</span>
<span class="line-removed">6944             return;</span>
<span class="line-removed">6945     }</span>
<span class="line-removed">6946     page-&gt;pointerLockController().requestPointerUnlock();</span>
<span class="line-removed">6947 }</span>
<span class="line-removed">6948 </span>
<span class="line-removed">6949 #endif</span>
<span class="line-removed">6950 </span>
<span class="line-removed">6951 void Document::decrementLoadEventDelayCount()</span>
<span class="line-removed">6952 {</span>
<span class="line-removed">6953     ASSERT(m_loadEventDelayCount);</span>
<span class="line-removed">6954     --m_loadEventDelayCount;</span>
<span class="line-removed">6955 </span>
<span class="line-removed">6956     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())</span>
<span class="line-removed">6957         m_loadEventDelayTimer.startOneShot(0_s);</span>
<span class="line-removed">6958 }</span>
<span class="line-removed">6959 </span>
<span class="line-removed">6960 void Document::loadEventDelayTimerFired()</span>
<span class="line-removed">6961 {</span>
<span class="line-removed">6962     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?</span>
<span class="line-removed">6963     // FIXME: Should this also call DocumentLoader::checkLoadComplete?</span>
<span class="line-removed">6964     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is</span>
<span class="line-removed">6965     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.</span>
<span class="line-removed">6966     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-removed">6967     checkCompleted();</span>
<span class="line-removed">6968     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">6969         frame-&gt;loader().checkLoadComplete();</span>
<span class="line-removed">6970 }</span>
<span class="line-removed">6971 </span>
<span class="line-removed">6972 void Document::checkCompleted()</span>
<span class="line-removed">6973 {</span>
<span class="line-removed">6974     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">6975         frame-&gt;loader().checkCompleted();</span>
<span class="line-removed">6976 }</span>
<span class="line-removed">6977 </span>
<span class="line-removed">6978 double Document::monotonicTimestamp() const</span>
<span class="line-removed">6979 {</span>
<span class="line-removed">6980     auto* loader = this-&gt;loader();</span>
<span class="line-removed">6981     if (!loader)</span>
<span class="line-removed">6982         return 0;</span>
<span class="line-removed">6983 </span>
<span class="line-removed">6984     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();</span>
<span class="line-removed">6985 }</span>
<span class="line-removed">6986 </span>
<span class="line-removed">6987 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)</span>
<span class="line-removed">6988 {</span>
<span class="line-removed">6989     if (!m_scriptedAnimationController) {</span>
<span class="line-removed">6990         m_scriptedAnimationController = ScriptedAnimationController::create(*this);</span>
<span class="line-removed">6991 </span>
<span class="line-removed">6992         // It&#39;s possible that the Page may have suspended scripted animations before</span>
<span class="line-removed">6993         // we were created. We need to make sure that we don&#39;t start up the animation</span>
<span class="line-removed">6994         // controller on a background tab, for example.</span>
<span class="line-removed">6995         if (!page() || page()-&gt;scriptedAnimationsSuspended())</span>
<span class="line-removed">6996             m_scriptedAnimationController-&gt;suspend();</span>
6997 
6998         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6999             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
7000 
7001         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
7002             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
7003     }
7004 
7005     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
7006 }
7007 
7008 void Document::cancelAnimationFrame(int id)
7009 {
7010     if (!m_scriptedAnimationController)
7011         return;
7012     m_scriptedAnimationController-&gt;cancelCallback(id);
7013 }
7014 
7015 void Document::clearScriptedAnimationController()
7016 {
</pre>
<hr />
<pre>
7021 }
7022 
7023 void Document::wheelEventHandlersChanged()
7024 {
7025     Page* page = this-&gt;page();
7026     if (!page)
7027         return;
7028 
7029     if (FrameView* frameView = view()) {
7030         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
7031             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
7032     }
7033 
7034     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
7035     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
7036 }
7037 
7038 void Document::didAddWheelEventHandler(Node&amp; node)
7039 {
7040     if (!m_wheelEventTargets)
<span class="line-modified">7041         m_wheelEventTargets = std::make_unique&lt;EventTargetSet&gt;();</span>
7042 
7043     m_wheelEventTargets-&gt;add(&amp;node);
7044 
7045     wheelEventHandlersChanged();
7046 
7047     if (Frame* frame = this-&gt;frame())
7048         DebugPageOverlays::didChangeEventHandlers(*frame);
7049 }
7050 
7051 HttpEquivPolicy Document::httpEquivPolicy() const
7052 {
7053     if (shouldEnforceContentDispositionAttachmentSandbox())
7054         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
7055     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
7056         return HttpEquivPolicy::DisabledBySettings;
7057     return HttpEquivPolicy::Enabled;
7058 }
7059 
7060 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
7061 {
</pre>
<hr />
<pre>
7081     if (Frame* frame = this-&gt;frame())
7082         DebugPageOverlays::didChangeEventHandlers(*frame);
7083 }
7084 
7085 unsigned Document::wheelEventHandlerCount() const
7086 {
7087     if (!m_wheelEventTargets)
7088         return 0;
7089 
7090     unsigned count = 0;
7091     for (auto&amp; handler : *m_wheelEventTargets)
7092         count += handler.value;
7093 
7094     return count;
7095 }
7096 
7097 void Document::didAddTouchEventHandler(Node&amp; handler)
7098 {
7099 #if ENABLE(TOUCH_EVENTS)
7100     if (!m_touchEventTargets)
<span class="line-modified">7101         m_touchEventTargets = std::make_unique&lt;EventTargetSet&gt;();</span>
7102 
7103     m_touchEventTargets-&gt;add(&amp;handler);
7104 
7105     if (Document* parent = parentDocument()) {
7106         parent-&gt;didAddTouchEventHandler(*this);
7107         return;
7108     }
7109 #else
7110     UNUSED_PARAM(handler);
7111 #endif
7112 }
7113 
7114 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
7115 {
7116 #if ENABLE(TOUCH_EVENTS)
7117     if (!m_touchEventTargets)
7118         return;
7119 
7120     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
7121 
</pre>
<hr />
<pre>
7222 {
7223     m_lastHandledUserGestureTimestamp = time;
7224 
7225     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
7226         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
7227         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
7228     }
7229 
7230     // DOM Timer alignment may depend on the user having interacted with the document.
7231     didChangeTimerAlignmentInterval();
7232 
7233     if (HTMLFrameOwnerElement* element = ownerElement())
7234         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
7235 }
7236 
7237 bool Document::processingUserGestureForMedia() const
7238 {
7239     if (UserGestureIndicator::processingUserGestureForMedia())
7240         return true;
7241 



7242     if (settings().mediaUserGestureInheritsFromDocument())
7243         return topDocument().hasHadUserInteraction();
7244 
7245     auto* loader = this-&gt;loader();
7246     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
7247         return topDocument().hasHadUserInteraction();
7248 
7249     return false;
7250 }
7251 
7252 void Document::startTrackingStyleRecalcs()
7253 {
7254     m_styleRecalcCount = 0;
7255 }
7256 
7257 unsigned Document::styleRecalcCount() const
7258 {
7259     return m_styleRecalcCount;
7260 }
7261 
</pre>
<hr />
<pre>
7387 
7388 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
7389 {
7390     if (!elementA || !elementB)
7391         return nullptr;
7392 
7393     if (elementA == elementB)
7394         return elementA;
7395 
7396     HashSet&lt;Element*&gt; ancestorChain;
7397     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
7398         ancestorChain.add(element);
7399 
7400     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
7401         if (ancestorChain.contains(element))
7402             return element;
7403     }
7404     return nullptr;
7405 }
7406 
<span class="line-modified">7407 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement)</span>
7408 {
7409     ASSERT(!request.readOnly());
7410 
7411     Element* innerElementInDocument = innerElement;
7412     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
7413         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
7414         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
7415     }
7416 
7417     Element* oldActiveElement = m_activeElement.get();
7418     if (oldActiveElement &amp;&amp; !request.active()) {
7419         // We are clearing the :active chain because the mouse has been released.
7420         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
7421             currentElement-&gt;setActive(false);
7422             m_userActionElements.setInActiveChain(*currentElement, false);
7423         }
7424         m_activeElement = nullptr;
7425     } else {
7426         Element* newActiveElement = innerElementInDocument;
7427         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
7428             // We are setting the :active chain and freezing it. If future moves happen, they
7429             // will need to reference this chain.
7430             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
7431                 Element* element = curr-&gt;element();
7432                 if (!element || curr-&gt;isTextOrLineBreak())
7433                     continue;
7434                 m_userActionElements.setInActiveChain(*element, true);
7435             }
7436 
7437             m_activeElement = newActiveElement;
7438         }
7439     }
7440     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
7441     // nodes should remain :active until the mouse is released.
7442     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
7443 
7444     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
7445     // :hover/:active to only apply to elements that are in the :active chain that we froze
<span class="line-modified">7446     // at the time the mouse went down.</span>
<span class="line-modified">7447     bool mustBeInActiveChain = request.active() &amp;&amp; request.move();</span>
7448 
7449     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
7450 
7451     // A touch release does not set a new hover target; clearing the element we&#39;re working with
7452     // will clear the chain of hovered elements all the way to the top of the tree.
7453     if (request.touchRelease())
7454         innerElementInDocument = nullptr;
7455 
7456     // Check to see if the hovered Element has changed.
7457     // If it hasn&#39;t, we do not need to do anything.
7458     Element* newHoveredElement = innerElementInDocument;
7459     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
7460         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
7461 
7462     m_hoveredElement = newHoveredElement;
7463 
7464     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
7465 
7466     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
7467     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
</pre>
<hr />
<pre>
7489         element-&gt;setHovered(false);
7490 
7491     bool sawCommonAncestor = false;
7492     for (auto&amp; element : elementsToAddToChain) {
7493         if (allowActiveChanges)
7494             element-&gt;setActive(true);
7495         if (element == commonAncestor)
7496             sawCommonAncestor = true;
7497         if (!sawCommonAncestor) {
7498             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
7499             element-&gt;setHovered(true);
7500         }
7501     }
7502 }
7503 
7504 bool Document::haveStylesheetsLoaded() const
7505 {
7506     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
7507 }
7508 
<span class="line-modified">7509 Locale&amp; Document::getCachedLocale(const AtomicString&amp; locale)</span>
7510 {
<span class="line-modified">7511     AtomicString localeKey = locale;</span>
7512     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
7513         localeKey = defaultLanguage();
7514     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
7515     if (result.isNewEntry)
7516         result.iterator-&gt;value = Locale::create(localeKey);
7517     return *(result.iterator-&gt;value);
7518 }
7519 
7520 Document&amp; Document::ensureTemplateDocument()
7521 {
7522     if (const Document* document = templateDocument())
7523         return const_cast&lt;Document&amp;&gt;(*document);
7524 
7525     if (isHTMLDocument())
<span class="line-modified">7526         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());</span>
7527     else
<span class="line-modified">7528         m_templateDocument = create(WTF::blankURL());</span>
7529 
7530     m_templateDocument-&gt;setContextDocument(contextDocument());
7531     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
7532 
7533     return *m_templateDocument;
7534 }
7535 
7536 Ref&lt;FontFaceSet&gt; Document::fonts()
7537 {
7538     updateStyleIfNeeded();
7539     return fontSelector().fontFaceSet();
7540 }
7541 





7542 float Document::deviceScaleFactor() const
7543 {
7544     float deviceScaleFactor = 1.0;
7545     if (Page* documentPage = page())
7546         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
7547     return deviceScaleFactor;
7548 }
7549 
7550 bool Document::useSystemAppearance() const
7551 {
<span class="line-modified">7552     bool useSystemAppearance = false;</span>
<span class="line-modified">7553     if (Page* documentPage = page())</span>
<span class="line-modified">7554         useSystemAppearance = documentPage-&gt;useSystemAppearance();</span>
<span class="line-removed">7555     return useSystemAppearance;</span>
7556 }
7557 
7558 bool Document::useDarkAppearance(const RenderStyle* style) const
7559 {
<span class="line-removed">7560 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
7561 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">7562     OptionSet&lt;ColorSchemes&gt; supportedColorSchemes;</span>
7563 
7564     // Use the style&#39;s supported color schemes, if supplied.
7565     if (style)
<span class="line-modified">7566         supportedColorSchemes = style-&gt;supportedColorSchemes().colorSchemes();</span>
7567 
7568     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
<span class="line-modified">7569     if (supportedColorSchemes.isEmpty())</span>
<span class="line-modified">7570         supportedColorSchemes = m_supportedColorSchemes;</span>
7571 
<span class="line-modified">7572     if (supportedColorSchemes.contains(ColorSchemes::Dark) &amp;&amp; !supportedColorSchemes.contains(ColorSchemes::Light))</span>
7573         return true;
7574 #else
7575     UNUSED_PARAM(style);
7576 #endif
7577 
7578     bool pageUsesDarkAppearance = false;
7579     if (Page* documentPage = page())
7580         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
7581 
7582     if (useSystemAppearance())
7583         return pageUsesDarkAppearance;
7584 
7585 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">7586     if (supportedColorSchemes.contains(ColorSchemes::Dark))</span>
7587         return pageUsesDarkAppearance;
7588 #endif
<span class="line-removed">7589 #else</span>
<span class="line-removed">7590     UNUSED_PARAM(style);</span>
<span class="line-removed">7591 #endif</span>
7592 
7593     return false;
7594 }
7595 







7596 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
7597 {
7598     OptionSet&lt;StyleColor::Options&gt; options;
7599     if (useSystemAppearance())
7600         options.add(StyleColor::Options::UseSystemAppearance);
7601     if (useDarkAppearance(style))
7602         options.add(StyleColor::Options::UseDarkAppearance);


7603     return options;
7604 }
7605 














7606 void Document::didAssociateFormControl(Element&amp; element)
7607 {
7608     auto* page = this-&gt;page();
7609     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7610         return;
7611     m_associatedFormControls.add(&amp;element);
7612     if (!m_didAssociateFormControlsTimer.isActive())
7613         m_didAssociateFormControlsTimer.startOneShot(0_s);
7614 }
7615 
7616 void Document::didAssociateFormControlsTimerFired()
7617 {
7618     auto vector = copyToVector(m_associatedFormControls);
7619     m_associatedFormControls.clear();
<span class="line-modified">7620     if (auto* page = this-&gt;page())</span>
<span class="line-modified">7621         page-&gt;chrome().client().didAssociateFormControls(vector);</span>


7622 }
7623 
7624 void Document::setCachedDOMCookies(const String&amp; cookies)
7625 {
7626     ASSERT(!isDOMCookieCacheValid());
7627     m_cachedDOMCookies = cookies;
7628     // The cookie cache is valid at most until we go back to the event loop.
7629     m_cookieCacheExpiryTimer.startOneShot(0_s);
7630 }
7631 
7632 void Document::invalidateDOMCookieCache()
7633 {
7634     m_cookieCacheExpiryTimer.stop();
7635     m_cachedDOMCookies = String();
7636 }
7637 
7638 void Document::didLoadResourceSynchronously()
7639 {
7640     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7641     // in this case, to be safe.
7642     invalidateDOMCookieCache();
7643 }
7644 
7645 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7646 {
7647     if (m_hasInjectedPlugInsScript)
7648         return;
7649 


7650     // Use the JS file provided by the Chrome client, or fallback to the default one.
7651     String jsString = page()-&gt;chrome().client().plugInExtraScript();
<span class="line-modified">7652     if (!jsString)</span>
7653         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7654 
<span class="line-modified">7655     frame()-&gt;script().evaluateInWorld(ScriptSourceCode(jsString), world);</span>

7656 
7657     m_hasInjectedPlugInsScript = true;
7658 }
7659 
7660 #if ENABLE(WEB_CRYPTO)
7661 
7662 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7663 {
7664     Page* page = this-&gt;page();
7665     if (!page)
7666         return false;
7667     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7668 }
7669 
7670 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7671 {
7672     Page* page = this-&gt;page();
7673     if (!page)
7674         return false;
7675     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
</pre>
<hr />
<pre>
7812 
7813 bool Document::shouldEnforceHTTP09Sandbox() const
7814 {
7815     if (m_isSynthesized || !m_frame)
7816         return false;
7817     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7818     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7819 }
7820 
7821 #if USE(QUICK_LOOK)
7822 bool Document::shouldEnforceQuickLookSandbox() const
7823 {
7824     if (m_isSynthesized || !m_frame)
7825         return false;
7826     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7827     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7828 }
7829 
7830 void Document::applyQuickLookSandbox()
7831 {
<span class="line-modified">7832     const URL&amp; responseURL = m_frame-&gt;loader().activeDocumentLoader()-&gt;responseURL();</span>



7833     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7834 
<span class="line-modified">7835     auto securityOrigin = SecurityOrigin::create(responseURL);</span>
7836     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7837     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7838 
7839     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7840     RELEASE_ASSERT(contentSecurityPolicy());
7841     // The sandbox directive is only allowed if the policy is from an HTTP header.
7842     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7843 
7844     disableSandboxFlags(SandboxNavigation);
7845 
7846     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7847 }
7848 #endif
7849 
7850 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7851 {
7852     if (!settings().contentDispositionAttachmentSandboxEnabled())
7853         return false;
7854 
7855     if (m_isSynthesized)
</pre>
<hr />
<pre>
7874 void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)
7875 {
7876     m_viewportDependentPictures.add(&amp;picture);
7877 }
7878 
7879 void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)
7880 {
7881     m_viewportDependentPictures.remove(&amp;picture);
7882 }
7883 
7884 void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7885 {
7886     m_appearanceDependentPictures.add(&amp;picture);
7887 }
7888 
7889 void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7890 {
7891     m_appearanceDependentPictures.remove(&amp;picture);
7892 }
7893 









7894 #if ENABLE(INTERSECTION_OBSERVER)
7895 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7896 {
7897     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7898     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7899 }
7900 
7901 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7902 {
7903     m_intersectionObservers.removeFirst(&amp;observer);
7904 }
7905 
7906 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7907 {
7908     FloatBoxExtent rootMarginFloatBox(
7909         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7910         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7911         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7912         floatValueForLength(rootMargin.left(), localRootBounds.width())
7913     );
</pre>
<hr />
<pre>
7963 
7964         if (rootRenderer-&gt;hasOverflowClip())
7965             localRootBounds = rootRenderer-&gt;contentBoxRect();
7966         else
7967             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7968     } else {
7969         ASSERT(frameView.frame().isMainFrame());
7970         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7971         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7972             return WTF::nullopt;
7973         rootRenderer = frameView.renderView();
7974         localRootBounds = frameView.layoutViewportRect();
7975     }
7976 
7977     if (applyRootMargin)
7978         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7979 
7980     LayoutRect localTargetBounds;
7981     if (is&lt;RenderBox&gt;(*targetRenderer))
7982         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
<span class="line-modified">7983     else if (is&lt;RenderInline&gt;(targetRenderer))</span>
<span class="line-modified">7984         localTargetBounds = downcast&lt;RenderInline&gt;(targetRenderer)-&gt;linesBoundingBox();</span>
<span class="line-modified">7985     else if (is&lt;RenderLineBreak&gt;(targetRenderer))</span>




7986         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7987 
7988     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7989     if (observer.root()) {
7990         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7991         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7992     } else
7993         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7994 
7995     FloatRect rootLocalIntersectionRect = localRootBounds;
7996 
7997     IntersectionObservationState intersectionState;
7998     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7999 
8000     if (intersectionState.isIntersecting) {
8001         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
8002         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
8003             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
8004         else {
8005             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
8006             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
8007         }
8008     }
8009 
8010     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
8011     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
8012     return intersectionState;
8013 }
8014 
8015 void Document::updateIntersectionObservations()
8016 {
8017     auto* frameView = view();
8018     if (!frameView)
8019         return;
8020 


8021     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
8022     if (needsLayout || hasPendingStyleRecalc())
8023         return;
8024 
<span class="line-removed">8025     m_needsForcedIntersectionObservationUpdate = false;</span>
<span class="line-removed">8026 </span>
8027     for (const auto&amp; observer : m_intersectionObservers) {
8028         bool needNotify = false;
8029         DOMHighResTimeStamp timestamp;
8030         if (!observer-&gt;createTimestamp(timestamp))
8031             continue;
8032         for (Element* target : observer-&gt;observationTargets()) {
8033             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
8034             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
8035                 return registration.observer.get() == observer;
8036             });
8037             ASSERT(index != notFound);
8038             auto&amp; registration = targetRegistrations[index];
8039 
8040             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
8041             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
8042 
8043             float intersectionRatio = 0;
8044             size_t thresholdIndex = 0;
8045             if (intersectionState) {
8046                 if (intersectionState-&gt;isIntersecting) {
</pre>
<hr />
<pre>
8083                     timestamp,
8084                     reportedRootBounds,
8085                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
8086                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
8087                     intersectionRatio,
8088                     target,
8089                     thresholdIndex &gt; 0,
8090                 }));
8091                 needNotify = true;
8092                 registration.previousThresholdIndex = thresholdIndex;
8093             }
8094         }
8095         if (needNotify)
8096             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
8097     }
8098 
8099     if (m_intersectionObserversWithPendingNotifications.size())
8100         m_intersectionObserversNotifyTimer.startOneShot(0_s);
8101 }
8102 
<span class="line-removed">8103 void Document::scheduleForcedIntersectionObservationUpdate()</span>
<span class="line-removed">8104 {</span>
<span class="line-removed">8105     ASSERT(!m_intersectionObservers.isEmpty());</span>
<span class="line-removed">8106     if (m_needsForcedIntersectionObservationUpdate)</span>
<span class="line-removed">8107         return;</span>
<span class="line-removed">8108 </span>
<span class="line-removed">8109     m_needsForcedIntersectionObservationUpdate = true;</span>
<span class="line-removed">8110     if (auto* page = this-&gt;page())</span>
<span class="line-removed">8111         page-&gt;scheduleForcedIntersectionObservationUpdate(*this);</span>
<span class="line-removed">8112 }</span>
<span class="line-removed">8113 </span>
8114 void Document::notifyIntersectionObserversTimerFired()
8115 {
8116     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
8117         if (observer)
8118             observer-&gt;notify();
8119     }
8120     m_intersectionObserversWithPendingNotifications.clear();
8121 }








8122 #endif
8123 
<span class="line-modified">8124 const AtomicString&amp; Document::dir() const</span>


















































































8125 {
8126     auto* documentElement = this-&gt;documentElement();
8127     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
8128         return nullAtom();
8129     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
8130 }
8131 
<span class="line-modified">8132 void Document::setDir(const AtomicString&amp; value)</span>
8133 {
8134     auto* documentElement = this-&gt;documentElement();
8135     if (is&lt;HTMLHtmlElement&gt;(documentElement))
8136         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
8137 }
8138 
8139 DOMSelection* Document::getSelection()
8140 {
8141     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
8142 }
8143 
8144 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
8145 {
8146     ASSERT(shadowRoot.isConnected());
8147     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
8148     m_inDocumentShadowRoots.add(&amp;shadowRoot);
8149 }
8150 
8151 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
8152 {
8153     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
8154     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
8155 }
8156 
8157 void Document::orientationChanged(int orientation)
8158 {
8159     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
8160     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
8161     m_orientationNotifier.orientationChanged(orientation);
8162 }
8163 
8164 void Document::notifyMediaCaptureOfVisibilityChanged()
8165 {
8166 #if ENABLE(MEDIA_STREAM)
8167     if (!page())
8168         return;
8169 
<span class="line-modified">8170     RealtimeMediaSourceCenter::singleton().setVideoCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
8171 #endif
8172 }
8173 
8174 #if ENABLE(MEDIA_STREAM)
8175 void Document::stopMediaCapture()
8176 {
<span class="line-modified">8177     MediaStreamRegistry::shared().forEach([this](MediaStream&amp; stream) {</span>
<span class="line-removed">8178         if (stream.document() == this)</span>
<span class="line-removed">8179             stream.endCaptureTracks();</span>
<span class="line-removed">8180     });</span>
8181 }
8182 
8183 void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
8184 {
8185     m_mediaStreamStateChangeElements.add(&amp;element);
8186 }
8187 
8188 void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
8189 {
8190     m_mediaStreamStateChangeElements.remove(&amp;element);
8191 }
8192 
8193 void Document::mediaStreamCaptureStateChanged()
8194 {
8195     if (!MediaProducer::isCapturing(m_mediaState))
8196         return;
8197 
8198     for (auto* mediaElement : m_mediaStreamStateChangeElements)
8199         mediaElement-&gt;mediaStreamCaptureStarted();
8200 }
</pre>
<hr />
<pre>
8206 }
8207 
8208 #endif
8209 
8210 void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
8211 {
8212     m_applicationStateChangeListeners.add(&amp;listener);
8213 }
8214 
8215 void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
8216 {
8217     m_applicationStateChangeListeners.remove(&amp;listener);
8218 }
8219 
8220 void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)
8221 {
8222     for (auto* listener : m_applicationStateChangeListeners)
8223         functor(*listener);
8224 }
8225 
<span class="line-modified">8226 const AtomicString&amp; Document::bgColor() const</span>
8227 {
8228     auto* bodyElement = body();
8229     if (!bodyElement)
8230         return emptyAtom();
8231     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
8232 }
8233 
8234 void Document::setBgColor(const String&amp; value)
8235 {
8236     if (auto* bodyElement = body())
8237         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
8238 }
8239 
<span class="line-modified">8240 const AtomicString&amp; Document::fgColor() const</span>
8241 {
8242     auto* bodyElement = body();
8243     if (!bodyElement)
8244         return emptyAtom();
8245     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
8246 }
8247 
8248 void Document::setFgColor(const String&amp; value)
8249 {
8250     if (auto* bodyElement = body())
8251         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
8252 }
8253 
<span class="line-modified">8254 const AtomicString&amp; Document::alinkColor() const</span>
8255 {
8256     auto* bodyElement = body();
8257     if (!bodyElement)
8258         return emptyAtom();
8259     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
8260 }
8261 
8262 void Document::setAlinkColor(const String&amp; value)
8263 {
8264     if (auto* bodyElement = body())
8265         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
8266 }
8267 
<span class="line-modified">8268 const AtomicString&amp; Document::linkColorForBindings() const</span>
8269 {
8270     auto* bodyElement = body();
8271     if (!bodyElement)
8272         return emptyAtom();
8273     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
8274 }
8275 
8276 void Document::setLinkColorForBindings(const String&amp; value)
8277 {
8278     if (auto* bodyElement = body())
8279         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
8280 }
8281 
<span class="line-modified">8282 const AtomicString&amp; Document::vlinkColor() const</span>
8283 {
8284     auto* bodyElement = body();
8285     if (!bodyElement)
8286         return emptyAtom();
8287     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
8288 }
8289 
8290 void Document::setVlinkColor(const String&amp; value)
8291 {
8292     if (auto* bodyElement = body())
8293         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
8294 }
8295 
8296 Logger&amp; Document::logger()
8297 {
8298     if (!m_logger) {
8299         m_logger = Logger::create(this);
8300         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());
8301         m_logger-&gt;addObserver(*this);
8302     }
8303 
8304     return *m_logger;
8305 }
8306 
<span class="line-modified">8307 Optional&lt;uint64_t&gt; Document::pageID() const</span>
8308 {
8309     return m_frame-&gt;loader().client().pageID();
8310 }
8311 
<span class="line-removed">8312 void Document::hasStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-removed">8313 {</span>
<span class="line-removed">8314     ASSERT(settings().storageAccessAPIEnabled());</span>
<span class="line-removed">8315 </span>
<span class="line-removed">8316 #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-removed">8317     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {</span>
<span class="line-removed">8318         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">8319         return;</span>
<span class="line-removed">8320     }</span>
<span class="line-removed">8321 </span>
<span class="line-removed">8322     if (!m_frame || securityOrigin().isUnique()) {</span>
<span class="line-removed">8323         promise-&gt;resolve&lt;IDLBoolean&gt;(false);</span>
<span class="line-removed">8324         return;</span>
<span class="line-removed">8325     }</span>
<span class="line-removed">8326 </span>
<span class="line-removed">8327     if (m_frame-&gt;isMainFrame()) {</span>
<span class="line-removed">8328         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">8329         return;</span>
<span class="line-removed">8330     }</span>
<span class="line-removed">8331 </span>
<span class="line-removed">8332     auto&amp; securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-removed">8333     auto&amp; topSecurityOrigin = topDocument().securityOrigin();</span>
<span class="line-removed">8334     if (securityOrigin.equal(&amp;topSecurityOrigin)) {</span>
<span class="line-removed">8335         promise-&gt;resolve&lt;IDLBoolean&gt;(true);</span>
<span class="line-removed">8336         return;</span>
<span class="line-removed">8337     }</span>
<span class="line-removed">8338 </span>
<span class="line-removed">8339     auto frameID = m_frame-&gt;loader().client().frameID();</span>
<span class="line-removed">8340     auto pageID = m_frame-&gt;loader().client().pageID();</span>
<span class="line-removed">8341     if (!frameID || !pageID) {</span>
<span class="line-removed">8342         promise-&gt;reject();</span>
<span class="line-removed">8343         return;</span>
<span class="line-removed">8344     }</span>
<span class="line-removed">8345 </span>
<span class="line-removed">8346     if (Page* page = this-&gt;page()) {</span>
<span class="line-removed">8347         auto iframeHost = securityOrigin.host();</span>
<span class="line-removed">8348         auto topHost = topSecurityOrigin.host();</span>
<span class="line-removed">8349         page-&gt;chrome().client().hasStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool hasAccess) {</span>
<span class="line-removed">8350             Document* document = documentReference.get();</span>
<span class="line-removed">8351             if (!document)</span>
<span class="line-removed">8352                 return;</span>
<span class="line-removed">8353 </span>
<span class="line-removed">8354             promise-&gt;resolve&lt;IDLBoolean&gt;(hasAccess);</span>
<span class="line-removed">8355         });</span>
<span class="line-removed">8356         return;</span>
<span class="line-removed">8357     }</span>
<span class="line-removed">8358 #endif</span>
<span class="line-removed">8359 </span>
<span class="line-removed">8360     promise-&gt;reject();</span>
<span class="line-removed">8361 }</span>
<span class="line-removed">8362 </span>
<span class="line-removed">8363 void Document::requestStorageAccess(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-removed">8364 {</span>
<span class="line-removed">8365     ASSERT(settings().storageAccessAPIEnabled());</span>
<span class="line-removed">8366 </span>
<span class="line-removed">8367 #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-removed">8368     if (m_frame &amp;&amp; hasFrameSpecificStorageAccess()) {</span>
<span class="line-removed">8369         promise-&gt;resolve();</span>
<span class="line-removed">8370         return;</span>
<span class="line-removed">8371     }</span>
<span class="line-removed">8372 </span>
<span class="line-removed">8373     if (!m_frame || securityOrigin().isUnique()) {</span>
<span class="line-removed">8374         promise-&gt;reject();</span>
<span class="line-removed">8375         return;</span>
<span class="line-removed">8376     }</span>
<span class="line-removed">8377 </span>
<span class="line-removed">8378     if (m_frame-&gt;isMainFrame()) {</span>
<span class="line-removed">8379         promise-&gt;resolve();</span>
<span class="line-removed">8380         return;</span>
<span class="line-removed">8381     }</span>
<span class="line-removed">8382 </span>
<span class="line-removed">8383     auto&amp; topDocument = this-&gt;topDocument();</span>
<span class="line-removed">8384     auto&amp; topSecurityOrigin = topDocument.securityOrigin();</span>
<span class="line-removed">8385     auto&amp; securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-removed">8386     if (securityOrigin.equal(&amp;topSecurityOrigin)) {</span>
<span class="line-removed">8387         promise-&gt;resolve();</span>
<span class="line-removed">8388         return;</span>
<span class="line-removed">8389     }</span>
<span class="line-removed">8390 </span>
<span class="line-removed">8391     // If there is a sandbox, it has to allow the storage access API to be called.</span>
<span class="line-removed">8392     if (sandboxFlags() != SandboxNone &amp;&amp; isSandboxed(SandboxStorageAccessByUserActivation)) {</span>
<span class="line-removed">8393         promise-&gt;reject();</span>
<span class="line-removed">8394         return;</span>
<span class="line-removed">8395     }</span>
<span class="line-removed">8396 </span>
<span class="line-removed">8397     // The iframe has to be a direct child of the top document.</span>
<span class="line-removed">8398     if (&amp;topDocument != parentDocument()) {</span>
<span class="line-removed">8399         promise-&gt;reject();</span>
<span class="line-removed">8400         return;</span>
<span class="line-removed">8401     }</span>
<span class="line-removed">8402 </span>
<span class="line-removed">8403     if (!UserGestureIndicator::processingUserGesture()) {</span>
<span class="line-removed">8404         promise-&gt;reject();</span>
<span class="line-removed">8405         return;</span>
<span class="line-removed">8406     }</span>
<span class="line-removed">8407 </span>
<span class="line-removed">8408     auto iframeHost = securityOrigin.host();</span>
<span class="line-removed">8409     auto topHost = topSecurityOrigin.host();</span>
<span class="line-removed">8410 </span>
<span class="line-removed">8411     Page* page = this-&gt;page();</span>
<span class="line-removed">8412     auto frameID = m_frame-&gt;loader().client().frameID();</span>
<span class="line-removed">8413     auto pageID = m_frame-&gt;loader().client().pageID();</span>
<span class="line-removed">8414     if (!page || !frameID || !pageID) {</span>
<span class="line-removed">8415         promise-&gt;reject();</span>
<span class="line-removed">8416         return;</span>
<span class="line-removed">8417     }</span>
<span class="line-removed">8418 </span>
<span class="line-removed">8419     page-&gt;chrome().client().requestStorageAccess(WTFMove(iframeHost), WTFMove(topHost), frameID.value(), pageID.value(), [documentReference = makeWeakPtr(*this), promise = WTFMove(promise)] (bool wasGranted) mutable {</span>
<span class="line-removed">8420         Document* document = documentReference.get();</span>
<span class="line-removed">8421         if (!document)</span>
<span class="line-removed">8422             return;</span>
<span class="line-removed">8423 </span>
<span class="line-removed">8424         if (wasGranted) {</span>
<span class="line-removed">8425             document-&gt;setHasFrameSpecificStorageAccess(true);</span>
<span class="line-removed">8426             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = makeWeakPtr(*document)] () {</span>
<span class="line-removed">8427                 if (auto* document = documentReference.get())</span>
<span class="line-removed">8428                     document-&gt;enableTemporaryTimeUserGesture();</span>
<span class="line-removed">8429             }));</span>
<span class="line-removed">8430             promise-&gt;resolve();</span>
<span class="line-removed">8431             MicrotaskQueue::mainThreadQueue().append(std::make_unique&lt;VoidMicrotask&gt;([documentReference = WTFMove(documentReference)] () {</span>
<span class="line-removed">8432                 if (auto* document = documentReference.get())</span>
<span class="line-removed">8433                     document-&gt;consumeTemporaryTimeUserGesture();</span>
<span class="line-removed">8434             }));</span>
<span class="line-removed">8435         } else</span>
<span class="line-removed">8436             promise-&gt;reject();</span>
<span class="line-removed">8437     });</span>
<span class="line-removed">8438 #else</span>
<span class="line-removed">8439     promise-&gt;reject();</span>
<span class="line-removed">8440 #endif</span>
<span class="line-removed">8441 }</span>
<span class="line-removed">8442 </span>
<span class="line-removed">8443 void Document::enableTemporaryTimeUserGesture()</span>
<span class="line-removed">8444 {</span>
<span class="line-removed">8445     m_temporaryUserGesture = std::make_unique&lt;UserGestureIndicator&gt;(ProcessingUserGesture, this);</span>
<span class="line-removed">8446 }</span>
<span class="line-removed">8447 </span>
<span class="line-removed">8448 void Document::consumeTemporaryTimeUserGesture()</span>
<span class="line-removed">8449 {</span>
<span class="line-removed">8450     m_temporaryUserGesture = nullptr;</span>
<span class="line-removed">8451 }</span>
<span class="line-removed">8452 </span>
8453 void Document::registerArticleElement(Element&amp; article)
8454 {
8455     m_articleElements.add(&amp;article);
8456 }
8457 
8458 void Document::unregisterArticleElement(Element&amp; article)
8459 {
8460     m_articleElements.remove(&amp;article);
8461     if (m_mainArticleElement == &amp;article)
8462         m_mainArticleElement = nullptr;
8463 }
8464 
8465 void Document::updateMainArticleElementAfterLayout()
8466 {
8467     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
8468 
8469     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
8470     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
8471 
8472     // We consider an article to be main content if it is either:
</pre>
<hr />
<pre>
8500 
8501     if (numberOfArticles == 1) {
8502         m_mainArticleElement = tallestArticle;
8503         return;
8504     }
8505 
8506     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
8507         return;
8508 
8509     if (!view())
8510         return;
8511 
8512     auto viewportSize = view()-&gt;layoutViewportRect().size();
8513     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
8514         return;
8515 
8516     m_mainArticleElement = tallestArticle;
8517 }
8518 
8519 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">8520 bool Document::hasFrameSpecificStorageAccess() const</span>
8521 {
<span class="line-modified">8522     return m_frame &amp;&amp; m_frame-&gt;loader().client().hasFrameSpecificStorageAccess();</span>
8523 }
8524 
<span class="line-modified">8525 void Document::setHasFrameSpecificStorageAccess(bool value)</span>
8526 {
<span class="line-modified">8527     if (m_frame)</span>
<span class="line-removed">8528     m_frame-&gt;loader().client().setHasFrameSpecificStorageAccess(value);</span>
8529 }
8530 
<span class="line-modified">8531 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)</span>
8532 {
<span class="line-modified">8533     return m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction == primaryDomain;</span>
8534 }
8535 
<span class="line-modified">8536 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const String&amp; primaryDomain)</span>
8537 {
<span class="line-modified">8538     m_primaryDomainRequestedPageSpecificStorageAccessWithUserInteraction = primaryDomain;</span>





















8539 }
8540 #endif
8541 
8542 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
8543 {
8544     m_consoleMessageListener = listener;
8545 }
8546 
<span class="line-removed">8547 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-removed">8548 DocumentAnimationScheduler&amp; Document::animationScheduler()</span>
<span class="line-removed">8549 {</span>
<span class="line-removed">8550     if (!m_animationScheduler)</span>
<span class="line-removed">8551         m_animationScheduler = DocumentAnimationScheduler::create(*this, page() ? page()-&gt;chrome().displayID() : 0);</span>
<span class="line-removed">8552 </span>
<span class="line-removed">8553     return *m_animationScheduler;</span>
<span class="line-removed">8554 }</span>
<span class="line-removed">8555 #endif</span>
<span class="line-removed">8556 </span>
8557 DocumentTimeline&amp; Document::timeline()
8558 {
8559     if (!m_timeline)
8560         m_timeline = DocumentTimeline::create(*this);
8561 
8562     return *m_timeline;
8563 }
8564 
8565 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
8566 {
8567     // For the list of animations to be current, we need to account for any pending CSS changes,
8568     // such as updates to CSS Animations and CSS Transitions.
8569     updateStyleIfNeeded();
8570 
8571     if (m_timeline)
8572         return m_timeline-&gt;getAnimations();
8573     return { };
8574 }
8575 
8576 #if ENABLE(ATTACHMENT_ELEMENT)
</pre>
<hr />
<pre>
8607     if (!identifier)
8608         return;
8609 
8610     m_attachmentIdentifierToElementMap.remove(identifier);
8611 
8612     if (frame())
8613         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
8614 }
8615 
8616 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
8617 {
8618     return m_attachmentIdentifierToElementMap.get(identifier);
8619 }
8620 
8621 #endif // ENABLE(ATTACHMENT_ELEMENT)
8622 
8623 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
8624 {
8625     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
8626     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);

8627 
8628     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8629         return MessageSource::Media;
8630 
8631     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8632         return MessageSource::WebRTC;
8633 



8634     return MessageSource::Other;
8635 }
8636 
8637 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8638 {
8639     switch (level) {
<span class="line-modified">8640     case WTFLogLevelAlways:</span>
8641         return MessageLevel::Log;
<span class="line-modified">8642     case WTFLogLevelError:</span>
8643         return MessageLevel::Error;
8644         break;
<span class="line-modified">8645     case WTFLogLevelWarning:</span>
8646         return MessageLevel::Warning;
8647         break;
<span class="line-modified">8648     case WTFLogLevelInfo:</span>
8649         return MessageLevel::Info;
8650         break;
<span class="line-modified">8651     case WTFLogLevelDebug:</span>
8652         return MessageLevel::Debug;
8653         break;
8654     }
8655 
8656     ASSERT_NOT_REACHED();
8657     return MessageLevel::Log;
8658 }
8659 








8660 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8661 {






8662     if (!page())
8663         return;
8664 
8665     ASSERT(sessionID().isAlwaysOnLoggingAllowed());
8666 
8667     auto messageSource = messageSourceForWTFLogChannel(channel);
8668     if (messageSource == MessageSource::Other)
8669         return;
8670 
8671     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8672         if (!page())
8673             return;
8674 
8675         auto messageLevel = messageLevelFromWTFLogLevel(level);
<span class="line-modified">8676         auto message = std::make_unique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));</span>
8677 
8678         addConsoleMessage(WTFMove(message));
8679     });
8680 }
8681 
8682 #if ENABLE(SERVICE_WORKER)
8683 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8684 {
8685     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8686         return;
8687 
8688     if (m_serviceWorkerConnection)
8689         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8690 
8691     m_serviceWorkerConnection = serviceWorkerConnection;
8692 
8693     if (!m_serviceWorkerConnection)
8694         return;
8695 
8696     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8697     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8698 }
8699 #endif
8700 
8701 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8702 {
8703     Page* page = this-&gt;page();
8704     if (!page)
8705         return emptyString();
8706     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8707 }
8708 
8709 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8710 {
<span class="line-modified">8711     return m_CSSRegisteredPropertySet.add(prop.name, std::make_unique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;</span>
8712 }
8713 
8714 void Document::detachFromFrame()
8715 {




8716     observeFrame(nullptr);
8717 }
8718 
8719 void Document::frameWasDisconnectedFromOwner()
8720 {
8721     if (!frame())
8722         return;
8723 
8724     if (auto* window = domWindow())
8725         window-&gt;willDetachDocumentFromFrame();
8726 
8727     detachFromFrame();
8728 }
8729 
8730 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8731 {
8732     return hitTest(request, result.hitTestLocation(), result);
8733 }
8734 
8735 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
</pre>
<hr />
<pre>
8749     FrameFlatteningLayoutDisallower disallower(frameView);
8750 
8751     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8752 
8753     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8754     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8755     // will always work so we need to check the ScrollView scrollbars in that case too.
8756     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8757         // FIXME: Consider if this test should be done unconditionally.
8758         if (request.allowsFrameScrollbars()) {
8759             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8760             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8761                 result.setScrollbar(frameScrollbar);
8762                 return true;
8763             }
8764         }
8765     }
8766     return resultLayer;
8767 }
8768 






































8769 #if ENABLE(CSS_PAINTING_API)
8770 Worklet&amp; Document::ensurePaintWorklet()
8771 {
8772     if (!m_paintWorklet)
8773         m_paintWorklet = Worklet::create();
8774     return *m_paintWorklet;
8775 }
8776 
8777 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8778 {
8779     return m_paintWorkletGlobalScopes.get(name);
8780 }
8781 
8782 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8783 {
8784     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8785     ASSERT_UNUSED(addResult, addResult);
8786 }
8787 #endif
8788 
<span class="line-modified">8789 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-modified">8790 void Document::updateTouchActionElements(Element&amp; element, const RenderStyle&amp; style)</span>

8791 {
<span class="line-modified">8792     bool changed = false;</span>



8793 
<span class="line-modified">8794     if (style.touchActions() != TouchAction::Auto) {</span>
<span class="line-modified">8795         if (!m_touchActionElements)</span>
<span class="line-modified">8796             m_touchActionElements = std::make_unique&lt;HashSet&lt;RefPtr&lt;Element&gt;&gt;&gt;();</span>
<span class="line-modified">8797         changed |= m_touchActionElements-&gt;add(&amp;element).isNewEntry;</span>
<span class="line-modified">8798     } else if (m_touchActionElements)</span>
<span class="line-modified">8799         changed |= m_touchActionElements-&gt;remove(&amp;element);</span>

8800 
<span class="line-modified">8801 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">8802     if (!changed)</span>
<span class="line-removed">8803         return;</span>
8804 
<span class="line-modified">8805     Page* page = this-&gt;page();</span>
<span class="line-modified">8806     if (!page)</span>
<span class="line-modified">8807         return;</span>


8808 
<span class="line-modified">8809     if (FrameView* frameView = view()) {</span>
<span class="line-modified">8810         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())</span>
<span class="line-modified">8811             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);</span>
<span class="line-modified">8812     }</span>
<span class="line-modified">8813 #endif</span>

















8814 }


















8815 #endif
8816 
8817 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
<span class="line-modified">   6  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   8  * Copyright (C) 2008, 2009, 2011, 2012 Google Inc. All rights reserved.
   9  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10  * Copyright (C) Research In Motion Limited 2010-2011. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
</pre>
<hr />
<pre>
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSStyleDeclaration.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CachedCSSStyleSheet.h&quot;
  41 #include &quot;CachedFrame.h&quot;
  42 #include &quot;CachedResourceLoader.h&quot;
  43 #include &quot;CanvasRenderingContext2D.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;Comment.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ComposedTreeIterator.h&quot;
  49 #include &quot;CompositionEvent.h&quot;
  50 #include &quot;ConstantPropertyMap.h&quot;
  51 #include &quot;ContentSecurityPolicy.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;CustomElementReactionQueue.h&quot;
  54 #include &quot;CustomElementRegistry.h&quot;
  55 #include &quot;CustomEvent.h&quot;
<span class="line-added">  56 #include &quot;CustomHeaderFields.h&quot;</span>
  57 #include &quot;DOMImplementation.h&quot;
  58 #include &quot;DOMWindow.h&quot;
  59 #include &quot;DateComponents.h&quot;
  60 #include &quot;DebugPageOverlays.h&quot;

  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
  66 #include &quot;Editing.h&quot;
  67 #include &quot;Editor.h&quot;
  68 #include &quot;ElementIterator.h&quot;
  69 #include &quot;EventHandler.h&quot;
  70 #include &quot;ExtensionStyleSheets.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;FocusEvent.h&quot;
  73 #include &quot;FontFaceSet.h&quot;
  74 #include &quot;FormController.h&quot;
  75 #include &quot;Frame.h&quot;
  76 #include &quot;FrameLoader.h&quot;
  77 #include &quot;FrameLoaderClient.h&quot;
  78 #include &quot;FrameView.h&quot;
<span class="line-added">  79 #include &quot;FullscreenManager.h&quot;</span>
  80 #include &quot;GenericCachedHTMLCollection.h&quot;
  81 #include &quot;HTMLAllCollection.h&quot;
  82 #include &quot;HTMLAnchorElement.h&quot;
  83 #include &quot;HTMLAttachmentElement.h&quot;
  84 #include &quot;HTMLBaseElement.h&quot;
  85 #include &quot;HTMLBodyElement.h&quot;
  86 #include &quot;HTMLCanvasElement.h&quot;
  87 #include &quot;HTMLDocument.h&quot;
  88 #include &quot;HTMLElementFactory.h&quot;
  89 #include &quot;HTMLFormControlElement.h&quot;
  90 #include &quot;HTMLFrameOwnerElement.h&quot;
  91 #include &quot;HTMLFrameSetElement.h&quot;
  92 #include &quot;HTMLHeadElement.h&quot;
  93 #include &quot;HTMLHtmlElement.h&quot;
  94 #include &quot;HTMLImageElement.h&quot;
  95 #include &quot;HTMLInputElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #include &quot;HTMLMediaElement.h&quot;
  98 #include &quot;HTMLNameCollection.h&quot;
  99 #include &quot;HTMLParserIdioms.h&quot;
 100 #include &quot;HTMLPictureElement.h&quot;
 101 #include &quot;HTMLPlugInElement.h&quot;
 102 #include &quot;HTMLScriptElement.h&quot;
 103 #include &quot;HTMLStyleElement.h&quot;
 104 #include &quot;HTMLTitleElement.h&quot;
 105 #include &quot;HTMLUnknownElement.h&quot;
 106 #include &quot;HTTPHeaderNames.h&quot;
 107 #include &quot;HTTPParsers.h&quot;
 108 #include &quot;HashChangeEvent.h&quot;
 109 #include &quot;History.h&quot;
 110 #include &quot;HitTestResult.h&quot;
 111 #include &quot;ImageBitmapRenderingContext.h&quot;
 112 #include &quot;ImageLoader.h&quot;
 113 #include &quot;InspectorInstrumentation.h&quot;
 114 #include &quot;IntersectionObserver.h&quot;
 115 #include &quot;JSCustomElementInterface.h&quot;

 116 #include &quot;JSLazyEventListener.h&quot;
 117 #include &quot;KeyboardEvent.h&quot;
 118 #include &quot;KeyframeEffect.h&quot;
 119 #include &quot;LayoutDisallowedScope.h&quot;
 120 #include &quot;LibWebRTCProvider.h&quot;
 121 #include &quot;LoaderStrategy.h&quot;
 122 #include &quot;Logging.h&quot;
 123 #include &quot;MediaCanStartListener.h&quot;
 124 #include &quot;MediaProducer.h&quot;
 125 #include &quot;MediaQueryList.h&quot;
 126 #include &quot;MediaQueryMatcher.h&quot;
<span class="line-added"> 127 #include &quot;MediaStream.h&quot;</span>
 128 #include &quot;MessageEvent.h&quot;
 129 #include &quot;Microtasks.h&quot;
 130 #include &quot;MouseEventWithHitTestResults.h&quot;
 131 #include &quot;MutationEvent.h&quot;
 132 #include &quot;NameNodeList.h&quot;
 133 #include &quot;NavigationDisabler.h&quot;
 134 #include &quot;NavigationScheduler.h&quot;
 135 #include &quot;NestingLevelIncrementer.h&quot;
 136 #include &quot;NodeIterator.h&quot;
 137 #include &quot;NodeRareData.h&quot;
 138 #include &quot;NodeWithIndex.h&quot;

 139 #include &quot;OverflowEvent.h&quot;
 140 #include &quot;PageConsoleClient.h&quot;
 141 #include &quot;PageGroup.h&quot;
 142 #include &quot;PageTransitionEvent.h&quot;
 143 #include &quot;PaintWorkletGlobalScope.h&quot;
 144 #include &quot;PlatformLocale.h&quot;
 145 #include &quot;PlatformMediaSessionManager.h&quot;
 146 #include &quot;PlatformScreen.h&quot;
 147 #include &quot;PlatformStrategies.h&quot;
 148 #include &quot;PlugInsResources.h&quot;
 149 #include &quot;PluginDocument.h&quot;
 150 #include &quot;PointerLockController.h&quot;
 151 #include &quot;PolicyChecker.h&quot;
 152 #include &quot;PopStateEvent.h&quot;
 153 #include &quot;ProcessingInstruction.h&quot;
 154 #include &quot;PublicSuffix.h&quot;
 155 #include &quot;Quirks.h&quot;
 156 #include &quot;RealtimeMediaSourceCenter.h&quot;
 157 #include &quot;RenderChildIterator.h&quot;
 158 #include &quot;RenderInline.h&quot;
 159 #include &quot;RenderLayerCompositor.h&quot;
 160 #include &quot;RenderLineBreak.h&quot;
 161 #include &quot;RenderTreeUpdater.h&quot;
 162 #include &quot;RenderView.h&quot;
 163 #include &quot;RenderWidget.h&quot;
 164 #include &quot;RequestAnimationFrameCallback.h&quot;
<span class="line-added"> 165 #include &quot;ResizeObserver.h&quot;</span>
 166 #include &quot;ResourceLoadObserver.h&quot;
 167 #include &quot;RuntimeApplicationChecks.h&quot;
 168 #include &quot;RuntimeEnabledFeatures.h&quot;
 169 #include &quot;SVGDocumentExtensions.h&quot;
 170 #include &quot;SVGElement.h&quot;
 171 #include &quot;SVGElementFactory.h&quot;
 172 #include &quot;SVGNames.h&quot;
 173 #include &quot;SVGSVGElement.h&quot;
 174 #include &quot;SVGTitleElement.h&quot;
 175 #include &quot;SVGUseElement.h&quot;
 176 #include &quot;SVGZoomEvent.h&quot;
 177 #include &quot;SWClientConnection.h&quot;
 178 #include &quot;SchemeRegistry.h&quot;
 179 #include &quot;ScopedEventQueue.h&quot;
 180 #include &quot;ScriptController.h&quot;
 181 #include &quot;ScriptDisallowedScope.h&quot;
 182 #include &quot;ScriptModuleLoader.h&quot;
 183 #include &quot;ScriptRunner.h&quot;
 184 #include &quot;ScriptSourceCode.h&quot;
 185 #include &quot;ScriptState.h&quot;
</pre>
<hr />
<pre>
 234 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 235 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 236 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 237 #include &lt;JavaScriptCore/VM.h&gt;
 238 #include &lt;ctime&gt;
 239 #include &lt;wtf/IsoMallocInlines.h&gt;
 240 #include &lt;wtf/Language.h&gt;
 241 #include &lt;wtf/NeverDestroyed.h&gt;
 242 #include &lt;wtf/SetForScope.h&gt;
 243 #include &lt;wtf/SystemTracing.h&gt;
 244 #include &lt;wtf/UUID.h&gt;
 245 #include &lt;wtf/text/StringBuffer.h&gt;
 246 #include &lt;wtf/text/TextStream.h&gt;
 247 
 248 #if PLATFORM(JAVA)
 249 #include &lt;wtf/unicode/java/UnicodeJava.h&gt;
 250 #endif
 251 
 252 #if ENABLE(DEVICE_ORIENTATION)
 253 #include &quot;DeviceMotionEvent.h&quot;
<span class="line-added"> 254 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;</span>
 255 #include &quot;DeviceOrientationEvent.h&quot;
 256 #endif
 257 
 258 #if ENABLE(FULLSCREEN_API)
 259 #include &quot;RenderFullScreen.h&quot;
 260 #endif
 261 
 262 #if ENABLE(INDEXED_DATABASE)
 263 #include &quot;IDBConnectionProxy.h&quot;
 264 #include &quot;IDBOpenDBRequest.h&quot;
 265 #endif
 266 
 267 #if PLATFORM(IOS_FAMILY)
<span class="line-added"> 268 #include &quot;ContentChangeObserver.h&quot;</span>
 269 #include &quot;CSSFontSelector.h&quot;
<span class="line-added"> 270 #include &quot;DOMTimerHoldingTank.h&quot;</span>
 271 #include &quot;DeviceMotionClientIOS.h&quot;
 272 #include &quot;DeviceMotionController.h&quot;
 273 #include &quot;DeviceOrientationClientIOS.h&quot;
 274 #include &quot;DeviceOrientationController.h&quot;
 275 #include &quot;Geolocation.h&quot;
 276 #include &quot;Navigator.h&quot;
 277 #include &quot;NavigatorGeolocation.h&quot;


 278 #endif
 279 
 280 #if ENABLE(IOS_GESTURE_EVENTS)
 281 #include &quot;GestureEvent.h&quot;
 282 #endif
 283 
 284 #if ENABLE(MATHML)
 285 #include &quot;MathMLElement.h&quot;
 286 #include &quot;MathMLElementFactory.h&quot;
 287 #include &quot;MathMLNames.h&quot;
 288 #endif
 289 
 290 #if ENABLE(MEDIA_SESSION)
 291 #include &quot;MediaSession.h&quot;
 292 #endif
 293 
 294 #if USE(QUICK_LOOK)
 295 #include &quot;QuickLook.h&quot;
 296 #endif
 297 
 298 #if ENABLE(TOUCH_EVENTS)
 299 #include &quot;TouchEvent.h&quot;
 300 #endif
 301 
 302 #if ENABLE(VIDEO_TRACK)
 303 #include &quot;CaptionUserPreferences.h&quot;
 304 #endif
 305 
 306 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 307 #include &quot;MediaPlaybackTargetClient.h&quot;
 308 #endif
 309 
 310 #if ENABLE(XSLT)
 311 #include &quot;XSLTProcessor.h&quot;
 312 #endif
 313 





 314 #if ENABLE(WEBGL)
 315 #include &quot;WebGLRenderingContext.h&quot;
 316 #endif
 317 #if ENABLE(WEBGL2)
 318 #include &quot;WebGL2RenderingContext.h&quot;
 319 #endif
 320 #if ENABLE(WEBGPU)
<span class="line-modified"> 321 #include &quot;GPUCanvasContext.h&quot;</span>
 322 #endif
<span class="line-modified"> 323 </span>
<span class="line-modified"> 324 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added"> 325 #include &quot;PointerCaptureController.h&quot;</span>
 326 #endif
 327 
 328 namespace WebCore {
 329 
 330 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 331 
 332 using namespace HTMLNames;
 333 using namespace PAL;
 334 using namespace WTF::Unicode;
 335 
 336 static const unsigned cMaxWriteRecursionDepth = 21;
 337 bool Document::hasEverCreatedAnAXObjectCache = false;
<span class="line-modified"> 338 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };</span>

 339 
 340 struct FrameFlatteningLayoutDisallower {
 341     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 342         : m_frameView(frameView)
 343         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 344     {
 345         if (m_disallowLayout)
 346             m_frameView.startDisallowingLayout();
 347     }
 348 
 349     ~FrameFlatteningLayoutDisallower()
 350     {
 351         if (m_disallowLayout)
 352             m_frameView.endDisallowingLayout();
 353     }
 354 
 355 private:
 356     FrameView&amp; m_frameView;
 357     bool m_disallowLayout { false };
 358 };
 359 
<span class="line-added"> 360 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-added"> 361 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };</span>
<span class="line-added"> 362 #endif</span>
<span class="line-added"> 363 </span>
 364 // DOM Level 2 says (letters added):
 365 //
 366 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 367 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 368 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 369 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 370 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 371 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 372 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 373 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 374 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 375 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 376 //
 377 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 378 
 379 static inline bool isValidNameStart(UChar32 c)
 380 {
 381     // rule (e) above
 382     if ((c &gt;= 0x02BB &amp;&amp; c &lt;= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)
 383         return true;
</pre>
<hr />
<pre>
 509     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 510     return documents;
 511 }
 512 
 513 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 514 {
 515     return allDocumentsMap().values();
 516 }
 517 
 518 static inline int currentOrientation(Frame* frame)
 519 {
 520 #if ENABLE(ORIENTATION_EVENTS)
 521     if (frame)
 522         return frame-&gt;orientation();
 523 #else
 524     UNUSED_PARAM(frame);
 525 #endif
 526     return 0;
 527 }
 528 
<span class="line-modified"> 529 Document::Document(PAL::SessionID sessionID, Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
 530     : ContainerNode(*this, CreateDocument)
 531     , TreeScope(*this)
 532     , FrameDestructionObserver(frame)
 533 #if ENABLE(IOS_TOUCH_EVENTS)
 534     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 535 #endif
 536     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 537     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 538     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 539     , m_domTreeVersion(++s_globalTreeVersion)
<span class="line-modified"> 540     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))</span>
<span class="line-modified"> 541     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))</span>
<span class="line-modified"> 542     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))</span>
<span class="line-modified"> 543     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))</span>
 544     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 545     , m_documentCreationTime(MonotonicTime::now())
<span class="line-modified"> 546     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))</span>
<span class="line-modified"> 547     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))</span>
 548 #if ENABLE(XSLT)
 549     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 550 #endif
 551     , m_xmlVersion(&quot;1.0&quot;_s)
<span class="line-modified"> 552     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))</span>
 553     , m_documentClasses(documentClasses)
 554     , m_eventQueue(*this)
<span class="line-added"> 555 #if ENABLE(FULLSCREEN_API)</span>
<span class="line-added"> 556     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }</span>
<span class="line-added"> 557 #endif</span>
 558 #if ENABLE(INTERSECTION_OBSERVER)
 559     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
<span class="line-added"> 560     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)</span>
 561 #endif
 562     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 563 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified"> 564     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;())</span>
<span class="line-modified"> 565     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))</span>
<span class="line-modified"> 566     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;())</span>
<span class="line-modified"> 567     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))</span>
 568 #endif
 569     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 570     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 571     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 572     , m_fontSelector(CSSFontSelector::create(*this))
 573     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 574     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 575     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 576     , m_isSynthesized(constructionFlags &amp; Synthesized)
 577     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 578     , m_orientationNotifier(currentOrientation(frame))
<span class="line-added"> 579     , m_sessionID(sessionID)</span>
 580     , m_identifier(DocumentIdentifier::generate())
 581     , m_undoManager(UndoManager::create(*this))
 582 {
<span class="line-added"> 583     ASSERT(!frame || frame-&gt;sessionID() == m_sessionID);</span>
<span class="line-added"> 584 </span>
 585     auto addResult = allDocumentsMap().add(m_identifier, this);
 586     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 587 
 588     // We depend on the url getting immediately set in subframes, but we
 589     // also depend on the url NOT getting immediately set in opened windows.
 590     // See fast/dom/early-frame-url.html
 591     // and fast/dom/location-new-window-no-crash.html, respectively.
 592     // FIXME: Can/should we unify this behavior?
 593     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 594         setURL(url);
 595 
 596     m_cachedResourceLoader-&gt;setDocument(this);
 597 
 598     resetLinkColor();
 599     resetVisitedLinkColor();
 600     resetActiveLinkColor();
 601 
 602     initSecurityContext();
 603     initDNSPrefetch();
 604 
 605     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 606 
 607     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 608         nodeListAndCollectionCount = 0;
 609 
 610     InspectorInstrumentation::addEventListenersToNode(*this);
 611 }
 612 















 613 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 614 {
<span class="line-modified"> 615     auto document = adoptRef(*new Document(contextDocument.sessionID(), nullptr, URL()));</span>
 616     document-&gt;setContextDocument(contextDocument);
 617     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 618     return document;
 619 }
 620 
<span class="line-added"> 621 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)</span>
<span class="line-added"> 622 {</span>
<span class="line-added"> 623     return adoptRef(*new Document(frame.sessionID(), &amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
<span class="line-added"> 624 }</span>
<span class="line-added"> 625 </span>
 626 Document::~Document()
 627 {
 628     if (m_logger)
 629         m_logger-&gt;removeObserver(*this);
 630 
 631     ASSERT(allDocumentsMap().contains(m_identifier));
 632     allDocumentsMap().remove(m_identifier);
 633     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 634     removeFromContextsMap();
 635 
 636     ASSERT(!renderView());
 637     ASSERT(m_pageCacheState != InPageCache);
 638     ASSERT(m_ranges.isEmpty());
 639     ASSERT(!m_parentTreeScope);
 640     ASSERT(!m_disabledFieldsetElementsCount);
 641     ASSERT(m_inDocumentShadowRoots.isEmpty());
 642 
 643 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 644     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 645     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
</pre>
<hr />
<pre>
 689     stopAllMediaPlayback();
 690 #endif
 691 
 692     // We must call clearRareData() here since a Document class inherits TreeScope
 693     // as well as Node. See a comment on TreeScope.h for the reason.
 694     if (hasRareData())
 695         clearRareData();
 696 
 697     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_listsInvalidatedAtDocument.isEmpty());
 698     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_collectionsInvalidatedAtDocument.isEmpty());
 699     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(m_svgUseElements.isEmpty());
 700 
 701     for (unsigned count : m_nodeListAndCollectionCounts)
 702         ASSERT_UNUSED(count, !count);
 703 }
 704 
 705 void Document::removedLastRef()
 706 {
 707     ASSERT(!m_deletionHasBegun);
 708     if (m_referencingNodeCount) {
<span class="line-added"> 709         // Node::removedLastRef doesn&#39;t set refCount() to zero because it&#39;s not observable.</span>
<span class="line-added"> 710         // But we need to remember that our refCount reached zero in subsequent calls to decrementReferencingNodeCount().</span>
<span class="line-added"> 711         m_refCountAndParentBit = 0;</span>
<span class="line-added"> 712 </span>
 713         // If removing a child removes the last node reference, we don&#39;t want the scope to be destroyed
 714         // until after removeDetachedChildren returns, so we protect ourselves.
 715         incrementReferencingNodeCount();
 716 
 717         RELEASE_ASSERT(!hasLivingRenderTree());
 718         // We must make sure not to be retaining any of our children through
 719         // these extra pointers or we will create a reference cycle.
 720         m_focusedElement = nullptr;
 721         m_hoveredElement = nullptr;
 722         m_activeElement = nullptr;
 723         m_titleElement = nullptr;
 724         m_documentElement = nullptr;
 725         m_focusNavigationStartingNode = nullptr;
 726         m_userActionElements.clear();
 727 #if ENABLE(FULLSCREEN_API)
<span class="line-modified"> 728         m_fullscreenManager-&gt;clear();</span>

 729 #endif
 730         m_associatedFormControls.clear();
 731 
 732         m_fontSelector-&gt;clearDocument();
 733         m_fontSelector-&gt;unregisterForInvalidationCallbacks(*this);
 734 
 735         detachParser();
 736 
 737         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 738         // so tear down scope information up front to avoid having
 739         // stale references in the map.
 740 
 741         destroyTreeScopeData();
 742         removeDetachedChildren();
 743         m_formController = nullptr;
 744 
 745         m_markers-&gt;detach();
 746 
 747         m_cssCanvasElements.clear();
 748 
 749         commonTeardown();
 750 
 751 #ifndef NDEBUG
 752         // We need to do this right now since selfOnlyDeref() can delete this.
 753         m_inRemovedLastRefFunction = false;
 754 #endif
 755         decrementReferencingNodeCount();
 756     } else {
 757 #ifndef NDEBUG
 758         m_inRemovedLastRefFunction = false;
 759         m_deletionHasBegun = true;
 760 #endif

 761         delete this;
 762     }
 763 }
 764 
 765 void Document::commonTeardown()
 766 {
 767     if (svgExtensions())
 768         accessSVGExtensions().pauseAnimations();
 769 
 770     clearScriptedAnimationController();
 771 }
 772 
 773 Element* Document::elementForAccessKey(const String&amp; key)
 774 {
 775     if (key.isEmpty())
 776         return nullptr;
 777     if (!m_accessKeyCache)
 778         buildAccessKeyCache();
 779     return m_accessKeyCache-&gt;get(key);
 780 }
 781 
 782 void Document::buildAccessKeyCache()
 783 {
<span class="line-modified"> 784     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {</span>
 785         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 786         for (auto&amp; node : composedTreeDescendants(*this)) {
 787             if (!is&lt;Element&gt;(node))
 788                 continue;
 789             auto&amp; element = downcast&lt;Element&gt;(node);
 790             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
 791             if (key.isEmpty())
 792                 continue;
 793             map.add(key, &amp;element);
<span class="line-modified"> 794         }</span>
 795         return map;
 796     }());
 797 }
 798 
 799 void Document::invalidateAccessKeyCacheSlowCase()
 800 {
 801     m_accessKeyCache = nullptr;
 802 }
 803 
 804 ExceptionOr&lt;SelectorQuery&amp;&gt; Document::selectorQueryForString(const String&amp; selectorString)
 805 {
 806     if (selectorString.isEmpty())
 807         return Exception { SyntaxError };
 808     if (!m_selectorQueryCache)
<span class="line-modified"> 809         m_selectorQueryCache = makeUnique&lt;SelectorQueryCache&gt;();</span>
 810     return m_selectorQueryCache-&gt;add(selectorString, *this);
 811 }
 812 
 813 void Document::clearSelectorQueryCache()
 814 {
 815     m_selectorQueryCache = nullptr;
 816 }
 817 
 818 void Document::setReferrerPolicy(ReferrerPolicy referrerPolicy)
 819 {
 820     // Do not override existing referrer policy with the &quot;empty string&quot; one as the &quot;empty string&quot; means we should use
 821     // the policy defined elsewhere.
 822     if (m_referrerPolicy &amp;&amp; referrerPolicy == ReferrerPolicy::EmptyString)
 823         return;
 824 
 825     m_referrerPolicy = referrerPolicy;
 826 }
 827 
 828 MediaQueryMatcher&amp; Document::mediaQueryMatcher()
 829 {
</pre>
<hr />
<pre>
 854 }
 855 
 856 void Document::resetLinkColor()
 857 {
 858     m_linkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr));
 859 }
 860 
 861 void Document::resetVisitedLinkColor()
 862 {
 863     m_visitedLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitLink, styleColorOptions(nullptr) | StyleColor::Options::ForVisitedLink);
 864 }
 865 
 866 void Document::resetActiveLinkColor()
 867 {
 868     m_activeLinkColor = StyleColor::colorFromKeyword(CSSValueWebkitActivelink, styleColorOptions(nullptr));
 869 }
 870 
 871 DOMImplementation&amp; Document::implementation()
 872 {
 873     if (!m_implementation)
<span class="line-modified"> 874         m_implementation = makeUnique&lt;DOMImplementation&gt;(*this);</span>
 875     return *m_implementation;
 876 }
 877 
 878 bool Document::hasManifest() const
 879 {
 880     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(htmlTag) &amp;&amp; documentElement()-&gt;hasAttributeWithoutSynchronization(manifestAttr);
 881 }
 882 
 883 DocumentType* Document::doctype() const
 884 {
 885     for (Node* node = firstChild(); node; node = node-&gt;nextSibling()) {
 886         if (is&lt;DocumentType&gt;(node))
 887             return downcast&lt;DocumentType&gt;(node);
 888     }
 889     return nullptr;
 890 }
 891 
 892 void Document::childrenChanged(const ChildChange&amp; change)
 893 {
 894     ContainerNode::childrenChanged(change);
</pre>
<hr />
<pre>
 901 
 902     Element* newDocumentElement = childrenOfType&lt;Element&gt;(*this).first();
 903     if (newDocumentElement == m_documentElement)
 904         return;
 905     m_documentElement = newDocumentElement;
 906     // The root style used for media query matching depends on the document element.
 907     styleScope().clearResolver();
 908 }
 909 
 910 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const QualifiedName&amp; name)
 911 {
 912     if (!RuntimeEnabledFeatures::sharedFeatures().customElementsEnabled()
 913         || Document::validateCustomElementName(name.localName()) != CustomElementNameValidationStatus::Valid)
 914         return HTMLUnknownElement::create(name, document);
 915 
 916     auto element = HTMLElement::create(name, document);
 917     element-&gt;setIsCustomElementUpgradeCandidate();
 918     return element;
 919 }
 920 
<span class="line-modified"> 921 static ALWAYS_INLINE Ref&lt;HTMLElement&gt; createUpgradeCandidateElement(Document&amp; document, const AtomString&amp; localName)</span>
 922 {
 923     return createUpgradeCandidateElement(document, QualifiedName { nullAtom(), localName, xhtmlNamespaceURI });
 924 }
 925 
<span class="line-modified"> 926 static inline bool isValidHTMLElementName(const AtomString&amp; localName)</span>
 927 {
 928     return Document::isValidName(localName);
 929 }
 930 
 931 static inline bool isValidHTMLElementName(const QualifiedName&amp; name)
 932 {
 933     return Document::isValidName(name.localName());
 934 }
 935 
 936 template&lt;typename NameType&gt;
 937 static ExceptionOr&lt;Ref&lt;Element&gt;&gt; createHTMLElementWithNameValidation(Document&amp; document, const NameType&amp; name)
 938 {
 939     auto element = HTMLElementFactory::createKnownElement(name, document);
 940     if (LIKELY(element))
 941         return Ref&lt;Element&gt; { element.releaseNonNull() };
 942 
 943     if (auto* window = document.domWindow()) {
 944         auto* registry = window-&gt;customElementRegistry();
 945         if (UNLIKELY(registry)) {
 946             if (auto* elementInterface = registry-&gt;findInterface(name))
 947                 return elementInterface-&gt;constructElementWithFallback(document, name);
 948         }
 949     }
 950 
 951     if (UNLIKELY(!isValidHTMLElementName(name)))
 952         return Exception { InvalidCharacterError };
 953 
 954     return Ref&lt;Element&gt; { createUpgradeCandidateElement(document, name) };
 955 }
 956 
<span class="line-modified"> 957 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementForBindings(const AtomString&amp; name)</span>
 958 {
 959     if (isHTMLDocument())
 960         return createHTMLElementWithNameValidation(*this, name.convertToASCIILowercase());
 961 
 962     if (isXHTMLDocument())
 963         return createHTMLElementWithNameValidation(*this, name);
 964 
 965     if (!isValidName(name))
 966         return Exception { InvalidCharacterError };
 967 
 968     return createElement(QualifiedName(nullAtom(), name, nullAtom()), false);
 969 }
 970 
 971 Ref&lt;DocumentFragment&gt; Document::createDocumentFragment()
 972 {
 973     return DocumentFragment::create(document());
 974 }
 975 
 976 Ref&lt;Text&gt; Document::createTextNode(const String&amp; data)
 977 {
</pre>
<hr />
<pre>
1009 Ref&lt;CSSStyleDeclaration&gt; Document::createCSSStyleDeclaration()
1010 {
1011     Ref&lt;MutableStyleProperties&gt; propertySet(MutableStyleProperties::create());
1012     return propertySet-&gt;ensureCSSStyleDeclaration();
1013 }
1014 
1015 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::importNode(Node&amp; nodeToImport, bool deep)
1016 {
1017     switch (nodeToImport.nodeType()) {
1018     case DOCUMENT_FRAGMENT_NODE:
1019         if (nodeToImport.isShadowRoot())
1020             break;
1021         FALLTHROUGH;
1022     case ELEMENT_NODE:
1023     case TEXT_NODE:
1024     case CDATA_SECTION_NODE:
1025     case PROCESSING_INSTRUCTION_NODE:
1026     case COMMENT_NODE:
1027         return nodeToImport.cloneNodeInternal(document(), deep ? CloningOperation::Everything : CloningOperation::OnlySelf);
1028 
<span class="line-modified">1029     case ATTRIBUTE_NODE: {</span>
<span class="line-modified">1030         auto&amp; attribute = downcast&lt;Attr&gt;(nodeToImport);</span>
<span class="line-modified">1031         return Ref&lt;Node&gt; { Attr::create(*this, attribute.qualifiedName(), attribute.value()) };</span>
<span class="line-modified">1032     }</span>
1033     case DOCUMENT_NODE: // Can&#39;t import a document into another document.
1034     case DOCUMENT_TYPE_NODE: // FIXME: Support cloning a DocumentType node per DOM4.
1035         break;
1036     }
1037 
1038     return Exception { NotSupportedError };
1039 }
1040 
1041 
1042 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Document::adoptNode(Node&amp; source)
1043 {
1044     EventQueueScope scope;
1045 
1046     switch (source.nodeType()) {
1047     case DOCUMENT_NODE:
1048         return Exception { NotSupportedError };
1049     case ATTRIBUTE_NODE: {
1050         auto&amp; attr = downcast&lt;Attr&gt;(source);
1051         if (auto* element = attr.ownerElement()) {
1052             auto result = element-&gt;removeAttributeNode(attr);
</pre>
<hr />
<pre>
1182         { &#39;a&#39;, &#39;z&#39; },
1183         { 0xB7, 0xB7 },
1184         { 0xC0, 0xD6 },
1185         { 0xD8, 0xF6 },
1186         { 0xF8, 0x37D },
1187         { 0x37F, 0x1FFF },
1188         { 0x200C, 0x200D },
1189         { 0x203F, 0x2040 },
1190         { 0x2070, 0x218F },
1191         { 0x2C00, 0x2FEF },
1192         { 0x3001, 0xD7FF },
1193         { 0xF900, 0xFDCF },
1194         { 0xFDF0, 0xFFFD },
1195         { 0x10000, 0xEFFFF },
1196     };
1197 
1198     ASSERT(std::is_sorted(std::begin(ranges), std::end(ranges)));
1199     return std::binary_search(std::begin(ranges), std::end(ranges), character);
1200 }
1201 
<span class="line-modified">1202 CustomElementNameValidationStatus Document::validateCustomElementName(const AtomString&amp; localName)</span>
1203 {
1204     if (!isASCIILower(localName[0]))
1205         return CustomElementNameValidationStatus::FirstCharacterIsNotLowercaseASCIILetter;
1206 
1207     bool containsHyphen = false;
1208     for (auto character : StringView(localName).codePoints()) {
1209         if (isASCIIUpper(character))
1210             return CustomElementNameValidationStatus::ContainsUppercaseASCIILetter;
1211         if (!isPotentialCustomElementNameCharacter(character))
1212             return CustomElementNameValidationStatus::ContainsDisallowedCharacter;
1213         if (character == &#39;-&#39;)
1214             containsHyphen = true;
1215     }
1216 
1217     if (!containsHyphen)
1218         return CustomElementNameValidationStatus::ContainsNoHyphen;
1219 
1220 #if ENABLE(MATHML)
1221     const auto&amp; annotationXmlLocalName = MathMLNames::annotation_xmlTag-&gt;localName();
1222 #else
<span class="line-modified">1223     static NeverDestroyed&lt;const AtomString&gt; annotationXmlLocalName(&quot;annotation-xml&quot;, AtomString::ConstructFromLiteral);</span>
1224 #endif
1225 
1226     if (localName == SVGNames::color_profileTag-&gt;localName()
1227         || localName == SVGNames::font_faceTag-&gt;localName()
1228         || localName == SVGNames::font_face_formatTag-&gt;localName()
1229         || localName == SVGNames::font_face_nameTag-&gt;localName()
1230         || localName == SVGNames::font_face_srcTag-&gt;localName()
1231         || localName == SVGNames::font_face_uriTag-&gt;localName()
1232         || localName == SVGNames::missing_glyphTag-&gt;localName()
1233         || localName == annotationXmlLocalName)
1234         return CustomElementNameValidationStatus::ConflictsWithStandardElementName;
1235 
1236     return CustomElementNameValidationStatus::Valid;
1237 }
1238 
<span class="line-modified">1239 ExceptionOr&lt;Ref&lt;Element&gt;&gt; Document::createElementNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)</span>
1240 {
1241     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
1242     if (parseResult.hasException())
1243         return parseResult.releaseException();
1244     QualifiedName parsedName { parseResult.releaseReturnValue() };
1245     if (!hasValidNamespaceForElements(parsedName))
1246         return Exception { NamespaceError };
1247 
1248     if (parsedName.namespaceURI() == xhtmlNamespaceURI)
1249         return createHTMLElementWithNameValidation(*this, parsedName);
1250 
1251     return createElement(parsedName, false);
1252 }
1253 
1254 void Document::setReadyState(ReadyState readyState)
1255 {
1256     if (readyState == m_readyState)
1257         return;
1258 
1259     switch (readyState) {
</pre>
<hr />
<pre>
1348 
1349     // If the client is extending the visual update suppression period explicitly, the
1350     // watchdog should not re-enable visual updates itself, but should wait for the client.
1351     if (view() &amp;&amp; !view()-&gt;visualUpdatesAllowedByClient())
1352         return;
1353 
1354     setVisualUpdatesAllowed(true);
1355 }
1356 
1357 void Document::setVisualUpdatesAllowedByClient(bool visualUpdatesAllowedByClient)
1358 {
1359     // We should only re-enable visual updates if ReadyState is Completed or the watchdog timer has fired,
1360     // both of which we can determine by looking at the timer.
1361 
1362     if (visualUpdatesAllowedByClient &amp;&amp; !m_visualUpdatesSuppressionTimer.isActive() &amp;&amp; !visualUpdatesAllowed())
1363         setVisualUpdatesAllowed(true);
1364 }
1365 
1366 String Document::characterSetWithUTF8Fallback() const
1367 {
<span class="line-modified">1368     AtomString name = encoding();</span>
1369     if (!name.isNull())
1370         return name;
1371     return UTF8Encoding().domName();
1372 }
1373 
1374 String Document::defaultCharsetForLegacyBindings() const
1375 {
1376     if (!frame())
1377         UTF8Encoding().domName();
1378     return settings().defaultTextEncodingName();
1379 }
1380 
1381 void Document::setCharset(const String&amp; charset)
1382 {
1383     if (!decoder())
1384         return;
1385     decoder()-&gt;setEncoding(charset, TextResourceDecoder::UserChosenEncoding);
1386 }
1387 
1388 void Document::setContentLanguage(const String&amp; language)
</pre>
<hr />
<pre>
1525         // 1. If the Document is in quirks mode, follow these substeps:
1526         if (inQuirksMode()) {
1527             auto* firstBody = body();
1528             // 1. If the HTML body element exists, and it is not potentially scrollable, return the
1529             // HTML body element and abort these steps.
1530             if (firstBody &amp;&amp; !isBodyPotentiallyScrollable(*firstBody))
1531                 return firstBody;
1532 
1533             // 2. Return null and abort these steps.
1534             return nullptr;
1535         }
1536 
1537         // 2. If there is a root element, return the root element and abort these steps.
1538         // 3. Return null.
1539         return documentElement();
1540     }
1541 
1542     return body();
1543 }
1544 
<span class="line-modified">1545 static String canonicalizedTitle(Document&amp; document, const String&amp; title)</span>
1546 {
<span class="line-modified">1547     // Collapse runs of HTML spaces into single space characters.</span>
<span class="line-modified">1548     // Strip leading and trailing spaces.</span>
<span class="line-modified">1549     // Replace backslashes with currency symbols.</span>




1550 
<span class="line-modified">1551     StringBuilder builder;</span>

1552 
1553     auto* decoder = document.decoder();
1554     auto backslashAsCurrencySymbol = decoder ? decoder-&gt;encoding().backslashAsCurrencySymbol() : &#39;\\&#39;;
1555 



1556     bool previousCharacterWasHTMLSpace = false;
<span class="line-modified">1557     for (auto character : StringView { title }.codeUnits()) {</span>

1558         if (isHTMLSpace(character))
1559             previousCharacterWasHTMLSpace = true;
1560         else {
1561             if (character == &#39;\\&#39;)
1562                 character = backslashAsCurrencySymbol;
<span class="line-modified">1563             if (previousCharacterWasHTMLSpace &amp;&amp; !builder.isEmpty())</span>
<span class="line-modified">1564                 builder.append(&#39; &#39;);</span>
<span class="line-modified">1565             builder.append(character);</span>
1566             previousCharacterWasHTMLSpace = false;
1567         }
1568     }


1569 
<span class="line-modified">1570     return builder == title ? title : builder.toString();</span>

1571 }
1572 
1573 void Document::updateTitle(const StringWithDirection&amp; title)
1574 {
1575     if (m_rawTitle == title)
1576         return;
1577 
1578     m_rawTitle = title;

1579 
<span class="line-modified">1580     m_title.string = canonicalizedTitle(*this, title.string);</span>
<span class="line-modified">1581     m_title.direction = title.direction;</span>




1582 
1583     if (auto* loader = this-&gt;loader())
1584         loader-&gt;setTitle(m_title);
1585 }
1586 
1587 void Document::updateTitleFromTitleElement()
1588 {
1589     if (!m_titleElement) {
1590         updateTitle({ });
1591         return;
1592     }
1593 
1594     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1595         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1596     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1597         // FIXME: Does the SVG title element have a text direction?
1598         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1599     }
1600 }
1601 
</pre>
<hr />
<pre>
1728 
1729 void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1730 {
1731     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);
1732 }
1733 
1734 void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)
1735 {
1736     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);
1737 }
1738 
1739 void Document::allowsMediaDocumentInlinePlaybackChanged()
1740 {
1741     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)
1742         element-&gt;allowsMediaDocumentInlinePlaybackChanged();
1743 }
1744 
1745 void Document::stopAllMediaPlayback()
1746 {
1747     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
<span class="line-modified">1748         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);</span>
1749 }
1750 
1751 void Document::suspendAllMediaPlayback()
1752 {
1753     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1754         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1755 }
1756 
1757 void Document::resumeAllMediaPlayback()
1758 {
1759     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1760         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1761 }
<span class="line-added">1762 </span>
<span class="line-added">1763 void Document::suspendAllMediaBuffering()</span>
<span class="line-added">1764 {</span>
<span class="line-added">1765     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())</span>
<span class="line-added">1766         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);</span>
<span class="line-added">1767 }</span>
<span class="line-added">1768 </span>
<span class="line-added">1769 void Document::resumeAllMediaBuffering()</span>
<span class="line-added">1770 {</span>
<span class="line-added">1771     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())</span>
<span class="line-added">1772         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);</span>
<span class="line-added">1773 }</span>
1774 #endif
1775 
1776 String Document::nodeName() const
1777 {
1778     return &quot;#document&quot;_s;
1779 }
1780 
1781 Node::NodeType Document::nodeType() const
1782 {
1783     return DOCUMENT_NODE;
1784 }
1785 
1786 FormController&amp; Document::formController()
1787 {
1788     if (!m_formController)
<span class="line-modified">1789         m_formController = makeUnique&lt;FormController&gt;();</span>
1790     return *m_formController;
1791 }
1792 
1793 Vector&lt;String&gt; Document::formElementsState() const
1794 {
1795     if (!m_formController)
1796         return Vector&lt;String&gt;();
1797     return m_formController-&gt;formElementsState();
1798 }
1799 
1800 void Document::setStateForNewFormElements(const Vector&lt;String&gt;&amp; stateVector)
1801 {
1802     if (!stateVector.size() &amp;&amp; !m_formController)
1803         return;
1804     formController().setStateForNewFormElements(stateVector);
1805 }
1806 
1807 FrameView* Document::view() const
1808 {
1809     return m_frame ? m_frame-&gt;view() : nullptr;
</pre>
<hr />
<pre>
1826 
1827 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1828 {
1829     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1830 }
1831 
1832 void Document::scheduleFullStyleRebuild()
1833 {
1834     m_needsFullStyleRebuild = true;
1835     scheduleStyleRecalc();
1836 }
1837 
1838 void Document::scheduleStyleRecalc()
1839 {
1840     ASSERT(!m_renderView || !inHitTesting());
1841 
1842     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)
1843         return;
1844 
1845     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);








1846     auto shouldThrottleStyleRecalc = [&amp;] {
1847         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1848             return false;
1849         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1850             return false;
1851         return true;
1852     };
1853 
1854     if (shouldThrottleStyleRecalc())
1855         return;
1856 
1857     m_styleRecalcTimer.startOneShot(0_s);
1858 
1859     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1860 }
1861 
1862 void Document::unscheduleStyleRecalc()
1863 {
1864     ASSERT(!childNeedsStyleRecalc());
1865 
</pre>
<hr />
<pre>
1890     if (frameView.isPainting())
1891         return;
1892 
1893     if (m_inStyleRecalc)
1894         return; // Guard against re-entrancy. -dwh
1895 
1896     TraceScope tracingScope(StyleRecalcStart, StyleRecalcEnd);
1897 
1898     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
1899     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1900 
1901     // FIXME: Do this update per tree scope.
1902     {
1903         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1904         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1905         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1906         for (auto&amp; element : elements)
1907             element-&gt;updateShadowTree();
1908     }
1909 
<span class="line-modified">1910     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at</span>
<span class="line-modified">1911     // the time this comment was originally written caused several tests to crash.</span>




1912 
1913     {
1914         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1915         styleScope().flushPendingUpdate();
1916         frameView.willRecalcStyle();
1917     }
1918 
1919     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);
1920 
1921     bool updatedCompositingLayers = false;
1922     {
1923         Style::PostResolutionCallbackDisabler disabler(*this);
1924         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1925         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1926 
1927         m_inStyleRecalc = true;
1928 
1929         if (m_needsFullStyleRebuild)
1930             type = ResolveStyleType::Rebuild;
1931 
</pre>
<hr />
<pre>
1958         clearChildNeedsStyleRecalc();
1959         unscheduleStyleRecalc();
1960 
1961         m_inStyleRecalc = false;
1962 
1963         if (styleUpdate) {
1964             SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
1965 
1966             RenderTreeUpdater updater(*this);
1967             updater.commit(WTFMove(styleUpdate));
1968 
1969             frameView.styleDidChange();
1970         }
1971 
1972         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
1973 
1974         if (m_renderView-&gt;needsLayout())
1975             frameView.layoutContext().scheduleLayout();
1976 
1977         // Usually this is handled by post-layout.
<span class="line-modified">1978         if (!frameView.needsLayout())</span>
1979             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();



1980 
1981         // As a result of the style recalculation, the currently hovered element might have been
1982         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
1983         // to check if any other elements ended up under the mouse pointer due to re-layout.
1984         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
1985             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
1986 
1987         ++m_styleRecalcCount;
1988         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
1989     }
1990 
1991     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.
1992     if (m_closeAfterStyleRecalc) {
1993         m_closeAfterStyleRecalc = false;
1994         implicitClose();
1995     }
1996 
1997     InspectorInstrumentation::didRecalculateStyle(cookie);
1998 
1999     // Some animated images may now be inside the viewport due to style recalc,
2000     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2001     // check if they need to be resumed after layout.
2002     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2003         frameView.viewportContentsChanged();
2004 
2005     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2006         frameView.scrollToFragment(m_url);
2007 }
2008 
2009 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2010 {
2011     ASSERT(!m_inRenderTreeUpdate);
2012     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2013 
<span class="line-modified">2014     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);</span>
2015     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2016 
2017     RenderTreeUpdater renderTreeUpdater(*this);
2018     renderTreeUpdater.commit(WTFMove(textUpdate));
2019 }
2020 
2021 bool Document::needsStyleRecalc() const
2022 {
2023     if (pageCacheState() != NotInPageCache)
2024         return false;
2025 
2026     if (m_needsFullStyleRebuild)
2027         return true;
2028 
2029     if (childNeedsStyleRecalc())
2030         return true;
2031 
2032     if (styleScope().hasPendingUpdate())
2033         return true;
2034 
2035     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.
2036     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())
2037         return true;
2038 
2039     return false;
2040 }
2041 
2042 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2043 {
2044     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2045     auto* frameView = document.view();
2046     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
<span class="line-modified">2047     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();</span>

2048 }
2049 
2050 bool Document::updateStyleIfNeeded()
2051 {
2052     RefPtr&lt;FrameView&gt; frameView = view();
2053     {
2054         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2055         ASSERT(isMainThread());
2056         ASSERT(!frameView || !frameView-&gt;isPainting());
2057 
2058         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
2059             return false;
2060 
2061         styleScope().flushPendingUpdate();
2062 
2063         if (!needsStyleRecalc())
2064             return false;
2065     }
2066 
2067 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2068     ContentChangeObserver::StyleRecalcScope observingScope(*this);</span>





2069 #endif
2070     // The early exit above for !needsStyleRecalc() is needed when updateWidgetPositions() is called in runOrScheduleAsynchronousTasks().
2071     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));

2072     resolveStyle();
















2073     return true;
2074 }
2075 
2076 void Document::updateLayout()
2077 {
2078     ASSERT(isMainThread());
2079 
2080     RefPtr&lt;FrameView&gt; frameView = view();
2081     if (frameView &amp;&amp; frameView-&gt;layoutContext().isInRenderTreeLayout()) {
2082         // View layout should not be re-entrant.
2083         ASSERT_NOT_REACHED();
2084         return;
2085     }
2086     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(isSafeToUpdateStyleOrLayout(*this));
2087 
2088     RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
2089 
2090     if (HTMLFrameOwnerElement* owner = ownerElement())
2091         owner-&gt;document().updateLayout();
2092 
</pre>
<hr />
<pre>
2276         width = valueForLength(size.width, 0);
2277         height = valueForLength(size.height, 0);
2278         break;
2279     }
2280     default:
2281         ASSERT_NOT_REACHED();
2282     }
2283     pageSize = IntSize(width, height);
2284 
2285     // The percentage is calculated with respect to the width even for margin top and bottom.
2286     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2287     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2288     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2289     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2290     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2291 }
2292 
2293 StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()
2294 {
2295     if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">2296         m_userAgentShadowTreeStyleResolver = makeUnique&lt;StyleResolver&gt;(*this);</span>
2297     return *m_userAgentShadowTreeStyleResolver;
2298 }
2299 
2300 void Document::fontsNeedUpdate(FontSelector&amp;)
2301 {
2302     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2303 }
2304 
2305 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2306 {
2307     if (auto* resolver = styleScope().resolverIfExists())
2308         resolver-&gt;invalidateMatchedPropertiesCache();
2309     if (pageCacheState() != NotInPageCache || !renderView())
2310         return;
2311     scheduleFullStyleRebuild();
2312 }
2313 
2314 void Document::didClearStyleResolver()
2315 {
2316     m_userAgentShadowTreeStyleResolver = nullptr;
</pre>
<hr />
<pre>
2380                 timeline-&gt;resumeAnimations();
2381         } else
2382             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2383     }
2384 }
2385 
2386 void Document::frameDestroyed()
2387 {
2388     // detachFromFrame() must be called before destroying the Frame.
2389     RELEASE_ASSERT(!m_frame);
2390 
2391     if (auto* window = domWindow())
2392         window-&gt;frameDestroyed();
2393 
2394     FrameDestructionObserver::frameDestroyed();
2395 }
2396 
2397 void Document::willDetachPage()
2398 {
2399     FrameDestructionObserver::willDetachPage();
<span class="line-modified">2400 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">2401     contentChangeObserver().willDetachPage();</span>
<span class="line-added">2402 #endif</span>
2403     if (domWindow() &amp;&amp; frame())
2404         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2405 }
2406 
2407 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2408 {
2409     RELEASE_ASSERT(cachedFrame.document() == this);
2410     ASSERT(cachedFrame.view());
2411     ASSERT(m_pageCacheState == Document::InPageCache);
2412     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2413 }
2414 
2415 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2416 {
2417     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2418     RELEASE_ASSERT(cachedFrame.document() == this);
2419     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
2420     ASSERT(m_pageCacheState == Document::InPageCache);
2421     detachFromFrame();
2422 }
</pre>
<hr />
<pre>
2478 
2479 #if USE(LIBWEBRTC)
2480     // FIXME: This should be moved to Modules/mediastream.
2481     if (LibWebRTCProvider::webRTCAvailable()) {
2482         if (auto* page = this-&gt;page())
2483             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2484     }
2485 #endif
2486 
2487 #if ENABLE(SERVICE_WORKER)
2488     setActiveServiceWorker(nullptr);
2489     setServiceWorkerConnection(nullptr);
2490 #endif
2491 
2492 #if ENABLE(IOS_TOUCH_EVENTS)
2493     clearTouchEventHandlersAndListeners();
2494 #endif
2495 
2496     m_undoManager-&gt;removeAllItems();
2497 
<span class="line-modified">2498 #if ENABLE(ACCESSIBILITY)</span>
2499     if (this != &amp;topDocument()) {
2500         // Let the ax cache know that this subframe goes out of scope.
2501         if (auto* cache = existingAXObjectCache())
2502             cache-&gt;prepareForDocumentDestruction(*this);
2503     }
2504 #endif
2505 
2506     {
2507         NavigationDisabler navigationDisabler(m_frame);
2508         disconnectDescendantFrames();
2509     }
<span class="line-added">2510     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());</span>
2511 
2512     if (m_domWindow &amp;&amp; m_frame)
2513         m_domWindow-&gt;willDetachDocumentFromFrame();
2514 
2515     styleScope().clearResolver();
2516 
2517     if (hasLivingRenderTree())
2518         destroyRenderTree();
2519 
2520     if (is&lt;PluginDocument&gt;(*this))
2521         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2522 
2523 #if ENABLE(POINTER_LOCK)
2524     if (page())
2525         page()-&gt;pointerLockController().documentDetached(*this);
2526 #endif
2527 
2528     if (auto* page = this-&gt;page()) {
2529         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2530             validationMessageClient-&gt;documentDetached(*this);
2531     }
2532 
2533     InspectorInstrumentation::documentDetached(*this);
2534 
2535     stopActiveDOMObjects();
2536     m_eventQueue.close();
2537 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">2538     m_fullscreenManager-&gt;emptyEventQueue();</span>

2539 #endif
2540 
2541     commonTeardown();
2542 
2543 #if ENABLE(TOUCH_EVENTS)
2544     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2545         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2546 #endif
2547 
2548     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2549         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2550 
2551     if (m_mediaQueryMatcher)
2552         m_mediaQueryMatcher-&gt;documentDestroyed();
2553 
2554 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2555     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2556         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2557             removePlaybackTargetPickerClient(*client);
2558     }
2559 #endif
2560 
2561     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2562 
2563     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2564         m_mediaState = MediaProducer::IsNotPlaying;
2565         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2566     }
2567 
2568     detachFromFrame();
2569 
2570     if (m_timeline) {
2571         m_timeline-&gt;detachFromDocument();
2572         m_timeline = nullptr;
2573     }
2574 







2575 #if ENABLE(CSS_PAINTING_API)
2576     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2577         scope-&gt;prepareForDestruction();
2578     m_paintWorkletGlobalScopes.clear();
2579 #endif
2580 
2581     m_hasPreparedForDestruction = true;
2582 
2583     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame
2584     // was removed in an onpagehide event handler fired when the top-level frame is
2585     // about to enter the page cache.
2586     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);
2587 }
2588 
2589 void Document::removeAllEventListeners()
2590 {
2591     EventTarget::removeAllEventListeners();
2592 
2593     if (m_domWindow)
2594         m_domWindow-&gt;removeAllEventListeners();
</pre>
<hr />
<pre>
2624         return;
2625     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2626 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2627     if (m_deviceMotionController)
2628         m_deviceMotionController-&gt;resumeUpdates();
2629     if (m_deviceOrientationController)
2630         m_deviceOrientationController-&gt;resumeUpdates();
2631 #endif
2632 }
2633 
2634 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2635 {
2636     // Bypass this policy when the world is known, and it not the normal world.
2637     auto&amp; callFrame = *commonVM().topCallFrame;
2638     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();
2639 }
2640 
2641 void Document::platformSuspendOrStopActiveDOMObjects()
2642 {
2643 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2644     contentChangeObserver().didSuspendActiveDOMObjects();</span>






2645 #endif
2646 }
2647 
2648 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2649 {
2650     ScriptExecutionContext::suspendActiveDOMObjects(why);
2651     suspendDeviceMotionAndOrientationUpdates();
2652     platformSuspendOrStopActiveDOMObjects();
2653 }
2654 
2655 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2656 {
2657     ScriptExecutionContext::resumeActiveDOMObjects(why);
2658     resumeDeviceMotionAndOrientationUpdates();
2659     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2660 }
2661 
2662 void Document::stopActiveDOMObjects()
2663 {
2664     ScriptExecutionContext::stopActiveDOMObjects();
</pre>
<hr />
<pre>
2679     return topDocument().m_axObjectCache.get();
2680 }
2681 
2682 AXObjectCache* Document::axObjectCache() const
2683 {
2684     if (!AXObjectCache::accessibilityEnabled())
2685         return nullptr;
2686 
2687     // The only document that actually has a AXObjectCache is the top-level
2688     // document.  This is because we need to be able to get from any WebCoreAXObject
2689     // to any other WebCoreAXObject on the same page.  Using a single cache allows
2690     // lookups across nested webareas (i.e. multiple documents).
2691     Document&amp; topDocument = this-&gt;topDocument();
2692 
2693     // If the document has already been detached, do not make a new axObjectCache.
2694     if (!topDocument.hasLivingRenderTree())
2695         return nullptr;
2696 
2697     ASSERT(&amp;topDocument == this || !m_axObjectCache);
2698     if (!topDocument.m_axObjectCache) {
<span class="line-modified">2699         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);</span>
2700         hasEverCreatedAnAXObjectCache = true;
2701     }
2702     return topDocument.m_axObjectCache.get();
2703 }
2704 
2705 void Document::setVisuallyOrdered()
2706 {
2707     m_visuallyOrdered = true;
2708     if (renderView())
2709         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2710 }
2711 
2712 Ref&lt;DocumentParser&gt; Document::createParser()
2713 {
2714     // FIXME: this should probably pass the frame instead
2715     return XMLDocumentParser::create(*this, view());
2716 }
2717 
2718 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2719 {
2720     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2721 }
2722 
<span class="line-modified">2723 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)</span>
2724 {
2725     if (!m_domWindow)
2726         return Exception { InvalidAccessError };
2727 
2728     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2729 }
2730 
2731 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2732 {
2733     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2734         return Exception { InvalidStateError };
2735 
2736     auto result = open(responsibleDocument);
2737     if (UNLIKELY(result.hasException()))
2738         return result.releaseException();
2739 
2740     return *this;
2741 }
2742 
2743 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
</pre>
<hr />
<pre>
2745     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2746         return Exception { SecurityError };
2747 
2748     if (m_ignoreOpensDuringUnloadCount)
2749         return { };
2750 
2751     if (m_frame) {
2752         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2753             if (parser-&gt;isParsing()) {
2754                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2755                 if (parser-&gt;isExecutingScript())
2756                     return { };
2757 
2758                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2759                     return { };
2760             }
2761         }
2762 
2763         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2764             m_frame-&gt;loader().policyChecker().stopCheck();
<span class="line-modified">2765         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)</span>
2766             m_frame-&gt;loader().stopAllLoaders();
2767     }
2768 
2769     removeAllEventListeners();
2770 
2771     if (responsibleDocument &amp;&amp; isFullyActive()) {
2772         auto newURL = responsibleDocument-&gt;url();
2773         if (responsibleDocument != this)
2774             newURL.removeFragmentIdentifier();
2775         setURL(newURL);
2776         auto newCookieURL = responsibleDocument-&gt;cookieURL();
2777         if (responsibleDocument != this)
2778             newCookieURL.removeFragmentIdentifier();
2779         setCookieURL(newCookieURL);
2780         setSecurityOriginPolicy(responsibleDocument-&gt;securityOriginPolicy());
2781     }
2782 
2783     implicitOpen();
2784     if (ScriptableDocumentParser* parser = scriptableDocumentParser())
2785         parser-&gt;setWasCreatedByScript(true);
</pre>
<hr />
<pre>
3013         view()-&gt;layoutContext().unscheduleLayout();
3014         return;
3015     }
3016 
3017     frame()-&gt;loader().checkCallImplicitClose();
3018 
3019     // We used to force a synchronous display and flush here.  This really isn&#39;t
3020     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3021     // (if your platform is syncing flushes and limiting them to 60fps).
3022     m_overMinimumLayoutThreshold = true;
3023     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3024         updateStyleIfNeeded();
3025 
3026         // Always do a layout after loading if needed.
3027         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3028             view()-&gt;layoutContext().layout();
3029     }
3030 
3031     m_processingLoadEvent = false;
3032 
<span class="line-added">3033     if (auto* fontFaceSet = fontSelector().optionalFontFaceSet())</span>
<span class="line-added">3034         fontFaceSet-&gt;didFirstLayout();</span>
<span class="line-added">3035 </span>
3036 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3037     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3038         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3039         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3040         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3041         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3042         //
3043         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3044         // catch new AND page history loads, and that uses AXLoadComplete
3045 
3046         axObjectCache()-&gt;getOrCreate(renderView());
3047         if (this == &amp;topDocument())
3048             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3049         else {
3050             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3051             // in an iframe that just finished loading, post AXLayoutComplete instead.
3052             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3053         }
3054     }
3055 #endif
3056 
3057     if (svgExtensions())
3058         accessSVGExtensions().startAnimations();
3059 }
3060 
3061 void Document::setParsing(bool b)
3062 {
3063     m_bParsing = b;
3064 
3065     if (m_bParsing &amp;&amp; !m_sharedObjectPool)
<span class="line-modified">3066         m_sharedObjectPool = makeUnique&lt;DocumentSharedObjectPool&gt;();</span>
3067 
3068     if (!m_bParsing &amp;&amp; view() &amp;&amp; !view()-&gt;needsLayout())
3069         view()-&gt;fireLayoutRelatedMilestonesIfNeeded();
3070 }
3071 
3072 bool Document::shouldScheduleLayout()
3073 {
3074     if (!documentElement())
3075         return false;
3076     if (!is&lt;HTMLHtmlElement&gt;(*documentElement()))
3077         return true;
3078     if (!bodyOrFrameset())
3079         return false;
3080     if (styleScope().hasPendingSheetsBeforeBody())
3081         return false;
3082     if (page() &amp;&amp; page()-&gt;chrome().client().layerFlushThrottlingIsActive() &amp;&amp; view() &amp;&amp; view()-&gt;isVisuallyNonEmpty())
3083         return false;
3084 
3085     return true;
3086 }
</pre>
<hr />
<pre>
3218 {
3219     URL oldBaseURL = m_baseURL;
3220     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3221     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3222     // from the Document interface otherwise.
3223     if (!m_baseElementURL.isEmpty())
3224         m_baseURL = m_baseElementURL;
3225     else if (!m_baseURLOverride.isEmpty())
3226         m_baseURL = m_baseURLOverride;
3227     else {
3228         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3229         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3230         // and DOM 3 Core does not specify how it should be resolved.
3231         m_baseURL = URL({ }, documentURI());
3232     }
3233 
3234     clearSelectorQueryCache();
3235 
3236     if (!m_baseURL.isValid())
3237         m_baseURL = URL();







3238 }
3239 
3240 void Document::setBaseURLOverride(const URL&amp; url)
3241 {
3242     m_baseURLOverride = url;
3243     updateBaseURL();
3244 }
3245 
3246 void Document::processBaseElement()
3247 {
3248     // Find the first href attribute in a base element and the first target attribute in a base element.
<span class="line-modified">3249     const AtomString* href = nullptr;</span>
<span class="line-modified">3250     const AtomString* target = nullptr;</span>
3251     auto baseDescendants = descendantsOfType&lt;HTMLBaseElement&gt;(*this);
3252     for (auto&amp; base : baseDescendants) {
3253         if (!href) {
<span class="line-modified">3254             const AtomString&amp; value = base.attributeWithoutSynchronization(hrefAttr);</span>
3255             if (!value.isNull()) {
3256                 href = &amp;value;
3257                 if (target)
3258                     break;
3259             }
3260         }
3261         if (!target) {
<span class="line-modified">3262             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);</span>
3263             if (!value.isNull()) {
3264                 target = &amp;value;
3265                 if (href)
3266                     break;
3267             }
3268         }
3269     }
3270 
3271     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3272     URL baseElementURL;
3273     if (href) {
3274         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3275         if (!strippedHref.isEmpty())
3276             baseElementURL = URL(url(), strippedHref);
3277     }
3278     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
3279         m_baseElementURL = baseElementURL;
3280         updateBaseURL();
3281     }
3282 
</pre>
<hr />
<pre>
3435 
3436     // Only prevent top frame navigations by subframes.
3437     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3438         return false;
3439 
3440     // Only prevent navigations by subframes that the user has not interacted with.
3441     if (m_frame-&gt;hasHadUserInteraction())
3442         return false;
3443 
3444     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3445     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3446     if (sandboxFlags() != SandboxNone)
3447         return false;
3448 
3449     // Only prevent navigations by third-party iframes.
3450     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))
3451         return false;
3452 
3453     // Only prevent cross-site navigations.
3454     auto* targetDocument = targetFrame.document();
<span class="line-modified">3455     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))</span>
3456         return false;
3457 
3458     return true;
3459 }
3460 
3461 void Document::didRemoveAllPendingStylesheet()
3462 {
3463     if (auto* parser = scriptableDocumentParser())
3464         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
3465 }
3466 
3467 bool Document::usesStyleBasedEditability() const
3468 {
3469     if (m_hasElementUsingStyleBasedEditability)
3470         return true;
3471 
3472     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3473     ASSERT(!m_inStyleRecalc);
3474 
3475     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
</pre>
<hr />
<pre>
3589 {
3590     auto disabledAdaptations = parseDisabledAdaptations(disabledAdaptationsString);
3591     if (m_disabledAdaptations == disabledAdaptations)
3592         return;
3593 
3594     m_disabledAdaptations = disabledAdaptations;
3595     dispatchDisabledAdaptationsDidChangeForMainFrame();
3596 }
3597 
3598 void Document::dispatchDisabledAdaptationsDidChangeForMainFrame()
3599 {
3600     if (!frame()-&gt;isMainFrame())
3601         return;
3602 
3603     if (!page())
3604         return;
3605 
3606     page()-&gt;chrome().dispatchDisabledAdaptationsDidChange(m_disabledAdaptations);
3607 }
3608 









3609 void Document::processViewport(const String&amp; features, ViewportArguments::Type origin)
3610 {
3611     ASSERT(!features.isNull());
3612 
3613     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;Document::processViewport &quot; &lt;&lt; features);
3614 
3615     if (origin &lt; m_viewportArguments.type)
3616         return;
3617 
3618     m_viewportArguments = ViewportArguments(origin);
3619 
3620     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3621 
3622     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3623         setViewportFeature(m_viewportArguments, *this, key, value);
3624     });
3625 
3626     updateViewportArguments();
3627 }
3628 
<span class="line-added">3629 ViewportArguments Document::viewportArguments() const</span>
<span class="line-added">3630 {</span>
<span class="line-added">3631     auto* page = this-&gt;page();</span>
<span class="line-added">3632     if (!page)</span>
<span class="line-added">3633         return m_viewportArguments;</span>
<span class="line-added">3634     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);</span>
<span class="line-added">3635 }</span>
<span class="line-added">3636 </span>
3637 void Document::updateViewportArguments()
3638 {
3639     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
3640 #ifndef NDEBUG
3641         m_didDispatchViewportPropertiesChanged = true;
3642 #endif
<span class="line-modified">3643         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());</span>
3644         page()-&gt;chrome().didReceiveDocType(*frame());
3645     }
3646 }
3647 
3648 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">3649 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)</span>
3650 {
<span class="line-modified">3651     unsigned length = colorScheme.length();</span>





3652     for (unsigned i = 0; i &lt; length; ) {
3653         // Skip to first non-separator.
<span class="line-modified">3654         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))</span>
3655             ++i;
3656         unsigned keyBegin = i;
3657 
3658         // Skip to first separator.
<span class="line-modified">3659         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))</span>
3660             ++i;
3661         unsigned keyEnd = i;
3662 
3663         if (keyBegin == keyEnd)
3664             continue;
3665 
<span class="line-modified">3666         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));</span>
3667     }
3668 }
3669 
<span class="line-modified">3670 void Document::processColorScheme(const String&amp; colorSchemeString)</span>
3671 {
<span class="line-modified">3672     OptionSet&lt;ColorScheme&gt; colorScheme;</span>
3673     bool allowsTransformations = true;
3674     bool autoEncountered = false;
3675 
<span class="line-modified">3676     processColorSchemeString(colorSchemeString, [&amp;](StringView key) {</span>
3677         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
<span class="line-modified">3678             colorScheme = { };</span>
3679             allowsTransformations = true;
3680             autoEncountered = true;
3681             return;
3682         }
3683 
3684         if (autoEncountered)
3685             return;
3686 
3687         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
<span class="line-modified">3688             colorScheme.add(ColorScheme::Light);</span>
3689         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
<span class="line-modified">3690             colorScheme.add(ColorScheme::Dark);</span>
3691         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3692             allowsTransformations = false;
3693     });
3694 
3695     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
<span class="line-modified">3696     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)</span>
<span class="line-modified">3697         colorScheme.add(ColorScheme::Light);</span>
3698 
<span class="line-modified">3699     m_colorScheme = colorScheme;</span>
3700     m_allowsColorSchemeTransformations = allowsTransformations;
3701 
3702     if (auto* frameView = view())
3703         frameView-&gt;recalculateBaseBackgroundColor();
3704 
3705     if (auto* page = this-&gt;page())
3706         page-&gt;updateStyleAfterChangeInEnvironment();
3707 }
3708 #endif
3709 
3710 #if PLATFORM(IOS_FAMILY)
3711 
3712 void Document::processFormatDetection(const String&amp; features)
3713 {
3714     // FIXME: Find a better place for this function.
3715     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3716         if (equalLettersIgnoringASCIICase(key, &quot;telephone&quot;) &amp;&amp; equalLettersIgnoringASCIICase(value, &quot;no&quot;))
3717             m_isTelephoneNumberParsingAllowed = false;
3718     });
3719 }
</pre>
<hr />
<pre>
3740         return;
3741 #endif
3742 
3743     auto referrerPolicy = parseReferrerPolicy(policy, source);
3744     if (!referrerPolicy) {
3745         // Unknown policy values are ignored (https://w3c.github.io/webappsec-referrer-policy/#unknown-policy-values).
3746         addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, &quot;Failed to set referrer policy: The value &#39;&quot; + policy + &quot;&#39; is not one of &#39;no-referrer&#39;, &#39;no-referrer-when-downgrade&#39;, &#39;same-origin&#39;, &#39;origin&#39;, &#39;strict-origin&#39;, &#39;origin-when-cross-origin&#39;, &#39;strict-origin-when-cross-origin&#39; or &#39;unsafe-url&#39;.&quot;);
3747         return;
3748     }
3749     setReferrerPolicy(referrerPolicy.value());
3750 }
3751 
3752 MouseEventWithHitTestResults Document::prepareMouseEvent(const HitTestRequest&amp; request, const LayoutPoint&amp; documentPoint, const PlatformMouseEvent&amp; event)
3753 {
3754     if (!hasLivingRenderTree())
3755         return MouseEventWithHitTestResults(event, HitTestResult(LayoutPoint()));
3756 
3757     HitTestResult result(documentPoint);
3758     hitTest(request, result);
3759 
<span class="line-modified">3760     auto captureElementChanged = CaptureChange::No;</span>
<span class="line-modified">3761     if (!request.readOnly()) {</span>
<span class="line-added">3762         auto targetElement = makeRefPtr(result.targetElement());</span>
<span class="line-added">3763 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">3764         if (auto* page = this-&gt;page()) {</span>
<span class="line-added">3765             // Before we dispatch a new mouse event, we must run the Process Pending Capture Element steps as defined</span>
<span class="line-added">3766             // in https://w3c.github.io/pointerevents/#process-pending-pointer-capture.</span>
<span class="line-added">3767             auto&amp; pointerCaptureController = page-&gt;pointerCaptureController();</span>
<span class="line-added">3768             auto* previousCaptureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());</span>
<span class="line-added">3769             pointerCaptureController.processPendingPointerCapture(event.pointerId());</span>
<span class="line-added">3770             auto* captureElement = pointerCaptureController.pointerCaptureElement(this, event.pointerId());</span>
<span class="line-added">3771             // If the capture element has changed while running the Process Pending Capture Element steps then</span>
<span class="line-added">3772             // we need to indicate that when calling updateHoverActiveState to be sure that the :active and :hover</span>
<span class="line-added">3773             // element chains are updated.</span>
<span class="line-added">3774             if (previousCaptureElement != captureElement)</span>
<span class="line-added">3775                 captureElementChanged = CaptureChange::Yes;</span>
<span class="line-added">3776             // If we have a capture element, we must target it instead of what would normally hit-test for this event.</span>
<span class="line-added">3777             if (captureElement)</span>
<span class="line-added">3778                 targetElement = captureElement;</span>
<span class="line-added">3779         }</span>
<span class="line-added">3780 #endif</span>
<span class="line-added">3781         updateHoverActiveState(request, targetElement.get(), captureElementChanged);</span>
<span class="line-added">3782     }</span>
3783 
3784     return MouseEventWithHitTestResults(event, result);
3785 }
3786 
3787 // DOM Section 1.1.1
3788 bool Document::childTypeAllowed(NodeType type) const
3789 {
3790     switch (type) {
3791     case ATTRIBUTE_NODE:
3792     case CDATA_SECTION_NODE:
3793     case DOCUMENT_FRAGMENT_NODE:
3794     case DOCUMENT_NODE:
3795     case TEXT_NODE:
3796         return false;
3797     case COMMENT_NODE:
3798     case PROCESSING_INSTRUCTION_NODE:
3799         return true;
3800     case DOCUMENT_TYPE_NODE:
3801     case ELEMENT_NODE:
3802         // Documents may contain no more than one of each of these.
</pre>
<hr />
<pre>
3872             }
3873         }
3874         break;
3875     }
3876     }
3877     return true;
3878 }
3879 
3880 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3881 {
3882     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3883     clone-&gt;cloneDataFromDocument(*this);
3884     switch (type) {
3885     case CloningOperation::OnlySelf:
3886     case CloningOperation::SelfWithTemplateContent:
3887         break;
3888     case CloningOperation::Everything:
3889         cloneChildNodes(clone);
3890         break;
3891     }
<span class="line-modified">3892     return clone;</span>
3893 }
3894 
3895 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
3896 {
3897     if (isXMLDocument()) {
3898         if (isXHTMLDocument())
<span class="line-modified">3899             return XMLDocument::createXHTML(sessionID(), nullptr, url());</span>
<span class="line-modified">3900         return XMLDocument::create(sessionID(), nullptr, url());</span>
3901     }
<span class="line-modified">3902     return create(sessionID(), url());</span>
3903 }
3904 
3905 void Document::cloneDataFromDocument(const Document&amp; other)
3906 {
3907     ASSERT(m_url == other.url());
3908     m_baseURL = other.baseURL();
3909     m_baseURLOverride = other.baseURLOverride();
3910     m_documentURI = other.documentURI();
3911 
3912     setCompatibilityMode(other.m_compatibilityMode);
3913     setContextDocument(other.contextDocument());
3914     setSecurityOriginPolicy(other.securityOriginPolicy());
3915     overrideMIMEType(other.contentType());
3916     setDecoder(other.decoder());
3917 }
3918 
3919 StyleSheetList&amp; Document::styleSheets()
3920 {
3921     if (!m_styleSheetList)
3922         m_styleSheetList = StyleSheetList::create(*this);
</pre>
<hr />
<pre>
3956         picture-&gt;sourcesChanged();
3957 }
3958 
3959 void Document::updateViewportUnitsOnResize()
3960 {
3961     if (!hasStyleWithViewportUnits())
3962         return;
3963 
3964     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();
3965 
3966     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
3967     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
3968         auto* renderer = element-&gt;renderer();
3969         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
3970             element-&gt;invalidateStyle();
3971     }
3972 }
3973 
3974 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
3975 {
<span class="line-modified">3976     m_audioProducers.add(audioProducer);</span>
3977     updateIsPlayingMedia();
3978 }
3979 
3980 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
3981 {
<span class="line-modified">3982     RELEASE_ASSERT(isMainThread());</span>
<span class="line-added">3983     m_audioProducers.remove(audioProducer);</span>
3984     updateIsPlayingMedia();
3985 }
3986 
3987 void Document::noteUserInteractionWithMediaElement()
3988 {
3989     if (m_userHasInteractedWithMediaElement)
3990         return;
3991 
3992     if (!topDocument().userDidInteractWithPage())
3993         return;
3994 
3995     m_userHasInteractedWithMediaElement = true;
3996     updateIsPlayingMedia();
3997 }
3998 
3999 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4000 {
<span class="line-added">4001     ASSERT(!m_audioProducers.hasNullReferences());</span>
4002     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
<span class="line-modified">4003     for (auto&amp; audioProducer : m_audioProducers)</span>
<span class="line-modified">4004         state |= audioProducer.mediaState();</span>
<span class="line-added">4005 </span>
<span class="line-added">4006 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">4007     state |= MediaStreamTrack::captureState();</span>
<span class="line-added">4008 #endif</span>
4009 
4010 #if ENABLE(MEDIA_SESSION)
4011     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4012         if (sourceElement-&gt;isPlaying())
4013             state |= MediaProducer::IsSourceElementPlaying;
4014 
4015         if (auto* session = sourceElement-&gt;session()) {
4016             if (auto* controls = session-&gt;controls()) {
4017                 if (controls-&gt;previousTrackEnabled())
4018                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4019                 if (controls-&gt;nextTrackEnabled())
4020                     state |= MediaProducer::IsNextTrackControlEnabled;
4021             }
4022         }
4023     }
4024 #endif
4025 
4026     if (m_userHasInteractedWithMediaElement)
4027         state |= MediaProducer::HasUserInteractedWithMediaElement;
4028 
4029     if (state == m_mediaState)
4030         return;
4031 
4032 #if ENABLE(MEDIA_STREAM)
4033     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4034 #endif
4035 
4036     m_mediaState = state;
4037 
4038     if (page())
4039         page()-&gt;updateIsPlayingMedia(sourceElementID);
4040 
4041 #if ENABLE(MEDIA_STREAM)
4042     if (captureStateChanged)
4043         mediaStreamCaptureStateChanged();
4044 #endif
4045 }
4046 
4047 void Document::pageMutedStateDidChange()
4048 {
<span class="line-modified">4049     for (auto&amp; audioProducer : m_audioProducers)</span>
<span class="line-modified">4050         audioProducer.pageMutedStateDidChange();</span>
<span class="line-added">4051 </span>
<span class="line-added">4052 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">4053     MediaStreamTrack::muteCapture();</span>
<span class="line-added">4054 #endif</span>
4055 }
4056 
4057 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4058 {
4059     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4060         return node.isDescendantOf(container);
4061 
4062     return &amp;node == &amp;container || node.isDescendantOf(container);
4063 }
4064 
4065 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4066 {
4067     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.
4068         return;
4069 
4070     Element* focusedElement = node.treeScope().focusedElementInScope();
4071     if (!focusedElement)
4072         return;
4073 
4074     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
</pre>
<hr />
<pre>
4089     if (!m_hoveredElement || &amp;element != m_hoveredElement)
4090         return;
4091 
4092     m_hoveredElement = element.parentElement();
4093     while (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
4094         m_hoveredElement = m_hoveredElement-&gt;parentElement();
4095     if (frame())
4096         frame()-&gt;eventHandler().scheduleHoverStateUpdate();
4097 }
4098 
4099 void Document::elementInActiveChainDidDetach(Element&amp; element)
4100 {
4101     if (!m_activeElement || &amp;element != m_activeElement)
4102         return;
4103 
4104     m_activeElement = element.parentElement();
4105     while (m_activeElement &amp;&amp; !m_activeElement-&gt;renderer())
4106         m_activeElement = m_activeElement-&gt;parentElement();
4107 }
4108 
<span class="line-modified">4109 void Document::invalidateRenderingDependentRegions()</span>





























4110 {











4111 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
4112     setTouchEventRegionsNeedUpdate();
4113 #endif
4114 
<span class="line-modified">4115 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)</span>
4116     if (auto* page = this-&gt;page()) {
4117         if (auto* frameView = view()) {
4118             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4119                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4120         }
4121     }
4122 #endif
4123 }
4124 
















4125 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4126 {
4127     RefPtr&lt;Element&gt; newFocusedElement = element;
4128     // Make sure newFocusedElement is actually in this document
4129     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4130         return true;
4131 
4132     if (m_focusedElement == newFocusedElement)
4133         return true;
4134 
4135     if (pageCacheState() != NotInPageCache)
4136         return false;
4137 
4138     bool focusChangeBlocked = false;
4139     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4140 
4141     // Remove focus from the existing focus node (if any)
4142     if (oldFocusedElement) {
4143         oldFocusedElement-&gt;setFocus(false);
4144         setFocusNavigationStartingNode(nullptr);
</pre>
<hr />
<pre>
4420             detachNodeIterator(*iterator);
4421             newDocument.attachNodeIterator(*iterator);
4422         }
4423     }
4424 }
4425 
4426 void Document::updateRangesAfterChildrenChanged(ContainerNode&amp; container)
4427 {
4428     for (auto* range : m_ranges)
4429         range-&gt;nodeChildrenChanged(container);
4430 }
4431 
4432 void Document::nodeChildrenWillBeRemoved(ContainerNode&amp; container)
4433 {
4434     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4435 
4436     adjustFocusedNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4437     adjustFocusNavigationNodeOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);
4438 
4439 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">4440     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(container, NodeRemoval::ChildrenOfNode);</span>
4441 #endif
4442 
4443     for (auto* range : m_ranges)
4444         range-&gt;nodeChildrenWillBeRemoved(container);
4445 
4446     for (auto* it : m_nodeIterators) {
4447         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling())
4448             it-&gt;nodeWillBeRemoved(*n);
4449     }
4450 
4451     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4452         for (Node* n = container.firstChild(); n; n = n-&gt;nextSibling()) {
4453             frame-&gt;eventHandler().nodeWillBeRemoved(*n);
4454             frame-&gt;selection().nodeWillBeRemoved(*n);
4455             frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(*n);
4456         }
4457     }
4458 
4459     if (m_markers-&gt;hasMarkers()) {
4460         for (Text* textNode = TextNodeTraversal::firstChild(container); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
4461             m_markers-&gt;removeMarkers(*textNode);
4462     }
4463 }
4464 
4465 void Document::nodeWillBeRemoved(Node&amp; node)
4466 {
4467     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
4468 
4469     adjustFocusedNodeOnNodeRemoval(node);
4470     adjustFocusNavigationNodeOnNodeRemoval(node);
4471 
4472 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">4473     m_fullscreenManager-&gt;adjustFullscreenElementOnNodeRemoval(node, NodeRemoval::Node);</span>
4474 #endif
4475 
4476     for (auto* it : m_nodeIterators)
4477         it-&gt;nodeWillBeRemoved(node);
4478 
4479     for (auto* range : m_ranges)
4480         range-&gt;nodeWillBeRemoved(node);
4481 
4482     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
4483         frame-&gt;eventHandler().nodeWillBeRemoved(node);
4484         frame-&gt;selection().nodeWillBeRemoved(node);
4485         frame-&gt;page()-&gt;dragCaretController().nodeWillBeRemoved(node);
4486     }
4487 
4488     if (is&lt;Text&gt;(node))
4489         m_markers-&gt;removeMarkers(node);





4490 }
4491 
4492 static Node* fallbackFocusNavigationStartingNodeAfterRemoval(Node&amp; node)
4493 {
4494     return node.previousSibling() ? node.previousSibling() : node.parentNode();
4495 }
4496 
4497 void Document::adjustFocusNavigationNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4498 {
4499     if (!m_focusNavigationStartingNode)
4500         return;
4501 
4502     if (isNodeInSubtree(*m_focusNavigationStartingNode, node, nodeRemoval)) {
4503         auto* newNode = (nodeRemoval == NodeRemoval::ChildrenOfNode) ? &amp;node : fallbackFocusNavigationStartingNodeAfterRemoval(node);
4504         m_focusNavigationStartingNode = (newNode != this) ? newNode : nullptr;
4505         m_focusNavigationStartingNodeIsRemoved = true;
4506     }
4507 }
4508 
4509 void Document::textInserted(Node&amp; text, unsigned offset, unsigned length)
4510 {
4511     if (!m_ranges.isEmpty()) {
4512         for (auto* range : m_ranges)
4513             range-&gt;textInserted(text, offset, length);
4514     }
4515 
4516     // Update the markers for spelling and grammar checking.
4517     m_markers-&gt;shiftMarkers(text, offset, length);
<span class="line-added">4518 </span>
<span class="line-added">4519 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)</span>
<span class="line-added">4520     // Freshly inserted text is expected to not inherit PlatformTextChecking markers.</span>
<span class="line-added">4521     m_markers-&gt;removeMarkers(text, offset, length, DocumentMarker::PlatformTextChecking);</span>
<span class="line-added">4522 #endif</span>
4523 }
4524 
4525 void Document::textRemoved(Node&amp; text, unsigned offset, unsigned length)
4526 {
4527     if (!m_ranges.isEmpty()) {
4528         for (auto* range : m_ranges)
4529             range-&gt;textRemoved(text, offset, length);
4530     }
4531 
4532     // Update the markers for spelling and grammar checking.
4533     m_markers-&gt;removeMarkers(text, offset, length);
4534     m_markers-&gt;shiftMarkers(text, offset + length, 0 - length);
4535 }
4536 
4537 void Document::textNodesMerged(Text&amp; oldNode, unsigned offset)
4538 {
4539     if (!m_ranges.isEmpty()) {
4540         NodeWithIndex oldNodeWithIndex(&amp;oldNode);
4541         for (auto* range : m_ranges)
4542             range-&gt;textNodesMerged(oldNodeWithIndex, offset);
</pre>
<hr />
<pre>
4578     m_domWindow-&gt;didSecureTransitionTo(*this);
4579 
4580     ASSERT(m_domWindow-&gt;document() == this);
4581     ASSERT(m_domWindow-&gt;frame() == m_frame);
4582 }
4583 
4584 WindowProxy* Document::windowProxy() const
4585 {
4586     if (!m_frame)
4587         return nullptr;
4588     return &amp;m_frame-&gt;windowProxy();
4589 }
4590 
4591 Document&amp; Document::contextDocument() const
4592 {
4593     if (m_contextDocument)
4594         return *m_contextDocument.get();
4595     return const_cast&lt;Document&amp;&gt;(*this);
4596 }
4597 
<span class="line-modified">4598 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
4599 {
4600     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4601 }
4602 
<span class="line-modified">4603 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)</span>
4604 {
4605     if (!m_domWindow)
4606         return;
4607     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4608 }
4609 
<span class="line-modified">4610 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)</span>
4611 {
4612     if (!m_domWindow)
4613         return;
4614     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4615 }
4616 
<span class="line-modified">4617 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)</span>
4618 {
4619     if (!m_domWindow)
4620         return nullptr;
4621     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4622 }
4623 
4624 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4625 {
4626     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4627     if (!m_domWindow)
4628         return;
4629     m_domWindow-&gt;dispatchEvent(event, target);
4630 }
4631 
4632 void Document::dispatchWindowLoadEvent()
4633 {
4634     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4635     if (!m_domWindow)
4636         return;
4637     m_domWindow-&gt;dispatchLoadEvent();
</pre>
<hr />
<pre>
4736 
4737     return Exception { NotSupportedError };
4738 }
4739 
4740 bool Document::hasListenerTypeForEventType(PlatformEvent::Type eventType) const
4741 {
4742     switch (eventType) {
4743     case PlatformEvent::MouseForceChanged:
4744         return m_listenerTypes &amp; Document::FORCECHANGED_LISTENER;
4745     case PlatformEvent::MouseForceDown:
4746         return m_listenerTypes &amp; Document::FORCEDOWN_LISTENER;
4747     case PlatformEvent::MouseForceUp:
4748         return m_listenerTypes &amp; Document::FORCEUP_LISTENER;
4749     case PlatformEvent::MouseScroll:
4750         return m_listenerTypes &amp; Document::SCROLL_LISTENER;
4751     default:
4752         return false;
4753     }
4754 }
4755 
<span class="line-modified">4756 void Document::addListenerTypeIfNeeded(const AtomString&amp; eventType)</span>
4757 {
4758     if (eventType == eventNames().DOMSubtreeModifiedEvent)
4759         addListenerType(DOMSUBTREEMODIFIED_LISTENER);
4760     else if (eventType == eventNames().DOMNodeInsertedEvent)
4761         addListenerType(DOMNODEINSERTED_LISTENER);
4762     else if (eventType == eventNames().DOMNodeRemovedEvent)
4763         addListenerType(DOMNODEREMOVED_LISTENER);
4764     else if (eventType == eventNames().DOMNodeRemovedFromDocumentEvent)
4765         addListenerType(DOMNODEREMOVEDFROMDOCUMENT_LISTENER);
4766     else if (eventType == eventNames().DOMNodeInsertedIntoDocumentEvent)
4767         addListenerType(DOMNODEINSERTEDINTODOCUMENT_LISTENER);
4768     else if (eventType == eventNames().DOMCharacterDataModifiedEvent)
4769         addListenerType(DOMCHARACTERDATAMODIFIED_LISTENER);
4770     else if (eventType == eventNames().overflowchangedEvent)
4771         addListenerType(OVERFLOWCHANGED_LISTENER);
4772     else if (eventType == eventNames().webkitAnimationStartEvent || eventType == eventNames().animationstartEvent)
4773         addListenerType(ANIMATIONSTART_LISTENER);
4774     else if (eventType == eventNames().webkitAnimationEndEvent || eventType == eventNames().animationendEvent)
4775         addListenerType(ANIMATIONEND_LISTENER);
4776     else if (eventType == eventNames().webkitAnimationIterationEvent || eventType == eventNames().animationiterationEvent)
</pre>
<hr />
<pre>
4845         return { };
4846 
4847     if (isCookieAverse())
4848         return { };
4849 
4850     if (!securityOrigin().canAccessCookies())
4851         return Exception { SecurityError };
4852 
4853     URL cookieURL = this-&gt;cookieURL();
4854     if (cookieURL.isEmpty())
4855         return { };
4856 
4857     invalidateDOMCookieCache();
4858     if (page())
4859         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
4860     return { };
4861 }
4862 
4863 String Document::referrer() const
4864 {
<span class="line-added">4865 #if ENABLE(RESOURCE_LOAD_STATISTICS)</span>
<span class="line-added">4866     if (!m_referrerOverride.isEmpty())</span>
<span class="line-added">4867         return m_referrerOverride;</span>
<span class="line-added">4868 #endif</span>
4869     if (frame())
4870         return frame()-&gt;loader().referrer();
4871     return String();
4872 }
4873 
4874 String Document::origin() const
4875 {
4876     return securityOrigin().toString();
4877 }
4878 
4879 String Document::domain() const
4880 {
4881     return securityOrigin().domain();
4882 }
4883 











































4884 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
4885 {
4886     if (!frame())
4887         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
4888 
4889     if (isSandboxed(SandboxDocumentDomain))
4890         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
4891 
4892     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))
4893         return Exception { SecurityError };
4894 
4895     // FIXME: We should add logging indicating why a domain was not allowed.
4896 
4897     const String&amp; effectiveDomain = domain();
4898     if (effectiveDomain.isEmpty())
4899         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
4900 
<span class="line-modified">4901     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))</span>
4902         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
4903 
4904     securityOrigin().setDomainFromDOM(newDomain);
4905     return { };
4906 }
4907 
4908 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
4909 {
4910     m_overrideLastModified = lastModified;
4911 }
4912 
4913 // http://www.whatwg.org/specs/web-apps/current-work/#dom-document-lastmodified
4914 String Document::lastModified() const
4915 {
4916     Optional&lt;WallTime&gt; dateTime;
4917     if (m_overrideLastModified)
4918         dateTime = m_overrideLastModified;
4919     else if (loader())
4920         dateTime = loader()-&gt;response().lastModified();
4921 
</pre>
<hr />
<pre>
4943 }
4944 
4945 static bool isValidNameNonASCII(const LChar* characters, unsigned length)
4946 {
4947     if (!isValidNameStart(characters[0]))
4948         return false;
4949 
4950     for (unsigned i = 1; i &lt; length; ++i) {
4951         if (!isValidNamePart(characters[i]))
4952             return false;
4953     }
4954 
4955     return true;
4956 }
4957 
4958 static bool isValidNameNonASCII(const UChar* characters, unsigned length)
4959 {
4960     unsigned i = 0;
4961 
4962     UChar32 c;
<span class="line-modified">4963     U16_NEXT(characters, i, length, c);</span>
4964     if (!isValidNameStart(c))
4965         return false;
4966 
4967     while (i &lt; length) {
<span class="line-modified">4968         U16_NEXT(characters, i, length, c);</span>
4969         if (!isValidNamePart(c))
4970             return false;
4971     }
4972 
4973     return true;
4974 }
4975 
4976 template&lt;typename CharType&gt;
4977 static inline bool isValidNameASCII(const CharType* characters, unsigned length)
4978 {
4979     CharType c = characters[0];
4980     if (!(isASCIIAlpha(c) || c == &#39;:&#39; || c == &#39;_&#39;))
4981         return false;
4982 
4983     for (unsigned i = 1; i &lt; length; ++i) {
4984         c = characters[i];
4985         if (!(isASCIIAlphanumeric(c) || c == &#39;:&#39; || c == &#39;_&#39; || c == &#39;-&#39; || c == &#39;.&#39;))
4986             return false;
4987     }
4988 
</pre>
<hr />
<pre>
4995     if (!length)
4996         return false;
4997 
4998     if (name.is8Bit()) {
4999         const LChar* characters = name.characters8();
5000 
5001         if (isValidNameASCII(characters, length))
5002             return true;
5003 
5004         return isValidNameNonASCII(characters, length);
5005     }
5006 
5007     const UChar* characters = name.characters16();
5008 
5009     if (isValidNameASCII(characters, length))
5010         return true;
5011 
5012     return isValidNameNonASCII(characters, length);
5013 }
5014 
<span class="line-modified">5015 ExceptionOr&lt;std::pair&lt;AtomString, AtomString&gt;&gt; Document::parseQualifiedName(const String&amp; qualifiedName)</span>
5016 {
5017     unsigned length = qualifiedName.length();
5018 
5019     if (!length)
5020         return Exception { InvalidCharacterError };
5021 
5022     bool nameStart = true;
5023     bool sawColon = false;
5024     unsigned colonPosition = 0;
5025 
5026     for (unsigned i = 0; i &lt; length; ) {
5027         UChar32 c;
<span class="line-modified">5028         U16_NEXT(qualifiedName, i, length, c);</span>
5029         if (c == &#39;:&#39;) {
5030             if (sawColon)
5031                 return Exception { InvalidCharacterError };
5032             nameStart = true;
5033             sawColon = true;
5034             colonPosition = i - 1;
5035         } else if (nameStart) {
5036             if (!isValidNameStart(c))
5037                 return Exception { InvalidCharacterError };
5038             nameStart = false;
5039         } else {
5040             if (!isValidNamePart(c))
5041                 return Exception { InvalidCharacterError };
5042         }
5043     }
5044 
5045     if (!sawColon)
<span class="line-modified">5046         return std::pair&lt;AtomString, AtomString&gt; { { }, { qualifiedName } };</span>
5047 
5048     if (!colonPosition || length - colonPosition &lt;= 1)
5049         return Exception { InvalidCharacterError };
5050 
<span class="line-modified">5051     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };</span>
5052 }
5053 
<span class="line-modified">5054 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)</span>
5055 {
5056     auto parseResult = parseQualifiedName(qualifiedName);
5057     if (parseResult.hasException())
5058         return parseResult.releaseException();
5059     auto parsedPieces = parseResult.releaseReturnValue();
5060     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5061 }
5062 
5063 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5064 {
5065     m_decoder = WTFMove(decoder);
5066 }
5067 
5068 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const
5069 {
5070     // Always return a null URL when passed a null string.
5071     // FIXME: Should we change the URL constructor to have this behavior?
5072     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5073     if (url.isNull())
5074         return URL();
5075     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
5076     if (!m_decoder)
5077         return URL(baseURL, url);
5078     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5079 }
5080 
5081 URL Document::completeURL(const String&amp; url) const
5082 {
5083     return completeURL(url, m_baseURL);
5084 }
5085 
5086 PAL::SessionID Document::sessionID() const
5087 {






5088     return m_sessionID;
5089 }
5090 
5091 void Document::setPageCacheState(PageCacheState state)
5092 {
5093     if (m_pageCacheState == state)
5094         return;
5095 
5096     m_pageCacheState = state;
5097 
5098     FrameView* v = view();
5099     Page* page = this-&gt;page();
5100 
5101     switch (state) {
5102     case InPageCache:
5103         if (v) {
5104             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
5105             // page cache and similar work that needs to occur when it comes out. This is where we do the work
5106             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5107             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
</pre>
<hr />
<pre>
5266     return settings().audioPlaybackRequiresUserGesture();
5267 }
5268 
5269 bool Document::videoPlaybackRequiresUserGesture() const
5270 {
5271     if (DocumentLoader* loader = this-&gt;loader()) {
5272         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5273         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5274         if (policy != AutoplayPolicy::Default)
5275             return policy == AutoplayPolicy::Deny;
5276     }
5277 
5278     return settings().videoPlaybackRequiresUserGesture();
5279 }
5280 
5281 void Document::storageBlockingStateDidChange()
5282 {
5283     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5284 }
5285 
<span class="line-modified">5286 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)</span>
5287 {
<span class="line-modified">5288     m_sessionID = sessionID;</span>
5289     if (m_logger)
<span class="line-modified">5290         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());</span>
5291 
5292     for (auto* element : m_privateBrowsingStateChangedElements)
<span class="line-modified">5293         element-&gt;privateBrowsingStateDidChange(sessionID);</span>
5294 
5295 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5296     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection)</span>
<span class="line-modified">5297         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID));</span>

5298 #endif
5299 }
5300 
5301 void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5302 {
5303     m_privateBrowsingStateChangedElements.add(&amp;element);
5304 }
5305 
5306 void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)
5307 {
5308     m_privateBrowsingStateChangedElements.remove(&amp;element);
5309 }
5310 
5311 #if ENABLE(VIDEO_TRACK)
5312 
5313 void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)
5314 {
5315     if (page())
5316         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5317 
</pre>
<hr />
<pre>
5364     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)
5365         mediaElement-&gt;userInterfaceLayoutDirectionChanged();
5366 }
5367 
5368 #endif
5369 
5370 void Document::setShouldCreateRenderers(bool f)
5371 {
5372     m_createRenderers = f;
5373 }
5374 
5375 bool Document::shouldCreateRenderers()
5376 {
5377     return m_createRenderers;
5378 }
5379 
5380 // Support for Javascript execCommand, and related methods
5381 
5382 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5383 {
<span class="line-modified">5384     auto protectedDocument = makeRef(*document);</span>


5385 
5386     document-&gt;updateStyleIfNeeded();
5387 
<span class="line-added">5388     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">5389 </span>
<span class="line-added">5390     if (!frame || frame-&gt;document() != document)</span>
<span class="line-added">5391         return Editor::Command();</span>
<span class="line-added">5392 </span>
5393     return frame-&gt;editor().command(commandName,
5394         userInterface ? CommandFromDOMWithUserInterface : CommandFromDOM);
5395 }
5396 
5397 bool Document::execCommand(const String&amp; commandName, bool userInterface, const String&amp; value)
5398 {
5399     EventQueueScope eventQueueScope;
5400     return command(this, commandName, userInterface).execute(value);
5401 }
5402 
5403 bool Document::queryCommandEnabled(const String&amp; commandName)
5404 {
5405     return command(this, commandName).isEnabled();
5406 }
5407 
5408 bool Document::queryCommandIndeterm(const String&amp; commandName)
5409 {
5410     return command(this, commandName).state() == MixedTriState;
5411 }
5412 
</pre>
<hr />
<pre>
5550     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
5551     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {
5552         if (!m_frame)
5553             return const_cast&lt;Document&amp;&gt;(*this);
5554         // This should always be non-null.
5555         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5556         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5557     }
5558 
5559     Document* document = const_cast&lt;Document*&gt;(this);
5560     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5561         document = &amp;element-&gt;document();
5562     return *document;
5563 }
5564 
5565 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)
5566 {
5567     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);
5568 }
5569 
<span class="line-modified">5570 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)</span>
5571 {
5572     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5573     if (parseResult.hasException())
5574         return parseResult.releaseException();
5575     QualifiedName parsedName { parseResult.releaseReturnValue() };
5576     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5577         return Exception { NamespaceError };
5578     return Attr::create(*this, parsedName, emptyString());
5579 }
5580 
5581 const SVGDocumentExtensions* Document::svgExtensions()
5582 {
5583     return m_svgExtensions.get();
5584 }
5585 
5586 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5587 {
5588     if (!m_svgExtensions)
<span class="line-modified">5589         m_svgExtensions = makeUnique&lt;SVGDocumentExtensions&gt;(*this);</span>
5590     return *m_svgExtensions;
5591 }
5592 
5593 void Document::addSVGUseElement(SVGUseElement&amp; element)
5594 {
5595     auto result = m_svgUseElements.add(&amp;element);
5596     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result.isNewEntry);
5597 }
5598 
5599 void Document::removeSVGUseElement(SVGUseElement&amp; element)
5600 {
5601     m_svgUseElements.remove(&amp;element);
5602     // FIXME: Assert that element was in m_svgUseElements once re-entrancy to update style and layout have been removed.
5603 }
5604 
5605 bool Document::hasSVGRootNode() const
5606 {
5607     return documentElement() &amp;&amp; documentElement()-&gt;hasTagName(SVGNames::svgTag);
5608 }
5609 
</pre>
<hr />
<pre>
5642 Ref&lt;HTMLCollection&gt; Document::links()
5643 {
5644     return ensureCachedCollection&lt;DocLinks&gt;();
5645 }
5646 
5647 Ref&lt;HTMLCollection&gt; Document::forms()
5648 {
5649     return ensureCachedCollection&lt;DocForms&gt;();
5650 }
5651 
5652 Ref&lt;HTMLCollection&gt; Document::anchors()
5653 {
5654     return ensureCachedCollection&lt;DocAnchors&gt;();
5655 }
5656 
5657 Ref&lt;HTMLCollection&gt; Document::all()
5658 {
5659     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllCollection&gt;(*this, DocAll);
5660 }
5661 
<span class="line-modified">5662 Ref&lt;HTMLCollection&gt; Document::allFilteredByName(const AtomString&amp; name)</span>
5663 {
5664     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLAllNamedSubCollection&gt;(*this, DocumentAllNamedItems, name);
5665 }
5666 
<span class="line-modified">5667 Ref&lt;HTMLCollection&gt; Document::windowNamedItems(const AtomString&amp; name)</span>
5668 {
5669     return ensureRareData().ensureNodeLists().addCachedCollection&lt;WindowNameCollection&gt;(*this, WindowNamedItems, name);
5670 }
5671 
<span class="line-modified">5672 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)</span>
5673 {
5674     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5675 }
5676 
5677 void Document::finishedParsing()
5678 {
5679     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5680     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5681     setParsing(false);
5682 
5683     Ref&lt;Document&gt; protectedThis(*this);
5684 
5685     scriptRunner().documentFinishedParsing();
5686 
5687     if (!m_documentTiming.domContentLoadedEventStart)
5688         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5689 
<span class="line-modified">5690     if (!page() || !page()-&gt;isForSanitizingWebContent()) {</span>
<span class="line-modified">5691         // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-added">5692         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
<span class="line-added">5693     }</span>
5694 
5695     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5696 
5697     if (!m_documentTiming.domContentLoadedEventEnd)
5698         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5699 
5700     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5701 #if ENABLE(XSLT)
5702         applyPendingXSLTransformsNowIfScheduled();
5703 #endif
5704 
5705         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5706         // resource loads are complete. HTMLObjectElements can start loading their resources from
5707         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5708         // tag and then reach the end of the document without updating styles, we might not have yet
5709         // started the resource load and might fire the window load event too early. To avoid this
5710         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5711         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5712         updateStyleIfNeeded();
5713 
</pre>
<hr />
<pre>
5731     m_sharedObjectPool = nullptr;
5732     m_sharedObjectPoolClearTimer.stop();
5733 }
5734 
5735 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5736 
5737 // FIXME: Find a better place for this code.
5738 
5739 bool Document::isTelephoneNumberParsingEnabled() const
5740 {
5741     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5742 }
5743 
5744 bool Document::isTelephoneNumberParsingAllowed() const
5745 {
5746     return m_isTelephoneNumberParsingAllowed;
5747 }
5748 
5749 #endif
5750 
<span class="line-modified">5751 String Document::originIdentifierForPasteboard() const</span>
5752 {
5753     auto origin = securityOrigin().toString();
5754     if (origin != &quot;null&quot;)
5755         return origin;
5756     if (!m_uniqueIdentifier)
5757         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5758     return m_uniqueIdentifier;
5759 }
5760 
5761 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5762 {
5763     if (!m_xpathEvaluator)
5764         m_xpathEvaluator = XPathEvaluator::create();
5765     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5766 }
5767 
5768 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)
5769 {
5770     if (!m_xpathEvaluator)
5771         m_xpathEvaluator = XPathEvaluator::create();
</pre>
<hr />
<pre>
5774 
5775 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)
5776 {
5777     if (!m_xpathEvaluator)
5778         m_xpathEvaluator = XPathEvaluator::create();
5779     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5780 }
5781 
5782 void Document::initSecurityContext()
5783 {
5784     if (haveInitializedSecurityOrigin()) {
5785         ASSERT(SecurityContext::securityOrigin());
5786         return;
5787     }
5788 
5789     if (!m_frame) {
5790         // No source for a security context.
5791         // This can occur via document.implementation.createDocument().
5792         setCookieURL(URL({ }, emptyString()));
5793         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
<span class="line-modified">5794         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));</span>
5795         return;
5796     }
5797 
5798     // In the common case, create the security context from the currently
5799     // loading URL with a fresh content security policy.
5800     setCookieURL(m_url);
5801     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5802     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5803 
5804     if (shouldEnforceContentDispositionAttachmentSandbox())
5805         applyContentDispositionAttachmentSandbox();
5806 
5807     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5808     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5809     if (!isSecurityOriginUnique)
5810         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5811 
5812     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
<span class="line-modified">5813     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>















5814 
5815     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5816     if (!overrideContentSecurityPolicy.isNull())
5817         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5818 
5819 #if USE(QUICK_LOOK)
5820     if (shouldEnforceQuickLookSandbox())
5821         applyQuickLookSandbox();
5822 #endif
5823 
5824     if (shouldEnforceHTTP09Sandbox()) {
5825         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5826         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5827         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5828     }
5829 
5830     if (settings().needsStorageAccessFromFileURLsQuirk())
5831         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5832     if (!settings().webSecurityEnabled()) {
5833         // Web security is turned off. We should let this document access every other document. This is used primary by testing
</pre>
<hr />
<pre>
5910     Frame* openerFrame = m_frame-&gt;loader().opener();
5911     if (!openerFrame)
5912         return false;
5913     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());
5914 }
5915 
5916 void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)
5917 {
5918     // 1. Inherit Upgrade Insecure Requests
5919     Frame* parentFrame = m_frame-&gt;tree().parent();
5920     if (parentFrame)
5921         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
5922 
5923     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).
5924     if (!shouldInheritContentSecurityPolicy())
5925         return;
5926     ContentSecurityPolicy* ownerPolicy = nullptr;
5927     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))
5928         ownerPolicy = previousPolicy;
5929     if (!ownerPolicy) {
<span class="line-modified">5930         Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">5931         if (!ownerFrame)</span>
<span class="line-modified">5932             ownerFrame = m_frame-&gt;loader().opener();</span>
5933         if (ownerFrame)
5934             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();
5935     }
5936     if (!ownerPolicy)
5937         return;
5938     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin
5939     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,
5940     // file, data) should inherit a policy.
5941     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())
5942         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);
5943     else
5944         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);
5945 }
5946 
5947 bool Document::isContextThread() const
5948 {
5949     return isMainThread();
5950 }
5951 
5952 bool Document::isSecureContext() const
5953 {
5954     if (!m_frame)
5955         return true;
<span class="line-added">5956     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())</span>
<span class="line-added">5957         return true;</span>
5958     if (!securityOrigin().isPotentiallyTrustworthy())
5959         return false;
5960     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {
5961         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
5962             return false;
5963     }
5964     return true;
5965 }
5966 
5967 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
5968 {
5969     Frame* f = frame();
5970     if (!f)
5971         return;
5972 
5973     setURL(url);
5974     f-&gt;loader().setOutgoingReferrer(url);
5975 
5976     if (DocumentLoader* documentLoader = loader())
5977         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
</pre>
<hr />
<pre>
6005 
6006 Optional&lt;RenderingContext&gt; Document::getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height)
6007 {
6008     HTMLCanvasElement* element = getCSSCanvasElement(name);
6009     if (!element)
6010         return WTF::nullopt;
6011     element-&gt;setSize({ width, height });
6012     auto context = element-&gt;getContext(type);
6013     if (!context)
6014         return WTF::nullopt;
6015 
6016 #if ENABLE(WEBGL)
6017     if (is&lt;WebGLRenderingContext&gt;(*context))
6018         return RenderingContext { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
6019 #endif
6020 #if ENABLE(WEBGL2)
6021     if (is&lt;WebGL2RenderingContext&gt;(*context))
6022         return RenderingContext { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
6023 #endif
6024 #if ENABLE(WEBGPU)
<span class="line-modified">6025     if (is&lt;GPUCanvasContext&gt;(*context))</span>
<span class="line-modified">6026         return RenderingContext { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*context) } };</span>




6027 #endif
6028 
6029     return RenderingContext { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*context) } };
6030 }
6031 
6032 HTMLCanvasElement* Document::getCSSCanvasElement(const String&amp; name)
6033 {
6034     RefPtr&lt;HTMLCanvasElement&gt;&amp; element = m_cssCanvasElements.add(name, nullptr).iterator-&gt;value;
6035     if (!element)
6036         element = HTMLCanvasElement::create(*this);
6037     return element.get();
6038 }
6039 
6040 String Document::nameForCSSCanvasElement(const HTMLCanvasElement&amp; canvasElement) const
6041 {
6042     for (const auto&amp; entry : m_cssCanvasElements) {
6043         if (entry.value.get() == &amp;canvasElement)
6044             return entry.key;
6045     }
6046     return String();
6047 }
6048 
6049 #if ENABLE(TEXT_AUTOSIZING)
6050 TextAutoSizing&amp; Document::textAutoSizing()
6051 {
6052     if (!m_textAutoSizing)
<span class="line-modified">6053         m_textAutoSizing = makeUnique&lt;TextAutoSizing&gt;();</span>
6054     return *m_textAutoSizing;
6055 }
6056 #endif // ENABLE(TEXT_AUTOSIZING)
6057 
6058 void Document::initDNSPrefetch()
6059 {
6060     m_haveExplicitlyDisabledDNSPrefetch = false;
6061     m_isDNSPrefetchEnabled = settings().dnsPrefetchingEnabled() &amp;&amp; securityOrigin().protocol() == &quot;http&quot;;
6062 
6063     // Inherit DNS prefetch opt-out from parent frame
6064     if (Document* parent = parentDocument()) {
6065         if (!parent-&gt;isDNSPrefetchEnabled())
6066             m_isDNSPrefetchEnabled = false;
6067     }
6068 }
6069 
6070 void Document::parseDNSPrefetchControlHeader(const String&amp; dnsPrefetchControl)
6071 {
6072     if (!settings().dnsPrefetchingEnabled())
6073         return;
6074 
6075     if (equalLettersIgnoringASCIICase(dnsPrefetchControl, &quot;on&quot;) &amp;&amp; !m_haveExplicitlyDisabledDNSPrefetch) {
6076         m_isDNSPrefetchEnabled = true;
6077         return;
6078     }
6079 
6080     m_isDNSPrefetchEnabled = false;
6081     m_haveExplicitlyDisabledDNSPrefetch = true;
6082 }
6083 
<span class="line-added">6084 void Document::getParserLocation(String&amp; completedURL, unsigned&amp; line, unsigned&amp; column) const</span>
<span class="line-added">6085 {</span>
<span class="line-added">6086     // We definitely cannot associate the message with a location being parsed if we are not even parsing.</span>
<span class="line-added">6087     if (!parsing())</span>
<span class="line-added">6088         return;</span>
<span class="line-added">6089 </span>
<span class="line-added">6090     ScriptableDocumentParser* parser = scriptableDocumentParser();</span>
<span class="line-added">6091     if (!parser)</span>
<span class="line-added">6092         return;</span>
<span class="line-added">6093 </span>
<span class="line-added">6094     // When the parser waits for scripts, any messages must be coming from some other source, and are not related to the location of the script element that made the parser wait.</span>
<span class="line-added">6095     if (!parser-&gt;shouldAssociateConsoleMessagesWithTextPosition())</span>
<span class="line-added">6096         return;</span>
<span class="line-added">6097 </span>
<span class="line-added">6098     completedURL = url().string();</span>
<span class="line-added">6099     TextPosition position = parser-&gt;textPosition();</span>
<span class="line-added">6100     line = position.m_line.oneBasedInt();</span>
<span class="line-added">6101     column = position.m_column.oneBasedInt();</span>
<span class="line-added">6102 }</span>
<span class="line-added">6103 </span>
6104 void Document::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
6105 {
6106     if (!isContextThread()) {
6107         postTask(AddConsoleMessageTask(WTFMove(consoleMessage)));
6108         return;
6109     }
6110 
6111     if (Page* page = this-&gt;page())
6112         page-&gt;console().addMessage(WTFMove(consoleMessage));
6113 }
6114 
6115 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6116 {
6117     if (!isContextThread()) {
6118         postTask(AddConsoleMessageTask(source, level, message));
6119         return;
6120     }
6121 
6122     if (Page* page = this-&gt;page())
6123         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6124 
6125     if (m_consoleMessageListener)
6126         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6127 }
6128 
6129 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)
6130 {
6131     if (!isContextThread()) {
6132         postTask(AddConsoleMessageTask(source, level, message));
6133         return;
6134     }
6135 
6136     if (Page* page = this-&gt;page())
6137         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6138 }
6139 
6140 void Document::postTask(Task&amp;&amp; task)
6141 {
<span class="line-modified">6142     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {</span>
6143         ASSERT(isMainThread());
6144 
<span class="line-modified">6145         auto* document = allDocumentsMap().get(documentID);</span>
6146         if (!document)
6147             return;
6148 
6149         Page* page = document-&gt;page();
6150         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6151             document-&gt;m_pendingTasks.append(WTFMove(task));
6152         else
6153             task.performTask(*document);
6154     });
6155 }
6156 
6157 void Document::pendingTasksTimerFired()
6158 {
6159     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6160     for (auto&amp; task : pendingTasks)
6161         task.performTask(*this);
6162 }
6163 
6164 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6165 {
</pre>
<hr />
<pre>
6209         m_pendingTasksTimer.startOneShot(0_s);
6210     scriptRunner().resume();
6211     resumeActiveDOMObjects(reason);
6212     resumeScriptedAnimationControllerCallbacks();
6213 
6214     m_scheduledTasksAreSuspended = false;
6215 }
6216 
6217 void Document::suspendScriptedAnimationControllerCallbacks()
6218 {
6219     if (m_scriptedAnimationController)
6220         m_scriptedAnimationController-&gt;suspend();
6221 }
6222 
6223 void Document::resumeScriptedAnimationControllerCallbacks()
6224 {
6225     if (m_scriptedAnimationController)
6226         m_scriptedAnimationController-&gt;resume();
6227 }
6228 
<span class="line-modified">6229 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)</span>
6230 {
<span class="line-modified">6231     if (m_timeline)</span>
<span class="line-modified">6232         m_timeline-&gt;updateAnimationsAndSendEvents(timestamp);</span>
<span class="line-modified">6233 }</span>
<span class="line-modified">6234 </span>
<span class="line-added">6235 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)</span>
<span class="line-added">6236 {</span>
<span class="line-added">6237     if (m_scriptedAnimationController)</span>
<span class="line-added">6238         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);</span>
<span class="line-added">6239 }</span>
6240 
<span class="line-added">6241 void Document::windowScreenDidChange(PlatformDisplayID displayID)</span>
<span class="line-added">6242 {</span>
6243     if (RenderView* view = renderView()) {
6244         if (view-&gt;usesCompositing())
6245             view-&gt;compositor().windowScreenDidChange(displayID);
6246     }
6247 }
6248 
6249 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6250 {
6251     if (!m_decoder)
6252         return string;
6253     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6254 }
6255 
6256 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6257 {
6258     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6259     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6260 }
6261 
6262 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
</pre>
<hr />
<pre>
6294 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
6295 
6296 DeviceMotionController&amp; Document::deviceMotionController() const
6297 {
6298     return *m_deviceMotionController;
6299 }
6300 
6301 DeviceOrientationController&amp; Document::deviceOrientationController() const
6302 {
6303     return *m_deviceOrientationController;
6304 }
6305 
6306 void Document::simulateDeviceOrientationChange(double alpha, double beta, double gamma)
6307 {
6308     auto orientation = DeviceOrientationData::create(alpha, beta, gamma, WTF::nullopt, WTF::nullopt);
6309     deviceOrientationController().didChangeDeviceOrientation(orientation.ptr());
6310 }
6311 
6312 #endif
6313 
<span class="line-modified">6314 #if ENABLE(POINTER_LOCK)</span>
6315 
<span class="line-modified">6316 void Document::exitPointerLock()</span>
6317 {
<span class="line-modified">6318     Page* page = this-&gt;page();</span>
<span class="line-added">6319     if (!page)</span>
<span class="line-added">6320         return;</span>
<span class="line-added">6321     if (auto* target = page-&gt;pointerLockController().element()) {</span>
<span class="line-added">6322         if (&amp;target-&gt;document() != this)</span>
<span class="line-added">6323             return;</span>
<span class="line-added">6324     }</span>
<span class="line-added">6325     page-&gt;pointerLockController().requestPointerUnlock();</span>
6326 }
6327 
<span class="line-modified">6328 #endif</span>
<span class="line-added">6329 </span>
<span class="line-added">6330 void Document::decrementLoadEventDelayCount()</span>
6331 {
<span class="line-modified">6332     ASSERT(m_loadEventDelayCount);</span>
<span class="line-modified">6333     --m_loadEventDelayCount;</span>
6334 
<span class="line-modified">6335     if (frame() &amp;&amp; !m_loadEventDelayCount &amp;&amp; !m_loadEventDelayTimer.isActive())</span>
<span class="line-modified">6336         m_loadEventDelayTimer.startOneShot(0_s);</span>
<span class="line-modified">6337 }</span>



6338 
<span class="line-modified">6339 void Document::loadEventDelayTimerFired()</span>
<span class="line-modified">6340 {</span>
<span class="line-modified">6341     // FIXME: Should the call to FrameLoader::checkLoadComplete be moved inside Document::checkCompleted?</span>
<span class="line-added">6342     // FIXME: Should this also call DocumentLoader::checkLoadComplete?</span>
<span class="line-added">6343     // FIXME: Not obvious why checkCompleted needs to go first. The order these are called is</span>
<span class="line-added">6344     // visible to WebKit clients, but it&#39;s more like a race than a well-defined relationship.</span>
<span class="line-added">6345     Ref&lt;Document&gt; protectedThis(*this);</span>
<span class="line-added">6346     checkCompleted();</span>
<span class="line-added">6347     if (auto* frame = this-&gt;frame())</span>
<span class="line-added">6348         frame-&gt;loader().checkLoadComplete();</span>
<span class="line-added">6349 }</span>
6350 
<span class="line-modified">6351 void Document::checkCompleted()</span>
<span class="line-modified">6352 {</span>
<span class="line-modified">6353     if (auto* frame = this-&gt;frame())</span>
<span class="line-modified">6354         frame-&gt;loader().checkCompleted();</span>
<span class="line-modified">6355 }</span>



6356 
<span class="line-modified">6357 double Document::monotonicTimestamp() const</span>
<span class="line-modified">6358 {</span>
<span class="line-modified">6359     auto* loader = this-&gt;loader();</span>
<span class="line-modified">6360     if (!loader)</span>
<span class="line-modified">6361         return 0;</span>


6362 
<span class="line-modified">6363     return loader-&gt;timing().secondsSinceStartTime(MonotonicTime::now()).seconds();</span>
<span class="line-modified">6364 }</span>



6365 
<span class="line-modified">6366 int Document::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)</span>
<span class="line-modified">6367 {</span>
<span class="line-modified">6368     if (!m_scriptedAnimationController) {</span>
<span class="line-modified">6369         m_scriptedAnimationController = ScriptedAnimationController::create(*this);</span>

6370 
<span class="line-modified">6371         // It&#39;s possible that the Page may have suspended scripted animations before</span>
<span class="line-modified">6372         // we were created. We need to make sure that we don&#39;t start up the animation</span>
<span class="line-modified">6373         // controller on a background tab, for example.</span>
<span class="line-modified">6374         if (!page() || page()-&gt;scriptedAnimationsSuspended())</span>
<span class="line-modified">6375             m_scriptedAnimationController-&gt;suspend();</span>


























































































































































































































































































































































































































































































































6376 
6377         if (page() &amp;&amp; page()-&gt;isLowPowerModeEnabled())
6378             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::LowPowerMode);
6379 
6380         if (!topOrigin().canAccess(securityOrigin()) &amp;&amp; !hasHadUserInteraction())
6381             m_scriptedAnimationController-&gt;addThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6382     }
6383 
6384     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6385 }
6386 
6387 void Document::cancelAnimationFrame(int id)
6388 {
6389     if (!m_scriptedAnimationController)
6390         return;
6391     m_scriptedAnimationController-&gt;cancelCallback(id);
6392 }
6393 
6394 void Document::clearScriptedAnimationController()
6395 {
</pre>
<hr />
<pre>
6400 }
6401 
6402 void Document::wheelEventHandlersChanged()
6403 {
6404     Page* page = this-&gt;page();
6405     if (!page)
6406         return;
6407 
6408     if (FrameView* frameView = view()) {
6409         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6410             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6411     }
6412 
6413     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6414     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6415 }
6416 
6417 void Document::didAddWheelEventHandler(Node&amp; node)
6418 {
6419     if (!m_wheelEventTargets)
<span class="line-modified">6420         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();</span>
6421 
6422     m_wheelEventTargets-&gt;add(&amp;node);
6423 
6424     wheelEventHandlersChanged();
6425 
6426     if (Frame* frame = this-&gt;frame())
6427         DebugPageOverlays::didChangeEventHandlers(*frame);
6428 }
6429 
6430 HttpEquivPolicy Document::httpEquivPolicy() const
6431 {
6432     if (shouldEnforceContentDispositionAttachmentSandbox())
6433         return HttpEquivPolicy::DisabledByContentDispositionAttachmentSandbox;
6434     if (page() &amp;&amp; !page()-&gt;settings().httpEquivEnabled())
6435         return HttpEquivPolicy::DisabledBySettings;
6436     return HttpEquivPolicy::Enabled;
6437 }
6438 
6439 static bool removeHandlerFromSet(EventTargetSet&amp; handlerSet, Node&amp; node, EventHandlerRemoval removal)
6440 {
</pre>
<hr />
<pre>
6460     if (Frame* frame = this-&gt;frame())
6461         DebugPageOverlays::didChangeEventHandlers(*frame);
6462 }
6463 
6464 unsigned Document::wheelEventHandlerCount() const
6465 {
6466     if (!m_wheelEventTargets)
6467         return 0;
6468 
6469     unsigned count = 0;
6470     for (auto&amp; handler : *m_wheelEventTargets)
6471         count += handler.value;
6472 
6473     return count;
6474 }
6475 
6476 void Document::didAddTouchEventHandler(Node&amp; handler)
6477 {
6478 #if ENABLE(TOUCH_EVENTS)
6479     if (!m_touchEventTargets)
<span class="line-modified">6480         m_touchEventTargets = makeUnique&lt;EventTargetSet&gt;();</span>
6481 
6482     m_touchEventTargets-&gt;add(&amp;handler);
6483 
6484     if (Document* parent = parentDocument()) {
6485         parent-&gt;didAddTouchEventHandler(*this);
6486         return;
6487     }
6488 #else
6489     UNUSED_PARAM(handler);
6490 #endif
6491 }
6492 
6493 void Document::didRemoveTouchEventHandler(Node&amp; handler, EventHandlerRemoval removal)
6494 {
6495 #if ENABLE(TOUCH_EVENTS)
6496     if (!m_touchEventTargets)
6497         return;
6498 
6499     removeHandlerFromSet(*m_touchEventTargets, handler, removal);
6500 
</pre>
<hr />
<pre>
6601 {
6602     m_lastHandledUserGestureTimestamp = time;
6603 
6604     if (static_cast&lt;bool&gt;(time) &amp;&amp; m_scriptedAnimationController) {
6605         // It&#39;s OK to always remove NonInteractedCrossOriginFrame even if this frame isn&#39;t cross-origin.
6606         m_scriptedAnimationController-&gt;removeThrottlingReason(ScriptedAnimationController::ThrottlingReason::NonInteractedCrossOriginFrame);
6607     }
6608 
6609     // DOM Timer alignment may depend on the user having interacted with the document.
6610     didChangeTimerAlignmentInterval();
6611 
6612     if (HTMLFrameOwnerElement* element = ownerElement())
6613         element-&gt;document().updateLastHandledUserGestureTimestamp(time);
6614 }
6615 
6616 bool Document::processingUserGestureForMedia() const
6617 {
6618     if (UserGestureIndicator::processingUserGestureForMedia())
6619         return true;
6620 
<span class="line-added">6621     if (m_userActivatedMediaFinishedPlayingTimestamp + maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying &gt;= MonotonicTime::now())</span>
<span class="line-added">6622         return true;</span>
<span class="line-added">6623 </span>
6624     if (settings().mediaUserGestureInheritsFromDocument())
6625         return topDocument().hasHadUserInteraction();
6626 
6627     auto* loader = this-&gt;loader();
6628     if (loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::InheritedUserGestures))
6629         return topDocument().hasHadUserInteraction();
6630 
6631     return false;
6632 }
6633 
6634 void Document::startTrackingStyleRecalcs()
6635 {
6636     m_styleRecalcCount = 0;
6637 }
6638 
6639 unsigned Document::styleRecalcCount() const
6640 {
6641     return m_styleRecalcCount;
6642 }
6643 
</pre>
<hr />
<pre>
6769 
6770 static Element* findNearestCommonComposedAncestor(Element* elementA, Element* elementB)
6771 {
6772     if (!elementA || !elementB)
6773         return nullptr;
6774 
6775     if (elementA == elementB)
6776         return elementA;
6777 
6778     HashSet&lt;Element*&gt; ancestorChain;
6779     for (auto* element = elementA; element; element = element-&gt;parentElementInComposedTree())
6780         ancestorChain.add(element);
6781 
6782     for (auto* element = elementB; element; element = element-&gt;parentElementInComposedTree()) {
6783         if (ancestorChain.contains(element))
6784             return element;
6785     }
6786     return nullptr;
6787 }
6788 
<span class="line-modified">6789 void Document::updateHoverActiveState(const HitTestRequest&amp; request, Element* innerElement, CaptureChange captureElementChanged)</span>
6790 {
6791     ASSERT(!request.readOnly());
6792 
6793     Element* innerElementInDocument = innerElement;
6794     while (innerElementInDocument &amp;&amp; &amp;innerElementInDocument-&gt;document() != this) {
6795         innerElementInDocument-&gt;document().updateHoverActiveState(request, innerElementInDocument);
6796         innerElementInDocument = innerElementInDocument-&gt;document().ownerElement();
6797     }
6798 
6799     Element* oldActiveElement = m_activeElement.get();
6800     if (oldActiveElement &amp;&amp; !request.active()) {
6801         // We are clearing the :active chain because the mouse has been released.
6802         for (Element* currentElement = oldActiveElement; currentElement; currentElement = currentElement-&gt;parentElementInComposedTree()) {
6803             currentElement-&gt;setActive(false);
6804             m_userActionElements.setInActiveChain(*currentElement, false);
6805         }
6806         m_activeElement = nullptr;
6807     } else {
6808         Element* newActiveElement = innerElementInDocument;
6809         if (!oldActiveElement &amp;&amp; newActiveElement &amp;&amp; request.active() &amp;&amp; !request.touchMove()) {
6810             // We are setting the :active chain and freezing it. If future moves happen, they
6811             // will need to reference this chain.
6812             for (RenderElement* curr = newActiveElement-&gt;renderer(); curr; curr = curr-&gt;parent()) {
6813                 Element* element = curr-&gt;element();
6814                 if (!element || curr-&gt;isTextOrLineBreak())
6815                     continue;
6816                 m_userActionElements.setInActiveChain(*element, true);
6817             }
6818 
6819             m_activeElement = newActiveElement;
6820         }
6821     }
6822     // If the mouse has just been pressed, set :active on the chain. Those (and only those)
6823     // nodes should remain :active until the mouse is released.
6824     bool allowActiveChanges = !oldActiveElement &amp;&amp; m_activeElement;
6825 
6826     // If the mouse is down and if this is a mouse move event, we want to restrict changes in
6827     // :hover/:active to only apply to elements that are in the :active chain that we froze
<span class="line-modified">6828     // at the time the mouse went down, unless the capture element changed.</span>
<span class="line-modified">6829     bool mustBeInActiveChain = request.active() &amp;&amp; request.move() &amp;&amp; captureElementChanged == CaptureChange::No;</span>
6830 
6831     RefPtr&lt;Element&gt; oldHoveredElement = WTFMove(m_hoveredElement);
6832 
6833     // A touch release does not set a new hover target; clearing the element we&#39;re working with
6834     // will clear the chain of hovered elements all the way to the top of the tree.
6835     if (request.touchRelease())
6836         innerElementInDocument = nullptr;
6837 
6838     // Check to see if the hovered Element has changed.
6839     // If it hasn&#39;t, we do not need to do anything.
6840     Element* newHoveredElement = innerElementInDocument;
6841     while (newHoveredElement &amp;&amp; !newHoveredElement-&gt;renderer())
6842         newHoveredElement = newHoveredElement-&gt;parentElementInComposedTree();
6843 
6844     m_hoveredElement = newHoveredElement;
6845 
6846     auto* commonAncestor = findNearestCommonComposedAncestor(oldHoveredElement.get(), newHoveredElement);
6847 
6848     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToRemoveFromChain;
6849     Vector&lt;RefPtr&lt;Element&gt;, 32&gt; elementsToAddToChain;
</pre>
<hr />
<pre>
6871         element-&gt;setHovered(false);
6872 
6873     bool sawCommonAncestor = false;
6874     for (auto&amp; element : elementsToAddToChain) {
6875         if (allowActiveChanges)
6876             element-&gt;setActive(true);
6877         if (element == commonAncestor)
6878             sawCommonAncestor = true;
6879         if (!sawCommonAncestor) {
6880             // Elements after the common hover ancestor does not change hover state, but are iterated over because they may change active state.
6881             element-&gt;setHovered(true);
6882         }
6883     }
6884 }
6885 
6886 bool Document::haveStylesheetsLoaded() const
6887 {
6888     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
6889 }
6890 
<span class="line-modified">6891 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)</span>
6892 {
<span class="line-modified">6893     AtomString localeKey = locale;</span>
6894     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
6895         localeKey = defaultLanguage();
6896     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
6897     if (result.isNewEntry)
6898         result.iterator-&gt;value = Locale::create(localeKey);
6899     return *(result.iterator-&gt;value);
6900 }
6901 
6902 Document&amp; Document::ensureTemplateDocument()
6903 {
6904     if (const Document* document = templateDocument())
6905         return const_cast&lt;Document&amp;&gt;(*document);
6906 
6907     if (isHTMLDocument())
<span class="line-modified">6908         m_templateDocument = HTMLDocument::create(sessionID(), nullptr, WTF::blankURL());</span>
6909     else
<span class="line-modified">6910         m_templateDocument = create(sessionID(), WTF::blankURL());</span>
6911 
6912     m_templateDocument-&gt;setContextDocument(contextDocument());
6913     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
6914 
6915     return *m_templateDocument;
6916 }
6917 
6918 Ref&lt;FontFaceSet&gt; Document::fonts()
6919 {
6920     updateStyleIfNeeded();
6921     return fontSelector().fontFaceSet();
6922 }
6923 
<span class="line-added">6924 EditingBehavior Document::editingBehavior() const</span>
<span class="line-added">6925 {</span>
<span class="line-added">6926     return EditingBehavior { settings().editingBehaviorType() };</span>
<span class="line-added">6927 }</span>
<span class="line-added">6928 </span>
6929 float Document::deviceScaleFactor() const
6930 {
6931     float deviceScaleFactor = 1.0;
6932     if (Page* documentPage = page())
6933         deviceScaleFactor = documentPage-&gt;deviceScaleFactor();
6934     return deviceScaleFactor;
6935 }
6936 
6937 bool Document::useSystemAppearance() const
6938 {
<span class="line-modified">6939     if (auto* documentPage = page())</span>
<span class="line-modified">6940         return documentPage-&gt;useSystemAppearance();</span>
<span class="line-modified">6941     return false;</span>

6942 }
6943 
6944 bool Document::useDarkAppearance(const RenderStyle* style) const
6945 {

6946 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">6947     OptionSet&lt;ColorScheme&gt; colorScheme;</span>
6948 
6949     // Use the style&#39;s supported color schemes, if supplied.
6950     if (style)
<span class="line-modified">6951         colorScheme = style-&gt;colorScheme().colorScheme();</span>
6952 
6953     // Fallback to the document&#39;s supported color schemes if style was empty (auto).
<span class="line-modified">6954     if (colorScheme.isEmpty())</span>
<span class="line-modified">6955         colorScheme = m_colorScheme;</span>
6956 
<span class="line-modified">6957     if (colorScheme.contains(ColorScheme::Dark) &amp;&amp; !colorScheme.contains(ColorScheme::Light))</span>
6958         return true;
6959 #else
6960     UNUSED_PARAM(style);
6961 #endif
6962 
6963     bool pageUsesDarkAppearance = false;
6964     if (Page* documentPage = page())
6965         pageUsesDarkAppearance = documentPage-&gt;useDarkAppearance();
6966 
6967     if (useSystemAppearance())
6968         return pageUsesDarkAppearance;
6969 
6970 #if ENABLE(DARK_MODE_CSS)
<span class="line-modified">6971     if (colorScheme.contains(ColorScheme::Dark))</span>
6972         return pageUsesDarkAppearance;
6973 #endif



6974 
6975     return false;
6976 }
6977 
<span class="line-added">6978 bool Document::useElevatedUserInterfaceLevel() const</span>
<span class="line-added">6979 {</span>
<span class="line-added">6980     if (auto* documentPage = page())</span>
<span class="line-added">6981         return documentPage-&gt;useElevatedUserInterfaceLevel();</span>
<span class="line-added">6982     return false;</span>
<span class="line-added">6983 }</span>
<span class="line-added">6984 </span>
6985 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
6986 {
6987     OptionSet&lt;StyleColor::Options&gt; options;
6988     if (useSystemAppearance())
6989         options.add(StyleColor::Options::UseSystemAppearance);
6990     if (useDarkAppearance(style))
6991         options.add(StyleColor::Options::UseDarkAppearance);
<span class="line-added">6992     if (useElevatedUserInterfaceLevel())</span>
<span class="line-added">6993         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);</span>
6994     return options;
6995 }
6996 
<span class="line-added">6997 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const</span>
<span class="line-added">6998 {</span>
<span class="line-added">6999     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))</span>
<span class="line-added">7000         return CompositeSourceOver;</span>
<span class="line-added">7001 </span>
<span class="line-added">7002     auto* frameView = view();</span>
<span class="line-added">7003     if (!frameView)</span>
<span class="line-added">7004         return CompositeSourceOver;</span>
<span class="line-added">7005 </span>
<span class="line-added">7006     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to</span>
<span class="line-added">7007     // use different composite modes to get the right results in this case.</span>
<span class="line-added">7008     return frameView-&gt;isTransparent() ? CompositeDestinationOut : CompositeDestinationIn;</span>
<span class="line-added">7009 }</span>
<span class="line-added">7010 </span>
7011 void Document::didAssociateFormControl(Element&amp; element)
7012 {
7013     auto* page = this-&gt;page();
7014     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7015         return;
7016     m_associatedFormControls.add(&amp;element);
7017     if (!m_didAssociateFormControlsTimer.isActive())
7018         m_didAssociateFormControlsTimer.startOneShot(0_s);
7019 }
7020 
7021 void Document::didAssociateFormControlsTimerFired()
7022 {
7023     auto vector = copyToVector(m_associatedFormControls);
7024     m_associatedFormControls.clear();
<span class="line-modified">7025     if (auto* page = this-&gt;page()) {</span>
<span class="line-modified">7026         ASSERT(m_frame);</span>
<span class="line-added">7027         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);</span>
<span class="line-added">7028     }</span>
7029 }
7030 
7031 void Document::setCachedDOMCookies(const String&amp; cookies)
7032 {
7033     ASSERT(!isDOMCookieCacheValid());
7034     m_cachedDOMCookies = cookies;
7035     // The cookie cache is valid at most until we go back to the event loop.
7036     m_cookieCacheExpiryTimer.startOneShot(0_s);
7037 }
7038 
7039 void Document::invalidateDOMCookieCache()
7040 {
7041     m_cookieCacheExpiryTimer.stop();
7042     m_cachedDOMCookies = String();
7043 }
7044 
7045 void Document::didLoadResourceSynchronously()
7046 {
7047     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7048     // in this case, to be safe.
7049     invalidateDOMCookieCache();
7050 }
7051 
7052 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7053 {
7054     if (m_hasInjectedPlugInsScript)
7055         return;
7056 
<span class="line-added">7057     auto&amp; scriptController = frame()-&gt;script();</span>
<span class="line-added">7058 </span>
7059     // Use the JS file provided by the Chrome client, or fallback to the default one.
7060     String jsString = page()-&gt;chrome().client().plugInExtraScript();
<span class="line-modified">7061     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))</span>
7062         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7063 
<span class="line-modified">7064     setHasEvaluatedUserAgentScripts();</span>
<span class="line-added">7065     scriptController.evaluateInWorld(ScriptSourceCode(jsString), world);</span>
7066 
7067     m_hasInjectedPlugInsScript = true;
7068 }
7069 
7070 #if ENABLE(WEB_CRYPTO)
7071 
7072 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7073 {
7074     Page* page = this-&gt;page();
7075     if (!page)
7076         return false;
7077     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7078 }
7079 
7080 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7081 {
7082     Page* page = this-&gt;page();
7083     if (!page)
7084         return false;
7085     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
</pre>
<hr />
<pre>
7222 
7223 bool Document::shouldEnforceHTTP09Sandbox() const
7224 {
7225     if (m_isSynthesized || !m_frame)
7226         return false;
7227     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7228     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7229 }
7230 
7231 #if USE(QUICK_LOOK)
7232 bool Document::shouldEnforceQuickLookSandbox() const
7233 {
7234     if (m_isSynthesized || !m_frame)
7235         return false;
7236     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7237     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7238 }
7239 
7240 void Document::applyQuickLookSandbox()
7241 {
<span class="line-modified">7242     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();</span>
<span class="line-added">7243     auto documentURL = documentLoader.documentURL();</span>
<span class="line-added">7244     auto&amp; responseURL = documentLoader.responseURL();</span>
<span class="line-added">7245     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));</span>
7246     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7247 
<span class="line-modified">7248     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());</span>
7249     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7250     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7251 
7252     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7253     RELEASE_ASSERT(contentSecurityPolicy());
7254     // The sandbox directive is only allowed if the policy is from an HTTP header.
7255     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7256 
7257     disableSandboxFlags(SandboxNavigation);
7258 
7259     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7260 }
7261 #endif
7262 
7263 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7264 {
7265     if (!settings().contentDispositionAttachmentSandboxEnabled())
7266         return false;
7267 
7268     if (m_isSynthesized)
</pre>
<hr />
<pre>
7287 void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)
7288 {
7289     m_viewportDependentPictures.add(&amp;picture);
7290 }
7291 
7292 void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)
7293 {
7294     m_viewportDependentPictures.remove(&amp;picture);
7295 }
7296 
7297 void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7298 {
7299     m_appearanceDependentPictures.add(&amp;picture);
7300 }
7301 
7302 void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)
7303 {
7304     m_appearanceDependentPictures.remove(&amp;picture);
7305 }
7306 
<span class="line-added">7307 void Document::scheduleTimedRenderingUpdate()</span>
<span class="line-added">7308 {</span>
<span class="line-added">7309 #if ENABLE(INTERSECTION_OBSERVER)</span>
<span class="line-added">7310     m_intersectionObserversInitialUpdateTimer.stop();</span>
<span class="line-added">7311 #endif</span>
<span class="line-added">7312     if (auto page = this-&gt;page())</span>
<span class="line-added">7313         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();</span>
<span class="line-added">7314 }</span>
<span class="line-added">7315 </span>
7316 #if ENABLE(INTERSECTION_OBSERVER)
7317 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7318 {
7319     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7320     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7321 }
7322 
7323 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7324 {
7325     m_intersectionObservers.removeFirst(&amp;observer);
7326 }
7327 
7328 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7329 {
7330     FloatBoxExtent rootMarginFloatBox(
7331         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7332         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7333         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7334         floatValueForLength(rootMargin.left(), localRootBounds.width())
7335     );
</pre>
<hr />
<pre>
7385 
7386         if (rootRenderer-&gt;hasOverflowClip())
7387             localRootBounds = rootRenderer-&gt;contentBoxRect();
7388         else
7389             localRootBounds = { FloatPoint(), rootRenderer-&gt;size() };
7390     } else {
7391         ASSERT(frameView.frame().isMainFrame());
7392         // FIXME: Handle the case of an implicit-root observer that has a target in a different frame tree.
7393         if (&amp;targetRenderer-&gt;frame().mainFrame() != &amp;frameView.frame())
7394             return WTF::nullopt;
7395         rootRenderer = frameView.renderView();
7396         localRootBounds = frameView.layoutViewportRect();
7397     }
7398 
7399     if (applyRootMargin)
7400         expandRootBoundsWithRootMargin(localRootBounds, observer.rootMarginBox());
7401 
7402     LayoutRect localTargetBounds;
7403     if (is&lt;RenderBox&gt;(*targetRenderer))
7404         localTargetBounds = downcast&lt;RenderBox&gt;(targetRenderer)-&gt;borderBoundingBox();
<span class="line-modified">7405     else if (is&lt;RenderInline&gt;(targetRenderer)) {</span>
<span class="line-modified">7406         auto pair = target.boundingAbsoluteRectWithoutLayout();</span>
<span class="line-modified">7407         if (pair) {</span>
<span class="line-added">7408             FloatRect absoluteTargetBounds = pair-&gt;second;</span>
<span class="line-added">7409             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());</span>
<span class="line-added">7410         }</span>
<span class="line-added">7411     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))</span>
7412         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7413 
7414     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7415     if (observer.root()) {
7416         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7417         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7418     } else
7419         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7420 
7421     FloatRect rootLocalIntersectionRect = localRootBounds;
7422 
7423     IntersectionObservationState intersectionState;
7424     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
7425 
7426     if (intersectionState.isIntersecting) {
7427         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7428         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7429             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7430         else {
7431             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7432             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7433         }
7434     }
7435 
7436     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();
7437     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();
7438     return intersectionState;
7439 }
7440 
7441 void Document::updateIntersectionObservations()
7442 {
7443     auto* frameView = view();
7444     if (!frameView)
7445         return;
7446 
<span class="line-added">7447     m_intersectionObserversInitialUpdateTimer.stop();</span>
<span class="line-added">7448 </span>
7449     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7450     if (needsLayout || hasPendingStyleRecalc())
7451         return;
7452 


7453     for (const auto&amp; observer : m_intersectionObservers) {
7454         bool needNotify = false;
7455         DOMHighResTimeStamp timestamp;
7456         if (!observer-&gt;createTimestamp(timestamp))
7457             continue;
7458         for (Element* target : observer-&gt;observationTargets()) {
7459             auto&amp; targetRegistrations = target-&gt;intersectionObserverData()-&gt;registrations;
7460             auto index = targetRegistrations.findMatching([observer](auto&amp; registration) {
7461                 return registration.observer.get() == observer;
7462             });
7463             ASSERT(index != notFound);
7464             auto&amp; registration = targetRegistrations[index];
7465 
7466             bool isSameOriginObservation = &amp;target-&gt;document() == this || target-&gt;document().securityOrigin().canAccess(securityOrigin());
7467             auto intersectionState = computeIntersectionState(*frameView, *observer, *target, isSameOriginObservation);
7468 
7469             float intersectionRatio = 0;
7470             size_t thresholdIndex = 0;
7471             if (intersectionState) {
7472                 if (intersectionState-&gt;isIntersecting) {
</pre>
<hr />
<pre>
7509                     timestamp,
7510                     reportedRootBounds,
7511                     { targetBoundingClientRect.x(), targetBoundingClientRect.y(), targetBoundingClientRect.width(), targetBoundingClientRect.height() },
7512                     { clientIntersectionRect.x(), clientIntersectionRect.y(), clientIntersectionRect.width(), clientIntersectionRect.height() },
7513                     intersectionRatio,
7514                     target,
7515                     thresholdIndex &gt; 0,
7516                 }));
7517                 needNotify = true;
7518                 registration.previousThresholdIndex = thresholdIndex;
7519             }
7520         }
7521         if (needNotify)
7522             m_intersectionObserversWithPendingNotifications.append(makeWeakPtr(observer.get()));
7523     }
7524 
7525     if (m_intersectionObserversWithPendingNotifications.size())
7526         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7527 }
7528 











7529 void Document::notifyIntersectionObserversTimerFired()
7530 {
7531     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7532         if (observer)
7533             observer-&gt;notify();
7534     }
7535     m_intersectionObserversWithPendingNotifications.clear();
7536 }
<span class="line-added">7537 </span>
<span class="line-added">7538 void Document::scheduleInitialIntersectionObservationUpdate()</span>
<span class="line-added">7539 {</span>
<span class="line-added">7540     if (m_readyState == Complete)</span>
<span class="line-added">7541         scheduleTimedRenderingUpdate();</span>
<span class="line-added">7542     else if (!m_intersectionObserversInitialUpdateTimer.isActive())</span>
<span class="line-added">7543         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);</span>
<span class="line-added">7544 }</span>
7545 #endif
7546 
<span class="line-modified">7547 #if ENABLE(RESIZE_OBSERVER)</span>
<span class="line-added">7548 void Document::addResizeObserver(ResizeObserver&amp; observer)</span>
<span class="line-added">7549 {</span>
<span class="line-added">7550     if (!m_resizeObservers.contains(&amp;observer))</span>
<span class="line-added">7551         m_resizeObservers.append(makeWeakPtr(&amp;observer));</span>
<span class="line-added">7552 }</span>
<span class="line-added">7553 </span>
<span class="line-added">7554 void Document::removeResizeObserver(ResizeObserver&amp; observer)</span>
<span class="line-added">7555 {</span>
<span class="line-added">7556     m_resizeObservers.removeFirst(&amp;observer);</span>
<span class="line-added">7557 }</span>
<span class="line-added">7558 </span>
<span class="line-added">7559 bool Document::hasResizeObservers()</span>
<span class="line-added">7560 {</span>
<span class="line-added">7561     return !m_resizeObservers.isEmpty();</span>
<span class="line-added">7562 }</span>
<span class="line-added">7563 </span>
<span class="line-added">7564 size_t Document::gatherResizeObservations(size_t deeperThan)</span>
<span class="line-added">7565 {</span>
<span class="line-added">7566     size_t minDepth = ResizeObserver::maxElementDepth();</span>
<span class="line-added">7567     for (const auto&amp; observer : m_resizeObservers) {</span>
<span class="line-added">7568         if (!observer-&gt;hasObservations())</span>
<span class="line-added">7569             continue;</span>
<span class="line-added">7570         auto depth = observer-&gt;gatherObservations(deeperThan);</span>
<span class="line-added">7571         minDepth = std::min(minDepth, depth);</span>
<span class="line-added">7572     }</span>
<span class="line-added">7573     return minDepth;</span>
<span class="line-added">7574 }</span>
<span class="line-added">7575 </span>
<span class="line-added">7576 void Document::deliverResizeObservations()</span>
<span class="line-added">7577 {</span>
<span class="line-added">7578     auto observersToNotify = m_resizeObservers;</span>
<span class="line-added">7579     for (const auto&amp; observer : observersToNotify) {</span>
<span class="line-added">7580         if (!observer || !observer-&gt;hasActiveObservations())</span>
<span class="line-added">7581             continue;</span>
<span class="line-added">7582         observer-&gt;deliverObservations();</span>
<span class="line-added">7583     }</span>
<span class="line-added">7584 }</span>
<span class="line-added">7585 </span>
<span class="line-added">7586 bool Document::hasSkippedResizeObservations() const</span>
<span class="line-added">7587 {</span>
<span class="line-added">7588     for (const auto&amp; observer : m_resizeObservers) {</span>
<span class="line-added">7589         if (observer-&gt;hasSkippedObservations())</span>
<span class="line-added">7590             return true;</span>
<span class="line-added">7591     }</span>
<span class="line-added">7592     return false;</span>
<span class="line-added">7593 }</span>
<span class="line-added">7594 </span>
<span class="line-added">7595 void Document::setHasSkippedResizeObservations(bool skipped)</span>
<span class="line-added">7596 {</span>
<span class="line-added">7597     for (const auto&amp; observer : m_resizeObservers)</span>
<span class="line-added">7598         observer-&gt;setHasSkippedObservations(skipped);</span>
<span class="line-added">7599 }</span>
<span class="line-added">7600 </span>
<span class="line-added">7601 void Document::updateResizeObservations(Page&amp; page)</span>
<span class="line-added">7602 {</span>
<span class="line-added">7603     if (!hasResizeObservers())</span>
<span class="line-added">7604         return;</span>
<span class="line-added">7605 </span>
<span class="line-added">7606     // We need layout the whole frame tree here. Because ResizeObserver could observe element in other frame,</span>
<span class="line-added">7607     // and it could change other frame in deliverResizeObservations().</span>
<span class="line-added">7608     page.layoutIfNeeded();</span>
<span class="line-added">7609 </span>
<span class="line-added">7610     // Start check resize obervers;</span>
<span class="line-added">7611     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {</span>
<span class="line-added">7612         deliverResizeObservations();</span>
<span class="line-added">7613         page.layoutIfNeeded();</span>
<span class="line-added">7614     }</span>
<span class="line-added">7615 </span>
<span class="line-added">7616     if (hasSkippedResizeObservations()) {</span>
<span class="line-added">7617         setHasSkippedResizeObservations(false);</span>
<span class="line-added">7618         String url;</span>
<span class="line-added">7619         unsigned line = 0;</span>
<span class="line-added">7620         unsigned column = 0;</span>
<span class="line-added">7621         getParserLocation(url, line, column);</span>
<span class="line-added">7622         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);</span>
<span class="line-added">7623         // Starting a new schedule the next round of notify.</span>
<span class="line-added">7624         scheduleTimedRenderingUpdate();</span>
<span class="line-added">7625     }</span>
<span class="line-added">7626 }</span>
<span class="line-added">7627 #endif</span>
<span class="line-added">7628 </span>
<span class="line-added">7629 const AtomString&amp; Document::dir() const</span>
7630 {
7631     auto* documentElement = this-&gt;documentElement();
7632     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7633         return nullAtom();
7634     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7635 }
7636 
<span class="line-modified">7637 void Document::setDir(const AtomString&amp; value)</span>
7638 {
7639     auto* documentElement = this-&gt;documentElement();
7640     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7641         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7642 }
7643 
7644 DOMSelection* Document::getSelection()
7645 {
7646     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
7647 }
7648 
7649 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7650 {
7651     ASSERT(shadowRoot.isConnected());
7652     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7653     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7654 }
7655 
7656 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7657 {
7658     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7659     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7660 }
7661 
7662 void Document::orientationChanged(int orientation)
7663 {
7664     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7665     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7666     m_orientationNotifier.orientationChanged(orientation);
7667 }
7668 
7669 void Document::notifyMediaCaptureOfVisibilityChanged()
7670 {
7671 #if ENABLE(MEDIA_STREAM)
7672     if (!page())
7673         return;
7674 
<span class="line-modified">7675     RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
7676 #endif
7677 }
7678 
7679 #if ENABLE(MEDIA_STREAM)
7680 void Document::stopMediaCapture()
7681 {
<span class="line-modified">7682     MediaStreamTrack::endCapture(*this);</span>



7683 }
7684 
7685 void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
7686 {
7687     m_mediaStreamStateChangeElements.add(&amp;element);
7688 }
7689 
7690 void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)
7691 {
7692     m_mediaStreamStateChangeElements.remove(&amp;element);
7693 }
7694 
7695 void Document::mediaStreamCaptureStateChanged()
7696 {
7697     if (!MediaProducer::isCapturing(m_mediaState))
7698         return;
7699 
7700     for (auto* mediaElement : m_mediaStreamStateChangeElements)
7701         mediaElement-&gt;mediaStreamCaptureStarted();
7702 }
</pre>
<hr />
<pre>
7708 }
7709 
7710 #endif
7711 
7712 void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
7713 {
7714     m_applicationStateChangeListeners.add(&amp;listener);
7715 }
7716 
7717 void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)
7718 {
7719     m_applicationStateChangeListeners.remove(&amp;listener);
7720 }
7721 
7722 void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)
7723 {
7724     for (auto* listener : m_applicationStateChangeListeners)
7725         functor(*listener);
7726 }
7727 
<span class="line-modified">7728 const AtomString&amp; Document::bgColor() const</span>
7729 {
7730     auto* bodyElement = body();
7731     if (!bodyElement)
7732         return emptyAtom();
7733     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7734 }
7735 
7736 void Document::setBgColor(const String&amp; value)
7737 {
7738     if (auto* bodyElement = body())
7739         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7740 }
7741 
<span class="line-modified">7742 const AtomString&amp; Document::fgColor() const</span>
7743 {
7744     auto* bodyElement = body();
7745     if (!bodyElement)
7746         return emptyAtom();
7747     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
7748 }
7749 
7750 void Document::setFgColor(const String&amp; value)
7751 {
7752     if (auto* bodyElement = body())
7753         bodyElement-&gt;setAttributeWithoutSynchronization(textAttr, value);
7754 }
7755 
<span class="line-modified">7756 const AtomString&amp; Document::alinkColor() const</span>
7757 {
7758     auto* bodyElement = body();
7759     if (!bodyElement)
7760         return emptyAtom();
7761     return bodyElement-&gt;attributeWithoutSynchronization(alinkAttr);
7762 }
7763 
7764 void Document::setAlinkColor(const String&amp; value)
7765 {
7766     if (auto* bodyElement = body())
7767         bodyElement-&gt;setAttributeWithoutSynchronization(alinkAttr, value);
7768 }
7769 
<span class="line-modified">7770 const AtomString&amp; Document::linkColorForBindings() const</span>
7771 {
7772     auto* bodyElement = body();
7773     if (!bodyElement)
7774         return emptyAtom();
7775     return bodyElement-&gt;attributeWithoutSynchronization(linkAttr);
7776 }
7777 
7778 void Document::setLinkColorForBindings(const String&amp; value)
7779 {
7780     if (auto* bodyElement = body())
7781         bodyElement-&gt;setAttributeWithoutSynchronization(linkAttr, value);
7782 }
7783 
<span class="line-modified">7784 const AtomString&amp; Document::vlinkColor() const</span>
7785 {
7786     auto* bodyElement = body();
7787     if (!bodyElement)
7788         return emptyAtom();
7789     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7790 }
7791 
7792 void Document::setVlinkColor(const String&amp; value)
7793 {
7794     if (auto* bodyElement = body())
7795         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7796 }
7797 
7798 Logger&amp; Document::logger()
7799 {
7800     if (!m_logger) {
7801         m_logger = Logger::create(this);
7802         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());
7803         m_logger-&gt;addObserver(*this);
7804     }
7805 
7806     return *m_logger;
7807 }
7808 
<span class="line-modified">7809 Optional&lt;PageIdentifier&gt; Document::pageID() const</span>
7810 {
7811     return m_frame-&gt;loader().client().pageID();
7812 }
7813 













































































































































7814 void Document::registerArticleElement(Element&amp; article)
7815 {
7816     m_articleElements.add(&amp;article);
7817 }
7818 
7819 void Document::unregisterArticleElement(Element&amp; article)
7820 {
7821     m_articleElements.remove(&amp;article);
7822     if (m_mainArticleElement == &amp;article)
7823         m_mainArticleElement = nullptr;
7824 }
7825 
7826 void Document::updateMainArticleElementAfterLayout()
7827 {
7828     ASSERT(page() &amp;&amp; page()-&gt;requestedLayoutMilestones().contains(DidRenderSignificantAmountOfText));
7829 
7830     // If there are too many article elements on the page, don&#39;t consider any one of them to be &quot;main content&quot;.
7831     const unsigned maxNumberOfArticlesBeforeIgnoringMainContentArticle = 10;
7832 
7833     // We consider an article to be main content if it is either:
</pre>
<hr />
<pre>
7861 
7862     if (numberOfArticles == 1) {
7863         m_mainArticleElement = tallestArticle;
7864         return;
7865     }
7866 
7867     if (tallestArticleHeight &lt; minimumSecondTallestArticleHeightFactor * secondTallestArticleHeight)
7868         return;
7869 
7870     if (!view())
7871         return;
7872 
7873     auto viewportSize = view()-&gt;layoutViewportRect().size();
7874     if (tallestArticleWidth * tallestArticleHeight &lt; minimumViewportAreaFactor * (viewportSize.width() * viewportSize.height()).toFloat())
7875         return;
7876 
7877     m_mainArticleElement = tallestArticle;
7878 }
7879 
7880 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">7881 bool Document::hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)</span>
7882 {
<span class="line-modified">7883     return m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction == domain;</span>
7884 }
7885 
<span class="line-modified">7886 void Document::setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp; domain)</span>
7887 {
<span class="line-modified">7888     m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction = domain;</span>

7889 }
7890 
<span class="line-modified">7891 void Document::wasLoadedWithDataTransferFromPrevalentResource()</span>
7892 {
<span class="line-modified">7893     downgradeReferrerToRegistrableDomain();</span>
7894 }
7895 
<span class="line-modified">7896 void Document::downgradeReferrerToRegistrableDomain()</span>
7897 {
<span class="line-modified">7898     auto referrerStr = referrer();</span>
<span class="line-added">7899     if (referrerStr.isEmpty())</span>
<span class="line-added">7900         return;</span>
<span class="line-added">7901 </span>
<span class="line-added">7902     URL referrerURL { URL(), referrerStr };</span>
<span class="line-added">7903     auto referrerPort = referrerURL.port();</span>
<span class="line-added">7904     RegistrableDomain referrerRegistrableDomain { referrerURL };</span>
<span class="line-added">7905     auto referrerRegistrableDomainStr = referrerRegistrableDomain.string();</span>
<span class="line-added">7906     if (referrerRegistrableDomainStr.isEmpty())</span>
<span class="line-added">7907         return;</span>
<span class="line-added">7908 </span>
<span class="line-added">7909     StringBuilder builder;</span>
<span class="line-added">7910     builder.append(referrerURL.protocol());</span>
<span class="line-added">7911     builder.appendLiteral(&quot;://&quot;);</span>
<span class="line-added">7912     builder.append(referrerRegistrableDomainStr);</span>
<span class="line-added">7913     if (referrerPort) {</span>
<span class="line-added">7914         builder.append(&#39;:&#39;);</span>
<span class="line-added">7915         builder.appendNumber(*referrerPort);</span>
<span class="line-added">7916     }</span>
<span class="line-added">7917     builder.append(&#39;/&#39;);</span>
<span class="line-added">7918 </span>
<span class="line-added">7919     m_referrerOverride = builder.toString();</span>
7920 }
7921 #endif
7922 
7923 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
7924 {
7925     m_consoleMessageListener = listener;
7926 }
7927 










7928 DocumentTimeline&amp; Document::timeline()
7929 {
7930     if (!m_timeline)
7931         m_timeline = DocumentTimeline::create(*this);
7932 
7933     return *m_timeline;
7934 }
7935 
7936 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
7937 {
7938     // For the list of animations to be current, we need to account for any pending CSS changes,
7939     // such as updates to CSS Animations and CSS Transitions.
7940     updateStyleIfNeeded();
7941 
7942     if (m_timeline)
7943         return m_timeline-&gt;getAnimations();
7944     return { };
7945 }
7946 
7947 #if ENABLE(ATTACHMENT_ELEMENT)
</pre>
<hr />
<pre>
7978     if (!identifier)
7979         return;
7980 
7981     m_attachmentIdentifierToElementMap.remove(identifier);
7982 
7983     if (frame())
7984         frame()-&gt;editor().didRemoveAttachmentElement(attachment);
7985 }
7986 
7987 RefPtr&lt;HTMLAttachmentElement&gt; Document::attachmentForIdentifier(const String&amp; identifier) const
7988 {
7989     return m_attachmentIdentifierToElementMap.get(identifier);
7990 }
7991 
7992 #endif // ENABLE(ATTACHMENT_ELEMENT)
7993 
7994 static MessageSource messageSourceForWTFLogChannel(const WTFLogChannel&amp; channel)
7995 {
7996     static const NeverDestroyed&lt;String&gt; mediaChannel = MAKE_STATIC_STRING_IMPL(&quot;media&quot;);
7997     static const NeverDestroyed&lt;String&gt; webrtcChannel = MAKE_STATIC_STRING_IMPL(&quot;webrtc&quot;);
<span class="line-added">7998     static const NeverDestroyed&lt;String&gt; mediaSourceChannel = MAKE_STATIC_STRING_IMPL(&quot;mediasource&quot;);</span>
7999 
8000     if (equalIgnoringASCIICase(mediaChannel, channel.name))
8001         return MessageSource::Media;
8002 
8003     if (equalIgnoringASCIICase(webrtcChannel, channel.name))
8004         return MessageSource::WebRTC;
8005 
<span class="line-added">8006     if (equalIgnoringASCIICase(mediaSourceChannel, channel.name))</span>
<span class="line-added">8007         return MessageSource::MediaSource;</span>
<span class="line-added">8008 </span>
8009     return MessageSource::Other;
8010 }
8011 
8012 static MessageLevel messageLevelFromWTFLogLevel(WTFLogLevel level)
8013 {
8014     switch (level) {
<span class="line-modified">8015     case WTFLogLevel::Always:</span>
8016         return MessageLevel::Log;
<span class="line-modified">8017     case WTFLogLevel::Error:</span>
8018         return MessageLevel::Error;
8019         break;
<span class="line-modified">8020     case WTFLogLevel::Warning:</span>
8021         return MessageLevel::Warning;
8022         break;
<span class="line-modified">8023     case WTFLogLevel::Info:</span>
8024         return MessageLevel::Info;
8025         break;
<span class="line-modified">8026     case WTFLogLevel::Debug:</span>
8027         return MessageLevel::Debug;
8028         break;
8029     }
8030 
8031     ASSERT_NOT_REACHED();
8032     return MessageLevel::Log;
8033 }
8034 
<span class="line-added">8035 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)</span>
<span class="line-added">8036 {</span>
<span class="line-added">8037     auto values = WTFMove(source);</span>
<span class="line-added">8038     for (auto&amp; value : values)</span>
<span class="line-added">8039         value.value = crossThreadCopy(WTFMove(value.value));</span>
<span class="line-added">8040     return values;</span>
<span class="line-added">8041 }</span>
<span class="line-added">8042 </span>
8043 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8044 {
<span class="line-added">8045     if (!isMainThread()) {</span>
<span class="line-added">8046         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {</span>
<span class="line-added">8047             didLogMessage(channel, level, WTFMove(logMessages));</span>
<span class="line-added">8048         });</span>
<span class="line-added">8049         return;</span>
<span class="line-added">8050     }</span>
8051     if (!page())
8052         return;
8053 
8054     ASSERT(sessionID().isAlwaysOnLoggingAllowed());
8055 
8056     auto messageSource = messageSourceForWTFLogChannel(channel);
8057     if (messageSource == MessageSource::Other)
8058         return;
8059 
8060     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
8061         if (!page())
8062             return;
8063 
8064         auto messageLevel = messageLevelFromWTFLogLevel(level);
<span class="line-modified">8065         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));</span>
8066 
8067         addConsoleMessage(WTFMove(message));
8068     });
8069 }
8070 
8071 #if ENABLE(SERVICE_WORKER)
8072 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8073 {
8074     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8075         return;
8076 
8077     if (m_serviceWorkerConnection)
8078         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8079 
8080     m_serviceWorkerConnection = serviceWorkerConnection;
8081 
8082     if (!m_serviceWorkerConnection)
8083         return;
8084 
8085     auto controllingServiceWorkerRegistrationIdentifier = activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;
8086     m_serviceWorkerConnection-&gt;registerServiceWorkerClient(topOrigin(), ServiceWorkerClientData::from(*this, *serviceWorkerConnection), controllingServiceWorkerRegistrationIdentifier, userAgent(url()));
8087 }
8088 #endif
8089 
8090 String Document::signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp; url)
8091 {
8092     Page* page = this-&gt;page();
8093     if (!page)
8094         return emptyString();
8095     return page-&gt;chrome().client().signedPublicKeyAndChallengeString(keySizeIndex, challengeString, url);
8096 }
8097 
8098 bool Document::registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp; prop)
8099 {
<span class="line-modified">8100     return m_CSSRegisteredPropertySet.add(prop.name, makeUnique&lt;CSSRegisteredCustomProperty&gt;(WTFMove(prop))).isNewEntry;</span>
8101 }
8102 
8103 void Document::detachFromFrame()
8104 {
<span class="line-added">8105     // Assertion to help pinpint rdar://problem/49877867. If this hits, the crash trace should tell us</span>
<span class="line-added">8106     // which piece of code is detaching the document from its frame while constructing the CachedFrames.</span>
<span class="line-added">8107     RELEASE_ASSERT(m_mayBeDetachedFromFrame);</span>
<span class="line-added">8108 </span>
8109     observeFrame(nullptr);
8110 }
8111 
8112 void Document::frameWasDisconnectedFromOwner()
8113 {
8114     if (!frame())
8115         return;
8116 
8117     if (auto* window = domWindow())
8118         window-&gt;willDetachDocumentFromFrame();
8119 
8120     detachFromFrame();
8121 }
8122 
8123 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8124 {
8125     return hitTest(request, result.hitTestLocation(), result);
8126 }
8127 
8128 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
</pre>
<hr />
<pre>
8142     FrameFlatteningLayoutDisallower disallower(frameView);
8143 
8144     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8145 
8146     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8147     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8148     // will always work so we need to check the ScrollView scrollbars in that case too.
8149     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8150         // FIXME: Consider if this test should be done unconditionally.
8151         if (request.allowsFrameScrollbars()) {
8152             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8153             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8154                 result.setScrollbar(frameScrollbar);
8155                 return true;
8156             }
8157         }
8158     }
8159     return resultLayer;
8160 }
8161 
<span class="line-added">8162 ElementIdentifier Document::identifierForElement(Element&amp; element)</span>
<span class="line-added">8163 {</span>
<span class="line-added">8164     ASSERT(&amp;element.document() == this);</span>
<span class="line-added">8165     auto result = m_identifiedElementsMap.ensure(&amp;element, [&amp;] {</span>
<span class="line-added">8166         return element.createElementIdentifier();</span>
<span class="line-added">8167     });</span>
<span class="line-added">8168     return result.iterator-&gt;value;</span>
<span class="line-added">8169 }</span>
<span class="line-added">8170 </span>
<span class="line-added">8171 Element* Document::searchForElementByIdentifier(const ElementIdentifier&amp; identifier)</span>
<span class="line-added">8172 {</span>
<span class="line-added">8173     for (auto it = m_identifiedElementsMap.begin(); it != m_identifiedElementsMap.end(); ++it) {</span>
<span class="line-added">8174         if (it-&gt;value == identifier)</span>
<span class="line-added">8175             return it-&gt;key;</span>
<span class="line-added">8176     }</span>
<span class="line-added">8177 </span>
<span class="line-added">8178     return nullptr;</span>
<span class="line-added">8179 }</span>
<span class="line-added">8180 </span>
<span class="line-added">8181 void Document::identifiedElementWasRemovedFromDocument(Element&amp; element)</span>
<span class="line-added">8182 {</span>
<span class="line-added">8183     m_identifiedElementsMap.remove(&amp;element);</span>
<span class="line-added">8184 }</span>
<span class="line-added">8185 </span>
<span class="line-added">8186 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-added">8187 </span>
<span class="line-added">8188 DeviceOrientationAndMotionAccessController&amp; Document::deviceOrientationAndMotionAccessController()</span>
<span class="line-added">8189 {</span>
<span class="line-added">8190     if (&amp;topDocument() != this)</span>
<span class="line-added">8191         return topDocument().deviceOrientationAndMotionAccessController();</span>
<span class="line-added">8192 </span>
<span class="line-added">8193     if (!m_deviceOrientationAndMotionAccessController)</span>
<span class="line-added">8194         m_deviceOrientationAndMotionAccessController = makeUnique&lt;DeviceOrientationAndMotionAccessController&gt;(*this);</span>
<span class="line-added">8195     return *m_deviceOrientationAndMotionAccessController;</span>
<span class="line-added">8196 }</span>
<span class="line-added">8197 </span>
<span class="line-added">8198 #endif</span>
<span class="line-added">8199 </span>
8200 #if ENABLE(CSS_PAINTING_API)
8201 Worklet&amp; Document::ensurePaintWorklet()
8202 {
8203     if (!m_paintWorklet)
8204         m_paintWorklet = Worklet::create();
8205     return *m_paintWorklet;
8206 }
8207 
8208 PaintWorkletGlobalScope* Document::paintWorkletGlobalScopeForName(const String&amp; name)
8209 {
8210     return m_paintWorkletGlobalScopes.get(name);
8211 }
8212 
8213 void Document::setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp; scope)
8214 {
8215     auto addResult = m_paintWorkletGlobalScopes.add(name, WTFMove(scope));
8216     ASSERT_UNUSED(addResult, addResult);
8217 }
8218 #endif
8219 
<span class="line-modified">8220 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">8221 </span>
<span class="line-added">8222 ContentChangeObserver&amp; Document::contentChangeObserver()</span>
8223 {
<span class="line-modified">8224     if (!m_contentChangeObserver)</span>
<span class="line-added">8225         m_contentChangeObserver = makeUnique&lt;ContentChangeObserver&gt;(*this);</span>
<span class="line-added">8226     return *m_contentChangeObserver;</span>
<span class="line-added">8227 }</span>
8228 
<span class="line-modified">8229 DOMTimerHoldingTank&amp; Document::domTimerHoldingTank()</span>
<span class="line-modified">8230 {</span>
<span class="line-modified">8231     if (m_domTimerHoldingTank)</span>
<span class="line-modified">8232         return *m_domTimerHoldingTank;</span>
<span class="line-modified">8233     m_domTimerHoldingTank = makeUnique&lt;DOMTimerHoldingTank&gt;();</span>
<span class="line-modified">8234     return *m_domTimerHoldingTank;</span>
<span class="line-added">8235 }</span>
8236 
<span class="line-modified">8237 #endif</span>


8238 
<span class="line-modified">8239 bool Document::hasEvaluatedUserAgentScripts() const</span>
<span class="line-modified">8240 {</span>
<span class="line-modified">8241     auto&amp; top = topDocument();</span>
<span class="line-added">8242     return this == &amp;top ? m_hasEvaluatedUserAgentScripts : top.hasEvaluatedUserAgentScripts();</span>
<span class="line-added">8243 }</span>
8244 
<span class="line-modified">8245 bool Document::isRunningUserScripts() const</span>
<span class="line-modified">8246 {</span>
<span class="line-modified">8247     auto&amp; top = topDocument();</span>
<span class="line-modified">8248     return this == &amp;top ? m_isRunningUserScripts : top.isRunningUserScripts();</span>
<span class="line-modified">8249 }</span>
<span class="line-added">8250 </span>
<span class="line-added">8251 void Document::setAsRunningUserScripts()</span>
<span class="line-added">8252 {</span>
<span class="line-added">8253     auto&amp; top = topDocument();</span>
<span class="line-added">8254     if (this == &amp;top)</span>
<span class="line-added">8255         m_isRunningUserScripts = true;</span>
<span class="line-added">8256     else</span>
<span class="line-added">8257         top.setAsRunningUserScripts();</span>
<span class="line-added">8258 }</span>
<span class="line-added">8259 </span>
<span class="line-added">8260 void Document::setHasEvaluatedUserAgentScripts()</span>
<span class="line-added">8261 {</span>
<span class="line-added">8262     auto&amp; top = topDocument();</span>
<span class="line-added">8263     if (this == &amp;top)</span>
<span class="line-added">8264         m_hasEvaluatedUserAgentScripts = true;</span>
<span class="line-added">8265     else</span>
<span class="line-added">8266         top.setHasEvaluatedUserAgentScripts();</span>
8267 }
<span class="line-added">8268 </span>
<span class="line-added">8269 #if ENABLE(APPLE_PAY)</span>
<span class="line-added">8270 </span>
<span class="line-added">8271 bool Document::isApplePayActive() const</span>
<span class="line-added">8272 {</span>
<span class="line-added">8273     auto&amp; top = topDocument();</span>
<span class="line-added">8274     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();</span>
<span class="line-added">8275 }</span>
<span class="line-added">8276 </span>
<span class="line-added">8277 void Document::setApplePayIsActive()</span>
<span class="line-added">8278 {</span>
<span class="line-added">8279     auto&amp; top = topDocument();</span>
<span class="line-added">8280     if (this == &amp;top)</span>
<span class="line-added">8281         m_hasStartedApplePaySession = true;</span>
<span class="line-added">8282     else</span>
<span class="line-added">8283         top.setApplePayIsActive();</span>
<span class="line-added">8284 }</span>
<span class="line-added">8285 </span>
8286 #endif
8287 
8288 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DeviceOrientationEvent.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>