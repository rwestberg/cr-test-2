<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #pragma once
  30 
  31 #include &quot;CallData.h&quot;
  32 #include &quot;CodeSpecializationKind.h&quot;
  33 #include &quot;CompleteSubspace.h&quot;
  34 #include &quot;ConcurrentJSLock.h&quot;
  35 #include &quot;ControlFlowProfiler.h&quot;
  36 #include &quot;DateInstanceCache.h&quot;
  37 #include &quot;DeleteAllCodeEffort.h&quot;
  38 #include &quot;ExceptionEventLocation.h&quot;
  39 #include &quot;ExecutableAllocator.h&quot;
  40 #include &quot;FunctionHasExecutedCache.h&quot;
<a name="1" id="anc1"></a>
  41 #include &quot;Heap.h&quot;
  42 #include &quot;Intrinsic.h&quot;
  43 #include &quot;IsoCellSet.h&quot;
  44 #include &quot;IsoSubspace.h&quot;
  45 #include &quot;JITThunks.h&quot;
  46 #include &quot;JSCJSValue.h&quot;
  47 #include &quot;JSLock.h&quot;
  48 #include &quot;MacroAssemblerCodeRef.h&quot;
  49 #include &quot;Microtask.h&quot;
  50 #include &quot;NumericStrings.h&quot;
  51 #include &quot;SmallStrings.h&quot;
  52 #include &quot;Strong.h&quot;
  53 #include &quot;StructureCache.h&quot;
  54 #include &quot;SubspaceAccess.h&quot;
  55 #include &quot;VMTraps.h&quot;
  56 #include &quot;WasmContext.h&quot;
  57 #include &quot;Watchpoint.h&quot;
  58 #include &lt;wtf/BumpPointerAllocator.h&gt;
  59 #include &lt;wtf/CheckedArithmetic.h&gt;
  60 #include &lt;wtf/DateMath.h&gt;
  61 #include &lt;wtf/Deque.h&gt;
  62 #include &lt;wtf/DoublyLinkedList.h&gt;
  63 #include &lt;wtf/Forward.h&gt;
  64 #include &lt;wtf/Gigacage.h&gt;
  65 #include &lt;wtf/HashMap.h&gt;
  66 #include &lt;wtf/HashSet.h&gt;
  67 #include &lt;wtf/SetForScope.h&gt;
  68 #include &lt;wtf/StackBounds.h&gt;
  69 #include &lt;wtf/StackPointer.h&gt;
  70 #include &lt;wtf/Stopwatch.h&gt;
  71 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  72 #include &lt;wtf/ThreadSpecific.h&gt;
  73 #include &lt;wtf/UniqueArray.h&gt;
  74 #include &lt;wtf/text/SymbolRegistry.h&gt;
  75 #include &lt;wtf/text/WTFString.h&gt;
  76 #if ENABLE(REGEXP_TRACING)
  77 #include &lt;wtf/ListHashSet.h&gt;
  78 #endif
  79 
  80 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
  81 #include &lt;wtf/StackTrace.h&gt;
  82 #endif
  83 
  84 // Enable the Objective-C API for platforms with a modern runtime. This has to match exactly what we
  85 // have in JSBase.h.
  86 #if !defined(JSC_OBJC_API_ENABLED)
  87 #if (defined(__clang__) &amp;&amp; defined(__APPLE__) &amp;&amp; ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; !defined(__i386__)) || (defined(TARGET_OS_IPHONE) &amp;&amp; TARGET_OS_IPHONE)))
  88 #define JSC_OBJC_API_ENABLED 1
  89 #else
  90 #define JSC_OBJC_API_ENABLED 0
  91 #endif
  92 #endif
  93 
  94 namespace WTF {
  95 class SimpleStats;
  96 } // namespace WTF
  97 using WTF::SimpleStats;
  98 
  99 namespace JSC {
 100 
 101 class BuiltinExecutables;
 102 class BytecodeIntrinsicRegistry;
 103 class CodeBlock;
 104 class CodeCache;
 105 class CommonIdentifiers;
 106 class CompactVariableMap;
 107 class CustomGetterSetter;
 108 class DOMAttributeGetterSetter;
 109 class ExecState;
 110 class Exception;
 111 class ExceptionScope;
 112 class FastMallocAlignedMemoryAllocator;
 113 class GigacageAlignedMemoryAllocator;
 114 class HandleStack;
 115 class TypeProfiler;
 116 class TypeProfilerLog;
 117 class HasOwnPropertyCache;
 118 class HeapProfiler;
 119 class Identifier;
 120 class Interpreter;
 121 class JSCustomGetterSetterFunction;
 122 class JSDestructibleObjectHeapCellType;
 123 class JSGlobalObject;
 124 class JSObject;
<a name="2" id="anc2"></a>

 125 class JSRunLoopTimer;
<a name="3" id="anc3"></a><span class="line-removed"> 126 class JSSegmentedVariableObjectHeapCellType;</span>
 127 class JSStringHeapCellType;
 128 class JSWebAssemblyCodeBlockHeapCellType;
 129 class JSWebAssemblyInstance;
 130 class LLIntOffsetsExtractor;
 131 class NativeExecutable;
 132 class PromiseDeferredTimer;
 133 class RegExp;
 134 class RegExpCache;
 135 class Register;
 136 class RegisterAtOffsetList;
 137 #if ENABLE(SAMPLING_PROFILER)
 138 class SamplingProfiler;
 139 #endif
 140 class ShadowChicken;
 141 class ScriptExecutable;
 142 class SourceProvider;
 143 class SourceProviderCache;
 144 class StackFrame;
 145 class Structure;
 146 #if ENABLE(REGEXP_TRACING)
 147 class RegExp;
 148 #endif
 149 class Symbol;
 150 class TypedArrayController;
 151 class UnlinkedCodeBlock;
 152 class UnlinkedEvalCodeBlock;
 153 class UnlinkedFunctionExecutable;
 154 class UnlinkedProgramCodeBlock;
 155 class UnlinkedModuleProgramCodeBlock;
 156 class VirtualRegister;
 157 class VMEntryScope;
 158 class Watchdog;
 159 class Watchpoint;
 160 class WatchpointSet;
<a name="4" id="anc4"></a>
 161 
 162 #if ENABLE(FTL_JIT)
 163 namespace FTL {
 164 class Thunks;
 165 }
 166 #endif // ENABLE(FTL_JIT)
 167 namespace Profiler {
 168 class Database;
 169 }
 170 namespace DOMJIT {
 171 class Signature;
 172 }
 173 
 174 struct EntryFrame;
 175 struct HashTable;
 176 struct Instruction;
 177 struct ValueProfile;
 178 
 179 typedef ExecState CallFrame;
 180 
 181 struct LocalTimeOffsetCache {
 182     LocalTimeOffsetCache()
 183         : start(0.0)
 184         , end(-1.0)
 185         , increment(0.0)
<a name="5" id="anc5"></a><span class="line-removed"> 186         , timeType(WTF::UTCTime)</span>
 187     {
 188     }
 189 
 190     void reset()
 191     {
 192         offset = LocalTimeOffset();
 193         start = 0.0;
 194         end = -1.0;
 195         increment = 0.0;
<a name="6" id="anc6"></a><span class="line-removed"> 196         timeType = WTF::UTCTime;</span>
 197     }
 198 
 199     LocalTimeOffset offset;
 200     double start;
 201     double end;
 202     double increment;
<a name="7" id="anc7"></a><span class="line-removed"> 203     WTF::TimeType timeType;</span>
 204 };
 205 
 206 class QueuedTask {
 207     WTF_MAKE_NONCOPYABLE(QueuedTask);
 208     WTF_MAKE_FAST_ALLOCATED;
 209 public:
 210     void run();
 211 
 212     QueuedTask(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Microtask&gt;&amp;&amp; microtask)
 213         : m_globalObject(vm, globalObject)
 214         , m_microtask(WTFMove(microtask))
 215     {
 216     }
 217 
 218 private:
 219     Strong&lt;JSGlobalObject&gt; m_globalObject;
 220     Ref&lt;Microtask&gt; m_microtask;
 221 };
 222 
 223 class ConservativeRoots;
 224 
 225 #if COMPILER(MSVC)
 226 #pragma warning(push)
 227 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
 228 #endif
 229 struct ScratchBuffer {
 230     ScratchBuffer()
 231     {
 232         u.m_activeLength = 0;
 233     }
 234 
 235     static ScratchBuffer* create(size_t size)
 236     {
 237         ScratchBuffer* result = new (fastMalloc(ScratchBuffer::allocationSize(size))) ScratchBuffer;
 238 
 239         return result;
 240     }
 241 
 242     static size_t allocationSize(Checked&lt;size_t&gt; bufferSize) { return (sizeof(ScratchBuffer) + bufferSize).unsafeGet(); }
 243     void setActiveLength(size_t activeLength) { u.m_activeLength = activeLength; }
 244     size_t activeLength() const { return u.m_activeLength; };
 245     size_t* addressOfActiveLength() { return &amp;u.m_activeLength; };
 246     void* dataBuffer() { return m_buffer; }
 247 
 248     union {
 249         size_t m_activeLength;
 250         double pad; // Make sure m_buffer is double aligned.
 251     } u;
 252 #if CPU(MIPS) &amp;&amp; (defined WTF_MIPS_ARCH_REV &amp;&amp; WTF_MIPS_ARCH_REV == 2)
 253     alignas(8) void* m_buffer[0];
 254 #else
 255     void* m_buffer[0];
 256 #endif
 257 };
 258 #if COMPILER(MSVC)
 259 #pragma warning(pop)
 260 #endif
 261 
 262 class VM : public ThreadSafeRefCounted&lt;VM&gt;, public DoublyLinkedListNode&lt;VM&gt; {
 263 public:
 264     // WebCore has a one-to-one mapping of threads to VMs;
 265     // create() should only be called once
 266     // on a thread, this is the &#39;default&#39; VM (it uses the
 267     // thread&#39;s default string uniquing table from Thread::current()).
 268     // API contexts created using the new context group aware interface
 269     // create APIContextGroup objects which require less locking of JSC
 270     // than the old singleton APIShared VM created for use by
 271     // the original API.
 272     enum VMType { Default, APIContextGroup, APIShared };
 273 
 274     struct ClientData {
 275         JS_EXPORT_PRIVATE virtual ~ClientData() = 0;
 276     };
 277 
 278     bool isSharedInstance() { return vmType == APIShared; }
 279     bool usingAPI() { return vmType != Default; }
 280     JS_EXPORT_PRIVATE static bool sharedInstanceExists();
 281     JS_EXPORT_PRIVATE static VM&amp; sharedInstance();
 282 
 283     JS_EXPORT_PRIVATE static Ref&lt;VM&gt; create(HeapType = SmallHeap);
 284     static Ref&lt;VM&gt; createContextGroup(HeapType = SmallHeap);
 285     JS_EXPORT_PRIVATE ~VM();
 286 
 287     Watchdog&amp; ensureWatchdog();
 288     Watchdog* watchdog() { return m_watchdog.get(); }
 289 
 290     HeapProfiler* heapProfiler() const { return m_heapProfiler.get(); }
 291     JS_EXPORT_PRIVATE HeapProfiler&amp; ensureHeapProfiler();
 292 
 293 #if ENABLE(SAMPLING_PROFILER)
 294     SamplingProfiler* samplingProfiler() { return m_samplingProfiler.get(); }
 295     JS_EXPORT_PRIVATE SamplingProfiler&amp; ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp;);
 296 #endif
 297 
<a name="8" id="anc8"></a>





 298     static unsigned numberOfIDs() { return s_numberOfIDs.load(); }
 299     unsigned id() const { return m_id; }
 300     bool isEntered() const { return !!entryScope; }
 301 
 302     inline CallFrame* topJSCallFrame() const;
 303 
 304     // Global object in which execution began.
 305     JS_EXPORT_PRIVATE JSGlobalObject* vmEntryGlobalObject(const CallFrame*) const;
 306 
 307 private:
 308     unsigned nextID();
 309 
 310     static Atomic&lt;unsigned&gt; s_numberOfIDs;
 311 
 312     unsigned m_id;
 313     RefPtr&lt;JSLock&gt; m_apiLock;
 314 #if USE(CF)
 315     // These need to be initialized before heap below.
 316     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
 317 #endif
 318 
 319 public:
 320     Heap heap;
 321 
 322     std::unique_ptr&lt;FastMallocAlignedMemoryAllocator&gt; fastMallocAllocator;
 323     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; primitiveGigacageAllocator;
 324     std::unique_ptr&lt;GigacageAlignedMemoryAllocator&gt; jsValueGigacageAllocator;
 325 
 326     std::unique_ptr&lt;HeapCellType&gt; auxiliaryHeapCellType;
 327     std::unique_ptr&lt;HeapCellType&gt; immutableButterflyHeapCellType;
 328     std::unique_ptr&lt;HeapCellType&gt; cellHeapCellType;
 329     std::unique_ptr&lt;HeapCellType&gt; destructibleCellHeapCellType;
 330     std::unique_ptr&lt;JSStringHeapCellType&gt; stringHeapCellType;
 331     std::unique_ptr&lt;JSDestructibleObjectHeapCellType&gt; destructibleObjectHeapCellType;
<a name="9" id="anc9"></a><span class="line-removed"> 332     std::unique_ptr&lt;JSSegmentedVariableObjectHeapCellType&gt; segmentedVariableObjectHeapCellType;</span>
 333 #if ENABLE(WEBASSEMBLY)
 334     std::unique_ptr&lt;JSWebAssemblyCodeBlockHeapCellType&gt; webAssemblyCodeBlockHeapCellType;
<a name="10" id="anc10"></a>
 335 #endif
 336 
 337     CompleteSubspace primitiveGigacageAuxiliarySpace; // Typed arrays, strings, bitvectors, etc go here.
 338     CompleteSubspace jsValueGigacageAuxiliarySpace; // Butterflies, arrays of JSValues, etc go here.
 339     CompleteSubspace immutableButterflyJSValueGigacageAuxiliarySpace; // JSImmutableButterfly goes here.
 340 
 341     // We make cross-cutting assumptions about typed arrays being in the primitive Gigacage and butterflies
 342     // being in the JSValue gigacage. For some types, it&#39;s super obvious where they should go, and so we
 343     // can hardcode that fact. But sometimes it&#39;s not clear, so we abstract it by having a Gigacage::Kind
 344     // constant somewhere.
 345     // FIXME: Maybe it would be better if everyone abstracted this?
 346     // https://bugs.webkit.org/show_bug.cgi?id=175248
 347     ALWAYS_INLINE CompleteSubspace&amp; gigacageAuxiliarySpace(Gigacage::Kind kind)
 348     {
 349         switch (kind) {
 350         case Gigacage::ReservedForFlagsAndNotABasePtr:
 351             RELEASE_ASSERT_NOT_REACHED();
 352         case Gigacage::Primitive:
 353             return primitiveGigacageAuxiliarySpace;
 354         case Gigacage::JSValue:
 355             return jsValueGigacageAuxiliarySpace;
 356         }
 357         RELEASE_ASSERT_NOT_REACHED();
 358         return primitiveGigacageAuxiliarySpace;
 359     }
 360 
 361     // Whenever possible, use subspaceFor&lt;CellType&gt;(vm) to get one of these subspaces.
 362     CompleteSubspace cellSpace;
 363     CompleteSubspace jsValueGigacageCellSpace; // FIXME: This space is problematic because we have things in here like DirectArguments and ScopedArguments; those should be split into JSValueOOB cells and JSValueStrict auxiliaries. https://bugs.webkit.org/show_bug.cgi?id=182858
 364     CompleteSubspace destructibleCellSpace;
 365     CompleteSubspace stringSpace;
 366     CompleteSubspace destructibleObjectSpace;
 367     CompleteSubspace eagerlySweptDestructibleObjectSpace;
<a name="11" id="anc11"></a><span class="line-removed"> 368     CompleteSubspace segmentedVariableObjectSpace;</span>
 369 
 370     IsoSubspace executableToCodeBlockEdgeSpace;
 371     IsoSubspace functionSpace;
 372     IsoSubspace internalFunctionSpace;
 373     IsoSubspace nativeExecutableSpace;
 374     IsoSubspace propertyTableSpace;
 375     IsoSubspace structureRareDataSpace;
 376     IsoSubspace structureSpace;
<a name="12" id="anc12"></a>
 377 
 378 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(name) \
 379     template&lt;SubspaceAccess mode&gt; \
 380     IsoSubspace* name() \
 381     { \
 382         if (m_##name || mode == SubspaceAccess::Concurrently) \
 383             return m_##name.get(); \
 384         return name##Slow(); \
 385     } \
 386     IsoSubspace* name##Slow(); \
 387     std::unique_ptr&lt;IsoSubspace&gt; m_##name;
 388 
 389 
 390 #if JSC_OBJC_API_ENABLED
 391     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(objCCallbackFunctionSpace)
 392 #endif
 393     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(boundFunctionSpace)
 394     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(callbackFunctionSpace)
 395     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(customGetterSetterFunctionSpace)
 396     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(errorInstanceSpace)
 397     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(nativeStdFunctionSpace)
 398     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(proxyRevokeSpace)
<a name="13" id="anc13"></a>
 399     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakSetSpace)
 400     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(weakMapSpace)
 401 #if ENABLE(WEBASSEMBLY)
 402     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyCodeBlockSpace)
 403     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyFunctionSpace)
 404     DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER(webAssemblyWrapperFunctionSpace)
 405 #endif
 406 
 407 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER
 408 
 409     IsoCellSet executableToCodeBlockEdgesWithConstraints;
 410     IsoCellSet executableToCodeBlockEdgesWithFinalizers;
 411 
 412 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(name) \
 413     template&lt;SubspaceAccess mode&gt; \
 414     IsoSubspace* name() \
 415     { \
 416         if (auto* spaceAndSet = m_##name.get()) \
 417             return &amp;spaceAndSet-&gt;space; \
 418         if (mode == SubspaceAccess::Concurrently) \
 419             return nullptr; \
 420         return name##Slow(); \
 421     } \
 422     IsoSubspace* name##Slow(); \
 423     std::unique_ptr&lt;SpaceAndSet&gt; m_##name;
 424 
 425     struct SpaceAndSet {
 426         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 427 
 428         IsoSubspace space;
 429         IsoCellSet set;
 430 
 431         template&lt;typename... Arguments&gt;
 432         SpaceAndSet(Arguments&amp;&amp;... arguments)
 433             : space(std::forward&lt;Arguments&gt;(arguments)...)
 434             , set(space)
 435         {
 436         }
 437 
 438         static IsoCellSet&amp; setFor(Subspace&amp; space)
 439         {
 440             return *bitwise_cast&lt;IsoCellSet*&gt;(
 441                 bitwise_cast&lt;char*&gt;(&amp;space) -
 442                 OBJECT_OFFSETOF(SpaceAndSet, space) +
 443                 OBJECT_OFFSETOF(SpaceAndSet, set));
 444         }
 445     };
 446 
 447     SpaceAndSet codeBlockSpace;
<a name="14" id="anc14"></a><span class="line-removed"> 448     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(inferredValueSpace)</span>
 449 
 450     template&lt;typename Func&gt;
 451     void forEachCodeBlockSpace(const Func&amp; func)
 452     {
 453         // This should not include webAssemblyCodeBlockSpace because this is about subsclasses of
 454         // JSC::CodeBlock.
 455         func(codeBlockSpace);
 456     }
 457 
 458     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(evalExecutableSpace)
 459     DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER(moduleProgramExecutableSpace)
 460     SpaceAndSet functionExecutableSpace;
 461     SpaceAndSet programExecutableSpace;
 462 
 463     template&lt;typename Func&gt;
 464     void forEachScriptExecutableSpace(const Func&amp; func)
 465     {
 466         if (m_evalExecutableSpace)
 467             func(*m_evalExecutableSpace);
 468         func(functionExecutableSpace);
 469         if (m_moduleProgramExecutableSpace)
 470             func(*m_moduleProgramExecutableSpace);
 471         func(programExecutableSpace);
 472     }
 473 
 474     SpaceAndSet unlinkedFunctionExecutableSpace;
 475 
 476 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER
 477 
 478     VMType vmType;
 479     ClientData* clientData;
 480     EntryFrame* topEntryFrame;
 481     // NOTE: When throwing an exception while rolling back the call frame, this may be equal to
 482     // topEntryFrame.
 483     // FIXME: This should be a void*, because it might not point to a CallFrame.
 484     // https://bugs.webkit.org/show_bug.cgi?id=160441
 485     ExecState* topCallFrame { nullptr };
 486 #if ENABLE(WEBASSEMBLY)
 487     Wasm::Context wasmContext;
 488 #endif
 489     Strong&lt;Structure&gt; structureStructure;
 490     Strong&lt;Structure&gt; structureRareDataStructure;
 491     Strong&lt;Structure&gt; terminatedExecutionErrorStructure;
 492     Strong&lt;Structure&gt; stringStructure;
 493     Strong&lt;Structure&gt; propertyNameEnumeratorStructure;
 494     Strong&lt;Structure&gt; customGetterSetterStructure;
 495     Strong&lt;Structure&gt; domAttributeGetterSetterStructure;
 496     Strong&lt;Structure&gt; scopedArgumentsTableStructure;
 497     Strong&lt;Structure&gt; apiWrapperStructure;
 498     Strong&lt;Structure&gt; nativeExecutableStructure;
 499     Strong&lt;Structure&gt; evalExecutableStructure;
 500     Strong&lt;Structure&gt; programExecutableStructure;
 501     Strong&lt;Structure&gt; functionExecutableStructure;
 502 #if ENABLE(WEBASSEMBLY)
 503     Strong&lt;Structure&gt; webAssemblyCodeBlockStructure;
 504 #endif
 505     Strong&lt;Structure&gt; moduleProgramExecutableStructure;
 506     Strong&lt;Structure&gt; regExpStructure;
 507     Strong&lt;Structure&gt; symbolStructure;
 508     Strong&lt;Structure&gt; symbolTableStructure;
 509     Strong&lt;Structure&gt; fixedArrayStructure;
 510     Strong&lt;Structure&gt; immutableButterflyStructures[NumberOfCopyOnWriteIndexingModes];
 511     Strong&lt;Structure&gt; sourceCodeStructure;
 512     Strong&lt;Structure&gt; scriptFetcherStructure;
 513     Strong&lt;Structure&gt; scriptFetchParametersStructure;
 514     Strong&lt;Structure&gt; structureChainStructure;
 515     Strong&lt;Structure&gt; sparseArrayValueMapStructure;
 516     Strong&lt;Structure&gt; templateObjectDescriptorStructure;
 517     Strong&lt;Structure&gt; arrayBufferNeuteringWatchpointStructure;
 518     Strong&lt;Structure&gt; unlinkedFunctionExecutableStructure;
 519     Strong&lt;Structure&gt; unlinkedProgramCodeBlockStructure;
 520     Strong&lt;Structure&gt; unlinkedEvalCodeBlockStructure;
 521     Strong&lt;Structure&gt; unlinkedFunctionCodeBlockStructure;
 522     Strong&lt;Structure&gt; unlinkedModuleProgramCodeBlockStructure;
 523     Strong&lt;Structure&gt; propertyTableStructure;
<a name="15" id="anc15"></a><span class="line-removed"> 524     Strong&lt;Structure&gt; inferredValueStructure;</span>
 525     Strong&lt;Structure&gt; functionRareDataStructure;
 526     Strong&lt;Structure&gt; exceptionStructure;
 527     Strong&lt;Structure&gt; promiseDeferredStructure;
 528     Strong&lt;Structure&gt; internalPromiseDeferredStructure;
 529     Strong&lt;Structure&gt; nativeStdFunctionCellStructure;
 530     Strong&lt;Structure&gt; programCodeBlockStructure;
 531     Strong&lt;Structure&gt; moduleProgramCodeBlockStructure;
 532     Strong&lt;Structure&gt; evalCodeBlockStructure;
 533     Strong&lt;Structure&gt; functionCodeBlockStructure;
 534     Strong&lt;Structure&gt; hashMapBucketSetStructure;
 535     Strong&lt;Structure&gt; hashMapBucketMapStructure;
<a name="16" id="anc16"></a><span class="line-removed"> 536     Strong&lt;Structure&gt; setIteratorStructure;</span>
<span class="line-removed"> 537     Strong&lt;Structure&gt; mapIteratorStructure;</span>
 538     Strong&lt;Structure&gt; bigIntStructure;
 539     Strong&lt;Structure&gt; executableToCodeBlockEdgeStructure;
 540 
<a name="17" id="anc17"></a><span class="line-modified"> 541     Strong&lt;JSCell&gt; emptyPropertyNameEnumerator;</span>



 542 
 543     Strong&lt;JSCell&gt; m_sentinelSetBucket;
 544     Strong&lt;JSCell&gt; m_sentinelMapBucket;
 545 
<a name="18" id="anc18"></a><span class="line-modified"> 546     std::unique_ptr&lt;PromiseDeferredTimer&gt; promiseDeferredTimer;</span>
 547 
 548     JSCell* currentlyDestructingCallbackObject;
 549     const ClassInfo* currentlyDestructingCallbackObjectClassInfo { nullptr };
 550 
<a name="19" id="anc19"></a><span class="line-modified"> 551     AtomicStringTable* m_atomicStringTable;</span>
 552     WTF::SymbolRegistry m_symbolRegistry;
 553     CommonIdentifiers* propertyNames;
 554     const ArgList* emptyList;
 555     SmallStrings smallStrings;
 556     NumericStrings numericStrings;
 557     DateInstanceCache dateInstanceCache;
 558     std::unique_ptr&lt;SimpleStats&gt; machineCodeBytesPerBytecodeWordForBaselineJIT;
 559     WeakGCMap&lt;std::pair&lt;CustomGetterSetter*, int&gt;, JSCustomGetterSetterFunction&gt; customGetterSetterFunctionMap;
 560     WeakGCMap&lt;StringImpl*, JSString, PtrHash&lt;StringImpl*&gt;&gt; stringCache;
 561     Strong&lt;JSString&gt; lastCachedString;
 562 
<a name="20" id="anc20"></a><span class="line-modified"> 563     AtomicStringTable* atomicStringTable() const { return m_atomicStringTable; }</span>
 564     WTF::SymbolRegistry&amp; symbolRegistry() { return m_symbolRegistry; }
 565 
<a name="21" id="anc21"></a>













 566     JSCell* sentinelSetBucket()
 567     {
 568         if (LIKELY(m_sentinelSetBucket))
 569             return m_sentinelSetBucket.get();
 570         return sentinelSetBucketSlow();
 571     }
 572 
 573     JSCell* sentinelMapBucket()
 574     {
 575         if (LIKELY(m_sentinelMapBucket))
 576             return m_sentinelMapBucket.get();
 577         return sentinelMapBucketSlow();
 578     }
 579 
<a name="22" id="anc22"></a>






 580     WeakGCMap&lt;SymbolImpl*, Symbol, PtrHash&lt;SymbolImpl*&gt;&gt; symbolImplToSymbolMap;
 581 
 582     enum class DeletePropertyMode {
 583         // Default behaviour of deleteProperty, matching the spec.
 584         Default,
 585         // This setting causes deleteProperty to force deletion of all
 586         // properties including those that are non-configurable (DontDelete).
 587         IgnoreConfigurable
 588     };
 589 
 590     DeletePropertyMode deletePropertyMode()
 591     {
 592         return m_deletePropertyMode;
 593     }
 594 
 595     class DeletePropertyModeScope {
 596     public:
 597         DeletePropertyModeScope(VM&amp; vm, DeletePropertyMode mode)
 598             : m_vm(vm)
 599             , m_previousMode(vm.m_deletePropertyMode)
 600         {
 601             m_vm.m_deletePropertyMode = mode;
 602         }
 603 
 604         ~DeletePropertyModeScope()
 605         {
 606             m_vm.m_deletePropertyMode = m_previousMode;
 607         }
 608 
 609     private:
 610         VM&amp; m_vm;
 611         DeletePropertyMode m_previousMode;
 612     };
 613 
 614     static JS_EXPORT_PRIVATE bool canUseAssembler();
<a name="23" id="anc23"></a><span class="line-modified"> 615     static JS_EXPORT_PRIVATE bool canUseRegExpJIT();</span>
<span class="line-modified"> 616     static JS_EXPORT_PRIVATE bool isInMiniMode();</span>







 617 
 618     static void computeCanUseJIT();
 619     ALWAYS_INLINE static bool canUseJIT()
 620     {
 621 #if ENABLE(JIT)
 622 #if !ASSERT_DISABLED
 623         RELEASE_ASSERT(s_canUseJITIsSet);
 624 #endif
 625         return s_canUseJIT;
 626 #else
 627         return false;
 628 #endif
 629     }
 630 
 631     SourceProviderCache* addSourceProviderCache(SourceProvider*);
 632     void clearSourceProviderCaches();
 633 
 634     StructureCache structureCache;
 635 
 636     typedef HashMap&lt;RefPtr&lt;SourceProvider&gt;, RefPtr&lt;SourceProviderCache&gt;&gt; SourceProviderCacheMap;
 637     SourceProviderCacheMap sourceProviderCacheMap;
 638     Interpreter* interpreter;
 639 #if ENABLE(JIT)
 640     std::unique_ptr&lt;JITThunks&gt; jitStubs;
 641     MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; getCTIStub(ThunkGenerator generator)
 642     {
<a name="24" id="anc24"></a><span class="line-modified"> 643         return jitStubs-&gt;ctiStub(this, generator);</span>
 644     }
 645 
 646 #endif // ENABLE(JIT)
 647 #if ENABLE(FTL_JIT)
 648     std::unique_ptr&lt;FTL::Thunks&gt; ftlThunks;
 649 #endif
 650     NativeExecutable* getHostFunction(NativeFunction, NativeFunction constructor, const String&amp; name);
 651     NativeExecutable* getHostFunction(NativeFunction, Intrinsic, NativeFunction constructor, const DOMJIT::Signature*, const String&amp; name);
 652 
 653     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; getCTIInternalFunctionTrampolineFor(CodeSpecializationKind);
 654 
 655     static ptrdiff_t exceptionOffset()
 656     {
 657         return OBJECT_OFFSETOF(VM, m_exception);
 658     }
 659 
 660     static ptrdiff_t callFrameForCatchOffset()
 661     {
 662         return OBJECT_OFFSETOF(VM, callFrameForCatch);
 663     }
 664 
 665     static ptrdiff_t topEntryFrameOffset()
 666     {
 667         return OBJECT_OFFSETOF(VM, topEntryFrame);
 668     }
 669 
<a name="25" id="anc25"></a>









 670     void restorePreviousException(Exception* exception) { setException(exception); }
 671 
 672     void clearLastException() { m_lastException = nullptr; }
 673 
 674     ExecState** addressOfCallFrameForCatch() { return &amp;callFrameForCatch; }
 675 
 676     JSCell** addressOfException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_exception); }
 677 
 678     Exception* lastException() const { return m_lastException; }
 679     JSCell** addressOfLastException() { return reinterpret_cast&lt;JSCell**&gt;(&amp;m_lastException); }
 680 
 681     // This should only be used for test or assertion code that wants to inspect
 682     // the pending exception without interfering with Throw/CatchScopes.
 683     Exception* exceptionForInspection() const { return m_exception; }
 684 
 685     void setFailNextNewCodeBlock() { m_failNextNewCodeBlock = true; }
 686     bool getAndClearFailNextNewCodeBlock()
 687     {
 688         bool result = m_failNextNewCodeBlock;
 689         m_failNextNewCodeBlock = false;
 690         return result;
 691     }
 692 
 693     ALWAYS_INLINE Structure* getStructure(StructureID id)
 694     {
 695         return heap.structureIDTable().get(decontaminate(id));
 696     }
 697 
 698     void* stackPointerAtVMEntry() const { return m_stackPointerAtVMEntry; }
 699     void setStackPointerAtVMEntry(void*);
 700 
 701     size_t softReservedZoneSize() const { return m_currentSoftReservedZoneSize; }
 702     size_t updateSoftReservedZoneSize(size_t softReservedZoneSize);
 703 
 704     static size_t committedStackByteCount();
 705     inline bool ensureStackCapacityFor(Register* newTopOfStack);
 706 
 707     void* stackLimit() { return m_stackLimit; }
 708     void* softStackLimit() { return m_softStackLimit; }
 709     void** addressOfSoftStackLimit() { return &amp;m_softStackLimit; }
 710 #if ENABLE(C_LOOP)
 711     void* cloopStackLimit() { return m_cloopStackLimit; }
 712     void setCLoopStackLimit(void* limit) { m_cloopStackLimit = limit; }
<a name="26" id="anc26"></a>
 713 #endif
 714 
 715     inline bool isSafeToRecurseSoft() const;
 716     bool isSafeToRecurse() const
 717     {
 718         return isSafeToRecurse(m_stackLimit);
 719     }
 720 
 721     void** addressOfLastStackTop() { return &amp;m_lastStackTop; }
 722     void* lastStackTop() { return m_lastStackTop; }
 723     void setLastStackTop(void*);
 724 
 725     void firePrimitiveGigacageEnabledIfNecessary()
 726     {
 727         if (m_needToFirePrimitiveGigacageEnabled) {
 728             m_needToFirePrimitiveGigacageEnabled = false;
 729             m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled asynchronously&quot;);
 730         }
 731     }
 732 
 733     JSValue hostCallReturnValue;
 734     unsigned varargsLength;
 735     ExecState* newCallFrameReturnValue;
 736     ExecState* callFrameForCatch;
 737     void* targetMachinePCForThrow;
 738     const Instruction* targetInterpreterPCForThrow;
 739     uint32_t osrExitIndex;
 740     void* osrExitJumpDestination;
 741     bool isExecutingInRegExpJIT { false };
 742 
 743     // The threading protocol here is as follows:
 744     // - You can call scratchBufferForSize from any thread.
 745     // - You can only set the ScratchBuffer&#39;s activeLength from the main thread.
 746     // - You can only write to entries in the ScratchBuffer from the main thread.
 747     ScratchBuffer* scratchBufferForSize(size_t size);
 748     void clearScratchBuffers();
 749 
 750     EncodedJSValue* exceptionFuzzingBuffer(size_t size)
 751     {
 752         ASSERT(Options::useExceptionFuzz());
 753         if (!m_exceptionFuzzBuffer)
 754             m_exceptionFuzzBuffer = MallocPtr&lt;EncodedJSValue&gt;::malloc(size);
 755         return m_exceptionFuzzBuffer.get();
 756     }
 757 
 758     void gatherScratchBufferRoots(ConservativeRoots&amp;);
 759 
 760     VMEntryScope* entryScope;
 761 
 762     JSObject* stringRecursionCheckFirstObject { nullptr };
 763     HashSet&lt;JSObject*&gt; stringRecursionCheckVisitedObjects;
 764 
<a name="27" id="anc27"></a>
 765     LocalTimeOffsetCache localTimeOffsetCache;
 766 
 767     String cachedDateString;
 768     double cachedDateStringValue;
 769 
 770     std::unique_ptr&lt;Profiler::Database&gt; m_perBytecodeProfiler;
 771     RefPtr&lt;TypedArrayController&gt; m_typedArrayController;
 772     RegExpCache* m_regExpCache;
 773     BumpPointerAllocator m_regExpAllocator;
 774     ConcurrentJSLock m_regExpAllocatorLock;
 775 
 776 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
 777     static constexpr size_t patternContextBufferSize = 8192; // Space allocated to save nested parenthesis context
 778     UniqueArray&lt;char&gt; m_regExpPatternContexBuffer;
 779     Lock m_regExpPatternContextLock;
 780     char* acquireRegExpPatternContexBuffer();
 781     void releaseRegExpPatternContexBuffer();
<a name="28" id="anc28"></a>

 782 #endif
 783 
 784     Ref&lt;CompactVariableMap&gt; m_compactVariableMap;
 785 
 786     std::unique_ptr&lt;HasOwnPropertyCache&gt; m_hasOwnPropertyCache;
 787     ALWAYS_INLINE HasOwnPropertyCache* hasOwnPropertyCache() { return m_hasOwnPropertyCache.get(); }
 788     HasOwnPropertyCache* ensureHasOwnPropertyCache();
 789 
 790 #if ENABLE(REGEXP_TRACING)
 791     typedef ListHashSet&lt;RegExp*&gt; RTTraceList;
 792     RTTraceList* m_rtTraceList;
 793 #endif
 794 
<a name="29" id="anc29"></a><span class="line-removed"> 795     std::unique_ptr&lt;ValueProfile&gt; noJITValueProfileSingleton;</span>
<span class="line-removed"> 796 </span>
 797     JS_EXPORT_PRIVATE void resetDateCache();
 798 
 799     RegExpCache* regExpCache() { return m_regExpCache; }
 800 #if ENABLE(REGEXP_TRACING)
 801     void addRegExpToTrace(RegExp*);
 802 #endif
 803     JS_EXPORT_PRIVATE void dumpRegExpTrace();
 804 
 805     bool isCollectorBusyOnCurrentThread() { return heap.isCurrentThreadBusy(); }
 806 
 807 #if ENABLE(GC_VALIDATION)
 808     bool isInitializingObject() const;
 809     void setInitializingObjectClass(const ClassInfo*);
 810 #endif
 811 
 812     bool currentThreadIsHoldingAPILock() const { return m_apiLock-&gt;currentThreadIsHoldingLock(); }
 813 
 814     JSLock&amp; apiLock() { return *m_apiLock; }
 815     CodeCache* codeCache() { return m_codeCache.get(); }
 816 
 817     JS_EXPORT_PRIVATE void whenIdle(Function&lt;void()&gt;&amp;&amp;);
 818 
 819     JS_EXPORT_PRIVATE void deleteAllCode(DeleteAllCodeEffort);
 820     JS_EXPORT_PRIVATE void deleteAllLinkedCode(DeleteAllCodeEffort);
 821 
 822     void shrinkFootprintWhenIdle();
 823 
 824     WatchpointSet* ensureWatchpointSetForImpureProperty(const Identifier&amp;);
 825     void registerWatchpointForImpureProperty(const Identifier&amp;, Watchpoint*);
 826 
<a name="30" id="anc30"></a><span class="line-modified"> 827     // FIXME: Use AtomicString once it got merged with Identifier.</span>
 828     JS_EXPORT_PRIVATE void addImpureProperty(const String&amp;);
 829 
 830     InlineWatchpointSet&amp; primitiveGigacageEnabled() { return m_primitiveGigacageEnabled; }
 831 
 832     BuiltinExecutables* builtinExecutables() { return m_builtinExecutables.get(); }
 833 
 834     bool enableTypeProfiler();
 835     bool disableTypeProfiler();
 836     TypeProfilerLog* typeProfilerLog() { return m_typeProfilerLog.get(); }
 837     TypeProfiler* typeProfiler() { return m_typeProfiler.get(); }
 838     JS_EXPORT_PRIVATE void dumpTypeProfilerData();
 839 
 840     FunctionHasExecutedCache* functionHasExecutedCache() { return &amp;m_functionHasExecutedCache; }
 841 
 842     ControlFlowProfiler* controlFlowProfiler() { return m_controlFlowProfiler.get(); }
 843     bool enableControlFlowProfiler();
 844     bool disableControlFlowProfiler();
 845 
 846     void queueMicrotask(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 847     JS_EXPORT_PRIVATE void drainMicrotasks();
<a name="31" id="anc31"></a><span class="line-modified"> 848     ALWAYS_INLINE void setOnEachMicrotaskTick(WTF::Function&lt;void(VM&amp;)&gt;&amp;&amp; func) { m_onEachMicrotaskTick = WTFMove(func); }</span>



 849     void setGlobalConstRedeclarationShouldThrow(bool globalConstRedeclarationThrow) { m_globalConstRedeclarationShouldThrow = globalConstRedeclarationThrow; }
 850     ALWAYS_INLINE bool globalConstRedeclarationShouldThrow() const { return m_globalConstRedeclarationShouldThrow; }
 851 
 852     void setShouldBuildPCToCodeOriginMapping() { m_shouldBuildPCToCodeOriginMapping = true; }
 853     bool shouldBuilderPCToCodeOriginMapping() const { return m_shouldBuildPCToCodeOriginMapping; }
 854 
 855     BytecodeIntrinsicRegistry&amp; bytecodeIntrinsicRegistry() { return *m_bytecodeIntrinsicRegistry; }
 856 
 857     ShadowChicken* shadowChicken() { return m_shadowChicken.get(); }
 858     void ensureShadowChicken();
 859 
 860     template&lt;typename Func&gt;
 861     void logEvent(CodeBlock*, const char* summary, const Func&amp; func);
 862 
 863     Optional&lt;RefPtr&lt;Thread&gt;&gt; ownerThread() const { return m_apiLock-&gt;ownerThread(); }
 864 
 865     VMTraps&amp; traps() { return m_traps; }
 866 
 867     void handleTraps(ExecState* exec, VMTraps::Mask mask = VMTraps::Mask::allEventTypes()) { m_traps.handleTraps(exec, mask); }
 868 
 869     bool needTrapHandling() { return m_traps.needTrapHandling(); }
 870     bool needTrapHandling(VMTraps::Mask mask) { return m_traps.needTrapHandling(mask); }
 871     void* needTrapHandlingAddress() { return m_traps.needTrapHandlingAddress(); }
 872 
 873     void notifyNeedDebuggerBreak() { m_traps.fireTrap(VMTraps::NeedDebuggerBreak); }
 874     void notifyNeedTermination() { m_traps.fireTrap(VMTraps::NeedTermination); }
 875     void notifyNeedWatchdogCheck() { m_traps.fireTrap(VMTraps::NeedWatchdogCheck); }
 876 
<a name="32" id="anc32"></a>

 877 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 878     StackTrace* nativeStackTraceOfLastThrow() const { return m_nativeStackTraceOfLastThrow.get(); }
 879     Thread* throwingThread() const { return m_throwingThread.get(); }
 880     bool needExceptionCheck() const { return m_needExceptionCheck; }
 881 #endif
 882 
 883 #if USE(CF)
 884     CFRunLoopRef runLoop() const { return m_runLoop.get(); }
 885     JS_EXPORT_PRIVATE void setRunLoop(CFRunLoopRef);
 886 #endif // USE(CF)
 887 
<a name="33" id="anc33"></a>

 888     class DeferExceptionScope {
 889     public:
 890         DeferExceptionScope(VM&amp; vm)
 891             : m_savedException(vm.m_exception, nullptr)
 892             , m_savedLastException(vm.m_lastException, nullptr)
 893         {
 894         }
 895 
 896     private:
 897         SetForScope&lt;Exception*&gt; m_savedException;
 898         SetForScope&lt;Exception*&gt; m_savedLastException;
 899     };
 900 
 901 private:
 902     friend class LLIntOffsetsExtractor;
 903 
 904     VM(VMType, HeapType);
 905     static VM*&amp; sharedInstanceInternal();
 906     void createNativeThunk();
 907 
<a name="34" id="anc34"></a>

 908     JSCell* sentinelSetBucketSlow();
 909     JSCell* sentinelMapBucketSlow();
<a name="35" id="anc35"></a>
 910 
 911     void updateStackLimits();
 912 
 913     bool isSafeToRecurse(void* stackLimit) const
 914     {
 915         ASSERT(Thread::current().stack().isGrowingDownward());
 916         void* curr = currentStackPointer();
 917         return curr &gt;= stackLimit;
 918     }
 919 
 920     void setException(Exception* exception)
 921     {
 922         m_exception = exception;
 923         m_lastException = exception;
 924     }
 925     Exception* exception() const
 926     {
 927 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 928         m_needExceptionCheck = false;
 929 #endif
 930         return m_exception;
 931     }
 932     void clearException()
 933     {
 934 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 935         m_needExceptionCheck = false;
 936         m_nativeStackTraceOfLastThrow = nullptr;
 937         m_throwingThread = nullptr;
 938 #endif
 939         m_exception = nullptr;
 940     }
 941 
 942 #if ENABLE(C_LOOP)
 943     bool ensureStackCapacityForCLoop(Register* newTopOfStack);
 944     bool isSafeToRecurseSoftCLoop() const;
 945 #endif // ENABLE(C_LOOP)
 946 
<a name="36" id="anc36"></a><span class="line-modified"> 947     JS_EXPORT_PRIVATE void throwException(ExecState*, Exception*);</span>
<span class="line-modified"> 948     JS_EXPORT_PRIVATE JSValue throwException(ExecState*, JSValue);</span>
<span class="line-modified"> 949     JS_EXPORT_PRIVATE JSObject* throwException(ExecState*, JSObject*);</span>
 950 
 951 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 952     void verifyExceptionCheckNeedIsSatisfied(unsigned depth, ExceptionEventLocation&amp;);
 953 #endif
 954 
 955     static void primitiveGigacageDisabledCallback(void*);
 956     void primitiveGigacageDisabled();
 957 
<a name="37" id="anc37"></a>


 958 #if ENABLE(GC_VALIDATION)
 959     const ClassInfo* m_initializingObjectClass;
 960 #endif
 961 
 962     void* m_stackPointerAtVMEntry;
 963     size_t m_currentSoftReservedZoneSize;
 964     void* m_stackLimit { nullptr };
 965     void* m_softStackLimit { nullptr };
 966 #if ENABLE(C_LOOP)
 967     void* m_cloopStackLimit { nullptr };
 968 #endif
 969     void* m_lastStackTop { nullptr };
 970 
 971     Exception* m_exception { nullptr };
 972     Exception* m_lastException { nullptr };
 973 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 974     ExceptionScope* m_topExceptionScope { nullptr };
 975     ExceptionEventLocation m_simulatedThrowPointLocation;
 976     unsigned m_simulatedThrowPointRecursionDepth { 0 };
 977     mutable bool m_needExceptionCheck { false };
 978     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastThrow;
 979     std::unique_ptr&lt;StackTrace&gt; m_nativeStackTraceOfLastSimulatedThrow;
 980     RefPtr&lt;Thread&gt; m_throwingThread;
 981 #endif
 982 
 983     bool m_failNextNewCodeBlock { false };
 984     DeletePropertyMode m_deletePropertyMode { DeletePropertyMode::Default };
 985     bool m_globalConstRedeclarationShouldThrow { true };
 986     bool m_shouldBuildPCToCodeOriginMapping { false };
 987     std::unique_ptr&lt;CodeCache&gt; m_codeCache;
 988     std::unique_ptr&lt;BuiltinExecutables&gt; m_builtinExecutables;
 989     HashMap&lt;String, RefPtr&lt;WatchpointSet&gt;&gt; m_impurePropertyWatchpointSets;
 990     std::unique_ptr&lt;TypeProfiler&gt; m_typeProfiler;
 991     std::unique_ptr&lt;TypeProfilerLog&gt; m_typeProfilerLog;
 992     unsigned m_typeProfilerEnabledCount;
 993     bool m_needToFirePrimitiveGigacageEnabled { false };
 994     Lock m_scratchBufferLock;
 995     Vector&lt;ScratchBuffer*&gt; m_scratchBuffers;
 996     size_t m_sizeOfLastScratchBuffer { 0 };
 997     InlineWatchpointSet m_primitiveGigacageEnabled;
 998     FunctionHasExecutedCache m_functionHasExecutedCache;
 999     std::unique_ptr&lt;ControlFlowProfiler&gt; m_controlFlowProfiler;
1000     unsigned m_controlFlowProfilerEnabledCount;
1001     Deque&lt;std::unique_ptr&lt;QueuedTask&gt;&gt; m_microtaskQueue;
1002     MallocPtr&lt;EncodedJSValue&gt; m_exceptionFuzzBuffer;
1003     VMTraps m_traps;
1004     RefPtr&lt;Watchdog&gt; m_watchdog;
1005     std::unique_ptr&lt;HeapProfiler&gt; m_heapProfiler;
1006 #if ENABLE(SAMPLING_PROFILER)
1007     RefPtr&lt;SamplingProfiler&gt; m_samplingProfiler;
1008 #endif
<a name="38" id="anc38"></a>
1009     std::unique_ptr&lt;ShadowChicken&gt; m_shadowChicken;
1010     std::unique_ptr&lt;BytecodeIntrinsicRegistry&gt; m_bytecodeIntrinsicRegistry;
1011 
<a name="39" id="anc39"></a>


1012     WTF::Function&lt;void(VM&amp;)&gt; m_onEachMicrotaskTick;
<a name="40" id="anc40"></a>
1013 
1014 #if ENABLE(JIT)
1015 #if !ASSERT_DISABLED
1016     JS_EXPORT_PRIVATE static bool s_canUseJITIsSet;
1017 #endif
1018     JS_EXPORT_PRIVATE static bool s_canUseJIT;
1019 #endif
1020 
1021     VM* m_prev; // Required by DoublyLinkedListNode.
1022     VM* m_next; // Required by DoublyLinkedListNode.
1023 
1024     // Friends for exception checking purpose only.
1025     friend class Heap;
1026     friend class CatchScope;
1027     friend class ExceptionScope;
1028     friend class ThrowScope;
1029     friend class VMTraps;
1030     friend class WTF::DoublyLinkedListNode&lt;VM&gt;;
1031 };
1032 
1033 #if ENABLE(GC_VALIDATION)
1034 inline bool VM::isInitializingObject() const
1035 {
1036     return !!m_initializingObjectClass;
1037 }
1038 
1039 inline void VM::setInitializingObjectClass(const ClassInfo* initializingObjectClass)
1040 {
1041     m_initializingObjectClass = initializingObjectClass;
1042 }
1043 #endif
1044 
1045 inline Heap* WeakSet::heap() const
1046 {
<a name="41" id="anc41"></a><span class="line-modified">1047     return &amp;m_vm-&gt;heap;</span>
1048 }
1049 
1050 #if !ENABLE(C_LOOP)
1051 extern &quot;C&quot; void sanitizeStackForVMImpl(VM*);
1052 #endif
1053 
<a name="42" id="anc42"></a><span class="line-modified">1054 JS_EXPORT_PRIVATE void sanitizeStackForVM(VM*);</span>
<span class="line-modified">1055 void logSanitizeStack(VM*);</span>
1056 
1057 } // namespace JSC
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>