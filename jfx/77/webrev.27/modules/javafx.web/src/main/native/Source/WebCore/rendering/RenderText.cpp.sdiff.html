<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTableSection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextControlMultiLine.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * (C) 2000 Dirk Mueller (mueller@kde.org)
<span class="line-modified">   4  * Copyright (C) 2004-2007, 2013-2015 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
</pre>
<hr />
<pre>
  34 #include &quot;FloatQuad.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;Hyphenation.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
  40 #include &quot;Range.h&quot;
  41 #include &quot;RenderBlock.h&quot;
  42 #include &quot;RenderCombineText.h&quot;
  43 #include &quot;RenderInline.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderView.h&quot;
  46 #include &quot;RenderedDocumentMarker.h&quot;
  47 #include &quot;Settings.h&quot;
  48 #include &quot;SimpleLineLayoutFunctions.h&quot;
  49 #include &quot;Text.h&quot;
  50 #include &quot;TextResourceDecoder.h&quot;
  51 #include &quot;VisiblePosition.h&quot;
  52 #include &lt;wtf/IsoMallocInlines.h&gt;
  53 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-removed">  54 #include &lt;wtf/text/StringBuffer.h&gt;</span>
  55 #include &lt;wtf/text/StringBuilder.h&gt;
  56 #include &lt;wtf/text/TextBreakIterator.h&gt;
  57 #include &lt;wtf/unicode/CharacterNames.h&gt;
  58 
  59 #if PLATFORM(IOS_FAMILY)
  60 #include &quot;Document.h&quot;
  61 #include &quot;EditorClient.h&quot;
  62 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  63 #include &quot;Page.h&quot;
  64 #include &quot;SelectionRect.h&quot;
  65 #endif
  66 
  67 namespace WebCore {
  68 
  69 using namespace WTF::Unicode;
  70 
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderText);
  72 
  73 struct SameSizeAsRenderText : public RenderObject {
  74     void* pointers[2];
</pre>
<hr />
<pre>
 124 
 125 void SecureTextTimer::fired()
 126 {
 127     ASSERT(secureTextTimers().get(&amp;m_renderer) == this);
 128     m_offsetAfterLastTypedCharacter = 0;
 129     m_renderer.setText(m_renderer.text(), true /* forcing setting text as it may be masked later */);
 130 }
 131 
 132 static HashMap&lt;const RenderText*, String&gt;&amp; originalTextMap()
 133 {
 134     static NeverDestroyed&lt;HashMap&lt;const RenderText*, String&gt;&gt; map;
 135     return map;
 136 }
 137 
 138 static HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&amp; inlineWrapperForDisplayContentsMap()
 139 {
 140     static NeverDestroyed&lt;HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&gt; map;
 141     return map;
 142 }
 143 
<span class="line-modified"> 144 String capitalize(const String&amp; string, UChar previousCharacter)</span>
 145 {
<span class="line-modified"> 146     // FIXME: Need to change this to use u_strToTitle instead of u_totitle and to consider locale.</span>

 147 
<span class="line-modified"> 148     if (string.isNull())</span>
<span class="line-modified"> 149         return string;</span>

 150 
 151     unsigned length = string.length();
 152     auto&amp; stringImpl = *string.impl();
 153 
<span class="line-modified"> 154     if (length &gt;= std::numeric_limits&lt;unsigned&gt;::max())</span>
<span class="line-removed"> 155         CRASH();</span>
 156 
<span class="line-modified"> 157     StringBuffer&lt;UChar&gt; stringWithPrevious(length + 1);</span>
<span class="line-modified"> 158     stringWithPrevious[0] = previousCharacter == noBreakSpace ? &#39; &#39; : previousCharacter;</span>
<span class="line-modified"> 159     for (unsigned i = 1; i &lt; length + 1; i++) {</span>
<span class="line-modified"> 160         // Replace NO BREAK SPACE with a real space since ICU does not treat it as a word separator.</span>
<span class="line-modified"> 161         if (stringImpl[i - 1] == noBreakSpace)</span>
<span class="line-removed"> 162             stringWithPrevious[i] = &#39; &#39;;</span>
<span class="line-removed"> 163         else</span>
<span class="line-removed"> 164             stringWithPrevious[i] = stringImpl[i - 1];</span>
<span class="line-removed"> 165     }</span>
 166 
<span class="line-modified"> 167     auto* boundary = wordBreakIterator(StringView(stringWithPrevious.characters(), length + 1));</span>
<span class="line-modified"> 168     if (!boundary)</span>
 169         return string;
 170 
 171     StringBuilder result;
 172     result.reserveCapacity(length);
 173 

 174     int32_t endOfWord;
<span class="line-modified"> 175     int32_t startOfWord = ubrk_first(boundary);</span>
<span class="line-modified"> 176     for (endOfWord = ubrk_next(boundary); endOfWord != UBRK_DONE; startOfWord = endOfWord, endOfWord = ubrk_next(boundary)) {</span>
<span class="line-modified"> 177         if (startOfWord) // Ignore first char of previous string</span>
<span class="line-removed"> 178             result.append(stringImpl[startOfWord - 1] == noBreakSpace ? noBreakSpace : u_totitle(stringWithPrevious[startOfWord]));</span>
 179         for (int i = startOfWord + 1; i &lt; endOfWord; i++)
 180             result.append(stringImpl[i - 1]);
 181     }
 182 
<span class="line-modified"> 183     return result.toString();</span>
 184 }
 185 
 186 inline RenderText::RenderText(Node&amp; node, const String&amp; text)
 187     : RenderObject(node)
 188     , m_hasTab(false)
 189     , m_linesDirty(false)
 190     , m_containsReversedText(false)
 191     , m_isAllASCII(text.impl()-&gt;isAllASCII())
 192     , m_knownToHaveNoOverflowAndNoFallbackFonts(false)
 193     , m_useBackslashAsYenSymbol(false)
 194     , m_originalTextDiffersFromRendered(false)
 195     , m_hasInlineWrapperForDisplayContents(false)
 196     , m_text(text)
 197 {
 198     ASSERT(!m_text.isNull());
 199     setIsText();
 200     m_canUseSimpleFontCodePath = computeCanUseSimpleFontCodePath();
 201 
 202     // FIXME: Find out how to increment the visually non empty character count when the font becomes available.
 203     auto isTextVisible = false;
</pre>
<hr />
<pre>
 367         // Note, box-&gt;end() returns the index of the last character, not the index past it.
 368         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end)
 369             rect = box-&gt;localSelectionRect(start, end);
 370         else {
 371             unsigned realEnd = std::min(box-&gt;end() + 1, end);
 372             rect = box-&gt;localSelectionRect(start, realEnd);
 373             if (rect.isEmpty())
 374                 continue;
 375         }
 376 
 377         if (box-&gt;root().isFirstAfterPageBreak()) {
 378             if (box-&gt;isHorizontal())
 379                 rect.shiftYEdgeTo(box-&gt;root().lineTopWithLeading());
 380             else
 381                 rect.shiftXEdgeTo(box-&gt;root().lineTopWithLeading());
 382         }
 383 
 384         RenderBlock* containingBlock = this-&gt;containingBlock();
 385         // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
 386         LogicalSelectionOffsetCaches cache(*containingBlock);
<span class="line-modified"> 387         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, box-&gt;logicalTop(), cache);</span>
<span class="line-modified"> 388         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, box-&gt;logicalTop(), cache);</span>
 389         LayoutRect extentsRect = rect;
 390         if (box-&gt;isHorizontal()) {
 391             extentsRect.setX(leftOffset);
 392             extentsRect.setWidth(rightOffset - leftOffset);
 393         } else {
 394             extentsRect.setY(leftOffset);
 395             extentsRect.setHeight(rightOffset - leftOffset);
 396         }
 397         extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
 398         if (!box-&gt;isHorizontal())
 399             extentsRect = extentsRect.transposedRect();
 400         bool isFirstOnLine = !box-&gt;previousOnLineExists();
 401         bool isLastOnLine = !box-&gt;nextOnLineExists();
 402         if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
 403             isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 404 
 405         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() + 1 &gt;= start;
 406         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() + 1 &gt;= end;
 407 
 408         bool isFixed = false;
</pre>
<hr />
<pre>
 693 {
 694     if (preferredLogicalWidthsDirty())
 695         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 696 
 697     return m_minWidth;
 698 }
 699 
 700 float RenderText::maxLogicalWidth() const
 701 {
 702     if (preferredLogicalWidthsDirty())
 703         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 704 
 705     return m_maxWidth;
 706 }
 707 
 708 LineBreakIteratorMode mapLineBreakToIteratorMode(LineBreak lineBreak)
 709 {
 710     switch (lineBreak) {
 711     case LineBreak::Auto:
 712     case LineBreak::AfterWhiteSpace:

 713         return LineBreakIteratorMode::Default;
 714     case LineBreak::Loose:
 715         return LineBreakIteratorMode::Loose;
 716     case LineBreak::Normal:
 717         return LineBreakIteratorMode::Normal;
 718     case LineBreak::Strict:
 719         return LineBreakIteratorMode::Strict;
 720     }
 721     ASSERT_NOT_REACHED();
 722     return LineBreakIteratorMode::Default;
 723 }
 724 
 725 void RenderText::computePreferredLogicalWidths(float leadWidth)
 726 {
 727     HashSet&lt;const Font*&gt; fallbackFonts;
 728     GlyphOverflow glyphOverflow;
 729     computePreferredLogicalWidths(leadWidth, fallbackFonts, glyphOverflow);
 730     if (fallbackFonts.isEmpty() &amp;&amp; !glyphOverflow.left &amp;&amp; !glyphOverflow.right &amp;&amp; !glyphOverflow.top &amp;&amp; !glyphOverflow.bottom)
 731         m_knownToHaveNoOverflowAndNoFallbackFonts = true;
 732 }
</pre>
<hr />
<pre>
 817     unsigned minimumPrefixLength = 0;
 818     unsigned minimumSuffixLength = 0;
 819     if (style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale())) {
 820         maxWordWidth = 0;
 821 
 822         // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 823         auto before = style.hyphenationLimitBefore();
 824         minimumPrefixLength = before &lt; 0 ? 2 : before;
 825 
 826         auto after = style.hyphenationLimitAfter();
 827         minimumSuffixLength = after &lt; 0 ? 2 : after;
 828     }
 829 
 830     Optional&lt;int&gt; firstGlyphLeftOverflow;
 831 
 832     bool breakNBSP = style.autoWrap() &amp;&amp; style.nbspMode() == NBSPMode::Space;
 833 
 834     // Note the deliberate omission of word-wrap and overflow-wrap from this breakAll check. Those
 835     // do not affect minimum preferred sizes. Note that break-word is a non-standard value for
 836     // word-break, but we support it as though it means break-all.

 837     bool breakAll = (style.wordBreak() == WordBreak::BreakAll || style.wordBreak() == WordBreak::BreakWord) &amp;&amp; style.autoWrap();
 838     bool keepAllWords = style.wordBreak() == WordBreak::KeepAll;
 839     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 840 
 841     for (unsigned i = 0; i &lt; length; i++) {
 842         UChar c = string[i];
 843 
 844         bool previousCharacterIsSpace = isSpace;
 845 
 846         bool isNewline = false;
 847         if (c == &#39;\n&#39;) {
 848             if (style.preserveNewline()) {
 849                 m_hasBreak = true;
 850                 isNewline = true;
 851                 isSpace = false;
 852             } else
 853                 isSpace = true;
 854         } else if (c == &#39;\t&#39;) {
 855             if (!style.collapseWhiteSpace()) {
 856                 m_hasTab = true;
</pre>
<hr />
<pre>
 865         if ((isSpace || isNewline) &amp;&amp; i == length - 1)
 866             m_hasEndWS = true;
 867 
 868         ignoringSpaces |= style.collapseWhiteSpace() &amp;&amp; previousCharacterIsSpace &amp;&amp; isSpace;
 869         ignoringSpaces &amp;= isSpace;
 870 
 871         // Ignore spaces and soft hyphens
 872         if (ignoringSpaces) {
 873             ASSERT(lastWordBoundary == i);
 874             lastWordBoundary++;
 875             continue;
 876         } else if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
 877             ASSERT(i &gt;= lastWordBoundary);
 878             currMaxWidth += widthFromCache(font, lastWordBoundary, i - lastWordBoundary, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 879             if (!firstGlyphLeftOverflow)
 880                 firstGlyphLeftOverflow = glyphOverflow.left;
 881             lastWordBoundary = i + 1;
 882             continue;
 883         }
 884 
<span class="line-modified"> 885         bool hasBreak = breakAll || isBreakable(breakIterator, i, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords);</span>
 886         bool betweenWords = true;
 887         unsigned j = i;
 888         while (c != &#39;\n&#39; &amp;&amp; !isSpaceAccordingToStyle(c, style) &amp;&amp; c != &#39;\t&#39; &amp;&amp; (c != softHyphen || style.hyphens() == Hyphens::None)) {
 889             j++;
 890             if (j == length)
 891                 break;
 892             c = string[j];
<span class="line-modified"> 893             if (isBreakable(breakIterator, j, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords) &amp;&amp; characterAt(j - 1) != softHyphen)</span>
 894                 break;
 895             if (breakAll) {
 896                 betweenWords = false;
 897                 break;
 898             }
 899         }
 900 
 901         unsigned wordLen = j - i;
 902         if (wordLen) {
 903             float currMinWidth = 0;
 904             bool isSpace = (j &lt; length) &amp;&amp; isSpaceAccordingToStyle(c, style);
 905             float w;
 906             Optional&lt;float&gt; wordTrailingSpaceWidth;
 907             if (isSpace)
 908                 wordTrailingSpaceWidth = wordTrailingSpace.width(fallbackFonts);
 909             if (wordTrailingSpaceWidth)
 910                 w = widthFromCache(font, i, wordLen + 1, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style) - wordTrailingSpaceWidth.value();
 911             else {
 912                 w = widthFromCache(font, i, wordLen, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 913                 if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None)
</pre>
<hr />
<pre>
1296     if (!m_useBackslashAsYenSymbol || style().textSecurity() != TextSecurity::None)
1297         return text();
1298 
1299     if (style().textTransform() == TextTransform::None)
1300         return originalText();
1301 
1302     return applyTextTransform(style(), originalText(), previousCharacter());
1303 }
1304 
1305 void RenderText::dirtyLineBoxes(bool fullLayout)
1306 {
1307     if (fullLayout)
1308         m_lineBoxes.deleteAll();
1309     else if (!m_linesDirty)
1310         m_lineBoxes.dirtyAll();
1311     m_linesDirty = false;
1312 }
1313 
1314 std::unique_ptr&lt;InlineTextBox&gt; RenderText::createTextBox()
1315 {
<span class="line-modified">1316     return std::make_unique&lt;InlineTextBox&gt;(*this);</span>
1317 }
1318 
1319 void RenderText::positionLineBox(InlineTextBox&amp; textBox)
1320 {
1321     if (!textBox.hasTextContent())
1322         return;
1323     m_containsReversedText |= !textBox.isLeftToRightDirection();
1324 }
1325 
1326 void RenderText::ensureLineBoxes()
1327 {
1328     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1329         return;
1330     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
1331 }
1332 
1333 const SimpleLineLayout::Layout* RenderText::simpleLineLayout() const
1334 {
1335     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1336         return nullptr;
</pre>
<hr />
<pre>
1474     if (auto* layout = simpleLineLayout())
1475         return SimpleLineLayout::findCaretMinimumOffset(*this, *layout);
1476     return m_lineBoxes.caretMinOffset();
1477 }
1478 
1479 int RenderText::caretMaxOffset() const
1480 {
1481     if (auto* layout = simpleLineLayout())
1482         return SimpleLineLayout::findCaretMaximumOffset(*this, *layout);
1483     return m_lineBoxes.caretMaxOffset(*this);
1484 }
1485 
1486 unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
1487 {
1488     ASSERT(!simpleLineLayout());
1489     return m_lineBoxes.countCharacterOffsetsUntil(offset);
1490 }
1491 
1492 bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
1493 {
<span class="line-modified">1494     ASSERT(!simpleLineLayout());</span>

1495     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CharacterOffset);
1496 }
1497 
1498 bool RenderText::containsCaretOffset(unsigned offset) const
1499 {
1500     if (auto* layout = simpleLineLayout())
<span class="line-modified">1501         return SimpleLineLayout::containsCaretOffset(*this, *layout, offset);</span>
1502     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CaretOffset);
1503 }
1504 
1505 bool RenderText::hasRenderedText() const
1506 {
1507     if (auto* layout = simpleLineLayout())
1508         return SimpleLineLayout::isTextRendered(*this, *layout);
1509     return m_lineBoxes.hasRenderedText();
1510 }
1511 
1512 int RenderText::previousOffset(int current) const
1513 {
1514     if (m_isAllASCII || text().is8Bit())
1515         return current - 1;
1516 
1517     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1518     return iterator.preceding(current).valueOr(current - 1);
1519 }
1520 
1521 int RenderText::previousOffsetForBackwardDeletion(int current) const
</pre>
<hr />
<pre>
1529     if (m_isAllASCII || text().is8Bit())
1530         return current + 1;
1531 
1532     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1533     return iterator.following(current).valueOr(current + 1);
1534 }
1535 
1536 bool RenderText::computeCanUseSimpleFontCodePath() const
1537 {
1538     if (m_isAllASCII || text().is8Bit())
1539         return true;
1540     return FontCascade::characterRangeCodePath(text().characters16(), length()) == FontCascade::Simple;
1541 }
1542 
1543 void RenderText::momentarilyRevealLastTypedCharacter(unsigned offsetAfterLastTypedCharacter)
1544 {
1545     if (style().textSecurity() == TextSecurity::None)
1546         return;
1547     auto&amp; secureTextTimer = secureTextTimers().add(this, nullptr).iterator-&gt;value;
1548     if (!secureTextTimer)
<span class="line-modified">1549         secureTextTimer = std::make_unique&lt;SecureTextTimer&gt;(*this);</span>
1550     secureTextTimer-&gt;restart(offsetAfterLastTypedCharacter);
1551 }
1552 
1553 StringView RenderText::stringView(unsigned start, Optional&lt;unsigned&gt; stop) const
1554 {
1555     unsigned destination = stop.valueOr(text().length());
1556     ASSERT(start &lt;= length());
1557     ASSERT(destination &lt;= length());
1558     ASSERT(start &lt;= destination);
1559     if (text().is8Bit())
1560         return { text().characters8() + start, destination - start };
1561     return { text().characters16() + start, destination - start };
1562 }
1563 
1564 RenderInline* RenderText::inlineWrapperForDisplayContents()
1565 {
1566     ASSERT(m_hasInlineWrapperForDisplayContents == inlineWrapperForDisplayContentsMap().contains(this));
1567 
1568     if (!m_hasInlineWrapperForDisplayContents)
1569         return nullptr;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * (C) 2000 Dirk Mueller (mueller@kde.org)
<span class="line-modified">   4  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   5  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
</pre>
<hr />
<pre>
  34 #include &quot;FloatQuad.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;Hyphenation.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
  40 #include &quot;Range.h&quot;
  41 #include &quot;RenderBlock.h&quot;
  42 #include &quot;RenderCombineText.h&quot;
  43 #include &quot;RenderInline.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderView.h&quot;
  46 #include &quot;RenderedDocumentMarker.h&quot;
  47 #include &quot;Settings.h&quot;
  48 #include &quot;SimpleLineLayoutFunctions.h&quot;
  49 #include &quot;Text.h&quot;
  50 #include &quot;TextResourceDecoder.h&quot;
  51 #include &quot;VisiblePosition.h&quot;
  52 #include &lt;wtf/IsoMallocInlines.h&gt;
  53 #include &lt;wtf/NeverDestroyed.h&gt;

  54 #include &lt;wtf/text/StringBuilder.h&gt;
  55 #include &lt;wtf/text/TextBreakIterator.h&gt;
  56 #include &lt;wtf/unicode/CharacterNames.h&gt;
  57 
  58 #if PLATFORM(IOS_FAMILY)
  59 #include &quot;Document.h&quot;
  60 #include &quot;EditorClient.h&quot;
  61 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  62 #include &quot;Page.h&quot;
  63 #include &quot;SelectionRect.h&quot;
  64 #endif
  65 
  66 namespace WebCore {
  67 
  68 using namespace WTF::Unicode;
  69 
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderText);
  71 
  72 struct SameSizeAsRenderText : public RenderObject {
  73     void* pointers[2];
</pre>
<hr />
<pre>
 123 
 124 void SecureTextTimer::fired()
 125 {
 126     ASSERT(secureTextTimers().get(&amp;m_renderer) == this);
 127     m_offsetAfterLastTypedCharacter = 0;
 128     m_renderer.setText(m_renderer.text(), true /* forcing setting text as it may be masked later */);
 129 }
 130 
 131 static HashMap&lt;const RenderText*, String&gt;&amp; originalTextMap()
 132 {
 133     static NeverDestroyed&lt;HashMap&lt;const RenderText*, String&gt;&gt; map;
 134     return map;
 135 }
 136 
 137 static HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&amp; inlineWrapperForDisplayContentsMap()
 138 {
 139     static NeverDestroyed&lt;HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&gt; map;
 140     return map;
 141 }
 142 
<span class="line-modified"> 143 static constexpr UChar convertNoBreakSpaceToSpace(UChar character)</span>
 144 {
<span class="line-modified"> 145     return character == noBreakSpace ? &#39; &#39; : character;</span>
<span class="line-added"> 146 }</span>
 147 
<span class="line-modified"> 148 String capitalize(const String&amp; string, UChar previousCharacter)</span>
<span class="line-modified"> 149 {</span>
<span class="line-added"> 150     // FIXME: Change this to use u_strToTitle instead of u_totitle and to consider locale.</span>
 151 
 152     unsigned length = string.length();
 153     auto&amp; stringImpl = *string.impl();
 154 
<span class="line-modified"> 155     static_assert(String::MaxLength &lt; std::numeric_limits&lt;unsigned&gt;::max(), &quot;Must be able to add one without overflowing unsigned&quot;);</span>

 156 
<span class="line-modified"> 157     // Replace NO BREAK SPACE with a normal spaces since ICU does not treat it as a word separator.</span>
<span class="line-modified"> 158     Vector&lt;UChar&gt; stringWithPrevious(length + 1);</span>
<span class="line-modified"> 159     stringWithPrevious[0] = convertNoBreakSpaceToSpace(previousCharacter);</span>
<span class="line-modified"> 160     for (unsigned i = 1; i &lt; length + 1; i++)</span>
<span class="line-modified"> 161         stringWithPrevious[i] = convertNoBreakSpaceToSpace(stringImpl[i - 1]);</span>




 162 
<span class="line-modified"> 163     auto* breakIterator = wordBreakIterator(StringView { stringWithPrevious.data(), length + 1 });</span>
<span class="line-modified"> 164     if (!breakIterator)</span>
 165         return string;
 166 
 167     StringBuilder result;
 168     result.reserveCapacity(length);
 169 
<span class="line-added"> 170     int32_t startOfWord = ubrk_first(breakIterator);</span>
 171     int32_t endOfWord;
<span class="line-modified"> 172     for (endOfWord = ubrk_next(breakIterator); endOfWord != UBRK_DONE; startOfWord = endOfWord, endOfWord = ubrk_next(breakIterator)) {</span>
<span class="line-modified"> 173         if (startOfWord) // Do not append the first character, since it&#39;s the previous character, not from this string.</span>
<span class="line-modified"> 174             result.appendCharacter(u_totitle(stringImpl[startOfWord - 1]));</span>

 175         for (int i = startOfWord + 1; i &lt; endOfWord; i++)
 176             result.append(stringImpl[i - 1]);
 177     }
 178 
<span class="line-modified"> 179     return result == string ? string : result.toString();</span>
 180 }
 181 
 182 inline RenderText::RenderText(Node&amp; node, const String&amp; text)
 183     : RenderObject(node)
 184     , m_hasTab(false)
 185     , m_linesDirty(false)
 186     , m_containsReversedText(false)
 187     , m_isAllASCII(text.impl()-&gt;isAllASCII())
 188     , m_knownToHaveNoOverflowAndNoFallbackFonts(false)
 189     , m_useBackslashAsYenSymbol(false)
 190     , m_originalTextDiffersFromRendered(false)
 191     , m_hasInlineWrapperForDisplayContents(false)
 192     , m_text(text)
 193 {
 194     ASSERT(!m_text.isNull());
 195     setIsText();
 196     m_canUseSimpleFontCodePath = computeCanUseSimpleFontCodePath();
 197 
 198     // FIXME: Find out how to increment the visually non empty character count when the font becomes available.
 199     auto isTextVisible = false;
</pre>
<hr />
<pre>
 363         // Note, box-&gt;end() returns the index of the last character, not the index past it.
 364         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end)
 365             rect = box-&gt;localSelectionRect(start, end);
 366         else {
 367             unsigned realEnd = std::min(box-&gt;end() + 1, end);
 368             rect = box-&gt;localSelectionRect(start, realEnd);
 369             if (rect.isEmpty())
 370                 continue;
 371         }
 372 
 373         if (box-&gt;root().isFirstAfterPageBreak()) {
 374             if (box-&gt;isHorizontal())
 375                 rect.shiftYEdgeTo(box-&gt;root().lineTopWithLeading());
 376             else
 377                 rect.shiftXEdgeTo(box-&gt;root().lineTopWithLeading());
 378         }
 379 
 380         RenderBlock* containingBlock = this-&gt;containingBlock();
 381         // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
 382         LogicalSelectionOffsetCaches cache(*containingBlock);
<span class="line-modified"> 383         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);</span>
<span class="line-modified"> 384         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);</span>
 385         LayoutRect extentsRect = rect;
 386         if (box-&gt;isHorizontal()) {
 387             extentsRect.setX(leftOffset);
 388             extentsRect.setWidth(rightOffset - leftOffset);
 389         } else {
 390             extentsRect.setY(leftOffset);
 391             extentsRect.setHeight(rightOffset - leftOffset);
 392         }
 393         extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
 394         if (!box-&gt;isHorizontal())
 395             extentsRect = extentsRect.transposedRect();
 396         bool isFirstOnLine = !box-&gt;previousOnLineExists();
 397         bool isLastOnLine = !box-&gt;nextOnLineExists();
 398         if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
 399             isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 400 
 401         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() + 1 &gt;= start;
 402         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() + 1 &gt;= end;
 403 
 404         bool isFixed = false;
</pre>
<hr />
<pre>
 689 {
 690     if (preferredLogicalWidthsDirty())
 691         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 692 
 693     return m_minWidth;
 694 }
 695 
 696 float RenderText::maxLogicalWidth() const
 697 {
 698     if (preferredLogicalWidthsDirty())
 699         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 700 
 701     return m_maxWidth;
 702 }
 703 
 704 LineBreakIteratorMode mapLineBreakToIteratorMode(LineBreak lineBreak)
 705 {
 706     switch (lineBreak) {
 707     case LineBreak::Auto:
 708     case LineBreak::AfterWhiteSpace:
<span class="line-added"> 709     case LineBreak::Anywhere:</span>
 710         return LineBreakIteratorMode::Default;
 711     case LineBreak::Loose:
 712         return LineBreakIteratorMode::Loose;
 713     case LineBreak::Normal:
 714         return LineBreakIteratorMode::Normal;
 715     case LineBreak::Strict:
 716         return LineBreakIteratorMode::Strict;
 717     }
 718     ASSERT_NOT_REACHED();
 719     return LineBreakIteratorMode::Default;
 720 }
 721 
 722 void RenderText::computePreferredLogicalWidths(float leadWidth)
 723 {
 724     HashSet&lt;const Font*&gt; fallbackFonts;
 725     GlyphOverflow glyphOverflow;
 726     computePreferredLogicalWidths(leadWidth, fallbackFonts, glyphOverflow);
 727     if (fallbackFonts.isEmpty() &amp;&amp; !glyphOverflow.left &amp;&amp; !glyphOverflow.right &amp;&amp; !glyphOverflow.top &amp;&amp; !glyphOverflow.bottom)
 728         m_knownToHaveNoOverflowAndNoFallbackFonts = true;
 729 }
</pre>
<hr />
<pre>
 814     unsigned minimumPrefixLength = 0;
 815     unsigned minimumSuffixLength = 0;
 816     if (style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale())) {
 817         maxWordWidth = 0;
 818 
 819         // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 820         auto before = style.hyphenationLimitBefore();
 821         minimumPrefixLength = before &lt; 0 ? 2 : before;
 822 
 823         auto after = style.hyphenationLimitAfter();
 824         minimumSuffixLength = after &lt; 0 ? 2 : after;
 825     }
 826 
 827     Optional&lt;int&gt; firstGlyphLeftOverflow;
 828 
 829     bool breakNBSP = style.autoWrap() &amp;&amp; style.nbspMode() == NBSPMode::Space;
 830 
 831     // Note the deliberate omission of word-wrap and overflow-wrap from this breakAll check. Those
 832     // do not affect minimum preferred sizes. Note that break-word is a non-standard value for
 833     // word-break, but we support it as though it means break-all.
<span class="line-added"> 834     bool breakAnywhere = style.lineBreak() == LineBreak::Anywhere &amp;&amp; style.autoWrap();</span>
 835     bool breakAll = (style.wordBreak() == WordBreak::BreakAll || style.wordBreak() == WordBreak::BreakWord) &amp;&amp; style.autoWrap();
 836     bool keepAllWords = style.wordBreak() == WordBreak::KeepAll;
 837     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 838 
 839     for (unsigned i = 0; i &lt; length; i++) {
 840         UChar c = string[i];
 841 
 842         bool previousCharacterIsSpace = isSpace;
 843 
 844         bool isNewline = false;
 845         if (c == &#39;\n&#39;) {
 846             if (style.preserveNewline()) {
 847                 m_hasBreak = true;
 848                 isNewline = true;
 849                 isSpace = false;
 850             } else
 851                 isSpace = true;
 852         } else if (c == &#39;\t&#39;) {
 853             if (!style.collapseWhiteSpace()) {
 854                 m_hasTab = true;
</pre>
<hr />
<pre>
 863         if ((isSpace || isNewline) &amp;&amp; i == length - 1)
 864             m_hasEndWS = true;
 865 
 866         ignoringSpaces |= style.collapseWhiteSpace() &amp;&amp; previousCharacterIsSpace &amp;&amp; isSpace;
 867         ignoringSpaces &amp;= isSpace;
 868 
 869         // Ignore spaces and soft hyphens
 870         if (ignoringSpaces) {
 871             ASSERT(lastWordBoundary == i);
 872             lastWordBoundary++;
 873             continue;
 874         } else if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
 875             ASSERT(i &gt;= lastWordBoundary);
 876             currMaxWidth += widthFromCache(font, lastWordBoundary, i - lastWordBoundary, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 877             if (!firstGlyphLeftOverflow)
 878                 firstGlyphLeftOverflow = glyphOverflow.left;
 879             lastWordBoundary = i + 1;
 880             continue;
 881         }
 882 
<span class="line-modified"> 883         bool hasBreak = breakAll || isBreakable(breakIterator, i, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords, breakAnywhere);</span>
 884         bool betweenWords = true;
 885         unsigned j = i;
 886         while (c != &#39;\n&#39; &amp;&amp; !isSpaceAccordingToStyle(c, style) &amp;&amp; c != &#39;\t&#39; &amp;&amp; (c != softHyphen || style.hyphens() == Hyphens::None)) {
 887             j++;
 888             if (j == length)
 889                 break;
 890             c = string[j];
<span class="line-modified"> 891             if (isBreakable(breakIterator, j, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords, breakAnywhere) &amp;&amp; characterAt(j - 1) != softHyphen)</span>
 892                 break;
 893             if (breakAll) {
 894                 betweenWords = false;
 895                 break;
 896             }
 897         }
 898 
 899         unsigned wordLen = j - i;
 900         if (wordLen) {
 901             float currMinWidth = 0;
 902             bool isSpace = (j &lt; length) &amp;&amp; isSpaceAccordingToStyle(c, style);
 903             float w;
 904             Optional&lt;float&gt; wordTrailingSpaceWidth;
 905             if (isSpace)
 906                 wordTrailingSpaceWidth = wordTrailingSpace.width(fallbackFonts);
 907             if (wordTrailingSpaceWidth)
 908                 w = widthFromCache(font, i, wordLen + 1, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style) - wordTrailingSpaceWidth.value();
 909             else {
 910                 w = widthFromCache(font, i, wordLen, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 911                 if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None)
</pre>
<hr />
<pre>
1294     if (!m_useBackslashAsYenSymbol || style().textSecurity() != TextSecurity::None)
1295         return text();
1296 
1297     if (style().textTransform() == TextTransform::None)
1298         return originalText();
1299 
1300     return applyTextTransform(style(), originalText(), previousCharacter());
1301 }
1302 
1303 void RenderText::dirtyLineBoxes(bool fullLayout)
1304 {
1305     if (fullLayout)
1306         m_lineBoxes.deleteAll();
1307     else if (!m_linesDirty)
1308         m_lineBoxes.dirtyAll();
1309     m_linesDirty = false;
1310 }
1311 
1312 std::unique_ptr&lt;InlineTextBox&gt; RenderText::createTextBox()
1313 {
<span class="line-modified">1314     return makeUnique&lt;InlineTextBox&gt;(*this);</span>
1315 }
1316 
1317 void RenderText::positionLineBox(InlineTextBox&amp; textBox)
1318 {
1319     if (!textBox.hasTextContent())
1320         return;
1321     m_containsReversedText |= !textBox.isLeftToRightDirection();
1322 }
1323 
1324 void RenderText::ensureLineBoxes()
1325 {
1326     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1327         return;
1328     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
1329 }
1330 
1331 const SimpleLineLayout::Layout* RenderText::simpleLineLayout() const
1332 {
1333     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1334         return nullptr;
</pre>
<hr />
<pre>
1472     if (auto* layout = simpleLineLayout())
1473         return SimpleLineLayout::findCaretMinimumOffset(*this, *layout);
1474     return m_lineBoxes.caretMinOffset();
1475 }
1476 
1477 int RenderText::caretMaxOffset() const
1478 {
1479     if (auto* layout = simpleLineLayout())
1480         return SimpleLineLayout::findCaretMaximumOffset(*this, *layout);
1481     return m_lineBoxes.caretMaxOffset(*this);
1482 }
1483 
1484 unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
1485 {
1486     ASSERT(!simpleLineLayout());
1487     return m_lineBoxes.countCharacterOffsetsUntil(offset);
1488 }
1489 
1490 bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
1491 {
<span class="line-modified">1492     if (auto* layout = simpleLineLayout())</span>
<span class="line-added">1493         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CharacterOffset);</span>
1494     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CharacterOffset);
1495 }
1496 
1497 bool RenderText::containsCaretOffset(unsigned offset) const
1498 {
1499     if (auto* layout = simpleLineLayout())
<span class="line-modified">1500         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CaretOffset);</span>
1501     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CaretOffset);
1502 }
1503 
1504 bool RenderText::hasRenderedText() const
1505 {
1506     if (auto* layout = simpleLineLayout())
1507         return SimpleLineLayout::isTextRendered(*this, *layout);
1508     return m_lineBoxes.hasRenderedText();
1509 }
1510 
1511 int RenderText::previousOffset(int current) const
1512 {
1513     if (m_isAllASCII || text().is8Bit())
1514         return current - 1;
1515 
1516     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1517     return iterator.preceding(current).valueOr(current - 1);
1518 }
1519 
1520 int RenderText::previousOffsetForBackwardDeletion(int current) const
</pre>
<hr />
<pre>
1528     if (m_isAllASCII || text().is8Bit())
1529         return current + 1;
1530 
1531     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1532     return iterator.following(current).valueOr(current + 1);
1533 }
1534 
1535 bool RenderText::computeCanUseSimpleFontCodePath() const
1536 {
1537     if (m_isAllASCII || text().is8Bit())
1538         return true;
1539     return FontCascade::characterRangeCodePath(text().characters16(), length()) == FontCascade::Simple;
1540 }
1541 
1542 void RenderText::momentarilyRevealLastTypedCharacter(unsigned offsetAfterLastTypedCharacter)
1543 {
1544     if (style().textSecurity() == TextSecurity::None)
1545         return;
1546     auto&amp; secureTextTimer = secureTextTimers().add(this, nullptr).iterator-&gt;value;
1547     if (!secureTextTimer)
<span class="line-modified">1548         secureTextTimer = makeUnique&lt;SecureTextTimer&gt;(*this);</span>
1549     secureTextTimer-&gt;restart(offsetAfterLastTypedCharacter);
1550 }
1551 
1552 StringView RenderText::stringView(unsigned start, Optional&lt;unsigned&gt; stop) const
1553 {
1554     unsigned destination = stop.valueOr(text().length());
1555     ASSERT(start &lt;= length());
1556     ASSERT(destination &lt;= length());
1557     ASSERT(start &lt;= destination);
1558     if (text().is8Bit())
1559         return { text().characters8() + start, destination - start };
1560     return { text().characters16() + start, destination - start };
1561 }
1562 
1563 RenderInline* RenderText::inlineWrapperForDisplayContents()
1564 {
1565     ASSERT(m_hasInlineWrapperForDisplayContents == inlineWrapperForDisplayContentsMap().contains(this));
1566 
1567     if (!m_hasInlineWrapperForDisplayContents)
1568         return nullptr;
</pre>
</td>
</tr>
</table>
<center><a href="RenderTableSection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTextControlMultiLine.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>