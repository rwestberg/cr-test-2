<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NumericStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyChangeAdaptiveWatchpoint.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2008-2017 Apple Inc. All rights reserved.</span>
   4  *
   5  *  This library is free software; you can redistribute it and/or
   6  *  modify it under the terms of the GNU Lesser General Public
   7  *  License as published by the Free Software Foundation; either
   8  *  version 2 of the License, or (at your option) any later version.
   9  *
  10  *  This library is distributed in the hope that it will be useful,
  11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  *  Lesser General Public License for more details.
  14  *
  15  *  You should have received a copy of the GNU Lesser General Public
  16  *  License along with this library; if not, write to the Free Software
  17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  18  *
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 #include &quot;ObjectConstructor.h&quot;
  23 
</pre>
<hr />
<pre>
  86   isExtensible              objectConstructorIsExtensible               DontEnum|Function 1
  87   is                        objectConstructorIs                         DontEnum|Function 2 ObjectIsIntrinsic
  88   assign                    objectConstructorAssign                     DontEnum|Function 2
  89   values                    objectConstructorValues                     DontEnum|Function 1
  90   entries                   JSBuiltin                                   DontEnum|Function 1
  91   fromEntries               JSBuiltin                                   DontEnum|Function 1
  92 @end
  93 */
  94 
  95 
  96 static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState*);
  97 static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState*);
  98 
  99 ObjectConstructor::ObjectConstructor(VM&amp; vm, Structure* structure)
 100     : InternalFunction(vm, structure, callObjectConstructor, constructWithObjectConstructor)
 101 {
 102 }
 103 
 104 void ObjectConstructor::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, ObjectPrototype* objectPrototype)
 105 {
<span class="line-modified"> 106     Base::finishCreation(vm, objectPrototype-&gt;classInfo(vm)-&gt;className);</span>
 107 
 108     putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, objectPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
 109     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 110 
 111     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().createPrivateName(), objectConstructorCreate, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 112     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().definePropertyPrivateName(), objectConstructorDefineProperty, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 3);
 113     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getPrototypeOfPrivateName(), objectConstructorGetPrototypeOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 114     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getOwnPropertyNamesPrivateName(), objectConstructorGetOwnPropertyNames, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 115 }
 116 
 117 // ES 19.1.1.1 Object([value])
 118 static ALWAYS_INLINE JSObject* constructObject(ExecState* exec, JSValue newTarget)
 119 {
 120     VM&amp; vm = exec-&gt;vm();
 121     ObjectConstructor* objectConstructor = jsCast&lt;ObjectConstructor*&gt;(exec-&gt;jsCallee());
 122     JSGlobalObject* globalObject = objectConstructor-&gt;globalObject(vm);
 123     auto scope = DECLARE_THROW_SCOPE(vm);
 124 
 125     // We need to check newTarget condition in this caller side instead of InternalFunction::createSubclassStructure side.
 126     // Since if we found this condition is met, we should not fall into the type conversion in the step 3.
</pre>
<hr />
<pre>
 187 JSValue objectConstructorGetOwnPropertyDescriptor(ExecState* exec, JSObject* object, const Identifier&amp; propertyName)
 188 {
 189     VM&amp; vm = exec-&gt;vm();
 190     auto scope = DECLARE_THROW_SCOPE(vm);
 191     PropertyDescriptor descriptor;
 192     if (!object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))
 193         RELEASE_AND_RETURN(scope, jsUndefined());
 194     RETURN_IF_EXCEPTION(scope, { });
 195 
 196     JSObject* result = constructObjectFromPropertyDescriptor(exec, descriptor);
 197     EXCEPTION_ASSERT(!!scope.exception() == !result);
 198     if (!result)
 199         return jsUndefined();
 200     return result;
 201 }
 202 
 203 JSValue objectConstructorGetOwnPropertyDescriptors(ExecState* exec, JSObject* object)
 204 {
 205     VM&amp; vm = exec-&gt;vm();
 206     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 207     PropertyNameArray properties(&amp;vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 208     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 209     RETURN_IF_EXCEPTION(scope, { });
 210 
 211     JSObject* descriptors = constructEmptyObject(exec);
 212     RETURN_IF_EXCEPTION(scope, { });
 213 
 214     for (auto&amp; propertyName : properties) {
 215         PropertyDescriptor descriptor;
 216         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 217         RETURN_IF_EXCEPTION(scope, { });
 218 
 219         if (!didGetDescriptor)
 220             continue;
 221 
 222         JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(exec, descriptor);
 223         EXCEPTION_ASSERT(!!scope.exception() == !fromDescriptor);
 224         if (!fromDescriptor)
 225             return jsUndefined();
 226 
 227         PutPropertySlot slot(descriptors);
</pre>
<hr />
<pre>
 356                     properties.append(entry.key);
 357                     values.appendWithCrashOnOverflow(source-&gt;getDirect(entry.offset));
 358 
 359                     return true;
 360                 });
 361 
 362                 for (size_t i = 0; i &lt; properties.size(); ++i) {
 363                     // FIXME: We could put properties in a batching manner to accelerate Object.assign more.
 364                     // https://bugs.webkit.org/show_bug.cgi?id=185358
 365                     PutPropertySlot putPropertySlot(target, true);
 366                     target-&gt;putOwnDataProperty(vm, properties[i].get(), values.at(i), putPropertySlot);
 367                 }
 368                 continue;
 369             }
 370         }
 371 
 372         // [[GetOwnPropertyNames]], [[Get]] etc. could modify target object and invalidate this assumption.
 373         // For example, [[Get]] of source object could configure setter to target object. So disable the fast path.
 374         targetCanPerformFastPut = false;
 375 
<span class="line-modified"> 376         PropertyNameArray properties(&amp;vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 377         source-&gt;methodTable(vm)-&gt;getOwnPropertyNames(source, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 378         RETURN_IF_EXCEPTION(scope, { });
 379 
 380         auto assign = [&amp;] (PropertyName propertyName) {
 381             PropertySlot slot(source, PropertySlot::InternalMethodType::GetOwnProperty);
 382             bool hasProperty = source-&gt;methodTable(vm)-&gt;getOwnPropertySlot(source, exec, propertyName, slot);
 383             RETURN_IF_EXCEPTION(scope, void());
 384             if (!hasProperty)
 385                 return;
 386             if (slot.attributes() &amp; PropertyAttribute::DontEnum)
 387                 return;
 388 
 389             JSValue value;
 390             if (LIKELY(!slot.isTaintedByOpaqueObject()))
 391                 value = slot.getValue(exec, propertyName);
 392             else
 393                 value = source-&gt;get(exec, propertyName);
 394             RETURN_IF_EXCEPTION(scope, void());
 395 
 396             PutPropertySlot putPropertySlot(target, true);
</pre>
<hr />
<pre>
 423             }
 424         }
 425     }
 426     return JSValue::encode(target);
 427 }
 428 
 429 EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState* exec)
 430 {
 431     VM&amp; vm = exec-&gt;vm();
 432     auto scope = DECLARE_THROW_SCOPE(vm);
 433 
 434     JSValue targetValue = exec-&gt;argument(0);
 435     if (targetValue.isUndefinedOrNull())
 436         return throwVMTypeError(exec, scope, &quot;Object.values requires that input parameter not be null or undefined&quot;_s);
 437     JSObject* target = targetValue.toObject(exec);
 438     RETURN_IF_EXCEPTION(scope, { });
 439 
 440     JSArray* values = constructEmptyArray(exec, nullptr);
 441     RETURN_IF_EXCEPTION(scope, { });
 442 
<span class="line-modified"> 443     PropertyNameArray properties(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
 444     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 445     RETURN_IF_EXCEPTION(scope, { });
 446 
 447     unsigned index = 0;
 448     auto addValue = [&amp;] (PropertyName propertyName) {
 449         PropertySlot slot(target, PropertySlot::InternalMethodType::GetOwnProperty);
 450         bool hasProperty = target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 451         RETURN_IF_EXCEPTION(scope, void());
 452         if (!hasProperty)
 453             return;
 454         if (slot.attributes() &amp; PropertyAttribute::DontEnum)
 455             return;
 456 
 457         JSValue value;
 458         if (LIKELY(!slot.isTaintedByOpaqueObject()))
 459             value = slot.getValue(exec, propertyName);
 460         else
 461             value = target-&gt;get(exec, propertyName);
 462         RETURN_IF_EXCEPTION(scope, void());
 463 
</pre>
<hr />
<pre>
 583         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);
 584     JSObject* obj = asObject(exec-&gt;argument(0));
 585     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);
 586     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 587     PropertyDescriptor descriptor;
 588     auto success = toPropertyDescriptor(exec, exec-&gt;argument(2), descriptor);
 589     EXCEPTION_ASSERT(!scope.exception() == success);
 590     if (!success)
 591         return JSValue::encode(jsNull());
 592     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
 593     scope.assertNoException();
 594     obj-&gt;methodTable(vm)-&gt;defineOwnProperty(obj, exec, propertyName, descriptor, true);
 595     RELEASE_AND_RETURN(scope, JSValue::encode(obj));
 596 }
 597 
 598 static JSValue defineProperties(ExecState* exec, JSObject* object, JSObject* properties)
 599 {
 600     VM&amp; vm = exec-&gt;vm();
 601     auto scope = DECLARE_THROW_SCOPE(vm);
 602 
<span class="line-modified"> 603     PropertyNameArray propertyNames(&amp;vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 604     asObject(properties)-&gt;methodTable(vm)-&gt;getOwnPropertyNames(asObject(properties), exec, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));
 605     RETURN_IF_EXCEPTION(scope, { });
 606     size_t numProperties = propertyNames.size();
 607     Vector&lt;PropertyDescriptor&gt; descriptors;
 608     MarkedArgumentBuffer markBuffer;






 609     for (size_t i = 0; i &lt; numProperties; i++) {
 610         JSValue prop = properties-&gt;get(exec, propertyNames[i]);
<span class="line-modified"> 611         RETURN_IF_EXCEPTION(scope, { });</span>
 612         PropertyDescriptor descriptor;
<span class="line-modified"> 613         bool success = toPropertyDescriptor(exec, prop, descriptor);</span>
<span class="line-modified"> 614         EXCEPTION_ASSERT(!scope.exception() || !success);</span>
<span class="line-removed"> 615         if (UNLIKELY(!success)) {</span>
<span class="line-removed"> 616             markBuffer.overflowCheckNotNeeded();</span>
<span class="line-removed"> 617             return jsNull();</span>
<span class="line-removed"> 618         }</span>
 619         descriptors.append(descriptor);
 620         // Ensure we mark all the values that we&#39;re accumulating
 621         if (descriptor.isDataDescriptor() &amp;&amp; descriptor.value())
 622             markBuffer.append(descriptor.value());
 623         if (descriptor.isAccessorDescriptor()) {
 624             if (descriptor.getter())
 625                 markBuffer.append(descriptor.getter());
 626             if (descriptor.setter())
 627                 markBuffer.append(descriptor.setter());
 628         }
 629     }
 630     RELEASE_ASSERT(!markBuffer.hasOverflowed());

 631     for (size_t i = 0; i &lt; numProperties; i++) {
 632         auto&amp; propertyName = propertyNames[i];
 633         ASSERT(!propertyName.isPrivateName());
 634 
 635         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, exec, propertyName, descriptors[i], true);
 636         RETURN_IF_EXCEPTION(scope, { });
 637     }
 638     return object;
 639 }
 640 
 641 EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState* exec)
 642 {
 643     VM&amp; vm = exec-&gt;vm();
 644     auto scope = DECLARE_THROW_SCOPE(vm);
 645 
 646     if (!exec-&gt;argument(0).isObject())
 647         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);
 648     JSObject* targetObj = asObject(exec-&gt;argument(0));
 649     JSObject* props = exec-&gt;argument(1).toObject(exec);
 650     EXCEPTION_ASSERT(!!scope.exception() == !props);
 651     if (UNLIKELY(!props))
 652         return encodedJSValue();
 653     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, targetObj, props)));
 654 }
 655 
 656 EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState* exec)
 657 {
 658     VM&amp; vm = exec-&gt;vm();
 659     auto scope = DECLARE_THROW_SCOPE(vm);
 660 
 661     JSValue proto = exec-&gt;argument(0);
 662     if (!proto.isObject() &amp;&amp; !proto.isNull())
 663         return throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);
 664     JSObject* newObject = proto.isObject()
 665         ? constructEmptyObject(exec, asObject(proto))
 666         : constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());
 667     if (exec-&gt;argument(1).isUndefined())
 668         return JSValue::encode(newObject);
<span class="line-modified"> 669     if (!exec-&gt;argument(1).isObject())</span>
<span class="line-modified"> 670         return throwVMTypeError(exec, scope, &quot;Property descriptor list must be an Object.&quot;_s);</span>
<span class="line-modified"> 671     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, newObject, asObject(exec-&gt;argument(1)))));</span>

 672 }
 673 
 674 enum class IntegrityLevel {
 675     Sealed,
 676     Frozen
 677 };
 678 
 679 template&lt;IntegrityLevel level&gt;
 680 bool setIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)
 681 {
 682     // See https://tc39.github.io/ecma262/#sec-setintegritylevel.
 683     auto scope = DECLARE_THROW_SCOPE(vm);
 684 
 685     bool success = object-&gt;methodTable(vm)-&gt;preventExtensions(object, exec);
 686     RETURN_IF_EXCEPTION(scope, false);
 687     if (UNLIKELY(!success))
 688         return false;
 689 
<span class="line-modified"> 690     PropertyNameArray properties(&amp;vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 691     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 692     RETURN_IF_EXCEPTION(scope, false);
 693 
 694     PropertyNameArray::const_iterator end = properties.end();
 695     for (PropertyNameArray::const_iterator iter = properties.begin(); iter != end; ++iter) {
 696         auto&amp; propertyName = *iter;
 697         ASSERT(!propertyName.isPrivateName());
 698 
 699         PropertyDescriptor desc;
 700         if (level == IntegrityLevel::Sealed)
 701             desc.setConfigurable(false);
 702         else {
 703             bool hasPropertyDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);
 704             RETURN_IF_EXCEPTION(scope, false);
 705             if (!hasPropertyDescriptor)
 706                 continue;
 707 
 708             if (desc.isDataDescriptor())
 709                 desc.setWritable(false);
 710 
</pre>
<hr />
<pre>
 717     return true;
 718 }
 719 
 720 template&lt;IntegrityLevel level&gt;
 721 bool testIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)
 722 {
 723     auto scope = DECLARE_THROW_SCOPE(vm);
 724 
 725     // 1. Assert: Type(O) is Object.
 726     // 2. Assert: level is either &quot;sealed&quot; or &quot;frozen&quot;.
 727 
 728     // 3. Let status be ?IsExtensible(O).
 729     bool status = object-&gt;isExtensible(exec);
 730     RETURN_IF_EXCEPTION(scope, { });
 731 
 732     // 4. If status is true, return false.
 733     if (status)
 734         return false;
 735 
 736     // 6. Let keys be ? O.[[OwnPropertyKeys]]().
<span class="line-modified"> 737     PropertyNameArray keys(&amp;vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 738     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, keys, EnumerationMode(DontEnumPropertiesMode::Include));
 739     RETURN_IF_EXCEPTION(scope, { });
 740 
 741     // 7. For each element k of keys, do
 742     PropertyNameArray::const_iterator end = keys.end();
 743     for (PropertyNameArray::const_iterator iter = keys.begin(); iter != end; ++iter) {
 744         auto&amp; propertyName = *iter;
 745         ASSERT(!propertyName.isPrivateName());
 746 
 747         // a. Let currentDesc be ? O.[[GetOwnProperty]](k)
 748         PropertyDescriptor desc;
 749         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);
 750         RETURN_IF_EXCEPTION(scope, { });
 751 
 752         // b. If currentDesc is not undefined, then
 753         if (!didGetDescriptor)
 754             continue;
 755 
 756         // i. If currentDesc.[[Configurable]] is true, return false.
 757         if (desc.configurable())
</pre>
<hr />
<pre>
 761         // 1. If currentDesc.[[Writable]] is true, return false.
 762         if (level == IntegrityLevel::Frozen &amp;&amp; desc.isDataDescriptor() &amp;&amp; desc.writable())
 763             return false;
 764     }
 765 
 766     return true;
 767 }
 768 
 769 JSObject* objectConstructorSeal(ExecState* exec, JSObject* object)
 770 {
 771     VM&amp; vm = exec-&gt;vm();
 772     auto scope = DECLARE_THROW_SCOPE(vm);
 773 
 774     if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
 775         object-&gt;seal(vm);
 776         return object;
 777     }
 778 
 779     bool success = setIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(exec, vm, object);
 780     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 781     if (UNLIKELY(!success))</span>
<span class="line-modified"> 782         return throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.seal&quot;_s);</span>


 783 
 784     return object;
 785 }
 786 
 787 EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState* exec)
 788 {
 789     VM&amp; vm = exec-&gt;vm();
 790     auto scope = DECLARE_THROW_SCOPE(vm);
 791 
 792     // 1. If Type(O) is not Object, return O.
 793     JSValue obj = exec-&gt;argument(0);
 794     if (!obj.isObject())
 795         return JSValue::encode(obj);
 796 
 797     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(exec, asObject(obj))));
 798 }
 799 
 800 JSObject* objectConstructorFreeze(ExecState* exec, JSObject* object)
 801 {
 802     VM&amp; vm = exec-&gt;vm();
 803     auto scope = DECLARE_THROW_SCOPE(vm);
 804 
 805     if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
 806         object-&gt;freeze(vm);
 807         return object;
 808     }
 809 
 810     bool success = setIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(exec, vm, object);
 811     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 812     if (!success)</span>
<span class="line-modified"> 813         return throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.freeze&quot;_s);</span>


 814     return object;
 815 }
 816 
 817 EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState* exec)
 818 {
 819     VM&amp; vm = exec-&gt;vm();
 820     auto scope = DECLARE_THROW_SCOPE(vm);
 821     // 1. If Type(O) is not Object, return O.
 822     JSValue obj = exec-&gt;argument(0);
 823     if (!obj.isObject())
 824         return JSValue::encode(obj);
 825     JSObject* result = objectConstructorFreeze(exec, asObject(obj));
 826     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 827     return JSValue::encode(result);
 828 }
 829 
 830 EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState* exec)
 831 {
 832     VM&amp; vm = exec-&gt;vm();
 833     JSValue argument = exec-&gt;argument(0);
</pre>
<hr />
<pre>
 892     return JSValue::encode(jsBoolean(sameValue(exec, exec-&gt;argument(0), exec-&gt;argument(1))));
 893 }
 894 
 895 JSArray* ownPropertyKeys(ExecState* exec, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)
 896 {
 897     VM&amp; vm = exec-&gt;vm();
 898     auto scope = DECLARE_THROW_SCOPE(vm);
 899 
 900     auto* globalObject = exec-&gt;lexicalGlobalObject();
 901     bool isObjectKeys = propertyNameMode == PropertyNameMode::Strings &amp;&amp; dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude;
 902     // We attempt to look up own property keys cache in Object.keys case.
 903     if (isObjectKeys) {
 904         if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
 905             if (auto* immutableButterfly = object-&gt;structure(vm)-&gt;cachedOwnKeys()) {
 906                 Structure* arrayStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
 907                 return JSArray::createWithButterfly(vm, nullptr, arrayStructure, immutableButterfly-&gt;toButterfly());
 908             }
 909         }
 910     }
 911 
<span class="line-modified"> 912     PropertyNameArray properties(&amp;vm, propertyNameMode, PrivateSymbolMode::Exclude);</span>
 913     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(dontEnumPropertiesMode));
 914     RETURN_IF_EXCEPTION(scope, nullptr);
 915 
<span class="line-removed"> 916     // https://tc39.github.io/ecma262/#sec-enumerableownproperties</span>
<span class="line-removed"> 917     // If {object} is a Proxy, an explicit and observable [[GetOwnProperty]] op is required to filter out non-enumerable properties.</span>
<span class="line-removed"> 918     // In other cases, filtering has already been performed.</span>
<span class="line-removed"> 919     const bool mustFilterProperty = dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude &amp;&amp; object-&gt;type() == ProxyObjectType;</span>
<span class="line-removed"> 920     auto filterPropertyIfNeeded = [exec, object, mustFilterProperty](const Identifier&amp; identifier) {</span>
<span class="line-removed"> 921         if (!mustFilterProperty)</span>
<span class="line-removed"> 922             return true;</span>
<span class="line-removed"> 923         PropertyDescriptor descriptor;</span>
<span class="line-removed"> 924         PropertyName name(identifier);</span>
<span class="line-removed"> 925         return object-&gt;getOwnPropertyDescriptor(exec, name, descriptor) &amp;&amp; descriptor.enumerable();</span>
<span class="line-removed"> 926     };</span>
<span class="line-removed"> 927 </span>
<span class="line-removed"> 928     // If !mustFilterProperty and PropertyNameMode::Strings mode, we do not need to filter out any entries in PropertyNameArray.</span>
<span class="line-removed"> 929     // We can use fast allocation and initialization.</span>
 930     if (propertyNameMode != PropertyNameMode::StringsAndSymbols) {
 931         ASSERT(propertyNameMode == PropertyNameMode::Strings || propertyNameMode == PropertyNameMode::Symbols);
<span class="line-modified"> 932         if (!mustFilterProperty &amp;&amp; properties.size() &lt; MIN_SPARSE_ARRAY_INDEX) {</span>
 933             if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
 934                 if (isObjectKeys) {
 935                     Structure* structure = object-&gt;structure(vm);
 936                     if (structure-&gt;canCacheOwnKeys()) {
 937                         auto* cachedButterfly = structure-&gt;cachedOwnKeysIgnoringSentinel();
 938                         if (cachedButterfly == StructureRareData::cachedOwnKeysSentinel()) {
 939                             size_t numProperties = properties.size();
 940                             auto* newButterfly = JSImmutableButterfly::create(vm, CopyOnWriteArrayWithContiguous, numProperties);
 941                             for (size_t i = 0; i &lt; numProperties; i++) {
 942                                 const auto&amp; identifier = properties[i];
 943                                 ASSERT(!identifier.isSymbol());
<span class="line-modified"> 944                                 newButterfly-&gt;setIndex(vm, i, jsOwnedString(&amp;vm, identifier.string()));</span>
 945                             }
 946 
 947                             structure-&gt;setCachedOwnKeys(vm, newButterfly);
 948                             Structure* arrayStructure = globalObject-&gt;originalArrayStructureForIndexingType(newButterfly-&gt;indexingMode());
 949                             return JSArray::createWithButterfly(vm, nullptr, arrayStructure, newButterfly-&gt;toButterfly());
 950                         }
 951 
 952                         if (cachedButterfly == nullptr)
 953                             structure-&gt;setCachedOwnKeys(vm, StructureRareData::cachedOwnKeysSentinel());
 954                     }
 955                 }
 956 
 957                 size_t numProperties = properties.size();
 958                 JSArray* keys = JSArray::create(vm, globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous), numProperties);
 959                 WriteBarrier&lt;Unknown&gt;* buffer = keys-&gt;butterfly()-&gt;contiguous().data();
 960                 for (size_t i = 0; i &lt; numProperties; i++) {
 961                     const auto&amp; identifier = properties[i];
 962                     if (propertyNameMode == PropertyNameMode::Strings) {
 963                         ASSERT(!identifier.isSymbol());
<span class="line-modified"> 964                         buffer[i].set(vm, keys, jsOwnedString(&amp;vm, identifier.string()));</span>
 965                     } else {
 966                         ASSERT(identifier.isSymbol());
 967                         buffer[i].set(vm, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));
 968                     }
 969                 }
 970                 return keys;
 971             }
 972         }
 973     }
 974 
 975     JSArray* keys = constructEmptyArray(exec, nullptr);
 976     RETURN_IF_EXCEPTION(scope, nullptr);
 977 
 978     unsigned index = 0;
 979     auto pushDirect = [&amp;] (ExecState* exec, JSArray* array, JSValue value) {
 980         array-&gt;putDirectIndex(exec, index++, value);
 981     };
 982 
 983     switch (propertyNameMode) {
 984     case PropertyNameMode::Strings: {
 985         size_t numProperties = properties.size();
 986         for (size_t i = 0; i &lt; numProperties; i++) {
 987             const auto&amp; identifier = properties[i];
 988             ASSERT(!identifier.isSymbol());
<span class="line-modified"> 989             bool hasProperty = filterPropertyIfNeeded(identifier);</span>
<span class="line-removed"> 990             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);</span>
<span class="line-removed"> 991             if (hasProperty)</span>
<span class="line-removed"> 992                 pushDirect(exec, keys, jsOwnedString(exec, identifier.string()));</span>
 993             RETURN_IF_EXCEPTION(scope, nullptr);
 994         }
 995         break;
 996     }
 997 
 998     case PropertyNameMode::Symbols: {
 999         size_t numProperties = properties.size();
1000         for (size_t i = 0; i &lt; numProperties; i++) {
1001             const auto&amp; identifier = properties[i];
1002             ASSERT(identifier.isSymbol());
1003             ASSERT(!identifier.isPrivateName());
<span class="line-modified">1004             bool hasProperty = filterPropertyIfNeeded(identifier);</span>
<span class="line-removed">1005             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);</span>
<span class="line-removed">1006             if (hasProperty)</span>
<span class="line-removed">1007                 pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
1008             RETURN_IF_EXCEPTION(scope, nullptr);
1009         }
1010         break;
1011     }
1012 
1013     case PropertyNameMode::StringsAndSymbols: {
1014         Vector&lt;Identifier, 16&gt; propertySymbols;
1015         size_t numProperties = properties.size();
1016         for (size_t i = 0; i &lt; numProperties; i++) {
1017             const auto&amp; identifier = properties[i];
1018             if (identifier.isSymbol()) {
1019                 ASSERT(!identifier.isPrivateName());
1020                 propertySymbols.append(identifier);
1021                 continue;
1022             }
1023 
<span class="line-modified">1024             bool hasProperty = filterPropertyIfNeeded(identifier);</span>
<span class="line-removed">1025             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);</span>
<span class="line-removed">1026             if (hasProperty)</span>
<span class="line-removed">1027                 pushDirect(exec, keys, jsOwnedString(exec, identifier.string()));</span>
1028             RETURN_IF_EXCEPTION(scope, nullptr);
1029         }
1030 
1031         // To ensure the order defined in the spec (9.1.12), we append symbols at the last elements of keys.
1032         for (const auto&amp; identifier : propertySymbols) {
<span class="line-modified">1033             bool hasProperty = filterPropertyIfNeeded(identifier);</span>
<span class="line-removed">1034             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);</span>
<span class="line-removed">1035             if (hasProperty)</span>
<span class="line-removed">1036                 pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
1037             RETURN_IF_EXCEPTION(scope, nullptr);
1038         }
1039 
1040         break;
1041     }
1042     }
1043 
1044     return keys;
1045 }
1046 
1047 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  *  This library is free software; you can redistribute it and/or
   6  *  modify it under the terms of the GNU Lesser General Public
   7  *  License as published by the Free Software Foundation; either
   8  *  version 2 of the License, or (at your option) any later version.
   9  *
  10  *  This library is distributed in the hope that it will be useful,
  11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  *  Lesser General Public License for more details.
  14  *
  15  *  You should have received a copy of the GNU Lesser General Public
  16  *  License along with this library; if not, write to the Free Software
  17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  18  *
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 #include &quot;ObjectConstructor.h&quot;
  23 
</pre>
<hr />
<pre>
  86   isExtensible              objectConstructorIsExtensible               DontEnum|Function 1
  87   is                        objectConstructorIs                         DontEnum|Function 2 ObjectIsIntrinsic
  88   assign                    objectConstructorAssign                     DontEnum|Function 2
  89   values                    objectConstructorValues                     DontEnum|Function 1
  90   entries                   JSBuiltin                                   DontEnum|Function 1
  91   fromEntries               JSBuiltin                                   DontEnum|Function 1
  92 @end
  93 */
  94 
  95 
  96 static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState*);
  97 static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState*);
  98 
  99 ObjectConstructor::ObjectConstructor(VM&amp; vm, Structure* structure)
 100     : InternalFunction(vm, structure, callObjectConstructor, constructWithObjectConstructor)
 101 {
 102 }
 103 
 104 void ObjectConstructor::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, ObjectPrototype* objectPrototype)
 105 {
<span class="line-modified"> 106     Base::finishCreation(vm, vm.propertyNames-&gt;Object.string(), NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);</span>
 107 
 108     putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, objectPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
 109     putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 110 
 111     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().createPrivateName(), objectConstructorCreate, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 112     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().definePropertyPrivateName(), objectConstructorDefineProperty, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 3);
 113     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getPrototypeOfPrivateName(), objectConstructorGetPrototypeOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 114     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getOwnPropertyNamesPrivateName(), objectConstructorGetOwnPropertyNames, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 115 }
 116 
 117 // ES 19.1.1.1 Object([value])
 118 static ALWAYS_INLINE JSObject* constructObject(ExecState* exec, JSValue newTarget)
 119 {
 120     VM&amp; vm = exec-&gt;vm();
 121     ObjectConstructor* objectConstructor = jsCast&lt;ObjectConstructor*&gt;(exec-&gt;jsCallee());
 122     JSGlobalObject* globalObject = objectConstructor-&gt;globalObject(vm);
 123     auto scope = DECLARE_THROW_SCOPE(vm);
 124 
 125     // We need to check newTarget condition in this caller side instead of InternalFunction::createSubclassStructure side.
 126     // Since if we found this condition is met, we should not fall into the type conversion in the step 3.
</pre>
<hr />
<pre>
 187 JSValue objectConstructorGetOwnPropertyDescriptor(ExecState* exec, JSObject* object, const Identifier&amp; propertyName)
 188 {
 189     VM&amp; vm = exec-&gt;vm();
 190     auto scope = DECLARE_THROW_SCOPE(vm);
 191     PropertyDescriptor descriptor;
 192     if (!object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))
 193         RELEASE_AND_RETURN(scope, jsUndefined());
 194     RETURN_IF_EXCEPTION(scope, { });
 195 
 196     JSObject* result = constructObjectFromPropertyDescriptor(exec, descriptor);
 197     EXCEPTION_ASSERT(!!scope.exception() == !result);
 198     if (!result)
 199         return jsUndefined();
 200     return result;
 201 }
 202 
 203 JSValue objectConstructorGetOwnPropertyDescriptors(ExecState* exec, JSObject* object)
 204 {
 205     VM&amp; vm = exec-&gt;vm();
 206     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 207     PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 208     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 209     RETURN_IF_EXCEPTION(scope, { });
 210 
 211     JSObject* descriptors = constructEmptyObject(exec);
 212     RETURN_IF_EXCEPTION(scope, { });
 213 
 214     for (auto&amp; propertyName : properties) {
 215         PropertyDescriptor descriptor;
 216         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 217         RETURN_IF_EXCEPTION(scope, { });
 218 
 219         if (!didGetDescriptor)
 220             continue;
 221 
 222         JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(exec, descriptor);
 223         EXCEPTION_ASSERT(!!scope.exception() == !fromDescriptor);
 224         if (!fromDescriptor)
 225             return jsUndefined();
 226 
 227         PutPropertySlot slot(descriptors);
</pre>
<hr />
<pre>
 356                     properties.append(entry.key);
 357                     values.appendWithCrashOnOverflow(source-&gt;getDirect(entry.offset));
 358 
 359                     return true;
 360                 });
 361 
 362                 for (size_t i = 0; i &lt; properties.size(); ++i) {
 363                     // FIXME: We could put properties in a batching manner to accelerate Object.assign more.
 364                     // https://bugs.webkit.org/show_bug.cgi?id=185358
 365                     PutPropertySlot putPropertySlot(target, true);
 366                     target-&gt;putOwnDataProperty(vm, properties[i].get(), values.at(i), putPropertySlot);
 367                 }
 368                 continue;
 369             }
 370         }
 371 
 372         // [[GetOwnPropertyNames]], [[Get]] etc. could modify target object and invalidate this assumption.
 373         // For example, [[Get]] of source object could configure setter to target object. So disable the fast path.
 374         targetCanPerformFastPut = false;
 375 
<span class="line-modified"> 376         PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 377         source-&gt;methodTable(vm)-&gt;getOwnPropertyNames(source, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 378         RETURN_IF_EXCEPTION(scope, { });
 379 
 380         auto assign = [&amp;] (PropertyName propertyName) {
 381             PropertySlot slot(source, PropertySlot::InternalMethodType::GetOwnProperty);
 382             bool hasProperty = source-&gt;methodTable(vm)-&gt;getOwnPropertySlot(source, exec, propertyName, slot);
 383             RETURN_IF_EXCEPTION(scope, void());
 384             if (!hasProperty)
 385                 return;
 386             if (slot.attributes() &amp; PropertyAttribute::DontEnum)
 387                 return;
 388 
 389             JSValue value;
 390             if (LIKELY(!slot.isTaintedByOpaqueObject()))
 391                 value = slot.getValue(exec, propertyName);
 392             else
 393                 value = source-&gt;get(exec, propertyName);
 394             RETURN_IF_EXCEPTION(scope, void());
 395 
 396             PutPropertySlot putPropertySlot(target, true);
</pre>
<hr />
<pre>
 423             }
 424         }
 425     }
 426     return JSValue::encode(target);
 427 }
 428 
 429 EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState* exec)
 430 {
 431     VM&amp; vm = exec-&gt;vm();
 432     auto scope = DECLARE_THROW_SCOPE(vm);
 433 
 434     JSValue targetValue = exec-&gt;argument(0);
 435     if (targetValue.isUndefinedOrNull())
 436         return throwVMTypeError(exec, scope, &quot;Object.values requires that input parameter not be null or undefined&quot;_s);
 437     JSObject* target = targetValue.toObject(exec);
 438     RETURN_IF_EXCEPTION(scope, { });
 439 
 440     JSArray* values = constructEmptyArray(exec, nullptr);
 441     RETURN_IF_EXCEPTION(scope, { });
 442 
<span class="line-modified"> 443     PropertyNameArray properties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
 444     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 445     RETURN_IF_EXCEPTION(scope, { });
 446 
 447     unsigned index = 0;
 448     auto addValue = [&amp;] (PropertyName propertyName) {
 449         PropertySlot slot(target, PropertySlot::InternalMethodType::GetOwnProperty);
 450         bool hasProperty = target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 451         RETURN_IF_EXCEPTION(scope, void());
 452         if (!hasProperty)
 453             return;
 454         if (slot.attributes() &amp; PropertyAttribute::DontEnum)
 455             return;
 456 
 457         JSValue value;
 458         if (LIKELY(!slot.isTaintedByOpaqueObject()))
 459             value = slot.getValue(exec, propertyName);
 460         else
 461             value = target-&gt;get(exec, propertyName);
 462         RETURN_IF_EXCEPTION(scope, void());
 463 
</pre>
<hr />
<pre>
 583         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);
 584     JSObject* obj = asObject(exec-&gt;argument(0));
 585     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);
 586     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 587     PropertyDescriptor descriptor;
 588     auto success = toPropertyDescriptor(exec, exec-&gt;argument(2), descriptor);
 589     EXCEPTION_ASSERT(!scope.exception() == success);
 590     if (!success)
 591         return JSValue::encode(jsNull());
 592     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
 593     scope.assertNoException();
 594     obj-&gt;methodTable(vm)-&gt;defineOwnProperty(obj, exec, propertyName, descriptor, true);
 595     RELEASE_AND_RETURN(scope, JSValue::encode(obj));
 596 }
 597 
 598 static JSValue defineProperties(ExecState* exec, JSObject* object, JSObject* properties)
 599 {
 600     VM&amp; vm = exec-&gt;vm();
 601     auto scope = DECLARE_THROW_SCOPE(vm);
 602 
<span class="line-modified"> 603     PropertyNameArray propertyNames(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 604     asObject(properties)-&gt;methodTable(vm)-&gt;getOwnPropertyNames(asObject(properties), exec, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));
 605     RETURN_IF_EXCEPTION(scope, { });
 606     size_t numProperties = propertyNames.size();
 607     Vector&lt;PropertyDescriptor&gt; descriptors;
 608     MarkedArgumentBuffer markBuffer;
<span class="line-added"> 609 #define RETURN_IF_EXCEPTION_CLEARING_OVERFLOW(value) do { \</span>
<span class="line-added"> 610     if (scope.exception()) { \</span>
<span class="line-added"> 611         markBuffer.overflowCheckNotNeeded(); \</span>
<span class="line-added"> 612         return value; \</span>
<span class="line-added"> 613     } \</span>
<span class="line-added"> 614 } while (false)</span>
 615     for (size_t i = 0; i &lt; numProperties; i++) {
 616         JSValue prop = properties-&gt;get(exec, propertyNames[i]);
<span class="line-modified"> 617         RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });</span>
 618         PropertyDescriptor descriptor;
<span class="line-modified"> 619         toPropertyDescriptor(exec, prop, descriptor);</span>
<span class="line-modified"> 620         RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });</span>




 621         descriptors.append(descriptor);
 622         // Ensure we mark all the values that we&#39;re accumulating
 623         if (descriptor.isDataDescriptor() &amp;&amp; descriptor.value())
 624             markBuffer.append(descriptor.value());
 625         if (descriptor.isAccessorDescriptor()) {
 626             if (descriptor.getter())
 627                 markBuffer.append(descriptor.getter());
 628             if (descriptor.setter())
 629                 markBuffer.append(descriptor.setter());
 630         }
 631     }
 632     RELEASE_ASSERT(!markBuffer.hasOverflowed());
<span class="line-added"> 633 #undef RETURN_IF_EXCEPTION_CLEARING_OVERFLOW</span>
 634     for (size_t i = 0; i &lt; numProperties; i++) {
 635         auto&amp; propertyName = propertyNames[i];
 636         ASSERT(!propertyName.isPrivateName());
 637 
 638         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, exec, propertyName, descriptors[i], true);
 639         RETURN_IF_EXCEPTION(scope, { });
 640     }
 641     return object;
 642 }
 643 
 644 EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState* exec)
 645 {
 646     VM&amp; vm = exec-&gt;vm();
 647     auto scope = DECLARE_THROW_SCOPE(vm);
 648 
 649     if (!exec-&gt;argument(0).isObject())
 650         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);
 651     JSObject* targetObj = asObject(exec-&gt;argument(0));
 652     JSObject* props = exec-&gt;argument(1).toObject(exec);
 653     EXCEPTION_ASSERT(!!scope.exception() == !props);
 654     if (UNLIKELY(!props))
 655         return encodedJSValue();
 656     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, targetObj, props)));
 657 }
 658 
 659 EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState* exec)
 660 {
 661     VM&amp; vm = exec-&gt;vm();
 662     auto scope = DECLARE_THROW_SCOPE(vm);
 663 
 664     JSValue proto = exec-&gt;argument(0);
 665     if (!proto.isObject() &amp;&amp; !proto.isNull())
 666         return throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);
 667     JSObject* newObject = proto.isObject()
 668         ? constructEmptyObject(exec, asObject(proto))
 669         : constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());
 670     if (exec-&gt;argument(1).isUndefined())
 671         return JSValue::encode(newObject);
<span class="line-modified"> 672     JSObject* properties = exec-&gt;uncheckedArgument(1).toObject(exec);</span>
<span class="line-modified"> 673     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-modified"> 674 </span>
<span class="line-added"> 675     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, newObject, properties)));</span>
 676 }
 677 
 678 enum class IntegrityLevel {
 679     Sealed,
 680     Frozen
 681 };
 682 
 683 template&lt;IntegrityLevel level&gt;
 684 bool setIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)
 685 {
 686     // See https://tc39.github.io/ecma262/#sec-setintegritylevel.
 687     auto scope = DECLARE_THROW_SCOPE(vm);
 688 
 689     bool success = object-&gt;methodTable(vm)-&gt;preventExtensions(object, exec);
 690     RETURN_IF_EXCEPTION(scope, false);
 691     if (UNLIKELY(!success))
 692         return false;
 693 
<span class="line-modified"> 694     PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 695     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));
 696     RETURN_IF_EXCEPTION(scope, false);
 697 
 698     PropertyNameArray::const_iterator end = properties.end();
 699     for (PropertyNameArray::const_iterator iter = properties.begin(); iter != end; ++iter) {
 700         auto&amp; propertyName = *iter;
 701         ASSERT(!propertyName.isPrivateName());
 702 
 703         PropertyDescriptor desc;
 704         if (level == IntegrityLevel::Sealed)
 705             desc.setConfigurable(false);
 706         else {
 707             bool hasPropertyDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);
 708             RETURN_IF_EXCEPTION(scope, false);
 709             if (!hasPropertyDescriptor)
 710                 continue;
 711 
 712             if (desc.isDataDescriptor())
 713                 desc.setWritable(false);
 714 
</pre>
<hr />
<pre>
 721     return true;
 722 }
 723 
 724 template&lt;IntegrityLevel level&gt;
 725 bool testIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)
 726 {
 727     auto scope = DECLARE_THROW_SCOPE(vm);
 728 
 729     // 1. Assert: Type(O) is Object.
 730     // 2. Assert: level is either &quot;sealed&quot; or &quot;frozen&quot;.
 731 
 732     // 3. Let status be ?IsExtensible(O).
 733     bool status = object-&gt;isExtensible(exec);
 734     RETURN_IF_EXCEPTION(scope, { });
 735 
 736     // 4. If status is true, return false.
 737     if (status)
 738         return false;
 739 
 740     // 6. Let keys be ? O.[[OwnPropertyKeys]]().
<span class="line-modified"> 741     PropertyNameArray keys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);</span>
 742     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, keys, EnumerationMode(DontEnumPropertiesMode::Include));
 743     RETURN_IF_EXCEPTION(scope, { });
 744 
 745     // 7. For each element k of keys, do
 746     PropertyNameArray::const_iterator end = keys.end();
 747     for (PropertyNameArray::const_iterator iter = keys.begin(); iter != end; ++iter) {
 748         auto&amp; propertyName = *iter;
 749         ASSERT(!propertyName.isPrivateName());
 750 
 751         // a. Let currentDesc be ? O.[[GetOwnProperty]](k)
 752         PropertyDescriptor desc;
 753         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);
 754         RETURN_IF_EXCEPTION(scope, { });
 755 
 756         // b. If currentDesc is not undefined, then
 757         if (!didGetDescriptor)
 758             continue;
 759 
 760         // i. If currentDesc.[[Configurable]] is true, return false.
 761         if (desc.configurable())
</pre>
<hr />
<pre>
 765         // 1. If currentDesc.[[Writable]] is true, return false.
 766         if (level == IntegrityLevel::Frozen &amp;&amp; desc.isDataDescriptor() &amp;&amp; desc.writable())
 767             return false;
 768     }
 769 
 770     return true;
 771 }
 772 
 773 JSObject* objectConstructorSeal(ExecState* exec, JSObject* object)
 774 {
 775     VM&amp; vm = exec-&gt;vm();
 776     auto scope = DECLARE_THROW_SCOPE(vm);
 777 
 778     if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
 779         object-&gt;seal(vm);
 780         return object;
 781     }
 782 
 783     bool success = setIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(exec, vm, object);
 784     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 785     if (UNLIKELY(!success)) {</span>
<span class="line-modified"> 786         throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.seal&quot;_s);</span>
<span class="line-added"> 787         return nullptr;</span>
<span class="line-added"> 788     }</span>
 789 
 790     return object;
 791 }
 792 
 793 EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState* exec)
 794 {
 795     VM&amp; vm = exec-&gt;vm();
 796     auto scope = DECLARE_THROW_SCOPE(vm);
 797 
 798     // 1. If Type(O) is not Object, return O.
 799     JSValue obj = exec-&gt;argument(0);
 800     if (!obj.isObject())
 801         return JSValue::encode(obj);
 802 
 803     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(exec, asObject(obj))));
 804 }
 805 
 806 JSObject* objectConstructorFreeze(ExecState* exec, JSObject* object)
 807 {
 808     VM&amp; vm = exec-&gt;vm();
 809     auto scope = DECLARE_THROW_SCOPE(vm);
 810 
 811     if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
 812         object-&gt;freeze(vm);
 813         return object;
 814     }
 815 
 816     bool success = setIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(exec, vm, object);
 817     RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified"> 818     if (UNLIKELY(!success)) {</span>
<span class="line-modified"> 819         throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.freeze&quot;_s);</span>
<span class="line-added"> 820         return nullptr;</span>
<span class="line-added"> 821     }</span>
 822     return object;
 823 }
 824 
 825 EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState* exec)
 826 {
 827     VM&amp; vm = exec-&gt;vm();
 828     auto scope = DECLARE_THROW_SCOPE(vm);
 829     // 1. If Type(O) is not Object, return O.
 830     JSValue obj = exec-&gt;argument(0);
 831     if (!obj.isObject())
 832         return JSValue::encode(obj);
 833     JSObject* result = objectConstructorFreeze(exec, asObject(obj));
 834     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 835     return JSValue::encode(result);
 836 }
 837 
 838 EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState* exec)
 839 {
 840     VM&amp; vm = exec-&gt;vm();
 841     JSValue argument = exec-&gt;argument(0);
</pre>
<hr />
<pre>
 900     return JSValue::encode(jsBoolean(sameValue(exec, exec-&gt;argument(0), exec-&gt;argument(1))));
 901 }
 902 
 903 JSArray* ownPropertyKeys(ExecState* exec, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)
 904 {
 905     VM&amp; vm = exec-&gt;vm();
 906     auto scope = DECLARE_THROW_SCOPE(vm);
 907 
 908     auto* globalObject = exec-&gt;lexicalGlobalObject();
 909     bool isObjectKeys = propertyNameMode == PropertyNameMode::Strings &amp;&amp; dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude;
 910     // We attempt to look up own property keys cache in Object.keys case.
 911     if (isObjectKeys) {
 912         if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
 913             if (auto* immutableButterfly = object-&gt;structure(vm)-&gt;cachedOwnKeys()) {
 914                 Structure* arrayStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
 915                 return JSArray::createWithButterfly(vm, nullptr, arrayStructure, immutableButterfly-&gt;toButterfly());
 916             }
 917         }
 918     }
 919 
<span class="line-modified"> 920     PropertyNameArray properties(vm, propertyNameMode, PrivateSymbolMode::Exclude);</span>
 921     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(dontEnumPropertiesMode));
 922     RETURN_IF_EXCEPTION(scope, nullptr);
 923 














 924     if (propertyNameMode != PropertyNameMode::StringsAndSymbols) {
 925         ASSERT(propertyNameMode == PropertyNameMode::Strings || propertyNameMode == PropertyNameMode::Symbols);
<span class="line-modified"> 926         if (properties.size() &lt; MIN_SPARSE_ARRAY_INDEX) {</span>
 927             if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
 928                 if (isObjectKeys) {
 929                     Structure* structure = object-&gt;structure(vm);
 930                     if (structure-&gt;canCacheOwnKeys()) {
 931                         auto* cachedButterfly = structure-&gt;cachedOwnKeysIgnoringSentinel();
 932                         if (cachedButterfly == StructureRareData::cachedOwnKeysSentinel()) {
 933                             size_t numProperties = properties.size();
 934                             auto* newButterfly = JSImmutableButterfly::create(vm, CopyOnWriteArrayWithContiguous, numProperties);
 935                             for (size_t i = 0; i &lt; numProperties; i++) {
 936                                 const auto&amp; identifier = properties[i];
 937                                 ASSERT(!identifier.isSymbol());
<span class="line-modified"> 938                                 newButterfly-&gt;setIndex(vm, i, jsOwnedString(vm, identifier.string()));</span>
 939                             }
 940 
 941                             structure-&gt;setCachedOwnKeys(vm, newButterfly);
 942                             Structure* arrayStructure = globalObject-&gt;originalArrayStructureForIndexingType(newButterfly-&gt;indexingMode());
 943                             return JSArray::createWithButterfly(vm, nullptr, arrayStructure, newButterfly-&gt;toButterfly());
 944                         }
 945 
 946                         if (cachedButterfly == nullptr)
 947                             structure-&gt;setCachedOwnKeys(vm, StructureRareData::cachedOwnKeysSentinel());
 948                     }
 949                 }
 950 
 951                 size_t numProperties = properties.size();
 952                 JSArray* keys = JSArray::create(vm, globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous), numProperties);
 953                 WriteBarrier&lt;Unknown&gt;* buffer = keys-&gt;butterfly()-&gt;contiguous().data();
 954                 for (size_t i = 0; i &lt; numProperties; i++) {
 955                     const auto&amp; identifier = properties[i];
 956                     if (propertyNameMode == PropertyNameMode::Strings) {
 957                         ASSERT(!identifier.isSymbol());
<span class="line-modified"> 958                         buffer[i].set(vm, keys, jsOwnedString(vm, identifier.string()));</span>
 959                     } else {
 960                         ASSERT(identifier.isSymbol());
 961                         buffer[i].set(vm, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));
 962                     }
 963                 }
 964                 return keys;
 965             }
 966         }
 967     }
 968 
 969     JSArray* keys = constructEmptyArray(exec, nullptr);
 970     RETURN_IF_EXCEPTION(scope, nullptr);
 971 
 972     unsigned index = 0;
 973     auto pushDirect = [&amp;] (ExecState* exec, JSArray* array, JSValue value) {
 974         array-&gt;putDirectIndex(exec, index++, value);
 975     };
 976 
 977     switch (propertyNameMode) {
 978     case PropertyNameMode::Strings: {
 979         size_t numProperties = properties.size();
 980         for (size_t i = 0; i &lt; numProperties; i++) {
 981             const auto&amp; identifier = properties[i];
 982             ASSERT(!identifier.isSymbol());
<span class="line-modified"> 983             pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));</span>



 984             RETURN_IF_EXCEPTION(scope, nullptr);
 985         }
 986         break;
 987     }
 988 
 989     case PropertyNameMode::Symbols: {
 990         size_t numProperties = properties.size();
 991         for (size_t i = 0; i &lt; numProperties; i++) {
 992             const auto&amp; identifier = properties[i];
 993             ASSERT(identifier.isSymbol());
 994             ASSERT(!identifier.isPrivateName());
<span class="line-modified"> 995             pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>



 996             RETURN_IF_EXCEPTION(scope, nullptr);
 997         }
 998         break;
 999     }
1000 
1001     case PropertyNameMode::StringsAndSymbols: {
1002         Vector&lt;Identifier, 16&gt; propertySymbols;
1003         size_t numProperties = properties.size();
1004         for (size_t i = 0; i &lt; numProperties; i++) {
1005             const auto&amp; identifier = properties[i];
1006             if (identifier.isSymbol()) {
1007                 ASSERT(!identifier.isPrivateName());
1008                 propertySymbols.append(identifier);
1009                 continue;
1010             }
1011 
<span class="line-modified">1012             pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));</span>



1013             RETURN_IF_EXCEPTION(scope, nullptr);
1014         }
1015 
1016         // To ensure the order defined in the spec (9.1.12), we append symbols at the last elements of keys.
1017         for (const auto&amp; identifier : propertySymbols) {
<span class="line-modified">1018             pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>



1019             RETURN_IF_EXCEPTION(scope, nullptr);
1020         }
1021 
1022         break;
1023     }
1024     }
1025 
1026     return keys;
1027 }
1028 
1029 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="NumericStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyChangeAdaptiveWatchpoint.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>