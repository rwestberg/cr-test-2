<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaElementSession.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;DocumentLoader.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
<a name="1" id="anc1"></a>
 36 #include &quot;HTMLAudioElement.h&quot;
 37 #include &quot;HTMLMediaElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLVideoElement.h&quot;
 40 #include &quot;HitTestResult.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;PlatformMediaSessionManager.h&quot;
<a name="2" id="anc2"></a>
 44 #include &quot;RenderMedia.h&quot;
 45 #include &quot;RenderView.h&quot;
 46 #include &quot;ScriptController.h&quot;
 47 #include &quot;Settings.h&quot;
 48 #include &quot;SourceBuffer.h&quot;
 49 #include &lt;wtf/text/StringBuilder.h&gt;
 50 
 51 #if PLATFORM(IOS_FAMILY)
 52 #include &quot;AudioSession.h&quot;
 53 #include &quot;RuntimeApplicationChecks.h&quot;
 54 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 55 #endif
 56 
 57 namespace WebCore {
 58 
 59 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
 60 static const Seconds elementMainContentCheckInterval { 250_ms };
 61 
 62 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp;);
 63 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp;, MediaSessionMainContentPurpose);
 64 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp;, bool shouldHitTestMainFrame);
 65 
 66 #if !RELEASE_LOG_DISABLED
 67 static String restrictionNames(MediaElementSession::BehaviorRestrictions restriction)
 68 {
 69     StringBuilder restrictionBuilder;
 70 #define CASE(restrictionType) \
 71     if (restriction &amp; MediaElementSession::restrictionType) { \
 72         if (!restrictionBuilder.isEmpty()) \
 73             restrictionBuilder.appendLiteral(&quot;, &quot;); \
 74         restrictionBuilder.append(#restrictionType); \
 75     } \
 76 
 77     CASE(NoRestrictions)
 78     CASE(RequireUserGestureForLoad)
 79     CASE(RequireUserGestureForVideoRateChange)
 80     CASE(RequireUserGestureForAudioRateChange)
 81     CASE(RequireUserGestureForFullscreen)
 82     CASE(RequirePageConsentToLoadMedia)
 83     CASE(RequirePageConsentToResumeMedia)
 84     CASE(RequireUserGestureToShowPlaybackTargetPicker)
 85     CASE(WirelessVideoPlaybackDisabled)
 86     CASE(RequireUserGestureToAutoplayToExternalDevice)
<a name="3" id="anc3"></a><span class="line-removed"> 87     CASE(MetadataPreloadingNotPermitted)</span>
 88     CASE(AutoPreloadingNotPermitted)
 89     CASE(InvisibleAutoplayNotPermitted)
 90     CASE(OverrideUserGestureRequirementForMainContent)
 91     CASE(RequireUserGestureToControlControlsManager)
 92     CASE(RequirePlaybackToControlControlsManager)
 93     CASE(RequireUserGestureForVideoDueToLowPowerMode)
 94 
 95     return restrictionBuilder.toString();
 96 }
 97 #endif
 98 
 99 static bool pageExplicitlyAllowsElementToAutoplayInline(const HTMLMediaElement&amp; element)
100 {
101     Document&amp; document = element.document();
102     Page* page = document.page();
103     return document.isMediaDocument() &amp;&amp; !document.ownerElement() &amp;&amp; page &amp;&amp; page-&gt;allowsMediaDocumentInlinePlayback();
104 }
105 
106 MediaElementSession::MediaElementSession(HTMLMediaElement&amp; element)
107     : PlatformMediaSession(element)
108     , m_element(element)
109     , m_restrictions(NoRestrictions)
110 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
111     , m_targetAvailabilityChangedTimer(*this, &amp;MediaElementSession::targetAvailabilityChangedTimerFired)
<a name="4" id="anc4"></a>
112 #endif
113     , m_mainContentCheckTimer(*this, &amp;MediaElementSession::mainContentCheckTimerFired)
114     , m_clientDataBufferingTimer(*this, &amp;MediaElementSession::clientDataBufferingTimerFired)
115 #if !RELEASE_LOG_DISABLED
116     , m_logIdentifier(element.logIdentifier())
117 #endif
118 {
119 }
120 
121 void MediaElementSession::registerWithDocument(Document&amp; document)
122 {
123 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
124     document.addPlaybackTargetPickerClient(*this);
125 #else
126     UNUSED_PARAM(document);
127 #endif
128 }
129 
130 void MediaElementSession::unregisterWithDocument(Document&amp; document)
131 {
132 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
133     document.removePlaybackTargetPickerClient(*this);
134 #else
135     UNUSED_PARAM(document);
136 #endif
137 }
138 
139 void MediaElementSession::clientWillBeginAutoplaying()
140 {
141     PlatformMediaSession::clientWillBeginAutoplaying();
142     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
143     updateClientDataBuffering();
144 }
145 
146 bool MediaElementSession::clientWillBeginPlayback()
147 {
148     if (!PlatformMediaSession::clientWillBeginPlayback())
149         return false;
150 
151     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
152     updateClientDataBuffering();
153     return true;
154 }
155 
156 bool MediaElementSession::clientWillPausePlayback()
157 {
158     if (!PlatformMediaSession::clientWillPausePlayback())
159         return false;
160 
161     updateClientDataBuffering();
162     return true;
163 }
164 
165 void MediaElementSession::visibilityChanged()
166 {
167     scheduleClientDataBufferingCheck();
168 
169     if (m_element.elementIsHidden() &amp;&amp; !m_element.isFullscreen())
170         m_elementIsHiddenUntilVisibleInViewport = true;
171     else if (m_element.isVisibleInViewport())
172         m_elementIsHiddenUntilVisibleInViewport = false;
173 }
174 
175 void MediaElementSession::isVisibleInViewportChanged()
176 {
177     scheduleClientDataBufferingCheck();
178 
179     if (m_element.isFullscreen() || m_element.isVisibleInViewport())
180         m_elementIsHiddenUntilVisibleInViewport = false;
181 }
182 
183 void MediaElementSession::inActiveDocumentChanged()
184 {
185     m_elementIsHiddenBecauseItWasRemovedFromDOM = !m_element.inActiveDocument();
186     scheduleClientDataBufferingCheck();
187 }
188 
189 void MediaElementSession::scheduleClientDataBufferingCheck()
190 {
191     if (!m_clientDataBufferingTimer.isActive())
192         m_clientDataBufferingTimer.startOneShot(clientDataBufferingTimerThrottleDelay);
193 }
194 
195 void MediaElementSession::clientDataBufferingTimerFired()
196 {
197     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, m_element.elementIsHidden());
198 
199     updateClientDataBuffering();
200 
201 #if PLATFORM(IOS_FAMILY)
202     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
203 #endif
204 
205     if (state() != Playing || !m_element.elementIsHidden())
206         return;
207 
208     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType());
209     if ((restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) == PlatformMediaSessionManager::BackgroundTabPlaybackRestricted)
210         pauseSession();
211 }
212 
213 void MediaElementSession::updateClientDataBuffering()
214 {
215     if (m_clientDataBufferingTimer.isActive())
216         m_clientDataBufferingTimer.stop();
217 
<a name="5" id="anc5"></a><span class="line-modified">218     m_element.setShouldBufferData(dataBufferingPermitted());</span>
219 }
220 
221 void MediaElementSession::addBehaviorRestriction(BehaviorRestrictions restrictions)
222 {
223     if (restrictions &amp; ~m_restrictions)
224         INFO_LOG(LOGIDENTIFIER, &quot;adding &quot;, restrictionNames(restrictions &amp; ~m_restrictions));
225 
226     m_restrictions |= restrictions;
227 
228     if (restrictions &amp; OverrideUserGestureRequirementForMainContent)
229         m_mainContentCheckTimer.startRepeating(elementMainContentCheckInterval);
230 }
231 
232 void MediaElementSession::removeBehaviorRestriction(BehaviorRestrictions restriction)
233 {
234     if (restriction &amp; RequireUserGestureToControlControlsManager) {
235         m_mostRecentUserInteractionTime = MonotonicTime::now();
236         if (auto page = m_element.document().page())
237             page-&gt;setAllowsPlaybackControlsForAutoplayingAudio(true);
238     }
239 
240     if (!(m_restrictions &amp; restriction))
241         return;
242 
<a name="6" id="anc6"></a><span class="line-modified">243     INFO_LOG(LOGIDENTIFIER, &quot;removing &quot;, restrictionNames(m_restrictions &amp; restriction));</span>
244     m_restrictions &amp;= ~restriction;
245 }
246 
<a name="7" id="anc7"></a><span class="line-removed">247 #if PLATFORM(MAC)</span>
<span class="line-removed">248 static bool needsArbitraryUserGestureAutoplayQuirk(const Document&amp; document)</span>
<span class="line-removed">249 {</span>
<span class="line-removed">250     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">251         return false;</span>
<span class="line-removed">252 </span>
<span class="line-removed">253     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed">254     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::ArbitraryUserGestures);</span>
<span class="line-removed">255 }</span>
<span class="line-removed">256 #endif // PLATFORM(MAC)</span>
<span class="line-removed">257 </span>
<span class="line-removed">258 static bool needsPerDocumentAutoplayBehaviorQuirk(const Document&amp; document)</span>
<span class="line-removed">259 {</span>
<span class="line-removed">260     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">261         return false;</span>
<span class="line-removed">262 </span>
<span class="line-removed">263     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed">264     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::PerDocumentAutoplayBehavior);</span>
<span class="line-removed">265 }</span>
<span class="line-removed">266 </span>
267 SuccessOr&lt;MediaPlaybackDenialReason&gt; MediaElementSession::playbackPermitted() const
268 {
269     if (m_element.isSuspended()) {
270         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is suspended&quot;);
271         return MediaPlaybackDenialReason::InvalidState;
272     }
273 
274     auto&amp; document = m_element.document();
275     auto* page = document.page();
<a name="8" id="anc8"></a><span class="line-modified">276     if (!page || page-&gt;mediaPlaybackIsSuspended())</span>

277         return MediaPlaybackDenialReason::PageConsentRequired;
<a name="9" id="anc9"></a>
278 
279     if (document.isMediaDocument() &amp;&amp; !document.ownerElement())
280         return { };
281 
282     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
283         return { };
284 
285     if (requiresFullscreenForVideoPlayback() &amp;&amp; !fullscreenPermitted()) {
286         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of fullscreen restriction&quot;);
287         return MediaPlaybackDenialReason::FullscreenRequired;
288     }
289 
290     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
291         return { };
292 
293 #if ENABLE(MEDIA_STREAM)
294     if (m_element.hasMediaStreamSrcObject()) {
295         if (document.isCapturing())
296             return { };
297         if (document.mediaState() &amp; MediaProducer::IsPlayingAudio)
298             return { };
299     }
300 #endif
301 
<a name="10" id="anc10"></a>
302     const auto&amp; topDocument = document.topDocument();
<a name="11" id="anc11"></a><span class="line-modified">303     if (topDocument.mediaState() &amp; MediaProducer::HasUserInteractedWithMediaElement &amp;&amp; needsPerDocumentAutoplayBehaviorQuirk(topDocument))</span>
304         return { };
305 
<a name="12" id="anc12"></a><span class="line-modified">306 #if PLATFORM(MAC)</span>
<span class="line-removed">307     if (document.hasHadUserInteraction() &amp;&amp; needsArbitraryUserGestureAutoplayQuirk(document))</span>
308         return { };
<a name="13" id="anc13"></a><span class="line-removed">309 #endif</span>
310 
311     if (m_restrictions &amp; RequireUserGestureForVideoRateChange &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
312         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
313         return MediaPlaybackDenialReason::UserGestureRequired;
314     }
315 
316     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
317         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
318         return MediaPlaybackDenialReason::UserGestureRequired;
319     }
320 
321     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
322         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
323         return MediaPlaybackDenialReason::UserGestureRequired;
324     }
325 
326     return { };
327 }
328 
329 bool MediaElementSession::autoplayPermitted() const
330 {
331     const Document&amp; document = m_element.document();
332     if (document.pageCacheState() != Document::NotInPageCache)
333         return false;
334     if (document.activeDOMObjectsAreSuspended())
335         return false;
336 
337     if (!hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
338         return true;
339 
340     // If the media element is audible, allow autoplay even when not visible as pausing it would be observable by the user.
341     if ((!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume())
342         return true;
343 
344     auto* renderer = m_element.renderer();
345     if (!renderer) {
346         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element has no renderer&quot;);
347         return false;
348     }
349     if (renderer-&gt;style().visibility() != Visibility::Visible) {
350         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible&quot;);
351         return false;
352     }
353     if (renderer-&gt;view().frameView().isOffscreen()) {
354         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because frame is offscreen&quot;);
355         return false;
356     }
357     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes) {
358         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible in the viewport&quot;);
359         return false;
360     }
361     return true;
362 }
363 
364 bool MediaElementSession::dataLoadingPermitted() const
365 {
366     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
367         return true;
368 
369     if (m_restrictions &amp; RequireUserGestureForLoad &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
370         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
371         return false;
372     }
373 
374     return true;
375 }
376 
<a name="14" id="anc14"></a><span class="line-modified">377 bool MediaElementSession::dataBufferingPermitted() const</span>
378 {
379     if (isSuspended())
<a name="15" id="anc15"></a><span class="line-modified">380         return false;</span>



381 
382     if (state() == PlatformMediaSession::Playing)
<a name="16" id="anc16"></a><span class="line-modified">383         return true;</span>
384 
385     if (shouldOverrideBackgroundLoadingRestriction())
<a name="17" id="anc17"></a><span class="line-modified">386         return true;</span>
387 
388 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
389     if (m_shouldPlayToPlaybackTarget)
<a name="18" id="anc18"></a><span class="line-modified">390         return true;</span>
391 #endif
392 
393     if (m_elementIsHiddenUntilVisibleInViewport || m_elementIsHiddenBecauseItWasRemovedFromDOM || m_element.elementIsHidden())
<a name="19" id="anc19"></a><span class="line-modified">394         return false;</span>
395 
<a name="20" id="anc20"></a><span class="line-modified">396     return true;</span>
397 }
398 
399 bool MediaElementSession::fullscreenPermitted() const
400 {
401     if (m_restrictions &amp; RequireUserGestureForFullscreen &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
402         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
403         return false;
404     }
405 
406     return true;
407 }
408 
409 bool MediaElementSession::pageAllowsDataLoading() const
410 {
411     Page* page = m_element.document().page();
412     if (m_restrictions &amp; RequirePageConsentToLoadMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
413         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
414         return false;
415     }
416 
417     return true;
418 }
419 
420 bool MediaElementSession::pageAllowsPlaybackAfterResuming() const
421 {
422     Page* page = m_element.document().page();
423     if (m_restrictions &amp; RequirePageConsentToResumeMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
424         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
425         return false;
426     }
427 
428     return true;
429 }
430 
431 bool MediaElementSession::canShowControlsManager(PlaybackControlsPurpose purpose) const
432 {
433     if (m_element.isSuspended() || !m_element.inActiveDocument()) {
434         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: isSuspended()&quot;);
435         return false;
436     }
437 
438     if (m_element.isFullscreen()) {
439         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is fullscreen&quot;);
440         return true;
441     }
442 
443     if (m_element.muted()) {
444         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: muted&quot;);
445         return false;
446     }
447 
448     if (m_element.document().isMediaDocument() &amp;&amp; (m_element.document().frame() &amp;&amp; m_element.document().frame()-&gt;isMainFrame())) {
449         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is media document&quot;);
450         return true;
451     }
452 
453     if (client().presentationType() == Audio) {
454         if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
455             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: audio element with user gesture&quot;);
456             return true;
457         }
458 
459         if (m_element.isPlaying() &amp;&amp; allowsPlaybackControlsForAutoplayingAudio()) {
460             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: user has played media before&quot;);
461             return true;
462         }
463 
464         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: audio element is not suitable&quot;);
465         return false;
466     }
467 
468     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; !isElementRectMostlyInMainFrame(m_element)) {
469         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: not in main frame&quot;);
470         return false;
471     }
472 
473     if (!m_element.hasAudio() &amp;&amp; !m_element.hasEverHadAudio()) {
474         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no audio&quot;);
475         return false;
476     }
477 
478     if (!playbackPermitted()) {
479         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: playback not permitted&quot;);
480         return false;
481     }
482 
483     if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
484         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: no user gesture required&quot;);
485         return true;
486     }
487 
488     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; hasBehaviorRestriction(RequirePlaybackToControlControlsManager) &amp;&amp; !m_element.isPlaying()) {
489         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: needs to be playing&quot;);
490         return false;
491     }
492 
493     if (!m_element.hasEverNotifiedAboutPlaying()) {
494         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: hasn&#39;t fired playing notification&quot;);
495         return false;
496     }
497 
498 #if ENABLE(FULLSCREEN_API)
499     // Elements which are not descendents of the current fullscreen element cannot be main content.
<a name="21" id="anc21"></a><span class="line-modified">500     auto* fullscreenElement = m_element.document().webkitCurrentFullScreenElement();</span>
501     if (fullscreenElement &amp;&amp; !m_element.isDescendantOf(*fullscreenElement)) {
502         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: outside of full screen&quot;);
503         return false;
504     }
505 #endif
506 
507     // Only allow the main content heuristic to forbid videos from showing up if our purpose is the controls manager.
508     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; m_element.isVideo()) {
509         if (!m_element.renderer()) {
510             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no renderer&quot;);
511             return false;
512         }
513 
514         if (!m_element.hasVideo() &amp;&amp; !m_element.hasEverHadVideo()) {
515             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no video&quot;);
516             return false;
517         }
518 
519         if (isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls)) {
520             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is main content&quot;);
521             return true;
522         }
523     }
524 
525     if (purpose == PlaybackControlsPurpose::NowPlaying) {
526         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: potentially plays audio&quot;);
527         return true;
528     }
529 
530     INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no user gesture&quot;);
531     return false;
532 }
533 
534 bool MediaElementSession::isLargeEnoughForMainContent(MediaSessionMainContentPurpose purpose) const
535 {
536     return isElementLargeEnoughForMainContent(m_element, purpose);
537 }
538 
539 bool MediaElementSession::isMainContentForPurposesOfAutoplayEvents() const
540 {
541     return isElementMainContentForPurposesOfAutoplay(m_element, false);
542 }
543 
544 MonotonicTime MediaElementSession::mostRecentUserInteractionTime() const
545 {
546     return m_mostRecentUserInteractionTime;
547 }
548 
549 bool MediaElementSession::wantsToObserveViewportVisibilityForMediaControls() const
550 {
551     return isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls);
552 }
553 
554 bool MediaElementSession::wantsToObserveViewportVisibilityForAutoplay() const
555 {
556     return m_element.isVideo();
557 }
558 
559 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
560 void MediaElementSession::showPlaybackTargetPicker()
561 {
562     INFO_LOG(LOGIDENTIFIER);
563 
564     auto&amp; document = m_element.document();
565     if (m_restrictions &amp; RequireUserGestureToShowPlaybackTargetPicker &amp;&amp; !document.processingUserGestureForMedia()) {
566         INFO_LOG(LOGIDENTIFIER, &quot;returning early because of permissions&quot;);
567         return;
568     }
569 
570     if (!document.page()) {
571         INFO_LOG(LOGIDENTIFIER, &quot;returning early because page is NULL&quot;);
572         return;
573     }
574 
575 #if !PLATFORM(IOS_FAMILY)
576     if (m_element.readyState() &lt; HTMLMediaElementEnums::HAVE_METADATA) {
577         INFO_LOG(LOGIDENTIFIER, &quot;returning early because element is not playable&quot;);
578         return;
579     }
580 #endif
581 
582     auto&amp; audioSession = AudioSession::sharedSession();
583     document.showPlaybackTargetPicker(*this, is&lt;HTMLVideoElement&gt;(m_element), audioSession.routeSharingPolicy(), audioSession.routingContextUID());
584 }
585 
586 bool MediaElementSession::hasWirelessPlaybackTargets() const
587 {
588     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, m_hasPlaybackTargets);
589 
590     return m_hasPlaybackTargets;
591 }
592 
593 bool MediaElementSession::wirelessVideoPlaybackDisabled() const
594 {
595     if (!m_element.document().settings().allowsAirPlayForMediaPlayback()) {
596         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of settings&quot;);
597         return true;
598     }
599 
600     if (m_element.hasAttributeWithoutSynchronization(HTMLNames::webkitwirelessvideoplaybackdisabledAttr)) {
601         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of attribute&quot;);
602         return true;
603     }
604 
605 #if PLATFORM(IOS_FAMILY)
606     auto&amp; legacyAirplayAttributeValue = m_element.attributeWithoutSynchronization(HTMLNames::webkitairplayAttr);
607     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;deny&quot;)) {
608         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of legacy attribute&quot;);
609         return true;
610     }
611     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;allow&quot;)) {
612         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE because of legacy attribute&quot;);
613         return false;
614     }
615 #endif
616 
617     auto player = m_element.player();
618     if (!player)
619         return true;
620 
621     bool disabled = player-&gt;wirelessVideoPlaybackDisabled();
622     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, disabled, &quot; because media engine says so&quot;);
623 
624     return disabled;
625 }
626 
627 void MediaElementSession::setWirelessVideoPlaybackDisabled(bool disabled)
628 {
629     if (disabled)
630         addBehaviorRestriction(WirelessVideoPlaybackDisabled);
631     else
632         removeBehaviorRestriction(WirelessVideoPlaybackDisabled);
633 
634     auto player = m_element.player();
635     if (!player)
636         return;
637 
638     INFO_LOG(LOGIDENTIFIER, disabled);
639     player-&gt;setWirelessVideoPlaybackDisabled(disabled);
640 }
641 
642 void MediaElementSession::setHasPlaybackTargetAvailabilityListeners(bool hasListeners)
643 {
644     INFO_LOG(LOGIDENTIFIER, hasListeners);
645 
646 #if PLATFORM(IOS_FAMILY)
647     m_hasPlaybackTargetAvailabilityListeners = hasListeners;
648     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
649 #else
650     UNUSED_PARAM(hasListeners);
651     m_element.document().playbackTargetPickerClientStateDidChange(*this, m_element.mediaState());
652 #endif
653 }
654 
655 void MediaElementSession::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
656 {
657     m_playbackTarget = WTFMove(device);
658     client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
659 }
660 
661 void MediaElementSession::targetAvailabilityChangedTimerFired()
662 {
663     client().wirelessRoutesAvailableDidChange();
664 }
665 
666 void MediaElementSession::externalOutputDeviceAvailableDidChange(bool hasTargets)
667 {
668     if (m_hasPlaybackTargets == hasTargets)
669         return;
670 
671     INFO_LOG(LOGIDENTIFIER, hasTargets);
672 
673     m_hasPlaybackTargets = hasTargets;
674     m_targetAvailabilityChangedTimer.startOneShot(0_s);
675 }
676 
677 bool MediaElementSession::isPlayingToWirelessPlaybackTarget() const
678 {
679 #if !PLATFORM(IOS_FAMILY)
680     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute())
681         return false;
682 #endif
683 
684     return client().isPlayingToWirelessPlaybackTarget();
685 }
686 
687 void MediaElementSession::setShouldPlayToPlaybackTarget(bool shouldPlay)
688 {
689     INFO_LOG(LOGIDENTIFIER, shouldPlay);
690     m_shouldPlayToPlaybackTarget = shouldPlay;
691     updateClientDataBuffering();
692     client().setShouldPlayToPlaybackTarget(shouldPlay);
693 }
694 
695 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
696 {
697     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
698 }
699 #endif
700 
701 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
702 {
703     MediaPlayer::Preload preload = m_element.preloadValue();
704 
705     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
706         return preload;
707 
<a name="22" id="anc22"></a><span class="line-removed">708     if (m_restrictions &amp; MetadataPreloadingNotPermitted)</span>
<span class="line-removed">709         return MediaPlayer::None;</span>
<span class="line-removed">710 </span>
711     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
712         if (preload &gt; MediaPlayer::MetaData)
713             return MediaPlayer::MetaData;
714     }
715 
716     return preload;
717 }
718 
719 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
720 {
721     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
722         return false;
723 
724     if (is&lt;HTMLAudioElement&gt;(m_element))
725         return false;
726 
727     if (m_element.document().isMediaDocument()) {
728         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
729         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
730         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
731             return false;
732     }
733 
734     if (m_element.isTemporarilyAllowingInlinePlaybackAfterFullscreen())
735         return false;
736 
737     if (!m_element.document().settings().allowsInlineMediaPlayback())
738         return true;
739 
740     if (!m_element.document().settings().inlineMediaPlaybackRequiresPlaysInlineAttribute())
741         return false;
742 
743 #if PLATFORM(IOS_FAMILY)
744     if (IOSApplication::isIBooks())
745         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr) &amp;&amp; !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
746     if (dyld_get_program_sdk_version() &lt; DYLD_IOS_VERSION_10_0)
747         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr);
748 #endif
749 
750     if (m_element.document().isMediaDocument() &amp;&amp; m_element.document().ownerElement())
751         return false;
752 
753     return !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
754 }
755 
756 bool MediaElementSession::allowsAutomaticMediaDataLoading() const
757 {
758     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
759         return true;
760 
761     if (m_element.document().settings().mediaDataLoadsAutomatically())
762         return true;
763 
764     return false;
765 }
766 
767 void MediaElementSession::mediaEngineUpdated()
768 {
769     INFO_LOG(LOGIDENTIFIER);
770 
771 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
772     if (m_restrictions &amp; WirelessVideoPlaybackDisabled)
773         setWirelessVideoPlaybackDisabled(true);
774     if (m_playbackTarget)
775         client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
776     if (m_shouldPlayToPlaybackTarget)
777         client().setShouldPlayToPlaybackTarget(true);
778 #endif
779 
780 }
781 
782 void MediaElementSession::resetPlaybackSessionState()
783 {
784     m_mostRecentUserInteractionTime = MonotonicTime();
785     addBehaviorRestriction(RequireUserGestureToControlControlsManager | RequirePlaybackToControlControlsManager);
786 }
787 
<a name="23" id="anc23"></a>
















788 bool MediaElementSession::allowsPictureInPicture() const
789 {
790     return m_element.document().settings().allowsPictureInPictureMediaPlayback();
791 }
792 
793 #if PLATFORM(IOS_FAMILY)
794 bool MediaElementSession::requiresPlaybackTargetRouteMonitoring() const
795 {
796     return m_hasPlaybackTargetAvailabilityListeners &amp;&amp; !m_element.elementIsHidden();
797 }
798 #endif
799 
800 #if ENABLE(MEDIA_SOURCE)
801 size_t MediaElementSession::maximumMediaSourceBufferSize(const SourceBuffer&amp; buffer) const
802 {
803     // A good quality 1080p video uses 8,000 kbps and stereo audio uses 384 kbps, so assume 95% for video and 5% for audio.
804     const float bufferBudgetPercentageForVideo = .95;
805     const float bufferBudgetPercentageForAudio = .05;
806 
807     size_t maximum = buffer.document().settings().maximumSourceBufferSize();
808 
809     // Allow a SourceBuffer to buffer as though it is audio-only even if it doesn&#39;t have any active tracks (yet).
810     size_t bufferSize = static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForAudio);
811     if (buffer.hasVideo())
812         bufferSize += static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForVideo);
813 
814     // FIXME: we might want to modify this algorithm to:
815     // - decrease the maximum size for background tabs
816     // - decrease the maximum size allowed for inactive elements when a process has more than one
817     //   element, eg. so a page with many elements which are played one at a time doesn&#39;t keep
818     //   everything buffered after an element has finished playing.
819 
820     return bufferSize;
821 }
822 #endif
823 
824 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp; element, bool shouldHitTestMainFrame)
825 {
826     Document&amp; document = element.document();
827     if (!document.hasLivingRenderTree() || document.activeDOMObjectsAreStopped() || element.isSuspended() || !element.hasAudio() || !element.hasVideo())
828         return false;
829 
830     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
831     auto* renderer = element.renderer();
832     if (!renderer)
833         return false;
834 
835     if (!isElementLargeEnoughForMainContent(element, MediaSessionMainContentPurpose::Autoplay))
836         return false;
837 
838     // Elements which are hidden by style, or have been scrolled out of view, cannot be main content.
839     // But elements which have audio &amp; video and are already playing should not stop playing because
840     // they are scrolled off the page.
841     if (renderer-&gt;style().visibility() != Visibility::Visible)
842         return false;
843     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes &amp;&amp; !element.isPlaying())
844         return false;
845 
846     // Main content elements must be in the main frame.
847     if (!document.frame() || !document.frame()-&gt;isMainFrame())
848         return false;
849 
850     auto&amp; mainFrame = document.frame()-&gt;mainFrame();
851     if (!mainFrame.view() || !mainFrame.view()-&gt;renderView())
852         return false;
853 
854     if (!shouldHitTestMainFrame)
855         return true;
856 
857     // Hit test the area of the main frame where the element appears, to determine if the element is being obscured.
858     IntRect rectRelativeToView = element.clientRect();
859     ScrollPosition scrollPosition = mainFrame.view()-&gt;documentScrollPositionRelativeToViewOrigin();
860     IntRect rectRelativeToTopDocument(rectRelativeToView.location() + scrollPosition, rectRelativeToView.size());
861     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent | HitTestRequest::IgnoreClipping | HitTestRequest::DisallowUserAgentShadowContent);
862     HitTestResult result(rectRelativeToTopDocument.center());
863 
864     // Elements which are obscured by other elements cannot be main content.
865     if (!mainFrame.document())
866         return false;
867     mainFrame.document()-&gt;hitTest(request, result);
868     result.setToNonUserAgentShadowAncestor();
869     RefPtr&lt;Element&gt; hitElement = result.targetElement();
870     if (hitElement != &amp;element)
871         return false;
872 
873     return true;
874 }
875 
876 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp; element)
877 {
878     if (!element.renderer())
879         return false;
880 
881     auto documentFrame = makeRefPtr(element.document().frame());
882     if (!documentFrame)
883         return false;
884 
885     auto mainFrameView = documentFrame-&gt;mainFrame().view();
886     if (!mainFrameView)
887         return false;
888 
889     IntRect mainFrameRectAdjustedForScrollPosition = IntRect(-mainFrameView-&gt;documentScrollPositionRelativeToViewOrigin(), mainFrameView-&gt;contentsSize());
890     IntRect elementRectInMainFrame = element.clientRect();
891     auto totalElementArea = elementRectInMainFrame.area&lt;RecordOverflow&gt;();
892     if (totalElementArea.hasOverflowed())
893         return false;
894 
895     elementRectInMainFrame.intersect(mainFrameRectAdjustedForScrollPosition);
896 
897     return elementRectInMainFrame.area().unsafeGet() &gt; totalElementArea.unsafeGet() / 2;
898 }
899 
900 static bool isElementLargeRelativeToMainFrame(const HTMLMediaElement&amp; element)
901 {
902     static const double minimumPercentageOfMainFrameAreaForMainContent = 0.9;
903     auto* renderer = element.renderer();
904     if (!renderer)
905         return false;
906 
907     auto documentFrame = makeRefPtr(element.document().frame());
908     if (!documentFrame)
909         return false;
910 
911     if (!documentFrame-&gt;mainFrame().view())
912         return false;
913 
914     auto&amp; mainFrameView = *documentFrame-&gt;mainFrame().view();
915     auto maxVisibleClientWidth = std::min(renderer-&gt;clientWidth().toInt(), mainFrameView.visibleWidth());
916     auto maxVisibleClientHeight = std::min(renderer-&gt;clientHeight().toInt(), mainFrameView.visibleHeight());
917 
918     return maxVisibleClientWidth * maxVisibleClientHeight &gt; minimumPercentageOfMainFrameAreaForMainContent * mainFrameView.visibleWidth() * mainFrameView.visibleHeight();
919 }
920 
921 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp; element, MediaSessionMainContentPurpose purpose)
922 {
923     static const double elementMainContentAreaMinimum = 400 * 300;
924     static const double maximumAspectRatio = purpose == MediaSessionMainContentPurpose::MediaControls ? 3 : 1.8;
925     static const double minimumAspectRatio = .5; // Slightly smaller than 9:16.
926 
927     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
928     auto* renderer = element.renderer();
929     if (!renderer)
930         return false;
931 
932     double width = renderer-&gt;clientWidth();
933     double height = renderer-&gt;clientHeight();
934     double area = width * height;
935     double aspectRatio = width / height;
936 
937     if (area &lt; elementMainContentAreaMinimum)
938         return false;
939 
940     if (aspectRatio &gt;= minimumAspectRatio &amp;&amp; aspectRatio &lt;= maximumAspectRatio)
941         return true;
942 
943     return isElementLargeRelativeToMainFrame(element);
944 }
945 
946 void MediaElementSession::mainContentCheckTimerFired()
947 {
948     if (!hasBehaviorRestriction(OverrideUserGestureRequirementForMainContent))
949         return;
950 
951     updateIsMainContent();
952 }
953 
954 bool MediaElementSession::updateIsMainContent() const
955 {
956     if (m_element.isSuspended())
957         return false;
958 
959     bool wasMainContent = m_isMainContent;
960     m_isMainContent = isElementMainContentForPurposesOfAutoplay(m_element, true);
961 
962     if (m_isMainContent != wasMainContent)
963         m_element.updateShouldPlay();
964 
965     return m_isMainContent;
966 }
967 
968 bool MediaElementSession::allowsNowPlayingControlsVisibility() const
969 {
970     auto page = m_element.document().page();
971     return page &amp;&amp; !page-&gt;isVisibleAndActive();
972 }
973 
974 bool MediaElementSession::allowsPlaybackControlsForAutoplayingAudio() const
975 {
976     auto page = m_element.document().page();
977     return page &amp;&amp; page-&gt;allowsPlaybackControlsForAutoplayingAudio();
978 }
979 
<a name="24" id="anc24"></a>















980 }
981 
982 #endif // ENABLE(VIDEO)
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>