<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptWrappable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  41 #endif
  42 #include &quot;JSDOMBinding.h&quot;
  43 #include &quot;JSDOMConvertBufferSource.h&quot;
  44 #include &quot;JSDOMGlobalObject.h&quot;
  45 #include &quot;JSDOMMatrix.h&quot;
  46 #include &quot;JSDOMPoint.h&quot;
  47 #include &quot;JSDOMQuad.h&quot;
  48 #include &quot;JSDOMRect.h&quot;
  49 #include &quot;JSFile.h&quot;
  50 #include &quot;JSFileList.h&quot;
  51 #include &quot;JSImageBitmap.h&quot;
  52 #include &quot;JSImageData.h&quot;
  53 #include &quot;JSMessagePort.h&quot;
  54 #include &quot;JSNavigator.h&quot;
  55 #include &quot;JSRTCCertificate.h&quot;
  56 #include &quot;ScriptExecutionContext.h&quot;
  57 #include &quot;ScriptState.h&quot;
  58 #include &quot;SharedBuffer.h&quot;
  59 #include &quot;WebCoreJSClientData.h&quot;
  60 #include &lt;JavaScriptCore/APICast.h&gt;
<span class="line-removed">  61 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
  62 #include &lt;JavaScriptCore/BooleanObject.h&gt;
  63 #include &lt;JavaScriptCore/CatchScope.h&gt;
  64 #include &lt;JavaScriptCore/DateInstance.h&gt;
  65 #include &lt;JavaScriptCore/Error.h&gt;
  66 #include &lt;JavaScriptCore/Exception.h&gt;
  67 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  68 #include &lt;JavaScriptCore/IterationKind.h&gt;
  69 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
  70 #include &lt;JavaScriptCore/JSArrayBufferView.h&gt;
  71 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  72 #include &lt;JavaScriptCore/JSDataView.h&gt;
  73 #include &lt;JavaScriptCore/JSMap.h&gt;
  74 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  75 #include &lt;JavaScriptCore/JSSet.h&gt;
  76 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  77 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  78 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  79 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  80 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  81 #include &lt;JavaScriptCore/RegExp.h&gt;
  82 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  84 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  85 #include &lt;JavaScriptCore/WasmModule.h&gt;

  86 #include &lt;limits&gt;

  87 #include &lt;wtf/MainThread.h&gt;
  88 #include &lt;wtf/RunLoop.h&gt;
  89 #include &lt;wtf/Vector.h&gt;
  90 
  91 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  92 #define ASSUME_LITTLE_ENDIAN 0
  93 #else
  94 #define ASSUME_LITTLE_ENDIAN 1
  95 #endif
  96 
  97 namespace WebCore {
  98 using namespace JSC;
  99 
 100 static const unsigned maximumFilterRecursion = 40000;
 101 
 102 enum class SerializationReturnCode {
 103     SuccessfullyCompleted,
 104     StackOverflowError,
 105     InterruptedExecutionError,
 106     ValidationError,
</pre>
<hr />
<pre>
 532             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 533             value &gt;&gt;= 8;
 534         }
 535     }
 536 #endif
 537     return true;
 538 }
 539 
 540 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 541 {
 542     buffer.append(values, length);
 543     return true;
 544 }
 545 
 546 class CloneSerializer : CloneBase {
 547 public:
 548     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 549 #if ENABLE(WEBASSEMBLY)
 550             WasmModuleArray&amp; wasmModules,
 551 #endif
<span class="line-modified"> 552         Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 553     {
 554         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,
 555 #if ENABLE(WEBASSEMBLY)
 556             wasmModules,
 557 #endif
<span class="line-modified"> 558             blobURLs, sessionID, out, context, sharedBuffers);</span>
 559         return serializer.serialize(value);
 560     }
 561 
 562     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 563     {
 564         writeLittleEndian(out, CurrentVersion);
 565         if (string.isEmpty()) {
 566             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 567             return true;
 568         }
 569         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 570         if (string.is8Bit()) {
 571             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 572             return writeLittleEndian(out, string.characters8(), string.length());
 573         }
 574         writeLittleEndian(out, string.length());
 575         return writeLittleEndian(out, string.characters16(), string.length());
 576     }
 577 
 578 private:
 579     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 580 
 581     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 582 #if ENABLE(WEBASSEMBLY)
 583             WasmModuleArray&amp; wasmModules,
 584 #endif
<span class="line-modified"> 585         Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 586         : CloneBase(exec)
 587         , m_buffer(out)
 588         , m_blobURLs(blobURLs)
<span class="line-modified"> 589         , m_sessionID(sessionID)</span>
<span class="line-removed"> 590         , m_emptyIdentifier(Identifier::fromString(exec, emptyString()))</span>
 591         , m_context(context)
 592         , m_sharedBuffers(sharedBuffers)
 593 #if ENABLE(WEBASSEMBLY)
 594         , m_wasmModules(wasmModules)
 595 #endif
 596     {
 597         write(CurrentVersion);
 598         fillTransferMap(messagePorts, m_transferredMessagePorts);
 599         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 600         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
 601     }
 602 
 603     template &lt;class T&gt;
 604     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 605     {
 606         if (input.isEmpty())
 607             return;
 608         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());
 609         for (size_t i = 0; i &lt; input.size(); i++) {
 610             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());
</pre>
<hr />
<pre>
1042                     }
1043                 }
1044 
1045                 write(ArrayBufferTag);
1046                 write(arrayBuffer-&gt;byteLength());
1047                 write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
1048                 return true;
1049             }
1050             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1051                 if (checkForDuplicate(obj))
1052                     return true;
1053                 bool success = dumpArrayBufferView(obj, code);
1054                 recordObject(obj);
1055                 return success;
1056             }
1057 #if ENABLE(WEB_CRYPTO)
1058             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1059                 write(CryptoKeyTag);
1060                 Vector&lt;uint8_t&gt; serializedKey;
1061                 Vector&lt;String&gt; dummyBlobURLs;
<span class="line-removed">1062                 PAL::SessionID dummySessionID;</span>
1063                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1064                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1065 #if ENABLE(WEBASSEMBLY)
1066                 WasmModuleArray dummyModules;
1067 #endif
1068                 ArrayBufferContentsArray dummySharedBuffers;
1069                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },
1070 #if ENABLE(WEBASSEMBLY)
1071                     dummyModules,
1072 #endif
<span class="line-modified">1073                     dummyBlobURLs, dummySessionID, serializedKey, SerializationContext::Default, dummySharedBuffers);</span>
1074                 rawKeySerializer.write(key);
1075                 Vector&lt;uint8_t&gt; wrappedKey;
1076                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))
1077                     return false;
1078                 write(wrappedKey);
1079                 return true;
1080             }
1081 #endif
1082 #if ENABLE(WEB_RTC)
1083             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1084                 write(RTCCertificateTag);
1085                 write(rtcCertificate-&gt;expires());
1086                 write(rtcCertificate-&gt;pemCertificate());
1087                 write(rtcCertificate-&gt;origin().toString());
1088                 write(rtcCertificate-&gt;pemPrivateKey());
1089                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1090                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1091                     write(fingerprint.algorithm);
1092                     write(fingerprint.value);
1093                 }
</pre>
<hr />
<pre>
1243             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1244         else
1245             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1246 
1247         if (!length)
1248             return;
1249         if (str.is8Bit()) {
1250             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1251                 fail();
1252             return;
1253         }
1254         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1255             fail();
1256     }
1257 
1258     void write(const String&amp; str)
1259     {
1260         if (str.isNull())
1261             write(m_emptyIdentifier);
1262         else
<span class="line-modified">1263             write(Identifier::fromString(m_exec, str));</span>
1264     }
1265 
1266     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1267     {
1268         uint32_t size = vector.size();
1269         write(size);
1270         writeLittleEndian(m_buffer, vector.data(), size);
1271     }
1272 
1273     void write(const File&amp; file)
1274     {
1275         m_blobURLs.append(file.url());
1276         write(file.path());
1277         write(file.url());
1278         write(file.type());
1279         write(file.name());
1280         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1281     }
1282 
1283 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1452             write(CryptoKeyClassSubtag::RSA);
1453             write(key-&gt;algorithmIdentifier());
1454             CryptoAlgorithmIdentifier hash;
1455             bool isRestrictedToHash = downcast&lt;CryptoKeyRSA&gt;(*key).isRestrictedToHash(hash);
1456             write(isRestrictedToHash);
1457             if (isRestrictedToHash)
1458                 write(hash);
1459             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1460             break;
1461         }
1462     }
1463 #endif
1464 
1465     void write(const uint8_t* data, unsigned length)
1466     {
1467         m_buffer.append(data, length);
1468     }
1469 
1470     Vector&lt;uint8_t&gt;&amp; m_buffer;
1471     Vector&lt;String&gt;&amp; m_blobURLs;
<span class="line-removed">1472     PAL::SessionID m_sessionID;</span>
1473     ObjectPool m_objectPool;
1474     ObjectPool m_transferredMessagePorts;
1475     ObjectPool m_transferredArrayBuffers;
1476     ObjectPool m_transferredImageBitmaps;
1477     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1478     StringConstantPool m_constantPool;
1479     Identifier m_emptyIdentifier;
1480     SerializationContext m_context;
1481     ArrayBufferContentsArray&amp; m_sharedBuffers;
1482 #if ENABLE(WEBASSEMBLY)
1483     WasmModuleArray&amp; m_wasmModules;
1484 #endif
1485 };
1486 
1487 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1488 {
1489     VM&amp; vm = m_exec-&gt;vm();
1490     Vector&lt;uint32_t, 16&gt; indexStack;
1491     Vector&lt;uint32_t, 16&gt; lengthStack;
1492     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
</pre>
<hr />
<pre>
1505                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1506                     return SerializationReturnCode::StackOverflowError;
1507 
1508                 JSArray* inArray = asArray(inValue);
1509                 unsigned length = inArray-&gt;length();
1510                 if (!startArray(inArray))
1511                     break;
1512                 inputObjectStack.append(inArray);
1513                 indexStack.append(0);
1514                 lengthStack.append(length);
1515             }
1516             arrayStartVisitMember:
1517             FALLTHROUGH;
1518             case ArrayStartVisitMember: {
1519                 JSObject* array = inputObjectStack.last();
1520                 uint32_t index = indexStack.last();
1521                 if (index == lengthStack.last()) {
1522                     indexStack.removeLast();
1523                     lengthStack.removeLast();
1524 
<span class="line-modified">1525                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1526                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());
1527                     if (propertyStack.last().size()) {
1528                         write(NonIndexPropertiesTag);
1529                         indexStack.append(0);
1530                         goto objectStartVisitMember;
1531                     }
1532                     propertyStack.removeLast();
1533 
1534                     endObject();
1535                     inputObjectStack.removeLast();
1536                     break;
1537                 }
1538                 inValue = array-&gt;getDirectIndex(m_exec, index);
1539                 if (!inValue) {
1540                     indexStack.last()++;
1541                     goto arrayStartVisitMember;
1542                 }
1543 
1544                 write(index);
1545                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
</pre>
<hr />
<pre>
1555             case ArrayEndVisitMember: {
1556                 indexStack.last()++;
1557                 goto arrayStartVisitMember;
1558             }
1559             objectStartState:
1560             case ObjectStartState: {
1561                 ASSERT(inValue.isObject());
1562                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1563                     return SerializationReturnCode::StackOverflowError;
1564                 JSObject* inObject = asObject(inValue);
1565                 if (!startObject(inObject))
1566                     break;
1567                 // At this point, all supported objects other than Object
1568                 // objects have been handled. If we reach this point and
1569                 // the input is not an Object object then we should throw
1570                 // a DataCloneError.
1571                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1572                     return SerializationReturnCode::DataCloneError;
1573                 inputObjectStack.append(inObject);
1574                 indexStack.append(0);
<span class="line-modified">1575                 propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1576                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());
1577             }
1578             objectStartVisitMember:
1579             FALLTHROUGH;
1580             case ObjectStartVisitMember: {
1581                 JSObject* object = inputObjectStack.last();
1582                 uint32_t index = indexStack.last();
1583                 PropertyNameArray&amp; properties = propertyStack.last();
1584                 if (index == properties.size()) {
1585                     endObject();
1586                     inputObjectStack.removeLast();
1587                     indexStack.removeLast();
1588                     propertyStack.removeLast();
1589                     break;
1590                 }
1591                 inValue = getProperty(vm, object, properties[index]);
1592                 if (shouldTerminate())
1593                     return SerializationReturnCode::ExistingExceptionError;
1594 
1595                 if (!inValue) {
</pre>
<hr />
<pre>
1608                     goto stateUnknown;
1609                 }
1610                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1611                     return terminalCode;
1612                 FALLTHROUGH;
1613             }
1614             case ObjectEndVisitMember: {
1615                 if (shouldTerminate())
1616                     return SerializationReturnCode::ExistingExceptionError;
1617 
1618                 indexStack.last()++;
1619                 goto objectStartVisitMember;
1620             }
1621             mapStartState: {
1622                 ASSERT(inValue.isObject());
1623                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1624                     return SerializationReturnCode::StackOverflowError;
1625                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1626                 if (!startMap(inMap))
1627                     break;
<span class="line-modified">1628                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure.get(), inMap, IterateKeyValue);</span>
1629                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1630                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1631                 mapIteratorStack.append(iterator);
1632                 inputObjectStack.append(inMap);
1633                 goto mapDataStartVisitEntry;
1634             }
1635             mapDataStartVisitEntry:
1636             case MapDataStartVisitEntry: {
1637                 JSMapIterator* iterator = mapIteratorStack.last();
1638                 JSValue key, value;
1639                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {
1640                     mapIteratorStack.removeLast();
1641                     JSObject* object = inputObjectStack.last();
1642                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
<span class="line-modified">1643                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1644                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1645                     write(NonMapPropertiesTag);
1646                     indexStack.append(0);
1647                     goto objectStartVisitMember;
1648                 }
1649                 inValue = key;
1650                 m_gcBuffer.appendWithCrashOnOverflow(value);
1651                 mapIteratorValueStack.append(value);
1652                 stateStack.append(MapDataEndVisitKey);
1653                 goto stateUnknown;
1654             }
1655             case MapDataEndVisitKey: {
1656                 inValue = mapIteratorValueStack.last();
1657                 mapIteratorValueStack.removeLast();
1658                 stateStack.append(MapDataEndVisitValue);
1659                 goto stateUnknown;
1660             }
1661             case MapDataEndVisitValue: {
1662                 goto mapDataStartVisitEntry;
1663             }
1664 
1665             setStartState: {
1666                 ASSERT(inValue.isObject());
1667                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1668                     return SerializationReturnCode::StackOverflowError;
1669                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1670                 if (!startSet(inSet))
1671                     break;
<span class="line-modified">1672                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure.get(), inSet, IterateKey);</span>
1673                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1674                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1675                 setIteratorStack.append(iterator);
1676                 inputObjectStack.append(inSet);
1677                 goto setDataStartVisitEntry;
1678             }
1679             setDataStartVisitEntry:
1680             case SetDataStartVisitEntry: {
1681                 JSSetIterator* iterator = setIteratorStack.last();
1682                 JSValue key;
1683                 if (!iterator-&gt;next(m_exec, key)) {
1684                     setIteratorStack.removeLast();
1685                     JSObject* object = inputObjectStack.last();
1686                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
<span class="line-modified">1687                     propertyStack.append(PropertyNameArray(&amp;vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1688                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1689                     write(NonSetPropertiesTag);
1690                     indexStack.append(0);
1691                     goto objectStartVisitMember;
1692                 }
1693                 inValue = key;
1694                 stateStack.append(SetDataEndVisitKey);
1695                 goto stateUnknown;
1696             }
1697             case SetDataEndVisitKey: {
1698                 goto setDataStartVisitEntry;
1699             }
1700 
1701             stateUnknown:
1702             case StateUnknown: {
1703                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1704                 if (dumpIfTerminal(inValue, terminalCode)) {
1705                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1706                         return terminalCode;
1707                     break;
</pre>
<hr />
<pre>
1736             return String();
1737         const uint8_t* ptr = buffer.begin();
1738         const uint8_t* end = buffer.end();
1739         uint32_t version;
1740         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1741             return String();
1742         uint8_t tag;
1743         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1744             return String();
1745         uint32_t length;
1746         if (!readLittleEndian(ptr, end, length))
1747             return String();
1748         bool is8Bit = length &amp; StringDataIs8BitFlag;
1749         length &amp;= ~StringDataIs8BitFlag;
1750         String str;
1751         if (!readString(ptr, end, str, length, is8Bit))
1752             return String();
1753         return str;
1754     }
1755 
<span class="line-modified">1756     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
1757 #if ENABLE(WEBASSEMBLY)
1758         , WasmModuleArray* wasmModules
1759 #endif
1760         )
1761     {
1762         if (!buffer.size())
1763             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">1764         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, sessionID, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
1765 #if ENABLE(WEBASSEMBLY)
1766             , wasmModules
1767 #endif
1768             );
1769         if (!deserializer.isValid())
1770             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1771         return deserializer.deserialize();
1772     }
1773 
1774 private:
1775     struct CachedString {
1776         CachedString(const String&amp; string)
1777             : m_string(string)
1778         {
1779         }
1780 
1781         JSValue jsString(ExecState* exec)
1782         {
1783             if (!m_jsString)
<span class="line-modified">1784                 m_jsString = JSC::jsString(exec, m_string);</span>
1785             return m_jsString;
1786         }
1787         const String&amp; string() { return m_string; }
1788         String takeString() { return WTFMove(m_string); }
1789 
1790     private:
1791         String m_string;
1792         JSValue m_jsString;
1793     };
1794 
1795     struct CachedStringRef {
1796         CachedStringRef()
1797             : m_base(0)
1798             , m_index(0)
1799         {
1800         }
1801         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1802             : m_base(base)
1803             , m_index(index)
1804         {
</pre>
<hr />
<pre>
1818         const Vector&lt;uint8_t&gt;&amp; buffer)
1819         : CloneBase(exec)
1820         , m_globalObject(globalObject)
1821         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1822         , m_ptr(buffer.data())
1823         , m_end(buffer.data() + buffer.size())
1824         , m_version(0xFFFFFFFF)
1825         , m_messagePorts(messagePorts)
1826         , m_arrayBufferContents(arrayBufferContents)
1827         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1828         , m_imageBuffers(WTFMove(imageBuffers))
1829         , m_imageBitmaps(m_imageBuffers.size())
1830 #if ENABLE(WEBASSEMBLY)
1831         , m_wasmModules(wasmModules)
1832 #endif
1833     {
1834         if (!read(m_version))
1835             m_version = 0xFFFFFFFF;
1836     }
1837 
<span class="line-modified">1838     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
1839 #if ENABLE(WEBASSEMBLY)
1840         , WasmModuleArray* wasmModules
1841 #endif
1842         )
1843         : CloneBase(exec)
1844         , m_globalObject(globalObject)
1845         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1846         , m_ptr(buffer.data())
1847         , m_end(buffer.data() + buffer.size())
1848         , m_version(0xFFFFFFFF)
1849         , m_messagePorts(messagePorts)
1850         , m_arrayBufferContents(arrayBufferContents)
1851         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1852         , m_blobURLs(blobURLs)
<span class="line-removed">1853         , m_sessionID(sessionID)</span>
1854         , m_blobFilePaths(blobFilePaths)
1855         , m_sharedBuffers(sharedBuffers)
1856         , m_imageBuffers(WTFMove(imageBuffers))
1857         , m_imageBitmaps(m_imageBuffers.size())
1858 #if ENABLE(WEBASSEMBLY)
1859         , m_wasmModules(wasmModules)
1860 #endif
1861     {
1862         if (!read(m_version))
1863             m_version = 0xFFFFFFFF;
1864     }
1865 
1866     DeserializationResult deserialize();
1867 
1868     bool isValid() const { return m_version &lt;= CurrentVersion; }
1869 
1870     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1871     {
1872         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1873             fail();
</pre>
<hr />
<pre>
2079         if (!readStringData(type))
2080             return false;
2081         CachedStringRef name;
2082         if (!readStringData(name))
2083             return false;
2084         Optional&lt;int64_t&gt; optionalLastModified;
2085         if (m_version &gt; 6) {
2086             double lastModified;
2087             if (!read(lastModified))
2088                 return false;
2089             if (lastModified &gt;= 0)
2090                 optionalLastModified = lastModified;
2091         }
2092 
2093         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2094         String filePath = blobFilePathForBlobURL(url-&gt;string());
2095         if (filePath.isEmpty())
2096             filePath = path-&gt;string();
2097 
2098         if (m_isDOMGlobalObject)
<span class="line-modified">2099             file = File::deserialize(filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
2100         return true;
2101     }
2102 
2103     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2104     {
2105         uint32_t length;
2106         if (!read(length))
2107             return false;
2108         if (m_ptr + length &gt; m_end)
2109             return false;
2110         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2111         m_ptr += length;
2112         return true;
2113     }
2114 
2115     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2116     {
2117         ArrayBufferViewSubtag arrayBufferViewSubtag;
2118         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2119             return false;
2120         uint32_t byteOffset;
2121         if (!read(byteOffset))
2122             return false;
2123         uint32_t byteLength;
2124         if (!read(byteLength))
2125             return false;
2126         JSObject* arrayBufferObj = asObject(readTerminal());
2127         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2128             return false;
2129 
2130         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2131         if (!elementSize)
2132             return false;
2133         unsigned length = byteLength / elementSize;
2134         if (length * elementSize != byteLength)
2135             return false;
2136 
2137         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2138         switch (arrayBufferViewSubtag) {
2139         case DataViewTag:
<span class="line-modified">2140             arrayBufferView = getJSValue(DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2141             return true;
2142         case Int8ArrayTag:
2143             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2144             return true;
2145         case Uint8ArrayTag:
2146             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2147             return true;
2148         case Uint8ClampedArrayTag:
2149             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2150             return true;
2151         case Int16ArrayTag:
2152             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2153             return true;
2154         case Uint16ArrayTag:
2155             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2156             return true;
2157         case Int32ArrayTag:
2158             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2159             return true;
2160         case Uint32ArrayTag:
</pre>
<hr />
<pre>
2639             return { };
2640         double height;
2641         if (!read(height))
2642             return { };
2643 
2644         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));
2645     }
2646 
2647     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2648     {
2649         DOMPointInit point;
2650         if (!read(point.x))
2651             return WTF::nullopt;
2652         if (!read(point.y))
2653             return WTF::nullopt;
2654         if (!read(point.z))
2655             return WTF::nullopt;
2656         if (!read(point.w))
2657             return WTF::nullopt;
2658 
<span class="line-modified">2659         return WTFMove(point);</span>
2660     }
2661 
2662     JSValue readDOMQuad()
2663     {
2664         auto p1 = readDOMPointInit();
2665         if (!p1)
2666             return JSValue();
2667         auto p2 = readDOMPointInit();
2668         if (!p2)
2669             return JSValue();
2670         auto p3 = readDOMPointInit();
2671         if (!p3)
2672             return JSValue();
2673         auto p4 = readDOMPointInit();
2674         if (!p4)
2675             return JSValue();
2676 
2677         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
2678     }
2679 
</pre>
<hr />
<pre>
2845             }
2846             if (length)
2847                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2848             else
2849                 result-&gt;data()-&gt;zeroFill();
2850             m_ptr += length;
2851             return getJSValue(result.get());
2852         }
2853         case BlobTag: {
2854             CachedStringRef url;
2855             if (!readStringData(url))
2856                 return JSValue();
2857             CachedStringRef type;
2858             if (!readStringData(type))
2859                 return JSValue();
2860             unsigned long long size = 0;
2861             if (!read(size))
2862                 return JSValue();
2863             if (!m_isDOMGlobalObject)
2864                 return jsNull();
<span class="line-modified">2865             return getJSValue(Blob::deserialize(URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
2866         }
2867         case StringTag: {
2868             CachedStringRef cachedString;
2869             if (!readStringData(cachedString))
2870                 return JSValue();
2871             return cachedString-&gt;jsString(m_exec);
2872         }
2873         case EmptyStringTag:
<span class="line-modified">2874             return jsEmptyString(&amp;m_exec-&gt;vm());</span>
2875         case StringObjectTag: {
2876             CachedStringRef cachedString;
2877             if (!readStringData(cachedString))
2878                 return JSValue();
2879             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));
2880             m_gcBuffer.appendWithCrashOnOverflow(obj);
2881             return obj;
2882         }
2883         case EmptyStringObjectTag: {
2884             VM&amp; vm = m_exec-&gt;vm();
<span class="line-modified">2885             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(&amp;vm));</span>
2886             m_gcBuffer.appendWithCrashOnOverflow(obj);
2887             return obj;
2888         }
2889         case RegExpTag: {
2890             CachedStringRef pattern;
2891             if (!readStringData(pattern))
2892                 return JSValue();
2893             CachedStringRef flags;
2894             if (!readStringData(flags))
2895                 return JSValue();
<span class="line-modified">2896             RegExpFlags reFlags = regExpFlags(flags-&gt;string());</span>
<span class="line-modified">2897             ASSERT(reFlags != InvalidFlags);</span>
2898             VM&amp; vm = m_exec-&gt;vm();
<span class="line-modified">2899             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags);</span>
2900             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
2901         }
2902         case ObjectReferenceTag: {
2903             unsigned index = 0;
2904             if (!readConstantPoolIndex(m_gcBuffer, index)) {
2905                 fail();
2906                 return JSValue();
2907             }
2908             return m_gcBuffer.at(index);
2909         }
2910         case MessagePortReferenceTag: {
2911             uint32_t index;
2912             bool indexSuccessfullyRead = read(index);
2913             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
2914                 fail();
2915                 return JSValue();
2916             }
2917             return getJSValue(m_messagePorts[index].get());
2918         }
2919 #if ENABLE(WEBASSEMBLY)
2920         case WasmModuleTag: {
2921             uint32_t index;
2922             bool indexSuccessfullyRead = read(index);
2923             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
2924                 fail();
2925                 return JSValue();
2926             }
2927             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());
<span class="line-modified">2928             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;WebAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
2929             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
2930             // module to not have been a valid module. Therefore, createStub should
2931             // not trow.
2932             scope.releaseAssertNoException();
2933             m_gcBuffer.appendWithCrashOnOverflow(result);
2934             return result;
2935         }
2936 #endif
2937         case ArrayBufferTag: {
2938             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2939             if (!readArrayBuffer(arrayBuffer)) {
2940                 fail();
2941                 return JSValue();
2942             }
2943             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
2944             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
2945             // array buffers while the sender is. In that case, we would see a null structure here.
2946             if (!structure) {
2947                 fail();
2948                 return JSValue();
</pre>
<hr />
<pre>
3043 
3044     template&lt;SerializationTag Tag&gt;
3045     bool consumeCollectionDataTerminationIfPossible()
3046     {
3047         if (readTag() == Tag)
3048             return true;
3049         m_ptr--;
3050         return false;
3051     }
3052 
3053     JSGlobalObject* m_globalObject;
3054     bool m_isDOMGlobalObject;
3055     const uint8_t* m_ptr;
3056     const uint8_t* m_end;
3057     unsigned m_version;
3058     Vector&lt;CachedString&gt; m_constantPool;
3059     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3060     ArrayBufferContentsArray* m_arrayBufferContents;
3061     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3062     Vector&lt;String&gt; m_blobURLs;
<span class="line-removed">3063     PAL::SessionID m_sessionID;</span>
3064     Vector&lt;String&gt; m_blobFilePaths;
3065     ArrayBufferContentsArray* m_sharedBuffers;
3066     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3067     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
3068 #if ENABLE(WEBASSEMBLY)
3069     WasmModuleArray* m_wasmModules;
3070 #endif
3071 
3072     String blobFilePathForBlobURL(const String&amp; blobURL)
3073     {
3074         size_t i = 0;
3075         for (; i &lt; m_blobURLs.size(); ++i) {
3076             if (m_blobURLs[i] == blobURL)
3077                 break;
3078         }
3079 
3080         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3081     }
3082 };
3083 
</pre>
<hr />
<pre>
3151             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
3152             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3153             outputObjectStack.append(outObject);
3154         }
3155         objectStartVisitMember:
3156         FALLTHROUGH;
3157         case ObjectStartVisitMember: {
3158             CachedStringRef cachedString;
3159             bool wasTerminator = false;
3160             if (!readStringData(cachedString, wasTerminator)) {
3161                 if (!wasTerminator)
3162                     goto error;
3163 
3164                 JSObject* outObject = outputObjectStack.last();
3165                 outValue = outObject;
3166                 outputObjectStack.removeLast();
3167                 break;
3168             }
3169 
3170             if (JSValue terminal = readTerminal()) {
<span class="line-modified">3171                 putProperty(outputObjectStack.last(), Identifier::fromString(m_exec, cachedString-&gt;string()), terminal);</span>
3172                 goto objectStartVisitMember;
3173             }
3174             stateStack.append(ObjectEndVisitMember);
<span class="line-modified">3175             propertyNameStack.append(Identifier::fromString(m_exec, cachedString-&gt;string()));</span>
3176             goto stateUnknown;
3177         }
3178         case ObjectEndVisitMember: {
3179             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3180             propertyNameStack.removeLast();
3181             goto objectStartVisitMember;
3182         }
3183         mapObjectStartState: {
3184             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3185                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3186             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());
3187             if (UNLIKELY(scope.exception()))
3188                 goto error;
3189             m_gcBuffer.appendWithCrashOnOverflow(map);
3190             outputObjectStack.append(map);
3191             mapStack.append(map);
3192             goto mapDataStartVisitEntry;
3193         }
3194         mapDataStartVisitEntry:
3195         case MapDataStartVisitEntry: {
</pre>
<hr />
<pre>
3264     ASSERT(!m_failed);
3265     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3266 error:
3267     fail();
3268     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3269 }
3270 
3271 SerializedScriptValue::~SerializedScriptValue() = default;
3272 
3273 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3274     : m_data(WTFMove(buffer))
3275 {
3276 }
3277 
3278 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3279     : m_data(WTFMove(buffer))
3280     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3281 {
3282 }
3283 
<span class="line-modified">3284 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID,  std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
3285 #if ENABLE(WEBASSEMBLY)
3286         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3287 #endif
3288         )
3289     : m_data(WTFMove(buffer))
3290     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3291     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3292     , m_imageBuffers(WTFMove(imageBuffers))
3293 #if ENABLE(WEBASSEMBLY)
3294     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3295 #endif
<span class="line-removed">3296     , m_sessionID(sessionID)</span>
3297 {
3298     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3299     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3300     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3301     for (auto&amp; url : blobURLs)
3302         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3303 }
3304 
3305 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3306 {
3307     if (arrayBuffers.isEmpty())
3308         return nullptr;
3309 
<span class="line-modified">3310     auto contents = std::make_unique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());</span>
3311 
3312     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3313     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3314         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3315             continue;
3316         visited.add(arrayBuffers[arrayBufferIndex].get());
3317 
3318         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3319         if (!result)
3320             return Exception { TypeError };
3321     }
3322 
<span class="line-modified">3323     return WTFMove(contents);</span>
3324 }
3325 
3326 static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)
3327 {
3328     auto&amp; vm = state.vm();
3329     auto scope = DECLARE_THROW_SCOPE(vm);
3330 
3331     switch (code) {
3332     case SerializationReturnCode::SuccessfullyCompleted:
3333         break;
3334     case SerializationReturnCode::StackOverflowError:
3335         throwException(&amp;state, scope, createStackOverflowError(&amp;state));
3336         break;
3337     case SerializationReturnCode::ValidationError:
3338         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);
3339         break;
3340     case SerializationReturnCode::DataCloneError:
3341         throwDataCloneError(state, scope);
3342         break;
3343     case SerializationReturnCode::ExistingExceptionError:
</pre>
<hr />
<pre>
3359         return Exception { TypeError };
3360     case SerializationReturnCode::DataCloneError:
3361         return Exception { DataCloneError };
3362     case SerializationReturnCode::ExistingExceptionError:
3363         return Exception { ExistingExceptionError };
3364     case SerializationReturnCode::UnspecifiedError:
3365         return Exception { TypeError };
3366     case SerializationReturnCode::SuccessfullyCompleted:
3367     case SerializationReturnCode::InterruptedExecutionError:
3368         ASSERT_NOT_REACHED();
3369         return Exception { TypeError };
3370     }
3371     ASSERT_NOT_REACHED();
3372     return Exception { TypeError };
3373 }
3374 
3375 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)
3376 {
3377     Vector&lt;uint8_t&gt; buffer;
3378     Vector&lt;String&gt; blobURLs;
<span class="line-removed">3379     PAL::SessionID sessionID;</span>
3380     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3381     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
3382     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3383 #if ENABLE(WEBASSEMBLY)
3384     WasmModuleArray dummyModules;
3385 #endif
3386     ArrayBufferContentsArray dummySharedBuffers;
3387     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
3388 #if ENABLE(WEBASSEMBLY)
3389         dummyModules,
3390 #endif
<span class="line-modified">3391         blobURLs, sessionID, buffer, SerializationContext::Default, dummySharedBuffers);</span>
3392 
3393 #if ENABLE(WEBASSEMBLY)
3394     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3395 #endif
3396 
3397     if (throwExceptions == SerializationErrorMode::Throwing)
3398         maybeThrowExceptionIfSerializationFailed(exec, code);
3399 
3400     if (code != SerializationReturnCode::SuccessfullyCompleted)
3401         return nullptr;
3402 
<span class="line-modified">3403     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, sessionID, nullptr, nullptr, { }</span>
3404 #if ENABLE(WEBASSEMBLY)
3405         , nullptr
3406 #endif
3407             ));
3408 }
3409 
3410 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3411 {
3412     HashSet&lt;ImageBitmap*&gt; visited;
3413     for (auto&amp; imageBitmap : imageBitmaps) {
3414         if (!visited.add(imageBitmap.get()))
3415             return true;
3416     }
3417     return false;
3418 }
3419 
3420 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)
3421 {
3422     VM&amp; vm = state.vm();
3423     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
</pre>
<hr />
<pre>
3439             messagePorts.append(WTFMove(port));
3440             continue;
3441         }
3442 
3443         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3444             if (imageBitmap-&gt;isDetached())
3445                 return Exception { DataCloneError };
3446 
3447             imageBitmaps.append(WTFMove(imageBitmap));
3448             continue;
3449         }
3450 
3451         return Exception { DataCloneError };
3452     }
3453 
3454     if (containsDuplicates(imageBitmaps))
3455         return Exception { DataCloneError };
3456 
3457     Vector&lt;uint8_t&gt; buffer;
3458     Vector&lt;String&gt; blobURLs;
<span class="line-removed">3459     PAL::SessionID sessionID;</span>
3460 #if ENABLE(WEBASSEMBLY)
3461     WasmModuleArray wasmModules;
3462 #endif
<span class="line-modified">3463     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = std::make_unique&lt;ArrayBufferContentsArray&gt;();</span>
3464     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,
3465 #if ENABLE(WEBASSEMBLY)
3466         wasmModules,
3467 #endif
<span class="line-modified">3468         blobURLs, sessionID, buffer, context, *sharedBuffers);</span>
3469 
3470     if (code != SerializationReturnCode::SuccessfullyCompleted)
3471         return exceptionForSerializationFailure(code);
3472 
3473     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3474     if (arrayBufferContentsArray.hasException())
3475         return arrayBufferContentsArray.releaseException();
3476 
3477     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3478 
<span class="line-modified">3479     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, sessionID, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)</span>
3480 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">3481                 , std::make_unique&lt;WasmModuleArray&gt;(wasmModules)</span>
3482 #endif
3483                 ));
3484 }
3485 
3486 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3487 {
3488     Vector&lt;uint8_t&gt; buffer;
3489     if (!CloneSerializer::serialize(string, buffer))
3490         return nullptr;
3491     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3492 }
3493 
3494 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3495 {
3496     ExecState* exec = toJS(originContext);
3497     VM&amp; vm = exec-&gt;vm();
3498     JSLockHolder locker(vm);
3499     auto scope = DECLARE_CATCH_SCOPE(vm);
3500 
3501     JSValue value = toJS(exec, apiValue);
</pre>
<hr />
<pre>
3507         return nullptr;
3508     }
3509     ASSERT(serializedValue);
3510     return serializedValue;
3511 }
3512 
3513 String SerializedScriptValue::toString()
3514 {
3515     return CloneDeserializer::deserializeString(m_data);
3516 }
3517 
3518 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
3519 {
3520     return deserialize(exec, globalObject, { }, throwExceptions);
3521 }
3522 
3523 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)
3524 {
3525     Vector&lt;String&gt; dummyBlobs;
3526     Vector&lt;String&gt; dummyPaths;
<span class="line-modified">3527     PAL::SessionID dummySessionID;</span>
<span class="line-removed">3528     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummySessionID, dummyPaths, throwExceptions);</span>
3529 }
3530 
<span class="line-modified">3531 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const PAL::SessionID&amp; sessionID, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
3532 {
<span class="line-modified">3533     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, sessionID, blobFilePaths, m_sharedBufferContentsArray.get()</span>
3534 #if ENABLE(WEBASSEMBLY)
3535         , m_wasmModulesArray.get()
3536 #endif
3537         );
3538     if (throwExceptions == SerializationErrorMode::Throwing)
3539         maybeThrowExceptionIfSerializationFailed(exec, result.second);
3540     return result.first ? result.first : jsNull();
3541 }
3542 
3543 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3544 {
3545     ExecState* exec = toJS(destinationContext);
3546     VM&amp; vm = exec-&gt;vm();
3547     JSLockHolder locker(vm);
3548     auto scope = DECLARE_CATCH_SCOPE(vm);
3549 
3550     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());
3551     if (UNLIKELY(scope.exception())) {
3552         if (exception)
3553             *exception = toRef(exec, scope.exception()-&gt;value());
</pre>
<hr />
<pre>
3562 {
3563     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3564 }
3565 
3566 uint32_t SerializedScriptValue::wireFormatVersion()
3567 {
3568     return CurrentVersion;
3569 }
3570 
3571 #if ENABLE(INDEXED_DATABASE)
3572 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3573 {
3574     Vector&lt;String&gt; result;
3575     result.reserveInitialCapacity(m_blobURLs.size());
3576     for (auto&amp; url : m_blobURLs)
3577         result.uncheckedAppend(url.isolatedCopy());
3578 
3579     return result;
3580 }
3581 
<span class="line-modified">3582 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
3583 {
3584     ASSERT(isMainThread());
3585     ASSERT(hasBlobURLs());
3586 
<span class="line-modified">3587     // FIXME: Add m_sessionID as a parameter here.</span>
<span class="line-removed">3588     blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
3589         ASSERT(isMainThread());
3590 
3591         if (blobFilePaths.isEmpty()) {
3592             // We should have successfully written blobs to temporary files.
3593             // If we failed, then we can&#39;t successfully store this record.
3594             completionHandler({ });
3595             return;
3596         }
3597 
3598         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3599 
<span class="line-modified">3600         completionHandler({ *this, m_blobURLs, m_sessionID, blobFilePaths });</span>
3601     });
3602 }
3603 
<span class="line-modified">3604 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()</span>
3605 {
3606     ASSERT(!isMainThread());
3607 
3608     IDBValue value;
3609     Lock lock;
3610     Condition condition;
3611     lock.lock();
3612 
<span class="line-modified">3613     RunLoop::main().dispatch([this, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">3614         writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
3615             ASSERT(isMainThread());
3616             valuePtr-&gt;setAsIsolatedCopy(result);
3617 
3618             conditionPtr-&gt;notifyAll();
3619         });
3620     });
3621 
3622     condition.wait(lock);
3623 
3624     return value;
3625 }
3626 
3627 #endif // ENABLE(INDEXED_DATABASE)
3628 
3629 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  41 #endif
  42 #include &quot;JSDOMBinding.h&quot;
  43 #include &quot;JSDOMConvertBufferSource.h&quot;
  44 #include &quot;JSDOMGlobalObject.h&quot;
  45 #include &quot;JSDOMMatrix.h&quot;
  46 #include &quot;JSDOMPoint.h&quot;
  47 #include &quot;JSDOMQuad.h&quot;
  48 #include &quot;JSDOMRect.h&quot;
  49 #include &quot;JSFile.h&quot;
  50 #include &quot;JSFileList.h&quot;
  51 #include &quot;JSImageBitmap.h&quot;
  52 #include &quot;JSImageData.h&quot;
  53 #include &quot;JSMessagePort.h&quot;
  54 #include &quot;JSNavigator.h&quot;
  55 #include &quot;JSRTCCertificate.h&quot;
  56 #include &quot;ScriptExecutionContext.h&quot;
  57 #include &quot;ScriptState.h&quot;
  58 #include &quot;SharedBuffer.h&quot;
  59 #include &quot;WebCoreJSClientData.h&quot;
  60 #include &lt;JavaScriptCore/APICast.h&gt;

  61 #include &lt;JavaScriptCore/BooleanObject.h&gt;
  62 #include &lt;JavaScriptCore/CatchScope.h&gt;
  63 #include &lt;JavaScriptCore/DateInstance.h&gt;
  64 #include &lt;JavaScriptCore/Error.h&gt;
  65 #include &lt;JavaScriptCore/Exception.h&gt;
  66 #include &lt;JavaScriptCore/ExceptionHelpers.h&gt;
  67 #include &lt;JavaScriptCore/IterationKind.h&gt;
  68 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
  69 #include &lt;JavaScriptCore/JSArrayBufferView.h&gt;
  70 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  71 #include &lt;JavaScriptCore/JSDataView.h&gt;
  72 #include &lt;JavaScriptCore/JSMap.h&gt;
  73 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  74 #include &lt;JavaScriptCore/JSSet.h&gt;
  75 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  76 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  77 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  78 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  79 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  80 #include &lt;JavaScriptCore/RegExp.h&gt;
  81 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  82 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  84 #include &lt;JavaScriptCore/WasmModule.h&gt;
<span class="line-added">  85 #include &lt;JavaScriptCore/YarrFlags.h&gt;</span>
  86 #include &lt;limits&gt;
<span class="line-added">  87 #include &lt;wtf/CompletionHandler.h&gt;</span>
  88 #include &lt;wtf/MainThread.h&gt;
  89 #include &lt;wtf/RunLoop.h&gt;
  90 #include &lt;wtf/Vector.h&gt;
  91 
  92 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  93 #define ASSUME_LITTLE_ENDIAN 0
  94 #else
  95 #define ASSUME_LITTLE_ENDIAN 1
  96 #endif
  97 
  98 namespace WebCore {
  99 using namespace JSC;
 100 
 101 static const unsigned maximumFilterRecursion = 40000;
 102 
 103 enum class SerializationReturnCode {
 104     SuccessfullyCompleted,
 105     StackOverflowError,
 106     InterruptedExecutionError,
 107     ValidationError,
</pre>
<hr />
<pre>
 533             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 534             value &gt;&gt;= 8;
 535         }
 536     }
 537 #endif
 538     return true;
 539 }
 540 
 541 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 542 {
 543     buffer.append(values, length);
 544     return true;
 545 }
 546 
 547 class CloneSerializer : CloneBase {
 548 public:
 549     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 550 #if ENABLE(WEBASSEMBLY)
 551             WasmModuleArray&amp; wasmModules,
 552 #endif
<span class="line-modified"> 553         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 554     {
 555         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,
 556 #if ENABLE(WEBASSEMBLY)
 557             wasmModules,
 558 #endif
<span class="line-modified"> 559             blobURLs, out, context, sharedBuffers);</span>
 560         return serializer.serialize(value);
 561     }
 562 
 563     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 564     {
 565         writeLittleEndian(out, CurrentVersion);
 566         if (string.isEmpty()) {
 567             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 568             return true;
 569         }
 570         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 571         if (string.is8Bit()) {
 572             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 573             return writeLittleEndian(out, string.characters8(), string.length());
 574         }
 575         writeLittleEndian(out, string.length());
 576         return writeLittleEndian(out, string.characters16(), string.length());
 577     }
 578 
 579 private:
 580     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 581 
 582     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,
 583 #if ENABLE(WEBASSEMBLY)
 584             WasmModuleArray&amp; wasmModules,
 585 #endif
<span class="line-modified"> 586         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)</span>
 587         : CloneBase(exec)
 588         , m_buffer(out)
 589         , m_blobURLs(blobURLs)
<span class="line-modified"> 590         , m_emptyIdentifier(Identifier::fromString(exec-&gt;vm(), emptyString()))</span>

 591         , m_context(context)
 592         , m_sharedBuffers(sharedBuffers)
 593 #if ENABLE(WEBASSEMBLY)
 594         , m_wasmModules(wasmModules)
 595 #endif
 596     {
 597         write(CurrentVersion);
 598         fillTransferMap(messagePorts, m_transferredMessagePorts);
 599         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 600         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
 601     }
 602 
 603     template &lt;class T&gt;
 604     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 605     {
 606         if (input.isEmpty())
 607             return;
 608         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());
 609         for (size_t i = 0; i &lt; input.size(); i++) {
 610             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());
</pre>
<hr />
<pre>
1042                     }
1043                 }
1044 
1045                 write(ArrayBufferTag);
1046                 write(arrayBuffer-&gt;byteLength());
1047                 write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
1048                 return true;
1049             }
1050             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1051                 if (checkForDuplicate(obj))
1052                     return true;
1053                 bool success = dumpArrayBufferView(obj, code);
1054                 recordObject(obj);
1055                 return success;
1056             }
1057 #if ENABLE(WEB_CRYPTO)
1058             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1059                 write(CryptoKeyTag);
1060                 Vector&lt;uint8_t&gt; serializedKey;
1061                 Vector&lt;String&gt; dummyBlobURLs;

1062                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1063                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1064 #if ENABLE(WEBASSEMBLY)
1065                 WasmModuleArray dummyModules;
1066 #endif
1067                 ArrayBufferContentsArray dummySharedBuffers;
1068                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },
1069 #if ENABLE(WEBASSEMBLY)
1070                     dummyModules,
1071 #endif
<span class="line-modified">1072                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);</span>
1073                 rawKeySerializer.write(key);
1074                 Vector&lt;uint8_t&gt; wrappedKey;
1075                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))
1076                     return false;
1077                 write(wrappedKey);
1078                 return true;
1079             }
1080 #endif
1081 #if ENABLE(WEB_RTC)
1082             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1083                 write(RTCCertificateTag);
1084                 write(rtcCertificate-&gt;expires());
1085                 write(rtcCertificate-&gt;pemCertificate());
1086                 write(rtcCertificate-&gt;origin().toString());
1087                 write(rtcCertificate-&gt;pemPrivateKey());
1088                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1089                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1090                     write(fingerprint.algorithm);
1091                     write(fingerprint.value);
1092                 }
</pre>
<hr />
<pre>
1242             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1243         else
1244             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1245 
1246         if (!length)
1247             return;
1248         if (str.is8Bit()) {
1249             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1250                 fail();
1251             return;
1252         }
1253         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1254             fail();
1255     }
1256 
1257     void write(const String&amp; str)
1258     {
1259         if (str.isNull())
1260             write(m_emptyIdentifier);
1261         else
<span class="line-modified">1262             write(Identifier::fromString(m_exec-&gt;vm(), str));</span>
1263     }
1264 
1265     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1266     {
1267         uint32_t size = vector.size();
1268         write(size);
1269         writeLittleEndian(m_buffer, vector.data(), size);
1270     }
1271 
1272     void write(const File&amp; file)
1273     {
1274         m_blobURLs.append(file.url());
1275         write(file.path());
1276         write(file.url());
1277         write(file.type());
1278         write(file.name());
1279         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1280     }
1281 
1282 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1451             write(CryptoKeyClassSubtag::RSA);
1452             write(key-&gt;algorithmIdentifier());
1453             CryptoAlgorithmIdentifier hash;
1454             bool isRestrictedToHash = downcast&lt;CryptoKeyRSA&gt;(*key).isRestrictedToHash(hash);
1455             write(isRestrictedToHash);
1456             if (isRestrictedToHash)
1457                 write(hash);
1458             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1459             break;
1460         }
1461     }
1462 #endif
1463 
1464     void write(const uint8_t* data, unsigned length)
1465     {
1466         m_buffer.append(data, length);
1467     }
1468 
1469     Vector&lt;uint8_t&gt;&amp; m_buffer;
1470     Vector&lt;String&gt;&amp; m_blobURLs;

1471     ObjectPool m_objectPool;
1472     ObjectPool m_transferredMessagePorts;
1473     ObjectPool m_transferredArrayBuffers;
1474     ObjectPool m_transferredImageBitmaps;
1475     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1476     StringConstantPool m_constantPool;
1477     Identifier m_emptyIdentifier;
1478     SerializationContext m_context;
1479     ArrayBufferContentsArray&amp; m_sharedBuffers;
1480 #if ENABLE(WEBASSEMBLY)
1481     WasmModuleArray&amp; m_wasmModules;
1482 #endif
1483 };
1484 
1485 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1486 {
1487     VM&amp; vm = m_exec-&gt;vm();
1488     Vector&lt;uint32_t, 16&gt; indexStack;
1489     Vector&lt;uint32_t, 16&gt; lengthStack;
1490     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
</pre>
<hr />
<pre>
1503                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1504                     return SerializationReturnCode::StackOverflowError;
1505 
1506                 JSArray* inArray = asArray(inValue);
1507                 unsigned length = inArray-&gt;length();
1508                 if (!startArray(inArray))
1509                     break;
1510                 inputObjectStack.append(inArray);
1511                 indexStack.append(0);
1512                 lengthStack.append(length);
1513             }
1514             arrayStartVisitMember:
1515             FALLTHROUGH;
1516             case ArrayStartVisitMember: {
1517                 JSObject* array = inputObjectStack.last();
1518                 uint32_t index = indexStack.last();
1519                 if (index == lengthStack.last()) {
1520                     indexStack.removeLast();
1521                     lengthStack.removeLast();
1522 
<span class="line-modified">1523                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1524                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());
1525                     if (propertyStack.last().size()) {
1526                         write(NonIndexPropertiesTag);
1527                         indexStack.append(0);
1528                         goto objectStartVisitMember;
1529                     }
1530                     propertyStack.removeLast();
1531 
1532                     endObject();
1533                     inputObjectStack.removeLast();
1534                     break;
1535                 }
1536                 inValue = array-&gt;getDirectIndex(m_exec, index);
1537                 if (!inValue) {
1538                     indexStack.last()++;
1539                     goto arrayStartVisitMember;
1540                 }
1541 
1542                 write(index);
1543                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
</pre>
<hr />
<pre>
1553             case ArrayEndVisitMember: {
1554                 indexStack.last()++;
1555                 goto arrayStartVisitMember;
1556             }
1557             objectStartState:
1558             case ObjectStartState: {
1559                 ASSERT(inValue.isObject());
1560                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1561                     return SerializationReturnCode::StackOverflowError;
1562                 JSObject* inObject = asObject(inValue);
1563                 if (!startObject(inObject))
1564                     break;
1565                 // At this point, all supported objects other than Object
1566                 // objects have been handled. If we reach this point and
1567                 // the input is not an Object object then we should throw
1568                 // a DataCloneError.
1569                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1570                     return SerializationReturnCode::DataCloneError;
1571                 inputObjectStack.append(inObject);
1572                 indexStack.append(0);
<span class="line-modified">1573                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1574                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());
1575             }
1576             objectStartVisitMember:
1577             FALLTHROUGH;
1578             case ObjectStartVisitMember: {
1579                 JSObject* object = inputObjectStack.last();
1580                 uint32_t index = indexStack.last();
1581                 PropertyNameArray&amp; properties = propertyStack.last();
1582                 if (index == properties.size()) {
1583                     endObject();
1584                     inputObjectStack.removeLast();
1585                     indexStack.removeLast();
1586                     propertyStack.removeLast();
1587                     break;
1588                 }
1589                 inValue = getProperty(vm, object, properties[index]);
1590                 if (shouldTerminate())
1591                     return SerializationReturnCode::ExistingExceptionError;
1592 
1593                 if (!inValue) {
</pre>
<hr />
<pre>
1606                     goto stateUnknown;
1607                 }
1608                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1609                     return terminalCode;
1610                 FALLTHROUGH;
1611             }
1612             case ObjectEndVisitMember: {
1613                 if (shouldTerminate())
1614                     return SerializationReturnCode::ExistingExceptionError;
1615 
1616                 indexStack.last()++;
1617                 goto objectStartVisitMember;
1618             }
1619             mapStartState: {
1620                 ASSERT(inValue.isObject());
1621                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1622                     return SerializationReturnCode::StackOverflowError;
1623                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1624                 if (!startMap(inMap))
1625                     break;
<span class="line-modified">1626                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterateKeyValue);</span>
1627                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1628                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1629                 mapIteratorStack.append(iterator);
1630                 inputObjectStack.append(inMap);
1631                 goto mapDataStartVisitEntry;
1632             }
1633             mapDataStartVisitEntry:
1634             case MapDataStartVisitEntry: {
1635                 JSMapIterator* iterator = mapIteratorStack.last();
1636                 JSValue key, value;
1637                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {
1638                     mapIteratorStack.removeLast();
1639                     JSObject* object = inputObjectStack.last();
1640                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
<span class="line-modified">1641                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1642                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1643                     write(NonMapPropertiesTag);
1644                     indexStack.append(0);
1645                     goto objectStartVisitMember;
1646                 }
1647                 inValue = key;
1648                 m_gcBuffer.appendWithCrashOnOverflow(value);
1649                 mapIteratorValueStack.append(value);
1650                 stateStack.append(MapDataEndVisitKey);
1651                 goto stateUnknown;
1652             }
1653             case MapDataEndVisitKey: {
1654                 inValue = mapIteratorValueStack.last();
1655                 mapIteratorValueStack.removeLast();
1656                 stateStack.append(MapDataEndVisitValue);
1657                 goto stateUnknown;
1658             }
1659             case MapDataEndVisitValue: {
1660                 goto mapDataStartVisitEntry;
1661             }
1662 
1663             setStartState: {
1664                 ASSERT(inValue.isObject());
1665                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1666                     return SerializationReturnCode::StackOverflowError;
1667                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1668                 if (!startSet(inSet))
1669                     break;
<span class="line-modified">1670                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterateKey);</span>
1671                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1672                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1673                 setIteratorStack.append(iterator);
1674                 inputObjectStack.append(inSet);
1675                 goto setDataStartVisitEntry;
1676             }
1677             setDataStartVisitEntry:
1678             case SetDataStartVisitEntry: {
1679                 JSSetIterator* iterator = setIteratorStack.last();
1680                 JSValue key;
1681                 if (!iterator-&gt;next(m_exec, key)) {
1682                     setIteratorStack.removeLast();
1683                     JSObject* object = inputObjectStack.last();
1684                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
<span class="line-modified">1685                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));</span>
1686                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
1687                     write(NonSetPropertiesTag);
1688                     indexStack.append(0);
1689                     goto objectStartVisitMember;
1690                 }
1691                 inValue = key;
1692                 stateStack.append(SetDataEndVisitKey);
1693                 goto stateUnknown;
1694             }
1695             case SetDataEndVisitKey: {
1696                 goto setDataStartVisitEntry;
1697             }
1698 
1699             stateUnknown:
1700             case StateUnknown: {
1701                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1702                 if (dumpIfTerminal(inValue, terminalCode)) {
1703                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1704                         return terminalCode;
1705                     break;
</pre>
<hr />
<pre>
1734             return String();
1735         const uint8_t* ptr = buffer.begin();
1736         const uint8_t* end = buffer.end();
1737         uint32_t version;
1738         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1739             return String();
1740         uint8_t tag;
1741         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1742             return String();
1743         uint32_t length;
1744         if (!readLittleEndian(ptr, end, length))
1745             return String();
1746         bool is8Bit = length &amp; StringDataIs8BitFlag;
1747         length &amp;= ~StringDataIs8BitFlag;
1748         String str;
1749         if (!readString(ptr, end, str, length, is8Bit))
1750             return String();
1751         return str;
1752     }
1753 
<span class="line-modified">1754     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
1755 #if ENABLE(WEBASSEMBLY)
1756         , WasmModuleArray* wasmModules
1757 #endif
1758         )
1759     {
1760         if (!buffer.size())
1761             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">1762         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
1763 #if ENABLE(WEBASSEMBLY)
1764             , wasmModules
1765 #endif
1766             );
1767         if (!deserializer.isValid())
1768             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1769         return deserializer.deserialize();
1770     }
1771 
1772 private:
1773     struct CachedString {
1774         CachedString(const String&amp; string)
1775             : m_string(string)
1776         {
1777         }
1778 
1779         JSValue jsString(ExecState* exec)
1780         {
1781             if (!m_jsString)
<span class="line-modified">1782                 m_jsString = JSC::jsString(exec-&gt;vm(), m_string);</span>
1783             return m_jsString;
1784         }
1785         const String&amp; string() { return m_string; }
1786         String takeString() { return WTFMove(m_string); }
1787 
1788     private:
1789         String m_string;
1790         JSValue m_jsString;
1791     };
1792 
1793     struct CachedStringRef {
1794         CachedStringRef()
1795             : m_base(0)
1796             , m_index(0)
1797         {
1798         }
1799         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1800             : m_base(base)
1801             , m_index(index)
1802         {
</pre>
<hr />
<pre>
1816         const Vector&lt;uint8_t&gt;&amp; buffer)
1817         : CloneBase(exec)
1818         , m_globalObject(globalObject)
1819         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1820         , m_ptr(buffer.data())
1821         , m_end(buffer.data() + buffer.size())
1822         , m_version(0xFFFFFFFF)
1823         , m_messagePorts(messagePorts)
1824         , m_arrayBufferContents(arrayBufferContents)
1825         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1826         , m_imageBuffers(WTFMove(imageBuffers))
1827         , m_imageBitmaps(m_imageBuffers.size())
1828 #if ENABLE(WEBASSEMBLY)
1829         , m_wasmModules(wasmModules)
1830 #endif
1831     {
1832         if (!read(m_version))
1833             m_version = 0xFFFFFFFF;
1834     }
1835 
<span class="line-modified">1836     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
1837 #if ENABLE(WEBASSEMBLY)
1838         , WasmModuleArray* wasmModules
1839 #endif
1840         )
1841         : CloneBase(exec)
1842         , m_globalObject(globalObject)
1843         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1844         , m_ptr(buffer.data())
1845         , m_end(buffer.data() + buffer.size())
1846         , m_version(0xFFFFFFFF)
1847         , m_messagePorts(messagePorts)
1848         , m_arrayBufferContents(arrayBufferContents)
1849         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1850         , m_blobURLs(blobURLs)

1851         , m_blobFilePaths(blobFilePaths)
1852         , m_sharedBuffers(sharedBuffers)
1853         , m_imageBuffers(WTFMove(imageBuffers))
1854         , m_imageBitmaps(m_imageBuffers.size())
1855 #if ENABLE(WEBASSEMBLY)
1856         , m_wasmModules(wasmModules)
1857 #endif
1858     {
1859         if (!read(m_version))
1860             m_version = 0xFFFFFFFF;
1861     }
1862 
1863     DeserializationResult deserialize();
1864 
1865     bool isValid() const { return m_version &lt;= CurrentVersion; }
1866 
1867     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1868     {
1869         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1870             fail();
</pre>
<hr />
<pre>
2076         if (!readStringData(type))
2077             return false;
2078         CachedStringRef name;
2079         if (!readStringData(name))
2080             return false;
2081         Optional&lt;int64_t&gt; optionalLastModified;
2082         if (m_version &gt; 6) {
2083             double lastModified;
2084             if (!read(lastModified))
2085                 return false;
2086             if (lastModified &gt;= 0)
2087                 optionalLastModified = lastModified;
2088         }
2089 
2090         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2091         String filePath = blobFilePathForBlobURL(url-&gt;string());
2092         if (filePath.isEmpty())
2093             filePath = path-&gt;string();
2094 
2095         if (m_isDOMGlobalObject)
<span class="line-modified">2096             file = File::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
2097         return true;
2098     }
2099 
2100     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2101     {
2102         uint32_t length;
2103         if (!read(length))
2104             return false;
2105         if (m_ptr + length &gt; m_end)
2106             return false;
2107         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2108         m_ptr += length;
2109         return true;
2110     }
2111 
2112     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2113     {
2114         ArrayBufferViewSubtag arrayBufferViewSubtag;
2115         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2116             return false;
2117         uint32_t byteOffset;
2118         if (!read(byteOffset))
2119             return false;
2120         uint32_t byteLength;
2121         if (!read(byteLength))
2122             return false;
2123         JSObject* arrayBufferObj = asObject(readTerminal());
2124         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2125             return false;
2126 
2127         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2128         if (!elementSize)
2129             return false;
2130         unsigned length = byteLength / elementSize;
2131         if (length * elementSize != byteLength)
2132             return false;
2133 
2134         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2135         switch (arrayBufferViewSubtag) {
2136         case DataViewTag:
<span class="line-modified">2137             arrayBufferView = toJS(m_exec, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2138             return true;
2139         case Int8ArrayTag:
2140             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2141             return true;
2142         case Uint8ArrayTag:
2143             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2144             return true;
2145         case Uint8ClampedArrayTag:
2146             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2147             return true;
2148         case Int16ArrayTag:
2149             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2150             return true;
2151         case Uint16ArrayTag:
2152             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2153             return true;
2154         case Int32ArrayTag:
2155             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
2156             return true;
2157         case Uint32ArrayTag:
</pre>
<hr />
<pre>
2636             return { };
2637         double height;
2638         if (!read(height))
2639             return { };
2640 
2641         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));
2642     }
2643 
2644     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2645     {
2646         DOMPointInit point;
2647         if (!read(point.x))
2648             return WTF::nullopt;
2649         if (!read(point.y))
2650             return WTF::nullopt;
2651         if (!read(point.z))
2652             return WTF::nullopt;
2653         if (!read(point.w))
2654             return WTF::nullopt;
2655 
<span class="line-modified">2656         return point;</span>
2657     }
2658 
2659     JSValue readDOMQuad()
2660     {
2661         auto p1 = readDOMPointInit();
2662         if (!p1)
2663             return JSValue();
2664         auto p2 = readDOMPointInit();
2665         if (!p2)
2666             return JSValue();
2667         auto p3 = readDOMPointInit();
2668         if (!p3)
2669             return JSValue();
2670         auto p4 = readDOMPointInit();
2671         if (!p4)
2672             return JSValue();
2673 
2674         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
2675     }
2676 
</pre>
<hr />
<pre>
2842             }
2843             if (length)
2844                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2845             else
2846                 result-&gt;data()-&gt;zeroFill();
2847             m_ptr += length;
2848             return getJSValue(result.get());
2849         }
2850         case BlobTag: {
2851             CachedStringRef url;
2852             if (!readStringData(url))
2853                 return JSValue();
2854             CachedStringRef type;
2855             if (!readStringData(type))
2856                 return JSValue();
2857             unsigned long long size = 0;
2858             if (!read(size))
2859                 return JSValue();
2860             if (!m_isDOMGlobalObject)
2861                 return jsNull();
<span class="line-modified">2862             return getJSValue(Blob::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
2863         }
2864         case StringTag: {
2865             CachedStringRef cachedString;
2866             if (!readStringData(cachedString))
2867                 return JSValue();
2868             return cachedString-&gt;jsString(m_exec);
2869         }
2870         case EmptyStringTag:
<span class="line-modified">2871             return jsEmptyString(m_exec-&gt;vm());</span>
2872         case StringObjectTag: {
2873             CachedStringRef cachedString;
2874             if (!readStringData(cachedString))
2875                 return JSValue();
2876             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));
2877             m_gcBuffer.appendWithCrashOnOverflow(obj);
2878             return obj;
2879         }
2880         case EmptyStringObjectTag: {
2881             VM&amp; vm = m_exec-&gt;vm();
<span class="line-modified">2882             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));</span>
2883             m_gcBuffer.appendWithCrashOnOverflow(obj);
2884             return obj;
2885         }
2886         case RegExpTag: {
2887             CachedStringRef pattern;
2888             if (!readStringData(pattern))
2889                 return JSValue();
2890             CachedStringRef flags;
2891             if (!readStringData(flags))
2892                 return JSValue();
<span class="line-modified">2893             auto reFlags = Yarr::parseFlags(flags-&gt;string());</span>
<span class="line-modified">2894             ASSERT(reFlags.hasValue());</span>
2895             VM&amp; vm = m_exec-&gt;vm();
<span class="line-modified">2896             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());</span>
2897             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
2898         }
2899         case ObjectReferenceTag: {
2900             unsigned index = 0;
2901             if (!readConstantPoolIndex(m_gcBuffer, index)) {
2902                 fail();
2903                 return JSValue();
2904             }
2905             return m_gcBuffer.at(index);
2906         }
2907         case MessagePortReferenceTag: {
2908             uint32_t index;
2909             bool indexSuccessfullyRead = read(index);
2910             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
2911                 fail();
2912                 return JSValue();
2913             }
2914             return getJSValue(m_messagePorts[index].get());
2915         }
2916 #if ENABLE(WEBASSEMBLY)
2917         case WasmModuleTag: {
2918             uint32_t index;
2919             bool indexSuccessfullyRead = read(index);
2920             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
2921                 fail();
2922                 return JSValue();
2923             }
2924             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());
<span class="line-modified">2925             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
2926             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
2927             // module to not have been a valid module. Therefore, createStub should
2928             // not trow.
2929             scope.releaseAssertNoException();
2930             m_gcBuffer.appendWithCrashOnOverflow(result);
2931             return result;
2932         }
2933 #endif
2934         case ArrayBufferTag: {
2935             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2936             if (!readArrayBuffer(arrayBuffer)) {
2937                 fail();
2938                 return JSValue();
2939             }
2940             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
2941             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
2942             // array buffers while the sender is. In that case, we would see a null structure here.
2943             if (!structure) {
2944                 fail();
2945                 return JSValue();
</pre>
<hr />
<pre>
3040 
3041     template&lt;SerializationTag Tag&gt;
3042     bool consumeCollectionDataTerminationIfPossible()
3043     {
3044         if (readTag() == Tag)
3045             return true;
3046         m_ptr--;
3047         return false;
3048     }
3049 
3050     JSGlobalObject* m_globalObject;
3051     bool m_isDOMGlobalObject;
3052     const uint8_t* m_ptr;
3053     const uint8_t* m_end;
3054     unsigned m_version;
3055     Vector&lt;CachedString&gt; m_constantPool;
3056     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3057     ArrayBufferContentsArray* m_arrayBufferContents;
3058     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3059     Vector&lt;String&gt; m_blobURLs;

3060     Vector&lt;String&gt; m_blobFilePaths;
3061     ArrayBufferContentsArray* m_sharedBuffers;
3062     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3063     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
3064 #if ENABLE(WEBASSEMBLY)
3065     WasmModuleArray* m_wasmModules;
3066 #endif
3067 
3068     String blobFilePathForBlobURL(const String&amp; blobURL)
3069     {
3070         size_t i = 0;
3071         for (; i &lt; m_blobURLs.size(); ++i) {
3072             if (m_blobURLs[i] == blobURL)
3073                 break;
3074         }
3075 
3076         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3077     }
3078 };
3079 
</pre>
<hr />
<pre>
3147             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());
3148             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3149             outputObjectStack.append(outObject);
3150         }
3151         objectStartVisitMember:
3152         FALLTHROUGH;
3153         case ObjectStartVisitMember: {
3154             CachedStringRef cachedString;
3155             bool wasTerminator = false;
3156             if (!readStringData(cachedString, wasTerminator)) {
3157                 if (!wasTerminator)
3158                     goto error;
3159 
3160                 JSObject* outObject = outputObjectStack.last();
3161                 outValue = outObject;
3162                 outputObjectStack.removeLast();
3163                 break;
3164             }
3165 
3166             if (JSValue terminal = readTerminal()) {
<span class="line-modified">3167                 putProperty(outputObjectStack.last(), Identifier::fromString(vm, cachedString-&gt;string()), terminal);</span>
3168                 goto objectStartVisitMember;
3169             }
3170             stateStack.append(ObjectEndVisitMember);
<span class="line-modified">3171             propertyNameStack.append(Identifier::fromString(vm, cachedString-&gt;string()));</span>
3172             goto stateUnknown;
3173         }
3174         case ObjectEndVisitMember: {
3175             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3176             propertyNameStack.removeLast();
3177             goto objectStartVisitMember;
3178         }
3179         mapObjectStartState: {
3180             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3181                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
3182             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());
3183             if (UNLIKELY(scope.exception()))
3184                 goto error;
3185             m_gcBuffer.appendWithCrashOnOverflow(map);
3186             outputObjectStack.append(map);
3187             mapStack.append(map);
3188             goto mapDataStartVisitEntry;
3189         }
3190         mapDataStartVisitEntry:
3191         case MapDataStartVisitEntry: {
</pre>
<hr />
<pre>
3260     ASSERT(!m_failed);
3261     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3262 error:
3263     fail();
3264     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3265 }
3266 
3267 SerializedScriptValue::~SerializedScriptValue() = default;
3268 
3269 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3270     : m_data(WTFMove(buffer))
3271 {
3272 }
3273 
3274 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3275     : m_data(WTFMove(buffer))
3276     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3277 {
3278 }
3279 
<span class="line-modified">3280 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
3281 #if ENABLE(WEBASSEMBLY)
3282         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3283 #endif
3284         )
3285     : m_data(WTFMove(buffer))
3286     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3287     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3288     , m_imageBuffers(WTFMove(imageBuffers))
3289 #if ENABLE(WEBASSEMBLY)
3290     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3291 #endif

3292 {
3293     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3294     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3295     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3296     for (auto&amp; url : blobURLs)
3297         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3298 }
3299 
3300 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3301 {
3302     if (arrayBuffers.isEmpty())
3303         return nullptr;
3304 
<span class="line-modified">3305     auto contents = makeUnique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());</span>
3306 
3307     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3308     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3309         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3310             continue;
3311         visited.add(arrayBuffers[arrayBufferIndex].get());
3312 
3313         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3314         if (!result)
3315             return Exception { TypeError };
3316     }
3317 
<span class="line-modified">3318     return contents;</span>
3319 }
3320 
3321 static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)
3322 {
3323     auto&amp; vm = state.vm();
3324     auto scope = DECLARE_THROW_SCOPE(vm);
3325 
3326     switch (code) {
3327     case SerializationReturnCode::SuccessfullyCompleted:
3328         break;
3329     case SerializationReturnCode::StackOverflowError:
3330         throwException(&amp;state, scope, createStackOverflowError(&amp;state));
3331         break;
3332     case SerializationReturnCode::ValidationError:
3333         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);
3334         break;
3335     case SerializationReturnCode::DataCloneError:
3336         throwDataCloneError(state, scope);
3337         break;
3338     case SerializationReturnCode::ExistingExceptionError:
</pre>
<hr />
<pre>
3354         return Exception { TypeError };
3355     case SerializationReturnCode::DataCloneError:
3356         return Exception { DataCloneError };
3357     case SerializationReturnCode::ExistingExceptionError:
3358         return Exception { ExistingExceptionError };
3359     case SerializationReturnCode::UnspecifiedError:
3360         return Exception { TypeError };
3361     case SerializationReturnCode::SuccessfullyCompleted:
3362     case SerializationReturnCode::InterruptedExecutionError:
3363         ASSERT_NOT_REACHED();
3364         return Exception { TypeError };
3365     }
3366     ASSERT_NOT_REACHED();
3367     return Exception { TypeError };
3368 }
3369 
3370 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)
3371 {
3372     Vector&lt;uint8_t&gt; buffer;
3373     Vector&lt;String&gt; blobURLs;

3374     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3375     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
3376     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3377 #if ENABLE(WEBASSEMBLY)
3378     WasmModuleArray dummyModules;
3379 #endif
3380     ArrayBufferContentsArray dummySharedBuffers;
3381     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
3382 #if ENABLE(WEBASSEMBLY)
3383         dummyModules,
3384 #endif
<span class="line-modified">3385         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);</span>
3386 
3387 #if ENABLE(WEBASSEMBLY)
3388     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3389 #endif
3390 
3391     if (throwExceptions == SerializationErrorMode::Throwing)
3392         maybeThrowExceptionIfSerializationFailed(exec, code);
3393 
3394     if (code != SerializationReturnCode::SuccessfullyCompleted)
3395         return nullptr;
3396 
<span class="line-modified">3397     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }</span>
3398 #if ENABLE(WEBASSEMBLY)
3399         , nullptr
3400 #endif
3401             ));
3402 }
3403 
3404 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3405 {
3406     HashSet&lt;ImageBitmap*&gt; visited;
3407     for (auto&amp; imageBitmap : imageBitmaps) {
3408         if (!visited.add(imageBitmap.get()))
3409             return true;
3410     }
3411     return false;
3412 }
3413 
3414 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)
3415 {
3416     VM&amp; vm = state.vm();
3417     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
</pre>
<hr />
<pre>
3433             messagePorts.append(WTFMove(port));
3434             continue;
3435         }
3436 
3437         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3438             if (imageBitmap-&gt;isDetached())
3439                 return Exception { DataCloneError };
3440 
3441             imageBitmaps.append(WTFMove(imageBitmap));
3442             continue;
3443         }
3444 
3445         return Exception { DataCloneError };
3446     }
3447 
3448     if (containsDuplicates(imageBitmaps))
3449         return Exception { DataCloneError };
3450 
3451     Vector&lt;uint8_t&gt; buffer;
3452     Vector&lt;String&gt; blobURLs;

3453 #if ENABLE(WEBASSEMBLY)
3454     WasmModuleArray wasmModules;
3455 #endif
<span class="line-modified">3456     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();</span>
3457     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,
3458 #if ENABLE(WEBASSEMBLY)
3459         wasmModules,
3460 #endif
<span class="line-modified">3461         blobURLs, buffer, context, *sharedBuffers);</span>
3462 
3463     if (code != SerializationReturnCode::SuccessfullyCompleted)
3464         return exceptionForSerializationFailure(code);
3465 
3466     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3467     if (arrayBufferContentsArray.hasException())
3468         return arrayBufferContentsArray.releaseException();
3469 
3470     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3471 
<span class="line-modified">3472     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)</span>
3473 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">3474                 , makeUnique&lt;WasmModuleArray&gt;(wasmModules)</span>
3475 #endif
3476                 ));
3477 }
3478 
3479 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3480 {
3481     Vector&lt;uint8_t&gt; buffer;
3482     if (!CloneSerializer::serialize(string, buffer))
3483         return nullptr;
3484     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3485 }
3486 
3487 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3488 {
3489     ExecState* exec = toJS(originContext);
3490     VM&amp; vm = exec-&gt;vm();
3491     JSLockHolder locker(vm);
3492     auto scope = DECLARE_CATCH_SCOPE(vm);
3493 
3494     JSValue value = toJS(exec, apiValue);
</pre>
<hr />
<pre>
3500         return nullptr;
3501     }
3502     ASSERT(serializedValue);
3503     return serializedValue;
3504 }
3505 
3506 String SerializedScriptValue::toString()
3507 {
3508     return CloneDeserializer::deserializeString(m_data);
3509 }
3510 
3511 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
3512 {
3513     return deserialize(exec, globalObject, { }, throwExceptions);
3514 }
3515 
3516 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)
3517 {
3518     Vector&lt;String&gt; dummyBlobs;
3519     Vector&lt;String&gt; dummyPaths;
<span class="line-modified">3520     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);</span>

3521 }
3522 
<span class="line-modified">3523 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
3524 {
<span class="line-modified">3525     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()</span>
3526 #if ENABLE(WEBASSEMBLY)
3527         , m_wasmModulesArray.get()
3528 #endif
3529         );
3530     if (throwExceptions == SerializationErrorMode::Throwing)
3531         maybeThrowExceptionIfSerializationFailed(exec, result.second);
3532     return result.first ? result.first : jsNull();
3533 }
3534 
3535 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3536 {
3537     ExecState* exec = toJS(destinationContext);
3538     VM&amp; vm = exec-&gt;vm();
3539     JSLockHolder locker(vm);
3540     auto scope = DECLARE_CATCH_SCOPE(vm);
3541 
3542     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());
3543     if (UNLIKELY(scope.exception())) {
3544         if (exception)
3545             *exception = toRef(exec, scope.exception()-&gt;value());
</pre>
<hr />
<pre>
3554 {
3555     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3556 }
3557 
3558 uint32_t SerializedScriptValue::wireFormatVersion()
3559 {
3560     return CurrentVersion;
3561 }
3562 
3563 #if ENABLE(INDEXED_DATABASE)
3564 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3565 {
3566     Vector&lt;String&gt; result;
3567     result.reserveInitialCapacity(m_blobURLs.size());
3568     for (auto&amp; url : m_blobURLs)
3569         result.uncheckedAppend(url.isolatedCopy());
3570 
3571     return result;
3572 }
3573 
<span class="line-modified">3574 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(PAL::SessionID sessionID, CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
3575 {
3576     ASSERT(isMainThread());
3577     ASSERT(hasBlobURLs());
3578 
<span class="line-modified">3579     blobRegistry().writeBlobsToTemporaryFiles(sessionID, m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>

3580         ASSERT(isMainThread());
3581 
3582         if (blobFilePaths.isEmpty()) {
3583             // We should have successfully written blobs to temporary files.
3584             // If we failed, then we can&#39;t successfully store this record.
3585             completionHandler({ });
3586             return;
3587         }
3588 
3589         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3590 
<span class="line-modified">3591         completionHandler({ *this, m_blobURLs, blobFilePaths });</span>
3592     });
3593 }
3594 
<span class="line-modified">3595 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously(PAL::SessionID sessionID)</span>
3596 {
3597     ASSERT(!isMainThread());
3598 
3599     IDBValue value;
3600     Lock lock;
3601     Condition condition;
3602     lock.lock();
3603 
<span class="line-modified">3604     RunLoop::main().dispatch([this, sessionID, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">3605         writeBlobsToDiskForIndexedDB(sessionID, [conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
3606             ASSERT(isMainThread());
3607             valuePtr-&gt;setAsIsolatedCopy(result);
3608 
3609             conditionPtr-&gt;notifyAll();
3610         });
3611     });
3612 
3613     condition.wait(lock);
3614 
3615     return value;
3616 }
3617 
3618 #endif // ENABLE(INDEXED_DATABASE)
3619 
3620 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ScriptWrappable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>