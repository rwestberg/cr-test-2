<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DisplayListItems.h&quot;
  28 
  29 #include &quot;FontCascade.h&quot;
  30 #include &lt;wtf/text/TextStream.h&gt;
  31 
  32 namespace WebCore {
  33 namespace DisplayList {
  34 
  35 // Should match RenderTheme::platformFocusRingWidth()
  36 static const float platformFocusRingWidth = 3;
  37 
  38 #if !defined(NDEBUG) || !LOG_DISABLED
  39 WTF::CString Item::description() const
  40 {
  41     TextStream ts;
  42     ts &lt;&lt; *this;
  43     return ts.release().utf8();
  44 }
  45 #endif
  46 
  47 size_t Item::sizeInBytes(const Item&amp; item)
  48 {
  49     switch (item.type()) {
  50     case ItemType::Save:
  51         return sizeof(downcast&lt;Save&gt;(item));
  52     case ItemType::Restore:
  53         return sizeof(downcast&lt;Restore&gt;(item));
  54     case ItemType::Translate:
  55         return sizeof(downcast&lt;Translate&gt;(item));
  56     case ItemType::Rotate:
  57         return sizeof(downcast&lt;Rotate&gt;(item));
  58     case ItemType::Scale:
  59         return sizeof(downcast&lt;Scale&gt;(item));
  60     case ItemType::ConcatenateCTM:
  61         return sizeof(downcast&lt;ConcatenateCTM&gt;(item));
  62     case ItemType::SetState:
  63         return sizeof(downcast&lt;SetState&gt;(item));
  64     case ItemType::SetLineCap:
  65         return sizeof(downcast&lt;SetLineCap&gt;(item));
  66     case ItemType::SetLineDash:
  67         return sizeof(downcast&lt;SetLineDash&gt;(item));
  68     case ItemType::SetLineJoin:
  69         return sizeof(downcast&lt;SetLineJoin&gt;(item));
  70     case ItemType::SetMiterLimit:
  71         return sizeof(downcast&lt;SetMiterLimit&gt;(item));
  72     case ItemType::ClearShadow:
  73         return sizeof(downcast&lt;ClearShadow&gt;(item));
  74     case ItemType::Clip:
  75         return sizeof(downcast&lt;Clip&gt;(item));
  76     case ItemType::ClipOut:
  77         return sizeof(downcast&lt;ClipOut&gt;(item));
  78     case ItemType::ClipOutToPath:
  79         return sizeof(downcast&lt;ClipOutToPath&gt;(item));
  80     case ItemType::ClipPath:
  81         return sizeof(downcast&lt;ClipPath&gt;(item));
  82     case ItemType::DrawGlyphs:
  83         return sizeof(downcast&lt;DrawGlyphs&gt;(item));
  84     case ItemType::DrawImage:
  85         return sizeof(downcast&lt;DrawImage&gt;(item));
  86     case ItemType::DrawTiledImage:
  87         return sizeof(downcast&lt;DrawTiledImage&gt;(item));
  88     case ItemType::DrawTiledScaledImage:
  89         return sizeof(downcast&lt;DrawTiledScaledImage&gt;(item));
  90 #if USE(CG) || USE(CAIRO)
  91     case ItemType::DrawNativeImage:
  92         return sizeof(downcast&lt;DrawNativeImage&gt;(item));
  93 #endif
  94     case ItemType::DrawPattern:
  95         return sizeof(downcast&lt;DrawPattern&gt;(item));
  96     case ItemType::DrawRect:
  97         return sizeof(downcast&lt;DrawRect&gt;(item));
  98     case ItemType::DrawLine:
  99         return sizeof(downcast&lt;DrawLine&gt;(item));
 100     case ItemType::DrawLinesForText:
 101         return sizeof(downcast&lt;DrawLinesForText&gt;(item));
 102     case ItemType::DrawDotsForDocumentMarker:
 103         return sizeof(downcast&lt;DrawDotsForDocumentMarker&gt;(item));
 104     case ItemType::DrawEllipse:
 105         return sizeof(downcast&lt;DrawEllipse&gt;(item));
 106     case ItemType::DrawPath:
 107         return sizeof(downcast&lt;DrawPath&gt;(item));
 108     case ItemType::DrawFocusRingPath:
 109         return sizeof(downcast&lt;DrawFocusRingPath&gt;(item));
 110     case ItemType::DrawFocusRingRects:
 111         return sizeof(downcast&lt;DrawFocusRingRects&gt;(item));
 112     case ItemType::FillRect:
 113         return sizeof(downcast&lt;FillRect&gt;(item));
 114     case ItemType::FillRectWithColor:
 115         return sizeof(downcast&lt;FillRectWithColor&gt;(item));
 116     case ItemType::FillRectWithGradient:
 117         return sizeof(downcast&lt;FillRectWithGradient&gt;(item));
 118     case ItemType::FillCompositedRect:
 119         return sizeof(downcast&lt;FillCompositedRect&gt;(item));
 120     case ItemType::FillRoundedRect:
 121         return sizeof(downcast&lt;FillRoundedRect&gt;(item));
 122     case ItemType::FillRectWithRoundedHole:
 123         return sizeof(downcast&lt;FillRectWithRoundedHole&gt;(item));
 124     case ItemType::FillPath:
 125         return sizeof(downcast&lt;FillPath&gt;(item));
 126     case ItemType::FillEllipse:
 127         return sizeof(downcast&lt;FillEllipse&gt;(item));
 128     case ItemType::StrokeRect:
 129         return sizeof(downcast&lt;StrokeRect&gt;(item));
 130     case ItemType::StrokePath:
 131         return sizeof(downcast&lt;StrokePath&gt;(item));
 132     case ItemType::StrokeEllipse:
 133         return sizeof(downcast&lt;StrokeEllipse&gt;(item));
 134     case ItemType::ClearRect:
 135         return sizeof(downcast&lt;ClearRect&gt;(item));
 136     case ItemType::BeginTransparencyLayer:
 137         return sizeof(downcast&lt;BeginTransparencyLayer&gt;(item));
 138     case ItemType::EndTransparencyLayer:
 139         return sizeof(downcast&lt;EndTransparencyLayer&gt;(item));
 140 #if USE(CG)
 141     case ItemType::ApplyStrokePattern:
 142         return sizeof(downcast&lt;ApplyStrokePattern&gt;(item));
 143     case ItemType::ApplyFillPattern:
 144         return sizeof(downcast&lt;ApplyFillPattern&gt;(item));
 145 #endif
 146     case ItemType::ApplyDeviceScaleFactor:
 147         return sizeof(downcast&lt;ApplyDeviceScaleFactor&gt;(item));
 148     }
 149     return 0;
 150 }
 151 
 152 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawingItem&amp; item)
 153 {
 154     ts.startGroup();
 155     ts &lt;&lt; &quot;extent &quot;;
 156     if (item.extentKnown())
 157         ts &lt;&lt; item.extent();
 158     else
 159         ts &lt;&lt; &quot;unknown&quot;;
 160 
 161     ts.endGroup();
 162     return ts;
 163 }
 164 
 165 void Save::apply(GraphicsContext&amp; context) const
 166 {
 167     context.save();
 168 }
 169 
 170 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Save&amp; item)
 171 {
 172     ts.dumpProperty(&quot;restore-index&quot;, item.restoreIndex());
 173     return ts;
 174 }
 175 
 176 void Restore::apply(GraphicsContext&amp; context) const
 177 {
 178     context.restore();
 179 }
 180 
 181 void Translate::apply(GraphicsContext&amp; context) const
 182 {
 183     context.translate(m_x, m_y);
 184 }
 185 
 186 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Translate&amp; item)
 187 {
 188     ts.dumpProperty(&quot;x&quot;, item.x());
 189     ts.dumpProperty(&quot;y&quot;, item.y());
 190 
 191     return ts;
 192 }
 193 
 194 void Rotate::apply(GraphicsContext&amp; context) const
 195 {
 196     context.rotate(m_angle);
 197 }
 198 
 199 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Rotate&amp; item)
 200 {
 201     ts.dumpProperty(&quot;angle&quot;, item.angle());
 202 
 203     return ts;
 204 }
 205 
 206 void Scale::apply(GraphicsContext&amp; context) const
 207 {
 208     context.scale(m_size);
 209 }
 210 
 211 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Scale&amp; item)
 212 {
 213     ts.dumpProperty(&quot;size&quot;, item.amount());
 214 
 215     return ts;
 216 }
 217 
 218 ConcatenateCTM::ConcatenateCTM(const AffineTransform&amp; transform)
 219     : Item(ItemType::ConcatenateCTM)
 220     , m_transform(transform)
 221 {
 222 }
 223 
 224 void ConcatenateCTM::apply(GraphicsContext&amp; context) const
 225 {
 226     context.concatCTM(m_transform);
 227 }
 228 
 229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ConcatenateCTM&amp; item)
 230 {
 231     ts.dumpProperty(&quot;ctm&quot;, item.transform());
 232 
 233     return ts;
 234 }
 235 
 236 void SetState::apply(GraphicsContext&amp; context) const
 237 {
 238     m_state.apply(context);
 239 }
 240 
 241 void SetState::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 242 {
 243     m_state.accumulate(state, flags);
 244 }
 245 
 246 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetState&amp; state)
 247 {
 248     ts &lt;&lt; state.state();
 249     return ts;
 250 }
 251 
 252 void SetLineCap::apply(GraphicsContext&amp; context) const
 253 {
 254     context.setLineCap(m_lineCap);
 255 }
 256 
 257 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineCap&amp; lineCap)
 258 {
 259     ts.dumpProperty(&quot;line-cap&quot;, lineCap.lineCap());
 260     return ts;
 261 }
 262 
 263 void SetLineDash::apply(GraphicsContext&amp; context) const
 264 {
 265     context.setLineDash(m_dashArray, m_dashOffset);
 266 }
 267 
 268 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineDash&amp; lineDash)
 269 {
 270     ts.dumpProperty(&quot;dash-array&quot;, lineDash.dashArray());
 271     ts.dumpProperty(&quot;dash-offset&quot;, lineDash.dashOffset());
 272     return ts;
 273 }
 274 
 275 void SetLineJoin::apply(GraphicsContext&amp; context) const
 276 {
 277     context.setLineJoin(m_lineJoin);
 278 }
 279 
 280 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineJoin&amp; lineJoin)
 281 {
 282     ts.dumpProperty(&quot;line-join&quot;, lineJoin.lineJoin());
 283     return ts;
 284 }
 285 
 286 void SetMiterLimit::apply(GraphicsContext&amp; context) const
 287 {
 288     context.setMiterLimit(m_miterLimit);
 289 }
 290 
 291 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetMiterLimit&amp; miterLimit)
 292 {
 293     ts.dumpProperty(&quot;mitre-limit&quot;, miterLimit.miterLimit());
 294     return ts;
 295 }
 296 
 297 void ClearShadow::apply(GraphicsContext&amp; context) const
 298 {
 299     context.clearShadow();
 300 }
 301 
 302 void Clip::apply(GraphicsContext&amp; context) const
 303 {
 304     context.clip(m_rect);
 305 }
 306 
 307 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Clip&amp; item)
 308 {
 309     ts.dumpProperty(&quot;rect&quot;, item.rect());
 310     return ts;
 311 }
 312 
 313 void ClipOut::apply(GraphicsContext&amp; context) const
 314 {
 315     context.clipOut(m_rect);
 316 }
 317 
 318 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOut&amp; item)
 319 {
 320     ts.dumpProperty(&quot;rect&quot;, item.rect());
 321     return ts;
 322 }
 323 
 324 void ClipOutToPath::apply(GraphicsContext&amp; context) const
 325 {
 326     context.clipOut(m_path);
 327 }
 328 
 329 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOutToPath&amp; item)
 330 {
 331     ts.dumpProperty(&quot;path&quot;, item.path());
 332     return ts;
 333 }
 334 
 335 void ClipPath::apply(GraphicsContext&amp; context) const
 336 {
 337     context.clipPath(m_path, m_windRule);
 338 }
 339 
 340 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipPath&amp; item)
 341 {
 342     ts.dumpProperty(&quot;path&quot;, item.path());
 343     ts.dumpProperty(&quot;wind-rule&quot;, item.windRule());
 344     return ts;
 345 }
 346 
 347 DrawGlyphs::DrawGlyphs(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 348     : DrawingItem(ItemType::DrawGlyphs)
 349     , m_font(const_cast&lt;Font&amp;&gt;(font))
 350     , m_blockLocation(blockLocation)
 351     , m_localAnchor(localAnchor)
 352     , m_smoothingMode(smoothingMode)
 353 {
 354     m_glyphs.reserveInitialCapacity(count);
 355     m_advances.reserveInitialCapacity(count);
 356     for (unsigned i = 0; i &lt; count; ++i) {
 357         m_glyphs.uncheckedAppend(glyphs[i]);
 358         m_advances.uncheckedAppend(advances[i]);
 359     }
 360     computeBounds();
 361 }
 362 
 363 inline GlyphBuffer DrawGlyphs::generateGlyphBuffer() const
 364 {
 365     GlyphBuffer result;
 366     for (size_t i = 0; i &lt; m_glyphs.size(); ++i) {
 367         result.add(m_glyphs[i], &amp;m_font.get(), m_advances[i]);
 368     }
 369     return result;
 370 }
 371 
 372 void DrawGlyphs::apply(GraphicsContext&amp; context) const
 373 {
 374     context.drawGlyphs(m_font, generateGlyphBuffer(), 0, m_glyphs.size(), anchorPoint(), m_smoothingMode);
 375 }
 376 
 377 void DrawGlyphs::computeBounds()
 378 {
 379     // FIXME: This code doesn&#39;t actually take the extents of the glyphs into consideration. It assumes that
 380     // the glyph lies entirely within its [(ascent + descent), advance] rect.
 381     float ascent = m_font-&gt;fontMetrics().floatAscent();
 382     float descent = m_font-&gt;fontMetrics().floatDescent();
 383     FloatPoint current = toFloatPoint(localAnchor());
 384     size_t numGlyphs = m_glyphs.size();
 385     for (size_t i = 0; i &lt; numGlyphs; ++i) {
 386         GlyphBufferAdvance advance = m_advances[i];
 387         FloatRect glyphRect = FloatRect(current.x(), current.y() - ascent, advance.width(), ascent + descent);
 388         m_bounds.unite(glyphRect);
 389 
 390         current.move(advance.width(), advance.height());
 391     }
 392 }
 393 
 394 Optional&lt;FloatRect&gt; DrawGlyphs::localBounds(const GraphicsContext&amp;) const
 395 {
 396     FloatRect localBounds = m_bounds;
 397     localBounds.move(m_blockLocation.x(), m_blockLocation.y());
 398     return localBounds;
 399 }
 400 
 401 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawGlyphs&amp; item)
 402 {
 403     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 404     // FIXME: dump more stuff.
 405     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 406     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 407     ts.dumpProperty(&quot;anchor-point&quot;, item.anchorPoint());
 408     ts.dumpProperty(&quot;length&quot;, item.glyphs().size());
 409 
 410     return ts;
 411 }
 412 
 413 DrawImage::DrawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 414     : DrawingItem(ItemType::DrawImage)
 415     , m_image(image)
 416     , m_destination(destination)
 417     , m_source(source)
 418     , m_imagePaintingOptions(imagePaintingOptions)
 419 {
 420 }
 421 
 422 void DrawImage::apply(GraphicsContext&amp; context) const
 423 {
 424     context.drawImage(m_image.get(), m_destination, m_source, m_imagePaintingOptions);
 425 }
 426 
 427 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawImage&amp; item)
 428 {
 429     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 430     ts.dumpProperty(&quot;image&quot;, item.image());
 431     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 432     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 433     return ts;
 434 }
 435 
 436 DrawTiledImage::DrawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 437     : DrawingItem(ItemType::DrawTiledImage)
 438     , m_image(image)
 439     , m_destination(destination)
 440     , m_source(source)
 441     , m_tileSize(tileSize)
 442     , m_spacing(spacing)
 443     , m_imagePaintingOptions(imagePaintingOptions)
 444 {
 445 }
 446 
 447 void DrawTiledImage::apply(GraphicsContext&amp; context) const
 448 {
 449     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileSize, m_spacing, m_imagePaintingOptions);
 450 }
 451 
 452 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledImage&amp; item)
 453 {
 454     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 455     ts.dumpProperty(&quot;image&quot;, item.image());
 456     ts.dumpProperty(&quot;source-point&quot;, item.source());
 457     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 458     ts.dumpProperty(&quot;tile-size&quot;, item.tileSize());
 459     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 460     return ts;
 461 }
 462 
 463 DrawTiledScaledImage::DrawTiledScaledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 464     : DrawingItem(ItemType::DrawTiledScaledImage)
 465     , m_image(image)
 466     , m_destination(destination)
 467     , m_source(source)
 468     , m_tileScaleFactor(tileScaleFactor)
 469     , m_hRule(hRule)
 470     , m_vRule(vRule)
 471     , m_imagePaintingOptions(imagePaintingOptions)
 472 {
 473 }
 474 
 475 void DrawTiledScaledImage::apply(GraphicsContext&amp; context) const
 476 {
 477     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileScaleFactor, m_hRule, m_vRule, m_imagePaintingOptions);
 478 }
 479 
 480 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledScaledImage&amp; item)
 481 {
 482     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 483     ts.dumpProperty(&quot;image&quot;, item.image());
 484     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 485     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 486     return ts;
 487 }
 488 
 489 #if USE(CG) || USE(CAIRO)
 490 DrawNativeImage::DrawNativeImage(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, CompositeOperator op, BlendMode blendMode, ImageOrientation orientation)
 491     : DrawingItem(ItemType::DrawNativeImage)
 492 #if USE(CG)
 493     // FIXME: Need to store an image for Cairo.
 494     , m_image(image)
 495 #endif
 496     , m_imageSize(imageSize)
 497     , m_destination(destRect)
 498     , m_srcRect(srcRect)
 499 #if USE(CG)
 500     , m_op(op)
 501     , m_blendMode(blendMode)
 502 #endif
 503     , m_orientation(orientation)
 504 {
 505 #if !USE(CG)
 506     UNUSED_PARAM(image);
 507     UNUSED_PARAM(op);
 508     UNUSED_PARAM(blendMode);
 509 #endif
 510 }
 511 
 512 void DrawNativeImage::apply(GraphicsContext&amp; context) const
 513 {
 514 #if USE(CG)
 515     context.drawNativeImage(m_image, m_imageSize, m_destination, m_srcRect, m_op, m_blendMode, m_orientation);
 516 #else
 517     UNUSED_PARAM(context);
 518 #endif
 519 }
 520 
 521 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawNativeImage&amp; item)
 522 {
 523     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 524     // FIXME: dump more stuff.
 525     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 526     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 527     return ts;
 528 }
 529 #endif
 530 
 531 DrawPattern::DrawPattern(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, CompositeOperator op, BlendMode blendMode)
 532     : DrawingItem(ItemType::DrawPattern)
 533     , m_image(image)
 534     , m_patternTransform(patternTransform)
 535     , m_tileRect(tileRect)
 536     , m_destination(destRect)
 537     , m_phase(phase)
 538     , m_spacing(spacing)
 539     , m_op(op)
 540     , m_blendMode(blendMode)
 541 {
 542 }
 543 
 544 void DrawPattern::apply(GraphicsContext&amp; context) const
 545 {
 546     context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_op, m_blendMode);
 547 }
 548 
 549 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPattern&amp; item)
 550 {
 551     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 552     ts.dumpProperty(&quot;image&quot;, item.image());
 553     ts.dumpProperty(&quot;pattern-transform&quot;, item.patternTransform());
 554     ts.dumpProperty(&quot;tile-rect&quot;, item.tileRect());
 555     ts.dumpProperty(&quot;dest-rect&quot;, item.destRect());
 556     ts.dumpProperty(&quot;phase&quot;, item.phase());
 557     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 558     return ts;
 559 }
 560 
 561 void DrawRect::apply(GraphicsContext&amp; context) const
 562 {
 563     context.drawRect(m_rect, m_borderThickness);
 564 }
 565 
 566 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawRect&amp; item)
 567 {
 568     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 569     ts.dumpProperty(&quot;rect&quot;, item.rect());
 570     ts.dumpProperty(&quot;border-thickness&quot;, item.borderThickness());
 571     return ts;
 572 }
 573 
 574 Optional&lt;FloatRect&gt; DrawLine::localBounds(const GraphicsContext&amp;) const
 575 {
 576     FloatRect bounds;
 577     bounds.fitToPoints(m_point1, m_point2);
 578     return bounds;
 579 }
 580 
 581 void DrawLine::apply(GraphicsContext&amp; context) const
 582 {
 583     context.drawLine(m_point1, m_point2);
 584 }
 585 
 586 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLine&amp; item)
 587 {
 588     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 589     ts.dumpProperty(&quot;point-1&quot;, item.point1());
 590     ts.dumpProperty(&quot;point-2&quot;, item.point2());
 591     return ts;
 592 }
 593 
 594 void DrawLinesForText::apply(GraphicsContext&amp; context) const
 595 {
 596     context.drawLinesForText(point(), m_thickness, m_widths, m_printing, m_doubleLines);
 597 }
 598 
 599 Optional&lt;FloatRect&gt; DrawLinesForText::localBounds(const GraphicsContext&amp;) const
 600 {
 601     // This function needs to return a value equal to or enclosing what GraphicsContext::computeLineBoundsAndAntialiasingModeForText() returns.
 602 
 603     if (!m_widths.size())
 604         return FloatRect();
 605 
 606     FloatRect result(point(), FloatSize(m_widths.last(), m_thickness));
 607     result.inflate(1); // Account for pixel snapping. FIXME: This isn&#39;t perfect, as it doesn&#39;t take the CTM into account.
 608     return result;
 609 }
 610 
 611 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLinesForText&amp; item)
 612 {
 613     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 614     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 615     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 616     ts.dumpProperty(&quot;point&quot;, item.point());
 617     ts.dumpProperty(&quot;thickness&quot;, item.thickness());
 618     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 619     ts.dumpProperty(&quot;widths&quot;, item.widths());
 620     ts.dumpProperty(&quot;is-printing&quot;, item.isPrinting());
 621     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 622     return ts;
 623 }
 624 
 625 void DrawDotsForDocumentMarker::apply(GraphicsContext&amp; context) const
 626 {
 627     context.drawDotsForDocumentMarker(m_rect, m_style);
 628 }
 629 
 630 Optional&lt;FloatRect&gt; DrawDotsForDocumentMarker::localBounds(const GraphicsContext&amp;) const
 631 {
 632     return m_rect;
 633 }
 634 
 635 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawDotsForDocumentMarker&amp; item)
 636 {
 637     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 638     ts.dumpProperty(&quot;rect&quot;, item.rect());
 639     return ts;
 640 }
 641 
 642 void DrawEllipse::apply(GraphicsContext&amp; context) const
 643 {
 644     context.drawEllipse(m_rect);
 645 }
 646 
 647 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawEllipse&amp; item)
 648 {
 649     ts.dumpProperty(&quot;rect&quot;, item.rect());
 650     return ts;
 651 }
 652 
 653 void DrawPath::apply(GraphicsContext&amp; context) const
 654 {
 655 #if USE(CG)
 656     context.drawPath(m_path);
 657 #else
 658     UNUSED_PARAM(context);
 659 #endif
 660 }
 661 
 662 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPath&amp; item)
 663 {
 664     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 665 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 666     return ts;
 667 }
 668 
 669 void DrawFocusRingPath::apply(GraphicsContext&amp; context) const
 670 {
 671     context.drawFocusRing(m_path, m_width, m_offset, m_color);
 672 }
 673 
 674 Optional&lt;FloatRect&gt; DrawFocusRingPath::localBounds(const GraphicsContext&amp;) const
 675 {
 676     FloatRect result = m_path.fastBoundingRect();
 677     result.inflate(platformFocusRingWidth);
 678     return result;
 679 }
 680 
 681 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingPath&amp; item)
 682 {
 683     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 684 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 685     ts.dumpProperty(&quot;width&quot;, item.width());
 686     ts.dumpProperty(&quot;offset&quot;, item.offset());
 687     ts.dumpProperty(&quot;color&quot;, item.color());
 688     return ts;
 689 }
 690 
 691 void DrawFocusRingRects::apply(GraphicsContext&amp; context) const
 692 {
 693     context.drawFocusRing(m_rects, m_width, m_offset, m_color);
 694 }
 695 
 696 Optional&lt;FloatRect&gt; DrawFocusRingRects::localBounds(const GraphicsContext&amp;) const
 697 {
 698     FloatRect result;
 699     for (auto&amp; rect : m_rects)
 700         result.unite(rect);
 701     result.inflate(platformFocusRingWidth);
 702     return result;
 703 }
 704 
 705 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingRects&amp; item)
 706 {
 707     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 708     ts.dumpProperty(&quot;rects&quot;, item.rects());
 709     ts.dumpProperty(&quot;width&quot;, item.width());
 710     ts.dumpProperty(&quot;offset&quot;, item.offset());
 711     ts.dumpProperty(&quot;color&quot;, item.color());
 712     return ts;
 713 }
 714 
 715 void FillRect::apply(GraphicsContext&amp; context) const
 716 {
 717     context.fillRect(m_rect);
 718 }
 719 
 720 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRect&amp; item)
 721 {
 722     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 723     ts.dumpProperty(&quot;rect&quot;, item.rect());
 724     return ts;
 725 }
 726 
 727 void FillRectWithColor::apply(GraphicsContext&amp; context) const
 728 {
 729     context.fillRect(m_rect, m_color);
 730 }
 731 
 732 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithColor&amp; item)
 733 {
 734     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 735     ts.dumpProperty(&quot;rect&quot;, item.rect());
 736     ts.dumpProperty(&quot;color&quot;, item.color());
 737     return ts;
 738 }
 739 
 740 void FillRectWithGradient::apply(GraphicsContext&amp; context) const
 741 {
 742     context.fillRect(m_rect, m_gradient.get());
 743 }
 744 
 745 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithGradient&amp; item)
 746 {
 747     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 748     // FIXME: log gradient.
 749     ts.dumpProperty(&quot;rect&quot;, item.rect());
 750     return ts;
 751 }
 752 
 753 void FillCompositedRect::apply(GraphicsContext&amp; context) const
 754 {
 755     context.fillRect(m_rect, m_color, m_op, m_blendMode);
 756 }
 757 
 758 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillCompositedRect&amp; item)
 759 {
 760     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 761     ts.dumpProperty(&quot;rect&quot;, item.rect());
 762     ts.dumpProperty(&quot;color&quot;, item.color());
 763     ts.dumpProperty(&quot;composite-operation&quot;, item.compositeOperator());
 764     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 765     return ts;
 766 }
 767 
 768 void FillRoundedRect::apply(GraphicsContext&amp; context) const
 769 {
 770     context.fillRoundedRect(m_rect, m_color, m_blendMode);
 771 }
 772 
 773 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRoundedRect&amp; item)
 774 {
 775     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 776     ts.dumpProperty(&quot;rect&quot;, item.roundedRect());
 777     ts.dumpProperty(&quot;color&quot;, item.color());
 778     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 779     return ts;
 780 }
 781 
 782 void FillRectWithRoundedHole::apply(GraphicsContext&amp; context) const
 783 {
 784     context.fillRectWithRoundedHole(m_rect, m_roundedHoleRect, m_color);
 785 }
 786 
 787 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithRoundedHole&amp; item)
 788 {
 789     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 790     ts.dumpProperty(&quot;rect&quot;, item.rect());
 791     ts.dumpProperty(&quot;rounded-hole-rect&quot;, item.roundedHoleRect());
 792     ts.dumpProperty(&quot;color&quot;, item.color());
 793     return ts;
 794 }
 795 
 796 void FillPath::apply(GraphicsContext&amp; context) const
 797 {
 798     context.fillPath(m_path);
 799 }
 800 
 801 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillPath&amp; item)
 802 {
 803     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 804     ts.dumpProperty(&quot;path&quot;, item.path());
 805     return ts;
 806 }
 807 
 808 void FillEllipse::apply(GraphicsContext&amp; context) const
 809 {
 810     context.fillEllipse(m_rect);
 811 }
 812 
 813 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillEllipse&amp; item)
 814 {
 815     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 816     ts.dumpProperty(&quot;rect&quot;, item.rect());
 817     return ts;
 818 }
 819 
 820 Optional&lt;FloatRect&gt; StrokeRect::localBounds(const GraphicsContext&amp;) const
 821 {
 822     FloatRect bounds = m_rect;
 823     bounds.expand(m_lineWidth, m_lineWidth);
 824     return bounds;
 825 }
 826 
 827 void StrokeRect::apply(GraphicsContext&amp; context) const
 828 {
 829     context.strokeRect(m_rect, m_lineWidth);
 830 }
 831 
 832 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeRect&amp; item)
 833 {
 834     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 835     ts.dumpProperty(&quot;rect&quot;, item.rect());
 836     ts.dumpProperty(&quot;line-width&quot;, item.lineWidth());
 837     return ts;
 838 }
 839 
 840 Optional&lt;FloatRect&gt; StrokePath::localBounds(const GraphicsContext&amp; context) const
 841 {
 842     // FIXME: Need to take stroke thickness into account correctly, via CGPathByStrokingPath().
 843     float strokeThickness = context.strokeThickness();
 844 
 845     FloatRect bounds = m_path.boundingRect();
 846     bounds.expand(strokeThickness, strokeThickness);
 847     return bounds;
 848 }
 849 
 850 void StrokePath::apply(GraphicsContext&amp; context) const
 851 {
 852     context.strokePath(m_path);
 853 }
 854 
 855 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokePath&amp; item)
 856 {
 857     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 858     ts.dumpProperty(&quot;path&quot;, item.path());
 859     return ts;
 860 }
 861 
 862 Optional&lt;FloatRect&gt; StrokeEllipse::localBounds(const GraphicsContext&amp; context) const
 863 {
 864     float strokeThickness = context.strokeThickness();
 865 
 866     FloatRect bounds = m_rect;
 867     bounds.expand(strokeThickness, strokeThickness);
 868     return bounds;
 869 }
 870 
 871 void StrokeEllipse::apply(GraphicsContext&amp; context) const
 872 {
 873     context.strokeEllipse(m_rect);
 874 }
 875 
 876 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeEllipse&amp; item)
 877 {
 878     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 879     ts.dumpProperty(&quot;rect&quot;, item.rect());
 880     return ts;
 881 }
 882 
 883 void ClearRect::apply(GraphicsContext&amp; context) const
 884 {
 885     context.clearRect(m_rect);
 886 }
 887 
 888 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClearRect&amp; item)
 889 {
 890     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 891     ts.dumpProperty(&quot;rect&quot;, item.rect());
 892     return ts;
 893 }
 894 
 895 void BeginTransparencyLayer::apply(GraphicsContext&amp; context) const
 896 {
 897     context.beginTransparencyLayer(m_opacity);
 898 }
 899 
 900 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BeginTransparencyLayer&amp; item)
 901 {
 902     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 903     ts.dumpProperty(&quot;opacity&quot;, item.opacity());
 904     return ts;
 905 }
 906 
 907 void EndTransparencyLayer::apply(GraphicsContext&amp; context) const
 908 {
 909     context.endTransparencyLayer();
 910 }
 911 
 912 #if USE(CG)
 913 void ApplyStrokePattern::apply(GraphicsContext&amp; context) const
 914 {
 915     context.applyStrokePattern();
 916 }
 917 
 918 void ApplyFillPattern::apply(GraphicsContext&amp; context) const
 919 {
 920     context.applyFillPattern();
 921 }
 922 #endif
 923 
 924 void ApplyDeviceScaleFactor::apply(GraphicsContext&amp; context) const
 925 {
 926     context.applyDeviceScaleFactor(m_scaleFactor);
 927 }
 928 
 929 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ApplyDeviceScaleFactor&amp; item)
 930 {
 931     ts.dumpProperty(&quot;scale-factor&quot;, item.scaleFactor());
 932     return ts;
 933 }
 934 
 935 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ItemType&amp; type)
 936 {
 937     switch (type) {
 938     case ItemType::Save: ts &lt;&lt; &quot;save&quot;; break;
 939     case ItemType::Restore: ts &lt;&lt; &quot;restore&quot;; break;
 940     case ItemType::Translate: ts &lt;&lt; &quot;translate&quot;; break;
 941     case ItemType::Rotate: ts &lt;&lt; &quot;rotate&quot;; break;
 942     case ItemType::Scale: ts &lt;&lt; &quot;scale&quot;; break;
 943     case ItemType::ConcatenateCTM: ts &lt;&lt; &quot;concatentate-ctm&quot;; break;
 944     case ItemType::SetState: ts &lt;&lt; &quot;set-state&quot;; break;
 945     case ItemType::SetLineCap: ts &lt;&lt; &quot;set-line-cap&quot;; break;
 946     case ItemType::SetLineDash: ts &lt;&lt; &quot;set-line-dash&quot;; break;
 947     case ItemType::SetLineJoin: ts &lt;&lt; &quot;set-line-join&quot;; break;
 948     case ItemType::SetMiterLimit: ts &lt;&lt; &quot;set-miter-limit&quot;; break;
 949     case ItemType::Clip: ts &lt;&lt; &quot;clip&quot;; break;
 950     case ItemType::ClipOut: ts &lt;&lt; &quot;clip-out&quot;; break;
 951     case ItemType::ClipOutToPath: ts &lt;&lt; &quot;clip-out-to-path&quot;; break;
 952     case ItemType::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
 953     case ItemType::DrawGlyphs: ts &lt;&lt; &quot;draw-glyphs&quot;; break;
 954     case ItemType::DrawImage: ts &lt;&lt; &quot;draw-image&quot;; break;
 955     case ItemType::DrawTiledImage: ts &lt;&lt; &quot;draw-tiled-image&quot;; break;
 956     case ItemType::DrawTiledScaledImage: ts &lt;&lt; &quot;draw-tiled-scaled-image&quot;; break;
 957 #if USE(CG) || USE(CAIRO)
 958     case ItemType::DrawNativeImage: ts &lt;&lt; &quot;draw-native-image&quot;; break;
 959 #endif
 960     case ItemType::DrawPattern: ts &lt;&lt; &quot;draw-pattern&quot;; break;
 961     case ItemType::DrawRect: ts &lt;&lt; &quot;draw-rect&quot;; break;
 962     case ItemType::DrawLine: ts &lt;&lt; &quot;draw-line&quot;; break;
 963     case ItemType::DrawLinesForText: ts &lt;&lt; &quot;draw-lines-for-text&quot;; break;
 964     case ItemType::DrawDotsForDocumentMarker: ts &lt;&lt; &quot;draw-dots-for-document-marker&quot;; break;
 965     case ItemType::DrawEllipse: ts &lt;&lt; &quot;draw-ellipse&quot;; break;
 966     case ItemType::DrawPath: ts &lt;&lt; &quot;draw-path&quot;; break;
 967     case ItemType::DrawFocusRingPath: ts &lt;&lt; &quot;draw-focus-ring-path&quot;; break;
 968     case ItemType::DrawFocusRingRects: ts &lt;&lt; &quot;draw-focus-ring-rects&quot;; break;
 969     case ItemType::FillRect: ts &lt;&lt; &quot;fill-rect&quot;; break;
 970     case ItemType::FillRectWithColor: ts &lt;&lt; &quot;fill-rect-with-color&quot;; break;
 971     case ItemType::FillRectWithGradient: ts &lt;&lt; &quot;fill-rect-with-gradient&quot;; break;
 972     case ItemType::FillCompositedRect: ts &lt;&lt; &quot;fill-composited-rect&quot;; break;
 973     case ItemType::FillRoundedRect: ts &lt;&lt; &quot;fill-rounded-rect&quot;; break;
 974     case ItemType::FillRectWithRoundedHole: ts &lt;&lt; &quot;fill-rect-with-rounded-hole&quot;; break;
 975     case ItemType::FillPath: ts &lt;&lt; &quot;fill-path&quot;; break;
 976     case ItemType::FillEllipse: ts &lt;&lt; &quot;fill-ellipse&quot;; break;
 977     case ItemType::StrokeRect: ts &lt;&lt; &quot;stroke-rect&quot;; break;
 978     case ItemType::StrokePath: ts &lt;&lt; &quot;stroke-path&quot;; break;
 979     case ItemType::StrokeEllipse: ts &lt;&lt; &quot;stroke-ellipse&quot;; break;
 980     case ItemType::ClearRect: ts &lt;&lt; &quot;clear-rect&quot;; break;
 981     case ItemType::BeginTransparencyLayer: ts &lt;&lt; &quot;begin-transparency-layer&quot;; break;
 982     case ItemType::EndTransparencyLayer: ts &lt;&lt; &quot;end-transparency-layer&quot;; break;
 983 #if USE(CG)
 984     case ItemType::ApplyStrokePattern: ts &lt;&lt; &quot;apply-stroke-pattern&quot;; break;
 985     case ItemType::ApplyFillPattern: ts &lt;&lt; &quot;apply-fill-pattern&quot;; break;
 986 #endif
 987     case ItemType::ApplyDeviceScaleFactor: ts &lt;&lt; &quot;apply-device-scale-factor&quot;; break;
 988     case ItemType::ClearShadow: ts &lt;&lt; &quot;clear-shadow&quot;; break;
 989     }
 990     return ts;
 991 }
 992 
 993 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Item&amp; item)
 994 {
 995     TextStream::GroupScope group(ts);
 996     ts &lt;&lt; item.type();
 997 
 998     // FIXME: Make a macro which takes a macro for all these enumeration switches
 999     switch (item.type()) {
1000     case ItemType::Save:
1001         ts &lt;&lt; downcast&lt;Save&gt;(item);
1002         break;
1003     case ItemType::Translate:
1004         ts &lt;&lt; downcast&lt;Translate&gt;(item);
1005         break;
1006     case ItemType::Rotate:
1007         ts &lt;&lt; downcast&lt;Rotate&gt;(item);
1008         break;
1009     case ItemType::Scale:
1010         ts &lt;&lt; downcast&lt;Scale&gt;(item);
1011         break;
1012     case ItemType::ConcatenateCTM:
1013         ts &lt;&lt; downcast&lt;ConcatenateCTM&gt;(item);
1014         break;
1015     case ItemType::SetState:
1016         ts &lt;&lt; downcast&lt;SetState&gt;(item);
1017         break;
1018     case ItemType::SetLineCap:
1019         ts &lt;&lt; downcast&lt;SetLineCap&gt;(item);
1020         break;
1021     case ItemType::SetLineDash:
1022         ts &lt;&lt; downcast&lt;SetLineDash&gt;(item);
1023         break;
1024     case ItemType::SetLineJoin:
1025         ts &lt;&lt; downcast&lt;SetLineJoin&gt;(item);
1026         break;
1027     case ItemType::SetMiterLimit:
1028         ts &lt;&lt; downcast&lt;SetMiterLimit&gt;(item);
1029         break;
1030     case ItemType::Clip:
1031         ts &lt;&lt; downcast&lt;Clip&gt;(item);
1032         break;
1033     case ItemType::ClipOut:
1034         ts &lt;&lt; downcast&lt;ClipOut&gt;(item);
1035         break;
1036     case ItemType::ClipOutToPath:
1037         ts &lt;&lt; downcast&lt;ClipOutToPath&gt;(item);
1038         break;
1039     case ItemType::ClipPath:
1040         ts &lt;&lt; downcast&lt;ClipPath&gt;(item);
1041         break;
1042     case ItemType::DrawGlyphs:
1043         ts &lt;&lt; downcast&lt;DrawGlyphs&gt;(item);
1044         break;
1045     case ItemType::DrawImage:
1046         ts &lt;&lt; downcast&lt;DrawImage&gt;(item);
1047         break;
1048     case ItemType::DrawTiledImage:
1049         ts &lt;&lt; downcast&lt;DrawTiledImage&gt;(item);
1050         break;
1051     case ItemType::DrawTiledScaledImage:
1052         ts &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(item);
1053         break;
1054 #if USE(CG) || USE(CAIRO)
1055     case ItemType::DrawNativeImage:
1056         ts &lt;&lt; downcast&lt;DrawNativeImage&gt;(item);
1057         break;
1058 #endif
1059     case ItemType::DrawPattern:
1060         ts &lt;&lt; downcast&lt;DrawPattern&gt;(item);
1061         break;
1062     case ItemType::DrawRect:
1063         ts &lt;&lt; downcast&lt;DrawRect&gt;(item);
1064         break;
1065     case ItemType::DrawLine:
1066         ts &lt;&lt; downcast&lt;DrawLine&gt;(item);
1067         break;
1068     case ItemType::DrawLinesForText:
1069         ts &lt;&lt; downcast&lt;DrawLinesForText&gt;(item);
1070         break;
1071     case ItemType::DrawDotsForDocumentMarker:
1072         ts &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(item);
1073         break;
1074     case ItemType::DrawEllipse:
1075         ts &lt;&lt; downcast&lt;DrawEllipse&gt;(item);
1076         break;
1077     case ItemType::DrawPath:
1078         ts &lt;&lt; downcast&lt;DrawPath&gt;(item);
1079         break;
1080     case ItemType::DrawFocusRingPath:
1081         ts &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(item);
1082         break;
1083     case ItemType::DrawFocusRingRects:
1084         ts &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(item);
1085         break;
1086     case ItemType::FillRect:
1087         ts &lt;&lt; downcast&lt;FillRect&gt;(item);
1088         break;
1089     case ItemType::FillRectWithColor:
1090         ts &lt;&lt; downcast&lt;FillRectWithColor&gt;(item);
1091         break;
1092     case ItemType::FillRectWithGradient:
1093         ts &lt;&lt; downcast&lt;FillRectWithGradient&gt;(item);
1094         break;
1095     case ItemType::FillCompositedRect:
1096         ts &lt;&lt; downcast&lt;FillCompositedRect&gt;(item);
1097         break;
1098     case ItemType::FillRoundedRect:
1099         ts &lt;&lt; downcast&lt;FillRoundedRect&gt;(item);
1100         break;
1101     case ItemType::FillRectWithRoundedHole:
1102         ts &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(item);
1103         break;
1104     case ItemType::FillPath:
1105         ts &lt;&lt; downcast&lt;FillPath&gt;(item);
1106         break;
1107     case ItemType::FillEllipse:
1108         ts &lt;&lt; downcast&lt;FillEllipse&gt;(item);
1109         break;
1110     case ItemType::StrokeRect:
1111         ts &lt;&lt; downcast&lt;StrokeRect&gt;(item);
1112         break;
1113     case ItemType::StrokePath:
1114         ts &lt;&lt; downcast&lt;StrokePath&gt;(item);
1115         break;
1116     case ItemType::StrokeEllipse:
1117         ts &lt;&lt; downcast&lt;StrokeEllipse&gt;(item);
1118         break;
1119     case ItemType::ClearRect:
1120         ts &lt;&lt; downcast&lt;ClearRect&gt;(item);
1121         break;
1122     case ItemType::BeginTransparencyLayer:
1123         ts &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(item);
1124         break;
1125     case ItemType::ApplyDeviceScaleFactor:
1126         ts &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(item);
1127         break;
1128 
1129     // Items with no additional data.
1130     case ItemType::Restore:
1131     case ItemType::EndTransparencyLayer:
1132 #if USE(CG)
1133     case ItemType::ApplyStrokePattern:
1134     case ItemType::ApplyFillPattern:
1135 #endif
1136     case ItemType::ClearShadow:
1137         break;
1138     }
1139     return ts;
1140 }
1141 
1142 }
1143 }
    </pre>
  </body>
</html>