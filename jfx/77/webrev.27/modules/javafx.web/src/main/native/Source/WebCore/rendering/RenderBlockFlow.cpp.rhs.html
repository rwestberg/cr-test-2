<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2007 David Smith (catfish.man@gmail.com)
   5  * Copyright (C) 2003-2015 Apple Inc. All rights reserved.
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 
<a name="1" id="anc1"></a><span class="line-added">  27 #include &quot;ComplexLineLayout.h&quot;</span>
  28 #include &quot;Editor.h&quot;
  29 #include &quot;FloatingObjects.h&quot;
  30 #include &quot;Frame.h&quot;
  31 #include &quot;FrameSelection.h&quot;
  32 #include &quot;HTMLElement.h&quot;
  33 #include &quot;HTMLInputElement.h&quot;
  34 #include &quot;HTMLParserIdioms.h&quot;
  35 #include &quot;HTMLTextAreaElement.h&quot;
  36 #include &quot;HitTestLocation.h&quot;
  37 #include &quot;InlineTextBox.h&quot;
  38 #include &quot;LayoutRepainter.h&quot;
  39 #include &quot;Logging.h&quot;
  40 #include &quot;RenderCombineText.h&quot;
  41 #include &quot;RenderFlexibleBox.h&quot;
  42 #include &quot;RenderInline.h&quot;
  43 #include &quot;RenderIterator.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderLayoutState.h&quot;
  46 #include &quot;RenderLineBreak.h&quot;
  47 #include &quot;RenderListItem.h&quot;
  48 #include &quot;RenderMarquee.h&quot;
  49 #include &quot;RenderMultiColumnFlow.h&quot;
  50 #include &quot;RenderMultiColumnSet.h&quot;
  51 #include &quot;RenderTableCell.h&quot;
  52 #include &quot;RenderText.h&quot;
  53 #include &quot;RenderTreeBuilder.h&quot;
  54 #include &quot;RenderView.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;SimpleLineLayoutFunctions.h&quot;
  57 #include &quot;SimpleLineLayoutPagination.h&quot;
  58 #include &quot;SimpleLineLayoutResolver.h&quot;
  59 #include &quot;TextAutoSizing.h&quot;
  60 #include &quot;VerticalPositionCache.h&quot;
  61 #include &quot;VisiblePosition.h&quot;
  62 #include &lt;wtf/IsoMallocInlines.h&gt;
  63 
  64 namespace WebCore {
  65 
  66 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBlockFlow);
  67 
  68 bool RenderBlock::s_canPropagateFloatIntoSibling = false;
  69 
  70 struct SameSizeAsMarginInfo {
  71     uint32_t bitfields : 16;
  72     LayoutUnit margins[2];
  73 };
  74 
  75 COMPILE_ASSERT(sizeof(RenderBlockFlow::MarginValues) == sizeof(LayoutUnit[4]), MarginValues_should_stay_small);
  76 COMPILE_ASSERT(sizeof(RenderBlockFlow::MarginInfo) == sizeof(SameSizeAsMarginInfo), MarginInfo_should_stay_small);
  77 
  78 // Our MarginInfo state used when laying out block children.
  79 RenderBlockFlow::MarginInfo::MarginInfo(const RenderBlockFlow&amp; block, LayoutUnit beforeBorderPadding, LayoutUnit afterBorderPadding)
  80     : m_atBeforeSideOfBlock(true)
  81     , m_atAfterSideOfBlock(false)
  82     , m_hasMarginBeforeQuirk(false)
  83     , m_hasMarginAfterQuirk(false)
  84     , m_determinedMarginBeforeQuirk(false)
  85     , m_discardMargin(false)
  86 {
  87     const RenderStyle&amp; blockStyle = block.style();
  88     ASSERT(block.isRenderView() || block.parent());
  89     m_canCollapseWithChildren = !block.createsNewFormattingContext() &amp;&amp; !block.isRenderView();
  90 
  91     m_canCollapseMarginBeforeWithChildren = m_canCollapseWithChildren &amp;&amp; !beforeBorderPadding &amp;&amp; blockStyle.marginBeforeCollapse() != MarginCollapse::Separate;
  92 
  93     // If any height other than auto is specified in CSS, then we don&#39;t collapse our bottom
  94     // margins with our children&#39;s margins. To do otherwise would be to risk odd visual
  95     // effects when the children overflow out of the parent block and yet still collapse
  96     // with it. We also don&#39;t collapse if we have any bottom border/padding.
  97     m_canCollapseMarginAfterWithChildren = m_canCollapseWithChildren &amp;&amp; !afterBorderPadding
  98         &amp;&amp; (blockStyle.logicalHeight().isAuto() &amp;&amp; !blockStyle.logicalHeight().value()) &amp;&amp; blockStyle.marginAfterCollapse() != MarginCollapse::Separate;
  99 
 100     m_quirkContainer = block.isTableCell() || block.isBody();
 101 
 102     m_discardMargin = m_canCollapseMarginBeforeWithChildren &amp;&amp; block.mustDiscardMarginBefore();
 103 
 104     m_positiveMargin = (m_canCollapseMarginBeforeWithChildren &amp;&amp; !block.mustDiscardMarginBefore()) ? block.maxPositiveMarginBefore() : 0_lu;
 105     m_negativeMargin = (m_canCollapseMarginBeforeWithChildren &amp;&amp; !block.mustDiscardMarginBefore()) ? block.maxNegativeMarginBefore() : 0_lu;
 106 }
 107 
 108 RenderBlockFlow::RenderBlockFlow(Element&amp; element, RenderStyle&amp;&amp; style)
 109     : RenderBlock(element, WTFMove(style), RenderBlockFlowFlag)
 110 #if ENABLE(TEXT_AUTOSIZING)
 111     , m_widthForTextAutosizing(-1)
 112     , m_lineCountForTextAutosizing(NOT_SET)
 113 #endif
 114 {
 115     setChildrenInline(true);
 116 }
 117 
 118 RenderBlockFlow::RenderBlockFlow(Document&amp; document, RenderStyle&amp;&amp; style)
 119     : RenderBlock(document, WTFMove(style), RenderBlockFlowFlag)
 120 #if ENABLE(TEXT_AUTOSIZING)
 121     , m_widthForTextAutosizing(-1)
 122     , m_lineCountForTextAutosizing(NOT_SET)
 123 #endif
 124 {
 125     setChildrenInline(true);
 126 }
 127 
 128 RenderBlockFlow::~RenderBlockFlow()
 129 {
 130     // Do not add any code here. Add it to willBeDestroyed() instead.
 131 }
 132 
 133 void RenderBlockFlow::willBeDestroyed()
 134 {
 135     if (!renderTreeBeingDestroyed()) {
 136         if (firstRootBox()) {
 137             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 138             // because by then we will have nuked the line boxes.
 139             if (isSelectionBorder())
 140                 frame().selection().setNeedsSelectionUpdate();
 141 
 142             // If we are an anonymous block, then our line boxes might have children
 143             // that will outlast this block. In the non-anonymous block case those
 144             // children will be destroyed by the time we return from this function.
 145             if (isAnonymousBlock()) {
 146                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 147                     while (auto childBox = box-&gt;firstChild())
 148                         childBox-&gt;removeFromParent();
 149                 }
 150             }
 151         } else if (parent())
 152             parent()-&gt;dirtyLinesFromChangedChild(*this);
 153     }
 154 
<a name="2" id="anc2"></a><span class="line-modified"> 155     if (m_complexLineLayout)</span>
<span class="line-added"> 156         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
 157 
 158     blockWillBeDestroyed();
 159 
 160     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 161     RenderBox::willBeDestroyed();
 162 }
 163 
<a name="3" id="anc3"></a><span class="line-added"> 164 RenderMultiColumnFlow* RenderBlockFlow::multiColumnFlowSlowCase() const</span>
<span class="line-added"> 165 {</span>
<span class="line-added"> 166     return rareBlockFlowData()-&gt;m_multiColumnFlow.get();</span>
<span class="line-added"> 167 }</span>
<span class="line-added"> 168 </span>
 169 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 170 {
 171     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 172     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 173     // to avoid floats.
 174     parentHasFloats = false;
 175     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 176         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
 177             auto&amp; siblingBlock = downcast&lt;RenderBlockFlow&gt;(*sibling);
 178             if (!siblingBlock.avoidsFloats())
 179                 return &amp;siblingBlock;
 180         }
 181         if (sibling-&gt;isFloating())
 182             parentHasFloats = true;
 183     }
 184     return nullptr;
 185 }
 186 
 187 void RenderBlockFlow::rebuildFloatingObjectSetFromIntrudingFloats()
 188 {
 189     if (m_floatingObjects)
 190         m_floatingObjects-&gt;setHorizontalWritingMode(isHorizontalWritingMode());
 191 
 192     HashSet&lt;RenderBox*&gt; oldIntrudingFloatSet;
 193     if (!childrenInline() &amp;&amp; m_floatingObjects) {
 194         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 195         auto end = floatingObjectSet.end();
 196         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
 197             FloatingObject* floatingObject = it-&gt;get();
 198             if (!floatingObject-&gt;isDescendant())
 199                 oldIntrudingFloatSet.add(&amp;floatingObject-&gt;renderer());
 200         }
 201     }
 202 
 203     // Inline blocks are covered by the isReplaced() check in the avoidFloats method.
 204     if (avoidsFloats() || isDocumentElementRenderer() || isRenderView() || isFloatingOrOutOfFlowPositioned() || isTableCell()) {
 205         if (m_floatingObjects)
 206             m_floatingObjects-&gt;clear();
 207         if (!oldIntrudingFloatSet.isEmpty())
 208             markAllDescendantsWithFloatsForLayout();
 209         return;
 210     }
 211 
 212     RendererToFloatInfoMap floatMap;
 213 
 214     if (m_floatingObjects) {
 215         if (childrenInline())
 216             m_floatingObjects-&gt;moveAllToFloatInfoMap(floatMap);
 217         else
 218             m_floatingObjects-&gt;clear();
 219     }
 220 
 221     // We should not process floats if the parent node is not a RenderBlock. Otherwise, we will add
 222     // floats in an invalid context. This will cause a crash arising from a bad cast on the parent.
 223     // See &lt;rdar://problem/8049753&gt;, where float property is applied on a text node in a SVG.
 224     if (!is&lt;RenderBlockFlow&gt;(parent()))
 225         return;
 226 
 227     // First add in floats from the parent. Self-collapsing blocks let their parent track any floats that intrude into
 228     // them (as opposed to floats they contain themselves) so check for those here too.
 229     auto&amp; parentBlock = downcast&lt;RenderBlockFlow&gt;(*parent());
 230     bool parentHasFloats = false;
 231     RenderBlockFlow* previousBlock = previousSiblingWithOverhangingFloats(parentHasFloats);
 232     LayoutUnit logicalTopOffset = logicalTop();
 233     if (parentHasFloats || (parentBlock.lowestFloatLogicalBottom() &gt; logicalTopOffset &amp;&amp; previousBlock &amp;&amp; previousBlock-&gt;isSelfCollapsingBlock()))
 234         addIntrudingFloats(&amp;parentBlock, &amp;parentBlock, parentBlock.logicalLeftOffsetForContent(), logicalTopOffset);
 235 
 236     LayoutUnit logicalLeftOffset;
 237     if (previousBlock)
 238         logicalTopOffset -= previousBlock-&gt;logicalTop();
 239     else {
 240         previousBlock = &amp;parentBlock;
 241         logicalLeftOffset += parentBlock.logicalLeftOffsetForContent();
 242     }
 243 
 244     // Add overhanging floats from the previous RenderBlock, but only if it has a float that intrudes into our space.
 245     if (previousBlock-&gt;m_floatingObjects &amp;&amp; previousBlock-&gt;lowestFloatLogicalBottom() &gt; logicalTopOffset)
 246         addIntrudingFloats(previousBlock, &amp;parentBlock, logicalLeftOffset, logicalTopOffset);
 247 
 248     if (childrenInline()) {
 249         LayoutUnit changeLogicalTop = LayoutUnit::max();
 250         LayoutUnit changeLogicalBottom = LayoutUnit::min();
 251         if (m_floatingObjects) {
 252             const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 253             auto end = floatingObjectSet.end();
 254             for (auto it = floatingObjectSet.begin(); it != end; ++it) {
 255                 const auto&amp; floatingObject = *it-&gt;get();
 256                 std::unique_ptr&lt;FloatingObject&gt; oldFloatingObject = floatMap.take(&amp;floatingObject.renderer());
 257                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
 258                 if (oldFloatingObject) {
 259                     LayoutUnit oldLogicalBottom = logicalBottomForFloat(*oldFloatingObject);
 260                     if (logicalWidthForFloat(floatingObject) != logicalWidthForFloat(*oldFloatingObject) || logicalLeftForFloat(floatingObject) != logicalLeftForFloat(*oldFloatingObject)) {
 261                         changeLogicalTop = 0;
 262                         changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalBottom, oldLogicalBottom));
 263                     } else {
 264                         if (logicalBottom != oldLogicalBottom) {
 265                             changeLogicalTop = std::min(changeLogicalTop, std::min(logicalBottom, oldLogicalBottom));
 266                             changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalBottom, oldLogicalBottom));
 267                         }
 268                         LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
 269                         LayoutUnit oldLogicalTop = logicalTopForFloat(*oldFloatingObject);
 270                         if (logicalTop != oldLogicalTop) {
 271                             changeLogicalTop = std::min(changeLogicalTop, std::min(logicalTop, oldLogicalTop));
 272                             changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalTop, oldLogicalTop));
 273                         }
 274                     }
 275 
 276                     if (oldFloatingObject-&gt;originatingLine() &amp;&amp; !selfNeedsLayout()) {
 277                         ASSERT(&amp;oldFloatingObject-&gt;originatingLine()-&gt;renderer() == this);
 278                         oldFloatingObject-&gt;originatingLine()-&gt;markDirty();
 279                     }
 280                 } else {
 281                     changeLogicalTop = 0;
 282                     changeLogicalBottom = std::max(changeLogicalBottom, logicalBottom);
 283                 }
 284             }
 285         }
 286 
 287         auto end = floatMap.end();
 288         for (auto it = floatMap.begin(); it != end; ++it) {
 289             const auto&amp; floatingObject = *it-&gt;value.get();
 290             if (!floatingObject.isDescendant()) {
 291                 changeLogicalTop = 0;
 292                 changeLogicalBottom = std::max(changeLogicalBottom, logicalBottomForFloat(floatingObject));
 293             }
 294         }
 295 
 296         markLinesDirtyInBlockRange(changeLogicalTop, changeLogicalBottom);
 297     } else if (!oldIntrudingFloatSet.isEmpty()) {
 298         // If there are previously intruding floats that no longer intrude, then children with floats
 299         // should also get layout because they might need their floating object lists cleared.
 300         if (m_floatingObjects-&gt;set().size() &lt; oldIntrudingFloatSet.size())
 301             markAllDescendantsWithFloatsForLayout();
 302         else {
 303             const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 304             auto end = floatingObjectSet.end();
 305             for (auto it = floatingObjectSet.begin(); it != end &amp;&amp; !oldIntrudingFloatSet.isEmpty(); ++it)
 306                 oldIntrudingFloatSet.remove(&amp;(*it)-&gt;renderer());
 307             if (!oldIntrudingFloatSet.isEmpty())
 308                 markAllDescendantsWithFloatsForLayout();
 309         }
 310     }
 311 }
 312 
 313 void RenderBlockFlow::adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 314 {
 315     if (!style().hasAutoColumnCount() || !style().hasAutoColumnWidth()) {
 316         // The min/max intrinsic widths calculated really tell how much space elements need when
 317         // laid out inside the columns. In order to eventually end up with the desired column width,
 318         // we need to convert them to values pertaining to the multicol container.
 319         int columnCount = style().hasAutoColumnCount() ? 1 : style().columnCount();
 320         LayoutUnit columnWidth;
 321         LayoutUnit colGap = columnGap();
 322         LayoutUnit gapExtra = (columnCount - 1) * colGap;
 323         if (style().hasAutoColumnWidth())
 324             minLogicalWidth = minLogicalWidth * columnCount + gapExtra;
 325         else {
 326             columnWidth = style().columnWidth();
 327             minLogicalWidth = std::min(minLogicalWidth, columnWidth);
 328         }
 329         // FIXME: If column-count is auto here, we should resolve it to calculate the maximum
 330         // intrinsic width, instead of pretending that it&#39;s 1. The only way to do that is by
 331         // performing a layout pass, but this is not an appropriate time or place for layout. The
 332         // good news is that if height is unconstrained and there are no explicit breaks, the
 333         // resolved column-count really should be 1.
 334         maxLogicalWidth = std::max(maxLogicalWidth, columnWidth) * columnCount + gapExtra;
 335     }
 336 }
 337 
 338 void RenderBlockFlow::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 339 {
 340     if (childrenInline())
 341         computeInlinePreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
 342     else
 343         computeBlockPreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
 344 
 345     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
 346 
 347     adjustIntrinsicLogicalWidthsForColumns(minLogicalWidth, maxLogicalWidth);
 348 
 349     if (!style().autoWrap() &amp;&amp; childrenInline()) {
 350         // A horizontal marquee with inline children has no minimum width.
 351         if (layer() &amp;&amp; layer()-&gt;marquee() &amp;&amp; layer()-&gt;marquee()-&gt;isHorizontal())
 352             minLogicalWidth = 0;
 353     }
 354 
 355     if (is&lt;RenderTableCell&gt;(*this)) {
 356         Length tableCellWidth = downcast&lt;RenderTableCell&gt;(*this).styleOrColLogicalWidth();
 357         if (tableCellWidth.isFixed() &amp;&amp; tableCellWidth.value() &gt; 0)
 358             maxLogicalWidth = std::max(minLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(tableCellWidth.value()));
 359     }
 360 
 361     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
 362     maxLogicalWidth += scrollbarWidth;
 363     minLogicalWidth += scrollbarWidth;
 364 }
 365 
 366 bool RenderBlockFlow::recomputeLogicalWidthAndColumnWidth()
 367 {
 368     bool changed = recomputeLogicalWidth();
 369 
 370     LayoutUnit oldColumnWidth = computedColumnWidth();
 371     computeColumnCountAndWidth();
 372 
 373     return changed || oldColumnWidth != computedColumnWidth();
 374 }
 375 
 376 LayoutUnit RenderBlockFlow::columnGap() const
 377 {
 378     if (style().columnGap().isNormal())
 379         return style().fontDescription().computedPixelSize(); // &quot;1em&quot; is recommended as the normal gap setting. Matches &lt;p&gt; margins.
 380     return valueForLength(style().columnGap().length(), availableLogicalWidth());
 381 }
 382 
 383 void RenderBlockFlow::computeColumnCountAndWidth()
 384 {
 385     // Calculate our column width and column count.
 386     // FIXME: Can overflow on fast/block/float/float-not-removed-from-next-sibling4.html, see https://bugs.webkit.org/show_bug.cgi?id=68744
 387     unsigned desiredColumnCount = 1;
 388     LayoutUnit desiredColumnWidth = contentLogicalWidth();
 389 
 390     // For now, we don&#39;t support multi-column layouts when printing, since we have to do a lot of work for proper pagination.
 391     if (document().paginated() || (style().hasAutoColumnCount() &amp;&amp; style().hasAutoColumnWidth()) || !style().hasInlineColumnAxis()) {
 392         setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 393         return;
 394     }
 395 
 396     LayoutUnit availWidth = desiredColumnWidth;
 397     LayoutUnit colGap = columnGap();
<a name="4" id="anc4"></a><span class="line-modified"> 398     LayoutUnit colWidth = std::max(1_lu, LayoutUnit(style().columnWidth()));</span>
 399     unsigned colCount = std::max&lt;unsigned&gt;(1, style().columnCount());
 400 
 401     if (style().hasAutoColumnWidth() &amp;&amp; !style().hasAutoColumnCount()) {
 402         desiredColumnCount = colCount;
 403         desiredColumnWidth = std::max&lt;LayoutUnit&gt;(0, (availWidth - ((desiredColumnCount - 1) * colGap)) / desiredColumnCount);
 404     } else if (!style().hasAutoColumnWidth() &amp;&amp; style().hasAutoColumnCount()) {
 405         desiredColumnCount = std::max&lt;unsigned&gt;(1, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned());
 406         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 407     } else {
 408         desiredColumnCount = std::max&lt;unsigned&gt;(std::min(colCount, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned()), 1);
 409         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 410     }
 411     setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 412 }
 413 
 414 bool RenderBlockFlow::willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount) const
 415 {
 416     // The following types are not supposed to create multicol context.
 417     if (isFileUploadControl() || isTextControl() || isListBox())
 418         return false;
 419     if (isRenderSVGBlock() || isRubyRun())
 420         return false;
 421 #if ENABLE(MATHML)
 422     if (isRenderMathMLBlock())
 423         return false;
 424 #endif // ENABLE(MATHML)
 425 
 426     if (!firstChild())
 427         return false;
 428 
 429     if (style().styleType() != PseudoId::None)
 430         return false;
 431 
 432     // If overflow-y is set to paged-x or paged-y on the body or html element, we&#39;ll handle the paginating in the RenderView instead.
 433     if ((style().overflowY() == Overflow::PagedX || style().overflowY() == Overflow::PagedY) &amp;&amp; !(isDocumentElementRenderer() || isBody()))
 434         return true;
 435 
 436     if (!style().specifiesColumns())
 437         return false;
 438 
 439     // column-axis with opposite writing direction initiates MultiColumnFlow.
 440     if (!style().hasInlineColumnAxis())
 441         return true;
 442 
 443     // Non-auto column-width always initiates MultiColumnFlow.
 444     if (!style().hasAutoColumnWidth())
 445         return true;
 446 
 447     if (desiredColumnCount)
 448         return desiredColumnCount.value() &gt; 1;
 449 
 450     // column-count &gt; 1 always initiates MultiColumnFlow.
 451     if (!style().hasAutoColumnCount())
 452         return style().columnCount() &gt; 1;
 453 
 454     ASSERT_NOT_REACHED();
 455     return false;
 456 }
 457 
 458 void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)
 459 {
 460     ASSERT(needsLayout());
 461 
 462     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 463         return;
 464 
 465     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 466 
 467     if (recomputeLogicalWidthAndColumnWidth())
 468         relayoutChildren = true;
 469 
 470     rebuildFloatingObjectSetFromIntrudingFloats();
 471 
 472     LayoutUnit previousHeight = logicalHeight();
 473     // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
 474     // for consistency with other render classes?
 475     setLogicalHeight(0);
 476 
 477     bool pageLogicalHeightChanged = false;
 478     checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
 479 
 480     LayoutUnit repaintLogicalTop;
 481     LayoutUnit repaintLogicalBottom;
 482     LayoutUnit maxFloatLogicalBottom;
 483     const RenderStyle&amp; styleToUse = style();
 484     {
 485         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 486 
 487         preparePaginationBeforeBlockLayout(relayoutChildren);
 488 
 489         // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track
 490         // our current maximal positive and negative margins. These values are used when we
 491         // are collapsed with adjacent blocks, so for example, if you have block A and B
 492         // collapsing together, then you&#39;d take the maximal positive margin from both A and B
 493         // and subtract it from the maximal negative margin from both A and B to get the
 494         // true collapsed margin. This algorithm is recursive, so when we finish layout()
 495         // our block knows its current maximal positive/negative values.
 496         //
 497         // Start out by setting our margin values to our current margins. Table cells have
 498         // no margins, so we don&#39;t fill in the values for table cells.
 499         bool isCell = isTableCell();
 500         if (!isCell) {
 501             initMaxMarginValues();
 502 
 503             setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());
 504             setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());
 505             setPaginationStrut(0);
 506         }
 507         if (!firstChild() &amp;&amp; !isAnonymousBlock())
 508             setChildrenInline(true);
 509         if (childrenInline())
 510             layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 511         else
 512             layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);
 513     }
 514 
 515     // Expand our intrinsic height to encompass floats.
 516     LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();
 517     if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())
 518         setLogicalHeight(lowestFloatLogicalBottom() + toAdd);
 519     if (relayoutForPagination() || relayoutToAvoidWidows()) {
 520         ASSERT(!shouldBreakAtLineToAvoidWidow());
 521         return;
 522     }
 523 
 524     // Calculate our new height.
 525     LayoutUnit oldHeight = logicalHeight();
 526     LayoutUnit oldClientAfterEdge = clientLogicalBottom();
 527 
 528     // Before updating the final size of the flow thread make sure a forced break is applied after the content.
 529     // This ensures the size information is correctly computed for the last auto-height fragment receiving content.
 530     if (is&lt;RenderFragmentedFlow&gt;(*this))
 531         downcast&lt;RenderFragmentedFlow&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);
 532 
 533     updateLogicalHeight();
 534     LayoutUnit newHeight = logicalHeight();
 535     {
 536         // FIXME: This could be removed once relayoutForPagination()/relayoutToAvoidWidows() either stop recursing or we manage to
 537         // re-order them.
 538         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 539 
 540         if (oldHeight != newHeight) {
 541             if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) {
 542                 // One of our children&#39;s floats may have become an overhanging float for us. We need to look for it.
 543                 for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
 544                     if (blockFlow.isFloatingOrOutOfFlowPositioned())
 545                         continue;
 546                     if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)
 547                         addOverhangingFloats(blockFlow, false);
 548                 }
 549             }
 550         }
 551 
 552         bool heightChanged = (previousHeight != newHeight);
 553         if (heightChanged)
 554             relayoutChildren = true;
 555         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 556     }
 557     // Add overflow from children (unless we&#39;re multi-column, since in that case all our child overflow is clipped anyway).
 558     computeOverflow(oldClientAfterEdge);
 559 
 560     fitBorderToLinesIfNeeded();
 561 
 562     auto* state = view().frameView().layoutContext().layoutState();
 563     if (state &amp;&amp; state-&gt;pageLogicalHeight())
 564         setPageLogicalOffset(state-&gt;pageLogicalOffset(this, logicalTop()));
 565 
 566     updateLayerTransform();
 567 
 568     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if
 569     // we overflow or not.
 570     updateScrollInfoAfterLayout();
 571 
 572     // FIXME: This repaint logic should be moved into a separate helper function!
 573     // Repaint with our new bounds if they are different from our old bounds.
 574     bool didFullRepaint = repainter.repaintAfterLayout();
 575     if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == Visibility::Visible || enclosingLayer()-&gt;hasVisibleContent())) {
 576         // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines
 577         // it had to lay out. We wouldn&#39;t need the hasOverflowClip() hack in that case either.
 578         LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();
 579         LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();
 580         if (hasOverflowClip()) {
 581             // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&#39;t propagate to our block&#39;s overflow.
 582             // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.
 583             // layoutInlineChildren should be patched to compute the entire repaint rect.
 584             repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());
 585             repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());
 586         }
 587 
 588         LayoutRect repaintRect;
 589         if (isHorizontalWritingMode())
 590             repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);
 591         else
 592             repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);
 593 
 594         if (hasOverflowClip()) {
 595             // Adjust repaint rect for scroll offset
 596             repaintRect.moveBy(-scrollPosition());
 597 
 598             // Don&#39;t allow this rect to spill out of our overflow box.
 599             repaintRect.intersect(LayoutRect(LayoutPoint(), size()));
 600         }
 601 
 602         // Make sure the rect is still non-empty after intersecting for overflow above
 603         if (!repaintRect.isEmpty()) {
 604             repaintRectangle(repaintRect); // We need to do a partial repaint of our content.
 605             if (hasReflection())
 606                 repaintRectangle(reflectedRect(repaintRect));
 607         }
 608     }
 609 
 610     clearNeedsLayout();
 611 }
 612 
 613 void RenderBlockFlow::layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom)
 614 {
 615     dirtyForLayoutFromPercentageHeightDescendants();
 616 
 617     LayoutUnit beforeEdge = borderAndPaddingBefore();
 618     LayoutUnit afterEdge = borderAndPaddingAfter() + scrollbarLogicalHeight();
 619 
 620     setLogicalHeight(beforeEdge);
 621 
 622     // Lay out our hypothetical grid line as though it occurs at the top of the block.
 623     if (view().frameView().layoutContext().layoutState()-&gt;lineGrid() == this)
 624         layoutLineGridBox();
 625 
 626     // The margin struct caches all our current margin collapsing state.
 627     MarginInfo marginInfo(*this, beforeEdge, afterEdge);
 628 
 629     // Fieldsets need to find their legend and position it inside the border of the object.
 630     // The legend then gets skipped during normal layout. The same is true for ruby text.
 631     // It doesn&#39;t get included in the normal layout process but is instead skipped.
 632     layoutExcludedChildren(relayoutChildren);
 633 
 634     LayoutUnit previousFloatLogicalBottom;
 635     maxFloatLogicalBottom = 0;
 636 
 637     RenderBox* next = firstChildBox();
 638 
 639     while (next) {
 640         RenderBox&amp; child = *next;
 641         next = child.nextSiblingBox();
 642 
 643         if (child.isExcludedFromNormalLayout())
 644             continue; // Skip this child, since it will be positioned by the specialized subclass (fieldsets and ruby runs).
 645 
 646         updateBlockChildDirtyBitsBeforeLayout(relayoutChildren, child);
 647 
 648         if (child.isOutOfFlowPositioned()) {
 649             child.containingBlock()-&gt;insertPositionedObject(child);
 650             adjustPositionedBlock(child, marginInfo);
 651             continue;
 652         }
 653         if (child.isFloating()) {
 654             insertFloatingObject(child);
 655             adjustFloatingBlock(marginInfo);
 656             continue;
 657         }
 658 
 659         // Lay out the child.
 660         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 661     }
 662 
 663     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 664     // determining the correct collapsed bottom margin information.
 665     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 666 }
 667 
 668 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 669 {
 670     if (lineLayoutPath() == UndeterminedPath)
 671         setLineLayoutPath(SimpleLineLayout::canUseFor(*this) ? SimpleLinesPath : LineBoxesPath);
 672 
 673     if (lineLayoutPath() == SimpleLinesPath) {
 674         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 675         return;
 676     }
 677 
 678     m_simpleLineLayout = nullptr;
<a name="5" id="anc5"></a><span class="line-modified"> 679 </span>
<span class="line-added"> 680     if (!m_complexLineLayout)</span>
<span class="line-added"> 681         m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-added"> 682 </span>
<span class="line-added"> 683     m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
 684 }
 685 
 686 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 687 {
 688     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 689     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 690 
 691     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 692     child.computeAndSetBlockDirectionMargins(*this);
 693 
 694     // Try to guess our correct logical top position. In most cases this guess will
 695     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 696     // will we have to potentially relayout.
 697     LayoutUnit estimateWithoutPagination;
 698     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 699 
 700     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 701     LayoutRect oldRect = child.frameRect();
 702     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 703 
 704 #if !ASSERT_DISABLED
 705     LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
 706 #endif
 707     // Position the child as though it didn&#39;t collapse with the top.
 708     setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
 709     estimateFragmentRangeForBoxChild(child);
 710 
 711     RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 712     bool markDescendantsWithFloats = false;
 713     if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 714         markDescendantsWithFloats = true;
 715     else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))
 716         // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for
 717         // very large elements. If it does the comparison with oldLogicalTop might yield a
 718         // false negative as adding and removing margins, borders etc from a saturated number
 719         // might yield incorrect results. If this is the case always mark for layout.
 720         markDescendantsWithFloats = true;
 721     else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) {
 722         // If an element might be affected by the presence of floats, then always mark it for
 723         // layout.
 724         LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());
 725         if (fb &gt; logicalTopEstimate)
 726             markDescendantsWithFloats = true;
 727     }
 728 
 729     if (childBlockFlow) {
 730         if (markDescendantsWithFloats)
 731             childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
 732         if (!child.isWritingModeRoot())
 733             previousFloatLogicalBottom = std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());
 734     }
 735 
 736     child.markForPaginationRelayoutIfNeeded();
 737 
 738     bool childHadLayout = child.everHadLayout();
 739     bool childNeededLayout = child.needsLayout();
 740     if (childNeededLayout)
 741         child.layout();
 742 
 743     // Cache if we are at the top of the block right now.
 744     bool atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();
 745 
 746     // Now determine the correct ypos based off examination of collapsing margin
 747     // values.
 748     LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);
 749 
 750     // Now check for clear.
 751     LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);
 752 
 753     bool paginated = view().frameView().layoutContext().layoutState()-&gt;isPaginated();
 754     if (paginated)
 755         logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);
 756 
 757     setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
 758 
 759     // Now we have a final top position. See if it really does end up being different from our estimate.
 760     // clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&#39;t move. This happens
 761     // when collapseMargins dynamically adds overhanging floats because of a child with negative margins.
 762     if (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) {
 763         if (child.shrinkToAvoidFloats()) {
 764             // The child&#39;s width depends on the line width. When the child shifts to clear an item, its width can
 765             // change (because it has more available line width). So mark the item as dirty.
 766             child.setChildNeedsLayout(MarkOnlyThis);
 767         }
 768 
 769         if (childBlockFlow) {
 770             if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())
 771                 childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
 772             child.markForPaginationRelayoutIfNeeded();
 773         }
 774     }
 775 
 776     if (updateFragmentRangeForBoxChild(child))
 777         child.setNeedsLayout(MarkOnlyThis);
 778 
 779     // In case our guess was wrong, relayout the child.
 780     child.layoutIfNeeded();
 781 
 782     // We are no longer at the top of the block if we encounter a non-empty child.
 783     // This has to be done after checking for clear, so that margins can be reset if a clear occurred.
 784     if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())
 785         marginInfo.setAtBeforeSideOfBlock(false);
 786 
 787     // Now place the child in the correct left position
 788     determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);
 789 
 790     // Update our height now that the child has been placed in the correct position.
 791     setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));
 792     if (mustSeparateMarginAfterForChild(child)) {
 793         setLogicalHeight(logicalHeight() + marginAfterForChild(child));
 794         marginInfo.clearMargin();
 795     }
 796     // If the child has overhanging floats that intrude into following siblings (or possibly out
 797     // of this block), then the parent gets notified of the floats now.
 798     if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 799         maxFloatLogicalBottom = std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));
 800 
 801     LayoutSize childOffset = child.location() - oldRect.location();
 802     if (childOffset.width() || childOffset.height()) {
 803         view().frameView().layoutContext().addLayoutDelta(childOffset);
 804 
 805         // If the child moved, we have to repaint it as well as any floating/positioned
 806         // descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
 807         // repaint ourselves (and the child) anyway.
 808         if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())
 809             child.repaintDuringLayoutIfMoved(oldRect);
 810     }
 811 
 812     if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) {
 813         child.repaint();
 814         child.repaintOverhangingFloats(true);
 815     }
 816 
 817     if (paginated) {
 818         if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
 819             fragmentedFlow-&gt;fragmentedFlowDescendantBoxLaidOut(&amp;child);
 820         // Check for an after page/column break.
 821         LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);
 822         if (newHeight != height())
 823             setLogicalHeight(newHeight);
 824     }
 825 
 826     ASSERT(view().frameView().layoutContext().layoutDeltaMatches(oldLayoutDelta));
 827 }
 828 
 829 void RenderBlockFlow::adjustPositionedBlock(RenderBox&amp; child, const MarginInfo&amp; marginInfo)
 830 {
 831     bool isHorizontal = isHorizontalWritingMode();
 832     bool hasStaticBlockPosition = child.style().hasStaticBlockPosition(isHorizontal);
 833 
 834     LayoutUnit logicalTop = logicalHeight();
 835     updateStaticInlinePositionForChild(child, logicalTop, DoNotIndentText);
 836 
 837     if (!marginInfo.canCollapseWithMarginBefore()) {
 838         // Positioned blocks don&#39;t collapse margins, so add the margin provided by
 839         // the container now. The child&#39;s own margin is added later when calculating its logical top.
 840         LayoutUnit collapsedBeforePos = marginInfo.positiveMargin();
 841         LayoutUnit collapsedBeforeNeg = marginInfo.negativeMargin();
 842         logicalTop += collapsedBeforePos - collapsedBeforeNeg;
 843     }
 844 
 845     RenderLayer* childLayer = child.layer();
 846     if (childLayer-&gt;staticBlockPosition() != logicalTop) {
 847         childLayer-&gt;setStaticBlockPosition(logicalTop);
 848         if (hasStaticBlockPosition)
 849             child.setChildNeedsLayout(MarkOnlyThis);
 850     }
 851 }
 852 
 853 LayoutUnit RenderBlockFlow::marginOffsetForSelfCollapsingBlock()
 854 {
 855     ASSERT(isSelfCollapsingBlock());
 856     RenderBlockFlow* parentBlock = downcast&lt;RenderBlockFlow&gt;(parent());
 857     if (parentBlock &amp;&amp; style().clear() != Clear::None &amp;&amp; parentBlock-&gt;getClearDelta(*this, logicalHeight()))
 858         return marginValuesForChild(*this).positiveMarginBefore();
 859     return 0_lu;
 860 }
 861 
 862 void RenderBlockFlow::determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode applyDelta)
 863 {
 864     LayoutUnit startPosition = borderStart() + paddingStart();
 865     if (shouldPlaceBlockDirectionScrollbarOnLeft())
 866         startPosition += (style().isLeftToRightDirection() ? 1 : -1) * verticalScrollbarWidth();
 867     LayoutUnit totalAvailableLogicalWidth = borderAndPaddingLogicalWidth() + availableLogicalWidth();
 868 
 869     // Add in our start margin.
 870     LayoutUnit childMarginStart = marginStartForChild(child);
 871     LayoutUnit newPosition = startPosition + childMarginStart;
 872 
 873     // Some objects (e.g., tables, horizontal rules, overflow:auto blocks) avoid floats. They need
 874     // to shift over as necessary to dodge any floats that might get in the way.
 875     if (child.avoidsFloats() &amp;&amp; containsFloats())
 876         newPosition += computeStartPositionDeltaForChildAvoidingFloats(child, marginStartForChild(child));
 877 
 878     setLogicalLeftForChild(child, style().isLeftToRightDirection() ? newPosition : totalAvailableLogicalWidth - newPosition - logicalWidthForChild(child), applyDelta);
 879 }
 880 
 881 void RenderBlockFlow::adjustFloatingBlock(const MarginInfo&amp; marginInfo)
 882 {
 883     // The float should be positioned taking into account the bottom margin
 884     // of the previous flow. We add that margin into the height, get the
 885     // float positioned properly, and then subtract the margin out of the
 886     // height again. In the case of self-collapsing blocks, we always just
 887     // use the top margins, since the self-collapsing block collapsed its
 888     // own bottom margin into its top margin.
 889     //
 890     // Note also that the previous flow may collapse its margin into the top of
 891     // our block. If this is the case, then we do not add the margin in to our
 892     // height when computing the position of the float. This condition can be tested
 893     // for by simply calling canCollapseWithMarginBefore. See
 894     // http://www.hixie.ch/tests/adhoc/css/box/block/margin-collapse/046.html for
 895     // an example of this scenario.
 896     LayoutUnit marginOffset = marginInfo.canCollapseWithMarginBefore() ? 0_lu : marginInfo.margin();
 897     setLogicalHeight(logicalHeight() + marginOffset);
 898     positionNewFloats();
 899     setLogicalHeight(logicalHeight() - marginOffset);
 900 }
 901 
 902 void RenderBlockFlow::updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText)
 903 {
 904     if (child.style().isOriginalDisplayInlineType())
 905         setStaticInlinePositionForChild(child, logicalTop, startAlignedOffsetForLine(logicalTop, shouldIndentText));
 906     else
 907         setStaticInlinePositionForChild(child, logicalTop, startOffsetForContent(logicalTop));
 908 }
 909 
 910 void RenderBlockFlow::setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition)
 911 {
 912     if (enclosingFragmentedFlow()) {
 913         // Shift the inline position to exclude the fragment offset.
 914         inlinePosition += startOffsetForContent() - startOffsetForContent(blockOffset);
 915     }
 916     child.layer()-&gt;setStaticInlinePosition(inlinePosition);
 917 }
 918 
<a name="6" id="anc6"></a><span class="line-added"> 919 LayoutUnit RenderBlockFlow::startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText)</span>
<span class="line-added"> 920 {</span>
<span class="line-added"> 921     TextAlignMode textAlign = style().textAlign();</span>
<span class="line-added"> 922     bool shouldApplyIndentText = false;</span>
<span class="line-added"> 923     switch (textAlign) {</span>
<span class="line-added"> 924     case TextAlignMode::Left:</span>
<span class="line-added"> 925     case TextAlignMode::WebKitLeft:</span>
<span class="line-added"> 926         shouldApplyIndentText = style().isLeftToRightDirection();</span>
<span class="line-added"> 927         break;</span>
<span class="line-added"> 928     case TextAlignMode::Right:</span>
<span class="line-added"> 929     case TextAlignMode::WebKitRight:</span>
<span class="line-added"> 930         shouldApplyIndentText = !style().isLeftToRightDirection();</span>
<span class="line-added"> 931         break;</span>
<span class="line-added"> 932     case TextAlignMode::Start:</span>
<span class="line-added"> 933         shouldApplyIndentText = true;</span>
<span class="line-added"> 934         break;</span>
<span class="line-added"> 935     default:</span>
<span class="line-added"> 936         shouldApplyIndentText = false;</span>
<span class="line-added"> 937     }</span>
<span class="line-added"> 938     // &lt;rdar://problem/15427571&gt;</span>
<span class="line-added"> 939     // https://bugs.webkit.org/show_bug.cgi?id=124522</span>
<span class="line-added"> 940     // This quirk is for legacy content that doesn&#39;t work properly with the center positioning scheme</span>
<span class="line-added"> 941     // being honored (e.g., epubs).</span>
<span class="line-added"> 942     if (shouldApplyIndentText || settings().useLegacyTextAlignPositionedElementBehavior()) // FIXME: Handle TextAlignMode::End here</span>
<span class="line-added"> 943         return startOffsetForLine(position, shouldIndentText);</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945     // updateLogicalWidthForAlignment() handles the direction of the block so no need to consider it here</span>
<span class="line-added"> 946     float totalLogicalWidth = 0;</span>
<span class="line-added"> 947     float logicalLeft = logicalLeftOffsetForLine(logicalHeight(), DoNotIndentText);</span>
<span class="line-added"> 948     float availableLogicalWidth = logicalRightOffsetForLine(logicalHeight(), DoNotIndentText) - logicalLeft;</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     ComplexLineLayout::updateLogicalWidthForAlignment(*this, textAlign, nullptr, nullptr, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952     if (!style().isLeftToRightDirection())</span>
<span class="line-added"> 953         return LayoutUnit(logicalWidth() - logicalLeft);</span>
<span class="line-added"> 954 </span>
<span class="line-added"> 955     return LayoutUnit(logicalLeft);</span>
<span class="line-added"> 956 }</span>
<span class="line-added"> 957 </span>
 958 RenderBlockFlow::MarginValues RenderBlockFlow::marginValuesForChild(RenderBox&amp; child) const
 959 {
 960     LayoutUnit childBeforePositive;
 961     LayoutUnit childBeforeNegative;
 962     LayoutUnit childAfterPositive;
 963     LayoutUnit childAfterNegative;
 964 
 965     LayoutUnit beforeMargin;
 966     LayoutUnit afterMargin;
 967 
 968     RenderBlockFlow* childRenderBlock = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 969 
 970     // If the child has the same directionality as we do, then we can just return its
 971     // margins in the same direction.
 972     if (!child.isWritingModeRoot()) {
 973         if (childRenderBlock) {
 974             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginBefore();
 975             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
 976             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginAfter();
 977             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
 978         } else {
 979             beforeMargin = child.marginBefore();
 980             afterMargin = child.marginAfter();
 981         }
 982     } else if (child.isHorizontalWritingMode() == isHorizontalWritingMode()) {
 983         // The child has a different directionality. If the child is parallel, then it&#39;s just
 984         // flipped relative to us. We can use the margins for the opposite edges.
 985         if (childRenderBlock) {
 986             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginAfter();
 987             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
 988             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginBefore();
 989             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
 990         } else {
 991             beforeMargin = child.marginAfter();
 992             afterMargin = child.marginBefore();
 993         }
 994     } else {
 995         // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
 996         // &quot;logical left/right&quot; sides of the child box. We can just return the raw margin in this case.
 997         beforeMargin = marginBeforeForChild(child);
 998         afterMargin = marginAfterForChild(child);
 999     }
1000 
1001     // Resolve uncollapsing margins into their positive/negative buckets.
1002     if (beforeMargin) {
1003         if (beforeMargin &gt; 0)
1004             childBeforePositive = beforeMargin;
1005         else
1006             childBeforeNegative = -beforeMargin;
1007     }
1008     if (afterMargin) {
1009         if (afterMargin &gt; 0)
1010             childAfterPositive = afterMargin;
1011         else
1012             childAfterNegative = -afterMargin;
1013     }
1014 
1015     return MarginValues(childBeforePositive, childBeforeNegative, childAfterPositive, childAfterNegative);
1016 }
1017 
1018 bool RenderBlockFlow::childrenPreventSelfCollapsing() const
1019 {
1020     if (!childrenInline())
1021         return RenderBlock::childrenPreventSelfCollapsing();
1022 
1023     return hasLines();
1024 }
1025 
1026 LayoutUnit RenderBlockFlow::collapseMargins(RenderBox&amp; child, MarginInfo&amp; marginInfo)
1027 {
1028     return collapseMarginsWithChildInfo(&amp;child, child.previousSibling(), marginInfo);
1029 }
1030 
1031 LayoutUnit RenderBlockFlow::collapseMarginsWithChildInfo(RenderBox* child, RenderObject* prevSibling, MarginInfo&amp; marginInfo)
1032 {
1033     bool childDiscardMarginBefore = child ? mustDiscardMarginBeforeForChild(*child) : false;
1034     bool childDiscardMarginAfter = child ? mustDiscardMarginAfterForChild(*child) : false;
1035     bool childIsSelfCollapsing = child ? child-&gt;isSelfCollapsingBlock() : false;
1036     bool beforeQuirk = child ? hasMarginBeforeQuirk(*child) : false;
1037     bool afterQuirk = child ? hasMarginAfterQuirk(*child) : false;
1038 
1039     // The child discards the before margin when the after margin has discarded in the case of a self collapsing block.
1040     childDiscardMarginBefore = childDiscardMarginBefore || (childDiscardMarginAfter &amp;&amp; childIsSelfCollapsing);
1041 
1042     // Get the four margin values for the child and cache them.
1043     const MarginValues childMargins = child ? marginValuesForChild(*child) : MarginValues(0, 0, 0, 0);
1044 
1045     // Get our max pos and neg top margins.
1046     LayoutUnit posTop = childMargins.positiveMarginBefore();
1047     LayoutUnit negTop = childMargins.negativeMarginBefore();
1048 
1049     // For self-collapsing blocks, collapse our bottom margins into our
1050     // top to get new posTop and negTop values.
1051     if (childIsSelfCollapsing) {
1052         posTop = std::max(posTop, childMargins.positiveMarginAfter());
1053         negTop = std::max(negTop, childMargins.negativeMarginAfter());
1054     }
1055 
1056     if (marginInfo.canCollapseWithMarginBefore()) {
1057         if (!childDiscardMarginBefore &amp;&amp; !marginInfo.discardMargin()) {
1058             // This child is collapsing with the top of the
1059             // block. If it has larger margin values, then we need to update
1060             // our own maximal values.
1061             if (!document().inQuirksMode() || !marginInfo.quirkContainer() || !beforeQuirk)
1062                 setMaxMarginBeforeValues(std::max(posTop, maxPositiveMarginBefore()), std::max(negTop, maxNegativeMarginBefore()));
1063 
1064             // The minute any of the margins involved isn&#39;t a quirk, don&#39;t
1065             // collapse it away, even if the margin is smaller (www.webreference.com
1066             // has an example of this, a &lt;dt&gt; with 0.8em author-specified inside
1067             // a &lt;dl&gt; inside a &lt;td&gt;.
1068             if (!marginInfo.determinedMarginBeforeQuirk() &amp;&amp; !beforeQuirk &amp;&amp; (posTop - negTop)) {
1069                 setHasMarginBeforeQuirk(false);
1070                 marginInfo.setDeterminedMarginBeforeQuirk(true);
1071             }
1072 
1073             if (!marginInfo.determinedMarginBeforeQuirk() &amp;&amp; beforeQuirk &amp;&amp; !marginBefore()) {
1074                 // We have no top margin and our top child has a quirky margin.
1075                 // We will pick up this quirky margin and pass it through.
1076                 // This deals with the &lt;td&gt;&lt;div&gt;&lt;p&gt; case.
1077                 // Don&#39;t do this for a block that split two inlines though. You do
1078                 // still apply margins in this case.
1079                 setHasMarginBeforeQuirk(true);
1080             }
1081         } else
1082             // The before margin of the container will also discard all the margins it is collapsing with.
1083             setMustDiscardMarginBefore();
1084     }
1085 
1086     // Once we find a child with discardMarginBefore all the margins collapsing with us must also discard.
1087     if (childDiscardMarginBefore) {
1088         marginInfo.setDiscardMargin(true);
1089         marginInfo.clearMargin();
1090     }
1091 
1092     if (marginInfo.quirkContainer() &amp;&amp; marginInfo.atBeforeSideOfBlock() &amp;&amp; (posTop - negTop))
1093         marginInfo.setHasMarginBeforeQuirk(beforeQuirk);
1094 
1095     LayoutUnit beforeCollapseLogicalTop = logicalHeight();
1096     LayoutUnit logicalTop = beforeCollapseLogicalTop;
1097 
1098     LayoutUnit clearanceForSelfCollapsingBlock;
1099 
1100     // If the child&#39;s previous sibling is a self-collapsing block that cleared a float then its top border edge has been set at the bottom border edge
1101     // of the float. Since we want to collapse the child&#39;s top margin with the self-collapsing block&#39;s top and bottom margins we need to adjust our parent&#39;s height to match the
1102     // margin top of the self-collapsing block. If the resulting collapsed margin leaves the child still intruding into the float then we will want to clear it.
1103     if (!marginInfo.canCollapseWithMarginBefore() &amp;&amp; is&lt;RenderBlockFlow&gt;(prevSibling) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*prevSibling).isSelfCollapsingBlock()) {
1104         clearanceForSelfCollapsingBlock = downcast&lt;RenderBlockFlow&gt;(*prevSibling).marginOffsetForSelfCollapsingBlock();
1105         setLogicalHeight(logicalHeight() - clearanceForSelfCollapsingBlock);
1106     }
1107 
1108     if (childIsSelfCollapsing) {
1109         // For a self collapsing block both the before and after margins get discarded. The block doesn&#39;t contribute anything to the height of the block.
1110         // Also, the child&#39;s top position equals the logical height of the container.
1111         if (!childDiscardMarginBefore &amp;&amp; !marginInfo.discardMargin()) {
1112             // This child has no height. We need to compute our
1113             // position before we collapse the child&#39;s margins together,
1114             // so that we can get an accurate position for the zero-height block.
1115             LayoutUnit collapsedBeforePos = std::max(marginInfo.positiveMargin(), childMargins.positiveMarginBefore());
1116             LayoutUnit collapsedBeforeNeg = std::max(marginInfo.negativeMargin(), childMargins.negativeMarginBefore());
1117             marginInfo.setMargin(collapsedBeforePos, collapsedBeforeNeg);
1118 
1119             // Now collapse the child&#39;s margins together, which means examining our
1120             // bottom margin values as well.
1121             marginInfo.setPositiveMarginIfLarger(childMargins.positiveMarginAfter());
1122             marginInfo.setNegativeMarginIfLarger(childMargins.negativeMarginAfter());
1123 
1124             if (!marginInfo.canCollapseWithMarginBefore())
1125                 // We need to make sure that the position of the self-collapsing block
1126                 // is correct, since it could have overflowing content
1127                 // that needs to be positioned correctly (e.g., a block that
1128                 // had a specified height of 0 but that actually had subcontent).
1129                 logicalTop = logicalHeight() + collapsedBeforePos - collapsedBeforeNeg;
1130         }
1131     } else {
1132         if (child &amp;&amp; mustSeparateMarginBeforeForChild(*child)) {
1133             ASSERT(!marginInfo.discardMargin() || (marginInfo.discardMargin() &amp;&amp; !marginInfo.margin()));
1134             // If we are at the before side of the block and we collapse, ignore the computed margin
1135             // and just add the child margin to the container height. This will correctly position
1136             // the child inside the container.
1137             LayoutUnit separateMargin = !marginInfo.canCollapseWithMarginBefore() ? marginInfo.margin() : 0_lu;
1138             setLogicalHeight(logicalHeight() + separateMargin + marginBeforeForChild(*child));
1139             logicalTop = logicalHeight();
1140         } else if (!marginInfo.discardMargin() &amp;&amp; (!marginInfo.atBeforeSideOfBlock()
1141             || (!marginInfo.canCollapseMarginBeforeWithChildren()
1142             &amp;&amp; (!document().inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.hasMarginBeforeQuirk())))) {
1143             // We&#39;re collapsing with a previous sibling&#39;s margins and not
1144             // with the top of the block.
1145             setLogicalHeight(logicalHeight() + std::max(marginInfo.positiveMargin(), posTop) - std::max(marginInfo.negativeMargin(), negTop));
1146             logicalTop = logicalHeight();
1147         }
1148 
1149         marginInfo.setDiscardMargin(childDiscardMarginAfter);
1150 
1151         if (!marginInfo.discardMargin()) {
1152             marginInfo.setPositiveMargin(childMargins.positiveMarginAfter());
1153             marginInfo.setNegativeMargin(childMargins.negativeMarginAfter());
1154         } else
1155             marginInfo.clearMargin();
1156 
1157         if (marginInfo.margin())
1158             marginInfo.setHasMarginAfterQuirk(afterQuirk);
1159     }
1160 
1161     // If margins would pull us past the top of the next page, then we need to pull back and pretend like the margins
1162     // collapsed into the page edge.
1163     auto* layoutState = view().frameView().layoutContext().layoutState();
1164     if (layoutState-&gt;isPaginated() &amp;&amp; layoutState-&gt;pageLogicalHeight() &amp;&amp; logicalTop &gt; beforeCollapseLogicalTop
1165         &amp;&amp; hasNextPage(beforeCollapseLogicalTop)) {
1166         LayoutUnit oldLogicalTop = logicalTop;
1167         logicalTop = std::min(logicalTop, nextPageLogicalTop(beforeCollapseLogicalTop));
1168         setLogicalHeight(logicalHeight() + (logicalTop - oldLogicalTop));
1169     }
1170 
1171     if (is&lt;RenderBlockFlow&gt;(prevSibling) &amp;&amp; !prevSibling-&gt;isFloatingOrOutOfFlowPositioned()) {
1172         // If |child| is a self-collapsing block it may have collapsed into a previous sibling and although it hasn&#39;t reduced the height of the parent yet
1173         // any floats from the parent will now overhang.
1174         RenderBlockFlow&amp; block = downcast&lt;RenderBlockFlow&gt;(*prevSibling);
1175         LayoutUnit oldLogicalHeight = logicalHeight();
1176         setLogicalHeight(logicalTop);
1177         if (block.containsFloats() &amp;&amp; !block.avoidsFloats() &amp;&amp; (block.logicalTop() + block.lowestFloatLogicalBottom()) &gt; logicalTop)
1178             addOverhangingFloats(block, false);
1179         setLogicalHeight(oldLogicalHeight);
1180 
1181         // If |child|&#39;s previous sibling is a self-collapsing block that cleared a float and margin collapsing resulted in |child| moving up
1182         // into the margin area of the self-collapsing block then the float it clears is now intruding into |child|. Layout again so that we can look for
1183         // floats in the parent that overhang |child|&#39;s new logical top.
1184         bool logicalTopIntrudesIntoFloat = clearanceForSelfCollapsingBlock &gt; 0 &amp;&amp; logicalTop &lt; beforeCollapseLogicalTop;
1185         if (child &amp;&amp; logicalTopIntrudesIntoFloat &amp;&amp; containsFloats() &amp;&amp; !child-&gt;avoidsFloats() &amp;&amp; lowestFloatLogicalBottom() &gt; logicalTop)
1186             child-&gt;setNeedsLayout();
1187     }
1188 
1189     return logicalTop;
1190 }
1191 
1192 LayoutUnit RenderBlockFlow::clearFloatsIfNeeded(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit oldTopPosMargin, LayoutUnit oldTopNegMargin, LayoutUnit yPos)
1193 {
1194     LayoutUnit heightIncrease = getClearDelta(child, yPos);
1195     if (!heightIncrease)
1196         return yPos;
1197 
1198     if (child.isSelfCollapsingBlock()) {
1199         bool childDiscardMargin = mustDiscardMarginBeforeForChild(child) || mustDiscardMarginAfterForChild(child);
1200 
1201         // For self-collapsing blocks that clear, they can still collapse their
1202         // margins with following siblings. Reset the current margins to represent
1203         // the self-collapsing block&#39;s margins only.
1204         // If DISCARD is specified for -webkit-margin-collapse, reset the margin values.
1205         MarginValues childMargins = marginValuesForChild(child);
1206         if (!childDiscardMargin) {
1207             marginInfo.setPositiveMargin(std::max(childMargins.positiveMarginBefore(), childMargins.positiveMarginAfter()));
1208             marginInfo.setNegativeMargin(std::max(childMargins.negativeMarginBefore(), childMargins.negativeMarginAfter()));
1209         } else
1210             marginInfo.clearMargin();
1211         marginInfo.setDiscardMargin(childDiscardMargin);
1212 
1213         // CSS2.1 states:
1214         // &quot;If the top and bottom margins of an element with clearance are adjoining, its margins collapse with
1215         // the adjoining margins of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.&quot;
1216         // So the parent&#39;s bottom margin cannot collapse through this block or any subsequent self-collapsing blocks. Check subsequent siblings
1217         // for a block with height - if none is found then don&#39;t allow the margins to collapse with the parent.
1218         bool wouldCollapseMarginsWithParent = marginInfo.canCollapseMarginAfterWithChildren();
1219         for (RenderBox* curr = child.nextSiblingBox(); curr &amp;&amp; wouldCollapseMarginsWithParent; curr = curr-&gt;nextSiblingBox()) {
1220             if (!curr-&gt;isFloatingOrOutOfFlowPositioned() &amp;&amp; !curr-&gt;isSelfCollapsingBlock())
1221                 wouldCollapseMarginsWithParent = false;
1222         }
1223         if (wouldCollapseMarginsWithParent)
1224             marginInfo.setCanCollapseMarginAfterWithChildren(false);
1225 
1226         // For now set the border-top of |child| flush with the bottom border-edge of the float so it can layout any floating or positioned children of
1227         // its own at the correct vertical position. If subsequent siblings attempt to collapse with |child|&#39;s margins in |collapseMargins| we will
1228         // adjust the height of the parent to |child|&#39;s margin top (which if it is positive sits up &#39;inside&#39; the float it&#39;s clearing) so that all three
1229         // margins can collapse at the correct vertical position.
1230         // Per CSS2.1 we need to ensure that any negative margin-top clears |child| beyond the bottom border-edge of the float so that the top border edge of the child
1231         // (i.e. its clearance)  is at a position that satisfies the equation: &quot;the amount of clearance is set so that clearance + margin-top = [height of float],
1232         // i.e., clearance = [height of float] - margin-top&quot;.
1233         setLogicalHeight(child.logicalTop() + childMargins.negativeMarginBefore());
1234     } else
1235         // Increase our height by the amount we had to clear.
1236         setLogicalHeight(logicalHeight() + heightIncrease);
1237 
1238     if (marginInfo.canCollapseWithMarginBefore()) {
1239         // We can no longer collapse with the top of the block since a clear
1240         // occurred. The empty blocks collapse into the cleared block.
1241         // FIXME: This isn&#39;t quite correct. Need clarification for what to do
1242         // if the height the cleared block is offset by is smaller than the
1243         // margins involved.
1244         setMaxMarginBeforeValues(oldTopPosMargin, oldTopNegMargin);
1245         marginInfo.setAtBeforeSideOfBlock(false);
1246 
1247         // In case the child discarded the before margin of the block we need to reset the mustDiscardMarginBefore flag to the initial value.
1248         setMustDiscardMarginBefore(style().marginBeforeCollapse() == MarginCollapse::Discard);
1249     }
1250 
1251     return yPos + heightIncrease;
1252 }
1253 
1254 void RenderBlockFlow::marginBeforeEstimateForChild(RenderBox&amp; child, LayoutUnit&amp; positiveMarginBefore, LayoutUnit&amp; negativeMarginBefore, bool&amp; discardMarginBefore) const
1255 {
1256     // Give up if in quirks mode and we&#39;re a body/table cell and the top margin of the child box is quirky.
1257     // Give up if the child specified -webkit-margin-collapse: separate that prevents collapsing.
1258     // FIXME: Use writing mode independent accessor for marginBeforeCollapse.
1259     if ((document().inQuirksMode() &amp;&amp; hasMarginAfterQuirk(child) &amp;&amp; (isTableCell() || isBody())) || child.style().marginBeforeCollapse() == MarginCollapse::Separate)
1260         return;
1261 
1262     // The margins are discarded by a child that specified -webkit-margin-collapse: discard.
1263     // FIXME: Use writing mode independent accessor for marginBeforeCollapse.
1264     if (child.style().marginBeforeCollapse() == MarginCollapse::Discard) {
1265         positiveMarginBefore = 0;
1266         negativeMarginBefore = 0;
1267         discardMarginBefore = true;
1268         return;
1269     }
1270 
1271     LayoutUnit beforeChildMargin = marginBeforeForChild(child);
1272     positiveMarginBefore = std::max(positiveMarginBefore, beforeChildMargin);
1273     negativeMarginBefore = std::max(negativeMarginBefore, -beforeChildMargin);
1274 
1275     if (!is&lt;RenderBlockFlow&gt;(child))
1276         return;
1277 
1278     RenderBlockFlow&amp; childBlock = downcast&lt;RenderBlockFlow&gt;(child);
1279     if (childBlock.childrenInline() || childBlock.isWritingModeRoot())
1280         return;
1281 
1282     MarginInfo childMarginInfo(childBlock, childBlock.borderAndPaddingBefore(), childBlock.borderAndPaddingAfter());
1283     if (!childMarginInfo.canCollapseMarginBeforeWithChildren())
1284         return;
1285 
1286     RenderBox* grandchildBox = childBlock.firstChildBox();
1287     for (; grandchildBox; grandchildBox = grandchildBox-&gt;nextSiblingBox()) {
1288         if (!grandchildBox-&gt;isFloatingOrOutOfFlowPositioned())
1289             break;
1290     }
1291 
1292     // Give up if there is clearance on the box, since it probably won&#39;t collapse into us.
1293     if (!grandchildBox || grandchildBox-&gt;style().clear() != Clear::None)
1294         return;
1295 
1296     // Make sure to update the block margins now for the grandchild box so that we&#39;re looking at current values.
1297     if (grandchildBox-&gt;needsLayout()) {
1298         grandchildBox-&gt;computeAndSetBlockDirectionMargins(*this);
1299         if (is&lt;RenderBlock&gt;(*grandchildBox)) {
1300             RenderBlock&amp; grandchildBlock = downcast&lt;RenderBlock&gt;(*grandchildBox);
1301             grandchildBlock.setHasMarginBeforeQuirk(grandchildBox-&gt;style().hasMarginBeforeQuirk());
1302             grandchildBlock.setHasMarginAfterQuirk(grandchildBox-&gt;style().hasMarginAfterQuirk());
1303         }
1304     }
1305 
1306     // Collapse the margin of the grandchild box with our own to produce an estimate.
1307     childBlock.marginBeforeEstimateForChild(*grandchildBox, positiveMarginBefore, negativeMarginBefore, discardMarginBefore);
1308 }
1309 
1310 LayoutUnit RenderBlockFlow::estimateLogicalTopPosition(RenderBox&amp; child, const MarginInfo&amp; marginInfo, LayoutUnit&amp; estimateWithoutPagination)
1311 {
1312     // FIXME: We need to eliminate the estimation of vertical position, because when it&#39;s wrong we sometimes trigger a pathological
1313     // relayout if there are intruding floats.
1314     LayoutUnit logicalTopEstimate = logicalHeight();
1315     if (!marginInfo.canCollapseWithMarginBefore()) {
1316         LayoutUnit positiveMarginBefore;
1317         LayoutUnit negativeMarginBefore;
1318         bool discardMarginBefore = false;
1319         if (child.selfNeedsLayout()) {
1320             // Try to do a basic estimation of how the collapse is going to go.
1321             marginBeforeEstimateForChild(child, positiveMarginBefore, negativeMarginBefore, discardMarginBefore);
1322         } else {
1323             // Use the cached collapsed margin values from a previous layout. Most of the time they
1324             // will be right.
1325             MarginValues marginValues = marginValuesForChild(child);
1326             positiveMarginBefore = std::max(positiveMarginBefore, marginValues.positiveMarginBefore());
1327             negativeMarginBefore = std::max(negativeMarginBefore, marginValues.negativeMarginBefore());
1328             discardMarginBefore = mustDiscardMarginBeforeForChild(child);
1329         }
1330 
1331         // Collapse the result with our current margins.
1332         if (!discardMarginBefore)
1333             logicalTopEstimate += std::max(marginInfo.positiveMargin(), positiveMarginBefore) - std::max(marginInfo.negativeMargin(), negativeMarginBefore);
1334     }
1335 
1336     // Adjust logicalTopEstimate down to the next page if the margins are so large that we don&#39;t fit on the current
1337     // page.
1338     auto* layoutState = view().frameView().layoutContext().layoutState();
1339     if (layoutState-&gt;isPaginated() &amp;&amp; layoutState-&gt;pageLogicalHeight() &amp;&amp; logicalTopEstimate &gt; logicalHeight()
1340         &amp;&amp; hasNextPage(logicalHeight()))
1341         logicalTopEstimate = std::min(logicalTopEstimate, nextPageLogicalTop(logicalHeight()));
1342 
1343     logicalTopEstimate += getClearDelta(child, logicalTopEstimate);
1344 
1345     estimateWithoutPagination = logicalTopEstimate;
1346 
1347     if (layoutState-&gt;isPaginated()) {
1348         // If the object has a page or column break value of &quot;before&quot;, then we should shift to the top of the next page.
1349         logicalTopEstimate = applyBeforeBreak(child, logicalTopEstimate);
1350 
1351         // For replaced elements and scrolled elements, we want to shift them to the next page if they don&#39;t fit on the current one.
1352         logicalTopEstimate = adjustForUnsplittableChild(child, logicalTopEstimate);
1353 
1354         if (!child.selfNeedsLayout() &amp;&amp; is&lt;RenderBlock&gt;(child))
1355             logicalTopEstimate += downcast&lt;RenderBlock&gt;(child).paginationStrut();
1356     }
1357 
1358     return logicalTopEstimate;
1359 }
1360 
1361 void RenderBlockFlow::setCollapsedBottomMargin(const MarginInfo&amp; marginInfo)
1362 {
1363     if (marginInfo.canCollapseWithMarginAfter() &amp;&amp; !marginInfo.canCollapseWithMarginBefore()) {
1364         // Update the after side margin of the container to discard if the after margin of the last child also discards and we collapse with it.
1365         // Don&#39;t update the max margin values because we won&#39;t need them anyway.
1366         if (marginInfo.discardMargin()) {
1367             setMustDiscardMarginAfter();
1368             return;
1369         }
1370 
1371         // Update our max pos/neg bottom margins, since we collapsed our bottom margins
1372         // with our children.
1373         setMaxMarginAfterValues(std::max(maxPositiveMarginAfter(), marginInfo.positiveMargin()), std::max(maxNegativeMarginAfter(), marginInfo.negativeMargin()));
1374 
1375         if (!marginInfo.hasMarginAfterQuirk())
1376             setHasMarginAfterQuirk(false);
1377 
1378         if (marginInfo.hasMarginAfterQuirk() &amp;&amp; !marginAfter())
1379             // We have no bottom margin and our last child has a quirky margin.
1380             // We will pick up this quirky margin and pass it through.
1381             // This deals with the &lt;td&gt;&lt;div&gt;&lt;p&gt; case.
1382             setHasMarginAfterQuirk(true);
1383     }
1384 }
1385 
1386 void RenderBlockFlow::handleAfterSideOfBlock(LayoutUnit beforeSide, LayoutUnit afterSide, MarginInfo&amp; marginInfo)
1387 {
1388     marginInfo.setAtAfterSideOfBlock(true);
1389 
1390     // If our last child was a self-collapsing block with clearance then our logical height is flush with the
1391     // bottom edge of the float that the child clears. The correct vertical position for the margin-collapsing we want
1392     // to perform now is at the child&#39;s margin-top - so adjust our height to that position.
1393     RenderObject* lastBlock = lastChild();
1394     if (is&lt;RenderBlockFlow&gt;(lastBlock) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*lastBlock).isSelfCollapsingBlock())
1395         setLogicalHeight(logicalHeight() - downcast&lt;RenderBlockFlow&gt;(*lastBlock).marginOffsetForSelfCollapsingBlock());
1396 
1397     // If we can&#39;t collapse with children then add in the bottom margin.
1398     if (!marginInfo.discardMargin() &amp;&amp; (!marginInfo.canCollapseWithMarginAfter() &amp;&amp; !marginInfo.canCollapseWithMarginBefore()
1399         &amp;&amp; (!document().inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.hasMarginAfterQuirk())))
1400         setLogicalHeight(logicalHeight() + marginInfo.margin());
1401 
1402     // Now add in our bottom border/padding.
1403     setLogicalHeight(logicalHeight() + afterSide);
1404 
1405     // Negative margins can cause our height to shrink below our minimal height (border/padding).
1406     // If this happens, ensure that the computed height is increased to the minimal height.
1407     setLogicalHeight(std::max(logicalHeight(), beforeSide + afterSide));
1408 
1409     // Update our bottom collapsed margin info.
1410     setCollapsedBottomMargin(marginInfo);
1411 }
1412 
1413 void RenderBlockFlow::setMaxMarginBeforeValues(LayoutUnit pos, LayoutUnit neg)
1414 {
1415     if (!hasRareBlockFlowData()) {
1416         if (pos == RenderBlockFlowRareData::positiveMarginBeforeDefault(*this) &amp;&amp; neg == RenderBlockFlowRareData::negativeMarginBeforeDefault(*this))
1417             return;
1418         materializeRareBlockFlowData();
1419     }
1420 
1421     rareBlockFlowData()-&gt;m_margins.setPositiveMarginBefore(pos);
1422     rareBlockFlowData()-&gt;m_margins.setNegativeMarginBefore(neg);
1423 }
1424 
1425 void RenderBlockFlow::setMaxMarginAfterValues(LayoutUnit pos, LayoutUnit neg)
1426 {
1427     if (!hasRareBlockFlowData()) {
1428         if (pos == RenderBlockFlowRareData::positiveMarginAfterDefault(*this) &amp;&amp; neg == RenderBlockFlowRareData::negativeMarginAfterDefault(*this))
1429             return;
1430         materializeRareBlockFlowData();
1431     }
1432 
1433     rareBlockFlowData()-&gt;m_margins.setPositiveMarginAfter(pos);
1434     rareBlockFlowData()-&gt;m_margins.setNegativeMarginAfter(neg);
1435 }
1436 
1437 void RenderBlockFlow::setMustDiscardMarginBefore(bool value)
1438 {
1439     if (style().marginBeforeCollapse() == MarginCollapse::Discard) {
1440         ASSERT(value);
1441         return;
1442     }
1443 
1444     if (!hasRareBlockFlowData()) {
1445         if (!value)
1446             return;
1447         materializeRareBlockFlowData();
1448     }
1449 
1450     rareBlockFlowData()-&gt;m_discardMarginBefore = value;
1451 }
1452 
1453 void RenderBlockFlow::setMustDiscardMarginAfter(bool value)
1454 {
1455     if (style().marginAfterCollapse() == MarginCollapse::Discard) {
1456         ASSERT(value);
1457         return;
1458     }
1459 
1460     if (!hasRareBlockFlowData()) {
1461         if (!value)
1462             return;
1463         materializeRareBlockFlowData();
1464     }
1465 
1466     rareBlockFlowData()-&gt;m_discardMarginAfter = value;
1467 }
1468 
1469 bool RenderBlockFlow::mustDiscardMarginBefore() const
1470 {
1471     return style().marginBeforeCollapse() == MarginCollapse::Discard || (hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_discardMarginBefore);
1472 }
1473 
1474 bool RenderBlockFlow::mustDiscardMarginAfter() const
1475 {
1476     return style().marginAfterCollapse() == MarginCollapse::Discard || (hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_discardMarginAfter);
1477 }
1478 
1479 bool RenderBlockFlow::mustDiscardMarginBeforeForChild(const RenderBox&amp; child) const
1480 {
1481     ASSERT(!child.selfNeedsLayout());
1482     if (!child.isWritingModeRoot())
1483         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginBefore() : (child.style().marginBeforeCollapse() == MarginCollapse::Discard);
1484     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1485         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginAfter() : (child.style().marginAfterCollapse() == MarginCollapse::Discard);
1486 
1487     // FIXME: We return false here because the implementation is not geometrically complete. We have values only for before/after, not start/end.
1488     // In case the boxes are perpendicular we assume the property is not specified.
1489     return false;
1490 }
1491 
1492 bool RenderBlockFlow::mustDiscardMarginAfterForChild(const RenderBox&amp; child) const
1493 {
1494     ASSERT(!child.selfNeedsLayout());
1495     if (!child.isWritingModeRoot())
1496         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginAfter() : (child.style().marginAfterCollapse() == MarginCollapse::Discard);
1497     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1498         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginBefore() : (child.style().marginBeforeCollapse() == MarginCollapse::Discard);
1499 
1500     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1501     return false;
1502 }
1503 
1504 bool RenderBlockFlow::mustSeparateMarginBeforeForChild(const RenderBox&amp; child) const
1505 {
1506     ASSERT(!child.selfNeedsLayout());
1507     const RenderStyle&amp; childStyle = child.style();
1508     if (!child.isWritingModeRoot())
1509         return childStyle.marginBeforeCollapse() == MarginCollapse::Separate;
1510     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1511         return childStyle.marginAfterCollapse() == MarginCollapse::Separate;
1512 
1513     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1514     return false;
1515 }
1516 
1517 bool RenderBlockFlow::mustSeparateMarginAfterForChild(const RenderBox&amp; child) const
1518 {
1519     ASSERT(!child.selfNeedsLayout());
1520     const RenderStyle&amp; childStyle = child.style();
1521     if (!child.isWritingModeRoot())
1522         return childStyle.marginAfterCollapse() == MarginCollapse::Separate;
1523     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1524         return childStyle.marginBeforeCollapse() == MarginCollapse::Separate;
1525 
1526     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1527     return false;
1528 }
1529 
1530 static bool inNormalFlow(RenderBox&amp; child)
1531 {
1532     RenderBlock* curr = child.containingBlock();
1533     while (curr &amp;&amp; curr != &amp;child.view()) {
1534         if (curr-&gt;isRenderFragmentedFlow())
1535             return true;
1536         if (curr-&gt;isFloatingOrOutOfFlowPositioned())
1537             return false;
1538         curr = curr-&gt;containingBlock();
1539     }
1540     return true;
1541 }
1542 
1543 LayoutUnit RenderBlockFlow::applyBeforeBreak(RenderBox&amp; child, LayoutUnit logicalOffset)
1544 {
1545     // FIXME: Add page break checking here when we support printing.
1546     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1547     bool isInsideMulticolFlow = fragmentedFlow;
1548     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
1549     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight(); // FIXME: Once columns can print we have to check this.
1550     bool checkFragmentBreaks = false;
1551     bool checkBeforeAlways = (checkColumnBreaks &amp;&amp; child.style().breakBefore() == BreakBetween::Column)
1552         || (checkPageBreaks &amp;&amp; alwaysPageBreak(child.style().breakBefore()));
1553     if (checkBeforeAlways &amp;&amp; inNormalFlow(child) &amp;&amp; hasNextPage(logicalOffset, IncludePageBoundary)) {
1554         if (checkColumnBreaks) {
1555             if (isInsideMulticolFlow)
1556                 checkFragmentBreaks = true;
1557         }
1558         if (checkFragmentBreaks) {
1559             LayoutUnit offsetBreakAdjustment;
1560             if (fragmentedFlow-&gt;addForcedFragmentBreak(this, offsetFromLogicalTopOfFirstPage() + logicalOffset, &amp;child, true, &amp;offsetBreakAdjustment))
1561                 return logicalOffset + offsetBreakAdjustment;
1562         }
1563         return nextPageLogicalTop(logicalOffset, IncludePageBoundary);
1564     }
1565     return logicalOffset;
1566 }
1567 
1568 LayoutUnit RenderBlockFlow::applyAfterBreak(RenderBox&amp; child, LayoutUnit logicalOffset, MarginInfo&amp; marginInfo)
1569 {
1570     // FIXME: Add page break checking here when we support printing.
1571     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1572     bool isInsideMulticolFlow = fragmentedFlow;
1573     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
1574     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight(); // FIXME: Once columns can print we have to check this.
1575     bool checkFragmentBreaks = false;
1576     bool checkAfterAlways = (checkColumnBreaks &amp;&amp; child.style().breakAfter() == BreakBetween::Column)
1577         || (checkPageBreaks &amp;&amp; alwaysPageBreak(child.style().breakAfter()));
1578     if (checkAfterAlways &amp;&amp; inNormalFlow(child) &amp;&amp; hasNextPage(logicalOffset, IncludePageBoundary)) {
1579         LayoutUnit marginOffset = marginInfo.canCollapseWithMarginBefore() ? 0_lu : marginInfo.margin();
1580 
1581         // So our margin doesn&#39;t participate in the next collapsing steps.
1582         marginInfo.clearMargin();
1583 
1584         if (checkColumnBreaks) {
1585             if (isInsideMulticolFlow)
1586                 checkFragmentBreaks = true;
1587         }
1588         if (checkFragmentBreaks) {
1589             LayoutUnit offsetBreakAdjustment;
1590             if (fragmentedFlow-&gt;addForcedFragmentBreak(this, offsetFromLogicalTopOfFirstPage() + logicalOffset + marginOffset, &amp;child, false, &amp;offsetBreakAdjustment))
1591                 return logicalOffset + marginOffset + offsetBreakAdjustment;
1592         }
1593         return nextPageLogicalTop(logicalOffset, IncludePageBoundary);
1594     }
1595     return logicalOffset;
1596 }
1597 
1598 LayoutUnit RenderBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTopAfterClear, LayoutUnit estimateWithoutPagination, RenderBox&amp; child, bool atBeforeSideOfBlock)
1599 {
1600     RenderBlock* childRenderBlock = is&lt;RenderBlock&gt;(child) ? &amp;downcast&lt;RenderBlock&gt;(child) : nullptr;
1601 
1602     if (estimateWithoutPagination != logicalTopAfterClear) {
1603         // Our guess prior to pagination movement was wrong. Before we attempt to paginate, let&#39;s try again at the new
1604         // position.
1605         setLogicalHeight(logicalTopAfterClear);
1606         setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
1607 
1608         if (child.shrinkToAvoidFloats()) {
1609             // The child&#39;s width depends on the line width. When the child shifts to clear an item, its width can
1610             // change (because it has more available line width). So mark the item as dirty.
1611             child.setChildNeedsLayout(MarkOnlyThis);
1612         }
1613 
1614         if (childRenderBlock) {
1615             if (!child.avoidsFloats() &amp;&amp; childRenderBlock-&gt;containsFloats())
1616                 downcast&lt;RenderBlockFlow&gt;(*childRenderBlock).markAllDescendantsWithFloatsForLayout();
1617             child.markForPaginationRelayoutIfNeeded();
1618         }
1619 
1620         // Our guess was wrong. Make the child lay itself out again.
1621         child.layoutIfNeeded();
1622     }
1623 
1624     LayoutUnit oldTop = logicalTopAfterClear;
1625 
1626     // If the object has a page or column break value of &quot;before&quot;, then we should shift to the top of the next page.
1627     LayoutUnit result = applyBeforeBreak(child, logicalTopAfterClear);
1628 
1629     if (pageLogicalHeightForOffset(result)) {
1630         LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(result, ExcludePageBoundary);
1631         LayoutUnit spaceShortage = child.logicalHeight() - remainingLogicalHeight;
1632         if (spaceShortage &gt; 0) {
1633             // If the child crosses a column boundary, report a break, in case nothing inside it has already
1634             // done so. The column balancer needs to know how much it has to stretch the columns to make more
1635             // content fit. If no breaks are reported (but do occur), the balancer will have no clue. FIXME:
1636             // This should be improved, though, because here we just pretend that the child is
1637             // unsplittable. A splittable child, on the other hand, has break opportunities at every position
1638             // where there&#39;s no child content, border or padding. In other words, we risk stretching more
1639             // than necessary.
1640             setPageBreak(result, spaceShortage);
1641         }
1642     }
1643 
1644     // For replaced elements and scrolled elements, we want to shift them to the next page if they don&#39;t fit on the current one.
1645     LayoutUnit logicalTopBeforeUnsplittableAdjustment = result;
1646     LayoutUnit logicalTopAfterUnsplittableAdjustment = adjustForUnsplittableChild(child, result);
1647 
1648     LayoutUnit paginationStrut;
1649     LayoutUnit unsplittableAdjustmentDelta = logicalTopAfterUnsplittableAdjustment - logicalTopBeforeUnsplittableAdjustment;
1650     if (unsplittableAdjustmentDelta)
1651         paginationStrut = unsplittableAdjustmentDelta;
1652     else if (childRenderBlock &amp;&amp; childRenderBlock-&gt;paginationStrut())
1653         paginationStrut = childRenderBlock-&gt;paginationStrut();
1654 
1655     if (paginationStrut) {
1656         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
1657         // to collapsing our margins, and as long as we didn&#39;t clear or move as a result of other pagination.
1658         if (atBeforeSideOfBlock &amp;&amp; oldTop == result &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1659             // FIXME: Should really check if we&#39;re exceeding the page height before propagating the strut, but we don&#39;t
1660             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
1661             // and pushes to the next page anyway, so not too concerned about it.
1662             setPaginationStrut(result + paginationStrut);
1663             if (childRenderBlock)
1664                 childRenderBlock-&gt;setPaginationStrut(0);
1665         } else
1666             result += paginationStrut;
1667     }
1668 
1669     // Similar to how we apply clearance. Boost height() to be the place where we&#39;re going to position the child.
1670     setLogicalHeight(logicalHeight() + (result - oldTop));
1671 
1672     // Return the final adjusted logical top.
1673     return result;
1674 }
1675 
1676 static inline LayoutUnit calculateMinimumPageHeight(const RenderStyle&amp; renderStyle, RootInlineBox&amp; lastLine, LayoutUnit lineTop, LayoutUnit lineBottom)
1677 {
1678     // We may require a certain minimum number of lines per page in order to satisfy
1679     // orphans and widows, and that may affect the minimum page height.
1680     unsigned lineCount = std::max&lt;unsigned&gt;(renderStyle.hasAutoOrphans() ? 1 : renderStyle.orphans(), renderStyle.hasAutoWidows() ? 1 : renderStyle.widows());
1681     if (lineCount &gt; 1) {
1682         RootInlineBox* line = &amp;lastLine;
1683         for (unsigned i = 1; i &lt; lineCount &amp;&amp; line-&gt;prevRootBox(); i++)
1684             line = line-&gt;prevRootBox();
1685 
1686         // FIXME: Paginating using line overflow isn&#39;t all fine. See FIXME in
1687         // adjustLinePositionForPagination() for more details.
1688         LayoutRect overflow = line-&gt;logicalVisualOverflowRect(line-&gt;lineTop(), line-&gt;lineBottom());
1689         lineTop = std::min(line-&gt;lineTopWithLeading(), overflow.y());
1690     }
1691     return lineBottom - lineTop;
1692 }
1693 
1694 static inline bool needsAppleMailPaginationQuirk(RootInlineBox&amp; lineBox)
1695 {
1696     auto&amp; renderer = lineBox.renderer();
1697 
1698     if (!renderer.settings().appleMailPaginationQuirkEnabled())
1699         return false;
1700 
1701     if (renderer.element() &amp;&amp; renderer.element()-&gt;idForStyleResolution() == &quot;messageContentContainer&quot;)
1702         return true;
1703 
1704     return false;
1705 }
1706 
1707 static void clearShouldBreakAtLineToAvoidWidowIfNeeded(RenderBlockFlow&amp; blockFlow)
1708 {
1709     if (!blockFlow.shouldBreakAtLineToAvoidWidow())
1710         return;
1711     blockFlow.clearShouldBreakAtLineToAvoidWidow();
1712     blockFlow.setDidBreakAtLineToAvoidWidow();
1713 }
1714 
1715 void RenderBlockFlow::adjustLinePositionForPagination(RootInlineBox* lineBox, LayoutUnit&amp; delta, bool&amp; overflowsFragment, RenderFragmentedFlow* fragmentedFlow)
1716 {
1717     // FIXME: For now we paginate using line overflow. This ensures that lines don&#39;t overlap at all when we
1718     // put a strut between them for pagination purposes. However, this really isn&#39;t the desired rendering, since
1719     // the line on the top of the next page will appear too far down relative to the same kind of line at the top
1720     // of the first column.
1721     //
1722     // The rendering we would like to see is one where the lineTopWithLeading is at the top of the column, and any line overflow
1723     // simply spills out above the top of the column. This effect would match what happens at the top of the first column.
1724     // We can&#39;t achieve this rendering, however, until we stop columns from clipping to the column bounds (thus allowing
1725     // for overflow to occur), and then cache visible overflow for each column rect.
1726     //
1727     // Furthermore, the paint we have to do when a column has overflow has to be special. We need to exclude
1728     // content that paints in a previous column (and content that paints in the following column).
1729     //
1730     // For now we&#39;ll at least honor the lineTopWithLeading when paginating if it is above the logical top overflow. This will
1731     // at least make positive leading work in typical cases.
1732     //
1733     // FIXME: Another problem with simply moving lines is that the available line width may change (because of floats).
1734     // Technically if the location we move the line to has a different line width than our old position, then we need to dirty the
1735     // line and all following lines.
1736     overflowsFragment = false;
1737     LayoutRect logicalVisualOverflow = lineBox-&gt;logicalVisualOverflowRect(lineBox-&gt;lineTop(), lineBox-&gt;lineBottom());
1738     LayoutUnit logicalOffset = std::min(lineBox-&gt;lineTopWithLeading(), logicalVisualOverflow.y());
1739     LayoutUnit logicalBottom = std::max(lineBox-&gt;lineBottomWithLeading(), logicalVisualOverflow.maxY());
1740     LayoutUnit lineHeight = logicalBottom - logicalOffset;
1741     updateMinimumPageHeight(logicalOffset, calculateMinimumPageHeight(style(), *lineBox, logicalOffset, logicalBottom));
1742     logicalOffset += delta;
1743     lineBox-&gt;setPaginationStrut(0);
1744     lineBox-&gt;setIsFirstAfterPageBreak(false);
1745     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1746     bool hasUniformPageLogicalHeight = !fragmentedFlow || fragmentedFlow-&gt;fragmentsHaveUniformLogicalHeight();
1747     // If lineHeight is greater than pageLogicalHeight, but logicalVisualOverflow.height() still fits, we are
1748     // still going to add a strut, so that the visible overflow fits on a single page.
1749     if (!pageLogicalHeight || !hasNextPage(logicalOffset)) {
1750         // FIXME: In case the line aligns with the top of the page (or it&#39;s slightly shifted downwards) it will not be marked as the first line in the page.
1751         // From here, the fix is not straightforward because it&#39;s not easy to always determine when the current line is the first in the page.
1752         return;
1753     }
1754 
1755     if (hasUniformPageLogicalHeight &amp;&amp; logicalVisualOverflow.height() &gt; pageLogicalHeight) {
1756         // We are so tall that we are bigger than a page. Before we give up and just leave the line where it is, try drilling into the
1757         // line and computing a new height that excludes anything we consider &quot;blank space&quot;. We will discard margins, descent, and even overflow. If we are
1758         // able to fit with the blank space and overflow excluded, we will give the line its own page with the highest non-blank element being aligned with the
1759         // top of the page.
1760         // FIXME: We are still honoring gigantic margins, which does leave open the possibility of blank pages caused by this heuristic. It remains to be seen whether or not
1761         // this will be a real-world issue. For now we don&#39;t try to deal with this problem.
1762         logicalOffset = intMaxForLayoutUnit;
1763         logicalBottom = intMinForLayoutUnit;
1764         lineBox-&gt;computeReplacedAndTextLineTopAndBottom(logicalOffset, logicalBottom);
1765         lineHeight = logicalBottom - logicalOffset;
1766         if (logicalOffset == intMaxForLayoutUnit || lineHeight &gt; pageLogicalHeight) {
1767             // Give up. We&#39;re genuinely too big even after excluding blank space and overflow.
1768             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1769             return;
1770         }
1771         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1772     }
1773 
1774     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1775     overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
1776 
1777     int lineIndex = lineCount(lineBox);
1778     if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
1779         if (lineBreakToAvoidWidow() == lineIndex)
1780             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1781         // If we have a non-uniform page height, then we have to shift further possibly.
1782         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
1783             return;
1784         if (lineHeight &gt; pageLogicalHeight) {
1785             // Split the top margin in order to avoid splitting the visible part of the line.
1786             remainingLogicalHeight -= std::min(lineHeight - pageLogicalHeight, std::max&lt;LayoutUnit&gt;(0, logicalVisualOverflow.y() - lineBox-&gt;lineTopWithLeading()));
1787         }
1788         LayoutUnit remainingLogicalHeightAtNewOffset = pageRemainingLogicalHeightForOffset(logicalOffset + remainingLogicalHeight, ExcludePageBoundary);
1789         overflowsFragment = (lineHeight &gt; remainingLogicalHeightAtNewOffset);
1790         LayoutUnit totalLogicalHeight = lineHeight + std::max&lt;LayoutUnit&gt;(0, logicalOffset);
1791         LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
1792         setPageBreak(logicalOffset, lineHeight - remainingLogicalHeight);
1793         if (((lineBox == firstRootBox() &amp;&amp; totalLogicalHeight &lt; pageLogicalHeightAtNewOffset) || (!style().hasAutoOrphans() &amp;&amp; style().orphans() &gt;= lineIndex))
1794             &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1795             auto firstRootBox = this-&gt;firstRootBox();
1796             auto firstRootBoxOverflowRect = firstRootBox-&gt;logicalVisualOverflowRect(firstRootBox-&gt;lineTop(), firstRootBox-&gt;lineBottom());
1797             auto firstLineUpperOverhang = std::max(-firstRootBoxOverflowRect.y(), 0_lu);
1798             if (needsAppleMailPaginationQuirk(*lineBox))
1799                 return;
1800             setPaginationStrut(remainingLogicalHeight + logicalOffset + firstLineUpperOverhang);
1801         } else {
1802             delta += remainingLogicalHeight;
1803             lineBox-&gt;setPaginationStrut(remainingLogicalHeight);
1804             lineBox-&gt;setIsFirstAfterPageBreak(true);
1805         }
1806     } else if (remainingLogicalHeight == pageLogicalHeight) {
1807         // We&#39;re at the very top of a page or column.
1808         if (lineBox != firstRootBox())
1809             lineBox-&gt;setIsFirstAfterPageBreak(true);
1810         if (lineBox != firstRootBox() || offsetFromLogicalTopOfFirstPage())
1811             setPageBreak(logicalOffset, lineHeight);
1812     }
1813 }
1814 
1815 void RenderBlockFlow::setBreakAtLineToAvoidWidow(int lineToBreak)
1816 {
1817     ASSERT(lineToBreak &gt;= 0);
1818     ASSERT(!ensureRareBlockFlowData().m_didBreakAtLineToAvoidWidow);
1819     ensureRareBlockFlowData().m_lineBreakToAvoidWidow = lineToBreak;
1820 }
1821 
1822 void RenderBlockFlow::setDidBreakAtLineToAvoidWidow()
1823 {
1824     ASSERT(!shouldBreakAtLineToAvoidWidow());
1825     if (!hasRareBlockFlowData())
1826         return;
1827 
1828     rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow = true;
1829 }
1830 
1831 void RenderBlockFlow::clearDidBreakAtLineToAvoidWidow()
1832 {
1833     if (!hasRareBlockFlowData())
1834         return;
1835 
1836     rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow = false;
1837 }
1838 
1839 void RenderBlockFlow::clearShouldBreakAtLineToAvoidWidow() const
1840 {
1841     ASSERT(shouldBreakAtLineToAvoidWidow());
1842     if (!hasRareBlockFlowData())
1843         return;
1844 
1845     rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow = -1;
1846 }
1847 
1848 bool RenderBlockFlow::relayoutToAvoidWidows()
1849 {
1850     if (!shouldBreakAtLineToAvoidWidow())
1851         return false;
1852 
1853     setEverHadLayout(true);
1854     layoutBlock(false);
1855     return true;
1856 }
1857 
1858 bool RenderBlockFlow::hasNextPage(LayoutUnit logicalOffset, PageBoundaryRule pageBoundaryRule) const
1859 {
1860     ASSERT(view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated());
1861 
1862     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1863     if (!fragmentedFlow)
1864         return true; // Printing and multi-column both make new pages to accommodate content.
1865 
1866     // See if we&#39;re in the last fragment.
1867     LayoutUnit pageOffset = offsetFromLogicalTopOfFirstPage() + logicalOffset;
1868     RenderFragmentContainer* fragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, pageOffset, true);
1869     if (!fragment)
1870         return false;
1871 
1872     if (fragment-&gt;isLastFragment())
1873         return fragment-&gt;isRenderFragmentContainerSet() || (pageBoundaryRule == IncludePageBoundary &amp;&amp; pageOffset == fragment-&gt;logicalTopForFragmentedFlowContent());
1874 
1875     RenderFragmentContainer* startFragment = nullptr;
1876     RenderFragmentContainer* endFragment = nullptr;
1877     fragmentedFlow-&gt;getFragmentRangeForBox(this, startFragment, endFragment);
1878     return (endFragment &amp;&amp; fragment != endFragment);
1879 }
1880 
1881 LayoutUnit RenderBlockFlow::adjustForUnsplittableChild(RenderBox&amp; child, LayoutUnit logicalOffset, LayoutUnit childBeforeMargin, LayoutUnit childAfterMargin)
1882 {
1883     // When flexboxes are embedded inside a block flow, they don&#39;t perform any adjustments for unsplittable
1884     // children. We&#39;ll treat flexboxes themselves as unsplittable just to get them to paginate properly inside
1885     // a block flow.
1886     bool isUnsplittable = childBoxIsUnsplittableForFragmentation(child);
1887     if (!isUnsplittable &amp;&amp; !(child.isFlexibleBox() &amp;&amp; !downcast&lt;RenderFlexibleBox&gt;(child).isFlexibleBoxImpl()))
1888         return logicalOffset;
1889 
1890     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1891     LayoutUnit childLogicalHeight = logicalHeightForChild(child) + childBeforeMargin + childAfterMargin;
1892     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1893     bool hasUniformPageLogicalHeight = !fragmentedFlow || fragmentedFlow-&gt;fragmentsHaveUniformLogicalHeight();
1894     if (isUnsplittable)
1895         updateMinimumPageHeight(logicalOffset, childLogicalHeight);
1896     if (!pageLogicalHeight || (hasUniformPageLogicalHeight &amp;&amp; childLogicalHeight &gt; pageLogicalHeight)
1897         || !hasNextPage(logicalOffset))
1898         return logicalOffset;
1899     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1900     if (remainingLogicalHeight &lt; childLogicalHeight) {
1901         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, childLogicalHeight))
1902             return logicalOffset;
1903         auto result = logicalOffset + remainingLogicalHeight;
1904         bool isInitialLetter = child.isFloating() &amp;&amp; child.style().styleType() == PseudoId::FirstLetter &amp;&amp; child.style().initialLetterDrop() &gt; 0;
1905         if (isInitialLetter) {
1906             // Increase our logical height to ensure that lines all get pushed along with the letter.
1907             setLogicalHeight(logicalOffset + remainingLogicalHeight);
1908         }
1909         return result;
1910     }
1911 
1912     return logicalOffset;
1913 }
1914 
1915 bool RenderBlockFlow::pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const
1916 {
1917     bool checkFragment = false;
1918     for (LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset + adjustment); pageLogicalHeight;
1919         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset + adjustment)) {
1920         if (minimumLogicalHeight &lt;= pageLogicalHeight)
1921             return true;
1922         if (!hasNextPage(logicalOffset + adjustment))
1923             return false;
1924         adjustment += pageLogicalHeight;
1925         checkFragment = true;
1926     }
1927     return !checkFragment;
1928 }
1929 
1930 void RenderBlockFlow::setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage)
1931 {
1932     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
1933         fragmentedFlow-&gt;setPageBreak(this, offsetFromLogicalTopOfFirstPage() + offset, spaceShortage);
1934 }
1935 
1936 void RenderBlockFlow::updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight)
1937 {
1938     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
1939         fragmentedFlow-&gt;updateMinimumPageHeight(this, offsetFromLogicalTopOfFirstPage() + offset, minHeight);
1940 }
1941 
1942 LayoutUnit RenderBlockFlow::nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule pageBoundaryRule) const
1943 {
1944     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1945     if (!pageLogicalHeight)
1946         return logicalOffset;
1947 
1948     // The logicalOffset is in our coordinate space.  We can add in our pushed offset.
1949     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset);
1950     if (pageBoundaryRule == ExcludePageBoundary)
1951         return logicalOffset + (remainingLogicalHeight ? remainingLogicalHeight : pageLogicalHeight);
1952     return logicalOffset + remainingLogicalHeight;
1953 }
1954 
1955 LayoutUnit RenderBlockFlow::pageLogicalTopForOffset(LayoutUnit offset) const
1956 {
1957     // Unsplittable objects clear out the pageLogicalHeight in the layout state as a way of signaling that no
1958     // pagination should occur. Therefore we have to check this first and bail if the value has been set to 0.
1959     auto* layoutState = view().frameView().layoutContext().layoutState();
1960     LayoutUnit pageLogicalHeight = layoutState-&gt;pageLogicalHeight();
1961     if (!pageLogicalHeight)
1962         return 0;
1963 
1964     LayoutUnit firstPageLogicalTop = isHorizontalWritingMode() ? layoutState-&gt;pageOffset().height() : layoutState-&gt;pageOffset().width();
1965     LayoutUnit blockLogicalTop = isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().height() : layoutState-&gt;layoutOffset().width();
1966 
1967     LayoutUnit cumulativeOffset = offset + blockLogicalTop;
1968     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1969     if (!fragmentedFlow)
1970         return cumulativeOffset - roundToInt(cumulativeOffset - firstPageLogicalTop) % roundToInt(pageLogicalHeight);
1971     return firstPageLogicalTop + fragmentedFlow-&gt;pageLogicalTopForOffset(cumulativeOffset - firstPageLogicalTop);
1972 }
1973 
1974 LayoutUnit RenderBlockFlow::pageLogicalHeightForOffset(LayoutUnit offset) const
1975 {
1976     // Unsplittable objects clear out the pageLogicalHeight in the layout state as a way of signaling that no
1977     // pagination should occur. Therefore we have to check this first and bail if the value has been set to 0.
1978     LayoutUnit pageLogicalHeight = view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
1979     if (!pageLogicalHeight)
1980         return 0;
1981 
1982     // Now check for a flow thread.
1983     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1984     if (!fragmentedFlow)
1985         return pageLogicalHeight;
1986     return fragmentedFlow-&gt;pageLogicalHeightForOffset(offset + offsetFromLogicalTopOfFirstPage());
1987 }
1988 
1989 LayoutUnit RenderBlockFlow::pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule pageBoundaryRule) const
1990 {
1991     offset += offsetFromLogicalTopOfFirstPage();
1992 
1993     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1994     if (!fragmentedFlow) {
1995         LayoutUnit pageLogicalHeight = view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
1996         LayoutUnit remainingHeight = pageLogicalHeight - intMod(offset, pageLogicalHeight);
1997         if (pageBoundaryRule == IncludePageBoundary) {
1998             // If includeBoundaryPoint is true the line exactly on the top edge of a
1999             // column will act as being part of the previous column.
2000             remainingHeight = intMod(remainingHeight, pageLogicalHeight);
2001         }
2002         return remainingHeight;
2003     }
2004 
2005     return fragmentedFlow-&gt;pageRemainingLogicalHeightForOffset(offset, pageBoundaryRule);
2006 }
2007 
2008 LayoutUnit RenderBlockFlow::logicalHeightForChildForFragmentation(const RenderBox&amp; child) const
2009 {
2010     return logicalHeightForChild(child);
2011 }
2012 
2013 void RenderBlockFlow::layoutLineGridBox()
2014 {
2015     if (style().lineGrid() == RenderStyle::initialLineGrid()) {
2016         setLineGridBox(0);
2017         return;
2018     }
2019 
2020     setLineGridBox(0);
2021 
<a name="7" id="anc7"></a><span class="line-modified">2022     auto lineGridBox = makeUnique&lt;RootInlineBox&gt;(*this);</span>
2023     lineGridBox-&gt;setHasTextChildren(); // Needed to make the line ascent/descent actually be honored in quirks mode.
2024     lineGridBox-&gt;setConstructed();
2025     GlyphOverflowAndFallbackFontsMap textBoxDataMap;
2026     VerticalPositionCache verticalPositionCache;
2027     lineGridBox-&gt;alignBoxesInBlockDirection(logicalHeight(), textBoxDataMap, verticalPositionCache);
2028 
2029     setLineGridBox(WTFMove(lineGridBox));
2030 
2031     // FIXME: If any of the characteristics of the box change compared to the old one, then we need to do a deep dirtying
2032     // (similar to what happens when the page height changes). Ideally, though, we only do this if someone is actually snapping
2033     // to this grid.
2034 }
2035 
2036 bool RenderBlockFlow::containsFloat(RenderBox&amp; renderer) const
2037 {
2038     return m_floatingObjects &amp;&amp; m_floatingObjects-&gt;set().contains&lt;FloatingObjectHashTranslator&gt;(renderer);
2039 }
2040 
2041 void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
2042 {
2043     RenderBlock::styleDidChange(diff, oldStyle);
2044 
2045     // After our style changed, if we lose our ability to propagate floats into next sibling
2046     // blocks, then we need to find the top most parent containing that overhanging float and
2047     // then mark its descendants with floats for layout and clear all floats from its next
2048     // sibling blocks that exist in our floating objects list. See bug 56299 and 62875.
2049     bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats();
2050     if (diff == StyleDifference::Layout &amp;&amp; s_canPropagateFloatIntoSibling &amp;&amp; !canPropagateFloatIntoSibling &amp;&amp; hasOverhangingFloats()) {
2051         RenderBlockFlow* parentBlock = this;
2052         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2053 
2054         for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(*this)) {
2055             if (ancestor.isRenderView())
2056                 break;
2057             if (ancestor.hasOverhangingFloats()) {
2058                 for (auto it = floatingObjectSet.begin(), end = floatingObjectSet.end(); it != end; ++it) {
2059                     RenderBox&amp; renderer = (*it)-&gt;renderer();
2060                     if (ancestor.hasOverhangingFloat(renderer)) {
2061                         parentBlock = &amp;ancestor;
2062                         break;
2063                     }
2064                 }
2065             }
2066         }
2067 
2068         parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
2069         parentBlock-&gt;markSiblingsWithFloatsForLayout();
2070     }
2071 
2072     if (diff &gt;= StyleDifference::Repaint) {
2073         // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.
2074         if (selfNeedsLayout() || !m_simpleLineLayout || !SimpleLineLayout::canUseFor(*this))
2075             invalidateLineLayoutPath();
2076     }
2077 
2078     if (multiColumnFlow())
2079         updateStylesForColumnChildren();
2080 }
2081 
2082 void RenderBlockFlow::updateStylesForColumnChildren()
2083 {
2084     for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
2085         child-&gt;setStyle(RenderStyle::createAnonymousStyleWithDisplay(style(), DisplayType::Block));
2086 }
2087 
2088 void RenderBlockFlow::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
2089 {
2090     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
2091     s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats() : false;
2092 
2093     if (oldStyle) {
2094         auto oldPosition = oldStyle-&gt;position();
2095         auto newPosition = newStyle.position();
2096 
2097         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2098             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2099                 markAllDescendantsWithFloatsForLayout();
2100         }
2101     }
2102 
2103     RenderBlock::styleWillChange(diff, newStyle);
2104 }
2105 
2106 void RenderBlockFlow::deleteLines()
2107 {
2108     if (containsFloats())
2109         m_floatingObjects-&gt;clearLineBoxTreePointers();
2110 
2111     if (m_simpleLineLayout) {
<a name="8" id="anc8"></a><span class="line-modified">2112         ASSERT(!m_complexLineLayout);</span>
2113         m_simpleLineLayout = nullptr;
<a name="9" id="anc9"></a><span class="line-modified">2114     } else if (m_complexLineLayout)</span>
<span class="line-modified">2115         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxTree();</span>
2116 
2117     RenderBlock::deleteLines();
2118 }
2119 
2120 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2121 {
2122     // When a portion of the render tree is being detached, anonymous blocks
2123     // will be combined as their children are deleted. In this process, the
2124     // anonymous block later in the tree is merged into the one preceeding it.
2125     // It can happen that the later block (this) contains floats that the
2126     // previous block (toBlockFlow) did not contain, and thus are not in the
2127     // floating objects list for toBlockFlow. This can result in toBlockFlow
2128     // containing floats that are not in it&#39;s floating objects list, but are in
2129     // the floating objects lists of siblings and parents. This can cause
2130     // problems when the float itself is deleted, since the deletion code
2131     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2132     // objects list, it isn&#39;t in any floating objects list. In order to
2133     // preserve this condition (removing it has serious performance
2134     // implications), we need to copy the floating objects from the old block
2135     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
2136     // all be wrong, but since toBlockFlow is already marked for layout, this
2137     // will get fixed before anything gets displayed.
2138     // See bug https://bugs.webkit.org/show_bug.cgi?id=115566
2139     if (!m_floatingObjects)
2140         return;
2141 
2142     if (!toBlockFlow.m_floatingObjects)
2143         toBlockFlow.createFloatingObjects();
2144 
2145     for (auto&amp; floatingObject : m_floatingObjects-&gt;set()) {
2146         if (toBlockFlow.containsFloat(floatingObject-&gt;renderer()))
2147             continue;
2148         toBlockFlow.m_floatingObjects-&gt;add(floatingObject-&gt;cloneForNewParent());
2149     }
2150 }
2151 
2152 void RenderBlockFlow::addOverflowFromFloats()
2153 {
2154     if (!m_floatingObjects)
2155         return;
2156 
2157     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2158     auto end = floatingObjectSet.end();
2159     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2160         const auto&amp; floatingObject = *it-&gt;get();
2161         if (floatingObject.isDescendant())
2162             addOverflowFromChild(&amp;floatingObject.renderer(), floatingObject.locationOffsetOfBorderBox());
2163     }
2164 }
2165 
2166 void RenderBlockFlow::computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats)
2167 {
2168     RenderBlock::computeOverflow(oldClientAfterEdge, recomputeFloats);
2169 
2170     if (!multiColumnFlow() &amp;&amp; (recomputeFloats || createsNewFormattingContext() || hasSelfPaintingLayer()))
2171         addOverflowFromFloats();
2172 }
2173 
2174 void RenderBlockFlow::repaintOverhangingFloats(bool paintAllDescendants)
2175 {
2176     // Repaint any overhanging floats (if we know we&#39;re the one to paint them).
2177     // Otherwise, bail out.
2178     if (!hasOverhangingFloats())
2179         return;
2180 
2181     // FIXME: Avoid disabling LayoutState. At the very least, don&#39;t disable it for floats originating
2182     // in this block. Better yet would be to push extra state for the containers of other floats.
2183     LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext());
2184     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2185     auto end = floatingObjectSet.end();
2186     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2187         const auto&amp; floatingObject = *it-&gt;get();
2188         // Only repaint the object if it is overhanging, is not in its own layer, and
2189         // is our responsibility to paint (m_shouldPaint is set). When paintAllDescendants is true, the latter
2190         // condition is replaced with being a descendant of us.
2191         auto&amp; renderer = floatingObject.renderer();
2192         if (logicalBottomForFloat(floatingObject) &gt; logicalHeight()
2193             &amp;&amp; !renderer.hasSelfPaintingLayer()
2194             &amp;&amp; (floatingObject.shouldPaint() || (paintAllDescendants &amp;&amp; renderer.isDescendantOf(this)))) {
2195             renderer.repaint();
2196             renderer.repaintOverhangingFloats(false);
2197         }
2198     }
2199 }
2200 
2201 void RenderBlockFlow::paintColumnRules(PaintInfo&amp; paintInfo, const LayoutPoint&amp; point)
2202 {
2203     RenderBlock::paintColumnRules(paintInfo, point);
2204 
2205     if (!multiColumnFlow() || paintInfo.context().paintingDisabled())
2206         return;
2207 
2208     // Iterate over our children and paint the column rules as needed.
2209     for (auto&amp; columnSet : childrenOfType&lt;RenderMultiColumnSet&gt;(*this)) {
2210         LayoutPoint childPoint = columnSet.location() + flipForWritingModeForChild(&amp;columnSet, point);
2211         columnSet.paintColumnRules(paintInfo, childPoint);
2212     }
2213 }
2214 
2215 void RenderBlockFlow::paintFloats(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, bool preservePhase)
2216 {
2217     if (!m_floatingObjects)
2218         return;
2219 
2220     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2221     auto end = floatingObjectSet.end();
2222     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2223         const auto&amp; floatingObject = *it-&gt;get();
2224         auto&amp; renderer = floatingObject.renderer();
2225         // Only paint the object if our m_shouldPaint flag is set.
2226         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2227             PaintInfo currentPaintInfo(paintInfo);
2228             currentPaintInfo.phase = preservePhase ? paintInfo.phase : PaintPhase::BlockBackground;
2229             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, paintOffset + floatingObject.translationOffsetToAncestor());
2230             renderer.paint(currentPaintInfo, childPoint);
2231             if (!preservePhase) {
2232                 currentPaintInfo.phase = PaintPhase::ChildBlockBackgrounds;
2233                 renderer.paint(currentPaintInfo, childPoint);
2234                 currentPaintInfo.phase = PaintPhase::Float;
2235                 renderer.paint(currentPaintInfo, childPoint);
2236                 currentPaintInfo.phase = PaintPhase::Foreground;
2237                 renderer.paint(currentPaintInfo, childPoint);
2238                 currentPaintInfo.phase = PaintPhase::Outline;
2239                 renderer.paint(currentPaintInfo, childPoint);
2240             }
2241         }
2242     }
2243 }
2244 
2245 void RenderBlockFlow::clipOutFloatingObjects(RenderBlock&amp; rootBlock, const PaintInfo* paintInfo, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock)
2246 {
2247     if (m_floatingObjects) {
2248         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2249         auto end = floatingObjectSet.end();
2250         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2251             const auto&amp; floatingObject = *it-&gt;get();
2252             LayoutRect floatBox(offsetFromRootBlock.width(), offsetFromRootBlock.height(), floatingObject.renderer().width(), floatingObject.renderer().height());
2253             floatBox.move(floatingObject.locationOffsetOfBorderBox());
2254             rootBlock.flipForWritingMode(floatBox);
2255             floatBox.move(rootBlockPhysicalPosition.x(), rootBlockPhysicalPosition.y());
2256             paintInfo-&gt;context().clipOut(snappedIntRect(floatBox));
2257         }
2258     }
2259 }
2260 
2261 void RenderBlockFlow::createFloatingObjects()
2262 {
<a name="10" id="anc10"></a><span class="line-modified">2263     m_floatingObjects = makeUnique&lt;FloatingObjects&gt;(*this);</span>
2264 }
2265 
2266 void RenderBlockFlow::removeFloatingObjects()
2267 {
2268     if (!m_floatingObjects)
2269         return;
2270 
2271     markSiblingsWithFloatsForLayout();
2272 
2273     m_floatingObjects-&gt;clear();
2274 }
2275 
2276 FloatingObject* RenderBlockFlow::insertFloatingObject(RenderBox&amp; floatBox)
2277 {
2278     ASSERT(floatBox.isFloating());
2279 
2280     // Create the list of special objects if we don&#39;t aleady have one
2281     if (!m_floatingObjects)
2282         createFloatingObjects();
2283     else {
2284         // Don&#39;t insert the floatingObject again if it&#39;s already in the list
2285         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2286         auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(floatBox);
2287         if (it != floatingObjectSet.end())
2288             return it-&gt;get();
2289     }
2290 
2291     // Create the special floatingObject entry &amp; append it to the list
2292 
2293     std::unique_ptr&lt;FloatingObject&gt; floatingObject = FloatingObject::create(floatBox);
2294 
2295     // Our location is irrelevant if we&#39;re unsplittable or no pagination is in effect. Just lay out the float.
2296     bool isChildRenderBlock = floatBox.isRenderBlock();
2297     if (isChildRenderBlock &amp;&amp; !floatBox.needsLayout() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeightChanged())
2298         floatBox.setChildNeedsLayout(MarkOnlyThis);
2299 
2300     bool needsBlockDirectionLocationSetBeforeLayout = isChildRenderBlock &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;needsBlockDirectionLocationSetBeforeLayout();
2301     if (!needsBlockDirectionLocationSetBeforeLayout || isWritingModeRoot()) {
2302         // We are unsplittable if we&#39;re a block flow root.
2303         floatBox.layoutIfNeeded();
2304         floatingObject-&gt;setShouldPaint(!floatBox.hasSelfPaintingLayer());
2305     }
2306     else {
2307         floatBox.updateLogicalWidth();
2308         floatBox.computeAndSetBlockDirectionMargins(*this);
2309     }
2310 
2311     setLogicalWidthForFloat(*floatingObject, logicalWidthForChild(floatBox) + marginStartForChild(floatBox) + marginEndForChild(floatBox));
2312 
2313     return m_floatingObjects-&gt;add(WTFMove(floatingObject));
2314 }
2315 
2316 void RenderBlockFlow::removeFloatingObject(RenderBox&amp; floatBox)
2317 {
2318     if (m_floatingObjects) {
2319         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2320         auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(floatBox);
2321         if (it != floatingObjectSet.end()) {
2322             auto&amp; floatingObject = *it-&gt;get();
2323             if (childrenInline()) {
2324                 LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
2325                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
2326 
2327                 // Fix for https://bugs.webkit.org/show_bug.cgi?id=54995.
2328                 if (logicalBottom &lt; 0 || logicalBottom &lt; logicalTop || logicalTop == LayoutUnit::max())
2329                     logicalBottom = LayoutUnit::max();
2330                 else {
2331                     // Special-case zero- and less-than-zero-height floats: those don&#39;t touch
2332                     // the line that they&#39;re on, but it still needs to be dirtied. This is
2333                     // accomplished by pretending they have a height of 1.
2334                     logicalBottom = std::max(logicalBottom, logicalTop + 1);
2335                 }
2336                 if (floatingObject.originatingLine()) {
2337                     floatingObject.originatingLine()-&gt;removeFloat(floatBox);
2338                     if (!selfNeedsLayout()) {
2339                         ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
2340                         floatingObject.originatingLine()-&gt;markDirty();
2341                     }
2342 #if !ASSERT_DISABLED
2343                     floatingObject.clearOriginatingLine();
2344 #endif
2345                 }
2346                 markLinesDirtyInBlockRange(0, logicalBottom);
2347             }
2348             m_floatingObjects-&gt;remove(&amp;floatingObject);
2349         }
2350     }
2351 }
2352 
2353 void RenderBlockFlow::removeFloatingObjectsBelow(FloatingObject* lastFloat, int logicalOffset)
2354 {
2355     if (!containsFloats())
2356         return;
2357 
2358     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2359     FloatingObject* curr = floatingObjectSet.last().get();
2360     while (curr != lastFloat &amp;&amp; (!curr-&gt;isPlaced() || logicalTopForFloat(*curr) &gt;= logicalOffset)) {
2361         m_floatingObjects-&gt;remove(curr);
2362         if (floatingObjectSet.isEmpty())
2363             break;
2364         curr = floatingObjectSet.last().get();
2365     }
2366 }
2367 
2368 LayoutUnit RenderBlockFlow::logicalLeftOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const
2369 {
2370     LayoutUnit offset = fixedOffset;
2371     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasLeftObjects())
2372         offset = m_floatingObjects-&gt;logicalLeftOffsetForPositioningFloat(fixedOffset, logicalTop, heightRemaining);
2373     return adjustLogicalLeftOffsetForLine(offset, applyTextIndent);
2374 }
2375 
2376 LayoutUnit RenderBlockFlow::logicalRightOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const
2377 {
2378     LayoutUnit offset = fixedOffset;
2379     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasRightObjects())
2380         offset = m_floatingObjects-&gt;logicalRightOffsetForPositioningFloat(fixedOffset, logicalTop, heightRemaining);
2381     return adjustLogicalRightOffsetForLine(offset, applyTextIndent);
2382 }
2383 
2384 void RenderBlockFlow::computeLogicalLocationForFloat(FloatingObject&amp; floatingObject, LayoutUnit&amp; logicalTopOffset)
2385 {
2386     auto&amp; childBox = floatingObject.renderer();
2387     LayoutUnit logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2388     LayoutUnit logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2389 
2390     LayoutUnit floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset); // The width we look for.
2391 
2392     LayoutUnit floatLogicalLeft;
2393 
2394     bool insideFragmentedFlow = enclosingFragmentedFlow();
2395     bool isInitialLetter = childBox.style().styleType() == PseudoId::FirstLetter &amp;&amp; childBox.style().initialLetterDrop() &gt; 0;
2396 
2397     if (isInitialLetter) {
2398         int letterClearance = lowestInitialLetterLogicalBottom() - logicalTopOffset;
2399         if (letterClearance &gt; 0) {
2400             logicalTopOffset += letterClearance;
2401             setLogicalHeight(logicalHeight() + letterClearance);
2402         }
2403     }
2404 
2405     if (childBox.style().floating() == Float::Left) {
2406         LayoutUnit heightRemainingLeft = 1_lu;
2407         LayoutUnit heightRemainingRight = 1_lu;
2408         floatLogicalLeft = logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft);
2409         while (logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight) - floatLogicalLeft &lt; floatLogicalWidth) {
2410             logicalTopOffset += std::min(heightRemainingLeft, heightRemainingRight);
2411             floatLogicalLeft = logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft);
2412             if (insideFragmentedFlow) {
2413                 // Have to re-evaluate all of our offsets, since they may have changed.
2414                 logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2415                 logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2416                 floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset);
2417             }
2418         }
2419         floatLogicalLeft = std::max(logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);
2420     } else {
2421         LayoutUnit heightRemainingLeft = 1_lu;
2422         LayoutUnit heightRemainingRight = 1_lu;
2423         floatLogicalLeft = logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight);
2424         while (floatLogicalLeft - logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft) &lt; floatLogicalWidth) {
2425             logicalTopOffset += std::min(heightRemainingLeft, heightRemainingRight);
2426             floatLogicalLeft = logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight);
2427             if (insideFragmentedFlow) {
2428                 // Have to re-evaluate all of our offsets, since they may have changed.
2429                 logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2430                 logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2431                 floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset);
2432             }
2433         }
2434         // Use the original width of the float here, since the local variable
2435         // |floatLogicalWidth| was capped to the available line width. See
2436         // fast/block/float/clamped-right-float.html.
2437         floatLogicalLeft -= logicalWidthForFloat(floatingObject);
2438     }
2439 
2440     LayoutUnit childLogicalLeftMargin = style().isLeftToRightDirection() ? marginStartForChild(childBox) : marginEndForChild(childBox);
2441     LayoutUnit childBeforeMargin = marginBeforeForChild(childBox);
2442 
2443     if (isInitialLetter)
2444         adjustInitialLetterPosition(childBox, logicalTopOffset, childBeforeMargin);
2445 
2446     setLogicalLeftForFloat(floatingObject, floatLogicalLeft);
2447     setLogicalLeftForChild(childBox, floatLogicalLeft + childLogicalLeftMargin);
2448 
2449     setLogicalTopForFloat(floatingObject, logicalTopOffset);
2450     setLogicalTopForChild(childBox, logicalTopOffset + childBeforeMargin);
2451 
2452     setLogicalMarginsForFloat(floatingObject, childLogicalLeftMargin, childBeforeMargin);
2453 }
2454 
2455 void RenderBlockFlow::adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset)
2456 {
2457     const RenderStyle&amp; style = firstLineStyle();
2458     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2459     if (!fontMetrics.hasCapHeight())
2460         return;
2461 
2462     LayoutUnit heightOfLine = lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
2463     LayoutUnit beforeMarginBorderPadding = childBox.borderAndPaddingBefore() + childBox.marginBefore();
2464 
2465     // Make an adjustment to align with the cap height of a theoretical block line.
2466     LayoutUnit adjustment = fontMetrics.ascent() + (heightOfLine - fontMetrics.height()) / 2 - fontMetrics.capHeight() - beforeMarginBorderPadding;
2467     logicalTopOffset += adjustment;
2468 
2469     // For sunken and raised caps, we have to make some adjustments. Test if we&#39;re sunken or raised (dropHeightDelta will be
2470     // positive for raised and negative for sunken).
2471     int dropHeightDelta = childBox.style().initialLetterHeight() - childBox.style().initialLetterDrop();
2472 
2473     // If we&#39;re sunken, the float needs to shift down but lines still need to avoid it. In order to do that we increase the float&#39;s margin.
2474     if (dropHeightDelta &lt; 0)
2475         marginBeforeOffset += -dropHeightDelta * heightOfLine;
2476 
2477     // If we&#39;re raised, then we actually have to grow the height of the block, since the lines have to be pushed down as though we&#39;re placing
2478     // empty lines beside the first letter.
2479     if (dropHeightDelta &gt; 0)
2480         setLogicalHeight(logicalHeight() + dropHeightDelta * heightOfLine);
2481 }
2482 
2483 bool RenderBlockFlow::positionNewFloats()
2484 {
2485     if (!m_floatingObjects)
2486         return false;
2487 
2488     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2489     if (floatingObjectSet.isEmpty())
2490         return false;
2491 
2492     // If all floats have already been positioned, then we have no work to do.
2493     if (floatingObjectSet.last()-&gt;isPlaced())
2494         return false;
2495 
2496     // Move backwards through our floating object list until we find a float that has
2497     // already been positioned. Then we&#39;ll be able to move forward, positioning all of
2498     // the new floats that need it.
2499     auto it = floatingObjectSet.end();
2500     --it; // Go to last item.
2501     auto begin = floatingObjectSet.begin();
2502     FloatingObject* lastPlacedFloatingObject = 0;
2503     while (it != begin) {
2504         --it;
2505         if ((*it)-&gt;isPlaced()) {
2506             lastPlacedFloatingObject = it-&gt;get();
2507             ++it;
2508             break;
2509         }
2510     }
2511 
2512     LayoutUnit logicalTop = logicalHeight();
2513 
2514     // The float cannot start above the top position of the last positioned float.
2515     if (lastPlacedFloatingObject)
2516         logicalTop = std::max(logicalTopForFloat(*lastPlacedFloatingObject), logicalTop);
2517 
2518     auto end = floatingObjectSet.end();
2519     // Now walk through the set of unpositioned floats and place them.
2520     for (; it != end; ++it) {
2521         auto&amp; floatingObject = *it-&gt;get();
2522         // The containing block is responsible for positioning floats, so if we have floats in our
2523         // list that come from somewhere else, do not attempt to position them.
2524         auto&amp; childBox = floatingObject.renderer();
2525         if (childBox.containingBlock() != this)
2526             continue;
2527 
2528         LayoutRect oldRect = childBox.frameRect();
2529 
2530         if (childBox.style().clear() == Clear::Left || childBox.style().clear() == Clear::Both)
2531             logicalTop = std::max(lowestFloatLogicalBottom(FloatingObject::FloatLeft), logicalTop);
2532         if (childBox.style().clear() == Clear::Right || childBox.style().clear() == Clear::Both)
2533             logicalTop = std::max(lowestFloatLogicalBottom(FloatingObject::FloatRight), logicalTop);
2534 
2535         computeLogicalLocationForFloat(floatingObject, logicalTop);
2536         LayoutUnit childLogicalTop = logicalTopForChild(childBox);
2537 
2538         estimateFragmentRangeForBoxChild(childBox);
2539 
2540         childBox.markForPaginationRelayoutIfNeeded();
2541         childBox.layoutIfNeeded();
2542 
2543         auto* layoutState = view().frameView().layoutContext().layoutState();
2544         bool isPaginated = layoutState-&gt;isPaginated();
2545         if (isPaginated) {
2546             // If we are unsplittable and don&#39;t fit, then we need to move down.
2547             // We include our margins as part of the unsplittable area.
2548             LayoutUnit newLogicalTop = adjustForUnsplittableChild(childBox, logicalTop, childLogicalTop - logicalTop, marginAfterForChild(childBox));
2549 
2550             // See if we have a pagination strut that is making us move down further.
2551             // Note that an unsplittable child can&#39;t also have a pagination strut, so this
2552             // is exclusive with the case above.
2553             RenderBlock* childBlock = is&lt;RenderBlock&gt;(childBox) ? &amp;downcast&lt;RenderBlock&gt;(childBox) : nullptr;
2554             if (childBlock &amp;&amp; childBlock-&gt;paginationStrut()) {
2555                 newLogicalTop += childBlock-&gt;paginationStrut();
2556                 childBlock-&gt;setPaginationStrut(0);
2557             }
2558 
2559             if (newLogicalTop != logicalTop) {
2560                 floatingObject.setPaginationStrut(newLogicalTop - logicalTop);
2561                 computeLogicalLocationForFloat(floatingObject, newLogicalTop);
2562                 if (childBlock)
2563                     childBlock-&gt;setChildNeedsLayout(MarkOnlyThis);
2564                 childBox.layoutIfNeeded();
2565                 logicalTop = newLogicalTop;
2566             }
2567 
2568             if (updateFragmentRangeForBoxChild(childBox)) {
2569                 childBox.setNeedsLayout(MarkOnlyThis);
2570                 childBox.layoutIfNeeded();
2571             }
2572         }
2573 
2574         setLogicalHeightForFloat(floatingObject, logicalHeightForChildForFragmentation(childBox) + (logicalTopForChild(childBox) - logicalTop) + marginAfterForChild(childBox));
2575 
2576         m_floatingObjects-&gt;addPlacedObject(&amp;floatingObject);
2577 
2578         if (ShapeOutsideInfo* shapeOutside = childBox.shapeOutsideInfo())
2579             shapeOutside-&gt;setReferenceBoxLogicalSize(logicalSizeForChild(childBox));
2580         // If the child moved, we have to repaint it.
2581         if (childBox.checkForRepaintDuringLayout())
2582             childBox.repaintDuringLayoutIfMoved(oldRect);
2583     }
2584     return true;
2585 }
2586 
2587 void RenderBlockFlow::clearFloats(Clear clear)
2588 {
2589     positionNewFloats();
2590     // set y position
2591     LayoutUnit newY;
2592     switch (clear) {
2593     case Clear::Left:
2594         newY = lowestFloatLogicalBottom(FloatingObject::FloatLeft);
2595         break;
2596     case Clear::Right:
2597         newY = lowestFloatLogicalBottom(FloatingObject::FloatRight);
2598         break;
2599     case Clear::Both:
2600         newY = lowestFloatLogicalBottom();
2601         break;
2602     case Clear::None:
2603         break;
2604     }
2605     if (height() &lt; newY)
2606         setLogicalHeight(newY);
2607 }
2608 
2609 LayoutUnit RenderBlockFlow::logicalLeftFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const
2610 {
2611     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasLeftObjects())
2612         return m_floatingObjects-&gt;logicalLeftOffset(fixedOffset, logicalTop, logicalHeight);
2613 
2614     return fixedOffset;
2615 }
2616 
2617 LayoutUnit RenderBlockFlow::logicalRightFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const
2618 {
2619     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasRightObjects())
2620         return m_floatingObjects-&gt;logicalRightOffset(fixedOffset, logicalTop, logicalHeight);
2621 
2622     return fixedOffset;
2623 }
2624 
2625 LayoutUnit RenderBlockFlow::nextFloatLogicalBottomBelow(LayoutUnit logicalHeight) const
2626 {
2627     if (!m_floatingObjects)
2628         return logicalHeight;
2629 
2630     return m_floatingObjects-&gt;findNextFloatLogicalBottomBelow(logicalHeight);
2631 }
2632 
2633 LayoutUnit RenderBlockFlow::nextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight) const
2634 {
2635     if (!m_floatingObjects)
2636         return logicalHeight;
2637 
2638     return m_floatingObjects-&gt;findNextFloatLogicalBottomBelowForBlock(logicalHeight);
2639 }
2640 
2641 LayoutUnit RenderBlockFlow::lowestFloatLogicalBottom(FloatingObject::Type floatType) const
2642 {
2643     if (!m_floatingObjects)
2644         return 0;
2645     LayoutUnit lowestFloatBottom;
2646     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2647     auto end = floatingObjectSet.end();
2648     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2649         const auto&amp; floatingObject = *it-&gt;get();
2650         if (floatingObject.isPlaced() &amp;&amp; floatingObject.type() &amp; floatType)
2651             lowestFloatBottom = std::max(lowestFloatBottom, logicalBottomForFloat(floatingObject));
2652     }
2653     return lowestFloatBottom;
2654 }
2655 
2656 LayoutUnit RenderBlockFlow::lowestInitialLetterLogicalBottom() const
2657 {
2658     if (!m_floatingObjects)
2659         return 0;
2660     LayoutUnit lowestFloatBottom;
2661     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2662     auto end = floatingObjectSet.end();
2663     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2664         const auto&amp; floatingObject = *it-&gt;get();
2665         if (floatingObject.isPlaced() &amp;&amp; floatingObject.renderer().style().styleType() == PseudoId::FirstLetter &amp;&amp; floatingObject.renderer().style().initialLetterDrop() &gt; 0)
2666             lowestFloatBottom = std::max(lowestFloatBottom, logicalBottomForFloat(floatingObject));
2667     }
2668     return lowestFloatBottom;
2669 }
2670 
2671 LayoutUnit RenderBlockFlow::addOverhangingFloats(RenderBlockFlow&amp; child, bool makeChildPaintOtherFloats)
2672 {
2673     // Prevent floats from being added to the canvas by the root element, e.g., &lt;html&gt;.
2674     if (!child.containsFloats() || child.createsNewFormattingContext())
2675         return 0;
2676 
2677     LayoutUnit childLogicalTop = child.logicalTop();
2678     LayoutUnit childLogicalLeft = child.logicalLeft();
2679     LayoutUnit lowestFloatLogicalBottom;
2680 
2681     // Floats that will remain the child&#39;s responsibility to paint should factor into its
2682     // overflow.
2683     auto childEnd = child.m_floatingObjects-&gt;set().end();
2684     for (auto childIt = child.m_floatingObjects-&gt;set().begin(); childIt != childEnd; ++childIt) {
2685         auto&amp; floatingObject = *childIt-&gt;get();
2686         LayoutUnit floatLogicalBottom = std::min(logicalBottomForFloat(floatingObject), LayoutUnit::max() - childLogicalTop);
2687         LayoutUnit logicalBottom = childLogicalTop + floatLogicalBottom;
2688         lowestFloatLogicalBottom = std::max(lowestFloatLogicalBottom, logicalBottom);
2689 
2690         if (logicalBottom &gt; logicalHeight()) {
2691             // If the object is not in the list, we add it now.
2692             if (!containsFloat(floatingObject.renderer())) {
2693                 LayoutSize offset = isHorizontalWritingMode() ? LayoutSize(-childLogicalLeft, -childLogicalTop) : LayoutSize(-childLogicalTop, -childLogicalLeft);
2694                 bool shouldPaint = false;
2695 
2696                 // The nearest enclosing layer always paints the float (so that zindex and stacking
2697                 // behaves properly). We always want to propagate the desire to paint the float as
2698                 // far out as we can, to the outermost block that overlaps the float, stopping only
2699                 // if we hit a self-painting layer boundary.
2700                 if (floatingObject.renderer().enclosingFloatPaintingLayer() == enclosingFloatPaintingLayer()) {
2701                     floatingObject.setShouldPaint(false);
2702                     shouldPaint = true;
2703                 }
2704                 // We create the floating object list lazily.
2705                 if (!m_floatingObjects)
2706                     createFloatingObjects();
2707 
2708                 m_floatingObjects-&gt;add(floatingObject.copyToNewContainer(offset, shouldPaint, true));
2709             }
2710         } else {
2711             const auto&amp; renderer = floatingObject.renderer();
2712             if (makeChildPaintOtherFloats &amp;&amp; !floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()
2713                 &amp;&amp; renderer.isDescendantOf(&amp;child) &amp;&amp; renderer.enclosingFloatPaintingLayer() == child.enclosingFloatPaintingLayer()) {
2714                 // The float is not overhanging from this block, so if it is a descendant of the child, the child should
2715                 // paint it (the other case is that it is intruding into the child), unless it has its own layer or enclosing
2716                 // layer.
2717                 // If makeChildPaintOtherFloats is false, it means that the child must already know about all the floats
2718                 // it should paint.
2719                 floatingObject.setShouldPaint(true);
2720             }
2721 
2722             // Since the float doesn&#39;t overhang, it didn&#39;t get put into our list. We need to add its overflow in to the child now.
2723             if (floatingObject.isDescendant())
2724                 child.addOverflowFromChild(&amp;renderer, floatingObject.locationOffsetOfBorderBox());
2725         }
2726     }
2727     return lowestFloatLogicalBottom;
2728 }
2729 
2730 bool RenderBlockFlow::hasOverhangingFloat(RenderBox&amp; renderer)
2731 {
2732     if (!m_floatingObjects || !parent())
2733         return false;
2734 
2735     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2736     const auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(renderer);
2737     if (it == floatingObjectSet.end())
2738         return false;
2739 
2740     return logicalBottomForFloat(*it-&gt;get()) &gt; logicalHeight();
2741 }
2742 
2743 void RenderBlockFlow::addIntrudingFloats(RenderBlockFlow* prev, RenderBlockFlow* container, LayoutUnit logicalLeftOffset, LayoutUnit logicalTopOffset)
2744 {
2745     ASSERT(!avoidsFloats());
2746 
2747     // If we create our own block formatting context then our contents don&#39;t interact with floats outside it, even those from our parent.
2748     if (createsNewFormattingContext())
2749         return;
2750 
2751     // If the parent or previous sibling doesn&#39;t have any floats to add, don&#39;t bother.
2752     if (!prev-&gt;m_floatingObjects)
2753         return;
2754 
2755     logicalLeftOffset += marginLogicalLeft();
2756 
2757     const FloatingObjectSet&amp; prevSet = prev-&gt;m_floatingObjects-&gt;set();
2758     auto prevEnd = prevSet.end();
2759     for (auto prevIt = prevSet.begin(); prevIt != prevEnd; ++prevIt) {
2760         auto&amp; floatingObject = *prevIt-&gt;get();
2761         if (logicalBottomForFloat(floatingObject) &gt; logicalTopOffset) {
2762             if (!m_floatingObjects || !m_floatingObjects-&gt;set().contains(&amp;floatingObject)) {
2763                 // We create the floating object list lazily.
2764                 if (!m_floatingObjects)
2765                     createFloatingObjects();
2766 
2767                 // Applying the child&#39;s margin makes no sense in the case where the child was passed in.
2768                 // since this margin was added already through the modification of the |logicalLeftOffset| variable
2769                 // above. |logicalLeftOffset| will equal the margin in this case, so it&#39;s already been taken
2770                 // into account. Only apply this code if prev is the parent, since otherwise the left margin
2771                 // will get applied twice.
2772                 LayoutSize offset = isHorizontalWritingMode()
2773                     ? LayoutSize(logicalLeftOffset - (prev != container ? prev-&gt;marginLeft() : 0_lu), logicalTopOffset)
2774                     : LayoutSize(logicalTopOffset, logicalLeftOffset - (prev != container ? prev-&gt;marginTop() : 0_lu));
2775 
2776                 m_floatingObjects-&gt;add(floatingObject.copyToNewContainer(offset));
2777             }
2778         }
2779     }
2780 }
2781 
2782 void RenderBlockFlow::markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove, bool inLayout)
2783 {
2784     if (!everHadLayout() &amp;&amp; !containsFloats())
2785         return;
2786 
2787     MarkingBehavior markParents = inLayout ? MarkOnlyThis : MarkContainingBlockChain;
2788     setChildNeedsLayout(markParents);
2789 
2790     if (floatToRemove)
2791         removeFloatingObject(*floatToRemove);
2792     else if (childrenInline())
2793         return;
2794 
2795     // Iterate over our block children and mark them as needed.
2796     for (auto&amp; block : childrenOfType&lt;RenderBlock&gt;(*this)) {
2797         if (!floatToRemove &amp;&amp; block.isFloatingOrOutOfFlowPositioned())
2798             continue;
2799         if (!is&lt;RenderBlockFlow&gt;(block)) {
2800             if (block.shrinkToAvoidFloats() &amp;&amp; block.everHadLayout())
2801                 block.setChildNeedsLayout(markParents);
2802             continue;
2803         }
2804         auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(block);
2805         if ((floatToRemove ? blockFlow.containsFloat(*floatToRemove) : blockFlow.containsFloats()) || blockFlow.shrinkToAvoidFloats())
2806             blockFlow.markAllDescendantsWithFloatsForLayout(floatToRemove, inLayout);
2807     }
2808 }
2809 
2810 void RenderBlockFlow::markSiblingsWithFloatsForLayout(RenderBox* floatToRemove)
2811 {
2812     if (!m_floatingObjects)
2813         return;
2814 
2815     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2816     auto end = floatingObjectSet.end();
2817 
2818     for (RenderObject* next = nextSibling(); next; next = next-&gt;nextSibling()) {
2819         if (!is&lt;RenderBlockFlow&gt;(*next) || next-&gt;isFloatingOrOutOfFlowPositioned())
2820             continue;
2821 
2822         RenderBlockFlow&amp; nextBlock = downcast&lt;RenderBlockFlow&gt;(*next);
2823         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2824             RenderBox&amp; floatingBox = (*it)-&gt;renderer();
2825             if (floatToRemove &amp;&amp; &amp;floatingBox != floatToRemove)
2826                 continue;
2827             if (nextBlock.containsFloat(floatingBox))
2828                 nextBlock.markAllDescendantsWithFloatsForLayout(&amp;floatingBox);
2829         }
2830     }
2831 }
2832 
2833 LayoutPoint RenderBlockFlow::flipFloatForWritingModeForChild(const FloatingObject&amp; child, const LayoutPoint&amp; point) const
2834 {
2835     if (!style().isFlippedBlocksWritingMode())
2836         return point;
2837 
2838     // This is similar to RenderBox::flipForWritingModeForChild. We have to subtract out our left/top offsets twice, since
2839     // it&#39;s going to get added back in. We hide this complication here so that the calling code looks normal for the unflipped
2840     // case.
2841     if (isHorizontalWritingMode())
2842         return LayoutPoint(point.x(), point.y() + height() - child.renderer().height() - 2 * child.locationOffsetOfBorderBox().height());
2843     return LayoutPoint(point.x() + width() - child.renderer().width() - 2 * child.locationOffsetOfBorderBox().width(), point.y());
2844 }
2845 
2846 LayoutUnit RenderBlockFlow::getClearDelta(RenderBox&amp; child, LayoutUnit logicalTop)
2847 {
2848     // There is no need to compute clearance if we have no floats.
2849     if (!containsFloats())
2850         return 0;
2851 
2852     // At least one float is present. We need to perform the clearance computation.
2853     bool clearSet = child.style().clear() != Clear::None;
2854     LayoutUnit logicalBottom;
2855     switch (child.style().clear()) {
2856     case Clear::None:
2857         break;
2858     case Clear::Left:
2859         logicalBottom = lowestFloatLogicalBottom(FloatingObject::FloatLeft);
2860         break;
2861     case Clear::Right:
2862         logicalBottom = lowestFloatLogicalBottom(FloatingObject::FloatRight);
2863         break;
2864     case Clear::Both:
2865         logicalBottom = lowestFloatLogicalBottom();
2866         break;
2867     }
2868 
2869     // We also clear floats if we are too big to sit on the same line as a float (and wish to avoid floats by default).
2870     LayoutUnit result = clearSet ? std::max&lt;LayoutUnit&gt;(0, logicalBottom - logicalTop) : 0_lu;
2871     if (!result &amp;&amp; child.avoidsFloats()) {
2872         LayoutUnit newLogicalTop = logicalTop;
2873         while (true) {
2874             LayoutUnit availableLogicalWidthAtNewLogicalTopOffset = availableLogicalWidthForLine(newLogicalTop, DoNotIndentText, logicalHeightForChild(child));
2875             if (availableLogicalWidthAtNewLogicalTopOffset == availableLogicalWidthForContent(newLogicalTop))
2876                 return newLogicalTop - logicalTop;
2877 
2878             RenderFragmentContainer* fragment = fragmentAtBlockOffset(logicalTopForChild(child));
2879             LayoutRect borderBox = child.borderBoxRectInFragment(fragment, DoNotCacheRenderBoxFragmentInfo);
2880             LayoutUnit childLogicalWidthAtOldLogicalTopOffset = isHorizontalWritingMode() ? borderBox.width() : borderBox.height();
2881 
2882             // FIXME: None of this is right for perpendicular writing-mode children.
2883             LayoutUnit childOldLogicalWidth = child.logicalWidth();
2884             LayoutUnit childOldMarginLeft = child.marginLeft();
2885             LayoutUnit childOldMarginRight = child.marginRight();
2886             LayoutUnit childOldLogicalTop = child.logicalTop();
2887 
2888             child.setLogicalTop(newLogicalTop);
2889             child.updateLogicalWidth();
2890             fragment = fragmentAtBlockOffset(logicalTopForChild(child));
2891             borderBox = child.borderBoxRectInFragment(fragment, DoNotCacheRenderBoxFragmentInfo);
2892             LayoutUnit childLogicalWidthAtNewLogicalTopOffset = isHorizontalWritingMode() ? borderBox.width() : borderBox.height();
2893 
2894             child.setLogicalTop(childOldLogicalTop);
2895             child.setLogicalWidth(childOldLogicalWidth);
2896             child.setMarginLeft(childOldMarginLeft);
2897             child.setMarginRight(childOldMarginRight);
2898 
2899             if (childLogicalWidthAtNewLogicalTopOffset &lt;= availableLogicalWidthAtNewLogicalTopOffset) {
2900                 // Even though we may not be moving, if the logical width did shrink because of the presence of new floats, then
2901                 // we need to force a relayout as though we shifted. This happens because of the dynamic addition of overhanging floats
2902                 // from previous siblings when negative margins exist on a child (see the addOverhangingFloats call at the end of collapseMargins).
2903                 if (childLogicalWidthAtOldLogicalTopOffset != childLogicalWidthAtNewLogicalTopOffset)
2904                     child.setChildNeedsLayout(MarkOnlyThis);
2905                 return newLogicalTop - logicalTop;
2906             }
2907 
2908             newLogicalTop = nextFloatLogicalBottomBelowForBlock(newLogicalTop);
2909             ASSERT(newLogicalTop &gt;= logicalTop);
2910             if (newLogicalTop &lt; logicalTop)
2911                 break;
2912         }
2913         ASSERT_NOT_REACHED();
2914     }
2915     return result;
2916 }
2917 
2918 bool RenderBlockFlow::hitTestFloats(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
2919 {
2920     if (!m_floatingObjects)
2921         return false;
2922 
2923     LayoutPoint adjustedLocation = accumulatedOffset;
2924     if (is&lt;RenderView&gt;(*this))
2925         adjustedLocation += toLayoutSize(downcast&lt;RenderView&gt;(*this).frameView().scrollPosition());
2926 
2927     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2928     auto begin = floatingObjectSet.begin();
2929     for (auto it = floatingObjectSet.end(); it != begin;) {
2930         --it;
2931         const auto&amp; floatingObject = *it-&gt;get();
2932         auto&amp; renderer = floatingObject.renderer();
2933         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2934             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2935             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2936                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2937                 return true;
2938             }
2939         }
2940     }
2941 
2942     return false;
2943 }
2944 
2945 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2946 {
2947     ASSERT(childrenInline());
2948 
2949     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
2950         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout, request, result, locationInContainer, accumulatedOffset, hitTestAction);
2951 
<a name="11" id="anc11"></a><span class="line-modified">2952     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
<span class="line-added">2953 }</span>
<span class="line-added">2954 </span>
<span class="line-added">2955 void RenderBlockFlow::addOverflowFromInlineChildren()</span>
<span class="line-added">2956 {</span>
<span class="line-added">2957     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {</span>
<span class="line-added">2958         ASSERT(!hasOverflowClip());</span>
<span class="line-added">2959         SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);</span>
<span class="line-added">2960         return;</span>
<span class="line-added">2961     }</span>
<span class="line-added">2962 </span>
<span class="line-added">2963     m_complexLineLayout-&gt;addOverflowFromInlineChildren();</span>
2964 }
2965 
2966 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
2967 {
2968     if (style().visibility() != Visibility::Visible)
2969         return;
2970 
2971     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
2972     // for either overflow or translations via relative positioning.
2973     if (childrenInline()) {
2974         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
2975 
2976         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
2977             if (box-&gt;firstChild())
2978                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
2979             if (box-&gt;lastChild())
2980                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
2981         }
2982     } else {
2983         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
2984             if (!obj-&gt;isFloatingOrOutOfFlowPositioned()) {
2985                 if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; !obj-&gt;hasOverflowClip())
2986                     downcast&lt;RenderBlockFlow&gt;(*obj).adjustForBorderFit(x + obj-&gt;x(), left, right);
2987                 else if (obj-&gt;style().visibility() == Visibility::Visible) {
2988                     // We are a replaced element or some kind of non-block-flow object.
2989                     left = std::min(left, x + obj-&gt;x());
2990                     right = std::max(right, x + obj-&gt;x() + obj-&gt;width());
2991                 }
2992             }
2993         }
2994     }
2995 
2996     if (m_floatingObjects) {
2997         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2998         auto end = floatingObjectSet.end();
2999         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
3000             const auto&amp; floatingObject = *it-&gt;get();
3001             // Only examine the object if our m_shouldPaint flag is set.
3002             if (floatingObject.shouldPaint()) {
3003                 LayoutUnit floatLeft = floatingObject.translationOffsetToAncestor().width();
3004                 LayoutUnit floatRight = floatLeft + floatingObject.renderer().width();
3005                 left = std::min(left, floatLeft);
3006                 right = std::max(right, floatRight);
3007             }
3008         }
3009     }
3010 }
3011 
3012 void RenderBlockFlow::fitBorderToLinesIfNeeded()
3013 {
3014     if (style().borderFit() == BorderFit::Border || hasOverrideContentLogicalWidth())
3015         return;
3016 
3017     // Walk any normal flow lines to snugly fit.
3018     LayoutUnit left = LayoutUnit::max();
3019     LayoutUnit right = LayoutUnit::min();
3020     LayoutUnit oldWidth = contentWidth();
3021     adjustForBorderFit(0, left, right);
3022 
3023     // Clamp to our existing edges. We can never grow. We only shrink.
3024     LayoutUnit leftEdge = borderLeft() + paddingLeft();
3025     LayoutUnit rightEdge = leftEdge + oldWidth;
3026     left = std::min(rightEdge, std::max(leftEdge, left));
3027     right = std::max(leftEdge, std::min(rightEdge, right));
3028 
3029     LayoutUnit newContentWidth = right - left;
3030     if (newContentWidth == oldWidth)
3031         return;
3032 
3033     setOverrideContentLogicalWidth(newContentWidth);
3034     layoutBlock(false);
3035     clearOverrideContentLogicalWidth();
3036 }
3037 
3038 void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
3039 {
3040     if (logicalTop &gt;= logicalBottom)
3041         return;
3042 
3043     // Floats currently affect the choice whether to use simple line layout path.
3044     if (m_simpleLineLayout) {
3045         invalidateLineLayoutPath();
3046         return;
3047     }
3048 
3049     RootInlineBox* lowestDirtyLine = lastRootBox();
3050     RootInlineBox* afterLowest = lowestDirtyLine;
3051     while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
3052         afterLowest = lowestDirtyLine;
3053         lowestDirtyLine = lowestDirtyLine-&gt;prevRootBox();
3054     }
3055 
3056     while (afterLowest &amp;&amp; afterLowest != highest &amp;&amp; (afterLowest-&gt;lineBottomWithLeading() &gt;= logicalTop || afterLowest-&gt;lineBottomWithLeading() &lt; 0)) {
3057         afterLowest-&gt;markDirty();
3058         afterLowest = afterLowest-&gt;prevRootBox();
3059     }
3060 }
3061 
3062 Optional&lt;int&gt; RenderBlockFlow::firstLineBaseline() const
3063 {
3064     if (isWritingModeRoot() &amp;&amp; !isRubyRun() &amp;&amp; !isGridItem())
3065         return WTF::nullopt;
3066 
3067     if (!childrenInline())
3068         return RenderBlock::firstLineBaseline();
3069 
3070     if (!hasLines())
3071         return WTF::nullopt;
3072 
3073     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3074         return Optional&lt;int&gt;(SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout));
3075 
3076     ASSERT(firstRootBox());
3077     if (style().isFlippedLinesWritingMode())
3078         return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
3079     return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
3080 }
3081 
3082 Optional&lt;int&gt; RenderBlockFlow::inlineBlockBaseline(LineDirectionMode lineDirection) const
3083 {
3084     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
3085         return WTF::nullopt;
3086 
3087     // Note that here we only take the left and bottom into consideration. Our caller takes the right and top into consideration.
3088     float boxHeight = lineDirection == HorizontalLine ? height() + m_marginBox.bottom() : width() + m_marginBox.left();
3089     float lastBaseline;
3090     if (!childrenInline()) {
3091         Optional&lt;int&gt; inlineBlockBaseline = RenderBlock::inlineBlockBaseline(lineDirection);
3092         if (!inlineBlockBaseline)
3093             return inlineBlockBaseline;
3094         lastBaseline = inlineBlockBaseline.value();
3095     } else {
3096         if (!hasLines()) {
3097             if (!hasLineIfEmpty())
3098                 return WTF::nullopt;
3099             const auto&amp; fontMetrics = firstLineStyle().fontMetrics();
3100             return Optional&lt;int&gt;(fontMetrics.ascent()
3101                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
3102                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
3103         }
3104 
3105         if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3106             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout);
3107         else {
3108             bool isFirstLine = lastRootBox() == firstRootBox();
3109             const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
3110             // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
3111             lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
3112                 + (style.isFlippedLinesWritingMode() ? logicalHeight() - lastRootBox()-&gt;logicalBottom() : lastRootBox()-&gt;logicalTop());
3113         }
3114     }
3115     // According to the CSS spec http://www.w3.org/TR/CSS21/visudet.html, we shouldn&#39;t be performing this min, but should
3116     // instead be returning boxHeight directly. However, we feel that a min here is better behavior (and is consistent
3117     // enough with the spec to not cause tons of breakages).
3118     return style().overflowY() == Overflow::Visible ? lastBaseline : std::min(boxHeight, lastBaseline);
3119 }
3120 
3121 void RenderBlockFlow::setSelectionState(SelectionState state)
3122 {
3123     if (state != SelectionNone)
3124         ensureLineBoxes();
3125     RenderBoxModelObject::setSelectionState(state);
3126 }
3127 
3128 GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
3129     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
3130 {
3131     ASSERT(!m_simpleLineLayout);
3132 
3133     GapRects result;
3134 
3135     bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
3136 
3137     if (!hasLines()) {
3138         if (containsStart) {
3139             // Update our lastLogicalTop to be the bottom of the block. &lt;hr&gt;s or empty blocks with height can trip this case.
3140             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3141             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3142             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3143         }
3144         return result;
3145     }
3146 
3147     RootInlineBox* lastSelectedLine = 0;
3148     RootInlineBox* curr;
3149     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3150 
3151     // Now paint the gaps for the lines.
3152     for (; curr &amp;&amp; curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) {
3153         LayoutUnit selTop =  curr-&gt;selectionTopAdjustedForPrecedingBlock();
3154         LayoutUnit selHeight = curr-&gt;selectionHeightAdjustedForPrecedingBlock();
3155 
3156         if (!containsStart &amp;&amp; !lastSelectedLine &amp;&amp;
3157             selectionState() != SelectionStart &amp;&amp; selectionState() != SelectionBoth &amp;&amp; !isRubyBase())
3158             result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, selTop, cache, paintInfo));
3159 
<a name="12" id="anc12"></a><span class="line-modified">3160         LayoutRect logicalRect { LayoutUnit(curr-&gt;logicalLeft()), selTop, LayoutUnit(curr-&gt;logicalWidth()), selTop + selHeight };</span>
3161         logicalRect.move(isHorizontalWritingMode() ? offsetFromRootBlock : offsetFromRootBlock.transposedSize());
3162         LayoutRect physicalRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
3163         if (!paintInfo || (isHorizontalWritingMode() &amp;&amp; physicalRect.y() &lt; paintInfo-&gt;rect.maxY() &amp;&amp; physicalRect.maxY() &gt; paintInfo-&gt;rect.y())
3164             || (!isHorizontalWritingMode() &amp;&amp; physicalRect.x() &lt; paintInfo-&gt;rect.maxX() &amp;&amp; physicalRect.maxX() &gt; paintInfo-&gt;rect.x()))
3165             result.unite(curr-&gt;lineSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, selTop, selHeight, cache, paintInfo));
3166 
3167         lastSelectedLine = curr;
3168     }
3169 
3170     if (containsStart &amp;&amp; !lastSelectedLine)
3171         // VisibleSelection must start just after our last line.
3172         lastSelectedLine = lastRootBox();
3173 
3174     if (lastSelectedLine &amp;&amp; selectionState() != SelectionEnd &amp;&amp; selectionState() != SelectionBoth) {
3175         // Update our lastY to be the bottom of the last selected line.
3176         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + lastSelectedLine-&gt;selectionBottom();
3177         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3178         lastLogicalRight = logicalRightSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3179     }
3180     return result;
3181 }
3182 
3183 bool RenderBlockFlow::needsLayoutAfterFragmentRangeChange() const
3184 {
3185     // A block without floats or that expands to enclose them won&#39;t need a relayout
3186     // after a fragment range change. There is no overflow content needing relayout
3187     // in the fragment chain because the fragment range can only shrink after the estimation.
3188     if (!containsFloats() || createsNewFormattingContext())
3189         return false;
3190 
3191     return true;
3192 }
3193 
3194 void RenderBlockFlow::setMultiColumnFlow(RenderMultiColumnFlow&amp; fragmentedFlow)
3195 {
3196     ASSERT(!hasRareBlockFlowData() || !rareBlockFlowData()-&gt;m_multiColumnFlow);
3197     ensureRareBlockFlowData().m_multiColumnFlow = makeWeakPtr(fragmentedFlow);
3198 }
3199 
3200 void RenderBlockFlow::clearMultiColumnFlow()
3201 {
3202     ASSERT(hasRareBlockFlowData());
3203     ASSERT(rareBlockFlowData()-&gt;m_multiColumnFlow);
3204     rareBlockFlowData()-&gt;m_multiColumnFlow.clear();
3205 }
3206 
3207 static bool shouldCheckLines(const RenderBlockFlow&amp; blockFlow)
3208 {
3209     return !blockFlow.isFloatingOrOutOfFlowPositioned() &amp;&amp; blockFlow.style().height().isAuto();
3210 }
3211 
3212 RootInlineBox* RenderBlockFlow::lineAtIndex(int i) const
3213 {
3214     ASSERT(i &gt;= 0);
3215 
3216     if (style().visibility() != Visibility::Visible)
3217         return nullptr;
3218 
3219     if (childrenInline()) {
3220         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3221             if (!i--)
3222                 return box;
3223         }
3224         return nullptr;
3225     }
3226 
3227     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3228         if (!shouldCheckLines(blockFlow))
3229             continue;
3230         if (RootInlineBox* box = blockFlow.lineAtIndex(i))
3231             return box;
3232     }
3233 
3234     return nullptr;
3235 }
3236 
3237 int RenderBlockFlow::lineCount(const RootInlineBox* stopRootInlineBox, bool* found) const
3238 {
3239     if (style().visibility() != Visibility::Visible)
3240         return 0;
3241 
3242     int count = 0;
3243 
3244     if (childrenInline()) {
3245         if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3246             ASSERT(!stopRootInlineBox);
3247             return simpleLineLayout-&gt;lineCount();
3248         }
3249         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3250             ++count;
3251             if (box == stopRootInlineBox) {
3252                 if (found)
3253                     *found = true;
3254                 break;
3255             }
3256         }
3257         return count;
3258     }
3259 
3260     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3261         if (!shouldCheckLines(blockFlow))
3262             continue;
3263         bool recursiveFound = false;
3264         count += blockFlow.lineCount(stopRootInlineBox, &amp;recursiveFound);
3265         if (recursiveFound) {
3266             if (found)
3267                 *found = true;
3268             break;
3269         }
3270     }
3271 
3272     return count;
3273 }
3274 
3275 static int getHeightForLineCount(const RenderBlockFlow&amp; block, int lineCount, bool includeBottom, int&amp; count)
3276 {
3277     if (block.style().visibility() != Visibility::Visible)
3278         return -1;
3279 
3280     if (block.childrenInline()) {
3281         for (auto* box = block.firstRootBox(); box; box = box-&gt;nextRootBox()) {
3282             if (++count == lineCount)
3283                 return box-&gt;lineBottom() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3284         }
3285     } else {
3286         RenderBox* normalFlowChildWithoutLines = nullptr;
3287         for (auto* obj = block.firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
3288             if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; shouldCheckLines(downcast&lt;RenderBlockFlow&gt;(*obj))) {
3289                 int result = getHeightForLineCount(downcast&lt;RenderBlockFlow&gt;(*obj), lineCount, false, count);
3290                 if (result != -1)
3291                     return result + obj-&gt;y() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3292             } else if (!obj-&gt;isFloatingOrOutOfFlowPositioned())
3293                 normalFlowChildWithoutLines = obj;
3294         }
3295         if (normalFlowChildWithoutLines &amp;&amp; !lineCount)
3296             return normalFlowChildWithoutLines-&gt;y() + normalFlowChildWithoutLines-&gt;height();
3297     }
3298 
3299     return -1;
3300 }
3301 
3302 int RenderBlockFlow::heightForLineCount(int lineCount)
3303 {
3304     int count = 0;
3305     return getHeightForLineCount(*this, lineCount, true, count);
3306 }
3307 
3308 void RenderBlockFlow::clearTruncation()
3309 {
3310     if (style().visibility() != Visibility::Visible)
3311         return;
3312 
3313     if (childrenInline() &amp;&amp; hasMarkupTruncation()) {
3314         ensureLineBoxes();
3315 
3316         setHasMarkupTruncation(false);
3317         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())
3318             box-&gt;clearTruncation();
3319         return;
3320     }
3321 
3322     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3323         if (shouldCheckLines(blockFlow))
3324             blockFlow.clearTruncation();
3325     }
3326 }
3327 
3328 bool RenderBlockFlow::containsNonZeroBidiLevel() const
3329 {
3330     for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3331         for (auto* box = root-&gt;firstLeafChild(); box; box = box-&gt;nextLeafChild()) {
3332             if (box-&gt;bidiLevel())
3333                 return true;
3334         }
3335     }
3336     return false;
3337 }
3338 
3339 Position RenderBlockFlow::positionForBox(InlineBox *box, bool start) const
3340 {
3341     if (!box)
3342         return Position();
3343 
3344     if (!box-&gt;renderer().nonPseudoNode())
3345         return createLegacyEditingPosition(nonPseudoElement(), start ? caretMinOffset() : caretMaxOffset());
3346 
3347     if (!is&lt;InlineTextBox&gt;(*box))
3348         return createLegacyEditingPosition(box-&gt;renderer().nonPseudoNode(), start ? box-&gt;renderer().caretMinOffset() : box-&gt;renderer().caretMaxOffset());
3349 
3350     auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*box);
3351     return createLegacyEditingPosition(textBox.renderer().nonPseudoNode(), start ? textBox.start() : textBox.start() + textBox.len());
3352 }
3353 
3354 RenderText* RenderBlockFlow::findClosestTextAtAbsolutePoint(const FloatPoint&amp; point)
3355 {
3356     // A light, non-recursive version of RenderBlock::positionForCoordinates that looks at
3357     // whether a point lies within the gaps between its root line boxes, to be called against
3358     // a node returned from elementAtPoint. We make the assumption that either the node or one
3359     // of its immediate children contains the root line boxes in question.
3360     // See &lt;rdar://problem/6824650&gt; for context.
3361 
3362     RenderBlock* block = this;
3363 
3364     FloatPoint localPoint = block-&gt;absoluteToLocal(point);
3365 
3366     if (!block-&gt;childrenInline()) {
3367         // Look among our immediate children for an alternate box that contains the point.
3368         for (RenderBox* child = block-&gt;firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
3369             if (!child-&gt;height() || child-&gt;style().visibility() != WebCore::Visibility::Visible || child-&gt;isFloatingOrOutOfFlowPositioned())
3370                 continue;
3371             float top = child-&gt;y();
3372 
3373             RenderBox* nextChild = child-&gt;nextSiblingBox();
3374             while (nextChild &amp;&amp; nextChild-&gt;isFloatingOrOutOfFlowPositioned())
3375                 nextChild = nextChild-&gt;nextSiblingBox();
3376             if (!nextChild) {
3377                 if (localPoint.y() &gt;= top) {
3378                     block = downcast&lt;RenderBlock&gt;(child);
3379                     break;
3380                 }
3381                 continue;
3382             }
3383 
3384             float bottom = nextChild-&gt;y();
3385 
3386             if (localPoint.y() &gt;= top &amp;&amp; localPoint.y() &lt; bottom &amp;&amp; is&lt;RenderBlock&gt;(*child)) {
3387                 block = downcast&lt;RenderBlock&gt;(child);
3388                 break;
3389             }
3390         }
3391 
3392         if (!block-&gt;childrenInline())
3393             return nullptr;
3394 
3395         localPoint = block-&gt;absoluteToLocal(point);
3396     }
3397 
3398     RenderBlockFlow&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*block);
3399 
3400     // Only check the gaps between the root line boxes. We deliberately ignore overflow because
3401     // experience has shown that hit tests on an exploded text node can fail when within the
3402     // overflow fragment.
3403     for (RootInlineBox* current = blockFlow.firstRootBox(); current &amp;&amp; current != blockFlow.lastRootBox(); current = current-&gt;nextRootBox()) {
3404         float currentBottom = current-&gt;y() + current-&gt;logicalHeight();
3405         if (localPoint.y() &lt; currentBottom)
3406             return nullptr;
3407 
3408         RootInlineBox* next = current-&gt;nextRootBox();
3409         float nextTop = next-&gt;y();
3410         if (localPoint.y() &lt; nextTop) {
3411             InlineBox* inlineBox = current-&gt;closestLeafChildForLogicalLeftPosition(localPoint.x());
3412             if (inlineBox &amp;&amp; inlineBox-&gt;behavesLikeText() &amp;&amp; is&lt;RenderText&gt;(inlineBox-&gt;renderer()))
3413                 return &amp;downcast&lt;RenderText&gt;(inlineBox-&gt;renderer());
3414         }
3415     }
3416     return nullptr;
3417 }
3418 
3419 VisiblePosition RenderBlockFlow::positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer* fragment)
3420 {
3421     ASSERT(childrenInline());
3422 
3423     ensureLineBoxes();
3424 
3425     if (!firstRootBox())
3426         return createVisiblePosition(0, DOWNSTREAM);
3427 
3428     bool linesAreFlipped = style().isFlippedLinesWritingMode();
3429     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
3430 
3431     // look for the closest line box in the root box which is at the passed-in y coordinate
3432     InlineBox* closestBox = 0;
3433     RootInlineBox* firstRootBoxWithChildren = 0;
3434     RootInlineBox* lastRootBoxWithChildren = 0;
3435     for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3436         if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
3437             continue;
3438 
3439         if (!root-&gt;firstLeafChild())
3440             continue;
3441         if (!firstRootBoxWithChildren)
3442             firstRootBoxWithChildren = root;
3443 
3444         if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
3445             || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;lineTopWithLeading())))
3446             break;
3447 
3448         lastRootBoxWithChildren = root;
3449 
3450         // check if this root line box is located at this y coordinate
3451         if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
3452             if (linesAreFlipped) {
3453                 RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
3454                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafChild())
3455                     nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
3456 
3457                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3458                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3459                     continue;
3460             }
3461             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3462             if (closestBox)
3463                 break;
3464         }
3465     }
3466 
3467     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3468 
3469     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3470         // y coordinate is below last root line box, pretend we hit it
3471         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3472     }
3473 
3474     if (closestBox) {
3475         if (moveCaretToBoundary) {
<a name="13" id="anc13"></a><span class="line-modified">3476             LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));</span>
3477             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3478                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
3479                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafChild();
3480                 if (box-&gt;isLineBreak()) {
3481                     if (InlineBox* newBox = box-&gt;nextLeafChildIgnoringLineBreak())
3482                         box = newBox;
3483                 }
3484                 // y coordinate is above first root line box, so return the start of the first
3485                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3486             }
3487         }
3488 
3489         // pass the box a top position that is inside it
3490         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3491         if (!isHorizontalWritingMode())
3492             point = point.transposedPoint();
3493         if (closestBox-&gt;renderer().isReplaced())
3494             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3495         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3496     }
3497 
3498     if (lastRootBoxWithChildren) {
3499         // We hit this case for Mac behavior when the Y coordinate is below the last box.
3500         ASSERT(moveCaretToBoundary);
3501         InlineBox* logicallyLastBox;
3502         if (lastRootBoxWithChildren-&gt;getLogicalEndBoxWithNode(logicallyLastBox))
3503             return VisiblePosition(positionForBox(logicallyLastBox, false), DOWNSTREAM);
3504     }
3505 
3506     // Can&#39;t reach this. We have a root line box, but it has no kids.
3507     // FIXME: This should ASSERT_NOT_REACHED(), but clicking on placeholder text
3508     // seems to hit this code path.
3509     return createVisiblePosition(0, DOWNSTREAM);
3510 }
3511 
3512 Position RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point)
3513 {
3514     // FIXME: It supports single text child only (which is the majority of simple line layout supported content at this point).
3515     if (!simpleLineLayout() || firstChild() != lastChild() || !is&lt;RenderText&gt;(firstChild()))
3516         return positionForPoint(point, nullptr).deepEquivalent();
3517     return downcast&lt;RenderText&gt;(*firstChild()).positionForPoint(point);
3518 }
3519 
3520 VisiblePosition RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
3521 {
3522     return RenderBlock::positionForPoint(point, nullptr);
3523 }
3524 
3525 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3526 {
3527     ASSERT(childrenInline());
3528     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
<a name="14" id="anc14"></a><span class="line-modified">3529         LayoutUnit top = std::max(curr-&gt;lineTop(), LayoutUnit(curr-&gt;top()));</span>
<span class="line-modified">3530         LayoutUnit bottom = std::min(curr-&gt;lineBottom(), LayoutUnit(curr-&gt;top() + curr-&gt;height()));</span>
<span class="line-modified">3531         LayoutRect rect { LayoutUnit(additionalOffset.x() + curr-&gt;x()), additionalOffset.y() + top, LayoutUnit(curr-&gt;width()), bottom - top };</span>
3532         if (!rect.isEmpty())
3533             rects.append(rect);
3534     }
3535 }
3536 
3537 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3538 {
3539     ASSERT(childrenInline());
3540 
3541     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3542         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3543         return;
3544     }
<a name="15" id="anc15"></a><span class="line-modified">3545 </span>
<span class="line-added">3546     if (m_complexLineLayout)</span>
<span class="line-added">3547         m_complexLineLayout-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
3548 }
3549 
3550 bool RenderBlockFlow::relayoutForPagination()
3551 {
3552     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3553         return false;
3554 
3555     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3556     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3557 
3558     bool needsRelayout;
3559     bool neededRelayout = false;
3560     bool firstPass = true;
3561     do {
3562         // Column heights may change here because of balancing. We may have to do multiple layout
3563         // passes, depending on how the contents is fitted to the changed column heights. In most
3564         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3565         // passes than that, though, but the number of retries should not exceed the number of
3566         // columns, unless we have a bug.
3567         needsRelayout = false;
3568         for (RenderMultiColumnSet* multicolSet = multiColumnFlow()-&gt;firstMultiColumnSet(); multicolSet; multicolSet = multicolSet-&gt;nextSiblingMultiColumnSet()) {
3569             if (multicolSet-&gt;recalculateColumnHeight(firstPass))
3570                 needsRelayout = true;
3571             if (needsRelayout) {
3572                 // Once a column set gets a new column height, that column set and all successive column
3573                 // sets need to be laid out over again, since their logical top will be affected by
3574                 // this, and therefore their column heights may change as well, at least if the multicol
3575                 // height is constrained.
3576                 multicolSet-&gt;setChildNeedsLayout(MarkOnlyThis);
3577             }
3578         }
3579         if (needsRelayout) {
3580             // Layout again. Column balancing resulted in a new height.
3581             neededRelayout = true;
3582             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3583             setChildNeedsLayout(MarkOnlyThis);
3584             layoutBlock(false);
3585         }
3586         firstPass = false;
3587     } while (needsRelayout);
3588 
3589     multiColumnFlow()-&gt;setInBalancingPass(false);
3590 
3591     return neededRelayout;
3592 }
3593 
3594 bool RenderBlockFlow::hasLines() const
3595 {
3596     if (!childrenInline())
3597         return false;
3598 
3599     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3600         return simpleLineLayout-&gt;lineCount();
3601 
<a name="16" id="anc16"></a><span class="line-modified">3602     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().firstLineBox();</span>
3603 }
3604 
3605 void RenderBlockFlow::invalidateLineLayoutPath()
3606 {
3607     switch (lineLayoutPath()) {
3608     case UndeterminedPath:
3609     case ForceLineBoxesPath:
3610         ASSERT(!m_simpleLineLayout);
3611         return;
3612     case LineBoxesPath:
3613         ASSERT(!m_simpleLineLayout);
3614         setLineLayoutPath(UndeterminedPath);
3615         return;
3616     case SimpleLinesPath:
3617         // The simple line layout may have become invalid.
3618         m_simpleLineLayout = nullptr;
3619         setLineLayoutPath(UndeterminedPath);
3620         if (needsLayout())
3621             return;
3622         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3623         setNeedsLayout();
3624         return;
3625     }
3626     ASSERT_NOT_REACHED();
3627 }
3628 
3629 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3630 {
3631     bool needsLayout = selfNeedsLayout() || relayoutChildren || !m_simpleLineLayout;
3632     if (needsLayout) {
3633         deleteLineBoxesBeforeSimpleLineLayout();
3634         m_simpleLineLayout = SimpleLineLayout::create(*this);
3635     }
3636     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
3637         m_simpleLineLayout-&gt;setIsPaginated();
3638         SimpleLineLayout::adjustLinePositionsForPagination(*m_simpleLineLayout, *this);
3639     }
3640     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3641         renderer.clearNeedsLayout();
<a name="17" id="anc17"></a><span class="line-modified">3642     ASSERT(!m_complexLineLayout);</span>
3643     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, *m_simpleLineLayout);
3644     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3645     repaintLogicalTop = lineLayoutTop;
3646     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3647     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3648 }
3649 
3650 void RenderBlockFlow::deleteLineBoxesBeforeSimpleLineLayout()
3651 {
3652     ASSERT(lineLayoutPath() == SimpleLinesPath);
<a name="18" id="anc18"></a><span class="line-modified">3653 </span>
<span class="line-added">3654     if (m_complexLineLayout)</span>
<span class="line-added">3655         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
<span class="line-added">3656 </span>
3657     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this)) {
3658         if (is&lt;RenderText&gt;(renderer))
3659             downcast&lt;RenderText&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3660         else if (is&lt;RenderLineBreak&gt;(renderer))
3661             downcast&lt;RenderLineBreak&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();
3662         else
3663             ASSERT_NOT_REACHED();
3664     }
<a name="19" id="anc19"></a><span class="line-added">3665 </span>
<span class="line-added">3666     m_complexLineLayout = nullptr;</span>
3667 }
3668 
3669 void RenderBlockFlow::ensureLineBoxes()
3670 {
<a name="20" id="anc20"></a><span class="line-added">3671     if (!childrenInline())</span>
<span class="line-added">3672         return;</span>
<span class="line-added">3673 </span>
3674     setLineLayoutPath(ForceLineBoxesPath);
<a name="21" id="anc21"></a><span class="line-added">3675 </span>
3676     if (!m_simpleLineLayout)
3677         return;
3678 
<a name="22" id="anc22"></a><span class="line-added">3679     ASSERT(!m_complexLineLayout);</span>
<span class="line-added">3680     m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-added">3681 </span>
3682     if (SimpleLineLayout::canUseForLineBoxTree(*this, *m_simpleLineLayout)) {
3683         SimpleLineLayout::generateLineBoxTree(*this, *m_simpleLineLayout);
3684         m_simpleLineLayout = nullptr;
3685         return;
3686     }
3687     bool isPaginated = m_simpleLineLayout-&gt;isPaginated();
3688     m_simpleLineLayout = nullptr;
3689 
3690 #if !ASSERT_DISABLED
3691     LayoutUnit oldHeight = logicalHeight();
3692 #endif
3693     bool didNeedLayout = needsLayout();
3694 
3695     bool relayoutChildren = false;
3696     LayoutUnit repaintLogicalTop;
3697     LayoutUnit repaintLogicalBottom;
3698     if (isPaginated) {
3699         PaginatedLayoutStateMaintainer state(*this);
<a name="23" id="anc23"></a><span class="line-modified">3700         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3701         // This matches relayoutToAvoidWidows.
3702         if (shouldBreakAtLineToAvoidWidow())
<a name="24" id="anc24"></a><span class="line-modified">3703             m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3704         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3705         repaint();
3706     } else
<a name="25" id="anc25"></a><span class="line-modified">3707         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3708 
3709     updateLogicalHeight();
3710     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3711 
3712     if (!didNeedLayout)
3713         clearNeedsLayout();
3714 }
3715 
3716 #if ENABLE(TREE_DEBUGGING)
3717 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3718 {
3719     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3720         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3721 
3722     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3723         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3724 }
3725 #endif
3726 
3727 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
3728 {
3729     if (hasRareBlockFlowData())
3730         return *m_rareBlockFlowData;
3731     materializeRareBlockFlowData();
3732     return *m_rareBlockFlowData;
3733 }
3734 
3735 void RenderBlockFlow::materializeRareBlockFlowData()
3736 {
3737     ASSERT(!hasRareBlockFlowData());
<a name="26" id="anc26"></a><span class="line-modified">3738     m_rareBlockFlowData = makeUnique&lt;RenderBlockFlow::RenderBlockFlowRareData&gt;(*this);</span>
3739 }
3740 
3741 #if ENABLE(TEXT_AUTOSIZING)
3742 
3743 static inline bool isVisibleRenderText(const RenderObject&amp; renderer)
3744 {
3745     if (!is&lt;RenderText&gt;(renderer))
3746         return false;
3747 
3748     auto&amp; renderText = downcast&lt;RenderText&gt;(renderer);
3749     return !renderText.linesBoundingBox().isEmpty() &amp;&amp; !renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
3750 }
3751 
3752 static inline bool resizeTextPermitted(const RenderObject&amp; renderer)
3753 {
3754     // We disallow resizing for text input fields and textarea to address &lt;rdar://problem/5792987&gt; and &lt;rdar://problem/8021123&gt;
3755     for (auto* ancestor = renderer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3756         // Get the first non-shadow HTMLElement and see if it&#39;s an input.
3757         if (is&lt;HTMLElement&gt;(ancestor-&gt;element()) &amp;&amp; !ancestor-&gt;element()-&gt;isInShadowTree()) {
3758             auto&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;element());
3759             return !is&lt;HTMLInputElement&gt;(element) &amp;&amp; !is&lt;HTMLTextAreaElement&gt;(element);
3760         }
3761     }
3762     return true;
3763 }
3764 
3765 int RenderBlockFlow::lineCountForTextAutosizing()
3766 {
3767     if (style().visibility() != Visibility::Visible)
3768         return 0;
3769     if (childrenInline())
3770         return lineCount();
3771     // Only descend into list items.
3772     int count = 0;
3773     for (auto&amp; listItem : childrenOfType&lt;RenderListItem&gt;(*this))
3774         count += listItem.lineCount();
3775     return count;
3776 }
3777 
3778 static bool isNonBlocksOrNonFixedHeightListItems(const RenderObject&amp; renderer)
3779 {
3780     if (!renderer.isRenderBlock())
3781         return true;
3782     if (renderer.isListItem())
3783         return renderer.style().height().type() != Fixed;
3784     return false;
3785 }
3786 
3787 // For now, we auto size single lines of text the same as multiple lines.
3788 // We&#39;ve been experimenting with low values for single lines of text.
3789 static inline float oneLineTextMultiplier(RenderObject&amp; renderer, float specifiedSize)
3790 {
3791     const float coefficient = renderer.settings().oneLineTextMultiplierCoefficient();
3792     return std::max((1.0f / log10f(specifiedSize) * coefficient), 1.0f);
3793 }
3794 
3795 static inline float textMultiplier(RenderObject&amp; renderer, float specifiedSize)
3796 {
3797     const float coefficient = renderer.settings().multiLineTextMultiplierCoefficient();
3798     return std::max((1.0f / log10f(specifiedSize) * coefficient), 1.0f);
3799 }
3800 
3801 void RenderBlockFlow::adjustComputedFontSizes(float size, float visibleWidth)
3802 {
3803     LOG(TextAutosizing, &quot;RenderBlockFlow %p adjustComputedFontSizes, size=%f visibleWidth=%f, width()=%f. Bailing: %d&quot;, this, size, visibleWidth, width().toFloat(), visibleWidth &gt;= width());
3804 
3805     // Don&#39;t do any work if the block is smaller than the visible area.
3806     if (visibleWidth &gt;= width())
3807         return;
3808 
3809     unsigned lineCount;
3810     if (m_lineCountForTextAutosizing == NOT_SET) {
3811         int count = lineCountForTextAutosizing();
3812         if (!count)
3813             lineCount = NO_LINE;
3814         else if (count == 1)
3815             lineCount = ONE_LINE;
3816         else
3817             lineCount = MULTI_LINE;
3818     } else
3819         lineCount = m_lineCountForTextAutosizing;
3820 
3821     ASSERT(lineCount != NOT_SET);
3822     if (lineCount == NO_LINE)
3823         return;
3824 
3825     float actualWidth = m_widthForTextAutosizing != -1 ? static_cast&lt;float&gt;(m_widthForTextAutosizing) : static_cast&lt;float&gt;(width());
3826     float scale = visibleWidth / actualWidth;
3827     float minFontSize = roundf(size / scale);
3828 
3829     for (auto* descendant = RenderObjectTraversal::firstChild(*this); descendant; ) {
3830         if (!isNonBlocksOrNonFixedHeightListItems(*descendant)) {
3831             descendant = RenderObjectTraversal::nextSkippingChildren(*descendant, this);
3832             continue;
3833         }
3834         if (!isVisibleRenderText(*descendant) || !resizeTextPermitted(*descendant)) {
3835             descendant = RenderObjectTraversal::next(*descendant, this);
3836             continue;
3837         }
3838 
3839         auto&amp; text = downcast&lt;RenderText&gt;(*descendant);
3840         auto&amp; oldStyle = text.style();
3841         auto&amp; fontDescription = oldStyle.fontDescription();
3842         float specifiedSize = fontDescription.specifiedSize();
3843         float scaledSize = roundf(specifiedSize * scale);
3844         if (scaledSize &gt; 0 &amp;&amp; scaledSize &lt; minFontSize) {
3845             // Record the width of the block and the line count the first time we resize text and use it from then on for text resizing.
3846             // This makes text resizing consistent even if the block&#39;s width or line count changes (which can be caused by text resizing itself 5159915).
3847             if (m_lineCountForTextAutosizing == NOT_SET)
3848                 m_lineCountForTextAutosizing = lineCount;
3849             if (m_widthForTextAutosizing == -1)
3850                 m_widthForTextAutosizing = actualWidth;
3851 
3852             float lineTextMultiplier = lineCount == ONE_LINE ? oneLineTextMultiplier(text, specifiedSize) : textMultiplier(text, specifiedSize);
3853             float candidateNewSize = roundf(std::min(minFontSize, specifiedSize * lineTextMultiplier));
<a name="27" id="anc27"></a><span class="line-added">3854 </span>
3855             if (candidateNewSize &gt; specifiedSize &amp;&amp; candidateNewSize != fontDescription.computedSize() &amp;&amp; text.textNode() &amp;&amp; oldStyle.textSizeAdjust().isAuto())
3856                 document().textAutoSizing().addTextNode(*text.textNode(), candidateNewSize);
3857         }
3858 
3859         descendant = RenderObjectTraversal::nextSkippingChildren(text, this);
3860     }
3861 }
3862 
3863 #endif // ENABLE(TEXT_AUTOSIZING)
3864 
3865 void RenderBlockFlow::layoutExcludedChildren(bool relayoutChildren)
3866 {
3867     RenderBlock::layoutExcludedChildren(relayoutChildren);
3868 
3869     auto* fragmentedFlow = multiColumnFlow();
3870     if (!fragmentedFlow)
3871         return;
3872 
3873     fragmentedFlow-&gt;setIsExcludedFromNormalLayout(true);
3874 
3875     setLogicalTopForChild(*fragmentedFlow, borderAndPaddingBefore());
3876 
3877     if (relayoutChildren)
3878         fragmentedFlow-&gt;setChildNeedsLayout(MarkOnlyThis);
3879 
3880     if (fragmentedFlow-&gt;needsLayout()) {
3881         for (RenderMultiColumnSet* columnSet = fragmentedFlow-&gt;firstMultiColumnSet(); columnSet; columnSet = columnSet-&gt;nextSiblingMultiColumnSet())
3882             columnSet-&gt;prepareForLayout(!fragmentedFlow-&gt;inBalancingPass());
3883 
3884         fragmentedFlow-&gt;invalidateFragments(MarkOnlyThis);
3885         fragmentedFlow-&gt;setNeedsHeightsRecalculation(true);
3886         fragmentedFlow-&gt;layout();
3887     } else {
3888         // At the end of multicol layout, relayoutForPagination() is called unconditionally, but if
3889         // no children are to be laid out (e.g. fixed width with layout already being up-to-date),
3890         // we want to prevent it from doing any work, so that the column balancing machinery doesn&#39;t
3891         // kick in and trigger additional unnecessary layout passes. Actually, it&#39;s not just a good
3892         // idea in general to not waste time on balancing content that hasn&#39;t been re-laid out; we
3893         // are actually required to guarantee this. The calculation of implicit breaks needs to be
3894         // preceded by a proper layout pass, since it&#39;s layout that sets up content runs, and the
3895         // runs get deleted right after every pass.
3896         fragmentedFlow-&gt;setNeedsHeightsRecalculation(false);
3897     }
3898     determineLogicalLeftPositionForChild(*fragmentedFlow);
3899 }
3900 
3901 void RenderBlockFlow::checkForPaginationLogicalHeightChange(bool&amp; relayoutChildren, LayoutUnit&amp; pageLogicalHeight, bool&amp; pageLogicalHeightChanged)
3902 {
3903     // If we don&#39;t use columns or flow threads, then bail.
3904     if (!isRenderFragmentedFlow() &amp;&amp; !multiColumnFlow())
3905         return;
3906 
3907     // We don&#39;t actually update any of the variables. We just subclassed to adjust our column height.
3908     if (RenderMultiColumnFlow* fragmentedFlow = multiColumnFlow()) {
3909         LayoutUnit newColumnHeight;
3910         if (hasDefiniteLogicalHeight() || view().frameView().pagination().mode != Pagination::Unpaginated) {
3911             auto computedValues = computeLogicalHeight(0_lu, logicalTop());
3912             newColumnHeight = std::max&lt;LayoutUnit&gt;(computedValues.m_extent - borderAndPaddingLogicalHeight() - scrollbarLogicalHeight(), 0);
3913             if (fragmentedFlow-&gt;columnHeightAvailable() != newColumnHeight)
3914                 relayoutChildren = true;
3915         }
3916         fragmentedFlow-&gt;setColumnHeightAvailable(newColumnHeight);
3917     } else if (is&lt;RenderFragmentedFlow&gt;(*this)) {
3918         RenderFragmentedFlow&amp; fragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(*this);
3919 
3920         // FIXME: This is a hack to always make sure we have a page logical height, if said height
3921         // is known. The page logical height thing in RenderLayoutState is meaningless for flow
3922         // thread-based pagination (page height isn&#39;t necessarily uniform throughout the flow
3923         // thread), but as long as it is used universally as a means to determine whether page
3924         // height is known or not, we need this. Page height is unknown when column balancing is
3925         // enabled and flow thread height is still unknown (i.e. during the first layout pass). When
3926         // it&#39;s unknown, we need to prevent the pagination code from assuming page breaks everywhere
3927         // and thereby eating every top margin. It should be trivial to clean up and get rid of this
3928         // hack once the old multicol implementation is gone (see also RenderView::pushLayoutStateForPagination).
3929         pageLogicalHeight = fragmentedFlow.isPageLogicalHeightKnown() ? 1_lu : 0_lu;
3930 
3931         pageLogicalHeightChanged = fragmentedFlow.pageLogicalSizeChanged();
3932     }
3933 }
3934 
3935 bool RenderBlockFlow::requiresColumns(int desiredColumnCount) const
3936 {
3937     return willCreateColumns(desiredColumnCount);
3938 }
3939 
3940 void RenderBlockFlow::setComputedColumnCountAndWidth(int count, LayoutUnit width)
3941 {
3942     ASSERT(!!multiColumnFlow() == requiresColumns(count));
3943     if (!multiColumnFlow())
3944         return;
3945     multiColumnFlow()-&gt;setColumnCountAndWidth(count, width);
3946     multiColumnFlow()-&gt;setProgressionIsInline(style().hasInlineColumnAxis());
3947     multiColumnFlow()-&gt;setProgressionIsReversed(style().columnProgression() == ColumnProgression::Reverse);
3948 }
3949 
3950 void RenderBlockFlow::updateColumnProgressionFromStyle(RenderStyle&amp; style)
3951 {
3952     if (!multiColumnFlow())
3953         return;
3954 
3955     bool needsLayout = false;
3956     bool oldProgressionIsInline = multiColumnFlow()-&gt;progressionIsInline();
3957     bool newProgressionIsInline = style.hasInlineColumnAxis();
3958     if (oldProgressionIsInline != newProgressionIsInline) {
3959         multiColumnFlow()-&gt;setProgressionIsInline(newProgressionIsInline);
3960         needsLayout = true;
3961     }
3962 
3963     bool oldProgressionIsReversed = multiColumnFlow()-&gt;progressionIsReversed();
3964     bool newProgressionIsReversed = style.columnProgression() == ColumnProgression::Reverse;
3965     if (oldProgressionIsReversed != newProgressionIsReversed) {
3966         multiColumnFlow()-&gt;setProgressionIsReversed(newProgressionIsReversed);
3967         needsLayout = true;
3968     }
3969 
3970     if (needsLayout)
3971         setNeedsLayoutAndPrefWidthsRecalc();
3972 }
3973 
3974 LayoutUnit RenderBlockFlow::computedColumnWidth() const
3975 {
3976     if (multiColumnFlow())
3977         return multiColumnFlow()-&gt;computedColumnWidth();
3978     return contentLogicalWidth();
3979 }
3980 
3981 unsigned RenderBlockFlow::computedColumnCount() const
3982 {
3983     if (multiColumnFlow())
3984         return multiColumnFlow()-&gt;computedColumnCount();
3985 
3986     return 1;
3987 }
3988 
3989 bool RenderBlockFlow::isTopLayoutOverflowAllowed() const
3990 {
3991     bool hasTopOverflow = RenderBlock::isTopLayoutOverflowAllowed();
3992     if (!multiColumnFlow() || style().columnProgression() == ColumnProgression::Normal)
3993         return hasTopOverflow;
3994 
3995     if (!(isHorizontalWritingMode() ^ !style().hasInlineColumnAxis()))
3996         hasTopOverflow = !hasTopOverflow;
3997 
3998     return hasTopOverflow;
3999 }
4000 
4001 bool RenderBlockFlow::isLeftLayoutOverflowAllowed() const
4002 {
4003     bool hasLeftOverflow = RenderBlock::isLeftLayoutOverflowAllowed();
4004     if (!multiColumnFlow() || style().columnProgression() == ColumnProgression::Normal)
4005         return hasLeftOverflow;
4006 
4007     if (isHorizontalWritingMode() ^ !style().hasInlineColumnAxis())
4008         hasLeftOverflow = !hasLeftOverflow;
4009 
4010     return hasLeftOverflow;
4011 }
4012 
4013 struct InlineMinMaxIterator {
4014 /* InlineMinMaxIterator is a class that will iterate over all render objects that contribute to
4015    inline min/max width calculations.  Note the following about the way it walks:
4016    (1) Positioned content is skipped (since it does not contribute to min/max width of a block)
4017    (2) We do not drill into the children of floats or replaced elements, since you can&#39;t break
4018        in the middle of such an element.
4019    (3) Inline flows (e.g., &lt;a&gt;, &lt;span&gt;, &lt;i&gt;) are walked twice, since each side can have
4020        distinct borders/margin/padding that contribute to the min/max width.
4021 */
4022     const RenderBlockFlow&amp; parent;
4023     RenderObject* current;
4024     bool endOfInline;
4025     bool initial;
4026 
4027     InlineMinMaxIterator(const RenderBlockFlow&amp; p)
4028         : parent(p)
4029         , current(nullptr)
4030         , endOfInline(false)
4031         , initial(true)
4032         { }
4033 
4034     RenderObject* next();
4035 };
4036 
4037 RenderObject* InlineMinMaxIterator::next()
4038 {
4039     RenderObject* result = nullptr;
4040     bool oldEndOfInline = endOfInline;
4041     endOfInline = false;
4042     do {
4043         if (!oldEndOfInline &amp;&amp; (current &amp;&amp; !current-&gt;isFloating() &amp;&amp; !current-&gt;isReplaced() &amp;&amp; !current-&gt;isOutOfFlowPositioned()))
4044             result = current-&gt;firstChildSlow();
4045         else if (initial) {
4046             result = parent.firstChild();
4047             initial = false;
4048         }
4049 
4050         if (!result) {
4051             // We hit the end of our inline. (It was empty, e.g., &lt;span&gt;&lt;/span&gt;.)
4052             if (!oldEndOfInline &amp;&amp; current &amp;&amp; current-&gt;isRenderInline()) {
4053                 result = current;
4054                 endOfInline = true;
4055                 break;
4056             }
4057 
4058             while (current &amp;&amp; current != &amp;parent) {
4059                 result = current-&gt;nextSibling();
4060                 if (result)
4061                     break;
4062                 current = current-&gt;parent();
4063                 if (current &amp;&amp; current != &amp;parent &amp;&amp; current-&gt;isRenderInline()) {
4064                     result = current;
4065                     endOfInline = true;
4066                     break;
4067                 }
4068             }
4069         }
4070 
4071         if (!result)
4072             break;
4073 
4074         if (!result-&gt;isOutOfFlowPositioned() &amp;&amp; (result-&gt;isTextOrLineBreak() || result-&gt;isFloating() || result-&gt;isReplaced() || result-&gt;isRenderInline()))
4075             break;
4076 
4077         current = result;
4078         result = nullptr;
4079     } while (current || current == &amp;parent);
4080     // Update our position.
4081     current = result;
4082     return result;
4083 }
4084 
4085 static LayoutUnit getBPMWidth(LayoutUnit childValue, Length cssUnit)
4086 {
4087     if (cssUnit.type() != Auto)
4088         return (cssUnit.isFixed() ? LayoutUnit(cssUnit.value()) : childValue);
4089     return 0;
4090 }
4091 
4092 static LayoutUnit getBorderPaddingMargin(const RenderBoxModelObject&amp; child, bool endOfInline)
4093 {
4094     const RenderStyle&amp; childStyle = child.style();
4095     if (endOfInline) {
4096         return getBPMWidth(child.marginEnd(), childStyle.marginEnd()) +
4097                getBPMWidth(child.paddingEnd(), childStyle.paddingEnd()) +
4098                child.borderEnd();
4099     }
4100     return getBPMWidth(child.marginStart(), childStyle.marginStart()) +
4101                getBPMWidth(child.paddingStart(), childStyle.paddingStart()) +
4102                child.borderStart();
4103 }
4104 
4105 static inline void stripTrailingSpace(float&amp; inlineMax, float&amp; inlineMin, RenderObject* trailingSpaceChild)
4106 {
4107     if (is&lt;RenderText&gt;(trailingSpaceChild)) {
4108         // Collapse away the trailing space at the end of a block.
4109         RenderText&amp; renderText = downcast&lt;RenderText&gt;(*trailingSpaceChild);
4110         const UChar space = &#39; &#39;;
4111         const FontCascade&amp; font = renderText.style().fontCascade(); // FIXME: This ignores first-line.
4112         float spaceWidth = font.width(RenderBlock::constructTextRun(&amp;space, 1, renderText.style()));
4113         inlineMax -= spaceWidth + font.wordSpacing();
4114         if (inlineMin &gt; inlineMax)
4115             inlineMin = inlineMax;
4116     }
4117 }
4118 
4119 static inline LayoutUnit preferredWidth(LayoutUnit preferredWidth, float result)
4120 {
4121     return std::max(preferredWidth, LayoutUnit::fromFloatCeil(result));
4122 }
4123 
4124 void RenderBlockFlow::computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
4125 {
4126     float inlineMax = 0;
4127     float inlineMin = 0;
4128 
4129     const RenderStyle&amp; styleToUse = style();
4130     RenderBlock* containingBlock = this-&gt;containingBlock();
4131     LayoutUnit cw = containingBlock ? containingBlock-&gt;contentLogicalWidth() : 0_lu;
4132 
4133     // If we are at the start of a line, we want to ignore all white-space.
4134     // Also strip spaces if we previously had text that ended in a trailing space.
4135     bool stripFrontSpaces = true;
4136     RenderObject* trailingSpaceChild = nullptr;
4137 
4138     // Firefox and Opera will allow a table cell to grow to fit an image inside it under
4139     // very specific cirucumstances (in order to match common WinIE renderings).
4140     // Not supporting the quirk has caused us to mis-render some real sites. (See Bugzilla 10517.)
4141     bool allowImagesToBreak = !document().inQuirksMode() || !isTableCell() || !styleToUse.logicalWidth().isIntrinsicOrAuto();
4142 
4143     bool oldAutoWrap = styleToUse.autoWrap();
4144 
4145     InlineMinMaxIterator childIterator(*this);
4146 
4147     // Only gets added to the max preffered width once.
4148     bool addedTextIndent = false;
4149     // Signals the text indent was more negative than the min preferred width
4150     bool hasRemainingNegativeTextIndent = false;
4151 
4152     LayoutUnit textIndent = minimumValueForLength(styleToUse.textIndent(), cw);
4153     RenderObject* prevFloat = 0;
4154     bool isPrevChildInlineFlow = false;
4155     bool shouldBreakLineAfterText = false;
4156     bool canHangPunctuationAtStart = styleToUse.hangingPunctuation().contains(HangingPunctuation::First);
4157     bool canHangPunctuationAtEnd = styleToUse.hangingPunctuation().contains(HangingPunctuation::Last);
4158     RenderText* lastText = nullptr;
4159 
4160     bool addedStartPunctuationHang = false;
4161 
4162     while (RenderObject* child = childIterator.next()) {
4163         bool autoWrap = child-&gt;isReplaced() ? child-&gt;parent()-&gt;style().autoWrap() :
4164             child-&gt;style().autoWrap();
4165         if (!child-&gt;isBR()) {
4166             // Step One: determine whether or not we need to terminate our current line.
4167             // Each discrete chunk can become the new min-width, if it is the widest chunk
4168             // seen so far, and it can also become the max-width.
4169 
4170             // Children fall into three categories:
4171             // (1) An inline flow object. These objects always have a min/max of 0,
4172             // and are included in the iteration solely so that their margins can
4173             // be added in.
4174             //
4175             // (2) An inline non-text non-flow object, e.g., an inline replaced element.
4176             // These objects can always be on a line by themselves, so in this situation
4177             // we need to break the current line, and then add in our own margins and min/max
4178             // width on its own line, and then terminate the line.
4179             //
4180             // (3) A text object. Text runs can have breakable characters at the start,
4181             // the middle or the end. They may also lose whitespace off the front if
4182             // we&#39;re already ignoring whitespace. In order to compute accurate min-width
4183             // information, we need three pieces of information.
4184             // (a) the min-width of the first non-breakable run. Should be 0 if the text string
4185             // starts with whitespace.
4186             // (b) the min-width of the last non-breakable run. Should be 0 if the text string
4187             // ends with whitespace.
4188             // (c) the min/max width of the string (trimmed for whitespace).
4189             //
4190             // If the text string starts with whitespace, then we need to terminate our current line
4191             // (unless we&#39;re already in a whitespace stripping mode.
4192             //
4193             // If the text string has a breakable character in the middle, but didn&#39;t start
4194             // with whitespace, then we add the width of the first non-breakable run and
4195             // then end the current line. We then need to use the intermediate min/max width
4196             // values (if any of them are larger than our current min/max). We then look at
4197             // the width of the last non-breakable run and use that to start a new line
4198             // (unless we end in whitespace).
4199             const RenderStyle&amp; childStyle = child-&gt;style();
4200             float childMin = 0;
4201             float childMax = 0;
4202 
4203             if (!child-&gt;isText()) {
4204                 if (child-&gt;isLineBreakOpportunity()) {
4205                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4206                     inlineMin = 0;
4207                     continue;
4208                 }
4209                 // Case (1) and (2). Inline replaced and inline flow elements.
4210                 if (is&lt;RenderInline&gt;(*child)) {
4211                     // Add in padding/border/margin from the appropriate side of
4212                     // the element.
4213                     float bpm = getBorderPaddingMargin(downcast&lt;RenderInline&gt;(*child), childIterator.endOfInline);
4214                     childMin += bpm;
4215                     childMax += bpm;
4216 
4217                     inlineMin += childMin;
4218                     inlineMax += childMax;
4219 
4220                     child-&gt;setPreferredLogicalWidthsDirty(false);
4221                 } else {
4222                     // Inline replaced elts add in their margins to their min/max values.
4223                     if (!child-&gt;isFloating())
4224                         lastText = nullptr;
4225                     LayoutUnit margins;
4226                     Length startMargin = childStyle.marginStart();
4227                     Length endMargin = childStyle.marginEnd();
4228                     if (startMargin.isFixed())
4229                         margins += LayoutUnit::fromFloatCeil(startMargin.value());
4230                     if (endMargin.isFixed())
4231                         margins += LayoutUnit::fromFloatCeil(endMargin.value());
4232                     childMin += margins.ceilToFloat();
4233                     childMax += margins.ceilToFloat();
4234                 }
4235             }
4236 
4237             if (!is&lt;RenderInline&gt;(*child) &amp;&amp; !is&lt;RenderText&gt;(*child)) {
4238                 // Case (2). Inline replaced elements and floats.
4239                 // Terminate the current line as far as minwidth is concerned.
4240                 LayoutUnit childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth;
4241                 computeChildPreferredLogicalWidths(*child, childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth);
4242                 childMin += childMinPreferredLogicalWidth.ceilToFloat();
4243                 childMax += childMaxPreferredLogicalWidth.ceilToFloat();
4244 
4245                 bool clearPreviousFloat;
4246                 if (child-&gt;isFloating()) {
4247                     clearPreviousFloat = (prevFloat
4248                         &amp;&amp; ((prevFloat-&gt;style().floating() == Float::Left &amp;&amp; (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both))
4249                             || (prevFloat-&gt;style().floating() == Float::Right &amp;&amp; (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both))));
4250                     prevFloat = child;
4251                 } else
4252                     clearPreviousFloat = false;
4253 
4254                 bool canBreakReplacedElement = !child-&gt;isImage() || allowImagesToBreak;
4255                 if (((canBreakReplacedElement &amp;&amp; (autoWrap || oldAutoWrap) &amp;&amp; (!isPrevChildInlineFlow || shouldBreakLineAfterText)) || clearPreviousFloat)) {
4256                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4257                     inlineMin = 0;
4258                 }
4259 
4260                 // If we&#39;re supposed to clear the previous float, then terminate maxwidth as well.
4261                 if (clearPreviousFloat) {
4262                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4263                     inlineMax = 0;
4264                 }
4265 
4266                 // Add in text-indent. This is added in only once.
4267                 if (!addedTextIndent &amp;&amp; !child-&gt;isFloating()) {
<a name="28" id="anc28"></a><span class="line-modified">4268                     LayoutUnit ceiledIndent { textIndent.ceilToFloat() };</span>
4269                     childMin += ceiledIndent;
4270                     childMax += ceiledIndent;
4271 
4272                     if (childMin &lt; 0)
4273                         textIndent = LayoutUnit::fromFloatCeil(childMin);
4274                     else
4275                         addedTextIndent = true;
4276                 }
4277 
4278                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang &amp;&amp; !child-&gt;isFloating())
4279                     addedStartPunctuationHang = true;
4280 
4281                 // Add our width to the max.
4282                 inlineMax += std::max&lt;float&gt;(0, childMax);
4283 
4284                 if ((!autoWrap || !canBreakReplacedElement || (isPrevChildInlineFlow &amp;&amp; !shouldBreakLineAfterText))) {
4285                     if (child-&gt;isFloating())
4286                         minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4287                     else
4288                         inlineMin += childMin;
4289                 } else {
4290                     // Now check our line.
4291                     minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4292 
4293                     // Now start a new line.
4294                     inlineMin = 0;
4295                 }
4296 
4297                 if (autoWrap &amp;&amp; canBreakReplacedElement &amp;&amp; isPrevChildInlineFlow) {
4298                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4299                     inlineMin = 0;
4300                 }
4301 
4302                 // We are no longer stripping whitespace at the start of a line.
4303                 if (!child-&gt;isFloating()) {
4304                     stripFrontSpaces = false;
4305                     trailingSpaceChild = nullptr;
4306                     lastText = nullptr;
4307                 }
4308             } else if (is&lt;RenderText&gt;(*child)) {
4309                 // Case (3). Text.
4310                 RenderText&amp; renderText = downcast&lt;RenderText&gt;(*child);
4311 
4312                 if (renderText.style().hasTextCombine() &amp;&amp; renderText.isCombineText())
4313                     downcast&lt;RenderCombineText&gt;(renderText).combineTextIfNeeded();
4314 
4315                 // Determine if we have a breakable character. Pass in
4316                 // whether or not we should ignore any spaces at the front
4317                 // of the string. If those are going to be stripped out,
4318                 // then they shouldn&#39;t be considered in the breakable char
4319                 // check.
4320                 bool strippingBeginWS = stripFrontSpaces;
4321                 auto widths = renderText.trimmedPreferredWidths(inlineMax, stripFrontSpaces);
4322 
4323                 childMin = widths.min;
4324                 childMax = widths.max;
4325 
4326                 // This text object will not be rendered, but it may still provide a breaking opportunity.
4327                 if (!widths.hasBreak &amp;&amp; !childMax) {
4328                     if (autoWrap &amp;&amp; (widths.beginWS || widths.endWS)) {
4329                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4330                         inlineMin = 0;
4331                     }
4332                     continue;
4333                 }
4334 
4335                 lastText = &amp;renderText;
4336 
4337                 if (stripFrontSpaces)
4338                     trailingSpaceChild = child;
4339                 else
4340                     trailingSpaceChild = 0;
4341 
4342                 // Add in text-indent. This is added in only once.
4343                 float ti = 0;
4344                 if (!addedTextIndent || hasRemainingNegativeTextIndent) {
4345                     ti = textIndent.ceilToFloat();
4346                     childMin += ti;
4347                     widths.beginMin += ti;
4348 
4349                     // It the text indent negative and larger than the child minimum, we re-use the remainder
4350                     // in future minimum calculations, but using the negative value again on the maximum
4351                     // will lead to under-counting the max pref width.
4352                     if (!addedTextIndent) {
4353                         childMax += ti;
4354                         widths.beginMax += ti;
4355                         addedTextIndent = true;
4356                     }
4357 
4358                     if (childMin &lt; 0) {
4359                         textIndent = childMin;
4360                         hasRemainingNegativeTextIndent = true;
4361                     }
4362                 }
4363 
4364                 // See if we have a hanging punctuation situation at the start.
4365                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang) {
4366                     unsigned startIndex = strippingBeginWS ? renderText.firstCharacterIndexStrippingSpaces() : 0;
4367                     float hangStartWidth = renderText.hangablePunctuationStartWidth(startIndex);
4368                     childMin -= hangStartWidth;
4369                     widths.beginMin -= hangStartWidth;
4370                     childMax -= hangStartWidth;
4371                     widths.beginMax -= hangStartWidth;
4372                     addedStartPunctuationHang = true;
4373                 }
4374 
4375                 // If we have no breakable characters at all,
4376                 // then this is the easy case. We add ourselves to the current
4377                 // min and max and continue.
4378                 if (!widths.hasBreakableChar)
4379                     inlineMin += childMin;
4380                 else {
4381                     // We have a breakable character. Now we need to know if
4382                     // we start and end with whitespace.
4383                     if (widths.beginWS) {
4384                         // End the current line.
4385                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4386                     } else {
4387                         inlineMin += widths.beginMin;
4388                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4389                         childMin -= ti;
4390                     }
4391 
4392                     inlineMin = childMin;
4393 
4394                     if (widths.endWS) {
4395                         // We end in whitespace, which means we can end our current line.
4396                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4397                         inlineMin = 0;
4398                         shouldBreakLineAfterText = false;
4399                     } else {
4400                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4401                         inlineMin = widths.endMin;
4402                         shouldBreakLineAfterText = true;
4403                     }
4404                 }
4405 
4406                 if (widths.hasBreak) {
4407                     inlineMax += widths.beginMax;
4408                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4409                     maxLogicalWidth = preferredWidth(maxLogicalWidth, childMax);
4410                     inlineMax = widths.endMax;
4411                     addedTextIndent = true;
4412                     addedStartPunctuationHang = true;
4413                 } else
4414                     inlineMax += std::max&lt;float&gt;(0, childMax);
4415             }
4416 
4417             // Ignore spaces after a list marker.
4418             if (child-&gt;isListMarker())
4419                 stripFrontSpaces = true;
4420         } else {
4421             minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4422             maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4423             inlineMin = inlineMax = 0;
4424             stripFrontSpaces = true;
4425             trailingSpaceChild = 0;
4426             addedTextIndent = true;
4427             addedStartPunctuationHang = true;
4428         }
4429 
4430         if (!child-&gt;isText() &amp;&amp; child-&gt;isRenderInline())
4431             isPrevChildInlineFlow = true;
4432         else
4433             isPrevChildInlineFlow = false;
4434 
4435         oldAutoWrap = autoWrap;
4436     }
4437 
4438     if (styleToUse.collapseWhiteSpace())
4439         stripTrailingSpace(inlineMax, inlineMin, trailingSpaceChild);
4440 
4441     if (canHangPunctuationAtEnd &amp;&amp; lastText &amp;&amp; lastText-&gt;text().length() &gt; 0) {
4442         unsigned endIndex = trailingSpaceChild == lastText ? lastText-&gt;lastCharacterIndexStrippingSpaces() : lastText-&gt;text().length() - 1;
4443         float endHangWidth = lastText-&gt;hangablePunctuationEndWidth(endIndex);
4444         inlineMin -= endHangWidth;
4445         inlineMax -= endHangWidth;
4446     }
4447 
4448     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4449     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4450 }
4451 
4452 }
4453 // namespace WebCore
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>