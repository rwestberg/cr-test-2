<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../css/typedom/TypedOMCSSUnparsedValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackAllocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/cssjit/SelectorCompiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 180     FragmentRelation relationToRightFragment;
 181     FragmentPositionInRootFragments positionInRootFragments;
 182     bool isRightmostOrAdjacent { false };
 183 
 184     BacktrackingAction traversalBacktrackingAction = BacktrackingAction::NoBacktracking;
 185     BacktrackingAction matchingTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 186     BacktrackingAction matchingPostTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 187     unsigned char backtrackingFlags = 0;
 188     unsigned tagNameMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 189     unsigned tagNameNotMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 190     unsigned heightFromDescendant = 0;
 191     unsigned tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 192     unsigned tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 193     unsigned widthFromIndirectAdjacent = 0;
 194 
 195     FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
 196 
 197     // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
 198     // the min/max/average of the vectors and pick better inline capacity.
 199     const CSSSelector* tagNameSelector = nullptr;
<span class="line-modified"> 200     const AtomicString* id = nullptr;</span>
<span class="line-modified"> 201     Vector&lt;const Vector&lt;AtomicString&gt;*&gt; languageArgumentsList;</span>
<span class="line-modified"> 202     Vector&lt;const AtomicStringImpl*, 8&gt; classNames;</span>
 203     HashSet&lt;unsigned&gt; pseudoClasses;
 204     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
 205     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
 206     Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
 207     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
 208     Vector&lt;NthChildOfSelectorInfo&gt; nthChildOfFilters;
 209     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthLastChildFilters;
 210     Vector&lt;NthChildOfSelectorInfo&gt; nthLastChildOfFilters;
 211     SelectorList notFilters;
 212     Vector&lt;SelectorList&gt; matchesFilters;
 213     Vector&lt;Vector&lt;SelectorFragment&gt;&gt; anyFilters;
 214     const CSSSelector* pseudoElementSelector = nullptr;
 215 
 216     // For quirks mode, follow this: http://quirks.spec.whatwg.org/#the-:active-and-:hover-quirk
 217     // In quirks mode, a compound selector &#39;selector&#39; that matches the following conditions must not match elements that would not also match the &#39;:any-link&#39; selector.
 218     //
 219     //    selector uses the &#39;:active&#39; or &#39;:hover&#39; pseudo-classes.
 220     //    selector does not use a type selector.
 221     //    selector does not use an attribute selector.
 222     //    selector does not use an ID selector.
</pre>
<hr />
<pre>
 283     void generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 284     void generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 285     void generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 286 
 287     void linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction, Assembler::JumpList&amp; localFailureCases);
 288     void generateAdjacentBacktrackingTail();
 289     void generateDescendantBacktrackingTail();
 290     void generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 291 
 292     // Element properties matchers.
 293     void generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp;);
 294     void generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 295     void generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 296     void generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 297     void generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 298     void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 299     void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
 300     void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
 301     void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 302     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<span class="line-modified"> 303     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomicString&gt;*);</span>
 304     void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
 305     void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
 306     void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
 307     void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 308     void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 309     void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
 310     void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
 311     void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
<span class="line-modified"> 312     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);</span>
<span class="line-modified"> 313     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);</span>
 314     void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
<span class="line-modified"> 315     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomicString&amp; idToMatch);</span>
<span class="line-modified"> 316     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomicStringImpl*, 8&gt;&amp; classNames);</span>
 317     void generateElementIsLink(Assembler::JumpList&amp; failureCases);
 318     void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 319     void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 320     void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 321     void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 322     void generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 323     void generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 324     void generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 325     void generateElementHasPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 326     void generateElementIsRoot(Assembler::JumpList&amp; failureCases);
 327     void generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases);
 328     void generateElementIsTarget(Assembler::JumpList&amp; failureCases);
 329     void generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases);
 330 
 331     // Helpers.
 332     void generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 333     void generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 334     Assembler::Jump branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 335     Assembler::Jump branchOnResolvingMode(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 336     void generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element);
</pre>
<hr />
<pre>
 523     if (b == 1 &amp;&amp; a &lt;= 0)
 524         pseudoClasses.add(firstMatchAlternative);
 525     else
 526         simpleCases.append(std::pair&lt;int, int&gt;(a, b));
 527     if (selectorContext == SelectorContext::QuerySelector)
 528         return FunctionType::SimpleSelectorChecker;
 529     return FunctionType::SelectorCheckerWithCheckingContext;
 530 }
 531 
 532 static inline FunctionType addPseudoClassType(const CSSSelector&amp; selector, SelectorFragment&amp; fragment, unsigned&amp; internalSpecificity, SelectorContext selectorContext, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 533 {
 534     CSSSelector::PseudoClassType type = selector.pseudoClassType();
 535     switch (type) {
 536     // Unoptimized pseudo selector. They are just function call to a simple testing function.
 537     case CSSSelector::PseudoClassAutofill:
 538         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilled));
 539         return FunctionType::SimpleSelectorChecker;
 540     case CSSSelector::PseudoClassAutofillStrongPassword:
 541         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 542         return FunctionType::SimpleSelectorChecker;



 543     case CSSSelector::PseudoClassChecked:
 544         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 545         return FunctionType::SimpleSelectorChecker;
 546     case CSSSelector::PseudoClassDefault:
 547         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 548         return FunctionType::SimpleSelectorChecker;
 549     case CSSSelector::PseudoClassDisabled:
 550         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 551         return FunctionType::SimpleSelectorChecker;
 552     case CSSSelector::PseudoClassEnabled:
 553         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 554         return FunctionType::SimpleSelectorChecker;
 555     case CSSSelector::PseudoClassDefined:
 556         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 557         return FunctionType::SimpleSelectorChecker;
 558     case CSSSelector::PseudoClassFocus:
 559         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 560         return FunctionType::SimpleSelectorChecker;
 561     case CSSSelector::PseudoClassFullPageMedia:
 562         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
</pre>
<hr />
<pre>
 764                 if (fragmentList.size() != 1)
 765                     return FunctionType::CannotCompile;
 766 
 767                 const SelectorFragment&amp; subFragment = fragmentList.first();
 768                 anyFragments.append(subFragment);
 769                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 770             }
 771 
 772             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 773             if (anyFragments.isEmpty())
 774                 return FunctionType::CannotMatchAnything;
 775 
 776             ASSERT(!anyFragments.isEmpty());
 777             fragment.anyFilters.append(anyFragments);
 778 
 779             return functionType;
 780         }
 781 
 782     case CSSSelector::PseudoClassLang:
 783         {
<span class="line-modified"> 784             const Vector&lt;AtomicString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
 785             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 786             fragment.languageArgumentsList.append(selectorLangArgumentList);
 787             return FunctionType::SimpleSelectorChecker;
 788         }
 789 
 790     case CSSSelector::PseudoClassMatches:
 791         {
 792             SelectorList matchesList;
 793             const CSSSelectorList* selectorList = selector.selectorList();
 794             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 795             unsigned firstFragmentListSpecificity = 0;
 796             bool firstFragmentListSpecificitySet = false;
 797             SelectorFragmentList* selectorFragments = nullptr;
 798             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 799                 if (!selectorFragments) {
 800                     matchesList.append(SelectorFragmentList());
 801                     selectorFragments = &amp;matchesList.last();
 802                 }
 803 
 804                 VisitedMode ignoreVisitedMode = VisitedMode::None;
</pre>
<hr />
<pre>
 900             selectorFragments.append(SelectorFragment());
 901             fragment = &amp;selectorFragments.last();
 902         }
 903 
 904         specificity = CSSSelector::addSpecificities(specificity, selector-&gt;simpleSelectorSpecificity());
 905 
 906         // A selector is invalid if something follows a pseudo-element.
 907         // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 908         // to follow the pseudo elements.
 909         if (fragment-&gt;pseudoElementSelector &amp;&amp; !isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 910             return FunctionType::CannotMatchAnything;
 911 
 912         switch (selector-&gt;match()) {
 913         case CSSSelector::Tag:
 914             ASSERT(!fragment-&gt;tagNameSelector);
 915             fragment-&gt;tagNameSelector = selector;
 916             if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
 917                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 918             break;
 919         case CSSSelector::Id: {
<span class="line-modified"> 920             const AtomicString&amp; id = selector-&gt;value();</span>
 921             if (fragment-&gt;id) {
 922                 if (id != *fragment-&gt;id)
 923                     return FunctionType::CannotMatchAnything;
 924             } else
 925                 fragment-&gt;id = &amp;(selector-&gt;value());
 926             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 927             break;
 928         }
 929         case CSSSelector::Class:
 930             fragment-&gt;classNames.append(selector-&gt;value().impl());
 931             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 932             break;
 933         case CSSSelector::PseudoClass: {
 934             FragmentPositionInRootFragments subPosition = positionInRootFragments;
 935             if (relationToPreviousFragment != FragmentRelation::Rightmost)
 936                 subPosition = isRightmostOrAdjacent ? FragmentPositionInRootFragments::AdjacentToRightmost : FragmentPositionInRootFragments::Other;
 937             if (fragment-&gt;pseudoElementSelector &amp;&amp; isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 938                 functionType = mostRestrictiveFunctionType(functionType, addScrollbarPseudoClassType(*selector, *fragment));
 939             else {
 940                 unsigned internalSpecificity = 0;
</pre>
<hr />
<pre>
1387 
1388 enum class TagNameEquality {
1389     StrictlyNotEqual,
1390     MaybeEqual,
1391     StrictlyEqual
1392 };
1393 
1394 static inline TagNameEquality equalTagNames(const CSSSelector* lhs, const CSSSelector* rhs)
1395 {
1396     if (!lhs || !rhs)
1397         return TagNameEquality::MaybeEqual;
1398 
1399     const QualifiedName&amp; lhsQualifiedName = lhs-&gt;tagQName();
1400     if (lhsQualifiedName == anyQName())
1401         return TagNameEquality::MaybeEqual;
1402 
1403     const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
1404     if (rhsQualifiedName == anyQName())
1405         return TagNameEquality::MaybeEqual;
1406 
<span class="line-modified">1407     const AtomicString&amp; lhsLocalName = lhsQualifiedName.localName();</span>
<span class="line-modified">1408     const AtomicString&amp; rhsLocalName = rhsQualifiedName.localName();</span>
1409     if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
<span class="line-modified">1410         const AtomicString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();</span>
<span class="line-modified">1411         const AtomicString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();</span>
1412 
1413         if (lhsLowercaseLocalName != rhsLowercaseLocalName)
1414             return TagNameEquality::StrictlyNotEqual;
1415 
1416         if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
1417             return TagNameEquality::StrictlyEqual;
1418         return TagNameEquality::MaybeEqual;
1419     }
1420 
<span class="line-modified">1421     const AtomicString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();</span>
<span class="line-modified">1422     const AtomicString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();</span>
1423     if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
1424         if (lhsNamespaceURI != rhsNamespaceURI)
1425             return TagNameEquality::StrictlyNotEqual;
1426         return TagNameEquality::StrictlyEqual;
1427     }
1428 
1429     return TagNameEquality::MaybeEqual;
1430 }
1431 
1432 static inline bool equalTagNamePatterns(const TagNamePattern&amp; lhs, const TagNamePattern&amp; rhs)
1433 {
1434     TagNameEquality result = equalTagNames(lhs.tagNameSelector, rhs.tagNameSelector);
1435     if (result == TagNameEquality::MaybeEqual)
1436         return true;
1437 
1438     // If both rhs &amp; lhs have actual localName (or NamespaceURI),
1439     // TagNameEquality result becomes StrictlyEqual or StrictlyNotEqual Since inverted lhs never matches on rhs.
1440     bool equal = result == TagNameEquality::StrictlyEqual;
1441     if (lhs.inverted)
1442         return !equal;
</pre>
<hr />
<pre>
2680     if (!fragment.attributes.isEmpty())
2681         generateElementAttributesMatching(failureCases, elementDataAddress, fragment);
2682 }
2683 
2684 void SelectorCodeGenerator::generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2685 {
2686     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLink)
2687         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassAnyLink)
2688         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2689         generateElementIsLink(failureCases);
2690 }
2691 
2692 static inline bool canMatchStyleAttribute(const SelectorFragment&amp; fragment)
2693 {
2694     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2695         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2696         const QualifiedName&amp; attributeName = attributeSelector.attribute();
2697         if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
2698             return true;
2699 
<span class="line-modified">2700         const AtomicString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2701         if (attributeName.localName() != canonicalLocalName
2702             &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
2703             return true;
2704         }
2705     }
2706     return false;
2707 }
2708 
2709 void SelectorCodeGenerator::generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2710 {
2711     // The style attribute is updated lazily based on the flag styleAttributeIsDirty.
2712     Assembler::Jump styleAttributeNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::styleAttributeIsDirtyFlag()));
2713 
2714     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2715     functionCall.setFunctionAddress(StyledElement::synchronizeStyleAttributeInternal);
2716     Assembler::RegisterID elementAddress = elementAddressRegister;
2717     functionCall.setOneArgument(elementAddress);
2718     functionCall.call();
2719 
2720     styleAttributeNotDirty.link(&amp;m_assembler);
2721 }
2722 
2723 static inline bool canMatchAnimatableSVGAttribute(const SelectorFragment&amp; fragment)
2724 {
2725     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2726         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2727         const QualifiedName&amp; selectorAttributeName = attributeSelector.attribute();
2728 
2729         const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2730         if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2731             return true;
2732 
<span class="line-modified">2733         const AtomicString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2734         if (selectorAttributeName.localName() != canonicalLocalName) {
2735             const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2736             if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2737                 return true;
2738         }
2739     }
2740     return false;
2741 }
2742 
2743 void SelectorCodeGenerator::generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2744 {
2745     // SVG attributes can be updated lazily depending on the flag AnimatedSVGAttributesAreDirty. We need to check
2746     // that first.
2747     Assembler::Jump animatedSVGAttributesNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::animatedSVGAttributesAreDirtyFlag()));
2748 
2749     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2750     functionCall.setFunctionAddress(SVGElement::synchronizeAllAnimatedSVGAttribute);
2751     Assembler::RegisterID elementAddress = elementAddressRegister;
2752     functionCall.setOneArgument(elementAddress);
2753     functionCall.call();
</pre>
<hr />
<pre>
2808             decIndexRegister = attributeArrayLength;
2809         }
2810 
2811         generateElementAttributeMatching(failureCases, currentAttributeAddress, decIndexRegister, fragment.attributes[i]);
2812 
2813         if (!isLastAttribute) {
2814             m_registerAllocator.deallocateRegister(decIndexRegister);
2815             m_registerAllocator.deallocateRegister(currentAttributeAddress);
2816         }
2817     }
2818 }
2819 
2820 void SelectorCodeGenerator::generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo)
2821 {
2822     // Get the localName used for comparison. HTML elements use a lowercase local name known in selectors as canonicalLocalName.
2823     LocalRegister localNameToMatch(m_registerAllocator);
2824 
2825     // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
2826     // which one to use.
2827     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">2828     const AtomicStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();</span>
<span class="line-modified">2829     const AtomicStringImpl* localName = attributeSelector.attribute().localName().impl();</span>
2830     if (canonicalLocalName == localName)
2831         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2832     else {
2833         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2834         Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
2835         m_assembler.move(Assembler::TrustedImmPtr(localName), localNameToMatch);
2836         elementIsHTML.link(&amp;m_assembler);
2837     }
2838 
2839     Assembler::JumpList successCases;
2840     Assembler::Label loopStart(m_assembler.label());
2841 
2842     {
2843         LocalRegister qualifiedNameImpl(m_registerAllocator);
2844         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::nameMemoryOffset()), qualifiedNameImpl);
2845 
2846         bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
2847         if (shouldCheckNamespace) {
2848             Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
2849 
<span class="line-modified">2850             const AtomicStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();</span>
2851             if (namespaceURI) {
2852                 LocalRegister namespaceToMatch(m_registerAllocator);
2853                 m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
2854                 successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
2855             } else
2856                 successCases.append(m_assembler.branchTestPtr(Assembler::Zero, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset())));
2857             nameDoesNotMatch.link(&amp;m_assembler);
2858         } else
2859             successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch));
2860     }
2861 
2862     Assembler::Label loopReEntry(m_assembler.label());
2863 
2864     // If we reached the last element -&gt; failure.
2865     failureCases.append(m_assembler.branchSub32(Assembler::Zero, Assembler::TrustedImm32(1), decIndexRegister));
2866 
2867     // Otherwise just loop over.
2868     m_assembler.addPtr(Assembler::TrustedImm32(sizeof(Attribute)), currentAttributeAddress);
2869     m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
2870 
2871     successCases.link(&amp;m_assembler);
2872 
2873     if (attributeSelector.match() != CSSSelector::Set) {
2874         // We make the assumption that name matching fails in most cases and we keep value matching outside
2875         // of the loop. We re-enter the loop if needed.
2876         // FIXME: exact case sensitive value matching is so simple that it should be done in the loop.
2877         Assembler::JumpList localFailureCases;
2878         generateElementAttributeValueMatching(localFailureCases, currentAttributeAddress, attributeInfo);
2879         localFailureCases.linkTo(loopReEntry, &amp;m_assembler);
2880     }
2881 }
2882 
2883 enum CaseSensitivity {
2884     CaseSensitive,
2885     CaseInsensitive
2886 };
2887 
2888 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2889 static bool attributeValueBeginsWith(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
2890 {
2891     ASSERT(expectedString);
2892 
<span class="line-modified">2893     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2894     if (caseSensitivity == CaseSensitive)
2895         return valueImpl.startsWith(*expectedString);
2896     return valueImpl.startsWithIgnoringASCIICase(*expectedString);
2897 }
2898 
2899 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2900 static bool attributeValueContains(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
2901 {
<span class="line-modified">2902     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2903     if (caseSensitivity == CaseSensitive)
2904         return valueImpl.find(expectedString) != notFound;
2905     return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
2906 }
2907 
2908 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2909 static bool attributeValueEndsWith(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
2910 {
2911     ASSERT(expectedString);
2912 
<span class="line-modified">2913     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2914     if (caseSensitivity == CaseSensitive)
2915         return valueImpl.endsWith(*expectedString);
2916     return valueImpl.endsWithIgnoringASCIICase(*expectedString);
2917 }
2918 
2919 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2920 static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
2921 {
2922     ASSERT(expectedString);
2923 
<span class="line-modified">2924     AtomicStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2925     if (valueImpl.length() &lt; expectedString-&gt;length())
2926         return false;
2927 
2928     bool valueStartsWithExpectedString;
2929     if (caseSensitivity == CaseSensitive)
2930         valueStartsWithExpectedString = valueImpl.startsWith(*expectedString);
2931     else
2932         valueStartsWithExpectedString = valueImpl.startsWithIgnoringASCIICase(*expectedString);
2933 
2934     if (!valueStartsWithExpectedString)
2935         return false;
2936 
2937     return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
2938 }
2939 
2940 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2941 static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomicStringImpl* expectedString)</span>
2942 {
<span class="line-modified">2943     AtomicStringImpl&amp; value = *attribute-&gt;value().impl();</span>
2944 
2945     unsigned startSearchAt = 0;
2946     while (true) {
2947         size_t foundPos;
2948         if (caseSensitivity == CaseSensitive)
2949             foundPos = value.find(expectedString, startSearchAt);
2950         else
2951             foundPos = value.findIgnoringASCIICase(expectedString, startSearchAt);
2952         if (foundPos == notFound)
2953             return false;
2954         if (!foundPos || isHTMLSpace(value[foundPos - 1])) {
2955             unsigned endStr = foundPos + expectedString-&gt;length();
2956             if (endStr == value.length() || isHTMLSpace(value[endStr]))
2957                 return true;
2958         }
2959         startSearchAt = foundPos + 1;
2960     }
2961     return false;
2962 }
2963 
2964 void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
2965 {
2966     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">2967     const AtomicString&amp; expectedValue = attributeSelector.value();</span>
2968     ASSERT(!expectedValue.isNull());
2969     AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
2970 
2971     switch (attributeSelector.match()) {
2972     case CSSSelector::Begin:
2973         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueBeginsWith&lt;CaseSensitive&gt;, attributeValueBeginsWith&lt;CaseInsensitive&gt;);
2974         break;
2975     case CSSSelector::Contain:
2976         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueContains&lt;CaseSensitive&gt;, attributeValueContains&lt;CaseInsensitive&gt;);
2977         break;
2978     case CSSSelector::End:
2979         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueEndsWith&lt;CaseSensitive&gt;, attributeValueEndsWith&lt;CaseInsensitive&gt;);
2980         break;
2981     case CSSSelector::Exact:
2982         generateElementAttributeValueExactMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity);
2983         break;
2984     case CSSSelector::Hyphen:
2985         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueMatchHyphenRule&lt;CaseSensitive&gt;, attributeValueMatchHyphenRule&lt;CaseInsensitive&gt;);
2986         break;
2987     case CSSSelector::List:
2988         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueSpaceSeparetedListContains&lt;CaseSensitive&gt;, attributeValueSpaceSeparetedListContains&lt;CaseInsensitive&gt;);
2989         break;
2990     default:
2991         ASSERT_NOT_REACHED();
2992     }
2993 }
2994 
2995 static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
2996 {
2997     return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
2998 }
2999 
<span class="line-modified">3000 void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)</span>
3001 {
3002     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3003     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3004 
3005     switch (valueCaseSensitivity) {
3006     case AttributeCaseSensitivity::CaseSensitive: {
3007         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister));
3008         break;
3009     }
3010     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3011         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister);
3012 
3013         // If the element is an HTML element, in a HTML dcoument (not including XHTML), value matching is case insensitive.
3014         // Taking the contrapositive, if we find the element is not HTML or is not in a HTML document, the condition above
3015         // sould be sufficient and we can fail early.
3016         failureCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3017 
3018         {
3019             LocalRegister document(m_registerAllocator);
3020             DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
</pre>
<hr />
<pre>
3030         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3031 
3032         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3033         break;
3034     }
3035     case AttributeCaseSensitivity::CaseInsensitive: {
3036         LocalRegister valueStringImpl(m_registerAllocator);
3037         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3038 
3039         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, valueStringImpl, expectedValueRegister);
3040         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3041         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3042         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3043         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3044         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3045         break;
3046     }
3047     }
3048 }
3049 
<span class="line-modified">3050 void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomicString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)</span>
3051 {
3052     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3053     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3054 
3055 
3056     switch (valueCaseSensitivity) {
3057     case AttributeCaseSensitivity::CaseSensitive: {
3058         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3059         functionCall.setFunctionAddress(caseSensitiveTest);
3060         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3061         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3062         break;
3063     }
3064     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3065         Assembler::JumpList shouldUseCaseSensitiveComparison;
3066         shouldUseCaseSensitiveComparison.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3067         {
3068             LocalRegister scratchRegister(m_registerAllocator);
3069             // scratchRegister = pointer to treeScope.
3070             m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::treeScopeMemoryOffset()), scratchRegister);
</pre>
<hr />
<pre>
3251     Assembler::JumpList successCases;
3252     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; fragment.relationToRightFragment != FragmentRelation::Rightmost) {
3253         // :hover always matches when not in rightmost position when collecting rules for descendant style invalidation optimization.
3254         // Resolving style for a matching descendant will set parent childrenAffectedByHover bit even when the element is not currently hovered.
3255         // This bit has to be set for the event based :hover invalidation to work.
3256         // FIXME: We should just collect style relation bits and apply them as needed when computing style invalidation optimization.
3257         LocalRegister checkingContext(m_registerAllocator);
3258         successCases.append(branchOnResolvingMode(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3259     }
3260 
3261     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3262     functionCall.setFunctionAddress(elementIsHovered);
3263     functionCall.setOneArgument(elementAddressRegister);
3264     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3265 
3266     successCases.link(&amp;m_assembler);
3267 }
3268 
3269 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3270 {
<span class="line-modified">3271     for (const Vector&lt;AtomicString&gt;* languageArguments : fragment.languageArgumentsList)</span>
3272         generateElementIsInLanguage(failureCases, languageArguments);
3273 }
3274 
<span class="line-modified">3275 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomicString&gt;* languageArguments)</span>
3276 {
3277     LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3278     m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
3279 
3280     Assembler::RegisterID elementAddress = elementAddressRegister;
3281     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3282     functionCall.setFunctionAddress(matchesLangPseudoClass);
3283     functionCall.setTwoArguments(elementAddress, langRangeRegister);
3284     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3285 }
3286 
3287 void SelectorCodeGenerator::generateElementIsLastChild(Assembler::JumpList&amp; failureCases)
3288 {
3289     if (m_selectorContext == SelectorContext::QuerySelector) {
3290         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3291         failureCases.append(m_assembler.jump());
3292 
3293         successCase.link(&amp;m_assembler);
3294         LocalRegister parent(m_registerAllocator);
3295         generateWalkToParentElementOrShadowRoot(failureCases, parent);
</pre>
<hr />
<pre>
3438     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegisterWithPreference(JSC::GPRInfo::argumentGPR1);
3439     loadCheckingContext(checkingContext);
3440     m_registerAllocator.deallocateRegister(checkingContext);
3441 
3442     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3443     functionCall.setFunctionAddress(makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown);
3444     functionCall.setTwoArguments(elementAddressRegister, checkingContext);
3445     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3446 }
3447 
3448 inline void SelectorCodeGenerator::generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector)
3449 {
3450     const QualifiedName&amp; nameToMatch = tagMatchingSelector.tagQName();
3451     if (nameToMatch == anyQName())
3452         return;
3453 
3454     // Load the QualifiedNameImpl from the input.
3455     LocalRegister qualifiedNameImpl(m_registerAllocator);
3456     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
3457 
<span class="line-modified">3458     const AtomicString&amp; selectorLocalName = nameToMatch.localName();</span>
3459     if (selectorLocalName != starAtom()) {
<span class="line-modified">3460         const AtomicString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();</span>
3461 
3462         if (selectorLocalName == lowercaseLocalName) {
3463             // Generate localName == element-&gt;localName().
3464             LocalRegister constantRegister(m_registerAllocator);
3465             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3466             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3467         } else {
3468             Assembler::JumpList caseSensitiveCases;
3469             caseSensitiveCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3470             {
3471                 LocalRegister document(m_registerAllocator);
3472                 DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3473                 caseSensitiveCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3474             }
3475 
3476             LocalRegister constantRegister(m_registerAllocator);
3477             m_assembler.move(Assembler::TrustedImmPtr(lowercaseLocalName.impl()), constantRegister);
3478             Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3479 
3480             caseSensitiveCases.link(&amp;m_assembler);
3481             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3482             skipCaseSensitiveCase.link(&amp;m_assembler);
3483 
3484             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3485         }
3486     }
3487 
<span class="line-modified">3488     const AtomicString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();</span>
3489     if (selectorNamespaceURI != starAtom()) {
3490         // Generate namespaceURI == element-&gt;namespaceURI().
3491         LocalRegister constantRegister(m_registerAllocator);
3492         m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
3493         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
3494     }
3495 }
3496 
<span class="line-modified">3497 void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomicString&amp; idToMatch)</span>
3498 {
<span class="line-modified">3499     // Compare the pointers of the AtomicStringImpl from idForStyleResolution with the reference idToMatch.</span>
3500     LocalRegister idToMatchRegister(m_registerAllocator);
3501     m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
3502     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
3503 }
3504 
<span class="line-modified">3505 void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomicStringImpl*, 8&gt;&amp; classNames)</span>
3506 {
3507     // Load m_classNames.
3508     LocalRegister spaceSplitStringData(m_registerAllocator);
3509     m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
3510 
3511     // If SpaceSplitString does not have a SpaceSplitStringData pointer, it is empty -&gt; failure case.
3512     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, spaceSplitStringData));
3513 
3514     // We loop over the classes of SpaceSplitStringData for each class name we need to match.
3515     LocalRegister indexRegister(m_registerAllocator);
3516     for (unsigned i = 0; i &lt; classNames.size(); ++i) {
3517         LocalRegister classNameToMatch(m_registerAllocator);
3518         m_assembler.move(Assembler::TrustedImmPtr(classNames[i]), classNameToMatch);
3519         m_assembler.move(Assembler::TrustedImm32(0), indexRegister);
3520 
3521         // Beginning of a loop over all the class name of element to find the one we are looking for.
3522         Assembler::Label loopStart(m_assembler.label());
3523 
3524         // If the pointers match, proceed to the next matcher.
3525         Assembler::Jump classFound = m_assembler.branchPtr(Assembler::Equal, Assembler::BaseIndex(spaceSplitStringData, indexRegister, Assembler::timesPtr(), SpaceSplitStringData::tokensMemoryOffset()), classNameToMatch);
</pre>
<hr />
<pre>
3582     }
3583     if (validSubsetFilters.isEmpty())
3584         return;
3585 
3586     // Setup the counter at 1.
3587     LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3588     m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3589 
3590     // Loop over the previous adjacent elements and increment the counter.
3591     {
3592         LocalRegister previousSibling(m_registerAllocator);
3593         m_assembler.move(elementAddressRegister, previousSibling);
3594 
3595         // Getting the child index is very efficient when it works. When there is no child index,
3596         // querying at every iteration is very inefficient. We solve this by only testing the child
3597         // index on the first direct adjacent.
3598         Assembler::JumpList noMoreSiblingsCases;
3599 
3600         Assembler::JumpList noCachedChildIndexCases;
3601         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
<span class="line-modified">3602         noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, Assembler::Address(previousSibling, Node::nodeFlagsMemoryOffset()), Assembler::TrustedImm32(Node::flagHasRareData())));</span>




3603         {
<span class="line-removed">3604             LocalRegister elementRareData(m_registerAllocator);</span>
<span class="line-removed">3605             m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);</span>
3606             LocalRegister cachedChildIndex(m_registerAllocator);
3607             m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
3608             noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
3609             m_assembler.add32(cachedChildIndex, elementCounter);
3610             noMoreSiblingsCases.append(m_assembler.jump());
3611         }
3612         noCachedChildIndexCases.link(&amp;m_assembler);
3613         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3614 
3615         Assembler::Label loopStart = m_assembler.label();
3616         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3617         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3618         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3619         noMoreSiblingsCases.link(&amp;m_assembler);
3620     }
3621 
3622     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::NthChildIndex, Assembler::RegisterID(elementCounter));
3623 
3624     for (const auto&amp; slot : validSubsetFilters)
3625         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
</pre>
</td>
<td>
<hr />
<pre>
 180     FragmentRelation relationToRightFragment;
 181     FragmentPositionInRootFragments positionInRootFragments;
 182     bool isRightmostOrAdjacent { false };
 183 
 184     BacktrackingAction traversalBacktrackingAction = BacktrackingAction::NoBacktracking;
 185     BacktrackingAction matchingTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 186     BacktrackingAction matchingPostTagNameBacktrackingAction = BacktrackingAction::NoBacktracking;
 187     unsigned char backtrackingFlags = 0;
 188     unsigned tagNameMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 189     unsigned tagNameNotMatchedBacktrackingStartHeightFromDescendant = invalidHeight;
 190     unsigned heightFromDescendant = 0;
 191     unsigned tagNameMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 192     unsigned tagNameNotMatchedBacktrackingStartWidthFromIndirectAdjacent = invalidWidth;
 193     unsigned widthFromIndirectAdjacent = 0;
 194 
 195     FunctionType appendUnoptimizedPseudoClassWithContext(bool (*matcher)(const SelectorChecker::CheckingContext&amp;));
 196 
 197     // FIXME: the large stack allocation caused by the inline capacity causes memory inefficiency. We should dump
 198     // the min/max/average of the vectors and pick better inline capacity.
 199     const CSSSelector* tagNameSelector = nullptr;
<span class="line-modified"> 200     const AtomString* id = nullptr;</span>
<span class="line-modified"> 201     Vector&lt;const Vector&lt;AtomString&gt;*&gt; languageArgumentsList;</span>
<span class="line-modified"> 202     Vector&lt;const AtomStringImpl*, 8&gt; classNames;</span>
 203     HashSet&lt;unsigned&gt; pseudoClasses;
 204     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClasses;
 205     Vector&lt;JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;, 4&gt; unoptimizedPseudoClassesWithContext;
 206     Vector&lt;AttributeMatchingInfo, 4&gt; attributes;
 207     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthChildFilters;
 208     Vector&lt;NthChildOfSelectorInfo&gt; nthChildOfFilters;
 209     Vector&lt;std::pair&lt;int, int&gt;, 2&gt; nthLastChildFilters;
 210     Vector&lt;NthChildOfSelectorInfo&gt; nthLastChildOfFilters;
 211     SelectorList notFilters;
 212     Vector&lt;SelectorList&gt; matchesFilters;
 213     Vector&lt;Vector&lt;SelectorFragment&gt;&gt; anyFilters;
 214     const CSSSelector* pseudoElementSelector = nullptr;
 215 
 216     // For quirks mode, follow this: http://quirks.spec.whatwg.org/#the-:active-and-:hover-quirk
 217     // In quirks mode, a compound selector &#39;selector&#39; that matches the following conditions must not match elements that would not also match the &#39;:any-link&#39; selector.
 218     //
 219     //    selector uses the &#39;:active&#39; or &#39;:hover&#39; pseudo-classes.
 220     //    selector does not use a type selector.
 221     //    selector does not use an attribute selector.
 222     //    selector does not use an ID selector.
</pre>
<hr />
<pre>
 283     void generateWalkToPreviousAdjacent(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 284     void generateDirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 285     void generateIndirectAdjacentTreeWalker(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 286 
 287     void linkFailures(Assembler::JumpList&amp; globalFailureCases, BacktrackingAction, Assembler::JumpList&amp; localFailureCases);
 288     void generateAdjacentBacktrackingTail();
 289     void generateDescendantBacktrackingTail();
 290     void generateBacktrackingTailsIfNeeded(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 291 
 292     // Element properties matchers.
 293     void generateElementMatching(Assembler::JumpList&amp; matchingTagNameFailureCases, Assembler::JumpList&amp; matchingPostTagNameFailureCases, const SelectorFragment&amp;);
 294     void generateElementDataMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 295     void generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 296     void generateElementFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 297     void generateContextFunctionCallTest(Assembler::JumpList&amp; failureCases, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;);
 298     void generateElementIsActive(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 299     void generateElementIsEmpty(Assembler::JumpList&amp; failureCases);
 300     void generateElementIsFirstChild(Assembler::JumpList&amp; failureCases);
 301     void generateElementIsHovered(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 302     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
<span class="line-modified"> 303     void generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;*);</span>
 304     void generateElementIsLastChild(Assembler::JumpList&amp; failureCases);
 305     void generateElementIsOnlyChild(Assembler::JumpList&amp; failureCases);
 306     void generateElementHasPlaceholderShown(Assembler::JumpList&amp; failureCases);
 307     void generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 308     void generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags);
 309     void generateElementAttributesMatching(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const SelectorFragment&amp;);
 310     void generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo);
 311     void generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo);
<span class="line-modified"> 312     void generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity);</span>
<span class="line-modified"> 313     void generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest);</span>
 314     void generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector);
<span class="line-modified"> 315     void generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch);</span>
<span class="line-modified"> 316     void generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames);</span>
 317     void generateElementIsLink(Assembler::JumpList&amp; failureCases);
 318     void generateElementIsNthChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 319     void generateElementIsNthChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 320     void generateElementIsNthLastChild(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 321     void generateElementIsNthLastChildOf(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 322     void generateElementMatchesNotPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 323     void generateElementMatchesAnyPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 324     void generateElementMatchesMatchesPseudoClass(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 325     void generateElementHasPseudoElement(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp;);
 326     void generateElementIsRoot(Assembler::JumpList&amp; failureCases);
 327     void generateElementIsScopeRoot(Assembler::JumpList&amp; failureCases);
 328     void generateElementIsTarget(Assembler::JumpList&amp; failureCases);
 329     void generateElementHasFocusWithin(Assembler::JumpList&amp; failureCases);
 330 
 331     // Helpers.
 332     void generateAddStyleRelationIfResolvingStyle(Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 333     void generateAddStyleRelation(Assembler::RegisterID checkingContext, Assembler::RegisterID element, Style::Relation::Type, Optional&lt;Assembler::RegisterID&gt; value = { });
 334     Assembler::Jump branchOnResolvingModeWithCheckingContext(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 335     Assembler::Jump branchOnResolvingMode(Assembler::RelationalCondition, SelectorChecker::Mode, Assembler::RegisterID checkingContext);
 336     void generateElementIsFirstLink(Assembler::JumpList&amp; failureCases, Assembler::RegisterID element);
</pre>
<hr />
<pre>
 523     if (b == 1 &amp;&amp; a &lt;= 0)
 524         pseudoClasses.add(firstMatchAlternative);
 525     else
 526         simpleCases.append(std::pair&lt;int, int&gt;(a, b));
 527     if (selectorContext == SelectorContext::QuerySelector)
 528         return FunctionType::SimpleSelectorChecker;
 529     return FunctionType::SelectorCheckerWithCheckingContext;
 530 }
 531 
 532 static inline FunctionType addPseudoClassType(const CSSSelector&amp; selector, SelectorFragment&amp; fragment, unsigned&amp; internalSpecificity, SelectorContext selectorContext, FragmentsLevel fragmentLevel, FragmentPositionInRootFragments positionInRootFragments, bool visitedMatchEnabled, VisitedMode&amp; visitedMode, PseudoElementMatchingBehavior pseudoElementMatchingBehavior)
 533 {
 534     CSSSelector::PseudoClassType type = selector.pseudoClassType();
 535     switch (type) {
 536     // Unoptimized pseudo selector. They are just function call to a simple testing function.
 537     case CSSSelector::PseudoClassAutofill:
 538         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilled));
 539         return FunctionType::SimpleSelectorChecker;
 540     case CSSSelector::PseudoClassAutofillStrongPassword:
 541         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPassword));
 542         return FunctionType::SimpleSelectorChecker;
<span class="line-added"> 543     case CSSSelector::PseudoClassAutofillStrongPasswordViewable:</span>
<span class="line-added"> 544         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isAutofilledStrongPasswordViewable));</span>
<span class="line-added"> 545         return FunctionType::SimpleSelectorChecker;</span>
 546     case CSSSelector::PseudoClassChecked:
 547         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isChecked));
 548         return FunctionType::SimpleSelectorChecker;
 549     case CSSSelector::PseudoClassDefault:
 550         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDefaultPseudoClass));
 551         return FunctionType::SimpleSelectorChecker;
 552     case CSSSelector::PseudoClassDisabled:
 553         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesDisabledPseudoClass));
 554         return FunctionType::SimpleSelectorChecker;
 555     case CSSSelector::PseudoClassEnabled:
 556         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(matchesEnabledPseudoClass));
 557         return FunctionType::SimpleSelectorChecker;
 558     case CSSSelector::PseudoClassDefined:
 559         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isDefinedElement));
 560         return FunctionType::SimpleSelectorChecker;
 561     case CSSSelector::PseudoClassFocus:
 562         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(SelectorChecker::matchesFocusPseudoClass));
 563         return FunctionType::SimpleSelectorChecker;
 564     case CSSSelector::PseudoClassFullPageMedia:
 565         fragment.unoptimizedPseudoClasses.append(JSC::FunctionPtr&lt;CSSOperationPtrTag&gt;(isMediaDocument));
</pre>
<hr />
<pre>
 767                 if (fragmentList.size() != 1)
 768                     return FunctionType::CannotCompile;
 769 
 770                 const SelectorFragment&amp; subFragment = fragmentList.first();
 771                 anyFragments.append(subFragment);
 772                 functionType = mostRestrictiveFunctionType(functionType, subFunctionType);
 773             }
 774 
 775             // Since all fragments in :any() cannot match anything, this :any() filter cannot match anything.
 776             if (anyFragments.isEmpty())
 777                 return FunctionType::CannotMatchAnything;
 778 
 779             ASSERT(!anyFragments.isEmpty());
 780             fragment.anyFilters.append(anyFragments);
 781 
 782             return functionType;
 783         }
 784 
 785     case CSSSelector::PseudoClassLang:
 786         {
<span class="line-modified"> 787             const Vector&lt;AtomString&gt;* selectorLangArgumentList = selector.langArgumentList();</span>
 788             ASSERT(selectorLangArgumentList &amp;&amp; !selectorLangArgumentList-&gt;isEmpty());
 789             fragment.languageArgumentsList.append(selectorLangArgumentList);
 790             return FunctionType::SimpleSelectorChecker;
 791         }
 792 
 793     case CSSSelector::PseudoClassMatches:
 794         {
 795             SelectorList matchesList;
 796             const CSSSelectorList* selectorList = selector.selectorList();
 797             FunctionType functionType = FunctionType::SimpleSelectorChecker;
 798             unsigned firstFragmentListSpecificity = 0;
 799             bool firstFragmentListSpecificitySet = false;
 800             SelectorFragmentList* selectorFragments = nullptr;
 801             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 802                 if (!selectorFragments) {
 803                     matchesList.append(SelectorFragmentList());
 804                     selectorFragments = &amp;matchesList.last();
 805                 }
 806 
 807                 VisitedMode ignoreVisitedMode = VisitedMode::None;
</pre>
<hr />
<pre>
 903             selectorFragments.append(SelectorFragment());
 904             fragment = &amp;selectorFragments.last();
 905         }
 906 
 907         specificity = CSSSelector::addSpecificities(specificity, selector-&gt;simpleSelectorSpecificity());
 908 
 909         // A selector is invalid if something follows a pseudo-element.
 910         // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 911         // to follow the pseudo elements.
 912         if (fragment-&gt;pseudoElementSelector &amp;&amp; !isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 913             return FunctionType::CannotMatchAnything;
 914 
 915         switch (selector-&gt;match()) {
 916         case CSSSelector::Tag:
 917             ASSERT(!fragment-&gt;tagNameSelector);
 918             fragment-&gt;tagNameSelector = selector;
 919             if (fragment-&gt;tagNameSelector-&gt;tagQName() != anyQName())
 920                 fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 921             break;
 922         case CSSSelector::Id: {
<span class="line-modified"> 923             const AtomString&amp; id = selector-&gt;value();</span>
 924             if (fragment-&gt;id) {
 925                 if (id != *fragment-&gt;id)
 926                     return FunctionType::CannotMatchAnything;
 927             } else
 928                 fragment-&gt;id = &amp;(selector-&gt;value());
 929             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 930             break;
 931         }
 932         case CSSSelector::Class:
 933             fragment-&gt;classNames.append(selector-&gt;value().impl());
 934             fragment-&gt;onlyMatchesLinksInQuirksMode = false;
 935             break;
 936         case CSSSelector::PseudoClass: {
 937             FragmentPositionInRootFragments subPosition = positionInRootFragments;
 938             if (relationToPreviousFragment != FragmentRelation::Rightmost)
 939                 subPosition = isRightmostOrAdjacent ? FragmentPositionInRootFragments::AdjacentToRightmost : FragmentPositionInRootFragments::Other;
 940             if (fragment-&gt;pseudoElementSelector &amp;&amp; isScrollbarPseudoElement(fragment-&gt;pseudoElementSelector-&gt;pseudoElementType()))
 941                 functionType = mostRestrictiveFunctionType(functionType, addScrollbarPseudoClassType(*selector, *fragment));
 942             else {
 943                 unsigned internalSpecificity = 0;
</pre>
<hr />
<pre>
1390 
1391 enum class TagNameEquality {
1392     StrictlyNotEqual,
1393     MaybeEqual,
1394     StrictlyEqual
1395 };
1396 
1397 static inline TagNameEquality equalTagNames(const CSSSelector* lhs, const CSSSelector* rhs)
1398 {
1399     if (!lhs || !rhs)
1400         return TagNameEquality::MaybeEqual;
1401 
1402     const QualifiedName&amp; lhsQualifiedName = lhs-&gt;tagQName();
1403     if (lhsQualifiedName == anyQName())
1404         return TagNameEquality::MaybeEqual;
1405 
1406     const QualifiedName&amp; rhsQualifiedName = rhs-&gt;tagQName();
1407     if (rhsQualifiedName == anyQName())
1408         return TagNameEquality::MaybeEqual;
1409 
<span class="line-modified">1410     const AtomString&amp; lhsLocalName = lhsQualifiedName.localName();</span>
<span class="line-modified">1411     const AtomString&amp; rhsLocalName = rhsQualifiedName.localName();</span>
1412     if (lhsLocalName != starAtom() &amp;&amp; rhsLocalName != starAtom()) {
<span class="line-modified">1413         const AtomString&amp; lhsLowercaseLocalName = lhs-&gt;tagLowercaseLocalName();</span>
<span class="line-modified">1414         const AtomString&amp; rhsLowercaseLocalName = rhs-&gt;tagLowercaseLocalName();</span>
1415 
1416         if (lhsLowercaseLocalName != rhsLowercaseLocalName)
1417             return TagNameEquality::StrictlyNotEqual;
1418 
1419         if (lhsLocalName == lhsLowercaseLocalName &amp;&amp; rhsLocalName == rhsLowercaseLocalName)
1420             return TagNameEquality::StrictlyEqual;
1421         return TagNameEquality::MaybeEqual;
1422     }
1423 
<span class="line-modified">1424     const AtomString&amp; lhsNamespaceURI = lhsQualifiedName.namespaceURI();</span>
<span class="line-modified">1425     const AtomString&amp; rhsNamespaceURI = rhsQualifiedName.namespaceURI();</span>
1426     if (lhsNamespaceURI != starAtom() &amp;&amp; rhsNamespaceURI != starAtom()) {
1427         if (lhsNamespaceURI != rhsNamespaceURI)
1428             return TagNameEquality::StrictlyNotEqual;
1429         return TagNameEquality::StrictlyEqual;
1430     }
1431 
1432     return TagNameEquality::MaybeEqual;
1433 }
1434 
1435 static inline bool equalTagNamePatterns(const TagNamePattern&amp; lhs, const TagNamePattern&amp; rhs)
1436 {
1437     TagNameEquality result = equalTagNames(lhs.tagNameSelector, rhs.tagNameSelector);
1438     if (result == TagNameEquality::MaybeEqual)
1439         return true;
1440 
1441     // If both rhs &amp; lhs have actual localName (or NamespaceURI),
1442     // TagNameEquality result becomes StrictlyEqual or StrictlyNotEqual Since inverted lhs never matches on rhs.
1443     bool equal = result == TagNameEquality::StrictlyEqual;
1444     if (lhs.inverted)
1445         return !equal;
</pre>
<hr />
<pre>
2683     if (!fragment.attributes.isEmpty())
2684         generateElementAttributesMatching(failureCases, elementDataAddress, fragment);
2685 }
2686 
2687 void SelectorCodeGenerator::generateElementLinkMatching(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
2688 {
2689     if (fragment.pseudoClasses.contains(CSSSelector::PseudoClassLink)
2690         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassAnyLink)
2691         || fragment.pseudoClasses.contains(CSSSelector::PseudoClassVisited))
2692         generateElementIsLink(failureCases);
2693 }
2694 
2695 static inline bool canMatchStyleAttribute(const SelectorFragment&amp; fragment)
2696 {
2697     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2698         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2699         const QualifiedName&amp; attributeName = attributeSelector.attribute();
2700         if (Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeName.localName(), attributeName.namespaceURI()))
2701             return true;
2702 
<span class="line-modified">2703         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2704         if (attributeName.localName() != canonicalLocalName
2705             &amp;&amp; Attribute::nameMatchesFilter(HTMLNames::styleAttr, attributeName.prefix(), attributeSelector.attributeCanonicalLocalName(), attributeName.namespaceURI())) {
2706             return true;
2707         }
2708     }
2709     return false;
2710 }
2711 
2712 void SelectorCodeGenerator::generateSynchronizeStyleAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2713 {
2714     // The style attribute is updated lazily based on the flag styleAttributeIsDirty.
2715     Assembler::Jump styleAttributeNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::styleAttributeIsDirtyFlag()));
2716 
2717     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2718     functionCall.setFunctionAddress(StyledElement::synchronizeStyleAttributeInternal);
2719     Assembler::RegisterID elementAddress = elementAddressRegister;
2720     functionCall.setOneArgument(elementAddress);
2721     functionCall.call();
2722 
2723     styleAttributeNotDirty.link(&amp;m_assembler);
2724 }
2725 
2726 static inline bool canMatchAnimatableSVGAttribute(const SelectorFragment&amp; fragment)
2727 {
2728     for (unsigned i = 0; i &lt; fragment.attributes.size(); ++i) {
2729         const CSSSelector&amp; attributeSelector = fragment.attributes[i].selector();
2730         const QualifiedName&amp; selectorAttributeName = attributeSelector.attribute();
2731 
2732         const QualifiedName&amp; candidateForLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2733         if (Attribute::nameMatchesFilter(candidateForLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2734             return true;
2735 
<span class="line-modified">2736         const AtomString&amp; canonicalLocalName = attributeSelector.attributeCanonicalLocalName();</span>
2737         if (selectorAttributeName.localName() != canonicalLocalName) {
2738             const QualifiedName&amp; candidateForCanonicalLocalName = SVGElement::animatableAttributeForName(selectorAttributeName.localName());
2739             if (Attribute::nameMatchesFilter(candidateForCanonicalLocalName, selectorAttributeName.prefix(), selectorAttributeName.localName(), selectorAttributeName.namespaceURI()))
2740                 return true;
2741         }
2742     }
2743     return false;
2744 }
2745 
2746 void SelectorCodeGenerator::generateSynchronizeAllAnimatedSVGAttribute(Assembler::RegisterID elementDataArraySizeAndFlags)
2747 {
2748     // SVG attributes can be updated lazily depending on the flag AnimatedSVGAttributesAreDirty. We need to check
2749     // that first.
2750     Assembler::Jump animatedSVGAttributesNotDirty = m_assembler.branchTest32(Assembler::Zero, elementDataArraySizeAndFlags, Assembler::TrustedImm32(ElementData::animatedSVGAttributesAreDirtyFlag()));
2751 
2752     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
2753     functionCall.setFunctionAddress(SVGElement::synchronizeAllAnimatedSVGAttribute);
2754     Assembler::RegisterID elementAddress = elementAddressRegister;
2755     functionCall.setOneArgument(elementAddress);
2756     functionCall.call();
</pre>
<hr />
<pre>
2811             decIndexRegister = attributeArrayLength;
2812         }
2813 
2814         generateElementAttributeMatching(failureCases, currentAttributeAddress, decIndexRegister, fragment.attributes[i]);
2815 
2816         if (!isLastAttribute) {
2817             m_registerAllocator.deallocateRegister(decIndexRegister);
2818             m_registerAllocator.deallocateRegister(currentAttributeAddress);
2819         }
2820     }
2821 }
2822 
2823 void SelectorCodeGenerator::generateElementAttributeMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, Assembler::RegisterID decIndexRegister, const AttributeMatchingInfo&amp; attributeInfo)
2824 {
2825     // Get the localName used for comparison. HTML elements use a lowercase local name known in selectors as canonicalLocalName.
2826     LocalRegister localNameToMatch(m_registerAllocator);
2827 
2828     // In general, canonicalLocalName and localName are the same. When they differ, we have to check if the node is HTML to know
2829     // which one to use.
2830     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">2831     const AtomStringImpl* canonicalLocalName = attributeSelector.attributeCanonicalLocalName().impl();</span>
<span class="line-modified">2832     const AtomStringImpl* localName = attributeSelector.attribute().localName().impl();</span>
2833     if (canonicalLocalName == localName)
2834         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2835     else {
2836         m_assembler.move(Assembler::TrustedImmPtr(canonicalLocalName), localNameToMatch);
2837         Assembler::Jump elementIsHTML = DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::NonZero, elementAddressRegister);
2838         m_assembler.move(Assembler::TrustedImmPtr(localName), localNameToMatch);
2839         elementIsHTML.link(&amp;m_assembler);
2840     }
2841 
2842     Assembler::JumpList successCases;
2843     Assembler::Label loopStart(m_assembler.label());
2844 
2845     {
2846         LocalRegister qualifiedNameImpl(m_registerAllocator);
2847         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::nameMemoryOffset()), qualifiedNameImpl);
2848 
2849         bool shouldCheckNamespace = attributeSelector.attribute().prefix() != starAtom();
2850         if (shouldCheckNamespace) {
2851             Assembler::Jump nameDoesNotMatch = m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch);
2852 
<span class="line-modified">2853             const AtomStringImpl* namespaceURI = attributeSelector.attribute().namespaceURI().impl();</span>
2854             if (namespaceURI) {
2855                 LocalRegister namespaceToMatch(m_registerAllocator);
2856                 m_assembler.move(Assembler::TrustedImmPtr(namespaceURI), namespaceToMatch);
2857                 successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), namespaceToMatch));
2858             } else
2859                 successCases.append(m_assembler.branchTestPtr(Assembler::Zero, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset())));
2860             nameDoesNotMatch.link(&amp;m_assembler);
2861         } else
2862             successCases.append(m_assembler.branchPtr(Assembler::Equal, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), localNameToMatch));
2863     }
2864 
2865     Assembler::Label loopReEntry(m_assembler.label());
2866 
2867     // If we reached the last element -&gt; failure.
2868     failureCases.append(m_assembler.branchSub32(Assembler::Zero, Assembler::TrustedImm32(1), decIndexRegister));
2869 
2870     // Otherwise just loop over.
2871     m_assembler.addPtr(Assembler::TrustedImm32(sizeof(Attribute)), currentAttributeAddress);
2872     m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
2873 
2874     successCases.link(&amp;m_assembler);
2875 
2876     if (attributeSelector.match() != CSSSelector::Set) {
2877         // We make the assumption that name matching fails in most cases and we keep value matching outside
2878         // of the loop. We re-enter the loop if needed.
2879         // FIXME: exact case sensitive value matching is so simple that it should be done in the loop.
2880         Assembler::JumpList localFailureCases;
2881         generateElementAttributeValueMatching(localFailureCases, currentAttributeAddress, attributeInfo);
2882         localFailureCases.linkTo(loopReEntry, &amp;m_assembler);
2883     }
2884 }
2885 
2886 enum CaseSensitivity {
2887     CaseSensitive,
2888     CaseInsensitive
2889 };
2890 
2891 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2892 static bool attributeValueBeginsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2893 {
2894     ASSERT(expectedString);
2895 
<span class="line-modified">2896     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2897     if (caseSensitivity == CaseSensitive)
2898         return valueImpl.startsWith(*expectedString);
2899     return valueImpl.startsWithIgnoringASCIICase(*expectedString);
2900 }
2901 
2902 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2903 static bool attributeValueContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2904 {
<span class="line-modified">2905     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2906     if (caseSensitivity == CaseSensitive)
2907         return valueImpl.find(expectedString) != notFound;
2908     return valueImpl.findIgnoringASCIICase(expectedString) != notFound;
2909 }
2910 
2911 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2912 static bool attributeValueEndsWith(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2913 {
2914     ASSERT(expectedString);
2915 
<span class="line-modified">2916     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2917     if (caseSensitivity == CaseSensitive)
2918         return valueImpl.endsWith(*expectedString);
2919     return valueImpl.endsWithIgnoringASCIICase(*expectedString);
2920 }
2921 
2922 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2923 static bool attributeValueMatchHyphenRule(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2924 {
2925     ASSERT(expectedString);
2926 
<span class="line-modified">2927     AtomStringImpl&amp; valueImpl = *attribute-&gt;value().impl();</span>
2928     if (valueImpl.length() &lt; expectedString-&gt;length())
2929         return false;
2930 
2931     bool valueStartsWithExpectedString;
2932     if (caseSensitivity == CaseSensitive)
2933         valueStartsWithExpectedString = valueImpl.startsWith(*expectedString);
2934     else
2935         valueStartsWithExpectedString = valueImpl.startsWithIgnoringASCIICase(*expectedString);
2936 
2937     if (!valueStartsWithExpectedString)
2938         return false;
2939 
2940     return valueImpl.length() == expectedString-&gt;length() || valueImpl[expectedString-&gt;length()] == &#39;-&#39;;
2941 }
2942 
2943 template&lt;CaseSensitivity caseSensitivity&gt;
<span class="line-modified">2944 static bool attributeValueSpaceSeparetedListContains(const Attribute* attribute, AtomStringImpl* expectedString)</span>
2945 {
<span class="line-modified">2946     AtomStringImpl&amp; value = *attribute-&gt;value().impl();</span>
2947 
2948     unsigned startSearchAt = 0;
2949     while (true) {
2950         size_t foundPos;
2951         if (caseSensitivity == CaseSensitive)
2952             foundPos = value.find(expectedString, startSearchAt);
2953         else
2954             foundPos = value.findIgnoringASCIICase(expectedString, startSearchAt);
2955         if (foundPos == notFound)
2956             return false;
2957         if (!foundPos || isHTMLSpace(value[foundPos - 1])) {
2958             unsigned endStr = foundPos + expectedString-&gt;length();
2959             if (endStr == value.length() || isHTMLSpace(value[endStr]))
2960                 return true;
2961         }
2962         startSearchAt = foundPos + 1;
2963     }
2964     return false;
2965 }
2966 
2967 void SelectorCodeGenerator::generateElementAttributeValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AttributeMatchingInfo&amp; attributeInfo)
2968 {
2969     const CSSSelector&amp; attributeSelector = attributeInfo.selector();
<span class="line-modified">2970     const AtomString&amp; expectedValue = attributeSelector.value();</span>
2971     ASSERT(!expectedValue.isNull());
2972     AttributeCaseSensitivity valueCaseSensitivity = attributeInfo.attributeCaseSensitivity();
2973 
2974     switch (attributeSelector.match()) {
2975     case CSSSelector::Begin:
2976         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueBeginsWith&lt;CaseSensitive&gt;, attributeValueBeginsWith&lt;CaseInsensitive&gt;);
2977         break;
2978     case CSSSelector::Contain:
2979         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueContains&lt;CaseSensitive&gt;, attributeValueContains&lt;CaseInsensitive&gt;);
2980         break;
2981     case CSSSelector::End:
2982         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueEndsWith&lt;CaseSensitive&gt;, attributeValueEndsWith&lt;CaseInsensitive&gt;);
2983         break;
2984     case CSSSelector::Exact:
2985         generateElementAttributeValueExactMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity);
2986         break;
2987     case CSSSelector::Hyphen:
2988         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueMatchHyphenRule&lt;CaseSensitive&gt;, attributeValueMatchHyphenRule&lt;CaseInsensitive&gt;);
2989         break;
2990     case CSSSelector::List:
2991         generateElementAttributeFunctionCallValueMatching(failureCases, currentAttributeAddress, expectedValue, valueCaseSensitivity, attributeValueSpaceSeparetedListContains&lt;CaseSensitive&gt;, attributeValueSpaceSeparetedListContains&lt;CaseInsensitive&gt;);
2992         break;
2993     default:
2994         ASSERT_NOT_REACHED();
2995     }
2996 }
2997 
2998 static inline Assembler::Jump testIsHTMLClassOnDocument(Assembler::ResultCondition condition, Assembler&amp; assembler, Assembler::RegisterID documentAddress)
2999 {
3000     return assembler.branchTest32(condition, Assembler::Address(documentAddress, Document::documentClassesMemoryOffset()), Assembler::TrustedImm32(Document::isHTMLDocumentClassFlag()));
3001 }
3002 
<span class="line-modified">3003 void SelectorCodeGenerator::generateElementAttributeValueExactMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity)</span>
3004 {
3005     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3006     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3007 
3008     switch (valueCaseSensitivity) {
3009     case AttributeCaseSensitivity::CaseSensitive: {
3010         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister));
3011         break;
3012     }
3013     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3014         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), expectedValueRegister);
3015 
3016         // If the element is an HTML element, in a HTML dcoument (not including XHTML), value matching is case insensitive.
3017         // Taking the contrapositive, if we find the element is not HTML or is not in a HTML document, the condition above
3018         // sould be sufficient and we can fail early.
3019         failureCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3020 
3021         {
3022             LocalRegister document(m_registerAllocator);
3023             DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
</pre>
<hr />
<pre>
3033         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3034 
3035         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3036         break;
3037     }
3038     case AttributeCaseSensitivity::CaseInsensitive: {
3039         LocalRegister valueStringImpl(m_registerAllocator);
3040         m_assembler.loadPtr(Assembler::Address(currentAttributeAddress, Attribute::valueMemoryOffset()), valueStringImpl);
3041 
3042         Assembler::Jump skipCaseInsensitiveComparison = m_assembler.branchPtr(Assembler::Equal, valueStringImpl, expectedValueRegister);
3043         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3044         functionCall.setFunctionAddress(WTF::equalIgnoringASCIICaseNonNull);
3045         functionCall.setTwoArguments(valueStringImpl, expectedValueRegister);
3046         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3047         skipCaseInsensitiveComparison.link(&amp;m_assembler);
3048         break;
3049     }
3050     }
3051 }
3052 
<span class="line-modified">3053 void SelectorCodeGenerator::generateElementAttributeFunctionCallValueMatching(Assembler::JumpList&amp; failureCases, Assembler::RegisterID currentAttributeAddress, const AtomString&amp; expectedValue, AttributeCaseSensitivity valueCaseSensitivity, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseSensitiveTest, JSC::FunctionPtr&lt;CSSOperationPtrTag&gt; caseInsensitiveTest)</span>
3054 {
3055     LocalRegisterWithPreference expectedValueRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3056     m_assembler.move(Assembler::TrustedImmPtr(expectedValue.impl()), expectedValueRegister);
3057 
3058 
3059     switch (valueCaseSensitivity) {
3060     case AttributeCaseSensitivity::CaseSensitive: {
3061         FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3062         functionCall.setFunctionAddress(caseSensitiveTest);
3063         functionCall.setTwoArguments(currentAttributeAddress, expectedValueRegister);
3064         failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3065         break;
3066     }
3067     case AttributeCaseSensitivity::HTMLLegacyCaseInsensitive: {
3068         Assembler::JumpList shouldUseCaseSensitiveComparison;
3069         shouldUseCaseSensitiveComparison.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3070         {
3071             LocalRegister scratchRegister(m_registerAllocator);
3072             // scratchRegister = pointer to treeScope.
3073             m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Node::treeScopeMemoryOffset()), scratchRegister);
</pre>
<hr />
<pre>
3254     Assembler::JumpList successCases;
3255     if (m_selectorContext != SelectorContext::QuerySelector &amp;&amp; fragment.relationToRightFragment != FragmentRelation::Rightmost) {
3256         // :hover always matches when not in rightmost position when collecting rules for descendant style invalidation optimization.
3257         // Resolving style for a matching descendant will set parent childrenAffectedByHover bit even when the element is not currently hovered.
3258         // This bit has to be set for the event based :hover invalidation to work.
3259         // FIXME: We should just collect style relation bits and apply them as needed when computing style invalidation optimization.
3260         LocalRegister checkingContext(m_registerAllocator);
3261         successCases.append(branchOnResolvingMode(Assembler::Equal, SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements, checkingContext));
3262     }
3263 
3264     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3265     functionCall.setFunctionAddress(elementIsHovered);
3266     functionCall.setOneArgument(elementAddressRegister);
3267     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3268 
3269     successCases.link(&amp;m_assembler);
3270 }
3271 
3272 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const SelectorFragment&amp; fragment)
3273 {
<span class="line-modified">3274     for (const Vector&lt;AtomString&gt;* languageArguments : fragment.languageArgumentsList)</span>
3275         generateElementIsInLanguage(failureCases, languageArguments);
3276 }
3277 
<span class="line-modified">3278 void SelectorCodeGenerator::generateElementIsInLanguage(Assembler::JumpList&amp; failureCases, const Vector&lt;AtomString&gt;* languageArguments)</span>
3279 {
3280     LocalRegisterWithPreference langRangeRegister(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3281     m_assembler.move(Assembler::TrustedImmPtr(languageArguments), langRangeRegister);
3282 
3283     Assembler::RegisterID elementAddress = elementAddressRegister;
3284     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3285     functionCall.setFunctionAddress(matchesLangPseudoClass);
3286     functionCall.setTwoArguments(elementAddress, langRangeRegister);
3287     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3288 }
3289 
3290 void SelectorCodeGenerator::generateElementIsLastChild(Assembler::JumpList&amp; failureCases)
3291 {
3292     if (m_selectorContext == SelectorContext::QuerySelector) {
3293         Assembler::JumpList successCase = jumpIfNoNextAdjacentElement();
3294         failureCases.append(m_assembler.jump());
3295 
3296         successCase.link(&amp;m_assembler);
3297         LocalRegister parent(m_registerAllocator);
3298         generateWalkToParentElementOrShadowRoot(failureCases, parent);
</pre>
<hr />
<pre>
3441     Assembler::RegisterID checkingContext = m_registerAllocator.allocateRegisterWithPreference(JSC::GPRInfo::argumentGPR1);
3442     loadCheckingContext(checkingContext);
3443     m_registerAllocator.deallocateRegister(checkingContext);
3444 
3445     FunctionCall functionCall(m_assembler, m_registerAllocator, m_stackAllocator, m_functionCalls);
3446     functionCall.setFunctionAddress(makeContextStyleUniqueIfNecessaryAndTestIsPlaceholderShown);
3447     functionCall.setTwoArguments(elementAddressRegister, checkingContext);
3448     failureCases.append(functionCall.callAndBranchOnBooleanReturnValue(Assembler::Zero));
3449 }
3450 
3451 inline void SelectorCodeGenerator::generateElementHasTagName(Assembler::JumpList&amp; failureCases, const CSSSelector&amp; tagMatchingSelector)
3452 {
3453     const QualifiedName&amp; nameToMatch = tagMatchingSelector.tagQName();
3454     if (nameToMatch == anyQName())
3455         return;
3456 
3457     // Load the QualifiedNameImpl from the input.
3458     LocalRegister qualifiedNameImpl(m_registerAllocator);
3459     m_assembler.loadPtr(Assembler::Address(elementAddressRegister, Element::tagQNameMemoryOffset() + QualifiedName::implMemoryOffset()), qualifiedNameImpl);
3460 
<span class="line-modified">3461     const AtomString&amp; selectorLocalName = nameToMatch.localName();</span>
3462     if (selectorLocalName != starAtom()) {
<span class="line-modified">3463         const AtomString&amp; lowercaseLocalName = tagMatchingSelector.tagLowercaseLocalName();</span>
3464 
3465         if (selectorLocalName == lowercaseLocalName) {
3466             // Generate localName == element-&gt;localName().
3467             LocalRegister constantRegister(m_registerAllocator);
3468             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3469             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3470         } else {
3471             Assembler::JumpList caseSensitiveCases;
3472             caseSensitiveCases.append(DOMJIT::branchTestIsHTMLFlagOnNode(m_assembler, Assembler::Zero, elementAddressRegister));
3473             {
3474                 LocalRegister document(m_registerAllocator);
3475                 DOMJIT::loadDocument(m_assembler, elementAddressRegister, document);
3476                 caseSensitiveCases.append(testIsHTMLClassOnDocument(Assembler::Zero, m_assembler, document));
3477             }
3478 
3479             LocalRegister constantRegister(m_registerAllocator);
3480             m_assembler.move(Assembler::TrustedImmPtr(lowercaseLocalName.impl()), constantRegister);
3481             Assembler::Jump skipCaseSensitiveCase = m_assembler.jump();
3482 
3483             caseSensitiveCases.link(&amp;m_assembler);
3484             m_assembler.move(Assembler::TrustedImmPtr(selectorLocalName.impl()), constantRegister);
3485             skipCaseSensitiveCase.link(&amp;m_assembler);
3486 
3487             failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::localNameMemoryOffset()), constantRegister));
3488         }
3489     }
3490 
<span class="line-modified">3491     const AtomString&amp; selectorNamespaceURI = nameToMatch.namespaceURI();</span>
3492     if (selectorNamespaceURI != starAtom()) {
3493         // Generate namespaceURI == element-&gt;namespaceURI().
3494         LocalRegister constantRegister(m_registerAllocator);
3495         m_assembler.move(Assembler::TrustedImmPtr(selectorNamespaceURI.impl()), constantRegister);
3496         failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(qualifiedNameImpl, QualifiedName::QualifiedNameImpl::namespaceMemoryOffset()), constantRegister));
3497     }
3498 }
3499 
<span class="line-modified">3500 void SelectorCodeGenerator::generateElementHasId(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const AtomString&amp; idToMatch)</span>
3501 {
<span class="line-modified">3502     // Compare the pointers of the AtomStringImpl from idForStyleResolution with the reference idToMatch.</span>
3503     LocalRegister idToMatchRegister(m_registerAllocator);
3504     m_assembler.move(Assembler::TrustedImmPtr(idToMatch.impl()), idToMatchRegister);
3505     failureCases.append(m_assembler.branchPtr(Assembler::NotEqual, Assembler::Address(elementDataAddress, ElementData::idForStyleResolutionMemoryOffset()), idToMatchRegister));
3506 }
3507 
<span class="line-modified">3508 void SelectorCodeGenerator::generateElementHasClasses(Assembler::JumpList&amp; failureCases, const LocalRegister&amp; elementDataAddress, const Vector&lt;const AtomStringImpl*, 8&gt;&amp; classNames)</span>
3509 {
3510     // Load m_classNames.
3511     LocalRegister spaceSplitStringData(m_registerAllocator);
3512     m_assembler.loadPtr(Assembler::Address(elementDataAddress, ElementData::classNamesMemoryOffset()), spaceSplitStringData);
3513 
3514     // If SpaceSplitString does not have a SpaceSplitStringData pointer, it is empty -&gt; failure case.
3515     failureCases.append(m_assembler.branchTestPtr(Assembler::Zero, spaceSplitStringData));
3516 
3517     // We loop over the classes of SpaceSplitStringData for each class name we need to match.
3518     LocalRegister indexRegister(m_registerAllocator);
3519     for (unsigned i = 0; i &lt; classNames.size(); ++i) {
3520         LocalRegister classNameToMatch(m_registerAllocator);
3521         m_assembler.move(Assembler::TrustedImmPtr(classNames[i]), classNameToMatch);
3522         m_assembler.move(Assembler::TrustedImm32(0), indexRegister);
3523 
3524         // Beginning of a loop over all the class name of element to find the one we are looking for.
3525         Assembler::Label loopStart(m_assembler.label());
3526 
3527         // If the pointers match, proceed to the next matcher.
3528         Assembler::Jump classFound = m_assembler.branchPtr(Assembler::Equal, Assembler::BaseIndex(spaceSplitStringData, indexRegister, Assembler::timesPtr(), SpaceSplitStringData::tokensMemoryOffset()), classNameToMatch);
</pre>
<hr />
<pre>
3585     }
3586     if (validSubsetFilters.isEmpty())
3587         return;
3588 
3589     // Setup the counter at 1.
3590     LocalRegisterWithPreference elementCounter(m_registerAllocator, JSC::GPRInfo::argumentGPR1);
3591     m_assembler.move(Assembler::TrustedImm32(1), elementCounter);
3592 
3593     // Loop over the previous adjacent elements and increment the counter.
3594     {
3595         LocalRegister previousSibling(m_registerAllocator);
3596         m_assembler.move(elementAddressRegister, previousSibling);
3597 
3598         // Getting the child index is very efficient when it works. When there is no child index,
3599         // querying at every iteration is very inefficient. We solve this by only testing the child
3600         // index on the first direct adjacent.
3601         Assembler::JumpList noMoreSiblingsCases;
3602 
3603         Assembler::JumpList noCachedChildIndexCases;
3604         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
<span class="line-modified">3605 </span>
<span class="line-added">3606         LocalRegister elementRareData(m_registerAllocator);</span>
<span class="line-added">3607         m_assembler.loadPtr(Assembler::Address(previousSibling, Node::rareDataMemoryOffset()), elementRareData);</span>
<span class="line-added">3608 </span>
<span class="line-added">3609         noCachedChildIndexCases.append(m_assembler.branchTestPtr(Assembler::Zero, elementRareData));</span>
3610         {


3611             LocalRegister cachedChildIndex(m_registerAllocator);
3612             m_assembler.load16(Assembler::Address(elementRareData, ElementRareData::childIndexMemoryOffset()), cachedChildIndex);
3613             noCachedChildIndexCases.append(m_assembler.branchTest32(Assembler::Zero, cachedChildIndex));
3614             m_assembler.add32(cachedChildIndex, elementCounter);
3615             noMoreSiblingsCases.append(m_assembler.jump());
3616         }
3617         noCachedChildIndexCases.link(&amp;m_assembler);
3618         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3619 
3620         Assembler::Label loopStart = m_assembler.label();
3621         generateWalkToPreviousAdjacentElement(noMoreSiblingsCases, previousSibling);
3622         m_assembler.add32(Assembler::TrustedImm32(1), elementCounter);
3623         m_assembler.jump().linkTo(loopStart, &amp;m_assembler);
3624         noMoreSiblingsCases.link(&amp;m_assembler);
3625     }
3626 
3627     generateAddStyleRelationIfResolvingStyle(elementAddressRegister, Style::Relation::NthChildIndex, Assembler::RegisterID(elementCounter));
3628 
3629     for (const auto&amp; slot : validSubsetFilters)
3630         generateNthFilterTest(failureCases, elementCounter, slot.first, slot.second);
</pre>
</td>
</tr>
</table>
<center><a href="../css/typedom/TypedOMCSSUnparsedValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackAllocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>