<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioBufferSourceNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 93,20 ***</span>
  #include &quot;Settings.h&quot;
  #endif
  
  #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  #include &lt;wtf/Atomics.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/Ref.h&gt;
  #include &lt;wtf/RefCounted.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  const unsigned MaxPeriodicWaveLength = 4096;
  
  namespace WebCore {
  
<span class="line-modified">! #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(document()-&gt;page() &amp;&amp; document()-&gt;page()-&gt;isAlwaysOnLoggingAllowed(), Media, &quot;%p - AudioContext::&quot; fmt, this, ##__VA_ARGS__)</span>
  
  bool AudioContext::isSampleRateRangeGood(float sampleRate)
  {
      // FIXME: It would be nice if the minimum sample-rate could be less than 44.1KHz,
      // but that will require some fixes in HRTFPanner::fftSizeForSampleRate(), and some testing there.
<span class="line-new-header">--- 93,24 ---</span>
  #include &quot;Settings.h&quot;
  #endif
  
  #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
  #include &lt;wtf/Atomics.h&gt;
<span class="line-added">+ #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/Ref.h&gt;
  #include &lt;wtf/RefCounted.h&gt;
<span class="line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  #include &lt;wtf/text/WTFString.h&gt;
  
  const unsigned MaxPeriodicWaveLength = 4096;
  
  namespace WebCore {
  
<span class="line-modified">! WTF_MAKE_ISO_ALLOCATED_IMPL(AudioContext);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(document() &amp;&amp; document()-&gt;page() &amp;&amp; document()-&gt;page()-&gt;isAlwaysOnLoggingAllowed(), Media, &quot;%p - AudioContext::&quot; fmt, this, ##__VA_ARGS__)</span>
  
  bool AudioContext::isSampleRateRangeGood(float sampleRate)
  {
      // FIXME: It would be nice if the minimum sample-rate could be less than 44.1KHz,
      // but that will require some fixes in HRTFPanner::fftSizeForSampleRate(), and some testing there.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,45 ***</span>
  }
  
  // Constructor for rendering to the audio hardware.
  AudioContext::AudioContext(Document&amp; document)
      : ActiveDOMObject(document)
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="line-modified">!     , m_eventQueue(std::make_unique&lt;GenericEventQueue&gt;(*this))</span>
  {
      constructCommon();
  
      m_destinationNode = DefaultAudioDestinationNode::create(*this);
  
      // Initialize the destination node&#39;s muted state to match the page&#39;s current muted state.
      pageMutedStateDidChange();
  }
  
  // Constructor for offline (non-realtime) rendering.
  AudioContext::AudioContext(Document&amp; document, unsigned numberOfChannels, size_t numberOfFrames, float sampleRate)
      : ActiveDOMObject(document)
      , m_isOfflineContext(true)
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="line-modified">!     , m_eventQueue(std::make_unique&lt;GenericEventQueue&gt;(*this))</span>
  {
      constructCommon();
  
      // Create a new destination for offline rendering.
      m_renderTarget = AudioBuffer::create(numberOfChannels, numberOfFrames, sampleRate);
      m_destinationNode = OfflineAudioDestinationNode::create(*this, m_renderTarget.get());
  }
  
  void AudioContext::constructCommon()
  {
<span class="line-removed">-     // According to spec AudioContext must die only after page navigate.</span>
<span class="line-removed">-     // Lets mark it as ActiveDOMObject with pending activity and unmark it in clear method.</span>
<span class="line-removed">-     setPendingActivity(*this);</span>
<span class="line-removed">- </span>
      FFTFrame::initialize();
  
      m_listener = AudioListener::create();
  
      if (document()-&gt;audioPlaybackRequiresUserGesture())
          addBehaviorRestriction(RequireUserGestureForAudioStartRestriction);
      else
          m_restrictions = NoRestrictions;
  
<span class="line-new-header">--- 133,57 ---</span>
  }
  
  // Constructor for rendering to the audio hardware.
  AudioContext::AudioContext(Document&amp; document)
      : ActiveDOMObject(document)
<span class="line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">+     , m_logger(document.logger())</span>
<span class="line-added">+     , m_logIdentifier(uniqueLogIdentifier())</span>
<span class="line-added">+ #endif</span>
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="line-modified">!     , m_eventQueue(makeUnique&lt;GenericEventQueue&gt;(*this))</span>
  {
<span class="line-added">+     // According to spec AudioContext must die only after page navigate.</span>
<span class="line-added">+     // Lets mark it as ActiveDOMObject with pending activity and unmark it in clear method.</span>
<span class="line-added">+     makePendingActivity();</span>
<span class="line-added">+ </span>
      constructCommon();
  
      m_destinationNode = DefaultAudioDestinationNode::create(*this);
  
      // Initialize the destination node&#39;s muted state to match the page&#39;s current muted state.
      pageMutedStateDidChange();
<span class="line-added">+ </span>
<span class="line-added">+     document.addAudioProducer(*this);</span>
<span class="line-added">+     document.registerForVisibilityStateChangedCallbacks(*this);</span>
  }
  
  // Constructor for offline (non-realtime) rendering.
  AudioContext::AudioContext(Document&amp; document, unsigned numberOfChannels, size_t numberOfFrames, float sampleRate)
      : ActiveDOMObject(document)
<span class="line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">+     , m_logger(document.logger())</span>
<span class="line-added">+     , m_logIdentifier(uniqueLogIdentifier())</span>
<span class="line-added">+ #endif</span>
      , m_isOfflineContext(true)
      , m_mediaSession(PlatformMediaSession::create(*this))
<span class="line-modified">!     , m_eventQueue(makeUnique&lt;GenericEventQueue&gt;(*this))</span>
  {
      constructCommon();
  
      // Create a new destination for offline rendering.
      m_renderTarget = AudioBuffer::create(numberOfChannels, numberOfFrames, sampleRate);
      m_destinationNode = OfflineAudioDestinationNode::create(*this, m_renderTarget.get());
  }
  
  void AudioContext::constructCommon()
  {
      FFTFrame::initialize();
  
      m_listener = AudioListener::create();
  
<span class="line-added">+     ASSERT(document());</span>
      if (document()-&gt;audioPlaybackRequiresUserGesture())
          addBehaviorRestriction(RequireUserGestureForAudioStartRestriction);
      else
          m_restrictions = NoRestrictions;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,14 ***</span>
<span class="line-new-header">--- 205,21 ---</span>
      ASSERT(m_automaticPullNodes.isEmpty());
      if (m_automaticPullNodesNeedUpdating)
          m_renderingAutomaticPullNodes.resize(m_automaticPullNodes.size());
      ASSERT(m_renderingAutomaticPullNodes.isEmpty());
      // FIXME: Can we assert that m_deferredFinishDerefList is empty?
<span class="line-added">+ </span>
<span class="line-added">+     if (!isOfflineContext() &amp;&amp; scriptExecutionContext()) {</span>
<span class="line-added">+         document()-&gt;removeAudioProducer(*this);</span>
<span class="line-added">+         document()-&gt;unregisterForVisibilityStateChangedCallbacks(*this);</span>
<span class="line-added">+     }</span>
  }
  
  void AudioContext::lazyInitialize()
  {
<span class="line-added">+     ASSERT(!m_isStopScheduled);</span>
<span class="line-added">+ </span>
      if (m_isInitialized)
          return;
  
      // Don&#39;t allow the context to initialize a second time after it&#39;s already been explicitly uninitialized.
      ASSERT(!m_isAudioThreadFinished);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,13 ***</span>
  
      if (m_destinationNode) {
          m_destinationNode-&gt;initialize();
  
          if (!isOfflineContext()) {
<span class="line-removed">-             document()-&gt;addAudioProducer(*this);</span>
<span class="line-removed">-             document()-&gt;registerForVisibilityStateChangedCallbacks(*this);</span>
<span class="line-removed">- </span>
              // This starts the audio thread. The destination node&#39;s provideInput() method will now be called repeatedly to render audio.
              // Each time provideInput() is called, a portion of the audio stream is rendered. Let&#39;s call this time period a &quot;render quantum&quot;.
              // NOTE: for now default AudioContext does not need an explicit startRendering() call from JavaScript.
              // We may want to consider requiring it for symmetry with OfflineAudioContext.
              startRendering();
<span class="line-new-header">--- 228,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,10 ***</span>
<span class="line-new-header">--- 241,12 ---</span>
      m_isInitialized = true;
  }
  
  void AudioContext::clear()
  {
<span class="line-added">+     Ref&lt;AudioContext&gt; protectedThis(*this);</span>
<span class="line-added">+ </span>
      // We have to release our reference to the destination node before the context will ever be deleted since the destination node holds a reference to the context.
      if (m_destinationNode)
          m_destinationNode = nullptr;
  
      // Audio thread is dead. Nobody will schedule node deletion action. Let&#39;s do it ourselves.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,31 ***</span>
          deleteMarkedNodes();
          m_nodesToDelete.appendVector(m_nodesMarkedForDeletion);
          m_nodesMarkedForDeletion.clear();
      } while (m_nodesToDelete.size());
  
<span class="line-modified">!     // It was set in constructCommon.</span>
<span class="line-removed">-     unsetPendingActivity(*this);</span>
  }
  
  void AudioContext::uninitialize()
  {
      ASSERT(isMainThread());
  
      if (!m_isInitialized)
          return;
  
      // This stops the audio thread and all audio rendering.
<span class="line-modified">!     m_destinationNode-&gt;uninitialize();</span>
  
      // Don&#39;t allow the context to initialize a second time after it&#39;s already been explicitly uninitialized.
      m_isAudioThreadFinished = true;
  
      if (!isOfflineContext()) {
<span class="line-removed">-         document()-&gt;removeAudioProducer(*this);</span>
<span class="line-removed">-         document()-&gt;unregisterForVisibilityStateChangedCallbacks(*this);</span>
<span class="line-removed">- </span>
          ASSERT(s_hardwareContextCount);
          --s_hardwareContextCount;
  
          // Offline contexts move to &#39;Closed&#39; state when dispatching the completion event.
          setState(State::Closed);
<span class="line-new-header">--- 254,30 ---</span>
          deleteMarkedNodes();
          m_nodesToDelete.appendVector(m_nodesMarkedForDeletion);
          m_nodesMarkedForDeletion.clear();
      } while (m_nodesToDelete.size());
  
<span class="line-modified">!     clearPendingActivity();</span>
  }
  
  void AudioContext::uninitialize()
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
  
      if (!m_isInitialized)
          return;
  
      // This stops the audio thread and all audio rendering.
<span class="line-modified">!     if (m_destinationNode)</span>
<span class="line-added">+         m_destinationNode-&gt;uninitialize();</span>
  
      // Don&#39;t allow the context to initialize a second time after it&#39;s already been explicitly uninitialized.
      m_isAudioThreadFinished = true;
  
      if (!isOfflineContext()) {
          ASSERT(s_hardwareContextCount);
          --s_hardwareContextCount;
  
          // Offline contexts move to &#39;Closed&#39; state when dispatching the completion event.
          setState(State::Closed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 301,17 ***</span>
<span class="line-new-header">--- 322,20 ---</span>
          promise.resolve();
  }
  
  void AudioContext::stop()
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
  
      // Usually ScriptExecutionContext calls stop twice.
      if (m_isStopScheduled)
          return;
      m_isStopScheduled = true;
  
<span class="line-added">+     ASSERT(document());</span>
      document()-&gt;updateIsPlayingMedia();
  
      m_eventQueue-&gt;close();
  
      uninitialize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 329,11 ***</span>
      return &quot;AudioContext&quot;;
  }
  
  Document* AudioContext::document() const
  {
<span class="line-removed">-     ASSERT(m_scriptExecutionContext);</span>
      return downcast&lt;Document&gt;(m_scriptExecutionContext);
  }
  
  Document* AudioContext::hostingDocument() const
  {
<span class="line-new-header">--- 353,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
  }
  
  void AudioContext::visibilityStateChanged()
  {
      // Do not suspend if audio is audible.
<span class="line-modified">!     if (mediaState() == MediaProducer::IsPlayingAudio)</span>
          return;
  
      if (document()-&gt;hidden()) {
          if (state() == State::Running) {
              RELEASE_LOG_IF_ALLOWED(&quot;visibilityStateChanged() Suspending playback after going to the background&quot;);
<span class="line-new-header">--- 384,11 ---</span>
  }
  
  void AudioContext::visibilityStateChanged()
  {
      // Do not suspend if audio is audible.
<span class="line-modified">!     if (!document() || mediaState() == MediaProducer::IsPlayingAudio || m_isStopScheduled)</span>
          return;
  
      if (document()-&gt;hidden()) {
          if (state() == State::Running) {
              RELEASE_LOG_IF_ALLOWED(&quot;visibilityStateChanged() Suspending playback after going to the background&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,18 ***</span>
      return audioBuffer.releaseNonNull();
  }
  
  void AudioContext::decodeAudioData(Ref&lt;ArrayBuffer&gt;&amp;&amp; audioData, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; successCallback, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; errorCallback)
  {
<span class="line-modified">!     m_audioDecoder.decodeAsync(WTFMove(audioData), sampleRate(), WTFMove(successCallback), WTFMove(errorCallback));</span>
  }
  
<span class="line-modified">! Ref&lt;AudioBufferSourceNode&gt; AudioContext::createBufferSource()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     Ref&lt;AudioBufferSourceNode&gt; node = AudioBufferSourceNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
<span class="line-new-header">--- 429,26 ---</span>
      return audioBuffer.releaseNonNull();
  }
  
  void AudioContext::decodeAudioData(Ref&lt;ArrayBuffer&gt;&amp;&amp; audioData, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; successCallback, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp; errorCallback)
  {
<span class="line-modified">!     if (!m_audioDecoder)</span>
<span class="line-added">+         m_audioDecoder = makeUnique&lt;AsyncAudioDecoder&gt;();</span>
<span class="line-added">+     m_audioDecoder-&gt;decodeAsync(WTFMove(audioData), sampleRate(), WTFMove(successCallback), WTFMove(errorCallback));</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;AudioBufferSourceNode&gt;&gt; AudioContext::createBufferSource()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+ </span>
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     Ref&lt;AudioBufferSourceNode&gt; node = AudioBufferSourceNode::create(*this, sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,32 ***</span>
  
  #if ENABLE(VIDEO)
  
  ExceptionOr&lt;Ref&lt;MediaElementAudioSourceNode&gt;&gt; AudioContext::createMediaElementSource(HTMLMediaElement&amp; mediaElement)
  {
      ASSERT(isMainThread());
<span class="line-removed">-     lazyInitialize();</span>
  
<span class="line-modified">!     if (mediaElement.audioSourceNode())</span>
          return Exception { InvalidStateError };
  
      auto node = MediaElementAudioSourceNode::create(*this, mediaElement);
  
      mediaElement.setAudioSourceNode(node.ptr());
  
      refNode(node.get()); // context keeps reference until node is disconnected
<span class="line-modified">!     return WTFMove(node);</span>
  }
  
  #endif
  
  #if ENABLE(MEDIA_STREAM)
  
  ExceptionOr&lt;Ref&lt;MediaStreamAudioSourceNode&gt;&gt; AudioContext::createMediaStreamSource(MediaStream&amp; mediaStream)
  {
      ASSERT(isMainThread());
  
      auto audioTracks = mediaStream.getAudioTracks();
      if (audioTracks.isEmpty())
          return Exception { InvalidStateError };
  
      MediaStreamTrack* providerTrack = nullptr;
<span class="line-new-header">--- 457,40 ---</span>
  
  #if ENABLE(VIDEO)
  
  ExceptionOr&lt;Ref&lt;MediaElementAudioSourceNode&gt;&gt; AudioContext::createMediaElementSource(HTMLMediaElement&amp; mediaElement)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
  
<span class="line-modified">!     if (m_isStopScheduled || mediaElement.audioSourceNode())</span>
          return Exception { InvalidStateError };
  
<span class="line-added">+     lazyInitialize();</span>
<span class="line-added">+ </span>
      auto node = MediaElementAudioSourceNode::create(*this, mediaElement);
  
      mediaElement.setAudioSourceNode(node.ptr());
  
      refNode(node.get()); // context keeps reference until node is disconnected
<span class="line-modified">!     return node;</span>
  }
  
  #endif
  
  #if ENABLE(MEDIA_STREAM)
  
  ExceptionOr&lt;Ref&lt;MediaStreamAudioSourceNode&gt;&gt; AudioContext::createMediaStreamSource(MediaStream&amp; mediaStream)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
  
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      auto audioTracks = mediaStream.getAudioTracks();
      if (audioTracks.isEmpty())
          return Exception { InvalidStateError };
  
      MediaStreamTrack* providerTrack = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,25 ***</span>
  
      auto node = MediaStreamAudioSourceNode::create(*this, mediaStream, *providerTrack);
      node-&gt;setFormat(2, sampleRate());
  
      refNode(node); // context keeps reference until node is disconnected
<span class="line-modified">!     return WTFMove(node);</span>
  }
  
<span class="line-modified">! Ref&lt;MediaStreamAudioDestinationNode&gt; AudioContext::createMediaStreamDestination()</span>
  {
      // FIXME: Add support for an optional argument which specifies the number of channels.
      // FIXME: The default should probably be stereo instead of mono.
      return MediaStreamAudioDestinationNode::create(*this, 1);
  }
  
  #endif
  
  ExceptionOr&lt;Ref&lt;ScriptProcessorNode&gt;&gt; AudioContext::createScriptProcessor(size_t bufferSize, size_t numberOfInputChannels, size_t numberOfOutputChannels)
  {
      ASSERT(isMainThread());
      lazyInitialize();
  
      // W3C Editor&#39;s Draft 06 June 2017
      //  https://webaudio.github.io/web-audio-api/#widl-BaseAudioContext-createScriptProcessor-ScriptProcessorNode-unsigned-long-bufferSize-unsigned-long-numberOfInputChannels-unsigned-long-numberOfOutputChannels
  
<span class="line-new-header">--- 507,34 ---</span>
  
      auto node = MediaStreamAudioSourceNode::create(*this, mediaStream, *providerTrack);
      node-&gt;setFormat(2, sampleRate());
  
      refNode(node); // context keeps reference until node is disconnected
<span class="line-modified">!     return node;</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;MediaStreamAudioDestinationNode&gt;&gt; AudioContext::createMediaStreamDestination()</span>
  {
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      // FIXME: Add support for an optional argument which specifies the number of channels.
      // FIXME: The default should probably be stereo instead of mono.
      return MediaStreamAudioDestinationNode::create(*this, 1);
  }
  
  #endif
  
  ExceptionOr&lt;Ref&lt;ScriptProcessorNode&gt;&gt; AudioContext::createScriptProcessor(size_t bufferSize, size_t numberOfInputChannels, size_t numberOfOutputChannels)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+ </span>
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
  
      // W3C Editor&#39;s Draft 06 June 2017
      //  https://webaudio.github.io/web-audio-api/#widl-BaseAudioContext-createScriptProcessor-ScriptProcessorNode-unsigned-long-bufferSize-unsigned-long-numberOfInputChannels-unsigned-long-numberOfOutputChannels
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,109 ***</span>
      // up to 32 must be supported. A NotSupportedError must be thrown if the number of channels is not supported.
  
      if (numberOfOutputChannels &gt; maxNumberOfChannels())
          return Exception { NotSupportedError };
  
<span class="line-modified">!     auto node = ScriptProcessorNode::create(*this, m_destinationNode-&gt;sampleRate(), bufferSize, numberOfInputChannels, numberOfOutputChannels);</span>
  
      refNode(node); // context keeps reference until we stop making javascript rendering callbacks
<span class="line-modified">!     return WTFMove(node);</span>
  }
  
<span class="line-modified">! Ref&lt;BiquadFilterNode&gt; AudioContext::createBiquadFilter()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return BiquadFilterNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
<span class="line-modified">! Ref&lt;WaveShaperNode&gt; AudioContext::createWaveShaper()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
      return WaveShaperNode::create(*this);
  }
  
<span class="line-modified">! Ref&lt;PannerNode&gt; AudioContext::createPanner()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return PannerNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
<span class="line-modified">! Ref&lt;ConvolverNode&gt; AudioContext::createConvolver()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return ConvolverNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
<span class="line-modified">! Ref&lt;DynamicsCompressorNode&gt; AudioContext::createDynamicsCompressor()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return DynamicsCompressorNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
<span class="line-modified">! Ref&lt;AnalyserNode&gt; AudioContext::createAnalyser()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return AnalyserNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
<span class="line-modified">! Ref&lt;GainNode&gt; AudioContext::createGain()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return GainNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  }
  
  ExceptionOr&lt;Ref&lt;DelayNode&gt;&gt; AudioContext::createDelay(double maxDelayTime)
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     return DelayNode::create(*this, m_destinationNode-&gt;sampleRate(), maxDelayTime);</span>
  }
  
  ExceptionOr&lt;Ref&lt;ChannelSplitterNode&gt;&gt; AudioContext::createChannelSplitter(size_t numberOfOutputs)
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     auto node = ChannelSplitterNode::create(*this, m_destinationNode-&gt;sampleRate(), numberOfOutputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
  ExceptionOr&lt;Ref&lt;ChannelMergerNode&gt;&gt; AudioContext::createChannelMerger(size_t numberOfInputs)
  {
      ASSERT(isMainThread());
      lazyInitialize();
<span class="line-modified">!     auto node = ChannelMergerNode::create(*this, m_destinationNode-&gt;sampleRate(), numberOfInputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
<span class="line-modified">! Ref&lt;OscillatorNode&gt; AudioContext::createOscillator()</span>
  {
      ASSERT(isMainThread());
      lazyInitialize();
  
<span class="line-modified">!     Ref&lt;OscillatorNode&gt; node = OscillatorNode::create(*this, m_destinationNode-&gt;sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
      return node;
  }
  
  ExceptionOr&lt;Ref&lt;PeriodicWave&gt;&gt; AudioContext::createPeriodicWave(Float32Array&amp; real, Float32Array&amp; imaginary)
  {
      ASSERT(isMainThread());
      if (real.length() != imaginary.length() || (real.length() &gt; MaxPeriodicWaveLength) || !real.length())
          return Exception { IndexSizeError };
      lazyInitialize();
      return PeriodicWave::create(sampleRate(), real, imaginary);
  }
<span class="line-new-header">--- 580,170 ---</span>
      // up to 32 must be supported. A NotSupportedError must be thrown if the number of channels is not supported.
  
      if (numberOfOutputChannels &gt; maxNumberOfChannels())
          return Exception { NotSupportedError };
  
<span class="line-modified">!     auto node = ScriptProcessorNode::create(*this, sampleRate(), bufferSize, numberOfInputChannels, numberOfOutputChannels);</span>
  
      refNode(node); // context keeps reference until we stop making javascript rendering callbacks
<span class="line-modified">!     return node;</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;BiquadFilterNode&gt;&gt; AudioContext::createBiquadFilter()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">! </span>
<span class="line-added">+     return BiquadFilterNode::create(*this, sampleRate());</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;WaveShaperNode&gt;&gt; AudioContext::createWaveShaper()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
      return WaveShaperNode::create(*this);
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;PannerNode&gt;&gt; AudioContext::createPanner()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return PannerNode::create(*this, sampleRate());</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;ConvolverNode&gt;&gt; AudioContext::createConvolver()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return ConvolverNode::create(*this, sampleRate());</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;DynamicsCompressorNode&gt;&gt; AudioContext::createDynamicsCompressor()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return DynamicsCompressorNode::create(*this, sampleRate());</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;AnalyserNode&gt;&gt; AudioContext::createAnalyser()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return AnalyserNode::create(*this, sampleRate());</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;GainNode&gt;&gt; AudioContext::createGain()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return GainNode::create(*this, sampleRate());</span>
  }
  
  ExceptionOr&lt;Ref&lt;DelayNode&gt;&gt; AudioContext::createDelay(double maxDelayTime)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     return DelayNode::create(*this, sampleRate(), maxDelayTime);</span>
  }
  
  ExceptionOr&lt;Ref&lt;ChannelSplitterNode&gt;&gt; AudioContext::createChannelSplitter(size_t numberOfOutputs)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     auto node = ChannelSplitterNode::create(*this, sampleRate(), numberOfOutputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
  ExceptionOr&lt;Ref&lt;ChannelMergerNode&gt;&gt; AudioContext::createChannelMerger(size_t numberOfInputs)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
<span class="line-modified">!     auto node = ChannelMergerNode::create(*this, sampleRate(), numberOfInputs);</span>
      if (!node)
          return Exception { IndexSizeError };
      return node.releaseNonNull();
  }
  
<span class="line-modified">! ExceptionOr&lt;Ref&lt;OscillatorNode&gt;&gt; AudioContext::createOscillator()</span>
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      lazyInitialize();
  
<span class="line-modified">!     Ref&lt;OscillatorNode&gt; node = OscillatorNode::create(*this, sampleRate());</span>
  
      // Because this is an AudioScheduledSourceNode, the context keeps a reference until it has finished playing.
      // When this happens, AudioScheduledSourceNode::finish() calls AudioContext::notifyNodeFinishedProcessing().
      refNode(node);
  
      return node;
  }
  
  ExceptionOr&lt;Ref&lt;PeriodicWave&gt;&gt; AudioContext::createPeriodicWave(Float32Array&amp; real, Float32Array&amp; imaginary)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
      ASSERT(isMainThread());
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return Exception { InvalidStateError };</span>
<span class="line-added">+ </span>
      if (real.length() != imaginary.length() || (real.length() &gt; MaxPeriodicWaveLength) || !real.length())
          return Exception { IndexSizeError };
      lazyInitialize();
      return PeriodicWave::create(sampleRate(), real, imaginary);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,11 ***</span>
          node-&gt;processIfNecessary(framesToProcess);
  }
  
  ScriptExecutionContext* AudioContext::scriptExecutionContext() const
  {
<span class="line-modified">!     return m_isStopScheduled ? 0 : ActiveDOMObject::scriptExecutionContext();</span>
  }
  
  void AudioContext::nodeWillBeginPlayback()
  {
      // Called by scheduled AudioNodes when clients schedule their start times.
<span class="line-new-header">--- 1069,11 ---</span>
          node-&gt;processIfNecessary(framesToProcess);
  }
  
  ScriptExecutionContext* AudioContext::scriptExecutionContext() const
  {
<span class="line-modified">!     return ActiveDOMObject::scriptExecutionContext();</span>
  }
  
  void AudioContext::nodeWillBeginPlayback()
  {
      // Called by scheduled AudioNodes when clients schedule their start times.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 978,30 ***</span>
          startRendering();
  }
  
  bool AudioContext::willBeginPlayback()
  {
      if (userGestureRequiredForAudioStart()) {
<span class="line-modified">!         if (!processingUserGestureForMedia() &amp;&amp; !document()-&gt;isCapturing())</span>
              return false;
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
  
      if (pageConsentRequiredForAudioStart()) {
          Page* page = document()-&gt;page();
          if (page &amp;&amp; !page-&gt;canStartMedia()) {
              document()-&gt;addMediaCanStartListener(*this);
              return false;
          }
          removeBehaviorRestriction(AudioContext::RequirePageConsentForAudioStartRestriction);
      }
  
<span class="line-modified">!     return m_mediaSession-&gt;clientWillBeginPlayback();</span>
  }
  
  bool AudioContext::willPausePlayback()
  {
      if (userGestureRequiredForAudioStart()) {
          if (!processingUserGestureForMedia())
              return false;
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
<span class="line-new-header">--- 1087,42 ---</span>
          startRendering();
  }
  
  bool AudioContext::willBeginPlayback()
  {
<span class="line-added">+     if (!document())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (userGestureRequiredForAudioStart()) {
<span class="line-modified">!         if (!processingUserGestureForMedia() &amp;&amp; !document()-&gt;isCapturing()) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, &quot;returning false, not processing user gesture or capturing&quot;);</span>
              return false;
<span class="line-added">+         }</span>
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
  
      if (pageConsentRequiredForAudioStart()) {
          Page* page = document()-&gt;page();
          if (page &amp;&amp; !page-&gt;canStartMedia()) {
              document()-&gt;addMediaCanStartListener(*this);
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, &quot;returning false, page doesn&#39;t allow media to start&quot;);</span>
              return false;
          }
          removeBehaviorRestriction(AudioContext::RequirePageConsentForAudioStartRestriction);
      }
  
<span class="line-modified">!     auto willBegin = m_mediaSession-&gt;clientWillBeginPlayback();</span>
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER, &quot;returning &quot;, willBegin);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return willBegin;</span>
  }
  
  bool AudioContext::willPausePlayback()
  {
<span class="line-added">+     if (!document())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (userGestureRequiredForAudioStart()) {
          if (!processingUserGestureForMedia())
              return false;
          removeBehaviorRestriction(AudioContext::RequireUserGestureForAudioStartRestriction);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1018,13 ***</span>
      return m_mediaSession-&gt;clientWillPausePlayback();
  }
  
  void AudioContext::startRendering()
  {
<span class="line-modified">!     if (!willBeginPlayback())</span>
          return;
  
      destination()-&gt;startRendering();
      setState(State::Running);
  }
  
  void AudioContext::mediaCanStart(Document&amp; document)
<span class="line-new-header">--- 1139,16 ---</span>
      return m_mediaSession-&gt;clientWillPausePlayback();
  }
  
  void AudioContext::startRendering()
  {
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+     if (m_isStopScheduled || !willBeginPlayback())</span>
          return;
  
<span class="line-added">+     makePendingActivity();</span>
<span class="line-added">+ </span>
      destination()-&gt;startRendering();
      setState(State::Running);
  }
  
  void AudioContext::mediaCanStart(Document&amp; document)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,11 ***</span>
      return MediaProducer::IsNotPlaying;
  }
  
  void AudioContext::pageMutedStateDidChange()
  {
<span class="line-modified">!     if (m_destinationNode &amp;&amp; document()-&gt;page())</span>
          m_destinationNode-&gt;setMuted(document()-&gt;page()-&gt;isAudioMuted());
  }
  
  void AudioContext::isPlayingAudioDidChange()
  {
<span class="line-new-header">--- 1166,11 ---</span>
      return MediaProducer::IsNotPlaying;
  }
  
  void AudioContext::pageMutedStateDidChange()
  {
<span class="line-modified">!     if (m_destinationNode &amp;&amp; document() &amp;&amp; document()-&gt;page())</span>
          m_destinationNode-&gt;setMuted(document()-&gt;page()-&gt;isAudioMuted());
  }
  
  void AudioContext::isPlayingAudioDidChange()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1056,28 ***</span>
          if (protectedThis-&gt;document())
              protectedThis-&gt;document()-&gt;updateIsPlayingMedia();
      });
  }
  
<span class="line-modified">! void AudioContext::fireCompletionEvent()</span>
  {
      ASSERT(isMainThread());
      if (!isMainThread())
          return;
  
      AudioBuffer* renderedBuffer = m_renderTarget.get();
      setState(State::Closed);
  
      ASSERT(renderedBuffer);
      if (!renderedBuffer)
          return;
  
      // Avoid firing the event if the document has already gone away.
<span class="line-modified">!     if (scriptExecutionContext()) {</span>
<span class="line-modified">!         // Call the offline rendering completion event listener.</span>
<span class="line-modified">!         m_eventQueue-&gt;enqueueEvent(OfflineAudioCompletionEvent::create(renderedBuffer));</span>
<span class="line-modified">!     }</span>
  }
  
  void AudioContext::incrementActiveSourceCount()
  {
      ++m_activeSourceCount;
<span class="line-new-header">--- 1180,47 ---</span>
          if (protectedThis-&gt;document())
              protectedThis-&gt;document()-&gt;updateIsPlayingMedia();
      });
  }
  
<span class="line-modified">! void AudioContext::finishedRendering(bool didRendering)</span>
  {
<span class="line-added">+     ASSERT(isOfflineContext());</span>
      ASSERT(isMainThread());
      if (!isMainThread())
          return;
  
<span class="line-added">+     auto clearPendingActivityIfExitEarly = WTF::makeScopeExit([this] {</span>
<span class="line-added">+         clearPendingActivity();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!didRendering)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      AudioBuffer* renderedBuffer = m_renderTarget.get();
      setState(State::Closed);
  
      ASSERT(renderedBuffer);
      if (!renderedBuffer)
          return;
  
      // Avoid firing the event if the document has already gone away.
<span class="line-modified">!     if (m_isStopScheduled)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     clearPendingActivityIfExitEarly.release();</span>
<span class="line-added">+     m_eventQueue-&gt;enqueueEvent(OfflineAudioCompletionEvent::create(renderedBuffer));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AudioContext::dispatchEvent(Event&amp; event)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     EventTarget::dispatchEvent(event);</span>
<span class="line-added">+     if (event.eventInterface() == OfflineAudioCompletionEventInterfaceType)</span>
<span class="line-added">+         clearPendingActivity();</span>
  }
  
  void AudioContext::incrementActiveSourceCount()
  {
      ++m_activeSourceCount;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,11 ***</span>
      --m_activeSourceCount;
  }
  
  void AudioContext::suspend(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext()) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Suspended) {
<span class="line-new-header">--- 1231,11 ---</span>
      --m_activeSourceCount;
  }
  
  void AudioContext::suspend(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Suspended) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1117,11 ***</span>
      });
  }
  
  void AudioContext::resume(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext()) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Running) {
<span class="line-new-header">--- 1260,11 ---</span>
      });
  }
  
  void AudioContext::resume(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Running) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1146,11 ***</span>
      });
  }
  
  void AudioContext::close(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext()) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Closed || !m_destinationNode) {
<span class="line-new-header">--- 1289,11 ---</span>
      });
  }
  
  void AudioContext::close(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
  {
<span class="line-modified">!     if (isOfflineContext() || m_isStopScheduled) {</span>
          promise.reject(InvalidStateError);
          return;
      }
  
      if (m_state == State::Closed || !m_destinationNode) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1206,9 ***</span>
<span class="line-new-header">--- 1349,51 ---</span>
      m_destinationNode-&gt;resume([this, protectedThis = makeRef(*this)] {
          setState(State::Running);
      });
  }
  
<span class="line-added">+ void AudioContext::postTask(WTF::Function&lt;void()&gt;&amp;&amp; task)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_isStopScheduled)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_scriptExecutionContext-&gt;postTask(WTFMove(task));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ const SecurityOrigin* AudioContext::origin() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_scriptExecutionContext ? m_scriptExecutionContext-&gt;securityOrigin() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AudioContext::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_scriptExecutionContext)</span>
<span class="line-added">+         m_scriptExecutionContext-&gt;addConsoleMessage(source, level, message);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AudioContext::clearPendingActivity()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_pendingActivity)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     m_pendingActivity = nullptr;</span>
<span class="line-added">+     // FIXME: Remove this specific deref() and ref() call in makePendingActivity().</span>
<span class="line-added">+     deref();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AudioContext::makePendingActivity()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_pendingActivity)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     m_pendingActivity = ActiveDOMObject::makePendingActivity(*this);</span>
<span class="line-added">+     ref();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">+ WTFLogChannel&amp; AudioContext::logChannel() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return LogMedia;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
  
  } // namespace WebCore
  
  #endif // ENABLE(WEB_AUDIO)
</pre>
<center><a href="AudioBufferSourceNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>