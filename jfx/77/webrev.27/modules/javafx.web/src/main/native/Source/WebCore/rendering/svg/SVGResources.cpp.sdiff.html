<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGResources.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGRenderTreeAsText.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGResourcesCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGResources.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #include &quot;RenderSVGResourceFilter.h&quot;
 27 #include &quot;RenderSVGResourceMarker.h&quot;
 28 #include &quot;RenderSVGResourceMasker.h&quot;
 29 #include &quot;RenderSVGRoot.h&quot;
 30 #include &quot;SVGGradientElement.h&quot;
 31 #include &quot;SVGNames.h&quot;
 32 #include &quot;SVGPatternElement.h&quot;
 33 #include &quot;SVGRenderStyle.h&quot;
 34 #include &quot;SVGURIReference.h&quot;
 35 
 36 #if ENABLE(TREE_DEBUGGING)
 37 #include &lt;stdio.h&gt;
 38 #endif
 39 
 40 namespace WebCore {
 41 
 42 SVGResources::SVGResources()
 43 {
 44 }
 45 
<span class="line-modified"> 46 static HashSet&lt;AtomicString&gt;&amp; clipperFilterMaskerTags()</span>
 47 {
<span class="line-modified"> 48     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; s_tagList;</span>
 49     if (s_tagList.get().isEmpty()) {
 50         // &quot;container elements&quot;: http://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 51         // &quot;graphics elements&quot; : http://www.w3.org/TR/SVG11/intro.html#TermGraphicsElement
 52         s_tagList.get().add(SVGNames::aTag-&gt;localName());
 53         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
 54         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
 55         s_tagList.get().add(SVGNames::glyphTag-&gt;localName());
 56         s_tagList.get().add(SVGNames::gTag-&gt;localName());
 57         s_tagList.get().add(SVGNames::imageTag-&gt;localName());
 58         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
 59         s_tagList.get().add(SVGNames::markerTag-&gt;localName());
 60         s_tagList.get().add(SVGNames::maskTag-&gt;localName());
 61         s_tagList.get().add(SVGNames::missing_glyphTag-&gt;localName());
 62         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
 63         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
 64         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
 65         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
 66         s_tagList.get().add(SVGNames::svgTag-&gt;localName());
 67         s_tagList.get().add(SVGNames::textTag-&gt;localName());
 68         s_tagList.get().add(SVGNames::useTag-&gt;localName());
</pre>
<hr />
<pre>
 75 
 76         // Not listed in the definitions are the text content elements, though filter/clipper/masker on tspan/text/.. is allowed.
 77         // (Already mailed SVG WG, waiting for a solution)
 78         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
 79         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
 80         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
 81         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
 82 
 83         // Not listed in the definitions is the foreignObject element, but clip-path
 84         // is a supported attribute.
 85         s_tagList.get().add(SVGNames::foreignObjectTag-&gt;localName());
 86 
 87         // Elements that we ignore, as it doesn&#39;t make any sense.
 88         // defs, pattern, switch (FIXME: Mail SVG WG about these)
 89         // symbol (is converted to a svg element, when referenced by use, we can safely ignore it.)
 90     }
 91 
 92     return s_tagList;
 93 }
 94 
<span class="line-modified"> 95 static HashSet&lt;AtomicString&gt;&amp; markerTags()</span>
 96 {
<span class="line-modified"> 97     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; s_tagList;</span>
 98     if (s_tagList.get().isEmpty()) {
 99         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
100         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
101         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
102         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
103     }
104 
105     return s_tagList;
106 }
107 
<span class="line-modified">108 static HashSet&lt;AtomicString&gt;&amp; fillAndStrokeTags()</span>
109 {
<span class="line-modified">110     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; s_tagList;</span>
111     if (s_tagList.get().isEmpty()) {
112         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
113         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
114         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
115         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
116         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
117         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
118         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
119         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
120         s_tagList.get().add(SVGNames::textTag-&gt;localName());
121         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
122         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
123         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
124     }
125 
126     return s_tagList;
127 }
128 
<span class="line-modified">129 static HashSet&lt;AtomicString&gt;&amp; chainableResourceTags()</span>
130 {
<span class="line-modified">131     static NeverDestroyed&lt;HashSet&lt;AtomicString&gt;&gt; s_tagList;</span>
132     if (s_tagList.get().isEmpty()) {
133         s_tagList.get().add(SVGNames::linearGradientTag-&gt;localName());
134         s_tagList.get().add(SVGNames::filterTag-&gt;localName());
135         s_tagList.get().add(SVGNames::patternTag-&gt;localName());
136         s_tagList.get().add(SVGNames::radialGradientTag-&gt;localName());
137     }
138 
139     return s_tagList;
140 }
141 
142 static inline String targetReferenceFromResource(SVGElement&amp; element)
143 {
144     String target;
145     if (is&lt;SVGPatternElement&gt;(element))
146         target = downcast&lt;SVGPatternElement&gt;(element).href();
147     else if (is&lt;SVGGradientElement&gt;(element))
148         target = downcast&lt;SVGGradientElement&gt;(element).href();
149     else if (is&lt;SVGFilterElement&gt;(element))
150         target = downcast&lt;SVGFilterElement&gt;(element).href();
151     else
152         ASSERT_NOT_REACHED();
153 
154     return SVGURIReference::fragmentIdentifierFromIRIString(target, element.document());
155 }
156 
157 static inline bool isChainableResource(const SVGElement&amp; element, const SVGElement&amp; linkedResource)
158 {
159     if (is&lt;SVGPatternElement&gt;(element))
160         return is&lt;SVGPatternElement&gt;(linkedResource);
161 
162     if (is&lt;SVGGradientElement&gt;(element))
163         return is&lt;SVGGradientElement&gt;(linkedResource);
164 
165     if (is&lt;SVGFilterElement&gt;(element))
166         return is&lt;SVGFilterElement&gt;(linkedResource);
167 
168     ASSERT_NOT_REACHED();
169     return false;
170 }
171 
<span class="line-modified">172 static inline RenderSVGResourceContainer* paintingResourceFromSVGPaint(Document&amp; document, const SVGPaintType&amp; paintType, const String&amp; paintUri, AtomicString&amp; id, bool&amp; hasPendingResource)</span>
173 {
174     if (paintType != SVGPaintType::URI &amp;&amp; paintType != SVGPaintType::URIRGBColor &amp;&amp; paintType != SVGPaintType::URICurrentColor)
175         return nullptr;
176 
177     id = SVGURIReference::fragmentIdentifierFromIRIString(paintUri, document);
178     RenderSVGResourceContainer* container = getRenderSVGResourceContainerById(document, id);
179     if (!container) {
180         hasPendingResource = true;
181         return nullptr;
182     }
183 
184     RenderSVGResourceType resourceType = container-&gt;resourceType();
185     if (resourceType != PatternResourceType &amp;&amp; resourceType != LinearGradientResourceType &amp;&amp; resourceType != RadialGradientResourceType)
186         return nullptr;
187 
188     return container;
189 }
190 
<span class="line-modified">191 static inline void registerPendingResource(SVGDocumentExtensions&amp; extensions, const AtomicString&amp; id, SVGElement&amp; element)</span>
192 {
193     extensions.addPendingResource(id, element);
194 }
195 
196 bool SVGResources::buildCachedResources(const RenderElement&amp; renderer, const RenderStyle&amp; style)
197 {
198     ASSERT(renderer.element());
199     ASSERT_WITH_SECURITY_IMPLICATION(renderer.element()-&gt;isSVGElement());
200 
201     if (!renderer.element())
202         return false;
203 
204     auto&amp; element = downcast&lt;SVGElement&gt;(*renderer.element());
205 
206     Document&amp; document = element.document();
207 
208     SVGDocumentExtensions&amp; extensions = document.accessSVGExtensions();
209 
<span class="line-modified">210     const AtomicString&amp; tagName = element.localName();</span>
211     if (tagName.isNull())
212         return false;
213 
214     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
215 
216     bool foundResources = false;
217     if (clipperFilterMaskerTags().contains(tagName)) {
218         if (svgStyle.hasClipper()) {
<span class="line-modified">219             AtomicString id(svgStyle.clipperResource());</span>
220             if (setClipper(getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document, id)))
221                 foundResources = true;
222             else
223                 registerPendingResource(extensions, id, element);
224         } else if (is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {
225             // FIXME: -webkit-clip-path should support external resources
226             // https://bugs.webkit.org/show_bug.cgi?id=127032
227             auto&amp; clipPath = downcast&lt;ReferenceClipPathOperation&gt;(*style.clipPath());
<span class="line-modified">228             AtomicString id(clipPath.fragment());</span>
229             if (setClipper(getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document, id)))
230                 foundResources = true;
231             else
232                 registerPendingResource(extensions, id, element);
233         }
234 
235         if (style.hasFilter()) {
236             const FilterOperations&amp; filterOperations = style.filter();
237             if (filterOperations.size() == 1) {
238                 const FilterOperation&amp; filterOperation = *filterOperations.at(0);
239                 if (filterOperation.type() == FilterOperation::REFERENCE) {
240                     const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified">241                     AtomicString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), element.document());</span>
242                     if (setFilter(getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(document, id)))
243                         foundResources = true;
244                     else
245                         registerPendingResource(extensions, id, element);
246                 }
247             }
248         }
249 
250         if (svgStyle.hasMasker()) {
<span class="line-modified">251             AtomicString id(svgStyle.maskerResource());</span>
252             if (setMasker(getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(document, id)))
253                 foundResources = true;
254             else
255                 registerPendingResource(extensions, id, element);
256         }
257     }
258 
259     if (markerTags().contains(tagName) &amp;&amp; svgStyle.hasMarkers()) {
<span class="line-modified">260         AtomicString markerStartId(svgStyle.markerStartResource());</span>
261         if (setMarkerStart(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerStartId)))
262             foundResources = true;
263         else
264             registerPendingResource(extensions, markerStartId, element);
265 
<span class="line-modified">266         AtomicString markerMidId(svgStyle.markerMidResource());</span>
267         if (setMarkerMid(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerMidId)))
268             foundResources = true;
269         else
270             registerPendingResource(extensions, markerMidId, element);
271 
<span class="line-modified">272         AtomicString markerEndId(svgStyle.markerEndResource());</span>
273         if (setMarkerEnd(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerEndId)))
274             foundResources = true;
275         else
276             registerPendingResource(extensions, markerEndId, element);
277     }
278 
279     if (fillAndStrokeTags().contains(tagName)) {
280         if (svgStyle.hasFill()) {
281             bool hasPendingResource = false;
<span class="line-modified">282             AtomicString id;</span>
283             if (setFill(paintingResourceFromSVGPaint(document, svgStyle.fillPaintType(), svgStyle.fillPaintUri(), id, hasPendingResource)))
284                 foundResources = true;
285             else if (hasPendingResource)
286                 registerPendingResource(extensions, id, element);
287         }
288 
289         if (svgStyle.hasStroke()) {
290             bool hasPendingResource = false;
<span class="line-modified">291             AtomicString id;</span>
292             if (setStroke(paintingResourceFromSVGPaint(document, svgStyle.strokePaintType(), svgStyle.strokePaintUri(), id, hasPendingResource)))
293                 foundResources = true;
294             else if (hasPendingResource)
295                 registerPendingResource(extensions, id, element);
296         }
297     }
298 
299     if (chainableResourceTags().contains(tagName)) {
<span class="line-modified">300         AtomicString id(targetReferenceFromResource(element));</span>
301         auto* linkedResource = getRenderSVGResourceContainerById(document, id);
302         if (!linkedResource)
303             registerPendingResource(extensions, id, element);
304         else if (isChainableResource(element, linkedResource-&gt;element())) {
305             setLinkedResource(linkedResource);
306             foundResources = true;
307         }
308     }
309 
310     return foundResources;
311 }
312 
313 void SVGResources::layoutDifferentRootIfNeeded(const RenderSVGRoot* svgRoot)
314 {
315     if (clipper() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*clipper()))
316         clipper()-&gt;layoutIfNeeded();
317 
318     if (masker() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*masker()))
319         masker()-&gt;layoutIfNeeded();
320 
</pre>
<hr />
<pre>
491         if (m_markerData-&gt;markerEnd)
492             set.add(m_markerData-&gt;markerEnd);
493     }
494 
495     if (m_fillStrokeData) {
496         if (m_fillStrokeData-&gt;fill)
497             set.add(m_fillStrokeData-&gt;fill);
498         if (m_fillStrokeData-&gt;stroke)
499             set.add(m_fillStrokeData-&gt;stroke);
500     }
501 }
502 
503 bool SVGResources::setClipper(RenderSVGResourceClipper* clipper)
504 {
505     if (!clipper)
506         return false;
507 
508     ASSERT(clipper-&gt;resourceType() == ClipperResourceType);
509 
510     if (!m_clipperFilterMaskerData)
<span class="line-modified">511         m_clipperFilterMaskerData = std::make_unique&lt;ClipperFilterMaskerData&gt;();</span>
512 
513     m_clipperFilterMaskerData-&gt;clipper = clipper;
514     return true;
515 }
516 
517 void SVGResources::resetClipper()
518 {
519     ASSERT(m_clipperFilterMaskerData);
520     ASSERT(m_clipperFilterMaskerData-&gt;clipper);
521     m_clipperFilterMaskerData-&gt;clipper = nullptr;
522 }
523 
524 bool SVGResources::setFilter(RenderSVGResourceFilter* filter)
525 {
526     if (!filter)
527         return false;
528 
529     ASSERT(filter-&gt;resourceType() == FilterResourceType);
530 
531     if (!m_clipperFilterMaskerData)
<span class="line-modified">532         m_clipperFilterMaskerData = std::make_unique&lt;ClipperFilterMaskerData&gt;();</span>
533 
534     m_clipperFilterMaskerData-&gt;filter = filter;
535     return true;
536 }
537 
538 void SVGResources::resetFilter()
539 {
540     ASSERT(m_clipperFilterMaskerData);
541     ASSERT(m_clipperFilterMaskerData-&gt;filter);
542     m_clipperFilterMaskerData-&gt;filter = nullptr;
543 }
544 
545 bool SVGResources::setMarkerStart(RenderSVGResourceMarker* markerStart)
546 {
547     if (!markerStart)
548         return false;
549 
550     ASSERT(markerStart-&gt;resourceType() == MarkerResourceType);
551 
552     if (!m_markerData)
<span class="line-modified">553         m_markerData = std::make_unique&lt;MarkerData&gt;();</span>
554 
555     m_markerData-&gt;markerStart = markerStart;
556     return true;
557 }
558 
559 void SVGResources::resetMarkerStart()
560 {
561     ASSERT(m_markerData);
562     ASSERT(m_markerData-&gt;markerStart);
563     m_markerData-&gt;markerStart = nullptr;
564 }
565 
566 bool SVGResources::setMarkerMid(RenderSVGResourceMarker* markerMid)
567 {
568     if (!markerMid)
569         return false;
570 
571     ASSERT(markerMid-&gt;resourceType() == MarkerResourceType);
572 
573     if (!m_markerData)
<span class="line-modified">574         m_markerData = std::make_unique&lt;MarkerData&gt;();</span>
575 
576     m_markerData-&gt;markerMid = markerMid;
577     return true;
578 }
579 
580 void SVGResources::resetMarkerMid()
581 {
582     ASSERT(m_markerData);
583     ASSERT(m_markerData-&gt;markerMid);
584     m_markerData-&gt;markerMid = nullptr;
585 }
586 
587 bool SVGResources::setMarkerEnd(RenderSVGResourceMarker* markerEnd)
588 {
589     if (!markerEnd)
590         return false;
591 
592     ASSERT(markerEnd-&gt;resourceType() == MarkerResourceType);
593 
594     if (!m_markerData)
<span class="line-modified">595         m_markerData = std::make_unique&lt;MarkerData&gt;();</span>
596 
597     m_markerData-&gt;markerEnd = markerEnd;
598     return true;
599 }
600 
601 void SVGResources::resetMarkerEnd()
602 {
603     ASSERT(m_markerData);
604     ASSERT(m_markerData-&gt;markerEnd);
605     m_markerData-&gt;markerEnd = nullptr;
606 }
607 
608 bool SVGResources::setMasker(RenderSVGResourceMasker* masker)
609 {
610     if (!masker)
611         return false;
612 
613     ASSERT(masker-&gt;resourceType() == MaskerResourceType);
614 
615     if (!m_clipperFilterMaskerData)
<span class="line-modified">616         m_clipperFilterMaskerData = std::make_unique&lt;ClipperFilterMaskerData&gt;();</span>
617 
618     m_clipperFilterMaskerData-&gt;masker = masker;
619     return true;
620 }
621 
622 void SVGResources::resetMasker()
623 {
624     ASSERT(m_clipperFilterMaskerData);
625     ASSERT(m_clipperFilterMaskerData-&gt;masker);
626     m_clipperFilterMaskerData-&gt;masker = nullptr;
627 }
628 
629 bool SVGResources::setFill(RenderSVGResourceContainer* fill)
630 {
631     if (!fill)
632         return false;
633 
634     ASSERT(fill-&gt;resourceType() == PatternResourceType
635            || fill-&gt;resourceType() == LinearGradientResourceType
636            || fill-&gt;resourceType() == RadialGradientResourceType);
637 
638     if (!m_fillStrokeData)
<span class="line-modified">639         m_fillStrokeData = std::make_unique&lt;FillStrokeData&gt;();</span>
640 
641     m_fillStrokeData-&gt;fill = fill;
642     return true;
643 }
644 
645 void SVGResources::resetFill()
646 {
647     ASSERT(m_fillStrokeData);
648     ASSERT(m_fillStrokeData-&gt;fill);
649     m_fillStrokeData-&gt;fill = nullptr;
650 }
651 
652 bool SVGResources::setStroke(RenderSVGResourceContainer* stroke)
653 {
654     if (!stroke)
655         return false;
656 
657     ASSERT(stroke-&gt;resourceType() == PatternResourceType
658            || stroke-&gt;resourceType() == LinearGradientResourceType
659            || stroke-&gt;resourceType() == RadialGradientResourceType);
660 
661     if (!m_fillStrokeData)
<span class="line-modified">662         m_fillStrokeData = std::make_unique&lt;FillStrokeData&gt;();</span>
663 
664     m_fillStrokeData-&gt;stroke = stroke;
665     return true;
666 }
667 
668 void SVGResources::resetStroke()
669 {
670     ASSERT(m_fillStrokeData);
671     ASSERT(m_fillStrokeData-&gt;stroke);
672     m_fillStrokeData-&gt;stroke = nullptr;
673 }
674 
675 bool SVGResources::setLinkedResource(RenderSVGResourceContainer* linkedResource)
676 {
677     if (!linkedResource)
678         return false;
679 
680     m_linkedResource = linkedResource;
681     return true;
682 }
</pre>
</td>
<td>
<hr />
<pre>
 26 #include &quot;RenderSVGResourceFilter.h&quot;
 27 #include &quot;RenderSVGResourceMarker.h&quot;
 28 #include &quot;RenderSVGResourceMasker.h&quot;
 29 #include &quot;RenderSVGRoot.h&quot;
 30 #include &quot;SVGGradientElement.h&quot;
 31 #include &quot;SVGNames.h&quot;
 32 #include &quot;SVGPatternElement.h&quot;
 33 #include &quot;SVGRenderStyle.h&quot;
 34 #include &quot;SVGURIReference.h&quot;
 35 
 36 #if ENABLE(TREE_DEBUGGING)
 37 #include &lt;stdio.h&gt;
 38 #endif
 39 
 40 namespace WebCore {
 41 
 42 SVGResources::SVGResources()
 43 {
 44 }
 45 
<span class="line-modified"> 46 static HashSet&lt;AtomString&gt;&amp; clipperFilterMaskerTags()</span>
 47 {
<span class="line-modified"> 48     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;</span>
 49     if (s_tagList.get().isEmpty()) {
 50         // &quot;container elements&quot;: http://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 51         // &quot;graphics elements&quot; : http://www.w3.org/TR/SVG11/intro.html#TermGraphicsElement
 52         s_tagList.get().add(SVGNames::aTag-&gt;localName());
 53         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
 54         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
 55         s_tagList.get().add(SVGNames::glyphTag-&gt;localName());
 56         s_tagList.get().add(SVGNames::gTag-&gt;localName());
 57         s_tagList.get().add(SVGNames::imageTag-&gt;localName());
 58         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
 59         s_tagList.get().add(SVGNames::markerTag-&gt;localName());
 60         s_tagList.get().add(SVGNames::maskTag-&gt;localName());
 61         s_tagList.get().add(SVGNames::missing_glyphTag-&gt;localName());
 62         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
 63         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
 64         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
 65         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
 66         s_tagList.get().add(SVGNames::svgTag-&gt;localName());
 67         s_tagList.get().add(SVGNames::textTag-&gt;localName());
 68         s_tagList.get().add(SVGNames::useTag-&gt;localName());
</pre>
<hr />
<pre>
 75 
 76         // Not listed in the definitions are the text content elements, though filter/clipper/masker on tspan/text/.. is allowed.
 77         // (Already mailed SVG WG, waiting for a solution)
 78         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
 79         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
 80         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
 81         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
 82 
 83         // Not listed in the definitions is the foreignObject element, but clip-path
 84         // is a supported attribute.
 85         s_tagList.get().add(SVGNames::foreignObjectTag-&gt;localName());
 86 
 87         // Elements that we ignore, as it doesn&#39;t make any sense.
 88         // defs, pattern, switch (FIXME: Mail SVG WG about these)
 89         // symbol (is converted to a svg element, when referenced by use, we can safely ignore it.)
 90     }
 91 
 92     return s_tagList;
 93 }
 94 
<span class="line-modified"> 95 static HashSet&lt;AtomString&gt;&amp; markerTags()</span>
 96 {
<span class="line-modified"> 97     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;</span>
 98     if (s_tagList.get().isEmpty()) {
 99         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
100         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
101         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
102         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
103     }
104 
105     return s_tagList;
106 }
107 
<span class="line-modified">108 static HashSet&lt;AtomString&gt;&amp; fillAndStrokeTags()</span>
109 {
<span class="line-modified">110     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;</span>
111     if (s_tagList.get().isEmpty()) {
112         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
113         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
114         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
115         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
116         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
117         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
118         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
119         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
120         s_tagList.get().add(SVGNames::textTag-&gt;localName());
121         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
122         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
123         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
124     }
125 
126     return s_tagList;
127 }
128 
<span class="line-modified">129 static HashSet&lt;AtomString&gt;&amp; chainableResourceTags()</span>
130 {
<span class="line-modified">131     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;</span>
132     if (s_tagList.get().isEmpty()) {
133         s_tagList.get().add(SVGNames::linearGradientTag-&gt;localName());
134         s_tagList.get().add(SVGNames::filterTag-&gt;localName());
135         s_tagList.get().add(SVGNames::patternTag-&gt;localName());
136         s_tagList.get().add(SVGNames::radialGradientTag-&gt;localName());
137     }
138 
139     return s_tagList;
140 }
141 
142 static inline String targetReferenceFromResource(SVGElement&amp; element)
143 {
144     String target;
145     if (is&lt;SVGPatternElement&gt;(element))
146         target = downcast&lt;SVGPatternElement&gt;(element).href();
147     else if (is&lt;SVGGradientElement&gt;(element))
148         target = downcast&lt;SVGGradientElement&gt;(element).href();
149     else if (is&lt;SVGFilterElement&gt;(element))
150         target = downcast&lt;SVGFilterElement&gt;(element).href();
151     else
152         ASSERT_NOT_REACHED();
153 
154     return SVGURIReference::fragmentIdentifierFromIRIString(target, element.document());
155 }
156 
157 static inline bool isChainableResource(const SVGElement&amp; element, const SVGElement&amp; linkedResource)
158 {
159     if (is&lt;SVGPatternElement&gt;(element))
160         return is&lt;SVGPatternElement&gt;(linkedResource);
161 
162     if (is&lt;SVGGradientElement&gt;(element))
163         return is&lt;SVGGradientElement&gt;(linkedResource);
164 
165     if (is&lt;SVGFilterElement&gt;(element))
166         return is&lt;SVGFilterElement&gt;(linkedResource);
167 
168     ASSERT_NOT_REACHED();
169     return false;
170 }
171 
<span class="line-modified">172 static inline RenderSVGResourceContainer* paintingResourceFromSVGPaint(Document&amp; document, const SVGPaintType&amp; paintType, const String&amp; paintUri, AtomString&amp; id, bool&amp; hasPendingResource)</span>
173 {
174     if (paintType != SVGPaintType::URI &amp;&amp; paintType != SVGPaintType::URIRGBColor &amp;&amp; paintType != SVGPaintType::URICurrentColor)
175         return nullptr;
176 
177     id = SVGURIReference::fragmentIdentifierFromIRIString(paintUri, document);
178     RenderSVGResourceContainer* container = getRenderSVGResourceContainerById(document, id);
179     if (!container) {
180         hasPendingResource = true;
181         return nullptr;
182     }
183 
184     RenderSVGResourceType resourceType = container-&gt;resourceType();
185     if (resourceType != PatternResourceType &amp;&amp; resourceType != LinearGradientResourceType &amp;&amp; resourceType != RadialGradientResourceType)
186         return nullptr;
187 
188     return container;
189 }
190 
<span class="line-modified">191 static inline void registerPendingResource(SVGDocumentExtensions&amp; extensions, const AtomString&amp; id, SVGElement&amp; element)</span>
192 {
193     extensions.addPendingResource(id, element);
194 }
195 
196 bool SVGResources::buildCachedResources(const RenderElement&amp; renderer, const RenderStyle&amp; style)
197 {
198     ASSERT(renderer.element());
199     ASSERT_WITH_SECURITY_IMPLICATION(renderer.element()-&gt;isSVGElement());
200 
201     if (!renderer.element())
202         return false;
203 
204     auto&amp; element = downcast&lt;SVGElement&gt;(*renderer.element());
205 
206     Document&amp; document = element.document();
207 
208     SVGDocumentExtensions&amp; extensions = document.accessSVGExtensions();
209 
<span class="line-modified">210     const AtomString&amp; tagName = element.localName();</span>
211     if (tagName.isNull())
212         return false;
213 
214     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
215 
216     bool foundResources = false;
217     if (clipperFilterMaskerTags().contains(tagName)) {
218         if (svgStyle.hasClipper()) {
<span class="line-modified">219             AtomString id(svgStyle.clipperResource());</span>
220             if (setClipper(getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document, id)))
221                 foundResources = true;
222             else
223                 registerPendingResource(extensions, id, element);
224         } else if (is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {
225             // FIXME: -webkit-clip-path should support external resources
226             // https://bugs.webkit.org/show_bug.cgi?id=127032
227             auto&amp; clipPath = downcast&lt;ReferenceClipPathOperation&gt;(*style.clipPath());
<span class="line-modified">228             AtomString id(clipPath.fragment());</span>
229             if (setClipper(getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document, id)))
230                 foundResources = true;
231             else
232                 registerPendingResource(extensions, id, element);
233         }
234 
235         if (style.hasFilter()) {
236             const FilterOperations&amp; filterOperations = style.filter();
237             if (filterOperations.size() == 1) {
238                 const FilterOperation&amp; filterOperation = *filterOperations.at(0);
239                 if (filterOperation.type() == FilterOperation::REFERENCE) {
240                     const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified">241                     AtomString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), element.document());</span>
242                     if (setFilter(getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(document, id)))
243                         foundResources = true;
244                     else
245                         registerPendingResource(extensions, id, element);
246                 }
247             }
248         }
249 
250         if (svgStyle.hasMasker()) {
<span class="line-modified">251             AtomString id(svgStyle.maskerResource());</span>
252             if (setMasker(getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(document, id)))
253                 foundResources = true;
254             else
255                 registerPendingResource(extensions, id, element);
256         }
257     }
258 
259     if (markerTags().contains(tagName) &amp;&amp; svgStyle.hasMarkers()) {
<span class="line-modified">260         AtomString markerStartId(svgStyle.markerStartResource());</span>
261         if (setMarkerStart(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerStartId)))
262             foundResources = true;
263         else
264             registerPendingResource(extensions, markerStartId, element);
265 
<span class="line-modified">266         AtomString markerMidId(svgStyle.markerMidResource());</span>
267         if (setMarkerMid(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerMidId)))
268             foundResources = true;
269         else
270             registerPendingResource(extensions, markerMidId, element);
271 
<span class="line-modified">272         AtomString markerEndId(svgStyle.markerEndResource());</span>
273         if (setMarkerEnd(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerEndId)))
274             foundResources = true;
275         else
276             registerPendingResource(extensions, markerEndId, element);
277     }
278 
279     if (fillAndStrokeTags().contains(tagName)) {
280         if (svgStyle.hasFill()) {
281             bool hasPendingResource = false;
<span class="line-modified">282             AtomString id;</span>
283             if (setFill(paintingResourceFromSVGPaint(document, svgStyle.fillPaintType(), svgStyle.fillPaintUri(), id, hasPendingResource)))
284                 foundResources = true;
285             else if (hasPendingResource)
286                 registerPendingResource(extensions, id, element);
287         }
288 
289         if (svgStyle.hasStroke()) {
290             bool hasPendingResource = false;
<span class="line-modified">291             AtomString id;</span>
292             if (setStroke(paintingResourceFromSVGPaint(document, svgStyle.strokePaintType(), svgStyle.strokePaintUri(), id, hasPendingResource)))
293                 foundResources = true;
294             else if (hasPendingResource)
295                 registerPendingResource(extensions, id, element);
296         }
297     }
298 
299     if (chainableResourceTags().contains(tagName)) {
<span class="line-modified">300         AtomString id(targetReferenceFromResource(element));</span>
301         auto* linkedResource = getRenderSVGResourceContainerById(document, id);
302         if (!linkedResource)
303             registerPendingResource(extensions, id, element);
304         else if (isChainableResource(element, linkedResource-&gt;element())) {
305             setLinkedResource(linkedResource);
306             foundResources = true;
307         }
308     }
309 
310     return foundResources;
311 }
312 
313 void SVGResources::layoutDifferentRootIfNeeded(const RenderSVGRoot* svgRoot)
314 {
315     if (clipper() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*clipper()))
316         clipper()-&gt;layoutIfNeeded();
317 
318     if (masker() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*masker()))
319         masker()-&gt;layoutIfNeeded();
320 
</pre>
<hr />
<pre>
491         if (m_markerData-&gt;markerEnd)
492             set.add(m_markerData-&gt;markerEnd);
493     }
494 
495     if (m_fillStrokeData) {
496         if (m_fillStrokeData-&gt;fill)
497             set.add(m_fillStrokeData-&gt;fill);
498         if (m_fillStrokeData-&gt;stroke)
499             set.add(m_fillStrokeData-&gt;stroke);
500     }
501 }
502 
503 bool SVGResources::setClipper(RenderSVGResourceClipper* clipper)
504 {
505     if (!clipper)
506         return false;
507 
508     ASSERT(clipper-&gt;resourceType() == ClipperResourceType);
509 
510     if (!m_clipperFilterMaskerData)
<span class="line-modified">511         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();</span>
512 
513     m_clipperFilterMaskerData-&gt;clipper = clipper;
514     return true;
515 }
516 
517 void SVGResources::resetClipper()
518 {
519     ASSERT(m_clipperFilterMaskerData);
520     ASSERT(m_clipperFilterMaskerData-&gt;clipper);
521     m_clipperFilterMaskerData-&gt;clipper = nullptr;
522 }
523 
524 bool SVGResources::setFilter(RenderSVGResourceFilter* filter)
525 {
526     if (!filter)
527         return false;
528 
529     ASSERT(filter-&gt;resourceType() == FilterResourceType);
530 
531     if (!m_clipperFilterMaskerData)
<span class="line-modified">532         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();</span>
533 
534     m_clipperFilterMaskerData-&gt;filter = filter;
535     return true;
536 }
537 
538 void SVGResources::resetFilter()
539 {
540     ASSERT(m_clipperFilterMaskerData);
541     ASSERT(m_clipperFilterMaskerData-&gt;filter);
542     m_clipperFilterMaskerData-&gt;filter = nullptr;
543 }
544 
545 bool SVGResources::setMarkerStart(RenderSVGResourceMarker* markerStart)
546 {
547     if (!markerStart)
548         return false;
549 
550     ASSERT(markerStart-&gt;resourceType() == MarkerResourceType);
551 
552     if (!m_markerData)
<span class="line-modified">553         m_markerData = makeUnique&lt;MarkerData&gt;();</span>
554 
555     m_markerData-&gt;markerStart = markerStart;
556     return true;
557 }
558 
559 void SVGResources::resetMarkerStart()
560 {
561     ASSERT(m_markerData);
562     ASSERT(m_markerData-&gt;markerStart);
563     m_markerData-&gt;markerStart = nullptr;
564 }
565 
566 bool SVGResources::setMarkerMid(RenderSVGResourceMarker* markerMid)
567 {
568     if (!markerMid)
569         return false;
570 
571     ASSERT(markerMid-&gt;resourceType() == MarkerResourceType);
572 
573     if (!m_markerData)
<span class="line-modified">574         m_markerData = makeUnique&lt;MarkerData&gt;();</span>
575 
576     m_markerData-&gt;markerMid = markerMid;
577     return true;
578 }
579 
580 void SVGResources::resetMarkerMid()
581 {
582     ASSERT(m_markerData);
583     ASSERT(m_markerData-&gt;markerMid);
584     m_markerData-&gt;markerMid = nullptr;
585 }
586 
587 bool SVGResources::setMarkerEnd(RenderSVGResourceMarker* markerEnd)
588 {
589     if (!markerEnd)
590         return false;
591 
592     ASSERT(markerEnd-&gt;resourceType() == MarkerResourceType);
593 
594     if (!m_markerData)
<span class="line-modified">595         m_markerData = makeUnique&lt;MarkerData&gt;();</span>
596 
597     m_markerData-&gt;markerEnd = markerEnd;
598     return true;
599 }
600 
601 void SVGResources::resetMarkerEnd()
602 {
603     ASSERT(m_markerData);
604     ASSERT(m_markerData-&gt;markerEnd);
605     m_markerData-&gt;markerEnd = nullptr;
606 }
607 
608 bool SVGResources::setMasker(RenderSVGResourceMasker* masker)
609 {
610     if (!masker)
611         return false;
612 
613     ASSERT(masker-&gt;resourceType() == MaskerResourceType);
614 
615     if (!m_clipperFilterMaskerData)
<span class="line-modified">616         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();</span>
617 
618     m_clipperFilterMaskerData-&gt;masker = masker;
619     return true;
620 }
621 
622 void SVGResources::resetMasker()
623 {
624     ASSERT(m_clipperFilterMaskerData);
625     ASSERT(m_clipperFilterMaskerData-&gt;masker);
626     m_clipperFilterMaskerData-&gt;masker = nullptr;
627 }
628 
629 bool SVGResources::setFill(RenderSVGResourceContainer* fill)
630 {
631     if (!fill)
632         return false;
633 
634     ASSERT(fill-&gt;resourceType() == PatternResourceType
635            || fill-&gt;resourceType() == LinearGradientResourceType
636            || fill-&gt;resourceType() == RadialGradientResourceType);
637 
638     if (!m_fillStrokeData)
<span class="line-modified">639         m_fillStrokeData = makeUnique&lt;FillStrokeData&gt;();</span>
640 
641     m_fillStrokeData-&gt;fill = fill;
642     return true;
643 }
644 
645 void SVGResources::resetFill()
646 {
647     ASSERT(m_fillStrokeData);
648     ASSERT(m_fillStrokeData-&gt;fill);
649     m_fillStrokeData-&gt;fill = nullptr;
650 }
651 
652 bool SVGResources::setStroke(RenderSVGResourceContainer* stroke)
653 {
654     if (!stroke)
655         return false;
656 
657     ASSERT(stroke-&gt;resourceType() == PatternResourceType
658            || stroke-&gt;resourceType() == LinearGradientResourceType
659            || stroke-&gt;resourceType() == RadialGradientResourceType);
660 
661     if (!m_fillStrokeData)
<span class="line-modified">662         m_fillStrokeData = makeUnique&lt;FillStrokeData&gt;();</span>
663 
664     m_fillStrokeData-&gt;stroke = stroke;
665     return true;
666 }
667 
668 void SVGResources::resetStroke()
669 {
670     ASSERT(m_fillStrokeData);
671     ASSERT(m_fillStrokeData-&gt;stroke);
672     m_fillStrokeData-&gt;stroke = nullptr;
673 }
674 
675 bool SVGResources::setLinkedResource(RenderSVGResourceContainer* linkedResource)
676 {
677     if (!linkedResource)
678         return false;
679 
680     m_linkedResource = linkedResource;
681     return true;
682 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGRenderTreeAsText.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGResourcesCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>