<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../config.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">! *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  *  Copyright (C) 2007 Maks Orlovich
  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   * Copyright (C) 2012 Igalia, S.L.
  *
<span class="line-new-header">--- 1,9 ---</span>
  /*
  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">! *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  *  Copyright (C) 2007 Maks Orlovich
  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   * Copyright (C) 2012 Igalia, S.L.
  *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,10 ***</span>
<span class="line-new-header">--- 39,12 ---</span>
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;LabelScope.h&quot;
  #include &quot;Lexer.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;StackAlignment.h&quot;
<span class="line-added">+ #include &quot;UnlinkedMetadataTableInlines.h&quot;</span>
<span class="line-added">+ #include &quot;YarrFlags.h&quot;</span>
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/Threading.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace JSC {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,13 ***</span>
  
  RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      if (dst == generator.ignoredResult())
          return nullptr;
<span class="line-modified">!     RegExp* regExp = RegExp::create(*generator.vm(), m_pattern.string(), regExpFlags(m_flags.string()));</span>
      if (regExp-&gt;isValid())
          return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
      const char* messageCharacters = regExp-&gt;errorMessage();
      const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
      generator.emitThrowStaticError(ErrorType::SyntaxError, message);
      return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
  }
<span class="line-new-header">--- 141,17 ---</span>
  
  RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      if (dst == generator.ignoredResult())
          return nullptr;
<span class="line-modified">! </span>
<span class="line-added">+     auto flags = Yarr::parseFlags(m_flags.string());</span>
<span class="line-added">+     ASSERT(flags.hasValue());</span>
<span class="line-added">+     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());</span>
      if (regExp-&gt;isValid())
          return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
<span class="line-added">+ </span>
      const char* messageCharacters = regExp-&gt;errorMessage();
      const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
      generator.emitThrowStaticError(ErrorType::SyntaxError, message);
      return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,16 ***</span>
      }
  
      auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
          if (length &amp;&amp; !hadVariableExpression) {
              recommendedIndexingType |= CopyOnWrite;
<span class="line-modified">!             ASSERT(generator.vm()-&gt;heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.</span>
<span class="line-modified">!             auto* array = JSImmutableButterfly::create(*generator.vm(), recommendedIndexingType, length);</span>
              unsigned index = 0;
              for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
                  ASSERT(element-&gt;value()-&gt;isConstant());
<span class="line-modified">!                 array-&gt;setIndex(*generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));</span>
              }
              return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
          }
          return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
      };
<span class="line-new-header">--- 408,16 ---</span>
      }
  
      auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
          if (length &amp;&amp; !hadVariableExpression) {
              recommendedIndexingType |= CopyOnWrite;
<span class="line-modified">!             ASSERT(generator.vm().heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.</span>
<span class="line-modified">!             auto* array = JSImmutableButterfly::create(generator.vm(), recommendedIndexingType, length);</span>
              unsigned index = 0;
              for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
                  ASSERT(element-&gt;value()-&gt;isConstant());
<span class="line-modified">!                 array-&gt;setIndex(generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));</span>
              }
              return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
          }
          return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,16 ***</span>
      }
  
      RegisterID* ret;
      RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
  
<span class="line-modified">!     if (isNonIndexStringElement(*m_subscript)) {</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
          generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
          ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
      } else {
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));</span>
          RegisterID* property = generator.emitNodeForProperty(m_subscript);
          generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
          ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
      }
  
<span class="line-new-header">--- 742,22 ---</span>
      }
  
      RegisterID* ret;
      RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
  
<span class="line-modified">!     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; base = subscriptIsNonIndexString</span>
<span class="line-added">+         ? generator.emitNode(m_base)</span>
<span class="line-added">+         : generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(base.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (subscriptIsNonIndexString) {</span>
          generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
          ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
      } else {
          RegisterID* property = generator.emitNodeForProperty(m_subscript);
          generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
          ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,21 ***</span>
  
  // ------------------------------ DotAccessorNode --------------------------------
  
  RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      bool baseIsSuper = m_base-&gt;isSuperNode();
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; base = baseIsSuper ? emitSuperBaseForCallee(generator) : generator.emitNode(m_base);</span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-removed">-     RegisterID* finalDest = generator.finalDestination(dst);</span>
      RegisterID* ret;
      if (baseIsSuper) {
          RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
<span class="line-modified">!         ret = generator.emitGetById(finalDest, base.get(), thisValue.get(), m_ident);</span>
      } else
<span class="line-modified">!         ret = generator.emitGetById(finalDest, base.get(), m_ident);</span>
<span class="line-modified">!     generator.emitProfileType(finalDest, divotStart(), divotEnd());</span>
      return ret;
  }
  
  // ------------------------------ ArgumentListNode -----------------------------
  
<span class="line-new-header">--- 767,30 ---</span>
  
  // ------------------------------ DotAccessorNode --------------------------------
  
  RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-added">+     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
      bool baseIsSuper = m_base-&gt;isSuperNode();
<span class="line-modified">! </span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base;</span>
<span class="line-added">+     if (baseIsSuper)</span>
<span class="line-added">+         base = emitSuperBaseForCallee(generator);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         base = generator.emitNode(m_base);</span>
<span class="line-added">+         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+             generator.emitOptionalCheck(base.get());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      RegisterID* ret;
      if (baseIsSuper) {
          RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
<span class="line-modified">!         ret = generator.emitGetById(finalDest.get(), base.get(), thisValue.get(), m_ident);</span>
      } else
<span class="line-modified">!         ret = generator.emitGetById(finalDest.get(), base.get(), m_ident);</span>
<span class="line-modified">!     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());</span>
      return ret;
  }
  
  // ------------------------------ ArgumentListNode -----------------------------
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 840,28 ***</span>
      // }
      if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
          generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
  
      Variable var = generator.variable(generator.propertyNames().eval);
<span class="line-modified">!     if (RegisterID* local = var.local()) {</span>
<span class="line-modified">!         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified">!         CallArguments callArguments(generator, m_args);</span>
          generator.emitLoad(callArguments.thisRegister(), jsUndefined());
<span class="line-modified">!         return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>
      }
  
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
<span class="line-modified">!     CallArguments callArguments(generator, m_args);</span>
<span class="line-modified">!     JSTextPosition newDivot = divotStart() + 4;</span>
<span class="line-modified">!     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-modified">!     generator.move(</span>
<span class="line-removed">-         callArguments.thisRegister(),</span>
<span class="line-removed">-         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed">-     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed">-     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
<span class="line-removed">-     return generator.emitCallEval(generator.finalDestination(dst, func.get()), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>
  }
  
  // ------------------------------ FunctionCallValueNode ----------------------------------
  
  RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
<span class="line-new-header">--- 861,36 ---</span>
      // }
      if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
          generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
  
      Variable var = generator.variable(generator.propertyNames().eval);
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; local = var.local();</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; func;</span>
<span class="line-modified">!     if (local) {</span>
<span class="line-modified">!         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);</span>
<span class="line-added">+         func = generator.move(generator.tempDestination(dst), local.get());</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         func = generator.newTemporary();</span>
<span class="line-added">+     CallArguments callArguments(generator, m_args);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (local)</span>
          generator.emitLoad(callArguments.thisRegister(), jsUndefined());
<span class="line-modified">!     else {</span>
<span class="line-added">+         JSTextPosition newDivot = divotStart() + 4;</span>
<span class="line-added">+         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-added">+         generator.move(</span>
<span class="line-added">+             callArguments.thisRegister(),</span>
<span class="line-added">+             generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-added">+         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-added">+         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
      }
  
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());</span>
<span class="line-modified">!     if (isOptionalChainBase())</span>
<span class="line-modified">!         generator.emitOptionalCheck(func.get());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return generator.emitCallEval(returnValue.get(), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);</span>
  }
  
  // ------------------------------ FunctionCallValueNode ----------------------------------
  
  RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 891,12 ***</span>
<span class="line-new-header">--- 920,16 ---</span>
          if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
              generator.emitPutThisToArrowFunctionContextScope();
  
          return ret;
      }
<span class="line-added">+ </span>
      RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-added">+     if (isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(func.get());</span>
<span class="line-added">+ </span>
      CallArguments callArguments(generator, m_args);
      generator.emitLoad(callArguments.thisRegister(), jsUndefined());
      RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
      generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
      return ret;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 904,42 ***</span>
  
  // ------------------------------ FunctionCallResolveNode ----------------------------------
  
  RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (UNLIKELY(m_ident == generator.vm()-&gt;propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
          if (ASSERT_DISABLED)
              return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
      }
  
      ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
  
      Variable var = generator.variable(m_ident);
<span class="line-modified">!     if (RegisterID* local = var.local()) {</span>
<span class="line-modified">!         generator.emitTDZCheckIfNecessary(var, local, nullptr);</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; func = generator.move(generator.tempDestination(dst), local);</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());</span>
<span class="line-modified">!         CallArguments callArguments(generator, m_args);</span>
          generator.emitLoad(callArguments.thisRegister(), jsUndefined());
          // This passes NoExpectedFunction because we expect that if the function is in a
          // local variable, then it&#39;s not one of our built-in constructors.
<span class="line-modified">!         RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);</span>
<span class="line-modified">!         generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());</span>
<span class="line-modified">!         return ret;</span>
      }
  
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; func = generator.newTemporary();</span>
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-modified">!     CallArguments callArguments(generator, m_args);</span>
  
<span class="line-removed">-     JSTextPosition newDivot = divotStart() + m_ident.length();</span>
<span class="line-removed">-     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-removed">-     generator.move(</span>
<span class="line-removed">-         callArguments.thisRegister(),</span>
<span class="line-removed">-         generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-removed">-     generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-removed">-     generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
      RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
      generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
      return ret;
  }
  
<span class="line-new-header">--- 937,46 ---</span>
  
  // ------------------------------ FunctionCallResolveNode ----------------------------------
  
  RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
          if (ASSERT_DISABLED)
              return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
      }
  
      ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
  
      Variable var = generator.variable(m_ident);
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; local = var.local();</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; func;</span>
<span class="line-modified">!     if (local) {</span>
<span class="line-modified">!         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);</span>
<span class="line-modified">!         func = generator.move(generator.tempDestination(dst), local.get());</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         func = generator.newTemporary();</span>
<span class="line-added">+     CallArguments callArguments(generator, m_args);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (local) {</span>
          generator.emitLoad(callArguments.thisRegister(), jsUndefined());
          // This passes NoExpectedFunction because we expect that if the function is in a
          // local variable, then it&#39;s not one of our built-in constructors.
<span class="line-modified">!         expectedFunction = NoExpectedFunction;</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         JSTextPosition newDivot = divotStart() + m_ident.length();</span>
<span class="line-added">+         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);</span>
<span class="line-added">+         generator.move(</span>
<span class="line-added">+             callArguments.thisRegister(),</span>
<span class="line-added">+             generator.emitResolveScope(callArguments.thisRegister(), var));</span>
<span class="line-added">+         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);</span>
<span class="line-added">+         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);</span>
      }
  
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
<span class="line-modified">!     if (isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(func.get());</span>
  
      RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
      generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
      return ret;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,11 ***</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
      node = node-&gt;m_next;
      ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">!     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
      ASSERT(symbol);
      ASSERT(!node-&gt;m_next);
      return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
  }
  
<span class="line-new-header">--- 1002,11 ---</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
      node = node-&gt;m_next;
      ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">!     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
      ASSERT(symbol);
      ASSERT(!node-&gt;m_next);
      return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,11 ***</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
      node = node-&gt;m_next;
      ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">!     SymbolImpl* symbol = generator.vm()-&gt;propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
      ASSERT(symbol);
      node = node-&gt;m_next;
      RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
  
      ASSERT(!node-&gt;m_next);
<span class="line-new-header">--- 1053,11 ---</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
      node = node-&gt;m_next;
      ASSERT(node-&gt;m_expr-&gt;isString());
<span class="line-modified">!     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());</span>
      ASSERT(symbol);
      node = node-&gt;m_next;
      RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
  
      ASSERT(!node-&gt;m_next);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,11 ***</span>
          ASSERT(node-&gt;m_expr-&gt;isString());
          const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
          ASSERT(!node-&gt;m_next);
          return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
      }
<span class="line-modified">!     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm()-&gt;propertyNames-&gt;emptyIdentifier));</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-new-header">--- 1172,11 ---</span>
          ASSERT(node-&gt;m_expr-&gt;isString());
          const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
          ASSERT(!node-&gt;m_next);
          return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
      }
<span class="line-modified">!     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1258,19 ***</span>
      { \
          ASSERT(!m_args); \
          ASSERT(type() == Type::Constant); \
          if (dst == generator.ignoredResult()) \
              return nullptr; \
<span class="line-modified">!         return generator.emitLoad(dst, generator.vm()-&gt;bytecodeIntrinsicRegistry().name##Value(generator)); \</span>
      }
      JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
  #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
  
  // ------------------------------ FunctionCallBracketNode ----------------------------------
  
  RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      bool baseIsSuper = m_base-&gt;isSuperNode();
      bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
  
      RefPtr&lt;RegisterID&gt; base;
      if (baseIsSuper)
<span class="line-new-header">--- 1295,21 ---</span>
      { \
          ASSERT(!m_args); \
          ASSERT(type() == Type::Constant); \
          if (dst == generator.ignoredResult()) \
              return nullptr; \
<span class="line-modified">!         return generator.emitLoad(dst, generator.vm().bytecodeIntrinsicRegistry().name##Value(generator)); \</span>
      }
      JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
  #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
  
  // ------------------------------ FunctionCallBracketNode ----------------------------------
  
  RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-added">+     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());</span>
      bool baseIsSuper = m_base-&gt;isSuperNode();
      bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
  
      RefPtr&lt;RegisterID&gt; base;
      if (baseIsSuper)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1278,34 ***</span>
      else {
          if (subscriptIsNonIndexString)
              base = generator.emitNode(m_base);
          else
              base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
      }
  
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; function;</span>
      RefPtr&lt;RegisterID&gt; thisRegister;
      if (baseIsSuper) {
          // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
          thisRegister = generator.ensureThis();
      }
      if (subscriptIsNonIndexString) {
          generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
          if (baseIsSuper)
<span class="line-modified">!             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
          else
<span class="line-modified">!             function = generator.emitGetById(generator.tempDestination(dst), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
      } else {
          RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
          generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
          if (baseIsSuper)
<span class="line-modified">!             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisRegister.get(), property.get());</span>
          else
<span class="line-modified">!             function = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());</span>
      }
  
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());</span>
      CallArguments callArguments(generator, m_args);
      if (baseIsSuper) {
          generator.emitTDZCheck(generator.thisRegister());
          generator.move(callArguments.thisRegister(), thisRegister.get());
      } else
<span class="line-new-header">--- 1317,37 ---</span>
      else {
          if (subscriptIsNonIndexString)
              base = generator.emitNode(m_base);
          else
              base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
<span class="line-added">+ </span>
<span class="line-added">+         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+             generator.emitOptionalCheck(base.get());</span>
      }
  
      RefPtr&lt;RegisterID&gt; thisRegister;
      if (baseIsSuper) {
          // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
          thisRegister = generator.ensureThis();
      }
      if (subscriptIsNonIndexString) {
          generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
          if (baseIsSuper)
<span class="line-modified">!             generator.emitGetById(function.get(), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
          else
<span class="line-modified">!             generator.emitGetById(function.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());</span>
      } else {
          RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
          generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
          if (baseIsSuper)
<span class="line-modified">!             generator.emitGetByVal(function.get(), base.get(), thisRegister.get(), property.get());</span>
          else
<span class="line-modified">!             generator.emitGetByVal(function.get(), base.get(), property.get());</span>
      }
<span class="line-added">+     if (isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(function.get());</span>
  
      CallArguments callArguments(generator, m_args);
      if (baseIsSuper) {
          generator.emitTDZCheck(generator.thisRegister());
          generator.move(callArguments.thisRegister(), thisRegister.get());
      } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1323,38 ***</span>
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
      CallArguments callArguments(generator, m_args);
      bool baseIsSuper = m_base-&gt;isSuperNode();
      if (baseIsSuper)
          generator.move(callArguments.thisRegister(), generator.ensureThis());
<span class="line-modified">!     else</span>
          generator.emitNode(callArguments.thisRegister(), m_base);
      generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
      if (baseIsSuper) {
          RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
          generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
      } else
          generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
      RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
      generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
      return ret;
  }
  
  static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
  
  RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
      generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);</span>
  
      auto makeFunction = [&amp;] {
          if (m_base-&gt;isSuperNode()) {
              RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
          } else
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
      };
  
      bool emitCallCheck = !generator.isBuiltinFunction();
      if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
          makeFunction();
<span class="line-new-header">--- 1365,52 ---</span>
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
      CallArguments callArguments(generator, m_args);
      bool baseIsSuper = m_base-&gt;isSuperNode();
      if (baseIsSuper)
          generator.move(callArguments.thisRegister(), generator.ensureThis());
<span class="line-modified">!     else {</span>
          generator.emitNode(callArguments.thisRegister(), m_base);
<span class="line-added">+         if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+             generator.emitOptionalCheck(callArguments.thisRegister());</span>
<span class="line-added">+     }</span>
      generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
      if (baseIsSuper) {
          RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
          generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
      } else
          generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
<span class="line-added">+ </span>
<span class="line-added">+     if (isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(function.get());</span>
<span class="line-added">+ </span>
      RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
      generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
      return ret;
  }
  
  static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
  
  RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-added">+     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);</span>
      RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
<span class="line-added">+ </span>
<span class="line-added">+     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(base.get());</span>
<span class="line-added">+ </span>
      generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
  
<span class="line-added">+     RefPtr&lt;RegisterID&gt; function;</span>
      auto makeFunction = [&amp;] {
          if (m_base-&gt;isSuperNode()) {
              RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
          } else
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
<span class="line-added">+ </span>
<span class="line-added">+         if (isOptionalChainBase())</span>
<span class="line-added">+             generator.emitOptionalCheck(function.get());</span>
      };
  
      bool emitCallCheck = !generator.isBuiltinFunction();
      if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
          makeFunction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1422,19 ***</span>
      // A few simple cases can be trivially handled as ordinary function calls.
      // function.apply(), function.apply(arg) -&gt; identical to function.call
      // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
      bool mayBeCall = areTrivialApplyArguments(m_args);
  
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; function;</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
      auto makeFunction = [&amp;] {
          if (m_base-&gt;isSuperNode()) {
              RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
          } else
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
      };
  
      bool emitCallCheck = !generator.isBuiltinFunction();
      if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
          makeFunction();
<span class="line-new-header">--- 1478,26 ---</span>
      // A few simple cases can be trivially handled as ordinary function calls.
      // function.apply(), function.apply(arg) -&gt; identical to function.call
      // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
      bool mayBeCall = areTrivialApplyArguments(m_args);
  
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(base.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; function;</span>
      auto makeFunction = [&amp;] {
          if (m_base-&gt;isSuperNode()) {
              RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
          } else
              function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
<span class="line-added">+ </span>
<span class="line-added">+         if (isOptionalChainBase())</span>
<span class="line-added">+             generator.emitOptionalCheck(function.get());</span>
      };
  
      bool emitCallCheck = !generator.isBuiltinFunction();
      if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
          makeFunction();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1658,10 ***</span>
<span class="line-new-header">--- 1721,11 ---</span>
          return emitBracket(generator, dst);
  
      if (m_expr-&gt;isDotAccessorNode())
          return emitDot(generator, dst);
  
<span class="line-added">+     ASSERT(m_expr-&gt;isFunctionCall());</span>
      return emitThrowReferenceError(generator, m_operator == OpPlusPlus
          ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
          : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1683,29 ***</span>
  
  // ------------------------------ DeleteBracketNode -----------------------------------
  
  RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);</span>
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      if (m_base-&gt;isSuperNode())
          return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">!     return generator.emitDeleteByVal(generator.finalDestination(dst), r0.get(), r1.get());</span>
  }
  
  // ------------------------------ DeleteDotNode -----------------------------------
  
  RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      if (m_base-&gt;isSuperNode())
          return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">!     return generator.emitDeleteById(generator.finalDestination(dst), r0.get(), m_ident);</span>
  }
  
  // ------------------------------ DeleteValueNode -----------------------------------
  
  RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
<span class="line-new-header">--- 1747,37 ---</span>
  
  // ------------------------------ DeleteBracketNode -----------------------------------
  
  RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-added">+     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
      RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
  
<span class="line-added">+     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(r0.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);</span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      if (m_base-&gt;isSuperNode())
          return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">!     return generator.emitDeleteByVal(finalDest.get(), r0.get(), r1.get());</span>
  }
  
  // ------------------------------ DeleteDotNode -----------------------------------
  
  RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-added">+     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
      RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
  
<span class="line-added">+     if (m_base-&gt;isOptionalChainBase())</span>
<span class="line-added">+         generator.emitOptionalCheck(r0.get());</span>
<span class="line-added">+ </span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      if (m_base-&gt;isSuperNode())
          return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
<span class="line-modified">!     return generator.emitDeleteById(finalDest.get(), r0.get(), m_ident);</span>
  }
  
  // ------------------------------ DeleteValueNode -----------------------------------
  
  RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1773,11 ***</span>
          generator.emitTDZCheckIfNecessary(var, local, nullptr);
          RefPtr&lt;RegisterID&gt; localReg = local;
          if (var.isReadOnly()) {
              generator.emitReadOnlyExceptionIfNeeded(var);
              localReg = generator.move(generator.tempDestination(dst), localReg.get());
<span class="line-modified">!         } else if (generator.vm()-&gt;typeProfiler()) {</span>
              RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
              generator.move(tempDst.get(), localReg.get());
              emitIncOrDec(generator, tempDst.get(), m_operator);
              generator.move(localReg.get(), tempDst.get());
              generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
<span class="line-new-header">--- 1845,11 ---</span>
          generator.emitTDZCheckIfNecessary(var, local, nullptr);
          RefPtr&lt;RegisterID&gt; localReg = local;
          if (var.isReadOnly()) {
              generator.emitReadOnlyExceptionIfNeeded(var);
              localReg = generator.move(generator.tempDestination(dst), localReg.get());
<span class="line-modified">!         } else if (generator.shouldEmitTypeProfilerHooks()) {</span>
              RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
              generator.move(tempDst.get(), localReg.get());
              emitIncOrDec(generator, tempDst.get(), m_operator);
              generator.move(localReg.get(), tempDst.get());
              generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1871,10 ***</span>
<span class="line-new-header">--- 1943,11 ---</span>
          return emitBracket(generator, dst);
  
      if (m_expr-&gt;isDotAccessorNode())
          return emitDot(generator, dst);
  
<span class="line-added">+     ASSERT(m_expr-&gt;isFunctionCall());</span>
      return emitThrowReferenceError(generator, m_operator == OpPlusPlus
          ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
          : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2249,20 ***</span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitIsObject(isObject.get(), constructor.get());
      generator.emitJumpIfFalse(isObject.get(), typeError.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">!     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;hasInstanceSymbol);</span>
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitJumpIfTrue(isCustom.get(), custom.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">!     generator.emitGetById(prototype.get(), constructor.get(), generator.vm()-&gt;propertyNames-&gt;prototype);</span>
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
  
      generator.emitJump(done.get());
<span class="line-new-header">--- 2322,20 ---</span>
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitIsObject(isObject.get(), constructor.get());
      generator.emitJumpIfFalse(isObject.get(), typeError.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">!     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm().propertyNames-&gt;hasInstanceSymbol);</span>
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitJumpIfTrue(isCustom.get(), custom.get());
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
<span class="line-modified">!     generator.emitGetById(prototype.get(), constructor.get(), generator.vm().propertyNames-&gt;prototype);</span>
  
      generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
      generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
  
      generator.emitJump(done.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2328,10 ***</span>
<span class="line-new-header">--- 2401,45 ---</span>
      generator.emitLabel(afterExpr1.get());
  
      generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
  }
  
<span class="line-added">+ // ------------------------------ CoalesceNode ----------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* CoalesceNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);</span>
<span class="line-added">+     Ref&lt;Label&gt; endLabel = generator.newLabel();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_hasAbsorbedOptionalChain)</span>
<span class="line-added">+         generator.pushOptionalChainTarget();</span>
<span class="line-added">+     generator.emitNode(temp.get(), m_expr1);</span>
<span class="line-added">+     generator.emitJumpIfFalse(generator.emitIsUndefinedOrNull(generator.newTemporary(), temp.get()), endLabel.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_hasAbsorbedOptionalChain)</span>
<span class="line-added">+         generator.popOptionalChainTarget();</span>
<span class="line-added">+     generator.emitNodeInTailPosition(temp.get(), m_expr2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     generator.emitLabel(endLabel.get());</span>
<span class="line-added">+     return generator.move(dst, temp.get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // ------------------------------ OptionalChainNode ----------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* OptionalChainNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_isOutermost)</span>
<span class="line-added">+         generator.pushOptionalChainTarget();</span>
<span class="line-added">+     generator.emitNodeInTailPosition(finalDest.get(), m_expr);</span>
<span class="line-added">+     if (m_isOutermost)</span>
<span class="line-added">+         generator.popOptionalChainTarget(finalDest.get(), m_expr-&gt;isDeleteNode());</span>
<span class="line-added">+ </span>
<span class="line-added">+     return finalDest.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // ------------------------------ ConditionalNode ------------------------------
  
  RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2718,11 ***</span>
  // ------------------------------ EmptyVarExpression ----------------------------
  
  RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
      // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<span class="line-modified">!     if (!generator.vm()-&gt;typeProfiler())</span>
          return nullptr;
  
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local())
          generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
<span class="line-new-header">--- 2826,11 ---</span>
  // ------------------------------ EmptyVarExpression ----------------------------
  
  RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
      // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<span class="line-modified">!     if (!generator.shouldEmitTypeProfilerHooks())</span>
          return nullptr;
  
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local())
          generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3348,11 ***</span>
      }
  
      generator.emitProfileControlFlow(endOffset());
      // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
      // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
<span class="line-modified">!     if (generator.vm()-&gt;controlFlowProfiler())</span>
          generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
  }
  
  // ------------------------------ WithNode -------------------------------------
  
<span class="line-new-header">--- 3456,11 ---</span>
      }
  
      generator.emitProfileControlFlow(endOffset());
      // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
      // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
<span class="line-modified">!     if (generator.shouldEmitControlFlowProfilerHooks())</span>
          generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
  }
  
  // ------------------------------ WithNode -------------------------------------
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3580,36 ***</span>
  
      if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
          generator.emitLoad(dst, jsUndefined());
  
      ASSERT(m_catchBlock || m_finallyBlock);
<span class="line-removed">-     BytecodeGenerator::CompletionRecordScope completionRecordScope(generator, m_finallyBlock);</span>
  
      RefPtr&lt;Label&gt; catchLabel;
      RefPtr&lt;Label&gt; catchEndLabel;
<span class="line-removed">-     RefPtr&lt;Label&gt; finallyViaThrowLabel;</span>
      RefPtr&lt;Label&gt; finallyLabel;
      RefPtr&lt;Label&gt; finallyEndLabel;
<span class="line-modified">! </span>
<span class="line-removed">-     Ref&lt;Label&gt; tryStartLabel = generator.newLabel();</span>
<span class="line-removed">-     generator.emitLabel(tryStartLabel.get());</span>
  
      if (m_finallyBlock) {
<span class="line-removed">-         finallyViaThrowLabel = generator.newLabel();</span>
          finallyLabel = generator.newLabel();
          finallyEndLabel = generator.newLabel();
  
<span class="line-modified">!         generator.pushFinallyControlFlowScope(*finallyLabel);</span>
      }
      if (m_catchBlock) {
          catchLabel = generator.newLabel();
          catchEndLabel = generator.newLabel();
      }
  
<span class="line-modified">!     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyViaThrowLabel;</span>
      HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
<span class="line-modified">!     TryData* tryData = generator.pushTry(tryStartLabel.get(), tryHandlerLabel, tryHandlerType);</span>
      TryData* finallyTryData = nullptr;
      if (!m_catchBlock &amp;&amp; m_finallyBlock)
          finallyTryData = tryData;
  
      generator.emitNode(dst, m_tryBlock);
<span class="line-new-header">--- 3688,33 ---</span>
  
      if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
          generator.emitLoad(dst, jsUndefined());
  
      ASSERT(m_catchBlock || m_finallyBlock);
  
      RefPtr&lt;Label&gt; catchLabel;
      RefPtr&lt;Label&gt; catchEndLabel;
      RefPtr&lt;Label&gt; finallyLabel;
      RefPtr&lt;Label&gt; finallyEndLabel;
<span class="line-modified">!     Optional&lt;FinallyContext&gt; finallyContext;</span>
  
      if (m_finallyBlock) {
          finallyLabel = generator.newLabel();
          finallyEndLabel = generator.newLabel();
  
<span class="line-modified">!         finallyContext.emplace(generator, *finallyLabel);</span>
<span class="line-added">+         generator.pushFinallyControlFlowScope(finallyContext.value());</span>
      }
      if (m_catchBlock) {
          catchLabel = generator.newLabel();
          catchEndLabel = generator.newLabel();
      }
  
<span class="line-modified">!     Ref&lt;Label&gt; tryLabel = generator.newEmittedLabel();</span>
<span class="line-added">+     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyLabel;</span>
      HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
<span class="line-modified">!     TryData* tryData = generator.pushTry(tryLabel.get(), tryHandlerLabel, tryHandlerType);</span>
      TryData* finallyTryData = nullptr;
      if (!m_catchBlock &amp;&amp; m_finallyBlock)
          finallyTryData = tryData;
  
      generator.emitNode(dst, m_tryBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3617,25 ***</span>
      if (m_finallyBlock)
          generator.emitJump(*finallyLabel);
      else
          generator.emitJump(*catchEndLabel);
  
<span class="line-modified">!     Ref&lt;Label&gt; endTryLabel = generator.newEmittedLabel();</span>
<span class="line-modified">!     generator.popTry(tryData, endTryLabel.get());</span>
  
      if (m_catchBlock) {
          // Uncaught exception path: the catch block.
          generator.emitLabel(*catchLabel);
          RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
<span class="line-modified">!         RegisterID* unused = generator.newTemporary();</span>
<span class="line-modified">!         generator.emitCatch(unused, thrownValueRegister.get(), tryData);</span>
          generator.restoreScopeRegister();
  
          if (m_finallyBlock) {
              // If the catch block throws an exception and we have a finally block, then the finally
              // block should &quot;catch&quot; that exception.
<span class="line-modified">!             finallyTryData = generator.pushTry(*catchLabel, *finallyViaThrowLabel, HandlerType::Finally);</span>
          }
  
          if (m_catchPattern) {
              generator.emitPushCatchScope(m_lexicalVariables);
              m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
<span class="line-new-header">--- 3722,25 ---</span>
      if (m_finallyBlock)
          generator.emitJump(*finallyLabel);
      else
          generator.emitJump(*catchEndLabel);
  
<span class="line-modified">!     Ref&lt;Label&gt; tryEndLabel = generator.newEmittedLabel();</span>
<span class="line-modified">!     generator.popTry(tryData, tryEndLabel.get());</span>
  
      if (m_catchBlock) {
          // Uncaught exception path: the catch block.
          generator.emitLabel(*catchLabel);
          RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
<span class="line-modified">!         RegisterID* completionTypeRegister = m_finallyBlock ? finallyContext-&gt;completionTypeRegister() : nullptr;</span>
<span class="line-modified">!         generator.emitOutOfLineCatchHandler(thrownValueRegister.get(), completionTypeRegister, tryData);</span>
          generator.restoreScopeRegister();
  
          if (m_finallyBlock) {
              // If the catch block throws an exception and we have a finally block, then the finally
              // block should &quot;catch&quot; that exception.
<span class="line-modified">!             finallyTryData = generator.pushTry(*catchLabel, *finallyLabel, HandlerType::Finally);</span>
          }
  
          if (m_catchPattern) {
              generator.emitPushCatchScope(m_lexicalVariables);
              m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3650,40 ***</span>
  
          if (m_catchPattern)
              generator.emitPopCatchScope(m_lexicalVariables);
  
          if (m_finallyBlock) {
<span class="line-modified">!             generator.emitSetCompletionType(CompletionType::Normal);</span>
              generator.emitJump(*finallyLabel);
<span class="line-modified">!             generator.popTry(finallyTryData, *finallyViaThrowLabel);</span>
          }
  
          generator.emitLabel(*catchEndLabel);
          generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
      }
  
      if (m_finallyBlock) {
<span class="line-modified">!         FinallyContext finallyContext = generator.popFinallyControlFlowScope();</span>
  
<span class="line-modified">!         // Entry to the finally block for CompletionType::Throw.</span>
<span class="line-modified">!         generator.emitLabel(*finallyViaThrowLabel);</span>
<span class="line-removed">-         RegisterID* unused = generator.newTemporary();</span>
<span class="line-removed">-         generator.emitCatch(generator.completionValueRegister(), unused, finallyTryData);</span>
<span class="line-removed">-         generator.emitSetCompletionType(CompletionType::Throw);</span>
  
          // Entry to the finally block for CompletionTypes other than Throw.
          generator.emitLabel(*finallyLabel);
          generator.restoreScopeRegister();
  
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; savedCompletionTypeRegister = generator.newTemporary();</span>
<span class="line-removed">-         generator.move(savedCompletionTypeRegister.get(), generator.completionTypeRegister());</span>
<span class="line-removed">- </span>
          int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
          generator.emitProfileControlFlow(finallyStartOffset);
          generator.emitNodeInTailPosition(m_finallyBlock);
  
<span class="line-modified">!         generator.emitFinallyCompletion(finallyContext, savedCompletionTypeRegister.get(), *finallyEndLabel);</span>
          generator.emitLabel(*finallyEndLabel);
          generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
      }
  }
  
<span class="line-new-header">--- 3755,34 ---</span>
  
          if (m_catchPattern)
              generator.emitPopCatchScope(m_lexicalVariables);
  
          if (m_finallyBlock) {
<span class="line-modified">!             generator.emitLoad(finallyContext-&gt;completionTypeRegister(), CompletionType::Normal);</span>
              generator.emitJump(*finallyLabel);
<span class="line-modified">!             generator.popTry(finallyTryData, *finallyLabel);</span>
          }
  
          generator.emitLabel(*catchEndLabel);
          generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
      }
  
      if (m_finallyBlock) {
<span class="line-modified">!         generator.popFinallyControlFlowScope();</span>
  
<span class="line-modified">!         // Entry to the finally block for CompletionType::Throw to be generated later.</span>
<span class="line-modified">!         generator.emitOutOfLineFinallyHandler(finallyContext-&gt;completionValueRegister(), finallyContext-&gt;completionTypeRegister(), finallyTryData);</span>
  
          // Entry to the finally block for CompletionTypes other than Throw.
          generator.emitLabel(*finallyLabel);
          generator.restoreScopeRegister();
  
          int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
          generator.emitProfileControlFlow(finallyStartOffset);
          generator.emitNodeInTailPosition(m_finallyBlock);
  
<span class="line-modified">!         generator.emitFinallyCompletion(finallyContext.value(), *finallyEndLabel);</span>
          generator.emitLabel(*finallyEndLabel);
          generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3739,11 ***</span>
  
  // ------------------------------ FunctionNode -----------------------------
  
  void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
<span class="line-modified">!     if (generator.vm()-&gt;typeProfiler()) {</span>
          // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
          if (m_parameters-&gt;isSimpleParameterList()) {
              for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
                  BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
                  RegisterID reg(CallFrame::argumentOffset(i));
<span class="line-new-header">--- 3838,11 ---</span>
  
  // ------------------------------ FunctionNode -----------------------------
  
  void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
<span class="line-modified">!     if (generator.shouldEmitTypeProfilerHooks()) {</span>
          // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
          if (m_parameters-&gt;isSimpleParameterList()) {
              for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
                  BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
                  RegisterID reg(CallFrame::argumentOffset(i));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4303,10 ***</span>
<span class="line-new-header">--- 4402,13 ---</span>
          excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
  
          addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
      }
  
<span class="line-added">+     BytecodeGenerator::PreservedTDZStack preservedTDZStack;</span>
<span class="line-added">+     generator.preserveTDZStack(preservedTDZStack);</span>
<span class="line-added">+ </span>
      for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
          const auto&amp; target = m_targetPatterns[i];
          if (target.bindingType == BindingType::Element) {
              RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
              RefPtr&lt;RegisterID&gt; propertyName;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4365,10 ***</span>
<span class="line-new-header">--- 4467,12 ---</span>
              RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
              generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
              target.pattern-&gt;bindValue(generator, result.get());
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     generator.restoreTDZStack(preservedTDZStack);</span>
  }
  
  void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
  {
      for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
</pre>
<center><a href="BytecodeGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../config.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>