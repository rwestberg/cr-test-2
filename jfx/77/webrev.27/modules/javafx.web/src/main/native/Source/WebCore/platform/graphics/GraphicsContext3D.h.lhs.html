<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext3D.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009, 2014 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
<a name="1" id="anc1"></a>

  28 #include &quot;ANGLEWebKitBridge.h&quot;
  29 #include &quot;GraphicsContext3DAttributes.h&quot;
  30 #include &quot;GraphicsTypes3D.h&quot;
  31 #include &quot;Image.h&quot;
  32 #include &quot;IntRect.h&quot;
  33 #include &quot;PlatformLayer.h&quot;
  34 #include &lt;memory&gt;
  35 #include &lt;wtf/HashCountedSet.h&gt;
  36 #include &lt;wtf/HashMap.h&gt;
  37 #include &lt;wtf/ListHashSet.h&gt;
  38 #include &lt;wtf/RefCounted.h&gt;
  39 #include &lt;wtf/RetainPtr.h&gt;
  40 #include &lt;wtf/UniqueArray.h&gt;
  41 #include &lt;wtf/text/WTFString.h&gt;
  42 
  43 #if USE(CA)
  44 #include &quot;PlatformCALayer.h&quot;
  45 #endif
  46 
  47 // FIXME: Find a better way to avoid the name confliction for NO_ERROR.
  48 #if PLATFORM(WIN)
  49 #undef NO_ERROR
  50 #elif PLATFORM(GTK)
  51 // This define is from the X11 headers, but it&#39;s used below, so we must undefine it.
  52 #undef VERSION
  53 #endif
  54 
  55 #if PLATFORM(COCOA)
  56 
  57 #if USE(OPENGL_ES)
  58 #include &lt;OpenGLES/ES2/gl.h&gt;
  59 #ifdef __OBJC__
  60 #import &lt;OpenGLES/EAGL.h&gt;
  61 typedef EAGLContext* PlatformGraphicsContext3D;
  62 #else
  63 typedef void* PlatformGraphicsContext3D;
  64 #endif // __OBJC__
  65 #endif // USE(OPENGL_ES)
  66 
<a name="2" id="anc2"></a><span class="line-modified">  67 #if !USE(OPENGL_ES)</span>
  68 typedef struct _CGLContextObject *CGLContextObj;
  69 typedef CGLContextObj PlatformGraphicsContext3D;
<a name="3" id="anc3"></a><span class="line-modified">  70 #endif</span>







  71 
  72 OBJC_CLASS CALayer;
  73 OBJC_CLASS WebGLLayer;
  74 typedef struct __IOSurface* IOSurfaceRef;
  75 #endif // PLATFORM(COCOA)
  76 
  77 #if USE(NICOSIA)
  78 namespace Nicosia {
  79 class GC3DLayer;
  80 }
  81 #endif
  82 
  83 #if !PLATFORM(COCOA)
  84 typedef unsigned GLuint;
  85 typedef void* PlatformGraphicsContext3D;
  86 typedef void* PlatformGraphicsSurface3D;
  87 #endif // !PLATFORM(COCOA)
  88 
  89 // These are currently the same among all implementations.
  90 const PlatformGraphicsContext3D NullPlatformGraphicsContext3D = 0;
  91 const Platform3DObject NullPlatform3DObject = 0;
  92 
  93 namespace WebCore {
  94 class Extensions3D;
  95 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
  96 class Extensions3DOpenGLES;
<a name="4" id="anc4"></a><span class="line-modified">  97 #else</span>
  98 class Extensions3DOpenGL;
<a name="5" id="anc5"></a>

  99 #endif
 100 class HostWindow;
 101 class Image;
 102 class ImageBuffer;
 103 class ImageData;
 104 class IntRect;
 105 class IntSize;
 106 class WebGLRenderingContextBase;
 107 #if USE(TEXTURE_MAPPER)
 108 class TextureMapperGC3DPlatformLayer;
 109 #endif
 110 
 111 typedef WTF::HashMap&lt;CString, uint64_t&gt; ShaderNameHash;
 112 
 113 struct ActiveInfo {
 114     String name;
 115     GC3Denum type;
 116     GC3Dint size;
 117 };
 118 
 119 class GraphicsContext3DPrivate;
 120 
 121 class GraphicsContext3D : public RefCounted&lt;GraphicsContext3D&gt; {
 122 public:
<a name="6" id="anc6"></a>








 123     enum {
 124         // WebGL 1 constants
 125         DEPTH_BUFFER_BIT = 0x00000100,
 126         STENCIL_BUFFER_BIT = 0x00000400,
 127         COLOR_BUFFER_BIT = 0x00004000,
 128         POINTS = 0x0000,
 129         LINES = 0x0001,
 130         LINE_LOOP = 0x0002,
 131         LINE_STRIP = 0x0003,
 132         TRIANGLES = 0x0004,
 133         TRIANGLE_STRIP = 0x0005,
 134         TRIANGLE_FAN = 0x0006,
 135         ZERO = 0,
 136         ONE = 1,
 137         SRC_COLOR = 0x0300,
 138         ONE_MINUS_SRC_COLOR = 0x0301,
 139         SRC_ALPHA = 0x0302,
 140         ONE_MINUS_SRC_ALPHA = 0x0303,
 141         DST_ALPHA = 0x0304,
 142         ONE_MINUS_DST_ALPHA = 0x0305,
 143         DST_COLOR = 0x0306,
 144         ONE_MINUS_DST_COLOR = 0x0307,
 145         SRC_ALPHA_SATURATE = 0x0308,
 146         FUNC_ADD = 0x8006,
 147         BLEND_EQUATION = 0x8009,
 148         BLEND_EQUATION_RGB = 0x8009,
 149         BLEND_EQUATION_ALPHA = 0x883D,
 150         FUNC_SUBTRACT = 0x800A,
 151         FUNC_REVERSE_SUBTRACT = 0x800B,
 152         BLEND_DST_RGB = 0x80C8,
 153         BLEND_SRC_RGB = 0x80C9,
 154         BLEND_DST_ALPHA = 0x80CA,
 155         BLEND_SRC_ALPHA = 0x80CB,
 156         CONSTANT_COLOR = 0x8001,
 157         ONE_MINUS_CONSTANT_COLOR = 0x8002,
 158         CONSTANT_ALPHA = 0x8003,
 159         ONE_MINUS_CONSTANT_ALPHA = 0x8004,
 160         BLEND_COLOR = 0x8005,
 161         ARRAY_BUFFER = 0x8892,
 162         ELEMENT_ARRAY_BUFFER = 0x8893,
 163         ARRAY_BUFFER_BINDING = 0x8894,
 164         ELEMENT_ARRAY_BUFFER_BINDING = 0x8895,
 165         STREAM_DRAW = 0x88E0,
 166         STATIC_DRAW = 0x88E4,
 167         DYNAMIC_DRAW = 0x88E8,
 168         BUFFER_SIZE = 0x8764,
 169         BUFFER_USAGE = 0x8765,
 170         CURRENT_VERTEX_ATTRIB = 0x8626,
 171         FRONT = 0x0404,
 172         BACK = 0x0405,
 173         FRONT_AND_BACK = 0x0408,
 174         TEXTURE_2D = 0x0DE1,
 175         CULL_FACE = 0x0B44,
 176         BLEND = 0x0BE2,
 177         DITHER = 0x0BD0,
 178         STENCIL_TEST = 0x0B90,
 179         DEPTH_TEST = 0x0B71,
 180         SCISSOR_TEST = 0x0C11,
 181         POLYGON_OFFSET_FILL = 0x8037,
 182         SAMPLE_ALPHA_TO_COVERAGE = 0x809E,
 183         SAMPLE_COVERAGE = 0x80A0,
 184         NO_ERROR = 0,
 185         INVALID_ENUM = 0x0500,
 186         INVALID_VALUE = 0x0501,
 187         INVALID_OPERATION = 0x0502,
 188         OUT_OF_MEMORY = 0x0505,
 189         CW = 0x0900,
 190         CCW = 0x0901,
 191         LINE_WIDTH = 0x0B21,
 192         ALIASED_POINT_SIZE_RANGE = 0x846D,
 193         ALIASED_LINE_WIDTH_RANGE = 0x846E,
 194         CULL_FACE_MODE = 0x0B45,
 195         FRONT_FACE = 0x0B46,
 196         DEPTH_RANGE = 0x0B70,
 197         DEPTH_WRITEMASK = 0x0B72,
 198         DEPTH_CLEAR_VALUE = 0x0B73,
 199         DEPTH_FUNC = 0x0B74,
 200         STENCIL_CLEAR_VALUE = 0x0B91,
 201         STENCIL_FUNC = 0x0B92,
 202         STENCIL_FAIL = 0x0B94,
 203         STENCIL_PASS_DEPTH_FAIL = 0x0B95,
 204         STENCIL_PASS_DEPTH_PASS = 0x0B96,
 205         STENCIL_REF = 0x0B97,
 206         STENCIL_VALUE_MASK = 0x0B93,
 207         STENCIL_WRITEMASK = 0x0B98,
 208         STENCIL_BACK_FUNC = 0x8800,
 209         STENCIL_BACK_FAIL = 0x8801,
 210         STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802,
 211         STENCIL_BACK_PASS_DEPTH_PASS = 0x8803,
 212         STENCIL_BACK_REF = 0x8CA3,
 213         STENCIL_BACK_VALUE_MASK = 0x8CA4,
 214         STENCIL_BACK_WRITEMASK = 0x8CA5,
 215         VIEWPORT = 0x0BA2,
 216         SCISSOR_BOX = 0x0C10,
 217         COLOR_CLEAR_VALUE = 0x0C22,
 218         COLOR_WRITEMASK = 0x0C23,
 219         UNPACK_ALIGNMENT = 0x0CF5,
 220         PACK_ALIGNMENT = 0x0D05,
 221         MAX_TEXTURE_SIZE = 0x0D33,
 222         MAX_VIEWPORT_DIMS = 0x0D3A,
 223         SUBPIXEL_BITS = 0x0D50,
 224         RED_BITS = 0x0D52,
 225         GREEN_BITS = 0x0D53,
 226         BLUE_BITS = 0x0D54,
 227         ALPHA_BITS = 0x0D55,
 228         DEPTH_BITS = 0x0D56,
 229         STENCIL_BITS = 0x0D57,
 230         POLYGON_OFFSET_UNITS = 0x2A00,
 231         POLYGON_OFFSET_FACTOR = 0x8038,
 232         TEXTURE_BINDING_2D = 0x8069,
 233         SAMPLE_BUFFERS = 0x80A8,
 234         SAMPLES = 0x80A9,
 235         SAMPLE_COVERAGE_VALUE = 0x80AA,
 236         SAMPLE_COVERAGE_INVERT = 0x80AB,
 237         NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2,
 238         COMPRESSED_TEXTURE_FORMATS = 0x86A3,
 239         DONT_CARE = 0x1100,
 240         FASTEST = 0x1101,
 241         NICEST = 0x1102,
 242         GENERATE_MIPMAP_HINT = 0x8192,
 243         BYTE = 0x1400,
 244         UNSIGNED_BYTE = 0x1401,
 245         SHORT = 0x1402,
 246         UNSIGNED_SHORT = 0x1403,
 247         INT = 0x1404,
 248         UNSIGNED_INT = 0x1405,
 249         FLOAT = 0x1406,
 250         HALF_FLOAT_OES = 0x8D61,
 251         FIXED = 0x140C,
 252         DEPTH_COMPONENT = 0x1902,
 253         ALPHA = 0x1906,
 254         RGB = 0x1907,
 255         RGBA = 0x1908,
 256         BGRA = 0x80E1,
 257         LUMINANCE = 0x1909,
 258         LUMINANCE_ALPHA = 0x190A,
 259         UNSIGNED_SHORT_4_4_4_4 = 0x8033,
 260         UNSIGNED_SHORT_5_5_5_1 = 0x8034,
 261         UNSIGNED_SHORT_5_6_5 = 0x8363,
 262         FRAGMENT_SHADER = 0x8B30,
 263         VERTEX_SHADER = 0x8B31,
 264         MAX_VERTEX_ATTRIBS = 0x8869,
 265         MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB,
 266         MAX_VARYING_VECTORS = 0x8DFC,
 267         MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D,
 268         MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C,
 269         MAX_TEXTURE_IMAGE_UNITS = 0x8872,
 270         MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD,
 271         SHADER_TYPE = 0x8B4F,
 272         DELETE_STATUS = 0x8B80,
 273         LINK_STATUS = 0x8B82,
 274         VALIDATE_STATUS = 0x8B83,
 275         ATTACHED_SHADERS = 0x8B85,
 276         ACTIVE_UNIFORMS = 0x8B86,
 277         ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87,
 278         ACTIVE_ATTRIBUTES = 0x8B89,
 279         ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A,
 280         SHADING_LANGUAGE_VERSION = 0x8B8C,
 281         CURRENT_PROGRAM = 0x8B8D,
 282         NEVER = 0x0200,
 283         LESS = 0x0201,
 284         EQUAL = 0x0202,
 285         LEQUAL = 0x0203,
 286         GREATER = 0x0204,
 287         NOTEQUAL = 0x0205,
 288         GEQUAL = 0x0206,
 289         ALWAYS = 0x0207,
 290         KEEP = 0x1E00,
 291         REPLACE = 0x1E01,
 292         INCR = 0x1E02,
 293         DECR = 0x1E03,
 294         INVERT = 0x150A,
 295         INCR_WRAP = 0x8507,
 296         DECR_WRAP = 0x8508,
 297         VENDOR = 0x1F00,
 298         RENDERER = 0x1F01,
 299         VERSION = 0x1F02,
 300         EXTENSIONS = 0x1F03,
 301         NEAREST = 0x2600,
 302         LINEAR = 0x2601,
 303         NEAREST_MIPMAP_NEAREST = 0x2700,
 304         LINEAR_MIPMAP_NEAREST = 0x2701,
 305         NEAREST_MIPMAP_LINEAR = 0x2702,
 306         LINEAR_MIPMAP_LINEAR = 0x2703,
 307         TEXTURE_MAG_FILTER = 0x2800,
 308         TEXTURE_MIN_FILTER = 0x2801,
 309         TEXTURE_WRAP_S = 0x2802,
 310         TEXTURE_WRAP_T = 0x2803,
 311         TEXTURE = 0x1702,
 312         TEXTURE_CUBE_MAP = 0x8513,
 313         TEXTURE_BINDING_CUBE_MAP = 0x8514,
 314         TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515,
 315         TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516,
 316         TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517,
 317         TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518,
 318         TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519,
 319         TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A,
 320         MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C,
 321         TEXTURE0 = 0x84C0,
 322         TEXTURE1 = 0x84C1,
 323         TEXTURE2 = 0x84C2,
 324         TEXTURE3 = 0x84C3,
 325         TEXTURE4 = 0x84C4,
 326         TEXTURE5 = 0x84C5,
 327         TEXTURE6 = 0x84C6,
 328         TEXTURE7 = 0x84C7,
 329         TEXTURE8 = 0x84C8,
 330         TEXTURE9 = 0x84C9,
 331         TEXTURE10 = 0x84CA,
 332         TEXTURE11 = 0x84CB,
 333         TEXTURE12 = 0x84CC,
 334         TEXTURE13 = 0x84CD,
 335         TEXTURE14 = 0x84CE,
 336         TEXTURE15 = 0x84CF,
 337         TEXTURE16 = 0x84D0,
 338         TEXTURE17 = 0x84D1,
 339         TEXTURE18 = 0x84D2,
 340         TEXTURE19 = 0x84D3,
 341         TEXTURE20 = 0x84D4,
 342         TEXTURE21 = 0x84D5,
 343         TEXTURE22 = 0x84D6,
 344         TEXTURE23 = 0x84D7,
 345         TEXTURE24 = 0x84D8,
 346         TEXTURE25 = 0x84D9,
 347         TEXTURE26 = 0x84DA,
 348         TEXTURE27 = 0x84DB,
 349         TEXTURE28 = 0x84DC,
 350         TEXTURE29 = 0x84DD,
 351         TEXTURE30 = 0x84DE,
 352         TEXTURE31 = 0x84DF,
 353         ACTIVE_TEXTURE = 0x84E0,
 354         REPEAT = 0x2901,
 355         CLAMP_TO_EDGE = 0x812F,
 356         MIRRORED_REPEAT = 0x8370,
 357         FLOAT_VEC2 = 0x8B50,
 358         FLOAT_VEC3 = 0x8B51,
 359         FLOAT_VEC4 = 0x8B52,
 360         INT_VEC2 = 0x8B53,
 361         INT_VEC3 = 0x8B54,
 362         INT_VEC4 = 0x8B55,
 363         BOOL = 0x8B56,
 364         BOOL_VEC2 = 0x8B57,
 365         BOOL_VEC3 = 0x8B58,
 366         BOOL_VEC4 = 0x8B59,
 367         FLOAT_MAT2 = 0x8B5A,
 368         FLOAT_MAT3 = 0x8B5B,
 369         FLOAT_MAT4 = 0x8B5C,
 370         SAMPLER_2D = 0x8B5E,
 371         SAMPLER_CUBE = 0x8B60,
 372         VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622,
 373         VERTEX_ATTRIB_ARRAY_SIZE = 0x8623,
 374         VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624,
 375         VERTEX_ATTRIB_ARRAY_TYPE = 0x8625,
 376         VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A,
 377         VERTEX_ATTRIB_ARRAY_POINTER = 0x8645,
 378         VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F,
 379         IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A,
 380         IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B,
 381         COMPILE_STATUS = 0x8B81,
 382         INFO_LOG_LENGTH = 0x8B84,
 383         SHADER_SOURCE_LENGTH = 0x8B88,
 384         SHADER_COMPILER = 0x8DFA,
 385         SHADER_BINARY_FORMATS = 0x8DF8,
 386         NUM_SHADER_BINARY_FORMATS = 0x8DF9,
 387         LOW_FLOAT = 0x8DF0,
 388         MEDIUM_FLOAT = 0x8DF1,
 389         HIGH_FLOAT = 0x8DF2,
 390         LOW_INT = 0x8DF3,
 391         MEDIUM_INT = 0x8DF4,
 392         HIGH_INT = 0x8DF5,
 393         FRAMEBUFFER = 0x8D40,
 394         RENDERBUFFER = 0x8D41,
 395         RGBA4 = 0x8056,
 396         RGB5_A1 = 0x8057,
 397         RGB565 = 0x8D62,
 398         DEPTH_COMPONENT16 = 0x81A5,
 399         STENCIL_INDEX = 0x1901,
 400         STENCIL_INDEX8 = 0x8D48,
 401         RENDERBUFFER_WIDTH = 0x8D42,
 402         RENDERBUFFER_HEIGHT = 0x8D43,
 403         RENDERBUFFER_INTERNAL_FORMAT = 0x8D44,
 404         RENDERBUFFER_RED_SIZE = 0x8D50,
 405         RENDERBUFFER_GREEN_SIZE = 0x8D51,
 406         RENDERBUFFER_BLUE_SIZE = 0x8D52,
 407         RENDERBUFFER_ALPHA_SIZE = 0x8D53,
 408         RENDERBUFFER_DEPTH_SIZE = 0x8D54,
 409         RENDERBUFFER_STENCIL_SIZE = 0x8D55,
 410         FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
 411         FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
 412         FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
 413         FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
 414         COLOR_ATTACHMENT0 = 0x8CE0,
 415         DEPTH_ATTACHMENT = 0x8D00,
 416         STENCIL_ATTACHMENT = 0x8D20,
 417         NONE = 0,
 418         FRAMEBUFFER_COMPLETE = 0x8CD5,
 419         FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
 420         FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
 421         FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9,
 422         FRAMEBUFFER_UNSUPPORTED = 0x8CDD,
 423         FRAMEBUFFER_BINDING = 0x8CA6,
 424         RENDERBUFFER_BINDING = 0x8CA7,
 425         MAX_RENDERBUFFER_SIZE = 0x84E8,
 426         INVALID_FRAMEBUFFER_OPERATION = 0x0506,
 427 
 428         // WebGL-specific enums
 429         UNPACK_FLIP_Y_WEBGL = 0x9240,
 430         UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
 431         CONTEXT_LOST_WEBGL = 0x9242,
 432         UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
 433         BROWSER_DEFAULT_WEBGL = 0x9244,
 434         VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE,
 435 
 436         // WebGL2 constants
 437         READ_BUFFER = 0x0C02,
 438         UNPACK_ROW_LENGTH = 0x0CF2,
 439         UNPACK_SKIP_ROWS = 0x0CF3,
 440         UNPACK_SKIP_PIXELS = 0x0CF4,
 441         PACK_ROW_LENGTH = 0x0D02,
 442         PACK_SKIP_ROWS = 0x0D03,
 443         PACK_SKIP_PIXELS = 0x0D04,
 444         COLOR = 0x1800,
 445         DEPTH = 0x1801,
 446         STENCIL = 0x1802,
 447         RED = 0x1903,
 448         RGB8 = 0x8051,
 449         RGBA8 = 0x8058,
 450         RGB10_A2 = 0x8059,
 451         TEXTURE_BINDING_3D = 0x806A,
 452         UNPACK_SKIP_IMAGES = 0x806D,
 453         UNPACK_IMAGE_HEIGHT = 0x806E,
 454         TEXTURE_3D = 0x806F,
 455         TEXTURE_WRAP_R = 0x8072,
 456         MAX_3D_TEXTURE_SIZE = 0x8073,
 457         UNSIGNED_INT_2_10_10_10_REV = 0x8368,
 458         MAX_ELEMENTS_VERTICES = 0x80E8,
 459         MAX_ELEMENTS_INDICES = 0x80E9,
 460         TEXTURE_MIN_LOD = 0x813A,
 461         TEXTURE_MAX_LOD = 0x813B,
 462         TEXTURE_BASE_LEVEL = 0x813C,
 463         TEXTURE_MAX_LEVEL = 0x813D,
 464         MIN = 0x8007,
 465         MAX = 0x8008,
 466         DEPTH_COMPONENT24 = 0x81A6,
 467         MAX_TEXTURE_LOD_BIAS = 0x84FD,
 468         TEXTURE_COMPARE_MODE = 0x884C,
 469         TEXTURE_COMPARE_FUNC = 0x884D,
 470         CURRENT_QUERY = 0x8865,
 471         QUERY_RESULT = 0x8866,
 472         QUERY_RESULT_AVAILABLE = 0x8867,
 473         STREAM_READ = 0x88E1,
 474         STREAM_COPY = 0x88E2,
 475         STATIC_READ = 0x88E5,
 476         STATIC_COPY = 0x88E6,
 477         DYNAMIC_READ = 0x88E9,
 478         DYNAMIC_COPY = 0x88EA,
 479         MAX_DRAW_BUFFERS = 0x8824,
 480         DRAW_BUFFER0 = 0x8825,
 481         DRAW_BUFFER1 = 0x8826,
 482         DRAW_BUFFER2 = 0x8827,
 483         DRAW_BUFFER3 = 0x8828,
 484         DRAW_BUFFER4 = 0x8829,
 485         DRAW_BUFFER5 = 0x882A,
 486         DRAW_BUFFER6 = 0x882B,
 487         DRAW_BUFFER7 = 0x882C,
 488         DRAW_BUFFER8 = 0x882D,
 489         DRAW_BUFFER9 = 0x882E,
 490         DRAW_BUFFER10 = 0x882F,
 491         DRAW_BUFFER11 = 0x8830,
 492         DRAW_BUFFER12 = 0x8831,
 493         DRAW_BUFFER13 = 0x8832,
 494         DRAW_BUFFER14 = 0x8833,
 495         DRAW_BUFFER15 = 0x8834,
 496         MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49,
 497         MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A,
 498         SAMPLER_3D = 0x8B5F,
 499         SAMPLER_2D_SHADOW = 0x8B62,
 500         FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
 501         PIXEL_PACK_BUFFER = 0x88EB,
 502         PIXEL_UNPACK_BUFFER = 0x88EC,
 503         PIXEL_PACK_BUFFER_BINDING = 0x88ED,
 504         PIXEL_UNPACK_BUFFER_BINDING = 0x88EF,
 505         FLOAT_MAT2x3 = 0x8B65,
 506         FLOAT_MAT2x4 = 0x8B66,
 507         FLOAT_MAT3x2 = 0x8B67,
 508         FLOAT_MAT3x4 = 0x8B68,
 509         FLOAT_MAT4x2 = 0x8B69,
 510         FLOAT_MAT4x3 = 0x8B6A,
 511         SRGB = 0x8C40,
 512         SRGB8 = 0x8C41,
 513         SRGB_ALPHA = 0x8C42,
 514         SRGB8_ALPHA8 = 0x8C43,
 515         COMPARE_REF_TO_TEXTURE = 0x884E,
 516         RGBA32F = 0x8814,
 517         RGB32F = 0x8815,
 518         RGBA16F = 0x881A,
 519         RGB16F = 0x881B,
 520         VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD,
 521         MAX_ARRAY_TEXTURE_LAYERS = 0x88FF,
 522         MIN_PROGRAM_TEXEL_OFFSET = 0x8904,
 523         MAX_PROGRAM_TEXEL_OFFSET = 0x8905,
 524         MAX_VARYING_COMPONENTS = 0x8B4B,
 525         TEXTURE_2D_ARRAY = 0x8C1A,
 526         TEXTURE_BINDING_2D_ARRAY = 0x8C1D,
 527         R11F_G11F_B10F = 0x8C3A,
 528         UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B,
 529         RGB9_E5 = 0x8C3D,
 530         UNSIGNED_INT_5_9_9_9_REV = 0x8C3E,
 531         TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F,
 532         MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80,
 533         TRANSFORM_FEEDBACK_VARYINGS = 0x8C83,
 534         TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84,
 535         TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85,
 536         TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88,
 537         RASTERIZER_DISCARD = 0x8C89,
 538         MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A,
 539         MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B,
 540         INTERLEAVED_ATTRIBS = 0x8C8C,
 541         SEPARATE_ATTRIBS = 0x8C8D,
 542         TRANSFORM_FEEDBACK_BUFFER = 0x8C8E,
 543         TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F,
 544         RGBA32UI = 0x8D70,
 545         RGB32UI = 0x8D71,
 546         RGBA16UI = 0x8D76,
 547         RGB16UI = 0x8D77,
 548         RGBA8UI = 0x8D7C,
 549         RGB8UI = 0x8D7D,
 550         RGBA32I = 0x8D82,
 551         RGB32I = 0x8D83,
 552         RGBA16I = 0x8D88,
 553         RGB16I = 0x8D89,
 554         RGBA8I = 0x8D8E,
 555         RGB8I = 0x8D8F,
 556         RED_INTEGER = 0x8D94,
 557         RGB_INTEGER = 0x8D98,
 558         RGBA_INTEGER = 0x8D99,
 559         SAMPLER_2D_ARRAY = 0x8DC1,
 560         SAMPLER_2D_ARRAY_SHADOW = 0x8DC4,
 561         SAMPLER_CUBE_SHADOW = 0x8DC5,
 562         UNSIGNED_INT_VEC2 = 0x8DC6,
 563         UNSIGNED_INT_VEC3 = 0x8DC7,
 564         UNSIGNED_INT_VEC4 = 0x8DC8,
 565         INT_SAMPLER_2D = 0x8DCA,
 566         INT_SAMPLER_3D = 0x8DCB,
 567         INT_SAMPLER_CUBE = 0x8DCC,
 568         INT_SAMPLER_2D_ARRAY = 0x8DCF,
 569         UNSIGNED_INT_SAMPLER_2D = 0x8DD2,
 570         UNSIGNED_INT_SAMPLER_3D = 0x8DD3,
 571         UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4,
 572         UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7,
 573         DEPTH_COMPONENT32F = 0x8CAC,
 574         DEPTH32F_STENCIL8 = 0x8CAD,
 575         FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD,
 576         FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
 577         FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
 578         FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212,
 579         FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
 580         FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
 581         FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
 582         FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
 583         FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
 584         FRAMEBUFFER_DEFAULT = 0x8218,
 585         DEPTH_STENCIL_ATTACHMENT = 0x821A,
 586         DEPTH_STENCIL = 0x84F9,
 587         UNSIGNED_INT_24_8 = 0x84FA,
 588         DEPTH24_STENCIL8 = 0x88F0,
 589         UNSIGNED_NORMALIZED = 0x8C17,
 590         DRAW_FRAMEBUFFER_BINDING = 0x8CA6, /* Same as FRAMEBUFFER_BINDING */
 591         READ_FRAMEBUFFER = 0x8CA8,
 592         DRAW_FRAMEBUFFER = 0x8CA9,
 593         READ_FRAMEBUFFER_BINDING = 0x8CAA,
 594         RENDERBUFFER_SAMPLES = 0x8CAB,
 595         FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
 596         MAX_COLOR_ATTACHMENTS = 0x8CDF,
 597         COLOR_ATTACHMENT1 = 0x8CE1,
 598         COLOR_ATTACHMENT2 = 0x8CE2,
 599         COLOR_ATTACHMENT3 = 0x8CE3,
 600         COLOR_ATTACHMENT4 = 0x8CE4,
 601         COLOR_ATTACHMENT5 = 0x8CE5,
 602         COLOR_ATTACHMENT6 = 0x8CE6,
 603         COLOR_ATTACHMENT7 = 0x8CE7,
 604         COLOR_ATTACHMENT8 = 0x8CE8,
 605         COLOR_ATTACHMENT9 = 0x8CE9,
 606         COLOR_ATTACHMENT10 = 0x8CEA,
 607         COLOR_ATTACHMENT11 = 0x8CEB,
 608         COLOR_ATTACHMENT12 = 0x8CEC,
 609         COLOR_ATTACHMENT13 = 0x8CED,
 610         COLOR_ATTACHMENT14 = 0x8CEE,
 611         COLOR_ATTACHMENT15 = 0x8CEF,
 612         FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
 613         MAX_SAMPLES = 0x8D57,
 614         HALF_FLOAT = 0x140B,
 615         RG = 0x8227,
 616         RG_INTEGER = 0x8228,
 617         R8 = 0x8229,
 618         RG8 = 0x822B,
 619         R16F = 0x822D,
 620         R32F = 0x822E,
 621         RG16F = 0x822F,
 622         RG32F = 0x8230,
 623         R8I = 0x8231,
 624         R8UI = 0x8232,
 625         R16I = 0x8233,
 626         R16UI = 0x8234,
 627         R32I = 0x8235,
 628         R32UI = 0x8236,
 629         RG8I = 0x8237,
 630         RG8UI = 0x8238,
 631         RG16I = 0x8239,
 632         RG16UI = 0x823A,
 633         RG32I = 0x823B,
 634         RG32UI = 0x823C,
 635         VERTEX_ARRAY_BINDING = 0x85B5,
 636         R8_SNORM = 0x8F94,
 637         RG8_SNORM = 0x8F95,
 638         RGB8_SNORM = 0x8F96,
 639         RGBA8_SNORM = 0x8F97,
 640         SIGNED_NORMALIZED = 0x8F9C,
 641         COPY_READ_BUFFER = 0x8F36,
 642         COPY_WRITE_BUFFER = 0x8F37,
 643         COPY_READ_BUFFER_BINDING = 0x8F36, /* Same as COPY_READ_BUFFER */
 644         COPY_WRITE_BUFFER_BINDING = 0x8F37, /* Same as COPY_WRITE_BUFFER */
 645         UNIFORM_BUFFER = 0x8A11,
 646         UNIFORM_BUFFER_BINDING = 0x8A28,
 647         UNIFORM_BUFFER_START = 0x8A29,
 648         UNIFORM_BUFFER_SIZE = 0x8A2A,
 649         MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B,
 650         MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D,
 651         MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E,
 652         MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F,
 653         MAX_UNIFORM_BLOCK_SIZE = 0x8A30,
 654         MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
 655         MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
 656         UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34,
 657         ACTIVE_UNIFORM_BLOCKS = 0x8A36,
 658         UNIFORM_TYPE = 0x8A37,
 659         UNIFORM_SIZE = 0x8A38,
 660         UNIFORM_BLOCK_INDEX = 0x8A3A,
 661         UNIFORM_OFFSET = 0x8A3B,
 662         UNIFORM_ARRAY_STRIDE = 0x8A3C,
 663         UNIFORM_MATRIX_STRIDE = 0x8A3D,
 664         UNIFORM_IS_ROW_MAJOR = 0x8A3E,
 665         UNIFORM_BLOCK_BINDING = 0x8A3F,
 666         UNIFORM_BLOCK_DATA_SIZE = 0x8A40,
 667         UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42,
 668         UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
 669         UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
 670         UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
 671         INVALID_INDEX = 0xFFFFFFFF,
 672         MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122,
 673         MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125,
 674         MAX_SERVER_WAIT_TIMEOUT = 0x9111,
 675         OBJECT_TYPE = 0x9112,
 676         SYNC_CONDITION = 0x9113,
 677         SYNC_STATUS = 0x9114,
 678         SYNC_FLAGS = 0x9115,
 679         SYNC_FENCE = 0x9116,
 680         SYNC_GPU_COMMANDS_COMPLETE = 0x9117,
 681         UNSIGNALED = 0x9118,
 682         SIGNALED = 0x9119,
 683         ALREADY_SIGNALED = 0x911A,
 684         TIMEOUT_EXPIRED = 0x911B,
 685         CONDITION_SATISFIED = 0x911C,
 686 #if PLATFORM(WIN)
 687         WAIT_FAILED_WIN = 0x911D,
 688 #else
 689         WAIT_FAILED = 0x911D,
 690 #endif
 691         SYNC_FLUSH_COMMANDS_BIT = 0x00000001,
 692         VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE,
 693         ANY_SAMPLES_PASSED = 0x8C2F,
 694         ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A,
 695         SAMPLER_BINDING = 0x8919,
 696         RGB10_A2UI = 0x906F,
 697         TEXTURE_SWIZZLE_R = 0x8E42,
 698         TEXTURE_SWIZZLE_G = 0x8E43,
 699         TEXTURE_SWIZZLE_B = 0x8E44,
 700         TEXTURE_SWIZZLE_A = 0x8E45,
 701         GREEN = 0x1904,
 702         BLUE = 0x1905,
 703         INT_2_10_10_10_REV = 0x8D9F,
 704         TRANSFORM_FEEDBACK = 0x8E22,
 705         TRANSFORM_FEEDBACK_PAUSED = 0x8E23,
 706         TRANSFORM_FEEDBACK_ACTIVE = 0x8E24,
 707         TRANSFORM_FEEDBACK_BINDING = 0x8E25,
 708         COMPRESSED_R11_EAC = 0x9270,
 709         COMPRESSED_SIGNED_R11_EAC = 0x9271,
 710         COMPRESSED_RG11_EAC = 0x9272,
 711         COMPRESSED_SIGNED_RG11_EAC = 0x9273,
 712         COMPRESSED_RGB8_ETC2 = 0x9274,
 713         COMPRESSED_SRGB8_ETC2 = 0x9275,
 714         COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,
 715         COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,
 716         COMPRESSED_RGBA8_ETC2_EAC = 0x9278,
 717         COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,
 718         TEXTURE_IMMUTABLE_FORMAT = 0x912F,
 719         MAX_ELEMENT_INDEX = 0x8D6B,
 720         NUM_SAMPLE_COUNTS = 0x9380,
 721         TEXTURE_IMMUTABLE_LEVELS = 0x82DF,
 722         PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69,
 723         PRIMITIVE_RESTART = 0x8F9D,
 724 
 725         // OpenGL ES 3 constants
 726         MAP_READ_BIT = 0x0001
 727     };
 728 
 729     enum RenderStyle {
 730         RenderOffscreen,
 731         RenderDirectlyToHostWindow,
 732     };
 733 
 734     class ContextLostCallback {
 735     public:
 736         virtual void onContextLost() = 0;
 737         virtual ~ContextLostCallback() = default;
 738     };
 739 
 740     class ErrorMessageCallback {
 741     public:
 742         virtual void onErrorMessage(const String&amp; message, GC3Dint id) = 0;
 743         virtual ~ErrorMessageCallback() = default;
 744     };
 745 
 746     void setContextLostCallback(std::unique_ptr&lt;ContextLostCallback&gt;);
 747     void setErrorMessageCallback(std::unique_ptr&lt;ErrorMessageCallback&gt;);
 748 
 749     static RefPtr&lt;GraphicsContext3D&gt; create(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen);
 750     ~GraphicsContext3D();
 751 
 752 #if PLATFORM(COCOA)
 753     static Ref&lt;GraphicsContext3D&gt; createShared(GraphicsContext3D&amp; sharedContext);
 754 #endif
 755 
 756 #if PLATFORM(COCOA)
 757     PlatformGraphicsContext3D platformGraphicsContext3D() const { return m_contextObj; }
 758     Platform3DObject platformTexture() const { return m_texture; }
 759     CALayer* platformLayer() const { return reinterpret_cast&lt;CALayer*&gt;(m_webGLLayer.get()); }
 760 #else
 761     PlatformGraphicsContext3D platformGraphicsContext3D();
 762     Platform3DObject platformTexture() const;
 763     PlatformLayer* platformLayer() const;
 764 #endif
 765 
 766     bool makeContextCurrent();
<a name="7" id="anc7"></a><span class="line-modified"> 767     void setWebGLContext(WebGLRenderingContextBase* base) { m_webglContext = base; }</span>


 768 
 769     // With multisampling on, blit from multisampleFBO to regular FBO.
 770     void prepareTexture();
 771 
 772     // Equivalent to ::glTexImage2D(). Allows pixels==0 with no allocation.
 773     void texImage2DDirect(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
 774 
 775     // Get an attribute location without checking the name -&gt; mangledname mapping.
 776     int getAttribLocationDirect(Platform3DObject program, const String&amp; name);
 777 
 778     // Compile a shader without going through ANGLE.
 779     void compileShaderDirect(Platform3DObject);
 780 
 781     // Helper to texImage2D with pixel==0 case: pixels are initialized to 0.
 782     // Return true if no GL error is synthesized.
 783     // By default, alignment is 4, the OpenGL default setting.
 784     bool texImage2DResourceSafe(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint alignment = 4);
 785 
 786     bool isGLES2Compliant() const;
 787 
 788     //----------------------------------------------------------------------
 789     // Helpers for texture uploading and pixel readback.
 790     //
 791 
 792     // Computes the components per pixel and bytes per component
 793     // for the given format and type combination. Returns false if
 794     // either was an invalid enum.
 795     static bool computeFormatAndTypeParameters(GC3Denum format,
 796                                                GC3Denum type,
 797                                                unsigned int* componentsPerPixel,
 798                                                unsigned int* bytesPerComponent);
 799 
 800     // Computes the image size in bytes. If paddingInBytes is not null, padding
 801     // is also calculated in return. Returns NO_ERROR if succeed, otherwise
 802     // return the suggested GL error indicating the cause of the failure:
 803     //   INVALID_VALUE if width/height is negative or overflow happens.
 804     //   INVALID_ENUM if format/type is illegal.
 805     static GC3Denum computeImageSizeInBytes(GC3Denum format,
 806                                      GC3Denum type,
 807                                      GC3Dsizei width,
 808                                      GC3Dsizei height,
 809                                      GC3Dint alignment,
 810                                      unsigned int* imageSizeInBytes,
 811                                      unsigned int* paddingInBytes);
 812 
 813     static bool possibleFormatAndTypeForInternalFormat(GC3Denum internalFormat, GC3Denum&amp; format, GC3Denum&amp; type);
 814 
 815     // Extracts the contents of the given ImageData into the passed Vector,
 816     // packing the pixel data according to the given format and type,
 817     // and obeying the flipY and premultiplyAlpha flags. Returns true
 818     // upon success.
 819     static bool extractImageData(ImageData*,
 820                           GC3Denum format,
 821                           GC3Denum type,
 822                           bool flipY,
 823                           bool premultiplyAlpha,
 824                           Vector&lt;uint8_t&gt;&amp; data);
 825 
 826     // Helper function which extracts the user-supplied texture
 827     // data, applying the flipY and premultiplyAlpha parameters.
 828     // If the data is not tightly packed according to the passed
 829     // unpackAlignment, the output data will be tightly packed.
 830     // Returns true if successful, false if any error occurred.
 831     static bool extractTextureData(unsigned int width, unsigned int height,
 832                             GC3Denum format, GC3Denum type,
 833                             unsigned int unpackAlignment,
 834                             bool flipY, bool premultiplyAlpha,
 835                             const void* pixels,
 836                             Vector&lt;uint8_t&gt;&amp; data);
 837 
 838 
 839     // Attempt to enumerate all possible native image formats to
 840     // reduce the amount of temporary allocations during texture
 841     // uploading. This enum must be public because it is accessed
 842     // by non-member functions.
 843     enum DataFormat {
 844         DataFormatRGBA8 = 0,
 845         DataFormatRGBA16Little,
 846         DataFormatRGBA16Big,
 847         DataFormatRGBA16F,
 848         DataFormatRGBA32F,
 849         DataFormatRGB8,
 850         DataFormatRGB16Little,
 851         DataFormatRGB16Big,
 852         DataFormatRGB16F,
 853         DataFormatRGB32F,
 854         DataFormatBGR8,
 855         DataFormatBGRA8,
 856         DataFormatBGRA16Little,
 857         DataFormatBGRA16Big,
 858         DataFormatARGB8,
 859         DataFormatARGB16Little,
 860         DataFormatARGB16Big,
 861         DataFormatABGR8,
 862         DataFormatRGBA5551,
 863         DataFormatRGBA4444,
 864         DataFormatRGB565,
 865         DataFormatR8,
 866         DataFormatR16Little,
 867         DataFormatR16Big,
 868         DataFormatR16F,
 869         DataFormatR32F,
 870         DataFormatRA8,
 871         DataFormatRA16Little,
 872         DataFormatRA16Big,
 873         DataFormatRA16F,
 874         DataFormatRA32F,
 875         DataFormatAR8,
 876         DataFormatAR16Little,
 877         DataFormatAR16Big,
 878         DataFormatA8,
 879         DataFormatA16Little,
 880         DataFormatA16Big,
 881         DataFormatA16F,
 882         DataFormatA32F,
 883         DataFormatNumFormats
 884     };
 885 
 886     ALWAYS_INLINE static bool hasAlpha(DataFormat format)
 887     {
 888         switch (format) {
 889         case GraphicsContext3D::DataFormatA8:
 890         case GraphicsContext3D::DataFormatA16F:
 891         case GraphicsContext3D::DataFormatA32F:
 892         case GraphicsContext3D::DataFormatRA8:
 893         case GraphicsContext3D::DataFormatAR8:
 894         case GraphicsContext3D::DataFormatRA16F:
 895         case GraphicsContext3D::DataFormatRA32F:
 896         case GraphicsContext3D::DataFormatRGBA8:
 897         case GraphicsContext3D::DataFormatBGRA8:
 898         case GraphicsContext3D::DataFormatARGB8:
 899         case GraphicsContext3D::DataFormatABGR8:
 900         case GraphicsContext3D::DataFormatRGBA16F:
 901         case GraphicsContext3D::DataFormatRGBA32F:
 902         case GraphicsContext3D::DataFormatRGBA4444:
 903         case GraphicsContext3D::DataFormatRGBA5551:
 904             return true;
 905         default:
 906             return false;
 907         }
 908     }
 909 
 910     ALWAYS_INLINE static bool hasColor(DataFormat format)
 911     {
 912         switch (format) {
 913         case GraphicsContext3D::DataFormatRGBA8:
 914         case GraphicsContext3D::DataFormatRGBA16F:
 915         case GraphicsContext3D::DataFormatRGBA32F:
 916         case GraphicsContext3D::DataFormatRGB8:
 917         case GraphicsContext3D::DataFormatRGB16F:
 918         case GraphicsContext3D::DataFormatRGB32F:
 919         case GraphicsContext3D::DataFormatBGR8:
 920         case GraphicsContext3D::DataFormatBGRA8:
 921         case GraphicsContext3D::DataFormatARGB8:
 922         case GraphicsContext3D::DataFormatABGR8:
 923         case GraphicsContext3D::DataFormatRGBA5551:
 924         case GraphicsContext3D::DataFormatRGBA4444:
 925         case GraphicsContext3D::DataFormatRGB565:
 926         case GraphicsContext3D::DataFormatR8:
 927         case GraphicsContext3D::DataFormatR16F:
 928         case GraphicsContext3D::DataFormatR32F:
 929         case GraphicsContext3D::DataFormatRA8:
 930         case GraphicsContext3D::DataFormatRA16F:
 931         case GraphicsContext3D::DataFormatRA32F:
 932         case GraphicsContext3D::DataFormatAR8:
 933             return true;
 934         default:
 935             return false;
 936         }
 937     }
 938 
 939     // Check if the format is one of the formats from the ImageData or DOM elements.
 940     // The formats from ImageData is always RGBA8.
 941     // The formats from DOM elements vary with Graphics ports. It can only be RGBA8 or BGRA8 for non-CG port while a little more for CG port.
 942     static ALWAYS_INLINE bool srcFormatComesFromDOMElementOrImageData(DataFormat SrcFormat)
 943     {
 944 #if USE(CG)
 945 #if CPU(BIG_ENDIAN)
 946     return SrcFormat == DataFormatRGBA8 || SrcFormat == DataFormatARGB8 || SrcFormat == DataFormatRGB8
 947         || SrcFormat == DataFormatRA8 || SrcFormat == DataFormatAR8 || SrcFormat == DataFormatR8 || SrcFormat == DataFormatA8;
 948 #else
 949     // That LITTLE_ENDIAN case has more possible formats than BIG_ENDIAN case is because some decoded image data is actually big endian
 950     // even on little endian architectures.
 951     return SrcFormat == DataFormatBGRA8 || SrcFormat == DataFormatABGR8 || SrcFormat == DataFormatBGR8
 952         || SrcFormat == DataFormatRGBA8 || SrcFormat == DataFormatARGB8 || SrcFormat == DataFormatRGB8
 953         || SrcFormat == DataFormatR8 || SrcFormat == DataFormatA8
 954         || SrcFormat == DataFormatRA8 || SrcFormat == DataFormatAR8;
 955 #endif
 956 #else
 957     return SrcFormat == DataFormatBGRA8 || SrcFormat == DataFormatRGBA8;
 958 #endif
 959     }
 960 
 961     //----------------------------------------------------------------------
 962     // Entry points for WebGL.
 963     //
 964 
 965     void activeTexture(GC3Denum texture);
 966     void attachShader(Platform3DObject program, Platform3DObject shader);
 967     void bindAttribLocation(Platform3DObject, GC3Duint index, const String&amp; name);
 968     void bindBuffer(GC3Denum target, Platform3DObject);
 969     void bindFramebuffer(GC3Denum target, Platform3DObject);
 970     void bindRenderbuffer(GC3Denum target, Platform3DObject);
 971     void bindTexture(GC3Denum target, Platform3DObject);
 972     void blendColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha);
 973     void blendEquation(GC3Denum mode);
 974     void blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha);
 975     void blendFunc(GC3Denum sfactor, GC3Denum dfactor);
 976     void blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha);
 977 
 978     void bufferData(GC3Denum target, GC3Dsizeiptr size, GC3Denum usage);
 979     void bufferData(GC3Denum target, GC3Dsizeiptr size, const void* data, GC3Denum usage);
 980     void bufferSubData(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr size, const void* data);
 981 
 982     void* mapBufferRange(GC3Denum target, GC3Dintptr offset, GC3Dsizeiptr length, GC3Dbitfield access);
 983     GC3Dboolean unmapBuffer(GC3Denum target);
 984     void copyBufferSubData(GC3Denum readTarget, GC3Denum writeTarget, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr);
 985 
 986     void getInternalformativ(GC3Denum target, GC3Denum internalformat, GC3Denum pname, GC3Dsizei bufSize, GC3Dint* params);
 987     void renderbufferStorageMultisample(GC3Denum target, GC3Dsizei samples, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
 988 
 989     void texStorage2D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
 990     void texStorage3D(GC3Denum target, GC3Dsizei levels, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth);
 991 
 992     void getActiveUniforms(Platform3DObject program, const Vector&lt;GC3Duint&gt;&amp; uniformIndices, GC3Denum pname, Vector&lt;GC3Dint&gt;&amp; params);
 993 
 994     GC3Denum checkFramebufferStatus(GC3Denum target);
 995     void clear(GC3Dbitfield mask);
 996     void clearColor(GC3Dclampf red, GC3Dclampf green, GC3Dclampf blue, GC3Dclampf alpha);
 997     void clearDepth(GC3Dclampf depth);
 998     void clearStencil(GC3Dint s);
 999     void colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha);
1000     void compileShader(Platform3DObject);
1001 
1002     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Dsizei imageSize, const void* data);
1003     void compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Dsizei imageSize, const void* data);
1004     void copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border);
1005     void copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1006     void cullFace(GC3Denum mode);
1007     void depthFunc(GC3Denum func);
1008     void depthMask(GC3Dboolean flag);
1009     void depthRange(GC3Dclampf zNear, GC3Dclampf zFar);
1010     void detachShader(Platform3DObject, Platform3DObject);
1011     void disable(GC3Denum cap);
1012     void disableVertexAttribArray(GC3Duint index);
1013     void drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count);
1014     void drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset);
1015 
1016     void enable(GC3Denum cap);
1017     void enableVertexAttribArray(GC3Duint index);
1018     void finish();
1019     void flush();
1020     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, Platform3DObject);
1021     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, Platform3DObject, GC3Dint level);
1022     void frontFace(GC3Denum mode);
1023     void generateMipmap(GC3Denum target);
1024 
1025     bool getActiveAttrib(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1026     bool getActiveAttribImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1027     bool getActiveUniform(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1028     bool getActiveUniformImpl(Platform3DObject program, GC3Duint index, ActiveInfo&amp;);
1029     void getAttachedShaders(Platform3DObject program, GC3Dsizei maxCount, GC3Dsizei* count, Platform3DObject* shaders);
1030     GC3Dint getAttribLocation(Platform3DObject, const String&amp; name);
1031     void getBooleanv(GC3Denum pname, GC3Dboolean* value);
1032     void getBufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1033     GraphicsContext3DAttributes getContextAttributes();
1034     GC3Denum getError();
1035     void getFloatv(GC3Denum pname, GC3Dfloat* value);
1036     void getFramebufferAttachmentParameteriv(GC3Denum target, GC3Denum attachment, GC3Denum pname, GC3Dint* value);
1037     void getIntegerv(GC3Denum pname, GC3Dint* value);
1038     void getInteger64v(GC3Denum pname, GC3Dint64* value);
1039     void getProgramiv(Platform3DObject program, GC3Denum pname, GC3Dint* value);
<a name="8" id="anc8"></a>
1040     void getNonBuiltInActiveSymbolCount(Platform3DObject program, GC3Denum pname, GC3Dint* value);
<a name="9" id="anc9"></a>
1041     String getProgramInfoLog(Platform3DObject);
1042     String getUnmangledInfoLog(Platform3DObject[2], GC3Dsizei, const String&amp;);
1043     void getRenderbufferParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1044     void getShaderiv(Platform3DObject, GC3Denum pname, GC3Dint* value);
1045     String getShaderInfoLog(Platform3DObject);
1046     void getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType, GC3Dint* range, GC3Dint* precision);
<a name="10" id="anc10"></a>
1047     String getShaderSource(Platform3DObject);
<a name="11" id="anc11"></a>
1048     String getString(GC3Denum name);
1049     void getTexParameterfv(GC3Denum target, GC3Denum pname, GC3Dfloat* value);
1050     void getTexParameteriv(GC3Denum target, GC3Denum pname, GC3Dint* value);
1051     void getUniformfv(Platform3DObject program, GC3Dint location, GC3Dfloat* value);
1052     void getUniformiv(Platform3DObject program, GC3Dint location, GC3Dint* value);
1053     GC3Dint getUniformLocation(Platform3DObject, const String&amp; name);
1054     void getVertexAttribfv(GC3Duint index, GC3Denum pname, GC3Dfloat* value);
1055     void getVertexAttribiv(GC3Duint index, GC3Denum pname, GC3Dint* value);
1056     GC3Dsizeiptr getVertexAttribOffset(GC3Duint index, GC3Denum pname);
1057 
1058     void hint(GC3Denum target, GC3Denum mode);
1059     GC3Dboolean isBuffer(Platform3DObject);
1060     GC3Dboolean isEnabled(GC3Denum cap);
1061     GC3Dboolean isFramebuffer(Platform3DObject);
1062     GC3Dboolean isProgram(Platform3DObject);
1063     GC3Dboolean isRenderbuffer(Platform3DObject);
1064     GC3Dboolean isShader(Platform3DObject);
1065     GC3Dboolean isTexture(Platform3DObject);
1066     void lineWidth(GC3Dfloat);
1067     void linkProgram(Platform3DObject);
1068     void pixelStorei(GC3Denum pname, GC3Dint param);
1069     void polygonOffset(GC3Dfloat factor, GC3Dfloat units);
1070 
1071     void readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, void* data);
1072 
1073     void releaseShaderCompiler();
1074 
1075     void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);
1076     void sampleCoverage(GC3Dclampf value, GC3Dboolean invert);
1077     void scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1078     void shaderSource(Platform3DObject, const String&amp; string);
1079     void stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask);
1080     void stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask);
1081     void stencilMask(GC3Duint mask);
1082     void stencilMaskSeparate(GC3Denum face, GC3Duint mask);
1083     void stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass);
1084     void stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass);
1085 
1086     bool texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);
1087     void texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param);
1088     void texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param);
1089     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, const void* pixels);
1090 
1091     void uniform1f(GC3Dint location, GC3Dfloat x);
1092     void uniform1fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1093     void uniform1i(GC3Dint location, GC3Dint x);
1094     void uniform1iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1095     void uniform2f(GC3Dint location, GC3Dfloat x, GC3Dfloat y);
1096     void uniform2fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1097     void uniform2i(GC3Dint location, GC3Dint x, GC3Dint y);
1098     void uniform2iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1099     void uniform3f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1100     void uniform3fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1101     void uniform3i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z);
1102     void uniform3iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1103     void uniform4f(GC3Dint location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1104     void uniform4fv(GC3Dint location, GC3Dsizei, const GC3Dfloat* v);
1105     void uniform4i(GC3Dint location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);
1106     void uniform4iv(GC3Dint location, GC3Dsizei, const GC3Dint* v);
1107     void uniformMatrix2fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1108     void uniformMatrix3fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1109     void uniformMatrix4fv(GC3Dint location, GC3Dsizei, GC3Dboolean transpose, const GC3Dfloat* value);
1110 
1111     void useProgram(Platform3DObject);
1112     void validateProgram(Platform3DObject);
<a name="12" id="anc12"></a>
1113     bool checkVaryingsPacking(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
1114     bool precisionsMatch(Platform3DObject vertexShader, Platform3DObject fragmentShader) const;
<a name="13" id="anc13"></a>
1115 
1116     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);
1117     void vertexAttrib1fv(GC3Duint index, const GC3Dfloat* values);
1118     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);
1119     void vertexAttrib2fv(GC3Duint index, const GC3Dfloat* values);
1120     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);
1121     void vertexAttrib3fv(GC3Duint index, const GC3Dfloat* values);
1122     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);
1123     void vertexAttrib4fv(GC3Duint index, const GC3Dfloat* values);
1124     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,
1125                              GC3Dsizei stride, GC3Dintptr offset);
1126 
1127     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);
1128 
1129     void reshape(int width, int height);
1130 
1131     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);
1132     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dintptr offset, GC3Dsizei primcount);
1133     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);
1134 
1135     // VertexArrayOject calls
1136     Platform3DObject createVertexArray();
1137     void deleteVertexArray(Platform3DObject);
1138     GC3Dboolean isVertexArray(Platform3DObject);
1139     void bindVertexArray(Platform3DObject);
1140 
1141     void paintToCanvas(const unsigned char* imagePixels, const IntSize&amp; imageSize, const IntSize&amp; canvasSize, GraphicsContext&amp;);
1142 
1143     void markContextChanged();
1144     void markLayerComposited();
1145     bool layerComposited() const;
1146     void forceContextLost();
1147     void recycleContext();
1148 
1149     void dispatchContextChangedNotification();
1150     void simulateContextChanged();
1151 
1152     void paintRenderingResultsToCanvas(ImageBuffer*);
1153     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
1154     bool paintCompositedResultsToCanvas(ImageBuffer*);
1155 
1156 #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
1157     void primitiveRestartIndex(GC3Duint);
1158 #endif
1159 
1160 #if PLATFORM(COCOA)
1161     bool texImageIOSurface2D(GC3Denum target, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, IOSurfaceRef, GC3Duint plane);
1162 
1163 #if USE(OPENGL_ES)
1164     void presentRenderbuffer();
1165 #endif
1166 
1167 #if USE(OPENGL)
1168     void allocateIOSurfaceBackingStore(IntSize);
1169     void updateFramebufferTextureBackingStoreFromLayer();
1170     void updateCGLContext();
1171 #endif
<a name="14" id="anc14"></a>




1172 #endif // PLATFORM(COCOA)
1173 
1174     void setContextVisibility(bool);
1175 
1176     GraphicsContext3DPowerPreference powerPreferenceUsedForCreation() const { return m_powerPreferenceUsedForCreation; }
1177 
1178     // Support for buffer creation and deletion
1179     Platform3DObject createBuffer();
1180     Platform3DObject createFramebuffer();
1181     Platform3DObject createProgram();
1182     Platform3DObject createRenderbuffer();
1183     Platform3DObject createShader(GC3Denum);
1184     Platform3DObject createTexture();
1185 
1186     void deleteBuffer(Platform3DObject);
1187     void deleteFramebuffer(Platform3DObject);
1188     void deleteProgram(Platform3DObject);
1189     void deleteRenderbuffer(Platform3DObject);
1190     void deleteShader(Platform3DObject);
1191     void deleteTexture(Platform3DObject);
1192 
1193     // Synthesizes an OpenGL error which will be returned from a
1194     // later call to getError. This is used to emulate OpenGL ES
1195     // 2.0 behavior on the desktop and to enforce additional error
1196     // checking mandated by WebGL.
1197     //
1198     // Per the behavior of glGetError, this stores at most one
1199     // instance of any given error, and returns them from calls to
1200     // getError in the order they were added.
1201     void synthesizeGLError(GC3Denum error);
1202 
1203     // Read real OpenGL errors, and move them to the synthetic
1204     // error list. Return true if at least one error is moved.
1205     bool moveErrorsToSyntheticErrorList();
1206 
1207     // Support for extensions. Returns a non-null object, though not
1208     // all methods it contains may necessarily be supported on the
1209     // current hardware. Must call Extensions3D::supports() to
1210     // determine this.
1211     Extensions3D&amp; getExtensions();
1212 
1213     IntSize getInternalFramebufferSize() const;
1214 
1215     static unsigned getClearBitsByAttachmentType(GC3Denum);
1216     static unsigned getClearBitsByFormat(GC3Denum);
1217 
1218     enum ChannelBits {
1219         ChannelRed = 1,
1220         ChannelGreen = 2,
1221         ChannelBlue = 4,
1222         ChannelAlpha = 8,
1223         ChannelDepth = 16,
1224         ChannelStencil = 32,
1225         ChannelRGB = ChannelRed | ChannelGreen | ChannelBlue,
1226         ChannelRGBA = ChannelRGB | ChannelAlpha,
1227     };
1228 
1229     static unsigned getChannelBitsByFormat(GC3Denum);
1230 
1231     // Possible alpha operations that may need to occur during
1232     // pixel packing. FIXME: kAlphaDoUnmultiply is lossy and must
1233     // be removed.
1234     enum AlphaOp {
1235         AlphaDoNothing = 0,
1236         AlphaDoPremultiply = 1,
1237         AlphaDoUnmultiply = 2
1238     };
1239 
1240     enum ImageHtmlDomSource {
1241         HtmlDomImage = 0,
1242         HtmlDomCanvas = 1,
1243         HtmlDomVideo = 2,
1244         HtmlDomNone = 3
1245     };
1246 
1247     // Packs the contents of the given Image which is passed in |pixels| into the passed Vector
1248     // according to the given format and type, and obeying the flipY and AlphaOp flags.
1249     // Returns true upon success.
1250     static bool packImageData(Image*, const void* pixels, GC3Denum format, GC3Denum type, bool flipY, AlphaOp, DataFormat sourceFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, Vector&lt;uint8_t&gt;&amp; data);
1251 
1252     class ImageExtractor {
1253     public:
1254         ImageExtractor(Image*, ImageHtmlDomSource, bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
1255 
1256         // Each platform must provide an implementation of this method to deallocate or release resources
1257         // associated with the image if needed.
1258         ~ImageExtractor();
1259 
1260         bool extractSucceeded() { return m_extractSucceeded; }
1261         const void* imagePixelData() { return m_imagePixelData; }
1262         unsigned imageWidth() { return m_imageWidth; }
1263         unsigned imageHeight() { return m_imageHeight; }
1264         DataFormat imageSourceFormat() { return m_imageSourceFormat; }
1265         AlphaOp imageAlphaOp() { return m_alphaOp; }
1266         unsigned imageSourceUnpackAlignment() { return m_imageSourceUnpackAlignment; }
1267         ImageHtmlDomSource imageHtmlDomSource() { return m_imageHtmlDomSource; }
1268     private:
1269         // Each platform must provide an implementation of this method.
1270         // Extracts the image and keeps track of its status, such as width, height, Source Alignment, format and AlphaOp etc,
1271         // needs to lock the resources or relevant data if needed and returns true upon success
1272         bool extractImage(bool premultiplyAlpha, bool ignoreGammaAndColorProfile);
1273 
1274 #if USE(CAIRO)
1275         RefPtr&lt;cairo_surface_t&gt; m_imageSurface;
1276 #elif USE(CG)
1277         RetainPtr&lt;CGImageRef&gt; m_cgImage;
1278         RetainPtr&lt;CGImageRef&gt; m_decodedImage;
1279         RetainPtr&lt;CFDataRef&gt; m_pixelData;
1280         UniqueArray&lt;uint8_t&gt; m_formalizedRGBA8Data;
1281 #endif
1282         Image* m_image;
1283         ImageHtmlDomSource m_imageHtmlDomSource;
1284         bool m_extractSucceeded;
1285         const void* m_imagePixelData;
1286         unsigned m_imageWidth;
1287         unsigned m_imageHeight;
1288         DataFormat m_imageSourceFormat;
1289         AlphaOp m_alphaOp;
1290         unsigned m_imageSourceUnpackAlignment;
1291     };
1292 
1293     void setFailNextGPUStatusCheck() { m_failNextStatusCheck = true; }
1294 
1295     GC3Denum activeTextureUnit() const { return m_state.activeTextureUnit; }
1296     GC3Denum currentBoundTexture() const { return m_state.currentBoundTexture(); }
1297     GC3Denum currentBoundTarget() const { return m_state.currentBoundTarget(); }
1298     unsigned textureSeed(GC3Duint texture) { return m_state.textureSeedCount.count(texture); }
1299 
1300 #if PLATFORM(MAC)
1301     using PlatformDisplayID = uint32_t;
1302     void screenDidChange(PlatformDisplayID);
1303 #endif
1304 
1305 private:
1306     GraphicsContext3D(GraphicsContext3DAttributes, HostWindow*, RenderStyle = RenderOffscreen, GraphicsContext3D* sharedContext = nullptr);
1307 
1308     // Helper for packImageData/extractImageData/extractTextureData which implement packing of pixel
1309     // data into the specified OpenGL destination format and type.
1310     // A sourceUnpackAlignment of zero indicates that the source
1311     // data is tightly packed. Non-zero values may take a slow path.
1312     // Destination data will have no gaps between rows.
1313     static bool packPixels(const uint8_t* sourceData, DataFormat sourceDataFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, unsigned destinationFormat, unsigned destinationType, AlphaOp, void* destinationData, bool flipY);
1314 
1315     // Take into account the user&#39;s requested context creation attributes,
1316     // in particular stencil and antialias, and determine which could or
1317     // could not be honored based on the capabilities of the OpenGL
1318     // implementation.
1319     void validateDepthStencil(const char* packedDepthStencilExtension);
1320     void validateAttributes();
1321 
1322     // Did the most recent drawing operation leave the GPU in an acceptable state?
1323     void checkGPUStatus();
1324 
1325     // Read rendering results into a pixel array with the same format as the
1326     // backbuffer.
1327     void readRenderingResults(unsigned char* pixels, int pixelsSize);
1328     void readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels);
1329 
1330 #if PLATFORM(IOS_FAMILY)
1331     void setRenderbufferStorageFromDrawable(GC3Dsizei width, GC3Dsizei height);
1332 #endif
1333 
1334     bool reshapeFBOs(const IntSize&amp;);
1335     void resolveMultisamplingIfNecessary(const IntRect&amp; = IntRect());
1336     void attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height);
1337 
1338 #if PLATFORM(COCOA)
1339     bool allowOfflineRenderers() const;
1340 #endif
1341 
1342     int m_currentWidth { 0 };
1343     int m_currentHeight { 0 };
1344 
1345 #if PLATFORM(COCOA)
1346     RetainPtr&lt;WebGLLayer&gt; m_webGLLayer;
1347     PlatformGraphicsContext3D m_contextObj { nullptr };
<a name="15" id="anc15"></a><span class="line-modified">1348 #endif</span>



1349 
1350 #if PLATFORM(WIN) &amp;&amp; USE(CA)
1351     RefPtr&lt;PlatformCALayer&gt; m_webGLLayer;
1352 #endif
1353 
1354     typedef HashMap&lt;String, sh::ShaderVariable&gt; ShaderSymbolMap;
1355 
1356     struct ShaderSourceEntry {
1357         GC3Denum type;
1358         String source;
1359         String translatedSource;
1360         String log;
1361         bool isValid;
1362         ShaderSymbolMap attributeMap;
1363         ShaderSymbolMap uniformMap;
1364         ShaderSymbolMap varyingMap;
1365         ShaderSourceEntry()
1366             : type(VERTEX_SHADER)
1367             , isValid(false)
1368         {
1369         }
1370 
1371         ShaderSymbolMap&amp; symbolMap(enum ANGLEShaderSymbolType symbolType)
1372         {
1373             ASSERT(symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE || symbolType == SHADER_SYMBOL_TYPE_UNIFORM || symbolType == SHADER_SYMBOL_TYPE_VARYING);
1374             if (symbolType == SHADER_SYMBOL_TYPE_ATTRIBUTE)
1375                 return attributeMap;
1376             if (symbolType == SHADER_SYMBOL_TYPE_VARYING)
1377                 return varyingMap;
1378             return uniformMap;
1379         }
1380     };
1381 
<a name="16" id="anc16"></a>
1382     // FIXME: Shaders are never removed from this map, even if they and their program are deleted.
1383     // This is bad, and it also relies on the fact we never reuse Platform3DObject numbers.
1384     typedef HashMap&lt;Platform3DObject, ShaderSourceEntry&gt; ShaderSourceMap;
1385     ShaderSourceMap m_shaderSourceMap;
1386 
1387     typedef HashMap&lt;Platform3DObject, std::pair&lt;Platform3DObject, Platform3DObject&gt;&gt; LinkedShaderMap;
1388     LinkedShaderMap m_linkedShaderMap;
1389 
1390     struct ActiveShaderSymbolCounts {
1391         Vector&lt;GC3Dint&gt; filteredToActualAttributeIndexMap;
1392         Vector&lt;GC3Dint&gt; filteredToActualUniformIndexMap;
1393 
1394         ActiveShaderSymbolCounts()
1395         {
1396         }
1397 
1398         GC3Dint countForType(GC3Denum activeType)
1399         {
1400             ASSERT(activeType == ACTIVE_ATTRIBUTES || activeType == ACTIVE_UNIFORMS);
1401             if (activeType == ACTIVE_ATTRIBUTES)
1402                 return filteredToActualAttributeIndexMap.size();
1403 
1404             return filteredToActualUniformIndexMap.size();
1405         }
1406     };
1407     typedef HashMap&lt;Platform3DObject, ActiveShaderSymbolCounts&gt; ShaderProgramSymbolCountMap;
1408     ShaderProgramSymbolCountMap m_shaderProgramSymbolCountMap;
1409 
1410     typedef HashMap&lt;String, String&gt; HashedSymbolMap;
1411     HashedSymbolMap m_possiblyUnusedAttributeMap;
1412 
1413     String mappedSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1414     String mappedSymbolName(Platform3DObject shaders[2], size_t count, const String&amp; name);
1415     String originalSymbolName(Platform3DObject program, ANGLEShaderSymbolType, const String&amp; name);
1416     Optional&lt;String&gt; mappedSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1417     Optional&lt;String&gt; originalSymbolInShaderSourceMap(Platform3DObject shader, ANGLEShaderSymbolType, const String&amp; name);
1418 
1419     std::unique_ptr&lt;ShaderNameHash&gt; nameHashMapForShaders;
<a name="17" id="anc17"></a>
1420 
1421 #if !PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
1422     friend class Extensions3DOpenGLES;
<a name="18" id="anc18"></a>
1423     std::unique_ptr&lt;Extensions3DOpenGLES&gt; m_extensions;
<a name="19" id="anc19"></a><span class="line-modified">1424 #else</span>
1425     friend class Extensions3DOpenGL;
<a name="20" id="anc20"></a>
1426     std::unique_ptr&lt;Extensions3DOpenGL&gt; m_extensions;
<a name="21" id="anc21"></a>


1427 #endif
<a name="22" id="anc22"></a><span class="line-removed">1428     friend class Extensions3DOpenGLCommon;</span>
1429 
1430     GraphicsContext3DAttributes m_attrs;
1431     GraphicsContext3DPowerPreference m_powerPreferenceUsedForCreation { GraphicsContext3DPowerPreference::Default };
1432     RenderStyle m_renderStyle;
1433     Vector&lt;Vector&lt;float&gt;&gt; m_vertexArray;
1434 
<a name="23" id="anc23"></a>
1435     ANGLEWebKitBridge m_compiler;
<a name="24" id="anc24"></a>
1436 
1437     GC3Duint m_texture { 0 };
1438     GC3Duint m_fbo { 0 };
1439 #if USE(COORDINATED_GRAPHICS)
1440     GC3Duint m_compositorTexture { 0 };
1441     GC3Duint m_intermediateTexture { 0 };
1442 #endif
1443 
1444     GC3Duint m_depthBuffer { 0 };
1445     GC3Duint m_stencilBuffer { 0 };
1446     GC3Duint m_depthStencilBuffer { 0 };
1447 
1448     bool m_layerComposited { false };
1449     GC3Duint m_internalColorFormat { 0 };
1450 
<a name="25" id="anc25"></a>



1451     struct GraphicsContext3DState {
1452         GC3Duint boundFBO { 0 };
1453         GC3Denum activeTextureUnit { GraphicsContext3D::TEXTURE0 };
1454 
1455         using BoundTextureMap = HashMap&lt;GC3Denum,
1456             std::pair&lt;GC3Duint, GC3Denum&gt;,
1457             WTF::IntHash&lt;GC3Denum&gt;,
1458             WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;,
1459             WTF::PairHashTraits&lt;WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;
1460         &gt;;
1461         BoundTextureMap boundTextureMap;
1462         GC3Duint currentBoundTexture() const { return boundTexture(activeTextureUnit); }
1463         GC3Duint boundTexture(GC3Denum textureUnit) const
1464         {
1465             auto iterator = boundTextureMap.find(textureUnit);
1466             if (iterator != boundTextureMap.end())
1467                 return iterator-&gt;value.first;
1468             return 0;
1469         }
1470 
1471         GC3Duint currentBoundTarget() const { return boundTarget(activeTextureUnit); }
1472         GC3Denum boundTarget(GC3Denum textureUnit) const
1473         {
1474             auto iterator = boundTextureMap.find(textureUnit);
1475             if (iterator != boundTextureMap.end())
1476                 return iterator-&gt;value.second;
1477             return 0;
1478         }
1479 
1480         void setBoundTexture(GC3Denum textureUnit, GC3Duint texture, GC3Denum target)
1481         {
1482             boundTextureMap.set(textureUnit, std::make_pair(texture, target));
1483         }
1484 
1485         using TextureSeedCount = HashCountedSet&lt;GC3Duint, WTF::IntHash&lt;GC3Duint&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;GC3Duint&gt;&gt;;
1486         TextureSeedCount textureSeedCount;
1487     };
1488 
1489     GraphicsContext3DState m_state;
1490 
1491     // For multisampling
1492     GC3Duint m_multisampleFBO { 0 };
1493     GC3Duint m_multisampleDepthStencilBuffer { 0 };
1494     GC3Duint m_multisampleColorBuffer { 0 };
1495 
1496     // Errors raised by synthesizeGLError().
1497     ListHashSet&lt;GC3Denum&gt; m_syntheticErrors;
1498 
1499 #if USE(NICOSIA) &amp;&amp; USE(TEXTURE_MAPPER)
1500     friend class Nicosia::GC3DLayer;
1501     std::unique_ptr&lt;Nicosia::GC3DLayer&gt; m_nicosiaLayer;
1502 #elif USE(TEXTURE_MAPPER)
1503     friend class TextureMapperGC3DPlatformLayer;
1504     std::unique_ptr&lt;TextureMapperGC3DPlatformLayer&gt; m_texmapLayer;
1505 #else
1506     friend class GraphicsContext3DPrivate;
1507     std::unique_ptr&lt;GraphicsContext3DPrivate&gt; m_private;
1508 #endif
1509 
<a name="26" id="anc26"></a><span class="line-modified">1510     // FIXME: Layering violation.</span>
<span class="line-removed">1511     WebGLRenderingContextBase* m_webglContext { nullptr };</span>
1512 
1513     bool m_isForWebGL2 { false };
1514     bool m_usingCoreProfile { false };
1515 
1516     unsigned m_statusCheckCount { 0 };
1517     bool m_failNextStatusCheck { false };
1518 
1519 #if USE(CAIRO)
1520     Platform3DObject m_vao { 0 };
1521 #endif
1522 
1523 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL)
1524     bool m_hasSwitchedToHighPerformanceGPU { false };
1525 #endif
1526 };
1527 
1528 } // namespace WebCore
<a name="27" id="anc27"></a>

<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>