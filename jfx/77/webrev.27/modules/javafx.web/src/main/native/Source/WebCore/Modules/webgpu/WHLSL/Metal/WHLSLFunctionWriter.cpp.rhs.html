<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;NotImplemented.h&quot;</span>
<span class="line-modified"> 32 #include &quot;WHLSLAST.h&quot;</span>








 33 #include &quot;WHLSLEntryPointScaffolding.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 34 #include &quot;WHLSLInferTypes.h&quot;</span>











 35 #include &quot;WHLSLNativeFunctionWriter.h&quot;
<a name="3" id="anc3"></a>

 36 #include &quot;WHLSLProgram.h&quot;
<a name="4" id="anc4"></a>



 37 #include &quot;WHLSLTypeNamer.h&quot;
<a name="5" id="anc5"></a>



 38 #include &quot;WHLSLVisitor.h&quot;
<a name="6" id="anc6"></a>
 39 #include &lt;wtf/HashMap.h&gt;
<a name="7" id="anc7"></a><span class="line-added"> 40 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 41 #include &lt;wtf/SetForScope.h&gt;</span>
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
<a name="8" id="anc8"></a><span class="line-modified"> 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-added"> 51 {</span>
<span class="line-added"> 52     if (functionDeclaration.entryPointType())</span>
<span class="line-added"> 53         return;</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55     auto iterator = functionMapping.find(&amp;functionDeclaration);</span>
<span class="line-added"> 56     ASSERT(iterator != functionMapping.end());</span>
<span class="line-added"> 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added"> 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {</span>
<span class="line-added"> 59         if (i)</span>
<span class="line-added"> 60             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added"> 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));</span>
<span class="line-added"> 62     }</span>
<span class="line-added"> 63     stringBuilder.append(&quot;);\n&quot;);</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66 class FunctionDefinitionWriter : public Visitor {</span>
 67 public:
<a name="9" id="anc9"></a><span class="line-modified"> 68     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)</span>
<span class="line-modified"> 69         : m_stringBuilder(stringBuilder)</span>
<span class="line-added"> 70         , m_intrinsics(intrinsics)</span>
<span class="line-added"> 71         , m_typeNamer(typeNamer)</span>
 72         , m_functionMapping(functionMapping)
<a name="10" id="anc10"></a><span class="line-added"> 73         , m_layout(layout)</span>
 74     {
 75     }
 76 
<a name="11" id="anc11"></a><span class="line-modified"> 77     virtual ~FunctionDefinitionWriter() = default;</span>
 78 
<a name="12" id="anc12"></a><span class="line-modified"> 79     void visit(AST::NativeFunctionDeclaration&amp;) override;</span>
<span class="line-modified"> 80     void visit(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82 protected:</span>
<span class="line-modified"> 83     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;</span>
<span class="line-added"> 84 </span>
<span class="line-added"> 85     void visit(AST::FunctionDeclaration&amp;) override;</span>
<span class="line-added"> 86     void visit(AST::Statement&amp;) override;</span>
<span class="line-added"> 87     void visit(AST::Block&amp;) override;</span>
<span class="line-added"> 88     void visit(AST::Break&amp;) override;</span>
<span class="line-added"> 89     void visit(AST::Continue&amp;) override;</span>
<span class="line-added"> 90     void visit(AST::DoWhileLoop&amp;) override;</span>
<span class="line-added"> 91     void visit(AST::EffectfulExpressionStatement&amp;) override;</span>
<span class="line-added"> 92     void visit(AST::Fallthrough&amp;) override;</span>
<span class="line-added"> 93     void visit(AST::ForLoop&amp;) override;</span>
<span class="line-added"> 94     void visit(AST::IfStatement&amp;) override;</span>
<span class="line-added"> 95     void visit(AST::Return&amp;) override;</span>
<span class="line-added"> 96     void visit(AST::SwitchStatement&amp;) override;</span>
<span class="line-added"> 97     void visit(AST::SwitchCase&amp;) override;</span>
<span class="line-added"> 98     void visit(AST::VariableDeclarationsStatement&amp;) override;</span>
<span class="line-added"> 99     void visit(AST::WhileLoop&amp;) override;</span>
<span class="line-added">100     void visit(AST::IntegerLiteral&amp;) override;</span>
<span class="line-added">101     void visit(AST::UnsignedIntegerLiteral&amp;) override;</span>
<span class="line-added">102     void visit(AST::FloatLiteral&amp;) override;</span>
<span class="line-added">103     void visit(AST::NullLiteral&amp;) override;</span>
<span class="line-added">104     void visit(AST::BooleanLiteral&amp;) override;</span>
<span class="line-added">105     void visit(AST::EnumerationMemberLiteral&amp;) override;</span>
<span class="line-added">106     void visit(AST::Expression&amp;) override;</span>
<span class="line-added">107     void visit(AST::DotExpression&amp;) override;</span>
<span class="line-added">108     void visit(AST::GlobalVariableReference&amp;) override;</span>
<span class="line-added">109     void visit(AST::IndexExpression&amp;) override;</span>
<span class="line-added">110     void visit(AST::PropertyAccessExpression&amp;) override;</span>
<span class="line-added">111     void visit(AST::VariableDeclaration&amp;) override;</span>
<span class="line-added">112     void visit(AST::AssignmentExpression&amp;) override;</span>
<span class="line-added">113     void visit(AST::CallExpression&amp;) override;</span>
<span class="line-added">114     void visit(AST::CommaExpression&amp;) override;</span>
<span class="line-added">115     void visit(AST::DereferenceExpression&amp;) override;</span>
<span class="line-added">116     void visit(AST::LogicalExpression&amp;) override;</span>
<span class="line-added">117     void visit(AST::LogicalNotExpression&amp;) override;</span>
<span class="line-added">118     void visit(AST::MakeArrayReferenceExpression&amp;) override;</span>
<span class="line-added">119     void visit(AST::MakePointerExpression&amp;) override;</span>
<span class="line-added">120     void visit(AST::ReadModifyWriteExpression&amp;) override;</span>
<span class="line-added">121     void visit(AST::TernaryExpression&amp;) override;</span>
<span class="line-added">122     void visit(AST::VariableReference&amp;) override;</span>
123 
<a name="13" id="anc13"></a><span class="line-modified">124     enum class LoopConditionLocation {</span>
<span class="line-modified">125         BeforeBody,</span>
<span class="line-modified">126         AfterBody</span>
<span class="line-modified">127     };</span>
<span class="line-modified">128     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);</span>





129 
<a name="14" id="anc14"></a><span class="line-modified">130     void emitConstantExpressionString(AST::ConstantExpression&amp;);</span>




131 
<a name="15" id="anc15"></a><span class="line-modified">132     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }</span>
<span class="line-modified">133 </span>
<span class="line-modified">134     enum class Nullability : uint8_t {</span>
<span class="line-modified">135         NotNull,</span>
<span class="line-modified">136         CanBeNull</span>
<span class="line-modified">137     };</span>
<span class="line-added">138 </span>
<span class="line-added">139     struct StackItem {</span>
<span class="line-added">140         MangledVariableName value;</span>
<span class="line-added">141         MangledVariableName leftValue;</span>
<span class="line-added">142         Nullability valueNullability;</span>
<span class="line-added">143         Nullability leftValueNullability;</span>
<span class="line-added">144         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="line-added">145     };</span>
<span class="line-added">146 </span>
<span class="line-added">147     struct StackValue {</span>
<span class="line-added">148         MangledVariableName value;</span>
<span class="line-added">149         Nullability nullability;</span>
<span class="line-added">150     };</span>
<span class="line-added">151 </span>
<span class="line-added">152     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="line-added">153     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="line-added">154     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="line-added">155     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="line-added">156     // a non-null lvalue.</span>
<span class="line-added">157     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
158     {
<a name="16" id="anc16"></a><span class="line-added">159         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
160     }
161 
<a name="17" id="anc17"></a><span class="line-modified">162     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="line-modified">163     {</span>
<span class="line-modified">164         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="line-added">165     }</span>
166 
<a name="18" id="anc18"></a><span class="line-modified">167     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
168     {
<a name="19" id="anc19"></a><span class="line-modified">169         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="line-modified">170         ASSERT(leftValue || generateLeftValue);</span>
<span class="line-modified">171         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
172     }
173 
<a name="20" id="anc20"></a><span class="line-modified">174     MangledVariableName takeLastValue()</span>
175     {
<a name="21" id="anc21"></a><span class="line-modified">176         return m_stack.takeLast().value;</span>
<span class="line-modified">177     }</span>
<span class="line-modified">178 </span>
<span class="line-modified">179     StackValue takeLastValueAndNullability()</span>
<span class="line-modified">180     {</span>
<span class="line-modified">181         auto last = m_stack.takeLast();</span>
<span class="line-modified">182         return { last.value, last.valueNullability };</span>
<span class="line-modified">183     }</span>
<span class="line-modified">184 </span>
<span class="line-modified">185     StackValue takeLastLeftValue()</span>
<span class="line-modified">186     {</span>
<span class="line-modified">187         auto last = m_stack.takeLast();</span>
<span class="line-modified">188         if (!last.leftValue)</span>
<span class="line-modified">189             last.leftValue = last.generateLeftValue();</span>
<span class="line-added">190         return { last.leftValue, last.leftValueNullability };</span>
<span class="line-added">191     }</span>
<span class="line-added">192 </span>
<span class="line-added">193     enum class BreakContext {</span>
<span class="line-added">194         Loop,</span>
<span class="line-added">195         Switch</span>
<span class="line-added">196     };</span>
<span class="line-added">197 </span>
<span class="line-added">198     Optional&lt;BreakContext&gt; m_currentBreakContext;</span>
<span class="line-added">199 </span>
<span class="line-added">200     StringBuilder&amp; m_stringBuilder;</span>
<span class="line-added">201     Intrinsics&amp; m_intrinsics;</span>
<span class="line-added">202     TypeNamer&amp; m_typeNamer;</span>
<span class="line-added">203     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;</span>
<span class="line-added">204     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;</span>
<span class="line-added">205 </span>
<span class="line-added">206     Vector&lt;StackItem&gt; m_stack;</span>
<span class="line-added">207     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;</span>
<span class="line-added">208     Layout&amp; m_layout;</span>
<span class="line-added">209     unsigned m_variableCount { 0 };</span>
<span class="line-added">210     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;</span>
<span class="line-added">211     Indentation&lt;4&gt; m_indent { 0 };</span>
<span class="line-added">212 };</span>
<span class="line-added">213 </span>
<span class="line-added">214 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)</span>
<span class="line-added">215 {</span>
<span class="line-added">216     // We inline native function calls.</span>
<span class="line-added">217 }</span>
<span class="line-added">218 </span>
<span class="line-added">219 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-added">220 {</span>
<span class="line-added">221     auto iterator = m_functionMapping.find(&amp;functionDefinition);</span>
<span class="line-added">222     ASSERT(iterator != m_functionMapping.end());</span>
<span class="line-added">223     if (functionDefinition.entryPointType()) {</span>
<span class="line-added">224         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);</span>
<span class="line-added">225         if (!entryPointScaffolding)</span>
<span class="line-added">226             return;</span>
<span class="line-added">227         m_entryPointScaffolding = WTFMove(entryPointScaffolding);</span>
<span class="line-added">228 </span>
<span class="line-added">229         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);</span>
<span class="line-added">230         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);</span>
<span class="line-added">231         m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">232         {</span>
<span class="line-added">233             IndentationScope scope(m_indent);</span>
<span class="line-added">234 </span>
<span class="line-added">235             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);</span>
<span class="line-added">236 </span>
237             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<a name="22" id="anc22"></a><span class="line-modified">238                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);</span>




239                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
<a name="23" id="anc23"></a>
240             }
<a name="24" id="anc24"></a>
241             checkErrorAndVisit(functionDefinition.block());
242             ASSERT(m_stack.isEmpty());
<a name="25" id="anc25"></a>
243         }
<a name="26" id="anc26"></a><span class="line-added">244         m_stringBuilder.append(&quot;}\n\n&quot;);</span>
<span class="line-added">245 </span>
<span class="line-added">246         m_entryPointScaffolding = nullptr;</span>
<span class="line-added">247     } else {</span>
<span class="line-added">248         ASSERT(m_entryPointScaffolding == nullptr);</span>
<span class="line-added">249         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);</span>
<span class="line-added">250         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {</span>
<span class="line-added">251             auto&amp; parameter = functionDefinition.parameters()[i];</span>
<span class="line-added">252             if (i)</span>
<span class="line-added">253                 m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">254             auto parameterName = generateNextVariableName();</span>
<span class="line-added">255             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);</span>
<span class="line-added">256             ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">257             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);</span>
<span class="line-added">258         }</span>
<span class="line-added">259         m_stringBuilder.append(&quot;)\n&quot;);</span>
<span class="line-added">260         checkErrorAndVisit(functionDefinition.block());</span>
<span class="line-added">261         ASSERT(m_stack.isEmpty());</span>
<span class="line-added">262         m_stringBuilder.append(&#39;\n&#39;);</span>
263     }
<a name="27" id="anc27"></a><span class="line-added">264 }</span>
265 
<a name="28" id="anc28"></a><span class="line-modified">266 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)</span>
<span class="line-modified">267 {</span>
<span class="line-modified">268     ASSERT_NOT_REACHED();</span>
<span class="line-modified">269 }</span>

270 
<a name="29" id="anc29"></a><span class="line-modified">271 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)</span>
<span class="line-modified">272 {</span>
<span class="line-modified">273     Visitor::visit(statement);</span>
<span class="line-modified">274 }</span>
275 
<a name="30" id="anc30"></a><span class="line-modified">276 void FunctionDefinitionWriter::visit(AST::Block&amp; block)</span>
<span class="line-added">277 {</span>
<span class="line-added">278     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
279     {
<a name="31" id="anc31"></a><span class="line-modified">280         IndentationScope scope(m_indent);</span>
281         for (auto&amp; statement : block.statements())
282             checkErrorAndVisit(statement);
<a name="32" id="anc32"></a>
283     }
<a name="33" id="anc33"></a><span class="line-added">284     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">285 }</span>
286 
<a name="34" id="anc34"></a><span class="line-modified">287 void FunctionDefinitionWriter::visit(AST::Break&amp;)</span>
<span class="line-modified">288 {</span>
<span class="line-modified">289     ASSERT(m_currentBreakContext);</span>
<span class="line-added">290     switch (*m_currentBreakContext) {</span>
<span class="line-added">291     case BreakContext::Switch:</span>
<span class="line-added">292         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-added">293         break;</span>
<span class="line-added">294     case BreakContext::Loop:</span>
<span class="line-added">295         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-added">296         m_stringBuilder.append(</span>
<span class="line-added">297             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,</span>
<span class="line-added">298             m_indent, &quot;break;\n&quot;</span>
<span class="line-added">299         );</span>
<span class="line-added">300         break;</span>
301     }
<a name="35" id="anc35"></a><span class="line-added">302 }</span>
303 
<a name="36" id="anc36"></a><span class="line-modified">304 void FunctionDefinitionWriter::visit(AST::Continue&amp;)</span>
<span class="line-modified">305 {</span>
<span class="line-modified">306     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);</span>
<span class="line-modified">307     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);</span>
<span class="line-modified">308 }</span>
309 
<a name="37" id="anc37"></a><span class="line-modified">310 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)</span>
<span class="line-modified">311 {</span>
<span class="line-modified">312     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());</span>
<span class="line-modified">313     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
<span class="line-modified">314 }</span>



315 
<a name="38" id="anc38"></a><span class="line-modified">316 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)</span>
<span class="line-modified">317 {</span>
<span class="line-modified">318     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.</span>
<span class="line-modified">319 }</span>

320 
<a name="39" id="anc39"></a><span class="line-modified">321 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)</span>
<span class="line-modified">322 {</span>
<span class="line-modified">323     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());</span>

324 
<a name="40" id="anc40"></a><span class="line-modified">325     m_stringBuilder.append(</span>
<span class="line-added">326         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,</span>
<span class="line-added">327         m_indent, &quot;while (true) {\n&quot;</span>
<span class="line-added">328     );</span>
329     {
<a name="41" id="anc41"></a><span class="line-modified">330         IndentationScope whileScope(m_indent);</span>
<span class="line-modified">331 </span>
<span class="line-modified">332         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {</span>
<span class="line-modified">333             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-modified">334             m_stringBuilder.append(</span>
<span class="line-modified">335                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">336                 m_indent, &quot;    break;\n&quot;);</span>




337         }
<a name="42" id="anc42"></a><span class="line-modified">338 </span>
<span class="line-modified">339         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);</span>
<span class="line-modified">340         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);</span>
<span class="line-modified">341 </span>
<span class="line-added">342         {</span>
<span class="line-added">343             IndentationScope doScope(m_indent);</span>
<span class="line-added">344             checkErrorAndVisit(body);</span>
<span class="line-added">345         }</span>
<span class="line-added">346         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);</span>
<span class="line-added">347 </span>
<span class="line-added">348         m_stringBuilder.append(</span>
<span class="line-added">349             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,</span>
<span class="line-added">350             m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">351 </span>
<span class="line-added">352         if (increment) {</span>
<span class="line-added">353             checkErrorAndVisit(*increment);</span>
<span class="line-added">354             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="line-added">355             // of increment, so we dispense of that now.</span>
<span class="line-added">356             takeLastValue();</span>
357         }
<a name="43" id="anc43"></a><span class="line-modified">358 </span>
<span class="line-added">359         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {</span>
<span class="line-added">360             checkErrorAndVisit(*conditionExpression);</span>
<span class="line-added">361             m_stringBuilder.append(</span>
<span class="line-added">362                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-added">363                 m_indent, &quot;    break;\n&quot;);</span>
<span class="line-added">364         }</span>
<span class="line-added">365     }</span>
<span class="line-added">366 </span>
<span class="line-added">367     m_stringBuilder.append(m_indent, &quot;} \n&quot;);</span>
<span class="line-added">368 }</span>
<span class="line-added">369 </span>
<span class="line-added">370 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)</span>
<span class="line-added">371 {</span>
<span class="line-added">372     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());</span>
<span class="line-added">373 }</span>
<span class="line-added">374 </span>
<span class="line-added">375 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)</span>
<span class="line-added">376 {</span>
<span class="line-added">377     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());</span>
<span class="line-added">378 }</span>
<span class="line-added">379 </span>
<span class="line-added">380 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)</span>
<span class="line-added">381 {</span>
<span class="line-added">382     m_stringBuilder.append(m_indent, &quot;{\n&quot;);</span>
<span class="line-added">383     {</span>
<span class="line-added">384         IndentationScope scope(m_indent);</span>
<span class="line-added">385         checkErrorAndVisit(forLoop.initialization());</span>
<span class="line-added">386         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());</span>
387     }
<a name="44" id="anc44"></a><span class="line-added">388     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">389 }</span>
390 
<a name="45" id="anc45"></a><span class="line-modified">391 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)</span>
<span class="line-added">392 {</span>
<span class="line-added">393     checkErrorAndVisit(ifStatement.conditional());</span>
<span class="line-added">394     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>
395     {
<a name="46" id="anc46"></a><span class="line-modified">396         IndentationScope ifScope(m_indent);</span>

397         checkErrorAndVisit(ifStatement.body());
<a name="47" id="anc47"></a><span class="line-modified">398     }</span>
<span class="line-modified">399     if (ifStatement.elseBody()) {</span>
<span class="line-added">400         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);</span>
<span class="line-added">401         {</span>
<span class="line-added">402             IndentationScope elseScope(m_indent);</span>
403             checkErrorAndVisit(*ifStatement.elseBody());
404         }
<a name="48" id="anc48"></a>
405     }
<a name="49" id="anc49"></a><span class="line-added">406     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">407 }</span>
408 
<a name="50" id="anc50"></a><span class="line-modified">409 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)</span>
<span class="line-modified">410 {</span>
<span class="line-modified">411     if (returnStatement.value()) {</span>
<span class="line-modified">412         checkErrorAndVisit(*returnStatement.value());</span>
<span class="line-modified">413 </span>
<span class="line-modified">414         if (m_entryPointScaffolding) {</span>
<span class="line-modified">415             auto variableName = generateNextVariableName();</span>
<span class="line-modified">416             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
<span class="line-modified">417             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);</span>

418         } else
<a name="51" id="anc51"></a><span class="line-modified">419             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-modified">420     } else</span>
<span class="line-added">421         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);</span>
<span class="line-added">422 }</span>
423 
<a name="52" id="anc52"></a><span class="line-modified">424 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)</span>
<span class="line-modified">425 {</span>
<span class="line-modified">426     checkErrorAndVisit(switchStatement.value());</span>
427 
<a name="53" id="anc53"></a><span class="line-modified">428     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
<span class="line-added">429     {</span>
<span class="line-added">430         IndentationScope switchScope(m_indent);</span>
431         for (auto&amp; switchCase : switchStatement.switchCases())
432             checkErrorAndVisit(switchCase);
<a name="54" id="anc54"></a>
433     }
<a name="55" id="anc55"></a><span class="line-added">434     m_stringBuilder.append(m_indent, &quot;}\n&quot;);</span>
<span class="line-added">435 }</span>
436 
<a name="56" id="anc56"></a><span class="line-modified">437 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)</span>
<span class="line-modified">438 {</span>
<span class="line-modified">439     if (switchCase.value()) {</span>
<span class="line-modified">440         m_stringBuilder.append(m_indent, &quot;case &quot;);</span>
<span class="line-modified">441         emitConstantExpressionString(*switchCase.value());</span>
<span class="line-modified">442         m_stringBuilder.append(&quot;:\n&quot;);</span>
<span class="line-modified">443     } else</span>
<span class="line-modified">444         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);</span>
<span class="line-modified">445     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);</span>
<span class="line-modified">446     checkErrorAndVisit(switchCase.block());</span>
<span class="line-added">447     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.</span>
<span class="line-added">448 }</span>
449 
<a name="57" id="anc57"></a><span class="line-modified">450 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)</span>
<span class="line-modified">451 {</span>
<span class="line-modified">452     Visitor::visit(variableDeclarationsStatement);</span>
<span class="line-modified">453 }</span>

454 
<a name="58" id="anc58"></a><span class="line-modified">455 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)</span>
<span class="line-modified">456 {</span>
<span class="line-modified">457     auto variableName = generateNextVariableName();</span>
<span class="line-modified">458     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());</span>
<span class="line-added">459     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-added">460     appendRightValue(integerLiteral, variableName);</span>
<span class="line-added">461 }</span>
462 
<a name="59" id="anc59"></a><span class="line-modified">463 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)</span>
<span class="line-modified">464 {</span>
<span class="line-modified">465     auto variableName = generateNextVariableName();</span>
<span class="line-modified">466     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());</span>
<span class="line-modified">467     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">468     appendRightValue(unsignedIntegerLiteral, variableName);</span>
<span class="line-modified">469 }</span>

470 
<a name="60" id="anc60"></a><span class="line-modified">471 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)</span>
<span class="line-modified">472 {</span>
<span class="line-modified">473     auto variableName = generateNextVariableName();</span>
<span class="line-modified">474     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());</span>
<span class="line-modified">475     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-modified">476     appendRightValue(floatLiteral, variableName);</span>
<span class="line-modified">477 }</span>

478 
<a name="61" id="anc61"></a><span class="line-modified">479 void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-modified">480 {</span>
<span class="line-modified">481     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="line-modified">482     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-modified">483     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-modified">484 </span>
<span class="line-modified">485     auto variableName = generateNextVariableName();</span>
<span class="line-modified">486     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="line-added">487     if (isArrayReferenceType)</span>
<span class="line-added">488         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">489     else</span>
<span class="line-added">490         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="line-added">491     appendRightValue(nullLiteral, variableName);</span>
<span class="line-added">492 }</span>
493 
<a name="62" id="anc62"></a><span class="line-modified">494 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)</span>
<span class="line-modified">495 {</span>
<span class="line-modified">496     auto variableName = generateNextVariableName();</span>
<span class="line-modified">497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());</span>
<span class="line-modified">498     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="line-modified">499     appendRightValue(booleanLiteral, variableName);</span>
<span class="line-modified">500 }</span>

501 
<a name="63" id="anc63"></a><span class="line-modified">502 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)</span>
<span class="line-modified">503 {</span>
<span class="line-modified">504     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">505     ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-modified">506     auto variableName = generateNextVariableName();</span>
<span class="line-modified">507     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());</span>
<span class="line-modified">508     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="line-modified">509     appendRightValue(enumerationMemberLiteral, variableName);</span>
<span class="line-modified">510 }</span>








511 
<a name="64" id="anc64"></a><span class="line-modified">512 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)</span>
<span class="line-modified">513 {</span>
<span class="line-modified">514     Visitor::visit(expression);</span>
<span class="line-modified">515 }</span>




516 
<a name="65" id="anc65"></a><span class="line-modified">517 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-modified">518 {</span>
<span class="line-modified">519     // This should be lowered already.</span>
<span class="line-modified">520     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">521     notImplemented();</span>
<span class="line-modified">522     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="line-modified">523 }</span>



524 
<a name="66" id="anc66"></a><span class="line-modified">525 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)</span>
<span class="line-modified">526 {</span>
<span class="line-modified">527     auto valueName = generateNextVariableName();</span>
<span class="line-modified">528     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
529 
<a name="67" id="anc67"></a><span class="line-modified">530     checkErrorAndVisit(globalVariableReference.base());</span>
<span class="line-modified">531     MangledVariableName structVariable = takeLastValue();</span>



532 
<a name="68" id="anc68"></a><span class="line-modified">533     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>




534 
<a name="69" id="anc69"></a><span class="line-modified">535     m_stringBuilder.append(</span>
<span class="line-modified">536         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>


537 
<a name="70" id="anc70"></a><span class="line-modified">538     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="line-modified">539         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="line-modified">540             auto pointerName = generateNextVariableName();</span>
<span class="line-modified">541             m_stringBuilder.append(</span>
<span class="line-modified">542                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="line-modified">543             return pointerName;</span>
<span class="line-modified">544         });</span>
<span class="line-modified">545 }</span>
<span class="line-modified">546 </span>
<span class="line-modified">547 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="line-modified">548 {</span>
<span class="line-modified">549     // This should be lowered already.</span>
<span class="line-modified">550     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">551     notImplemented();</span>
<span class="line-modified">552     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="line-added">553 }</span>
<span class="line-added">554 </span>
<span class="line-added">555 void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-added">556 {</span>
<span class="line-added">557     // This should be lowered already.</span>
<span class="line-added">558     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-added">559     notImplemented();</span>
<span class="line-added">560     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>
<span class="line-added">561 }</span>
<span class="line-added">562 </span>
<span class="line-added">563 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)</span>
<span class="line-added">564 {</span>
<span class="line-added">565     ASSERT(variableDeclaration.type());</span>
<span class="line-added">566     auto variableName = generateNextVariableName();</span>
<span class="line-added">567     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);</span>
<span class="line-added">568     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">569     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.</span>
<span class="line-added">570     if (variableDeclaration.initializer()) {</span>
<span class="line-added">571         checkErrorAndVisit(*variableDeclaration.initializer());</span>
<span class="line-added">572         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
<span class="line-added">573     } else</span>
<span class="line-added">574         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
<span class="line-added">577 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)</span>
<span class="line-added">578 {</span>
<span class="line-added">579     checkErrorAndVisit(assignmentExpression.left());</span>
<span class="line-added">580     auto [pointerName, nullability] = takeLastLeftValue();</span>
<span class="line-added">581     checkErrorAndVisit(assignmentExpression.right());</span>
<span class="line-added">582     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="line-added">583 </span>
<span class="line-added">584     if (nullability == Nullability::CanBeNull)</span>
<span class="line-added">585         m_stringBuilder.append(</span>
<span class="line-added">586             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="line-added">587             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">588     else</span>
<span class="line-added">589         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-added">590     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
<span class="line-added">591 }</span>
<span class="line-added">592 </span>
<span class="line-added">593 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)</span>
<span class="line-added">594 {</span>
<span class="line-added">595     Vector&lt;MangledVariableName&gt; argumentNames;</span>
<span class="line-added">596     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-added">597         checkErrorAndVisit(argument);</span>
<span class="line-added">598         argumentNames.append(takeLastValue());</span>
599     }
600 
<a name="71" id="anc71"></a><span class="line-modified">601     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="line-modified">602     MangledVariableName returnName;</span>
<span class="line-modified">603     if (!isVoid) {</span>
<span class="line-modified">604         returnName = generateNextVariableName();</span>
<span class="line-modified">605         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>


606     }
607 
<a name="72" id="anc72"></a><span class="line-modified">608     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {</span>
<span class="line-modified">609         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">610             return this-&gt;generateNextVariableName();</span>
<span class="line-modified">611         };</span>
<span class="line-modified">612 </span>
<span class="line-modified">613         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">614         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="line-modified">615         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-modified">616     } else {</span>
<span class="line-modified">617         m_stringBuilder.append(m_indent);</span>
<span class="line-added">618 </span>
<span class="line-added">619         auto iterator = m_functionMapping.find(&amp;callExpression.function());</span>
620         ASSERT(iterator != m_functionMapping.end());
<a name="73" id="anc73"></a><span class="line-modified">621         if (!isVoid)</span>
<span class="line-modified">622             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
<span class="line-added">623         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);</span>
624         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {
625             if (i)
626                 m_stringBuilder.append(&quot;, &quot;);
627             m_stringBuilder.append(argumentNames[i]);
628         }
629         m_stringBuilder.append(&quot;);\n&quot;);
<a name="74" id="anc74"></a>
630     }
631 
<a name="75" id="anc75"></a><span class="line-modified">632     appendRightValue(callExpression, returnName);</span>
<span class="line-modified">633 }</span>







634 
<a name="76" id="anc76"></a><span class="line-modified">635 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)</span>
<span class="line-modified">636 {</span>
<span class="line-modified">637     Optional&lt;MangledVariableName&gt; result;</span>
<span class="line-modified">638     for (auto&amp; expression : commaExpression.list()) {</span>
<span class="line-modified">639         checkErrorAndVisit(expression);</span>
<span class="line-modified">640         result = takeLastValue();</span>


641     }
<a name="77" id="anc77"></a><span class="line-added">642     ASSERT(result);</span>
<span class="line-added">643     appendRightValue(commaExpression, *result);</span>
<span class="line-added">644 }</span>
645 
<a name="78" id="anc78"></a><span class="line-modified">646 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)</span>
<span class="line-modified">647 {</span>
<span class="line-modified">648     checkErrorAndVisit(dereferenceExpression.pointer());</span>
<span class="line-modified">649     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="line-modified">650     auto resultValue = generateNextVariableName();</span>
<span class="line-modified">651     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="line-modified">652 </span>
<span class="line-modified">653     if (nullability == Nullability::CanBeNull) {</span>
<span class="line-modified">654         m_stringBuilder.append(</span>
<span class="line-modified">655             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="line-modified">656     } else</span>
<span class="line-modified">657         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="line-modified">658 </span>
<span class="line-modified">659     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
<span class="line-modified">660 }</span>
<span class="line-modified">661 </span>
<span class="line-modified">662 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)</span>
<span class="line-added">663 {</span>
<span class="line-added">664     checkErrorAndVisit(logicalExpression.left());</span>
<span class="line-added">665     auto left = takeLastValue();</span>
<span class="line-added">666     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-added">667     auto right = takeLastValue();</span>
<span class="line-added">668     auto variableName = generateNextVariableName();</span>
<span class="line-added">669 </span>
<span class="line-added">670     m_stringBuilder.append(</span>
<span class="line-added">671         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
<span class="line-added">672     switch (logicalExpression.type()) {</span>
<span class="line-added">673     case AST::LogicalExpression::Type::And:</span>
<span class="line-added">674         m_stringBuilder.append(&quot; &amp;&amp; &quot;);</span>
<span class="line-added">675         break;</span>
<span class="line-added">676     default:</span>
<span class="line-added">677         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
<span class="line-added">678         m_stringBuilder.append(&quot; || &quot;);</span>
<span class="line-added">679         break;</span>
<span class="line-added">680     }</span>
<span class="line-added">681     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="line-added">682     appendRightValue(logicalExpression, variableName);</span>
<span class="line-added">683 }</span>
<span class="line-added">684 </span>
<span class="line-added">685 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)</span>
<span class="line-added">686 {</span>
<span class="line-added">687     checkErrorAndVisit(logicalNotExpression.operand());</span>
<span class="line-added">688     auto operand = takeLastValue();</span>
<span class="line-added">689     auto variableName = generateNextVariableName();</span>
<span class="line-added">690 </span>
<span class="line-added">691     m_stringBuilder.append(</span>
<span class="line-added">692         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="line-added">693     appendRightValue(logicalNotExpression, variableName);</span>
<span class="line-added">694 }</span>
<span class="line-added">695 </span>
<span class="line-added">696 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)</span>
<span class="line-added">697 {</span>
<span class="line-added">698     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">699     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.</span>
<span class="line-added">700     // https://bugs.webkit.org/show_bug.cgi?id=198838</span>
<span class="line-added">701     auto variableName = generateNextVariableName();</span>
<span class="line-added">702 </span>
<span class="line-added">703     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());</span>
<span class="line-added">704     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">705         auto ptrValue = takeLastValue();</span>
<span class="line-added">706         m_stringBuilder.append(</span>
<span class="line-added">707             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-added">708     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {</span>
<span class="line-added">709         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">710         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());</span>
<span class="line-added">711         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>
<span class="line-added">712     } else {</span>
<span class="line-added">713         auto lValue = takeLastLeftValue().value;</span>
<span class="line-added">714         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>
<span class="line-added">715     }</span>
<span class="line-added">716     appendRightValue(makeArrayReferenceExpression, variableName);</span>
<span class="line-added">717 }</span>
<span class="line-added">718 </span>
<span class="line-added">719 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)</span>
<span class="line-added">720 {</span>
<span class="line-added">721     checkErrorAndVisit(makePointerExpression.leftValue());</span>
<span class="line-added">722     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="line-added">723     auto variableName = generateNextVariableName();</span>
<span class="line-added">724     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="line-added">725     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
<span class="line-added">726 }</span>
<span class="line-added">727 </span>
<span class="line-added">728 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
<span class="line-added">729 {</span>
<span class="line-added">730     // This should be lowered already.</span>
<span class="line-added">731     ASSERT_NOT_REACHED();</span>
<span class="line-added">732 }</span>
<span class="line-added">733 </span>
<span class="line-added">734 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)</span>
<span class="line-added">735 {</span>
<span class="line-added">736     checkErrorAndVisit(ternaryExpression.predicate());</span>
<span class="line-added">737     auto check = takeLastValue();</span>
<span class="line-added">738     checkErrorAndVisit(ternaryExpression.bodyExpression());</span>
<span class="line-added">739     auto body = takeLastValue();</span>
<span class="line-added">740     checkErrorAndVisit(ternaryExpression.elseExpression());</span>
<span class="line-added">741     auto elseBody = takeLastValue();</span>
<span class="line-added">742 </span>
<span class="line-added">743     auto variableName = generateNextVariableName();</span>
<span class="line-added">744     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="line-added">745     appendRightValue(ternaryExpression, variableName);</span>
<span class="line-added">746 }</span>
<span class="line-added">747 </span>
<span class="line-added">748 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)</span>
<span class="line-added">749 {</span>
<span class="line-added">750     ASSERT(variableReference.variable());</span>
<span class="line-added">751     auto iterator = m_variableMapping.find(variableReference.variable());</span>
<span class="line-added">752     ASSERT(iterator != m_variableMapping.end());</span>
<span class="line-added">753 </span>
<span class="line-added">754     MangledVariableName variableName = iterator-&gt;value;</span>
<span class="line-added">755 </span>
<span class="line-added">756     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="line-added">757         [this, &amp;variableReference, variableName] {</span>
<span class="line-added">758             auto pointerName = generateNextVariableName();</span>
<span class="line-added">759             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-added">760             return pointerName;</span>
<span class="line-added">761         });</span>
<span class="line-added">762 }</span>
<span class="line-added">763 </span>
<span class="line-added">764 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)</span>
<span class="line-added">765 {</span>
<span class="line-added">766     constantExpression.visit(WTF::makeVisitor(</span>
<span class="line-added">767         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {</span>
<span class="line-added">768             m_stringBuilder.append(integerLiteral.value());</span>
<span class="line-added">769         },</span>
<span class="line-added">770         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {</span>
<span class="line-added">771             m_stringBuilder.append(unsignedIntegerLiteral.value());</span>
<span class="line-added">772         },</span>
<span class="line-added">773         [&amp;](AST::FloatLiteral&amp; floatLiteral) {</span>
<span class="line-added">774             m_stringBuilder.append(floatLiteral.value());</span>
<span class="line-added">775         },</span>
<span class="line-added">776         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-added">777             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-added">778         },</span>
<span class="line-added">779         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {</span>
<span class="line-added">780             if (booleanLiteral.value())</span>
<span class="line-added">781                 m_stringBuilder.append(&quot;true&quot;);</span>
<span class="line-added">782             else</span>
<span class="line-added">783                 m_stringBuilder.append(&quot;false&quot;);</span>
<span class="line-added">784         },</span>
<span class="line-added">785         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {</span>
<span class="line-added">786             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">787             ASSERT(enumerationMemberLiteral.enumerationDefinition());</span>
<span class="line-added">788             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>
789         }
<a name="79" id="anc79"></a><span class="line-modified">790     ));</span>
<span class="line-modified">791 }</span>

792 
<a name="80" id="anc80"></a><span class="line-modified">793 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">794 public:</span>
<span class="line-added">795     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">796         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">797         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
798     {
<a name="81" id="anc81"></a>





799     }
800 
<a name="82" id="anc82"></a><span class="line-modified">801 private:</span>
<span class="line-modified">802     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>














803 
<a name="83" id="anc83"></a><span class="line-modified">804     MatchedRenderSemantics m_matchedSemantics;</span>
<span class="line-modified">805 };</span>
<span class="line-modified">806 </span>
<span class="line-modified">807 std::unique_ptr&lt;EntryPointScaffolding&gt; RenderFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">808 {</span>
<span class="line-modified">809     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">810         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">811     };</span>
<span class="line-modified">812     if (&amp;functionDefinition == m_matchedSemantics.vertexShader)</span>
<span class="line-added">813         return makeUnique&lt;VertexEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.vertexShaderEntryPointItems, m_matchedSemantics.vertexShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedVertexAttributes);</span>
<span class="line-added">814     if (&amp;functionDefinition == m_matchedSemantics.fragmentShader)</span>
<span class="line-added">815         return makeUnique&lt;FragmentEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.fragmentShaderEntryPointItems, m_matchedSemantics.fragmentShaderResourceMap, m_layout, WTFMove(generateNextVariableName), m_matchedSemantics.matchedColorAttachments);</span>
<span class="line-added">816     return nullptr;</span>
<span class="line-added">817 }</span>
818 
<a name="84" id="anc84"></a><span class="line-modified">819 class ComputeFunctionDefinitionWriter final : public FunctionDefinitionWriter {</span>
<span class="line-added">820 public:</span>
<span class="line-added">821     ComputeFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">822         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)</span>
<span class="line-added">823         , m_matchedSemantics(WTFMove(matchedSemantics))</span>
824     {
<a name="85" id="anc85"></a>

825     }
826 
<a name="86" id="anc86"></a><span class="line-modified">827 private:</span>
<span class="line-modified">828     std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) override;</span>
<span class="line-modified">829 </span>
<span class="line-modified">830     MatchedComputeSemantics m_matchedSemantics;</span>
<span class="line-modified">831 };</span>
<span class="line-modified">832 </span>
<span class="line-modified">833 std::unique_ptr&lt;EntryPointScaffolding&gt; ComputeFunctionDefinitionWriter::createEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition)</span>
<span class="line-modified">834 {</span>
<span class="line-modified">835     auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-modified">836         return this-&gt;generateNextVariableName();</span>
<span class="line-modified">837     };</span>
<span class="line-modified">838     if (&amp;functionDefinition == m_matchedSemantics.shader)</span>
<span class="line-modified">839         return makeUnique&lt;ComputeEntryPointScaffolding&gt;(functionDefinition, m_intrinsics, m_typeNamer, m_matchedSemantics.entryPointItems, m_matchedSemantics.resourceMap, m_layout, WTFMove(generateNextVariableName));</span>
<span class="line-modified">840     return nullptr;</span>
<span class="line-modified">841 }</span>
<span class="line-modified">842 </span>
<span class="line-modified">843 static HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; generateMetalFunctionsMapping(Program&amp; program)</span>
<span class="line-added">844 {</span>
<span class="line-added">845     unsigned numFunctions = 0;</span>
<span class="line-added">846     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt; functionMapping;</span>
<span class="line-added">847     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">848         auto addResult = functionMapping.add(&amp;functionDefinition, MangledFunctionName { numFunctions++ });</span>
<span class="line-added">849         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
850     }
851 
<a name="87" id="anc87"></a><span class="line-modified">852     return functionMapping;</span>
<span class="line-modified">853 }</span>
<span class="line-modified">854 </span>
<span class="line-modified">855 static void emitSharedMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, const HashSet&lt;AST::FunctionDeclaration*&gt;&amp; reachableFunctions, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)</span>
<span class="line-modified">856 {</span>
<span class="line-modified">857     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">858         if (!functionDefinition-&gt;entryPointType() &amp;&amp; reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-added">859             declareFunction(stringBuilder, functionDefinition, typeNamer, functionMapping);</span>
860     }
861 
<a name="88" id="anc88"></a><span class="line-modified">862     stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-added">863 }</span>
<span class="line-added">864 </span>
<span class="line-added">865 class ReachableFunctionsGatherer final : public Visitor {</span>
<span class="line-added">866 public:</span>
<span class="line-added">867     void visit(AST::FunctionDeclaration&amp; functionDeclaration) override</span>
868     {
<a name="89" id="anc89"></a><span class="line-modified">869         auto result = m_reachableFunctions.add(&amp;functionDeclaration);</span>
<span class="line-modified">870         if (result.isNewEntry)</span>
<span class="line-modified">871             Visitor::visit(functionDeclaration);</span>














872     }
873 
<a name="90" id="anc90"></a><span class="line-modified">874     void visit(AST::CallExpression&amp; callExpression) override</span>
875     {
<a name="91" id="anc91"></a><span class="line-modified">876         Visitor::visit(callExpression);</span>
<span class="line-added">877         if (is&lt;AST::FunctionDefinition&gt;(callExpression.function()))</span>
<span class="line-added">878             checkErrorAndVisit(downcast&lt;AST::FunctionDefinition&gt;(callExpression.function()));</span>
<span class="line-added">879         else</span>
<span class="line-added">880             checkErrorAndVisit(downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()));</span>
881     }
882 
<a name="92" id="anc92"></a><span class="line-added">883     HashSet&lt;AST::FunctionDeclaration*&gt; takeReachableFunctions() { return WTFMove(m_reachableFunctions); }</span>
<span class="line-added">884 </span>
885 private:
<a name="93" id="anc93"></a><span class="line-modified">886     HashSet&lt;AST::FunctionDeclaration*&gt; m_reachableFunctions;</span>







887 };
888 
<a name="94" id="anc94"></a><span class="line-modified">889 RenderMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
890 {
<a name="95" id="anc95"></a><span class="line-modified">891     auto&amp; vertexShaderEntryPoint = *matchedSemantics.vertexShader;</span>
<span class="line-added">892     auto* fragmentShaderEntryPoint = matchedSemantics.fragmentShader;</span>
893 
<a name="96" id="anc96"></a><span class="line-modified">894     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">895     reachableFunctionsGatherer.Visitor::visit(vertexShaderEntryPoint);</span>
<span class="line-modified">896     if (fragmentShaderEntryPoint)</span>
<span class="line-modified">897         reachableFunctionsGatherer.Visitor::visit(*fragmentShaderEntryPoint);</span>
<span class="line-modified">898     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">899 </span>
<span class="line-added">900     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">901 </span>
<span class="line-added">902     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">903 </span>
<span class="line-added">904     RenderFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
905     for (auto&amp; functionDefinition : program.functionDefinitions()) {
<a name="97" id="anc97"></a><span class="line-modified">906         if (reachableFunctions.contains(&amp;functionDefinition))</span>
<span class="line-modified">907             functionDefinitionWriter.visit(functionDefinition);</span>
908     }
909 
<a name="98" id="anc98"></a><span class="line-modified">910     return { functionMapping.get(&amp;vertexShaderEntryPoint), fragmentShaderEntryPoint ? functionMapping.get(fragmentShaderEntryPoint) : MangledFunctionName { 0 } };</span>
<span class="line-modified">911 }</span>








912 
<a name="99" id="anc99"></a><span class="line-modified">913 ComputeMetalFunctionEntryPoints emitMetalFunctions(StringBuilder&amp; stringBuilder, Program&amp; program, TypeNamer&amp; typeNamer, MatchedComputeSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)</span>
<span class="line-added">914 {</span>
<span class="line-added">915     auto&amp; entryPoint = *matchedSemantics.shader;</span>
916 
<a name="100" id="anc100"></a><span class="line-modified">917     ReachableFunctionsGatherer reachableFunctionsGatherer;</span>
<span class="line-modified">918     reachableFunctionsGatherer.Visitor::visit(entryPoint);</span>
<span class="line-modified">919     auto reachableFunctions = reachableFunctionsGatherer.takeReachableFunctions();</span>
<span class="line-modified">920 </span>
<span class="line-modified">921     auto functionMapping = generateMetalFunctionsMapping(program);</span>
<span class="line-added">922     emitSharedMetalFunctions(stringBuilder, program, typeNamer, reachableFunctions, functionMapping);</span>
<span class="line-added">923 </span>
<span class="line-added">924     ComputeFunctionDefinitionWriter functionDefinitionWriter(stringBuilder, program.intrinsics(), typeNamer, functionMapping, WTFMove(matchedSemantics), layout);</span>
<span class="line-added">925     for (auto&amp; functionDefinition : program.functionDefinitions()) {</span>
<span class="line-added">926         if (reachableFunctions.contains(&amp;functionDefinition))</span>
927             functionDefinitionWriter.visit(functionDefinition);
<a name="101" id="anc101"></a>
928     }
929 
<a name="102" id="anc102"></a><span class="line-modified">930     return { functionMapping.get(&amp;entryPoint) };</span>
931 }
932 
933 } // namespace Metal
934 
935 } // namespace WHLSL
936 
937 } // namespace WebCore
938 
939 #endif
<a name="103" id="anc103"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="103" type="hidden" />
</body>
</html>