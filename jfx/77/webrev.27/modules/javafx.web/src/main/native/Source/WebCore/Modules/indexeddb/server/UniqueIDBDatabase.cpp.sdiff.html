<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteIDBTransaction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;SerializedScriptValue.h&quot;

  44 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  45 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">  46 #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
  47 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="line-removed">  48 #include &lt;JavaScriptCore/StructureInlines.h&gt;</span>
  49 #include &lt;wtf/MainThread.h&gt;
  50 #include &lt;wtf/NeverDestroyed.h&gt;
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 



















































  57 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
  58     : m_server(server)
  59     , m_identifier(identifier)
  60     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
  61 {
  62     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
  63 }
  64 
  65 UniqueIDBDatabase::~UniqueIDBDatabase()
  66 {
  67     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
  68     ASSERT(isMainThread());
  69     ASSERT(!hasAnyPendingCallbacks());
  70     ASSERT(!hasUnfinishedTransactions());
  71     ASSERT(m_pendingTransactions.isEmpty());
  72     ASSERT(m_openDatabaseConnections.isEmpty());
  73     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());
  74     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());
  75 
  76     RELEASE_ASSERT(m_databaseQueue.isKilled());
</pre>
<hr />
<pre>
 101 
 102 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const
 103 {
 104     return !m_errorCallbacks.isEmpty()
 105         || !m_keyDataCallbacks.isEmpty()
 106         || !m_getResultCallbacks.isEmpty()
 107         || !m_getAllResultsCallbacks.isEmpty()
 108         || !m_countCallbacks.isEmpty();
 109 }
 110 
 111 bool UniqueIDBDatabase::isVersionChangeInProgress()
 112 {
 113 #if !LOG_DISABLED
 114     if (m_versionChangeTransaction)
 115         ASSERT(m_versionChangeDatabaseConnection);
 116 #endif
 117 
 118     return m_versionChangeDatabaseConnection;
 119 }
 120 


































 121 void UniqueIDBDatabase::performCurrentOpenOperation()
 122 {
 123     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 124 
 125     ASSERT(m_currentOpenDBRequest);
 126     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 127 
 128     if (!m_databaseInfo) {
 129         if (!m_isOpeningBackingStore) {
 130             m_isOpeningBackingStore = true;
<span class="line-modified"> 131             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>




















 132         }
<span class="line-removed"> 133 </span>
 134         return;
 135     }
 136 
 137     // If we previously started a version change operation but were blocked by having open connections,
 138     // we might now be unblocked.
 139     if (m_versionChangeDatabaseConnection) {
 140         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 141             startVersionChangeTransaction();
 142         return;
 143     }
 144 
 145     // 3.3.1 Opening a database
 146     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 147     // or the current version of db otherwise.
 148     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 149     if (!requestedVersion)
 150         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 151 
 152     // 3.3.1 Opening a database
 153     // If the database version higher than the requested version, abort these steps and return a VersionError.
</pre>
<hr />
<pre>
 223 
 224     if (!m_deleteBackingStoreInProgress) {
 225         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 226             didDeleteBackingStore(0);
 227         else {
 228             m_deleteBackingStoreInProgress = true;
 229             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));
 230         }
 231     }
 232 }
 233 
 234 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 235 {
 236     ASSERT(!isMainThread());
 237     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);
 238 
 239     uint64_t deletedVersion = 0;
 240 
 241     if (m_backingStore) {
 242         m_backingStore-&gt;deleteBackingStore();


 243         m_backingStore = nullptr;
 244         m_backingStoreSupportsSimultaneousTransactions = false;
 245         m_backingStoreIsEphemeral = false;
 246     } else {
<span class="line-modified"> 247         auto backingStore = m_server.createBackingStore(identifier);</span>

 248 
 249         IDBDatabaseInfo databaseInfo;
 250         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 251         if (!error.isNull())
 252             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
 253 
 254         deletedVersion = databaseInfo.version();
 255         backingStore-&gt;deleteBackingStore();

 256     }
 257 
 258     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 259 }
 260 
 261 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()
 262 {
 263     ASSERT(!isMainThread());
 264     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);
 265 
 266     if (m_backingStore)
 267         m_backingStore-&gt;deleteBackingStore();
 268 
 269     shutdownForClose();
 270 }
 271 
 272 void UniqueIDBDatabase::scheduleShutdownForClose()
 273 {
 274     ASSERT(isMainThread());
 275 
 276     m_operationAndTransactionTimer.stop();
 277 
 278     RELEASE_ASSERT(!m_owningPointerForClose);
<span class="line-modified"> 279     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
 280 
 281     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 282 }
 283 
 284 void UniqueIDBDatabase::shutdownForClose()
 285 {
 286     ASSERT(!isMainThread());
 287     ASSERT(m_owningPointerForClose.get() == this);
 288 
 289     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
 290 





 291     m_backingStore = nullptr;
 292     m_backingStoreSupportsSimultaneousTransactions = false;
 293     m_backingStoreIsEphemeral = false;
 294 
 295     if (!m_databaseQueue.isEmpty()) {
 296         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 297         return;
 298     }
 299     m_databaseQueue.kill();
 300 
 301     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));
 302 }
 303 
 304 void UniqueIDBDatabase::didShutdownForClose()
 305 {
 306     ASSERT(m_databaseReplyQueue.isEmpty());
 307     m_databaseReplyQueue.kill();


 308 }
 309 
 310 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 311 {
 312     ASSERT(isMainThread());
 313     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);
 314 
 315     ASSERT(!hasAnyPendingCallbacks());
 316     ASSERT(!hasUnfinishedTransactions());
 317     ASSERT(m_pendingTransactions.isEmpty());
 318     ASSERT(m_openDatabaseConnections.isEmpty());
 319     ASSERT(!m_backingStore);
 320 
 321     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.
 322     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.
 323     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());
 324 
 325     if (m_databaseInfo)
 326         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 327 
 328     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 329     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 330     // passed in deletedVersion argument.
 331     if (!m_mostRecentDeletedDatabaseInfo)
<span class="line-modified"> 332         m_mostRecentDeletedDatabaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
 333 
 334     if (m_currentOpenDBRequest) {
 335         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 336         m_currentOpenDBRequest = nullptr;
 337     }
 338 


 339     m_deleteBackingStoreInProgress = false;
 340 
 341     if (m_hardClosedForUserDelete)
 342         return;
 343 
 344     invokeOperationAndTransactionTimer();
 345 }
 346 
 347 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 348 {
 349     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 350         m_pendingOpenDBRequests.removeFirst();
 351 }
 352 
 353 void UniqueIDBDatabase::handleDatabaseOperations()
 354 {
 355     ASSERT(isMainThread());
 356     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 357     ASSERT(!m_hardClosedForUserDelete);
 358 
<span class="line-modified"> 359     if (m_deleteBackingStoreInProgress)</span>
 360         return;
 361 
 362     clearStalePendingOpenDBRequests();
 363 
 364     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
 365         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 366         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
 367             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 368 
 369         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle
 370         if (m_currentOpenDBRequest)
 371             handleCurrentOperation();
 372 
 373         return;
 374     }
 375 
 376     if (m_pendingOpenDBRequests.isEmpty()) {
 377         m_currentOpenDBRequest = nullptr;
 378         return;
 379     }
</pre>
<hr />
<pre>
 406     return !m_openDatabaseConnections.isEmpty();
 407 }
 408 
 409 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 410 {
 411     for (auto&amp; connection : m_openDatabaseConnections) {
 412         if (!connection-&gt;connectionIsClosing())
 413             return false;
 414     }
 415 
 416     return true;
 417 }
 418 
 419 static uint64_t generateUniqueCallbackIdentifier()
 420 {
 421     ASSERT(isMainThread());
 422     static uint64_t currentID = 0;
 423     return ++currentID;
 424 }
 425 
<span class="line-modified"> 426 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback)</span>
 427 {
 428     if (m_hardClosedForUserDelete) {
 429         callback(IDBError::userDeleteError());
 430         return 0;
 431     }
 432 
 433     uint64_t identifier = generateUniqueCallbackIdentifier();
 434     ASSERT(!m_errorCallbacks.contains(identifier));
 435     m_errorCallbacks.add(identifier, WTFMove(callback));






 436     m_callbackQueue.append(identifier);
 437     return identifier;
 438 }
 439 
<span class="line-modified"> 440 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback)</span>
 441 {
 442     if (m_hardClosedForUserDelete) {
 443         callback(IDBError::userDeleteError(), { });
 444         return 0;
 445     }
 446 
 447     uint64_t identifier = generateUniqueCallbackIdentifier();
 448     ASSERT(!m_keyDataCallbacks.contains(identifier));
 449     m_keyDataCallbacks.add(identifier, WTFMove(callback));






 450     m_callbackQueue.append(identifier);
 451     return identifier;
 452 }
 453 
 454 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
 455 {
 456     if (m_hardClosedForUserDelete) {
 457         callback(IDBError::userDeleteError(), { });
 458         return 0;
 459     }
 460 
 461     uint64_t identifier = generateUniqueCallbackIdentifier();
 462     ASSERT(!m_getResultCallbacks.contains(identifier));
 463     m_getResultCallbacks.add(identifier, WTFMove(callback));
 464     m_callbackQueue.append(identifier);
 465     return identifier;
 466 }
 467 
 468 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)
 469 {
</pre>
<hr />
<pre>
 494 }
 495 
 496 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 497 {
 498     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);
 499     ASSERT(!m_hardClosedForUserDelete);
 500 
 501     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 502     handleDatabaseOperations();
 503 }
 504 
 505 void UniqueIDBDatabase::startVersionChangeTransaction()
 506 {
 507     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 508 
 509     ASSERT(!m_versionChangeTransaction);
 510     ASSERT(m_currentOpenDBRequest);
 511     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 512     ASSERT(m_versionChangeDatabaseConnection);
 513 
<span class="line-modified"> 514     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516     uint64_t requestedVersion = operation-&gt;requestData().requestedVersion();</span>
 517     if (!requestedVersion)
 518         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 519 
<span class="line-removed"> 520     addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="line-removed"> 521 </span>
 522     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<span class="line-removed"> 523     m_databaseInfo-&gt;setVersion(requestedVersion);</span>
<span class="line-removed"> 524 </span>
 525     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);
<span class="line-removed"> 526     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::beginTransactionInBackingStore, m_versionChangeTransaction-&gt;info()));</span>
 527 
<span class="line-modified"> 528     auto result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="line-removed"> 529     operation-&gt;connection().didOpenDatabase(result);</span>
 530 }
 531 
<span class="line-modified"> 532 void UniqueIDBDatabase::beginTransactionInBackingStore(const IDBTransactionInfo&amp; info)</span>
 533 {
<span class="line-modified"> 534     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::beginTransactionInBackingStore&quot;);</span>
<span class="line-modified"> 535     m_backingStore-&gt;beginTransaction(info);</span>





























 536 }
 537 
 538 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 539 {
 540     ASSERT(m_currentOpenDBRequest);
 541 
 542     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 543         return;
 544 
 545     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 546     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 547 
 548     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 549 
 550     // 3.3.7 &quot;versionchange&quot; transaction steps
 551     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 552     // The event must not be fired on connections which has the closePending flag set.
 553     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 554     for (const auto&amp; connection : m_openDatabaseConnections) {
 555         if (connection-&gt;closePending())
</pre>
<hr />
<pre>
 615     for (auto&amp; request : m_pendingOpenDBRequests) {
 616         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 617             m_pendingOpenDBRequests.remove(request);
 618             return;
 619         }
 620     }
 621 }
 622 
 623 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 624 {
 625     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 626     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 627 }
 628 
 629 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 630 {
 631     ASSERT(!isMainThread());
 632     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
 633 
 634     ASSERT(!m_backingStore);
<span class="line-modified"> 635     m_backingStore = m_server.createBackingStore(identifier);</span>
 636     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
 637     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
 638 




 639     IDBDatabaseInfo databaseInfo;
 640     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 641 
 642     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 643 }
 644 
 645 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
 646 {
 647     ASSERT(isMainThread());
 648     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
 649 
<span class="line-modified"> 650     m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(info);</span>
 651     m_backingStoreOpenError = error;
 652 
 653     ASSERT(m_isOpeningBackingStore);
 654     m_isOpeningBackingStore = false;
 655 


 656     if (m_hardClosedForUserDelete)
 657         return;
 658 
 659     handleDatabaseOperations();
 660 }
 661 
 662 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 663 {
 664     ASSERT(isMainThread());
 665     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
 666 
<span class="line-modified"> 667     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 668     if (!callbackID)
 669         return;
 670 
 671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 672 }
 673 
 674 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 675 {
 676     ASSERT(!isMainThread());
 677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);
 678 
 679     ASSERT(m_backingStore);
 680     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);
 681 
 682     IDBError error;
 683     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));
 684 }
 685 
 686 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)
 687 {
 688     ASSERT(isMainThread());
 689     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);
 690 
 691     if (error.isNull())
 692         m_databaseInfo-&gt;addExistingObjectStore(info);
 693 
 694     performErrorCallback(callbackIdentifier, error);
 695 }
 696 
 697 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 698 {
 699     ASSERT(isMainThread());
 700     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
 701 















 702     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 703     if (!callbackID)
 704         return;
 705 
 706     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 707     if (!info) {
 708         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 709         return;
 710     }
 711 
 712     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));
 713 }
 714 
 715 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 716 {
 717     ASSERT(!isMainThread());
 718     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);
 719 
 720     ASSERT(m_backingStore);
 721     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);
</pre>
<hr />
<pre>
 723     IDBError error;
 724     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));
 725 }
 726 
 727 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)
 728 {
 729     ASSERT(isMainThread());
 730     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);
 731 
 732     if (error.isNull())
 733         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
 734 
 735     performErrorCallback(callbackIdentifier, error);
 736 }
 737 
 738 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 739 {
 740     ASSERT(isMainThread());
 741     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
 742 
<span class="line-modified"> 743     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 744     if (!callbackID)
 745         return;
 746 
 747     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 748     if (!info) {
 749         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 750         return;
 751     }
 752 
 753     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));
 754 }
 755 
 756 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
 757 {
 758     ASSERT(!isMainThread());
 759     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);
 760 
 761     ASSERT(m_backingStore);
 762     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);
 763 
 764     IDBError error;
 765     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));
 766 }
 767 
 768 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)
 769 {
 770     ASSERT(isMainThread());
 771     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);
 772 
 773     if (error.isNull())
 774         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 775 
 776     performErrorCallback(callbackIdentifier, error);
 777 }
 778 
 779 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 780 {
 781     ASSERT(isMainThread());
 782     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
 783 















 784     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 785     if (!callbackID)
 786         return;
 787     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
 788 }
 789 
 790 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 791 {
 792     ASSERT(!isMainThread());
 793     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);
 794 
 795     ASSERT(m_backingStore);
 796     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);
 797 
 798     IDBError error;
 799     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));
 800 }
 801 
 802 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)
 803 {
 804     ASSERT(isMainThread());
 805     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);
 806 
 807     performErrorCallback(callbackIdentifier, error);
 808 }
 809 
 810 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
 811 {
 812     ASSERT(isMainThread());
 813     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
 814 
<span class="line-modified"> 815     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 816     if (!callbackID)
 817         return;
 818     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
 819 }
 820 
 821 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
 822 {
 823     ASSERT(!isMainThread());
 824     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
 825 

 826     ASSERT(m_backingStore);
<span class="line-modified"> 827     IDBError error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>





 828 

 829     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
 830 }
 831 
 832 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
 833 {
 834     ASSERT(isMainThread());
 835     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);
 836 
 837     if (error.isNull()) {
 838         ASSERT(m_databaseInfo);
 839         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
 840         ASSERT(objectStoreInfo);
 841         objectStoreInfo-&gt;addExistingIndex(info);
 842     }
 843 
 844     performErrorCallback(callbackIdentifier, error);
 845 }
 846 
 847 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
 848 {
 849     ASSERT(isMainThread());
 850     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
 851 















 852     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 853     if (!callbackID)
 854         return;
 855 
 856     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 857     if (!objectStoreInfo) {
 858         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
 859         return;
 860     }
 861 
 862     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
 863     if (!indexInfo) {
 864         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
 865         return;
 866     }
 867 
 868     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));
 869 }
 870 
 871 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)
</pre>
<hr />
<pre>
 882 
 883 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
 884 {
 885     ASSERT(isMainThread());
 886     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);
 887 
 888     if (error.isNull()) {
 889         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 890         if (objectStoreInfo)
 891             objectStoreInfo-&gt;deleteIndex(indexIdentifier);
 892     }
 893 
 894     performErrorCallback(callbackIdentifier, error);
 895 }
 896 
 897 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
 898 {
 899     ASSERT(isMainThread());
 900     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
 901 
<span class="line-modified"> 902     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
















 903     if (!callbackID)
 904         return;
 905 
 906     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 907     if (!objectStoreInfo) {
 908         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
 909         return;
 910     }
 911 
 912     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 913     if (!indexInfo) {
 914         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
 915         return;
 916     }
 917 
 918     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));
 919 }
 920 
 921 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
 922 {
</pre>
<hr />
<pre>
 936     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);
 937 
 938     if (error.isNull()) {
 939         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 940         ASSERT(objectStoreInfo);
 941         if (objectStoreInfo) {
 942             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
 943             ASSERT(indexInfo);
 944             indexInfo-&gt;rename(newName);
 945         }
 946     }
 947 
 948     performErrorCallback(callbackIdentifier, error);
 949 }
 950 
 951 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
 952 {
 953     ASSERT(isMainThread());
 954     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
 955 
<span class="line-modified"> 956     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-modified"> 957     if (!callbackID)</span>
<span class="line-modified"> 958         return;</span>
<span class="line-modified"> 959     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
<span class="line-modified"> 960 }</span>
<span class="line-modified"> 961 </span>
<span class="line-modified"> 962 VM&amp; UniqueIDBDatabase::databaseThreadVM()</span>
<span class="line-modified"> 963 {</span>
<span class="line-removed"> 964     ASSERT(!isMainThread());</span>
<span class="line-removed"> 965     static VM* vm = &amp;VM::create().leakRef();</span>
<span class="line-removed"> 966     return *vm;</span>
 967 }
 968 
<span class="line-modified"> 969 ExecState&amp; UniqueIDBDatabase::databaseThreadExecState()</span>
 970 {
<span class="line-modified"> 971     ASSERT(!isMainThread());</span>
<span class="line-modified"> 972 </span>
<span class="line-modified"> 973     static NeverDestroyed&lt;Strong&lt;JSGlobalObject&gt;&gt; globalObject(databaseThreadVM(), JSGlobalObject::create(databaseThreadVM(), JSGlobalObject::createStructure(databaseThreadVM(), jsNull())));</span>
<span class="line-modified"> 974 </span>
<span class="line-removed"> 975     RELEASE_ASSERT(globalObject.get()-&gt;globalExec());</span>
<span class="line-removed"> 976     return *globalObject.get()-&gt;globalExec();</span>
 977 }
 978 
 979 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
 980 {
 981     ASSERT(!isMainThread());
 982     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);
 983 
 984     ASSERT(m_backingStore);
 985     ASSERT(objectStoreIdentifier);
 986 
 987     IDBKeyData usedKey;
 988     IDBError error;
 989 







 990     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
 991     if (!objectStoreInfo) {
 992         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
 993         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
 994         return;
 995     }
 996 
 997     bool usedKeyIsGenerated = false;
 998     uint64_t keyNumber;
 999     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1000         if (usedKeyIsGenerated)
1001             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1002     });
1003     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1004         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1005         if (!error.isNull()) {
1006             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1007             return;
1008         }
1009 
1010         usedKey.setNumberValue(keyNumber);
1011         usedKeyIsGenerated = true;
1012     } else
1013         usedKey = keyData;
1014 
1015     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1016         bool keyExists;
1017         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1018         if (error.isNull() &amp;&amp; keyExists)
1019             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);
1020 
1021         if (!error.isNull()) {
1022             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1023             return;
1024         }
1025     }
1026 
<span class="line-removed">1027     // 3.4.1.2 Object Store Storage Operation</span>
<span class="line-removed">1028     // If ObjectStore has a key path and the key is autogenerated, then inject the key into the value</span>
<span class="line-removed">1029     // using steps to assign a key to a value using a key path.</span>
<span class="line-removed">1030     ThreadSafeDataBuffer injectedRecordValue;</span>
<span class="line-removed">1031     if (usedKeyIsGenerated &amp;&amp; objectStoreInfo-&gt;keyPath()) {</span>
<span class="line-removed">1032         VM&amp; vm = databaseThreadVM();</span>
<span class="line-removed">1033         JSLockHolder locker(vm);</span>
<span class="line-removed">1034         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1035 </span>
<span class="line-removed">1036         auto value = deserializeIDBValueToJSValue(databaseThreadExecState(), originalRecordValue.data());</span>
<span class="line-removed">1037         if (value.isUndefined()) {</span>
<span class="line-removed">1038             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to deserialize record value for record key injection&quot;_s), usedKey));</span>
<span class="line-removed">1039             return;</span>
<span class="line-removed">1040         }</span>
<span class="line-removed">1041 </span>
<span class="line-removed">1042         if (!injectIDBKeyIntoScriptValue(databaseThreadExecState(), usedKey, value, objectStoreInfo-&gt;keyPath().value())) {</span>
<span class="line-removed">1043             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to inject record key into record value&quot;_s), usedKey));</span>
<span class="line-removed">1044             return;</span>
<span class="line-removed">1045         }</span>
<span class="line-removed">1046 </span>
<span class="line-removed">1047         auto serializedValue = SerializedScriptValue::create(databaseThreadExecState(), value);</span>
<span class="line-removed">1048         if (UNLIKELY(scope.exception())) {</span>
<span class="line-removed">1049             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, IDBError(ConstraintError, &quot;Unable to serialize record value after injecting record key&quot;_s), usedKey));</span>
<span class="line-removed">1050             return;</span>
<span class="line-removed">1051         }</span>
<span class="line-removed">1052 </span>
<span class="line-removed">1053         injectedRecordValue = ThreadSafeDataBuffer::copyVector(serializedValue-&gt;data());</span>
<span class="line-removed">1054     }</span>
<span class="line-removed">1055 </span>
1056     // 3.4.1 Object Store Storage Operation
1057     // ...If a record already exists in store ...
1058     // then remove the record from store using the steps for deleting records from an object store...
1059     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1060     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1061     if (!error.isNull()) {
1062         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1063         return;
1064     }
1065 
<span class="line-modified">1066     if (injectedRecordValue.data())</span>
<span class="line-removed">1067         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, { injectedRecordValue, originalRecordValue.blobURLs(), originalRecordValue.sessionID(), originalRecordValue.blobFilePaths() });</span>
<span class="line-removed">1068     else</span>
<span class="line-removed">1069         error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
1070 
1071     if (!error.isNull()) {
1072         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1073         return;
1074     }
1075 
1076     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1077         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1078 
1079     generatedKeyResetter.release();
1080     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1081 }
1082 
1083 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1084 {
1085     ASSERT(isMainThread());
1086     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);
1087 
1088     performKeyDataCallback(callbackIdentifier, error, resultKey);
1089 }
1090 
1091 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1092 {
1093     ASSERT(isMainThread());
1094     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
1095 











1096     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1097     if (!callbackID)
1098         return;
1099 
1100     if (uint64_t indexIdentifier = requestData.indexIdentifier())
1101         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));
1102     else
1103         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));
1104 }
1105 
1106 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1107 {
1108     ASSERT(isMainThread());
1109     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
1110 











1111     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1112     if (!callbackID)
1113         return;
1114 
1115     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
1116 }
1117 
1118 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)
1119 {
1120     ASSERT(!isMainThread());
1121     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);
1122 
1123     ASSERT(m_backingStore);
1124 
1125     IDBGetResult result;
1126     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);
1127 
1128     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1129 }
1130 
</pre>
<hr />
<pre>
1158 
1159     IDBGetAllResult result;
1160     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);
1161 
1162     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));
1163 }
1164 
1165 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)
1166 {
1167     ASSERT(isMainThread());
1168     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);
1169 
1170     performGetAllResultsCallback(callbackIdentifier, error, result);
1171 }
1172 
1173 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1174 {
1175     ASSERT(isMainThread());
1176     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
1177 











1178     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1179     if (!callbackID)
1180         return;
1181     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
1182 }
1183 
1184 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)
1185 {
1186     ASSERT(!isMainThread());
1187     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);
1188 
1189     ASSERT(m_backingStore);
1190     ASSERT(objectStoreIdentifier);
1191 
1192     uint64_t count;
1193     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);
1194 
1195     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));
1196 }
1197 
1198 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1199 {
1200     ASSERT(isMainThread());
1201     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);
1202 
1203     performCountCallback(callbackIdentifier, error, count);
1204 }
1205 
1206 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1207 {
1208     ASSERT(isMainThread());
1209     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
1210 











1211     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1212     if (!callbackID)
1213         return;
1214     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
1215 }
1216 
1217 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
1218 {
1219     ASSERT(!isMainThread());
1220     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);
1221 
1222     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);
1223 
1224     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));
1225 }
1226 
1227 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)
1228 {
1229     ASSERT(isMainThread());
1230     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);
1231 
1232     performErrorCallback(callbackIdentifier, error);
1233 }
1234 
1235 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1236 {
1237     ASSERT(isMainThread());
1238     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
1239 











1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1241     if (!callbackID)
1242         return;
1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
1244 }
1245 
1246 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)
1247 {
1248     ASSERT(!isMainThread());
1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);
1250 
1251     IDBGetResult result;
1252     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);
1253 
1254     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));
1255 }
1256 
1257 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1258 {
1259     ASSERT(isMainThread());
1260     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);
1261 
1262     performGetResultCallback(callbackIdentifier, error, result);
1263 }
1264 
1265 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1266 {
1267     ASSERT(isMainThread());
1268     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
1269 











1270     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1271     if (!callbackID)
1272         return;
1273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
1274 }
1275 
1276 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)
1277 {
1278     ASSERT(!isMainThread());
1279     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);
1280 
1281     IDBGetResult result;
1282     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
1283 
1284     if (error.isNull()) {
1285         auto addResult = m_cursorPrefetches.add(cursorIdentifier);
1286         if (addResult.isNewEntry)
1287             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1288     }
1289 
</pre>
<hr />
<pre>
1293 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
1294 {
1295     ASSERT(!isMainThread());
1296     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));
1297     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);
1298 
1299     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))
1300         m_cursorPrefetches.remove(cursorIdentifier);
1301     else
1302         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1303 }
1304 
1305 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1306 {
1307     ASSERT(isMainThread());
1308     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
1309 
1310     performGetResultCallback(callbackIdentifier, error, result);
1311 }
1312 
<span class="line-modified">1313 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction)</span>
1314 {
1315     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
1316     if (!takenTransaction)
1317         return false;
1318 
1319     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));

1320     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
1321 
1322     return true;
1323 }
1324 
1325 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1326 {
1327     ASSERT(isMainThread());
1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1329 
1330     ASSERT(transaction.databaseConnection().database() == this);
1331 















1332     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1333     if (!callbackID)
1334         return;
1335 
<span class="line-modified">1336     if (!prepareToFinishTransaction(transaction)) {</span>
1337         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1338             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
1339             forgetErrorCallback(callbackID);
1340             return;
1341         }
1342 
1343         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });
1344         return;
1345     }
1346 
1347     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));
1348 }
1349 
1350 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1351 {
1352     ASSERT(!isMainThread());
1353     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1354 
1355     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);
1356     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));
1357 }
1358 
1359 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1360 {
1361     ASSERT(isMainThread());
1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1363 
<span class="line-modified">1364     performErrorCallback(callbackIdentifier, error);</span>
















1365 
1366     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
1367 }
1368 
<span class="line-modified">1369 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
1370 {
1371     ASSERT(isMainThread());
1372     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1373 
1374     ASSERT(transaction.databaseConnection().database() == this);
1375 















1376     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1377     if (!callbackID)
1378         return;
1379 
<span class="line-modified">1380     if (!prepareToFinishTransaction(transaction)) {</span>
1381         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1382             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
1383             forgetErrorCallback(callbackID);
1384             return;
1385         }
1386 
1387         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });
1388         return;
1389     }
1390 
1391     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));
1392 }
1393 
1394 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
1395 {
1396     ASSERT(isMainThread());
1397     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
1398 
1399     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
1400     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
</pre>
<hr />
<pre>
1414 {
1415     ASSERT(!isMainThread());
1416     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1417 
1418     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
1419     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));
1420 }
1421 
1422 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1423 {
1424     ASSERT(isMainThread());
1425     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1426 
1427     auto transaction = m_finishingTransactions.take(transactionIdentifier);
1428     ASSERT(transaction);
1429 
1430     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
1431         ASSERT(m_versionChangeTransaction == transaction);
1432         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1433         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
<span class="line-modified">1434         m_databaseInfo = std::make_unique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
1435     }
1436 
<span class="line-modified">1437     performErrorCallback(callbackIdentifier, error);</span>

1438 
1439     transactionCompleted(WTFMove(transaction));
1440 }
1441 
1442 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
1443 {
1444     if (m_versionChangeTransaction == &amp;transaction)
1445         m_versionChangeTransaction = nullptr;
1446 }
1447 
1448 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1449 {
1450     ASSERT(isMainThread());
1451     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1452 







1453     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1454     m_openDatabaseConnections.remove(&amp;connection);
1455 
1456     if (m_versionChangeDatabaseConnection == &amp;connection) {
1457         if (m_versionChangeTransaction) {
1458             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));
1459 
1460             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();
1461             if (m_inProgressTransactions.contains(transactionIdentifier)) {
1462                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));
1463                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
1464             }
1465 
1466             return;
1467         }
1468 
1469         m_versionChangeDatabaseConnection = nullptr;
1470     }
1471 
1472     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
</pre>
<hr />
<pre>
1512 
1513     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {
1514         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));
1515         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));
1516         return;
1517     }
1518 
1519     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1520     m_openDatabaseConnections.remove(&amp;connection);
1521 
1522     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1523 
1524     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1525 }
1526 
1527 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
1528 {
1529     ASSERT(isMainThread());
1530     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1531 




1532     if (m_hardClosedForUserDelete)
1533         maybeFinishHardClose();
<span class="line-removed">1534     ASSERT(m_serverClosePendingDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">1535     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
1536 }
1537 
1538 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1539 {
1540     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
1541     ASSERT(!m_hardClosedForUserDelete);
1542 
1543     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1544 
1545     m_pendingTransactions.append(WTFMove(transaction));
1546 
1547     invokeOperationAndTransactionTimer();
1548 }
1549 
1550 bool UniqueIDBDatabase::isCurrentlyInUse() const
1551 {
1552     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;
1553 }
1554 
1555 bool UniqueIDBDatabase::hasUnfinishedTransactions() const
</pre>
<hr />
<pre>
1742     if (m_versionChangeTransaction == transaction)
1743         m_versionChangeTransaction = nullptr;
1744 
1745     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.
1746     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.
1747     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {
1748         scheduleShutdownForClose();
1749         return;
1750     }
1751 
1752     // Previously blocked operations might be runnable.
1753     if (!m_hardClosedForUserDelete)
1754         invokeOperationAndTransactionTimer();
1755     else
1756         maybeFinishHardClose();
1757 }
1758 
1759 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
1760 {
1761     m_databaseQueue.append(WTFMove(task));
<span class="line-modified">1762     m_server.postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
1763 }
1764 
1765 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
1766 {



1767     m_databaseReplyQueue.append(WTFMove(task));
<span class="line-modified">1768     m_server.postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
1769 }
1770 
1771 void UniqueIDBDatabase::executeNextDatabaseTask()
1772 {
1773     ASSERT(!isMainThread());
1774     ASSERT(!m_databaseQueue.isKilled());
1775 
1776     auto task = m_databaseQueue.tryGetMessage();
1777     ASSERT(task);
1778 
1779     task-&gt;performTask();
1780 }
1781 
1782 void UniqueIDBDatabase::executeNextDatabaseTaskReply()
1783 {
1784     ASSERT(isMainThread());
1785     ASSERT(!m_databaseReplyQueue.isKilled());
1786 
1787     auto task = m_databaseReplyQueue.tryGetMessage();
1788     ASSERT(task);
</pre>
<hr />
<pre>
1811 bool UniqueIDBDatabase::isDoneWithHardClose()
1812 {
1813     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();
1814 }
1815 
1816 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
1817 {
1818     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
1819     if (request.isOpenRequest())
1820         request.connection().didOpenDatabase(result);
1821     else
1822         request.connection().didDeleteDatabase(result);
1823 }
1824 
1825 void UniqueIDBDatabase::immediateCloseForUserDelete()
1826 {
1827     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
1828 
1829     ASSERT(isMainThread());
1830 



1831     // Error out all transactions
1832     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
1833         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
1834 
1835     ASSERT(m_inProgressTransactions.isEmpty());
1836 
1837     for (auto&amp; transaction : m_pendingTransactions)
1838         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
1839     m_pendingTransactions.clear();
1840     m_objectStoreTransactionCounts.clear();
1841     m_objectStoreWriteTransactions.clear();
1842 
1843     // Error out all pending callbacks
1844     IDBError error = IDBError::userDeleteError();
1845     IDBKeyData keyData;
1846     IDBGetResult getResult;
1847     IDBGetAllResult getAllResult;
1848 
1849     while (!m_callbackQueue.isEmpty()) {
1850         auto identifier = m_callbackQueue.first();
</pre>
<hr />
<pre>
1861         else
1862             ASSERT_NOT_REACHED();
1863     }
1864 
1865     // Error out all IDBOpenDBRequests
1866     if (m_currentOpenDBRequest) {
1867         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
1868         m_currentOpenDBRequest = nullptr;
1869     }
1870 
1871     for (auto&amp; request : m_pendingOpenDBRequests)
1872         errorOpenDBRequestForUserDelete(*request);
1873 
1874     m_pendingOpenDBRequests.clear();
1875 
1876     // Close all open connections
1877     auto openDatabaseConnections = m_openDatabaseConnections;
1878     for (auto&amp; connection : openDatabaseConnections)
1879         connectionClosedFromServer(*connection);
1880 





1881     // Cancel the operation timer
1882     m_operationAndTransactionTimer.stop();
1883 
1884     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
1885     // database connections confirm that they have closed.
1886     m_hardClosedForUserDelete = true;
1887 
1888     // If this database already owns itself, it is already closing on the background thread.
1889     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;
1890     // which will also cover this database.
1891     if (m_owningPointerForClose)
1892         return;
1893 
1894     // Otherwise, this database is still potentially active.
1895     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
<span class="line-modified">1896     m_owningPointerForClose = m_server.closeAndTakeUniqueIDBDatabase(*this);</span>
1897     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
1898 }
1899 























1900 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
1901 {


1902     auto callback = m_errorCallbacks.take(callbackIdentifier);
1903     ASSERT(callback || m_hardClosedForUserDelete);
1904     if (callback) {
1905         callback(error);
1906         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1907         m_callbackQueue.removeFirst();
1908     }
1909 }
1910 
1911 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1912 {


1913     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
1914     ASSERT(callback || m_hardClosedForUserDelete);
1915     if (callback) {
1916         callback(error, resultKey);
1917         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1918         m_callbackQueue.removeFirst();
1919     }
1920 }
1921 
1922 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)
1923 {
1924     auto callback = m_getResultCallbacks.take(callbackIdentifier);
1925     ASSERT(callback || m_hardClosedForUserDelete);
1926     if (callback) {
1927         callback(error, resultData);
1928         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1929         m_callbackQueue.removeFirst();
1930     }
1931 }
1932 
</pre>
<hr />
<pre>
1937     if (callback) {
1938         callback(error, resultData);
1939         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1940         m_callbackQueue.removeFirst();
1941     }
1942 }
1943 
1944 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1945 {
1946     auto callback = m_countCallbacks.take(callbackIdentifier);
1947     ASSERT(callback || m_hardClosedForUserDelete);
1948     if (callback) {
1949         callback(error, count);
1950         ASSERT(m_callbackQueue.first() == callbackIdentifier);
1951         m_callbackQueue.removeFirst();
1952     }
1953 }
1954 
1955 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
1956 {


1957     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
1958     ASSERT(m_callbackQueue.last() == callbackIdentifier);
1959     m_callbackQueue.removeLast();
1960     m_errorCallbacks.remove(callbackIdentifier);
1961 }
1962 
<span class="line-modified">1963 void UniqueIDBDatabase::setQuota(uint64_t quota)</span>
1964 {
<span class="line-modified">1965     if (m_backingStore)</span>
<span class="line-modified">1966         m_backingStore-&gt;setQuota(quota);</span>



































1967 }
1968 
1969 } // namespace IDBServer
1970 } // namespace WebCore
1971 
1972 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;UniqueIDBDatabase.h&quot;
  28 
  29 #if ENABLE(INDEXED_DATABASE)
  30 
  31 #include &quot;IDBBindingUtilities.h&quot;
  32 #include &quot;IDBCursorInfo.h&quot;
  33 #include &quot;IDBGetAllRecordsData.h&quot;
  34 #include &quot;IDBGetAllResult.h&quot;
  35 #include &quot;IDBGetRecordData.h&quot;
  36 #include &quot;IDBIterateCursorData.h&quot;
  37 #include &quot;IDBKeyRangeData.h&quot;
  38 #include &quot;IDBResultData.h&quot;
  39 #include &quot;IDBServer.h&quot;
  40 #include &quot;IDBTransactionInfo.h&quot;
  41 #include &quot;IDBValue.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;SerializedScriptValue.h&quot;
<span class="line-added">  44 #include &quot;StorageQuotaManager.h&quot;</span>
  45 #include &quot;UniqueIDBDatabaseConnection.h&quot;
  46 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
<span class="line-modified">  47 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
  48 #include &lt;JavaScriptCore/StrongInlines.h&gt;

  49 #include &lt;wtf/MainThread.h&gt;
  50 #include &lt;wtf/NeverDestroyed.h&gt;
  51 #include &lt;wtf/Scope.h&gt;
  52 
  53 namespace WebCore {
  54 using namespace JSC;
  55 namespace IDBServer {
  56 
<span class="line-added">  57 static const uint64_t defaultWriteOperationCost = 4;</span>
<span class="line-added">  58 </span>
<span class="line-added">  59 static inline uint64_t estimateSize(const IDBKeyData&amp; keyData)</span>
<span class="line-added">  60 {</span>
<span class="line-added">  61     uint64_t size = 4;</span>
<span class="line-added">  62     switch (keyData.type()) {</span>
<span class="line-added">  63     case IndexedDB::KeyType::String:</span>
<span class="line-added">  64         size += keyData.string().sizeInBytes();</span>
<span class="line-added">  65         break;</span>
<span class="line-added">  66     case IndexedDB::KeyType::Binary: {</span>
<span class="line-added">  67         size += keyData.binary().size();</span>
<span class="line-added">  68         break;</span>
<span class="line-added">  69     }</span>
<span class="line-added">  70     case IndexedDB::KeyType::Array:</span>
<span class="line-added">  71         for (auto&amp; data : keyData.array())</span>
<span class="line-added">  72             size += estimateSize(data);</span>
<span class="line-added">  73         break;</span>
<span class="line-added">  74     default:</span>
<span class="line-added">  75         break;</span>
<span class="line-added">  76     }</span>
<span class="line-added">  77     return size;</span>
<span class="line-added">  78 }</span>
<span class="line-added">  79 </span>
<span class="line-added">  80 static inline uint64_t estimateSize(const IDBValue&amp; value)</span>
<span class="line-added">  81 {</span>
<span class="line-added">  82     uint64_t size = 4;</span>
<span class="line-added">  83     size += value.data().size();</span>
<span class="line-added">  84     for (auto&amp; url : value.blobURLs())</span>
<span class="line-added">  85         size += url.sizeInBytes();</span>
<span class="line-added">  86     for (auto&amp; path : value.blobFilePaths())</span>
<span class="line-added">  87         size += path.sizeInBytes();</span>
<span class="line-added">  88     return size;</span>
<span class="line-added">  89 }</span>
<span class="line-added">  90 </span>
<span class="line-added">  91 static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)</span>
<span class="line-added">  92 {</span>
<span class="line-added">  93     uint64_t size = 4;</span>
<span class="line-added">  94     size += info.name().sizeInBytes();</span>
<span class="line-added">  95     return size;</span>
<span class="line-added">  96 }</span>
<span class="line-added">  97 </span>
<span class="line-added">  98 static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)</span>
<span class="line-added">  99 {</span>
<span class="line-added"> 100     uint64_t size = 4;</span>
<span class="line-added"> 101     size += info.name().sizeInBytes();</span>
<span class="line-added"> 102     // FIXME: estimate keyPath.</span>
<span class="line-added"> 103     for (auto&amp; indexInfo : info.indexMap().values())</span>
<span class="line-added"> 104         size += estimateSize(indexInfo);</span>
<span class="line-added"> 105     return size;</span>
<span class="line-added"> 106 }</span>
<span class="line-added"> 107 </span>
 108 UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
 109     : m_server(server)
 110     , m_identifier(identifier)
 111     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)
 112 {
 113     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 114 }
 115 
 116 UniqueIDBDatabase::~UniqueIDBDatabase()
 117 {
 118     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());
 119     ASSERT(isMainThread());
 120     ASSERT(!hasAnyPendingCallbacks());
 121     ASSERT(!hasUnfinishedTransactions());
 122     ASSERT(m_pendingTransactions.isEmpty());
 123     ASSERT(m_openDatabaseConnections.isEmpty());
 124     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());
 125     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());
 126 
 127     RELEASE_ASSERT(m_databaseQueue.isKilled());
</pre>
<hr />
<pre>
 152 
 153 bool UniqueIDBDatabase::hasAnyPendingCallbacks() const
 154 {
 155     return !m_errorCallbacks.isEmpty()
 156         || !m_keyDataCallbacks.isEmpty()
 157         || !m_getResultCallbacks.isEmpty()
 158         || !m_getAllResultsCallbacks.isEmpty()
 159         || !m_countCallbacks.isEmpty();
 160 }
 161 
 162 bool UniqueIDBDatabase::isVersionChangeInProgress()
 163 {
 164 #if !LOG_DISABLED
 165     if (m_versionChangeTransaction)
 166         ASSERT(m_versionChangeDatabaseConnection);
 167 #endif
 168 
 169     return m_versionChangeDatabaseConnection;
 170 }
 171 
<span class="line-added"> 172 static inline String quotaErrorMessageName(const char* taskName)</span>
<span class="line-added"> 173 {</span>
<span class="line-added"> 174     return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);</span>
<span class="line-added"> 175 }</span>
<span class="line-added"> 176 </span>
<span class="line-added"> 177 void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-added"> 178 {</span>
<span class="line-added"> 179     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {</span>
<span class="line-added"> 180         if (!weakThis) {</span>
<span class="line-added"> 181             callback(IDBError { UnknownError });</span>
<span class="line-added"> 182             return;</span>
<span class="line-added"> 183         }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185         if (m_owningPointerForClose) {</span>
<span class="line-added"> 186             // We are closing the database, there is no point in trying to modify the database at that point.</span>
<span class="line-added"> 187             callback(IDBError { UnknownError });</span>
<span class="line-added"> 188             return;</span>
<span class="line-added"> 189         }</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191         switch (decision) {</span>
<span class="line-added"> 192         case StorageQuotaManager::Decision::Deny:</span>
<span class="line-added"> 193             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });</span>
<span class="line-added"> 194             return;</span>
<span class="line-added"> 195         case StorageQuotaManager::Decision::Grant:</span>
<span class="line-added"> 196             callback({ });</span>
<span class="line-added"> 197         };</span>
<span class="line-added"> 198     });</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-added"> 202 {</span>
<span class="line-added"> 203     requestSpace(0, &quot;&quot;, WTFMove(callback));</span>
<span class="line-added"> 204 }</span>
<span class="line-added"> 205 </span>
 206 void UniqueIDBDatabase::performCurrentOpenOperation()
 207 {
 208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);
 209 
 210     ASSERT(m_currentOpenDBRequest);
 211     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 212 
 213     if (!m_databaseInfo) {
 214         if (!m_isOpeningBackingStore) {
 215             m_isOpeningBackingStore = true;
<span class="line-modified"> 216             // We do not know whether this is an existing or a new database.</span>
<span class="line-added"> 217             // We set a small cost so that it is not possible to open an infinite number of database.</span>
<span class="line-added"> 218             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {</span>
<span class="line-added"> 219                 if (!weakThis)</span>
<span class="line-added"> 220                     return;</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222                 if (m_owningPointerForClose)</span>
<span class="line-added"> 223                     return;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225                 switch (decision) {</span>
<span class="line-added"> 226                 case StorageQuotaManager::Decision::Deny: {</span>
<span class="line-added"> 227                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });</span>
<span class="line-added"> 228                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 229                     m_currentOpenDBRequest = nullptr;</span>
<span class="line-added"> 230                     m_isOpeningBackingStore = false;</span>
<span class="line-added"> 231                     break;</span>
<span class="line-added"> 232                 }</span>
<span class="line-added"> 233                 case StorageQuotaManager::Decision::Grant:</span>
<span class="line-added"> 234                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="line-added"> 235                 };</span>
<span class="line-added"> 236             });</span>
 237         }

 238         return;
 239     }
 240 
 241     // If we previously started a version change operation but were blocked by having open connections,
 242     // we might now be unblocked.
 243     if (m_versionChangeDatabaseConnection) {
 244         if (!m_versionChangeTransaction &amp;&amp; !hasAnyOpenConnections())
 245             startVersionChangeTransaction();
 246         return;
 247     }
 248 
 249     // 3.3.1 Opening a database
 250     // If requested version is undefined, then let requested version be 1 if db was created in the previous step,
 251     // or the current version of db otherwise.
 252     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
 253     if (!requestedVersion)
 254         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 255 
 256     // 3.3.1 Opening a database
 257     // If the database version higher than the requested version, abort these steps and return a VersionError.
</pre>
<hr />
<pre>
 327 
 328     if (!m_deleteBackingStoreInProgress) {
 329         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)
 330             didDeleteBackingStore(0);
 331         else {
 332             m_deleteBackingStoreInProgress = true;
 333             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));
 334         }
 335     }
 336 }
 337 
 338 void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 339 {
 340     ASSERT(!isMainThread());
 341     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);
 342 
 343     uint64_t deletedVersion = 0;
 344 
 345     if (m_backingStore) {
 346         m_backingStore-&gt;deleteBackingStore();
<span class="line-added"> 347         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 348 </span>
 349         m_backingStore = nullptr;
 350         m_backingStoreSupportsSimultaneousTransactions = false;
 351         m_backingStoreIsEphemeral = false;
 352     } else {
<span class="line-modified"> 353         auto backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-added"> 354         m_currentDatabaseSize = backingStore-&gt;databaseSize();</span>
 355 
 356         IDBDatabaseInfo databaseInfo;
 357         auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 358         if (!error.isNull())
 359             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());
 360 
 361         deletedVersion = databaseInfo.version();
 362         backingStore-&gt;deleteBackingStore();
<span class="line-added"> 363         m_newDatabaseSize = backingStore-&gt;databaseSize();</span>
 364     }
 365 
 366     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));
 367 }
 368 
 369 void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()
 370 {
 371     ASSERT(!isMainThread());
 372     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);
 373 
 374     if (m_backingStore)
 375         m_backingStore-&gt;deleteBackingStore();
 376 
 377     shutdownForClose();
 378 }
 379 
 380 void UniqueIDBDatabase::scheduleShutdownForClose()
 381 {
 382     ASSERT(isMainThread());
 383 
 384     m_operationAndTransactionTimer.stop();
 385 
 386     RELEASE_ASSERT(!m_owningPointerForClose);
<span class="line-modified"> 387     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
 388 
 389     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 390 }
 391 
 392 void UniqueIDBDatabase::shutdownForClose()
 393 {
 394     ASSERT(!isMainThread());
 395     ASSERT(m_owningPointerForClose.get() == this);
 396 
 397     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);
 398 
<span class="line-added"> 399     if (m_backingStore) {</span>
<span class="line-added"> 400         m_backingStore-&gt;close();</span>
<span class="line-added"> 401         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 402     }</span>
<span class="line-added"> 403 </span>
 404     m_backingStore = nullptr;
 405     m_backingStoreSupportsSimultaneousTransactions = false;
 406     m_backingStoreIsEphemeral = false;
 407 
 408     if (!m_databaseQueue.isEmpty()) {
 409         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));
 410         return;
 411     }
 412     m_databaseQueue.kill();
 413 
 414     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));
 415 }
 416 
 417 void UniqueIDBDatabase::didShutdownForClose()
 418 {
 419     ASSERT(m_databaseReplyQueue.isEmpty());
 420     m_databaseReplyQueue.kill();
<span class="line-added"> 421 </span>
<span class="line-added"> 422     updateSpaceUsedIfNeeded();</span>
 423 }
 424 
 425 void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
 426 {
 427     ASSERT(isMainThread());
 428     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);
 429 
 430     ASSERT(!hasAnyPendingCallbacks());
 431     ASSERT(!hasUnfinishedTransactions());
 432     ASSERT(m_pendingTransactions.isEmpty());
 433     ASSERT(m_openDatabaseConnections.isEmpty());
 434     ASSERT(!m_backingStore);
 435 
 436     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.
 437     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.
 438     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());
 439 
 440     if (m_databaseInfo)
 441         m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
 442 
 443     // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
 444     // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
 445     // passed in deletedVersion argument.
 446     if (!m_mostRecentDeletedDatabaseInfo)
<span class="line-modified"> 447         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
 448 
 449     if (m_currentOpenDBRequest) {
 450         m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
 451         m_currentOpenDBRequest = nullptr;
 452     }
 453 
<span class="line-added"> 454     updateSpaceUsedIfNeeded();</span>
<span class="line-added"> 455 </span>
 456     m_deleteBackingStoreInProgress = false;
 457 
 458     if (m_hardClosedForUserDelete)
 459         return;
 460 
 461     invokeOperationAndTransactionTimer();
 462 }
 463 
 464 void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
 465 {
 466     while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
 467         m_pendingOpenDBRequests.removeFirst();
 468 }
 469 
 470 void UniqueIDBDatabase::handleDatabaseOperations()
 471 {
 472     ASSERT(isMainThread());
 473     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());
 474     ASSERT(!m_hardClosedForUserDelete);
 475 
<span class="line-modified"> 476     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)</span>
 477         return;
 478 
 479     clearStalePendingOpenDBRequests();
 480 
 481     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {
 482         // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
 483         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())
 484             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();
 485 
 486         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle
 487         if (m_currentOpenDBRequest)
 488             handleCurrentOperation();
 489 
 490         return;
 491     }
 492 
 493     if (m_pendingOpenDBRequests.isEmpty()) {
 494         m_currentOpenDBRequest = nullptr;
 495         return;
 496     }
</pre>
<hr />
<pre>
 523     return !m_openDatabaseConnections.isEmpty();
 524 }
 525 
 526 bool UniqueIDBDatabase::allConnectionsAreClosedOrClosing() const
 527 {
 528     for (auto&amp; connection : m_openDatabaseConnections) {
 529         if (!connection-&gt;connectionIsClosing())
 530             return false;
 531     }
 532 
 533     return true;
 534 }
 535 
 536 static uint64_t generateUniqueCallbackIdentifier()
 537 {
 538     ASSERT(isMainThread());
 539     static uint64_t currentID = 0;
 540     return ++currentID;
 541 }
 542 
<span class="line-modified"> 543 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)</span>
 544 {
 545     if (m_hardClosedForUserDelete) {
 546         callback(IDBError::userDeleteError());
 547         return 0;
 548     }
 549 
 550     uint64_t identifier = generateUniqueCallbackIdentifier();
 551     ASSERT(!m_errorCallbacks.contains(identifier));
 552     m_errorCallbacks.add(identifier, WTFMove(callback));
<span class="line-added"> 553 </span>
<span class="line-added"> 554     if (taskSize) {</span>
<span class="line-added"> 555         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-added"> 556         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-added"> 557     }</span>
<span class="line-added"> 558 </span>
 559     m_callbackQueue.append(identifier);
 560     return identifier;
 561 }
 562 
<span class="line-modified"> 563 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)</span>
 564 {
 565     if (m_hardClosedForUserDelete) {
 566         callback(IDBError::userDeleteError(), { });
 567         return 0;
 568     }
 569 
 570     uint64_t identifier = generateUniqueCallbackIdentifier();
 571     ASSERT(!m_keyDataCallbacks.contains(identifier));
 572     m_keyDataCallbacks.add(identifier, WTFMove(callback));
<span class="line-added"> 573 </span>
<span class="line-added"> 574     if (taskSize) {</span>
<span class="line-added"> 575         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-added"> 576         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-added"> 577     }</span>
<span class="line-added"> 578 </span>
 579     m_callbackQueue.append(identifier);
 580     return identifier;
 581 }
 582 
 583 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)
 584 {
 585     if (m_hardClosedForUserDelete) {
 586         callback(IDBError::userDeleteError(), { });
 587         return 0;
 588     }
 589 
 590     uint64_t identifier = generateUniqueCallbackIdentifier();
 591     ASSERT(!m_getResultCallbacks.contains(identifier));
 592     m_getResultCallbacks.add(identifier, WTFMove(callback));
 593     m_callbackQueue.append(identifier);
 594     return identifier;
 595 }
 596 
 597 uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)
 598 {
</pre>
<hr />
<pre>
 623 }
 624 
 625 void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
 626 {
 627     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);
 628     ASSERT(!m_hardClosedForUserDelete);
 629 
 630     m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
 631     handleDatabaseOperations();
 632 }
 633 
 634 void UniqueIDBDatabase::startVersionChangeTransaction()
 635 {
 636     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);
 637 
 638     ASSERT(!m_versionChangeTransaction);
 639     ASSERT(m_currentOpenDBRequest);
 640     ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
 641     ASSERT(m_versionChangeDatabaseConnection);
 642 
<span class="line-modified"> 643     uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();</span>


 644     if (!requestedVersion)
 645         requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
 646 


 647     m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);


 648     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);

 649 
<span class="line-modified"> 650     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));</span>

 651 }
 652 
<span class="line-modified"> 653 void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)</span>
 654 {
<span class="line-modified"> 655     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);</span>
<span class="line-modified"> 656 </span>
<span class="line-added"> 657     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-added"> 658     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));</span>
<span class="line-added"> 659 }</span>
<span class="line-added"> 660 </span>
<span class="line-added"> 661 void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)</span>
<span class="line-added"> 662 {</span>
<span class="line-added"> 663     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665     // Open request may already be canceled by client or user, or connection to client is lost.</span>
<span class="line-added"> 666     if (!m_versionChangeDatabaseConnection)</span>
<span class="line-added"> 667         return;</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669     ASSERT(m_currentOpenDBRequest);</span>
<span class="line-added"> 670     ASSERT(m_versionChangeTransaction);</span>
<span class="line-added"> 671     auto operation = WTFMove(m_currentOpenDBRequest);</span>
<span class="line-added"> 672     IDBResultData result;</span>
<span class="line-added"> 673     if (error.isNull()) {</span>
<span class="line-added"> 674         addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);</span>
<span class="line-added"> 675         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());</span>
<span class="line-added"> 676         result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);</span>
<span class="line-added"> 677         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 678     } else {</span>
<span class="line-added"> 679         m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-added"> 680         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added"> 681         result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);</span>
<span class="line-added"> 682         operation-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added"> 683     }</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685     invokeOperationAndTransactionTimer();</span>
 686 }
 687 
 688 void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
 689 {
 690     ASSERT(m_currentOpenDBRequest);
 691 
 692     if (m_currentOpenDBRequest-&gt;hasNotifiedConnectionsOfVersionChange())
 693         return;
 694 
 695     uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
 696     auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
 697 
 698     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);
 699 
 700     // 3.3.7 &quot;versionchange&quot; transaction steps
 701     // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
 702     // The event must not be fired on connections which has the closePending flag set.
 703     HashSet&lt;uint64_t&gt; connectionIdentifiers;
 704     for (const auto&amp; connection : m_openDatabaseConnections) {
 705         if (connection-&gt;closePending())
</pre>
<hr />
<pre>
 765     for (auto&amp; request : m_pendingOpenDBRequests) {
 766         if (request-&gt;requestData().requestIdentifier() == requestIdentifier) {
 767             m_pendingOpenDBRequests.remove(request);
 768             return;
 769         }
 770     }
 771 }
 772 
 773 void UniqueIDBDatabase::addOpenDatabaseConnection(Ref&lt;UniqueIDBDatabaseConnection&gt;&amp;&amp; connection)
 774 {
 775     ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
 776     m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
 777 }
 778 
 779 void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)
 780 {
 781     ASSERT(!isMainThread());
 782     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);
 783 
 784     ASSERT(!m_backingStore);
<span class="line-modified"> 785     m_backingStore = m_server-&gt;createBackingStore(identifier);</span>
 786     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();
 787     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();
 788 
<span class="line-added"> 789     // QuotaUser should have initiliazed storage usage, which contains the</span>
<span class="line-added"> 790     // size of this database.</span>
<span class="line-added"> 791     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added"> 792 </span>
 793     IDBDatabaseInfo databaseInfo;
 794     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
 795 
 796     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));
 797 }
 798 
 799 void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)
 800 {
 801     ASSERT(isMainThread());
 802     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);
 803 
<span class="line-modified"> 804     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);</span>
 805     m_backingStoreOpenError = error;
 806 
 807     ASSERT(m_isOpeningBackingStore);
 808     m_isOpeningBackingStore = false;
 809 
<span class="line-added"> 810     updateSpaceUsedIfNeeded();</span>
<span class="line-added"> 811 </span>
 812     if (m_hardClosedForUserDelete)
 813         return;
 814 
 815     handleDatabaseOperations();
 816 }
 817 
 818 void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)
 819 {
 820     ASSERT(isMainThread());
 821     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);
 822 
<span class="line-modified"> 823     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added"> 824     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 825         if (error) {</span>
<span class="line-added"> 826             callback(WTFMove(*error));</span>
<span class="line-added"> 827             return;</span>
<span class="line-added"> 828         }</span>
<span class="line-added"> 829         if (!transaction) {</span>
<span class="line-added"> 830             callback(IDBError { UnknownError });</span>
<span class="line-added"> 831             return;</span>
<span class="line-added"> 832         }</span>
<span class="line-added"> 833         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-added"> 834     });</span>
<span class="line-added"> 835 }</span>
<span class="line-added"> 836 </span>
<span class="line-added"> 837 void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
<span class="line-added"> 838 {</span>
<span class="line-added"> 839     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
 840     if (!callbackID)
 841         return;
 842 
 843     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));
 844 }
 845 
 846 void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
 847 {
 848     ASSERT(!isMainThread());
 849     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);
 850 
 851     ASSERT(m_backingStore);
 852     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);
 853 
 854     IDBError error;
 855     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));
 856 }
 857 
 858 void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)
 859 {
 860     ASSERT(isMainThread());
 861     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);
 862 
 863     if (error.isNull())
 864         m_databaseInfo-&gt;addExistingObjectStore(info);
 865 
 866     performErrorCallback(callbackIdentifier, error);
 867 }
 868 
 869 void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)
 870 {
 871     ASSERT(isMainThread());
 872     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);
 873 
<span class="line-added"> 874     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 875         if (error) {</span>
<span class="line-added"> 876             callback(WTFMove(*error));</span>
<span class="line-added"> 877             return;</span>
<span class="line-added"> 878         }</span>
<span class="line-added"> 879         if (!transaction) {</span>
<span class="line-added"> 880             callback(IDBError { UnknownError });</span>
<span class="line-added"> 881             return;</span>
<span class="line-added"> 882         }</span>
<span class="line-added"> 883         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));</span>
<span class="line-added"> 884     });</span>
<span class="line-added"> 885 }</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887 void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
<span class="line-added"> 888 {</span>
 889     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
 890     if (!callbackID)
 891         return;
 892 
 893     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);
 894     if (!info) {
 895         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });
 896         return;
 897     }
 898 
 899     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));
 900 }
 901 
 902 void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
 903 {
 904     ASSERT(!isMainThread());
 905     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);
 906 
 907     ASSERT(m_backingStore);
 908     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);
</pre>
<hr />
<pre>
 910     IDBError error;
 911     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));
 912 }
 913 
 914 void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)
 915 {
 916     ASSERT(isMainThread());
 917     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);
 918 
 919     if (error.isNull())
 920         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);
 921 
 922     performErrorCallback(callbackIdentifier, error);
 923 }
 924 
 925 void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)
 926 {
 927     ASSERT(isMainThread());
 928     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);
 929 
<span class="line-modified"> 930     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-added"> 931     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 932         if (error) {</span>
<span class="line-added"> 933             callback(WTFMove(*error));</span>
<span class="line-added"> 934             return;</span>
<span class="line-added"> 935         }</span>
<span class="line-added"> 936         if (!transaction) {</span>
<span class="line-added"> 937             callback(IDBError { UnknownError });</span>
<span class="line-added"> 938             return;</span>
<span class="line-added"> 939         }</span>
<span class="line-added"> 940         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));</span>
<span class="line-added"> 941     });</span>
<span class="line-added"> 942 }</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944 void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-added"> 945 {</span>
<span class="line-added"> 946     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
 947     if (!callbackID)
 948         return;
 949 
 950     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
 951     if (!info) {
 952         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });
 953         return;
 954     }
 955 
 956     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));
 957 }
 958 
 959 void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
 960 {
 961     ASSERT(!isMainThread());
 962     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);
 963 
 964     ASSERT(m_backingStore);
 965     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);
 966 
 967     IDBError error;
 968     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));
 969 }
 970 
 971 void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)
 972 {
 973     ASSERT(isMainThread());
 974     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);
 975 
 976     if (error.isNull())
 977         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
 978 
 979     performErrorCallback(callbackIdentifier, error);
 980 }
 981 
 982 void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)
 983 {
 984     ASSERT(isMainThread());
 985     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);
 986 
<span class="line-added"> 987     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added"> 988         if (error) {</span>
<span class="line-added"> 989             callback(WTFMove(*error));</span>
<span class="line-added"> 990             return;</span>
<span class="line-added"> 991         }</span>
<span class="line-added"> 992         if (!transaction) {</span>
<span class="line-added"> 993             callback(IDBError { UnknownError });</span>
<span class="line-added"> 994             return;</span>
<span class="line-added"> 995         }</span>
<span class="line-added"> 996         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));</span>
<span class="line-added"> 997     });</span>
<span class="line-added"> 998 }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000 void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-added">1001 {</span>
1002     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1003     if (!callbackID)
1004         return;
1005     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));
1006 }
1007 
1008 void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
1009 {
1010     ASSERT(!isMainThread());
1011     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);
1012 
1013     ASSERT(m_backingStore);
1014     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);
1015 
1016     IDBError error;
1017     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));
1018 }
1019 
1020 void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)
1021 {
1022     ASSERT(isMainThread());
1023     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);
1024 
1025     performErrorCallback(callbackIdentifier, error);
1026 }
1027 
1028 void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)
1029 {
1030     ASSERT(isMainThread());
1031     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);
1032 
<span class="line-modified">1033     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added">1034     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1035         if (error) {</span>
<span class="line-added">1036             callback(WTFMove(*error));</span>
<span class="line-added">1037             return;</span>
<span class="line-added">1038         }</span>
<span class="line-added">1039         if (!transaction) {</span>
<span class="line-added">1040             callback(IDBError { UnknownError });</span>
<span class="line-added">1041             return;</span>
<span class="line-added">1042         }</span>
<span class="line-added">1043         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-added">1044     });</span>
<span class="line-added">1045 }</span>
<span class="line-added">1046 </span>
<span class="line-added">1047 void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-added">1048 {</span>
<span class="line-added">1049     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
1050     if (!callbackID)
1051         return;
1052     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));
1053 }
1054 
1055 void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
1056 {
1057     ASSERT(!isMainThread());
1058     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);
1059 
<span class="line-added">1060     IDBError error;</span>
1061     ASSERT(m_backingStore);
<span class="line-modified">1062     if (!m_backingStore) {</span>
<span class="line-added">1063         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);</span>
<span class="line-added">1064         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);</span>
<span class="line-added">1065         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-added">1066         return;</span>
<span class="line-added">1067     }</span>
1068 
<span class="line-added">1069     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
1070     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));
1071 }
1072 
1073 void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)
1074 {
1075     ASSERT(isMainThread());
1076     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);
1077 
1078     if (error.isNull()) {
1079         ASSERT(m_databaseInfo);
1080         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1081         ASSERT(objectStoreInfo);
1082         objectStoreInfo-&gt;addExistingIndex(info);
1083     }
1084 
1085     performErrorCallback(callbackIdentifier, error);
1086 }
1087 
1088 void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)
1089 {
1090     ASSERT(isMainThread());
1091     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);
1092 
<span class="line-added">1093     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1094         if (error) {</span>
<span class="line-added">1095             callback(WTFMove(*error));</span>
<span class="line-added">1096             return;</span>
<span class="line-added">1097         }</span>
<span class="line-added">1098         if (!transaction) {</span>
<span class="line-added">1099             callback(IDBError { UnknownError });</span>
<span class="line-added">1100             return;</span>
<span class="line-added">1101         }</span>
<span class="line-added">1102         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));</span>
<span class="line-added">1103     });</span>
<span class="line-added">1104 }</span>
<span class="line-added">1105 </span>
<span class="line-added">1106 void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-added">1107 {</span>
1108     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1109     if (!callbackID)
1110         return;
1111 
1112     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1113     if (!objectStoreInfo) {
1114         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });
1115         return;
1116     }
1117 
1118     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
1119     if (!indexInfo) {
1120         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });
1121         return;
1122     }
1123 
1124     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));
1125 }
1126 
1127 void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)
</pre>
<hr />
<pre>
1138 
1139 void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
1140 {
1141     ASSERT(isMainThread());
1142     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);
1143 
1144     if (error.isNull()) {
1145         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1146         if (objectStoreInfo)
1147             objectStoreInfo-&gt;deleteIndex(indexIdentifier);
1148     }
1149 
1150     performErrorCallback(callbackIdentifier, error);
1151 }
1152 
1153 void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
1154 {
1155     ASSERT(isMainThread());
1156     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);
1157 
<span class="line-modified">1158     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-added">1159     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1160         if (error) {</span>
<span class="line-added">1161             callback(WTFMove(*error));</span>
<span class="line-added">1162             return;</span>
<span class="line-added">1163         }</span>
<span class="line-added">1164         if (!transaction) {</span>
<span class="line-added">1165             callback(IDBError { UnknownError });</span>
<span class="line-added">1166             return;</span>
<span class="line-added">1167         }</span>
<span class="line-added">1168         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));</span>
<span class="line-added">1169     });</span>
<span class="line-added">1170 }</span>
<span class="line-added">1171 </span>
<span class="line-added">1172 void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-added">1173 {</span>
<span class="line-added">1174     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
1175     if (!callbackID)
1176         return;
1177 
1178     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1179     if (!objectStoreInfo) {
1180         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });
1181         return;
1182     }
1183 
1184     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1185     if (!indexInfo) {
1186         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });
1187         return;
1188     }
1189 
1190     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));
1191 }
1192 
1193 void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1194 {
</pre>
<hr />
<pre>
1208     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);
1209 
1210     if (error.isNull()) {
1211         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1212         ASSERT(objectStoreInfo);
1213         if (objectStoreInfo) {
1214             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
1215             ASSERT(indexInfo);
1216             indexInfo-&gt;rename(newName);
1217         }
1218     }
1219 
1220     performErrorCallback(callbackIdentifier, error);
1221 }
1222 
1223 void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
1224 {
1225     ASSERT(isMainThread());
1226     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);
1227 
<span class="line-modified">1228     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-modified">1229     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {</span>
<span class="line-modified">1230         if (error) {</span>
<span class="line-modified">1231             callback(WTFMove(*error), { });</span>
<span class="line-modified">1232             return;</span>
<span class="line-modified">1233         }</span>
<span class="line-modified">1234         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));</span>
<span class="line-modified">1235     });</span>



1236 }
1237 
<span class="line-modified">1238 void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)</span>
1239 {
<span class="line-modified">1240     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-modified">1241     if (!callbackID)</span>
<span class="line-modified">1242         return;</span>
<span class="line-modified">1243     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>


1244 }
1245 
1246 void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
1247 {
1248     ASSERT(!isMainThread());
1249     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);
1250 
1251     ASSERT(m_backingStore);
1252     ASSERT(objectStoreIdentifier);
1253 
1254     IDBKeyData usedKey;
1255     IDBError error;
1256 
<span class="line-added">1257     if (!m_backingStore) {</span>
<span class="line-added">1258         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);</span>
<span class="line-added">1259         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);</span>
<span class="line-added">1260         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
<span class="line-added">1261         return;</span>
<span class="line-added">1262     }</span>
<span class="line-added">1263 </span>
1264     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);
1265     if (!objectStoreInfo) {
1266         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);
1267         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1268         return;
1269     }
1270 
1271     bool usedKeyIsGenerated = false;
1272     uint64_t keyNumber;
1273     auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
1274         if (usedKeyIsGenerated)
1275             m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1276     });
1277     if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
1278         error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
1279         if (!error.isNull()) {
1280             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1281             return;
1282         }
1283 
1284         usedKey.setNumberValue(keyNumber);
1285         usedKeyIsGenerated = true;
1286     } else
1287         usedKey = keyData;
1288 
1289     if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
1290         bool keyExists;
1291         error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
1292         if (error.isNull() &amp;&amp; keyExists)
1293             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);
1294 
1295         if (!error.isNull()) {
1296             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1297             return;
1298         }
1299     }
1300 





























1301     // 3.4.1 Object Store Storage Operation
1302     // ...If a record already exists in store ...
1303     // then remove the record from store using the steps for deleting records from an object store...
1304     // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
1305     error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
1306     if (!error.isNull()) {
1307         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1308         return;
1309     }
1310 
<span class="line-modified">1311     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>



1312 
1313     if (!error.isNull()) {
1314         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1315         return;
1316     }
1317 
1318     if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
1319         error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
1320 
1321     generatedKeyResetter.release();
1322     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));
1323 }
1324 
1325 void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
1326 {
1327     ASSERT(isMainThread());
1328     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);
1329 
1330     performKeyDataCallback(callbackIdentifier, error, resultKey);
1331 }
1332 
1333 void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
1334 {
1335     ASSERT(isMainThread());
1336     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);
1337 
<span class="line-added">1338     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1339         if (error) {</span>
<span class="line-added">1340             callback(WTFMove(*error), { });</span>
<span class="line-added">1341             return;</span>
<span class="line-added">1342         }</span>
<span class="line-added">1343         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));</span>
<span class="line-added">1344     });</span>
<span class="line-added">1345 }</span>
<span class="line-added">1346 </span>
<span class="line-added">1347 void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)</span>
<span class="line-added">1348 {</span>
1349     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1350     if (!callbackID)
1351         return;
1352 
1353     if (uint64_t indexIdentifier = requestData.indexIdentifier())
1354         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));
1355     else
1356         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));
1357 }
1358 
1359 void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)
1360 {
1361     ASSERT(isMainThread());
1362     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);
1363 
<span class="line-added">1364     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1365         if (error) {</span>
<span class="line-added">1366             callback(WTFMove(*error), { });</span>
<span class="line-added">1367             return;</span>
<span class="line-added">1368         }</span>
<span class="line-added">1369         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));</span>
<span class="line-added">1370     });</span>
<span class="line-added">1371 }</span>
<span class="line-added">1372 </span>
<span class="line-added">1373 void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-added">1374 {</span>
1375     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1376     if (!callbackID)
1377         return;
1378 
1379     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));
1380 }
1381 
1382 void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)
1383 {
1384     ASSERT(!isMainThread());
1385     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);
1386 
1387     ASSERT(m_backingStore);
1388 
1389     IDBGetResult result;
1390     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);
1391 
1392     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));
1393 }
1394 
</pre>
<hr />
<pre>
1422 
1423     IDBGetAllResult result;
1424     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);
1425 
1426     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));
1427 }
1428 
1429 void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)
1430 {
1431     ASSERT(isMainThread());
1432     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);
1433 
1434     performGetAllResultsCallback(callbackIdentifier, error, result);
1435 }
1436 
1437 void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)
1438 {
1439     ASSERT(isMainThread());
1440     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);
1441 
<span class="line-added">1442     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1443         if (error) {</span>
<span class="line-added">1444             callback(WTFMove(*error), { });</span>
<span class="line-added">1445             return;</span>
<span class="line-added">1446         }</span>
<span class="line-added">1447         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));</span>
<span class="line-added">1448     });</span>
<span class="line-added">1449 }</span>
<span class="line-added">1450 </span>
<span class="line-added">1451 void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-added">1452 {</span>
1453     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1454     if (!callbackID)
1455         return;
1456     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));
1457 }
1458 
1459 void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)
1460 {
1461     ASSERT(!isMainThread());
1462     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);
1463 
1464     ASSERT(m_backingStore);
1465     ASSERT(objectStoreIdentifier);
1466 
1467     uint64_t count;
1468     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);
1469 
1470     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));
1471 }
1472 
1473 void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
1474 {
1475     ASSERT(isMainThread());
1476     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);
1477 
1478     performCountCallback(callbackIdentifier, error, count);
1479 }
1480 
1481 void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)
1482 {
1483     ASSERT(isMainThread());
1484     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);
1485 
<span class="line-added">1486     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1487         if (error) {</span>
<span class="line-added">1488             callback(WTFMove(*error));</span>
<span class="line-added">1489             return;</span>
<span class="line-added">1490         }</span>
<span class="line-added">1491         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));</span>
<span class="line-added">1492     });</span>
<span class="line-added">1493 }</span>
<span class="line-added">1494 </span>
<span class="line-added">1495 void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-added">1496 {</span>
1497     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1498     if (!callbackID)
1499         return;
1500     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));
1501 }
1502 
1503 void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
1504 {
1505     ASSERT(!isMainThread());
1506     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);
1507 
1508     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);
1509 
1510     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));
1511 }
1512 
1513 void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)
1514 {
1515     ASSERT(isMainThread());
1516     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);
1517 
1518     performErrorCallback(callbackIdentifier, error);
1519 }
1520 
1521 void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)
1522 {
1523     ASSERT(isMainThread());
1524     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);
1525 
<span class="line-added">1526     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1527         if (error) {</span>
<span class="line-added">1528             callback(WTFMove(*error), { });</span>
<span class="line-added">1529             return;</span>
<span class="line-added">1530         }</span>
<span class="line-added">1531         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));</span>
<span class="line-added">1532     });</span>
<span class="line-added">1533 }</span>
<span class="line-added">1534 </span>
<span class="line-added">1535 void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-added">1536 {</span>
1537     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1538     if (!callbackID)
1539         return;
1540     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));
1541 }
1542 
1543 void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)
1544 {
1545     ASSERT(!isMainThread());
1546     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);
1547 
1548     IDBGetResult result;
1549     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);
1550 
1551     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));
1552 }
1553 
1554 void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1555 {
1556     ASSERT(isMainThread());
1557     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);
1558 
1559     performGetResultCallback(callbackIdentifier, error, result);
1560 }
1561 
1562 void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)
1563 {
1564     ASSERT(isMainThread());
1565     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);
1566 
<span class="line-added">1567     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1568         if (error) {</span>
<span class="line-added">1569             callback(WTFMove(*error), { });</span>
<span class="line-added">1570             return;</span>
<span class="line-added">1571         }</span>
<span class="line-added">1572         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));</span>
<span class="line-added">1573     });</span>
<span class="line-added">1574 }</span>
<span class="line-added">1575 </span>
<span class="line-added">1576 void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-added">1577 {</span>
1578     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1579     if (!callbackID)
1580         return;
1581     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));
1582 }
1583 
1584 void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)
1585 {
1586     ASSERT(!isMainThread());
1587     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);
1588 
1589     IDBGetResult result;
1590     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);
1591 
1592     if (error.isNull()) {
1593         auto addResult = m_cursorPrefetches.add(cursorIdentifier);
1594         if (addResult.isNewEntry)
1595             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1596     }
1597 
</pre>
<hr />
<pre>
1601 void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)
1602 {
1603     ASSERT(!isMainThread());
1604     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));
1605     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);
1606 
1607     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))
1608         m_cursorPrefetches.remove(cursorIdentifier);
1609     else
1610         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));
1611 }
1612 
1613 void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)
1614 {
1615     ASSERT(isMainThread());
1616     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);
1617 
1618     performGetResultCallback(callbackIdentifier, error, result);
1619 }
1620 
<span class="line-modified">1621 bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)</span>
1622 {
1623     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());
1624     if (!takenTransaction)
1625         return false;
1626 
1627     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));
<span class="line-added">1628     takenTransaction-&gt;setState(state);</span>
1629     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));
1630 
1631     return true;
1632 }
1633 
1634 void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)
1635 {
1636     ASSERT(isMainThread());
1637     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1638 
1639     ASSERT(transaction.databaseConnection().database() == this);
1640 
<span class="line-added">1641     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-added">1642         if (error) {</span>
<span class="line-added">1643             callback(WTFMove(*error));</span>
<span class="line-added">1644             return;</span>
<span class="line-added">1645         }</span>
<span class="line-added">1646         if (!transaction) {</span>
<span class="line-added">1647             callback(IDBError { UnknownError });</span>
<span class="line-added">1648             return;</span>
<span class="line-added">1649         }</span>
<span class="line-added">1650         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));</span>
<span class="line-added">1651     });</span>
<span class="line-added">1652 }</span>
<span class="line-added">1653 </span>
<span class="line-added">1654 void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="line-added">1655 {</span>
1656     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1657     if (!callbackID)
1658         return;
1659 
<span class="line-modified">1660     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {</span>
1661         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1662             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.
1663             forgetErrorCallback(callbackID);
1664             return;
1665         }
1666 
1667         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });
1668         return;
1669     }
1670 
1671     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));
1672 }
1673 
1674 void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
1675 {
1676     ASSERT(!isMainThread());
1677     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1678 
1679     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);
1680     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));
1681 }
1682 
1683 void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1684 {
1685     ASSERT(isMainThread());
1686     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1687 
<span class="line-modified">1688     IDBError result = error;</span>
<span class="line-added">1689     auto transaction = m_finishingTransactions.get(transactionIdentifier);</span>
<span class="line-added">1690     switch (transaction-&gt;state()) {</span>
<span class="line-added">1691     case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-added">1692         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };</span>
<span class="line-added">1693         break;</span>
<span class="line-added">1694     case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-added">1695         result = transaction-&gt;result();</span>
<span class="line-added">1696         break;</span>
<span class="line-added">1697     case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-added">1698         break;</span>
<span class="line-added">1699     case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-added">1700     case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-added">1701         ASSERT_NOT_REACHED();</span>
<span class="line-added">1702     }</span>
<span class="line-added">1703 </span>
<span class="line-added">1704     performErrorCallback(callbackIdentifier, result);</span>
1705 
1706     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));
1707 }
1708 
<span class="line-modified">1709 void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)</span>
1710 {
1711     ASSERT(isMainThread());
1712     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());
1713 
1714     ASSERT(transaction.databaseConnection().database() == this);
1715 
<span class="line-added">1716     if (waitForPendingTasks == WaitForPendingTasks::Yes) {</span>
<span class="line-added">1717         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {</span>
<span class="line-added">1718             if (error) {</span>
<span class="line-added">1719                 callback(WTFMove(*error));</span>
<span class="line-added">1720                 return;</span>
<span class="line-added">1721             }</span>
<span class="line-added">1722             if (!transaction) {</span>
<span class="line-added">1723                 callback(IDBError { UnknownError });</span>
<span class="line-added">1724                 return;</span>
<span class="line-added">1725             }</span>
<span class="line-added">1726             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));</span>
<span class="line-added">1727         });</span>
<span class="line-added">1728         return;</span>
<span class="line-added">1729     }</span>
<span class="line-added">1730 </span>
1731     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));
1732     if (!callbackID)
1733         return;
1734 
<span class="line-modified">1735     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {</span>
1736         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {
1737             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.
1738             forgetErrorCallback(callbackID);
1739             return;
1740         }
1741 
1742         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });
1743         return;
1744     }
1745 
1746     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));
1747 }
1748 
1749 void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)
1750 {
1751     ASSERT(isMainThread());
1752     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);
1753 
1754     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);
1755     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);
</pre>
<hr />
<pre>
1769 {
1770     ASSERT(!isMainThread());
1771     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1772 
1773     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);
1774     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));
1775 }
1776 
1777 void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)
1778 {
1779     ASSERT(isMainThread());
1780     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
1781 
1782     auto transaction = m_finishingTransactions.take(transactionIdentifier);
1783     ASSERT(transaction);
1784 
1785     if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
1786         ASSERT(m_versionChangeTransaction == transaction);
1787         ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
1788         ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
<span class="line-modified">1789         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());</span>
1790     }
1791 
<span class="line-modified">1792     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;</span>
<span class="line-added">1793     performErrorCallback(callbackIdentifier, result);</span>
1794 
1795     transactionCompleted(WTFMove(transaction));
1796 }
1797 
1798 void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)
1799 {
1800     if (m_versionChangeTransaction == &amp;transaction)
1801         m_versionChangeTransaction = nullptr;
1802 }
1803 
1804 void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
1805 {
1806     ASSERT(isMainThread());
1807     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1808 
<span class="line-added">1809     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-added">1810         m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added">1811         if (m_hardClosedForUserDelete)</span>
<span class="line-added">1812             maybeFinishHardClose();</span>
<span class="line-added">1813         return;</span>
<span class="line-added">1814     }</span>
<span class="line-added">1815 </span>
1816     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1817     m_openDatabaseConnections.remove(&amp;connection);
1818 
1819     if (m_versionChangeDatabaseConnection == &amp;connection) {
1820         if (m_versionChangeTransaction) {
1821             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));
1822 
1823             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();
1824             if (m_inProgressTransactions.contains(transactionIdentifier)) {
1825                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));
1826                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);
1827             }
1828 
1829             return;
1830         }
1831 
1832         m_versionChangeDatabaseConnection = nullptr;
1833     }
1834 
1835     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;
</pre>
<hr />
<pre>
1875 
1876     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {
1877         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));
1878         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));
1879         return;
1880     }
1881 
1882     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
1883     m_openDatabaseConnections.remove(&amp;connection);
1884 
1885     connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
1886 
1887     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));
1888 }
1889 
1890 void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)
1891 {
1892     ASSERT(isMainThread());
1893     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
1894 
<span class="line-added">1895     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))</span>
<span class="line-added">1896         return;</span>
<span class="line-added">1897     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added">1898 </span>
1899     if (m_hardClosedForUserDelete)
1900         maybeFinishHardClose();


1901 }
1902 
1903 void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
1904 {
1905     LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
1906     ASSERT(!m_hardClosedForUserDelete);
1907 
1908     ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
1909 
1910     m_pendingTransactions.append(WTFMove(transaction));
1911 
1912     invokeOperationAndTransactionTimer();
1913 }
1914 
1915 bool UniqueIDBDatabase::isCurrentlyInUse() const
1916 {
1917     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;
1918 }
1919 
1920 bool UniqueIDBDatabase::hasUnfinishedTransactions() const
</pre>
<hr />
<pre>
2107     if (m_versionChangeTransaction == transaction)
2108         m_versionChangeTransaction = nullptr;
2109 
2110     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.
2111     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.
2112     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {
2113         scheduleShutdownForClose();
2114         return;
2115     }
2116 
2117     // Previously blocked operations might be runnable.
2118     if (!m_hardClosedForUserDelete)
2119         invokeOperationAndTransactionTimer();
2120     else
2121         maybeFinishHardClose();
2122 }
2123 
2124 void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)
2125 {
2126     m_databaseQueue.append(WTFMove(task));
<span class="line-modified">2127     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
2128 }
2129 
2130 void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)
2131 {
<span class="line-added">2132     if (m_backingStore)</span>
<span class="line-added">2133         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-added">2134 </span>
2135     m_databaseReplyQueue.append(WTFMove(task));
<span class="line-modified">2136     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
2137 }
2138 
2139 void UniqueIDBDatabase::executeNextDatabaseTask()
2140 {
2141     ASSERT(!isMainThread());
2142     ASSERT(!m_databaseQueue.isKilled());
2143 
2144     auto task = m_databaseQueue.tryGetMessage();
2145     ASSERT(task);
2146 
2147     task-&gt;performTask();
2148 }
2149 
2150 void UniqueIDBDatabase::executeNextDatabaseTaskReply()
2151 {
2152     ASSERT(isMainThread());
2153     ASSERT(!m_databaseReplyQueue.isKilled());
2154 
2155     auto task = m_databaseReplyQueue.tryGetMessage();
2156     ASSERT(task);
</pre>
<hr />
<pre>
2179 bool UniqueIDBDatabase::isDoneWithHardClose()
2180 {
2181     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();
2182 }
2183 
2184 static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
2185 {
2186     auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
2187     if (request.isOpenRequest())
2188         request.connection().didOpenDatabase(result);
2189     else
2190         request.connection().didDeleteDatabase(result);
2191 }
2192 
2193 void UniqueIDBDatabase::immediateCloseForUserDelete()
2194 {
2195     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());
2196 
2197     ASSERT(isMainThread());
2198 
<span class="line-added">2199     m_pendingSpaceIncreasingTasks.clear();</span>
<span class="line-added">2200     m_server-&gt;resetSpaceUsed(m_identifier.origin());</span>
<span class="line-added">2201 </span>
2202     // Error out all transactions
2203     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
2204         m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
2205 
2206     ASSERT(m_inProgressTransactions.isEmpty());
2207 
2208     for (auto&amp; transaction : m_pendingTransactions)
2209         transaction-&gt;databaseConnection().deleteTransaction(*transaction);
2210     m_pendingTransactions.clear();
2211     m_objectStoreTransactionCounts.clear();
2212     m_objectStoreWriteTransactions.clear();
2213 
2214     // Error out all pending callbacks
2215     IDBError error = IDBError::userDeleteError();
2216     IDBKeyData keyData;
2217     IDBGetResult getResult;
2218     IDBGetAllResult getAllResult;
2219 
2220     while (!m_callbackQueue.isEmpty()) {
2221         auto identifier = m_callbackQueue.first();
</pre>
<hr />
<pre>
2232         else
2233             ASSERT_NOT_REACHED();
2234     }
2235 
2236     // Error out all IDBOpenDBRequests
2237     if (m_currentOpenDBRequest) {
2238         errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
2239         m_currentOpenDBRequest = nullptr;
2240     }
2241 
2242     for (auto&amp; request : m_pendingOpenDBRequests)
2243         errorOpenDBRequestForUserDelete(*request);
2244 
2245     m_pendingOpenDBRequests.clear();
2246 
2247     // Close all open connections
2248     auto openDatabaseConnections = m_openDatabaseConnections;
2249     for (auto&amp; connection : openDatabaseConnections)
2250         connectionClosedFromServer(*connection);
2251 
<span class="line-added">2252     if (m_versionChangeDatabaseConnection) {</span>
<span class="line-added">2253         connectionClosedFromServer(*m_versionChangeDatabaseConnection);</span>
<span class="line-added">2254         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added">2255     }</span>
<span class="line-added">2256 </span>
2257     // Cancel the operation timer
2258     m_operationAndTransactionTimer.stop();
2259 
2260     // Set up the database to remain alive-but-inert until all of its background activity finishes and all
2261     // database connections confirm that they have closed.
2262     m_hardClosedForUserDelete = true;
2263 
2264     // If this database already owns itself, it is already closing on the background thread.
2265     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;
2266     // which will also cover this database.
2267     if (m_owningPointerForClose)
2268         return;
2269 
2270     // Otherwise, this database is still potentially active.
2271     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.
<span class="line-modified">2272     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
2273     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));
2274 }
2275 
<span class="line-added">2276 void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)</span>
<span class="line-added">2277 {</span>
<span class="line-added">2278     ASSERT(isMainThread());</span>
<span class="line-added">2279 </span>
<span class="line-added">2280     if (optionalCallbackIdentifier) {</span>
<span class="line-added">2281         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();</span>
<span class="line-added">2282         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);</span>
<span class="line-added">2283         if (iterator != m_pendingSpaceIncreasingTasks.end()) {</span>
<span class="line-added">2284             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);</span>
<span class="line-added">2285             m_pendingSpaceIncreasingTasks.remove(iterator);</span>
<span class="line-added">2286         }</span>
<span class="line-added">2287     }</span>
<span class="line-added">2288 </span>
<span class="line-added">2289     uint64_t databaseSize = m_newDatabaseSize;</span>
<span class="line-added">2290     if (databaseSize != m_currentDatabaseSize) {</span>
<span class="line-added">2291         if (databaseSize &gt; m_currentDatabaseSize)</span>
<span class="line-added">2292             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);</span>
<span class="line-added">2293         else</span>
<span class="line-added">2294             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);</span>
<span class="line-added">2295         m_currentDatabaseSize = databaseSize;</span>
<span class="line-added">2296     }</span>
<span class="line-added">2297 }</span>
<span class="line-added">2298 </span>
2299 void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)
2300 {
<span class="line-added">2301     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2302 </span>
2303     auto callback = m_errorCallbacks.take(callbackIdentifier);
2304     ASSERT(callback || m_hardClosedForUserDelete);
2305     if (callback) {
2306         callback(error);
2307         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2308         m_callbackQueue.removeFirst();
2309     }
2310 }
2311 
2312 void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)
2313 {
<span class="line-added">2314     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2315 </span>
2316     auto callback = m_keyDataCallbacks.take(callbackIdentifier);
2317     ASSERT(callback || m_hardClosedForUserDelete);
2318     if (callback) {
2319         callback(error, resultKey);
2320         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2321         m_callbackQueue.removeFirst();
2322     }
2323 }
2324 
2325 void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)
2326 {
2327     auto callback = m_getResultCallbacks.take(callbackIdentifier);
2328     ASSERT(callback || m_hardClosedForUserDelete);
2329     if (callback) {
2330         callback(error, resultData);
2331         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2332         m_callbackQueue.removeFirst();
2333     }
2334 }
2335 
</pre>
<hr />
<pre>
2340     if (callback) {
2341         callback(error, resultData);
2342         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2343         m_callbackQueue.removeFirst();
2344     }
2345 }
2346 
2347 void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)
2348 {
2349     auto callback = m_countCallbacks.take(callbackIdentifier);
2350     ASSERT(callback || m_hardClosedForUserDelete);
2351     if (callback) {
2352         callback(error, count);
2353         ASSERT(m_callbackQueue.first() == callbackIdentifier);
2354         m_callbackQueue.removeFirst();
2355     }
2356 }
2357 
2358 void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)
2359 {
<span class="line-added">2360     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-added">2361 </span>
2362     ASSERT(m_errorCallbacks.contains(callbackIdentifier));
2363     ASSERT(m_callbackQueue.last() == callbackIdentifier);
2364     m_callbackQueue.removeLast();
2365     m_errorCallbacks.remove(callbackIdentifier);
2366 }
2367 
<span class="line-modified">2368 void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
2369 {
<span class="line-modified">2370     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));</span>
<span class="line-modified">2371     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);</span>
<span class="line-added">2372 }</span>
<span class="line-added">2373 </span>
<span class="line-added">2374 void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="line-added">2375 {</span>
<span class="line-added">2376     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));</span>
<span class="line-added">2377     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);</span>
<span class="line-added">2378 }</span>
<span class="line-added">2379 </span>
<span class="line-added">2380 void UniqueIDBDatabase::finishActiveTransactions()</span>
<span class="line-added">2381 {</span>
<span class="line-added">2382     ASSERT(isMainThread());</span>
<span class="line-added">2383 </span>
<span class="line-added">2384     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-added">2385         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-added">2386         abortTransactionOnMainThread(*transaction);</span>
<span class="line-added">2387     }</span>
<span class="line-added">2388 </span>
<span class="line-added">2389     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {</span>
<span class="line-added">2390         if (!m_backingStore-&gt;hasTransaction(identifier))</span>
<span class="line-added">2391             continue;</span>
<span class="line-added">2392 </span>
<span class="line-added">2393         auto transaction = m_finishingTransactions.get(identifier);</span>
<span class="line-added">2394         switch (transaction-&gt;state()) {</span>
<span class="line-added">2395         case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-added">2396             abortTransactionOnMainThread(*transaction);</span>
<span class="line-added">2397             break;</span>
<span class="line-added">2398         case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-added">2399             commitTransactionOnMainThread(*transaction);</span>
<span class="line-added">2400             break;</span>
<span class="line-added">2401         case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-added">2402         case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-added">2403         case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-added">2404             ASSERT_NOT_REACHED();</span>
<span class="line-added">2405         }</span>
<span class="line-added">2406     }</span>
2407 }
2408 
2409 } // namespace IDBServer
2410 } // namespace WebCore
2411 
2412 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="SQLiteIDBTransaction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>