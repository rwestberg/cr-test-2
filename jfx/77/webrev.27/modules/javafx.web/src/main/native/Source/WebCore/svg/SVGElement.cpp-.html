<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3  * Copyright (C) 2004, 2005, 2006, 2008 Rob Buis &lt;buis@kde.org&gt;
   4  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
   5  * Copyright (C) 2008 Alp Toker &lt;alp@atoker.com&gt;
   6  * Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   7  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
   8  * Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public License
  21  * along with this library; see the file COPYING.LIB.  If not, write to
  22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;SVGElement.h&quot;
  28 
  29 #include &quot;CSSPropertyParser.h&quot;
  30 #include &quot;DeprecatedCSSOMValue.h&quot;
  31 #include &quot;Document.h&quot;
  32 #include &quot;ElementIterator.h&quot;
  33 #include &quot;Event.h&quot;
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;
  47 #include &quot;SVGRenderStyle.h&quot;
  48 #include &quot;SVGRenderSupport.h&quot;
  49 #include &quot;SVGSVGElement.h&quot;
  50 #include &quot;SVGTitleElement.h&quot;
  51 #include &quot;SVGUseElement.h&quot;
  52 #include &quot;ShadowRoot.h&quot;
  53 #include &quot;XMLNames.h&quot;
  54 #include &lt;wtf/Assertions.h&gt;
  55 #include &lt;wtf/HashMap.h&gt;
  56 #include &lt;wtf/IsoMallocInlines.h&gt;
  57 #include &lt;wtf/NeverDestroyed.h&gt;
  58 #include &lt;wtf/StdLibExtras.h&gt;
  59 #include &lt;wtf/text/WTFString.h&gt;
  60 
  61 
  62 namespace WebCore {
  63 
  64 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  65 
  66 static NEVER_INLINE HashMap&lt;AtomicStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()
  67 {
  68     using namespace HTMLNames;
  69     using namespace SVGNames;
  70 
  71     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  72     static const QualifiedName* const attributeNames[] = {
  73         &amp;alignment_baselineAttr.get(),
  74         &amp;baseline_shiftAttr.get(),
  75         &amp;buffered_renderingAttr.get(),
  76         &amp;clipAttr.get(),
  77         &amp;clip_pathAttr.get(),
  78         &amp;clip_ruleAttr.get(),
  79         &amp;SVGNames::colorAttr.get(),
  80         &amp;color_interpolationAttr.get(),
  81         &amp;color_interpolation_filtersAttr.get(),
  82         &amp;color_profileAttr.get(),
  83         &amp;color_renderingAttr.get(),
  84         &amp;cursorAttr.get(),
  85         &amp;cxAttr.get(),
  86         &amp;cyAttr.get(),
  87         &amp;SVGNames::directionAttr.get(),
  88         &amp;displayAttr.get(),
  89         &amp;dominant_baselineAttr.get(),
  90         &amp;enable_backgroundAttr.get(),
  91         &amp;fillAttr.get(),
  92         &amp;fill_opacityAttr.get(),
  93         &amp;fill_ruleAttr.get(),
  94         &amp;filterAttr.get(),
  95         &amp;flood_colorAttr.get(),
  96         &amp;flood_opacityAttr.get(),
  97         &amp;font_familyAttr.get(),
  98         &amp;font_sizeAttr.get(),
  99         &amp;font_stretchAttr.get(),
 100         &amp;font_styleAttr.get(),
 101         &amp;font_variantAttr.get(),
 102         &amp;font_weightAttr.get(),
 103         &amp;glyph_orientation_horizontalAttr.get(),
 104         &amp;glyph_orientation_verticalAttr.get(),
 105         &amp;image_renderingAttr.get(),
 106         &amp;SVGNames::heightAttr.get(),
 107         &amp;kerningAttr.get(),
 108         &amp;letter_spacingAttr.get(),
 109         &amp;lighting_colorAttr.get(),
 110         &amp;marker_endAttr.get(),
 111         &amp;marker_midAttr.get(),
 112         &amp;marker_startAttr.get(),
 113         &amp;maskAttr.get(),
 114         &amp;mask_typeAttr.get(),
 115         &amp;opacityAttr.get(),
 116         &amp;overflowAttr.get(),
 117         &amp;paint_orderAttr.get(),
 118         &amp;pointer_eventsAttr.get(),
 119         &amp;rAttr.get(),
 120         &amp;rxAttr.get(),
 121         &amp;ryAttr.get(),
 122         &amp;shape_renderingAttr.get(),
 123         &amp;stop_colorAttr.get(),
 124         &amp;stop_opacityAttr.get(),
 125         &amp;strokeAttr.get(),
 126         &amp;stroke_dasharrayAttr.get(),
 127         &amp;stroke_dashoffsetAttr.get(),
 128         &amp;stroke_linecapAttr.get(),
 129         &amp;stroke_linejoinAttr.get(),
 130         &amp;stroke_miterlimitAttr.get(),
 131         &amp;stroke_opacityAttr.get(),
 132         &amp;stroke_widthAttr.get(),
 133         &amp;text_anchorAttr.get(),
 134         &amp;text_decorationAttr.get(),
 135         &amp;text_renderingAttr.get(),
 136         &amp;unicode_bidiAttr.get(),
 137         &amp;vector_effectAttr.get(),
 138         &amp;visibilityAttr.get(),
 139         &amp;SVGNames::widthAttr.get(),
 140         &amp;word_spacingAttr.get(),
 141         &amp;writing_modeAttr.get(),
 142         &amp;xAttr.get(),
 143         &amp;yAttr.get(),
 144     };
 145 
 146     HashMap&lt;AtomicStringImpl*, CSSPropertyID&gt; map;
 147 
 148     for (auto&amp; name : attributeNames) {
 149         const AtomicString&amp; localName = name-&gt;localName();
 150         map.add(localName.impl(), cssPropertyID(localName));
 151     }
 152 
 153     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 154     // and we can add transform_originAttr to the table above instead.
 155     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 156 
 157     return map;
 158 }
 159 
 160 static NEVER_INLINE HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; createAttributeNameToAnimatedPropertyTypeMap()
 161 {
 162     using namespace HTMLNames;
 163     using namespace SVGNames;
 164 
 165     struct TableEntry {
 166         const QualifiedName&amp; attributeName;
 167         AnimatedPropertyType type;
 168     };
 169 
 170     static const TableEntry table[] = {
 171         { alignment_baselineAttr, AnimatedString },
 172         { baseline_shiftAttr, AnimatedString },
 173         { buffered_renderingAttr, AnimatedString },
 174         { clipAttr, AnimatedRect },
 175         { clip_pathAttr, AnimatedString },
 176         { clip_ruleAttr, AnimatedString },
 177         { SVGNames::colorAttr, AnimatedColor },
 178         { color_interpolationAttr, AnimatedString },
 179         { color_interpolation_filtersAttr, AnimatedString },
 180         { color_profileAttr, AnimatedString },
 181         { color_renderingAttr, AnimatedString },
 182         { cursorAttr, AnimatedString },
 183         { displayAttr, AnimatedString },
 184         { dominant_baselineAttr, AnimatedString },
 185         { fillAttr, AnimatedColor },
 186         { fill_opacityAttr, AnimatedNumber },
 187         { fill_ruleAttr, AnimatedString },
 188         { filterAttr, AnimatedString },
 189         { flood_colorAttr, AnimatedColor },
 190         { flood_opacityAttr, AnimatedNumber },
 191         { font_familyAttr, AnimatedString },
 192         { font_sizeAttr, AnimatedLength },
 193         { font_stretchAttr, AnimatedString },
 194         { font_styleAttr, AnimatedString },
 195         { font_variantAttr, AnimatedString },
 196         { font_weightAttr, AnimatedString },
 197         { image_renderingAttr, AnimatedString },
 198         { kerningAttr, AnimatedLength },
 199         { letter_spacingAttr, AnimatedLength },
 200         { lighting_colorAttr, AnimatedColor },
 201         { marker_endAttr, AnimatedString },
 202         { marker_midAttr, AnimatedString },
 203         { marker_startAttr, AnimatedString },
 204         { maskAttr, AnimatedString },
 205         { mask_typeAttr, AnimatedString },
 206         { opacityAttr, AnimatedNumber },
 207         { overflowAttr, AnimatedString },
 208         { paint_orderAttr, AnimatedString },
 209         { pointer_eventsAttr, AnimatedString },
 210         { shape_renderingAttr, AnimatedString },
 211         { stop_colorAttr, AnimatedColor },
 212         { stop_opacityAttr, AnimatedNumber },
 213         { strokeAttr, AnimatedColor },
 214         { stroke_dasharrayAttr, AnimatedLengthList },
 215         { stroke_dashoffsetAttr, AnimatedLength },
 216         { stroke_linecapAttr, AnimatedString },
 217         { stroke_linejoinAttr, AnimatedString },
 218         { stroke_miterlimitAttr, AnimatedNumber },
 219         { stroke_opacityAttr, AnimatedNumber },
 220         { stroke_widthAttr, AnimatedLength },
 221         { text_anchorAttr, AnimatedString },
 222         { text_decorationAttr, AnimatedString },
 223         { text_renderingAttr, AnimatedString },
 224         { vector_effectAttr, AnimatedString },
 225         { visibilityAttr, AnimatedString },
 226         { word_spacingAttr, AnimatedLength },
 227     };
 228 
 229     HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; map;
 230     for (auto&amp; entry : table)
 231         map.add(entry.attributeName.impl(), entry.type);
 232     return map;
 233 }
 234 
 235 static const HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt;&amp; attributeNameToAnimatedPropertyTypeMap()
 236 {
 237     static const auto map = makeNeverDestroyed(createAttributeNameToAnimatedPropertyTypeMap());
 238     return map;
 239 }
 240 
 241 static NEVER_INLINE HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; createCSSPropertyWithSVGDOMNameToAnimatedPropertyTypeMap()
 242 {
 243     using namespace HTMLNames;
 244     using namespace SVGNames;
 245 
 246     struct TableEntry {
 247         const QualifiedName&amp; attributeName;
 248         AnimatedPropertyType type;
 249     };
 250 
 251     static const TableEntry table[] = {
 252         { cxAttr, AnimatedLength },
 253         { cyAttr, AnimatedLength },
 254         { rAttr, AnimatedLength },
 255         { rxAttr, AnimatedLength },
 256         { ryAttr, AnimatedLength },
 257         { SVGNames::heightAttr, AnimatedLength },
 258         { SVGNames::widthAttr, AnimatedLength },
 259         { xAttr, AnimatedLength },
 260         { yAttr, AnimatedLength },
 261     };
 262 
 263     HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt; map;
 264     for (auto&amp; entry : table)
 265         map.add(entry.attributeName.impl(), entry.type);
 266     return map;
 267 }
 268 
 269 static inline const HashMap&lt;QualifiedName::QualifiedNameImpl*, AnimatedPropertyType&gt;&amp; cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap()
 270 {
 271     static const auto map = makeNeverDestroyed(createCSSPropertyWithSVGDOMNameToAnimatedPropertyTypeMap());
 272     return map;
 273 }
 274 
 275 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 276     : StyledElement(tagName, document, CreateSVGElement)
 277     , SVGLangSpace(this)
 278 {
 279     registerAttributes();
 280 }
 281 
 282 SVGElement::~SVGElement()
 283 {
 284     if (m_svgRareData) {
 285         for (SVGElement* instance : m_svgRareData-&gt;instances())
 286             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 287         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 288             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 289 
 290         m_svgRareData = nullptr;
 291     }
 292     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 293     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 294 }
 295 
 296 int SVGElement::tabIndex() const
 297 {
 298     if (supportsFocus())
 299         return Element::tabIndex();
 300     return -1;
 301 }
 302 
 303 void SVGElement::willRecalcStyle(Style::Change change)
 304 {
 305     if (!m_svgRareData || styleResolutionShouldRecompositeLayer())
 306         return;
 307     // If the style changes because of a regular property change (not induced by SMIL animations themselves)
 308     // reset the &quot;computed style without SMIL style properties&quot;, so the base value change gets reflected.
 309     if (change &gt; Style::NoChange || needsStyleRecalc())
 310         m_svgRareData-&gt;setNeedsOverrideComputedStyleUpdate();
 311 }
 312 
 313 SVGElementRareData&amp; SVGElement::ensureSVGRareData()
 314 {
 315     if (!m_svgRareData)
 316         m_svgRareData = std::make_unique&lt;SVGElementRareData&gt;();
 317     return *m_svgRareData;
 318 }
 319 
 320 bool SVGElement::isOutermostSVGSVGElement() const
 321 {
 322     if (!is&lt;SVGSVGElement&gt;(*this))
 323         return false;
 324 
 325     // If we&#39;re living in a shadow tree, we&#39;re a &lt;svg&gt; element that got created as replacement
 326     // for a &lt;symbol&gt; element or a cloned &lt;svg&gt; element in the referenced tree. In that case
 327     // we&#39;re always an inner &lt;svg&gt; element.
 328     if (isInShadowTree() &amp;&amp; parentOrShadowHostElement() &amp;&amp; parentOrShadowHostElement()-&gt;isSVGElement())
 329         return false;
 330 
 331     // Element may not be in the document, pretend we&#39;re outermost for viewport(), getCTM(), etc.
 332     if (!parentNode())
 333         return true;
 334 
 335     // We act like an outermost SVG element, if we&#39;re a direct child of a &lt;foreignObject&gt; element.
 336     if (parentNode()-&gt;hasTagName(SVGNames::foreignObjectTag))
 337         return true;
 338 
 339     // This is true whenever this is the outermost SVG, even if there are HTML elements outside it
 340     return !parentNode()-&gt;isSVGElement();
 341 }
 342 
 343 void SVGElement::reportAttributeParsingError(SVGParsingError error, const QualifiedName&amp; name, const AtomicString&amp; value)
 344 {
 345     if (error == NoError)
 346         return;
 347 
 348     String errorString = &quot;&lt;&quot; + tagName() + &quot;&gt; attribute &quot; + name.toString() + &quot;=\&quot;&quot; + value + &quot;\&quot;&quot;;
 349     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 350 
 351     if (error == NegativeValueForbiddenError) {
 352         extensions.reportError(&quot;Invalid negative value for &quot; + errorString);
 353         return;
 354     }
 355 
 356     if (error == ParsingAttributeFailedError) {
 357         extensions.reportError(&quot;Invalid value for &quot; + errorString);
 358         return;
 359     }
 360 
 361     ASSERT_NOT_REACHED();
 362 }
 363 
 364 void SVGElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 365 {
 366     if (removalType.disconnectedFromDocument)
 367         updateRelativeLengthsInformation(false, this);
 368 
 369     StyledElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 370 
 371     if (removalType.disconnectedFromDocument) {
 372         document().accessSVGExtensions().clearTargetDependencies(*this);
 373         document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
 374     }
 375     invalidateInstances();
 376 }
 377 
 378 SVGSVGElement* SVGElement::ownerSVGElement() const
 379 {
 380     ContainerNode* node = parentOrShadowHostNode();
 381     while (node) {
 382         if (is&lt;SVGSVGElement&gt;(*node))
 383             return downcast&lt;SVGSVGElement&gt;(node);
 384 
 385         node = node-&gt;parentOrShadowHostNode();
 386     }
 387 
 388     return nullptr;
 389 }
 390 
 391 SVGElement* SVGElement::viewportElement() const
 392 {
 393     // This function needs shadow tree support - as RenderSVGContainer uses this function
 394     // to determine the &quot;overflow&quot; property. &lt;use&gt; on &lt;symbol&gt; wouldn&#39;t work otherwhise.
 395     ContainerNode* node = parentOrShadowHostNode();
 396     while (node) {
 397         if (is&lt;SVGSVGElement&gt;(*node) || is&lt;SVGImageElement&gt;(*node) || node-&gt;hasTagName(SVGNames::symbolTag))
 398             return downcast&lt;SVGElement&gt;(node);
 399 
 400         node = node-&gt;parentOrShadowHostNode();
 401     }
 402 
 403     return nullptr;
 404 }
 405 
 406 const HashSet&lt;SVGElement*&gt;&amp; SVGElement::instances() const
 407 {
 408     if (!m_svgRareData) {
 409         static NeverDestroyed&lt;HashSet&lt;SVGElement*&gt;&gt; emptyInstances;
 410         return emptyInstances;
 411     }
 412     return m_svgRareData-&gt;instances();
 413 }
 414 
 415 bool SVGElement::getBoundingBox(FloatRect&amp; rect, SVGLocatable::StyleUpdateStrategy styleUpdateStrategy)
 416 {
 417     if (is&lt;SVGGraphicsElement&gt;(*this)) {
 418         rect = downcast&lt;SVGGraphicsElement&gt;(*this).getBBox(styleUpdateStrategy);
 419         return true;
 420     }
 421     return false;
 422 }
 423 
 424 SVGElement* SVGElement::correspondingElement() const
 425 {
 426     return m_svgRareData ? m_svgRareData-&gt;correspondingElement() : nullptr;
 427 }
 428 
 429 RefPtr&lt;SVGUseElement&gt; SVGElement::correspondingUseElement() const
 430 {
 431     auto* root = containingShadowRoot();
 432     if (!root)
 433         return nullptr;
 434     if (root-&gt;mode() != ShadowRootMode::UserAgent)
 435         return nullptr;
 436     auto* host = root-&gt;host();
 437     if (!is&lt;SVGUseElement&gt;(host))
 438         return nullptr;
 439     return &amp;downcast&lt;SVGUseElement&gt;(*host);
 440 }
 441 
 442 void SVGElement::setCorrespondingElement(SVGElement* correspondingElement)
 443 {
 444     if (m_svgRareData) {
 445         if (auto oldCorrespondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 446             oldCorrespondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 447     }
 448     if (m_svgRareData || correspondingElement)
 449         ensureSVGRareData().setCorrespondingElement(correspondingElement);
 450     if (correspondingElement)
 451         correspondingElement-&gt;ensureSVGRareData().instances().add(this);
 452 }
 453 
 454 void SVGElement::registerAttributes()
 455 {
 456     auto&amp; registry = attributeRegistry();
 457     if (!registry.isEmpty())
 458         return;
 459     registry.registerAttribute&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
 460 }
 461 
 462 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)
 463 {
 464     if (name == HTMLNames::classAttr) {
 465         m_className.setValue(value);
 466         return;
 467     }
 468 
 469     if (name == HTMLNames::tabindexAttr) {
 470         if (value.isEmpty())
 471             clearTabIndexExplicitlyIfNeeded();
 472         else if (auto optionalTabIndex = parseHTMLInteger(value))
 473             setTabIndexExplicitly(optionalTabIndex.value());
 474         return;
 475     }
 476 
 477     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 478     if (!eventName.isNull()) {
 479         setAttributeEventListener(eventName, name, value);
 480         return;
 481     }
 482 
 483     SVGLangSpace::parseAttribute(name, value);
 484 }
 485 
 486 Vector&lt;AnimatedPropertyType&gt; SVGElement::animatedPropertyTypesForAttribute(const QualifiedName&amp; attributeName)
 487 {
 488     auto types = animatedTypes(attributeName);
 489     if (!types.isEmpty())
 490         return types;
 491 
 492     {
 493         auto&amp; map = attributeNameToAnimatedPropertyTypeMap();
 494         auto it = map.find(attributeName.impl());
 495         if (it != map.end()) {
 496             types.append(it-&gt;value);
 497             return types;
 498         }
 499     }
 500 
 501     {
 502         auto&amp; map = cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap();
 503         auto it = map.find(attributeName.impl());
 504         if (it != map.end()) {
 505             types.append(it-&gt;value);
 506             return types;
 507         }
 508     }
 509 
 510     return types;
 511 }
 512 
 513 bool SVGElement::haveLoadedRequiredResources()
 514 {
 515     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 516         if (!child.haveLoadedRequiredResources())
 517             return false;
 518     }
 519     return true;
 520 }
 521 
 522 bool SVGElement::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
 523 {
 524     // Add event listener to regular DOM element
 525     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 526         return false;
 527 
 528     if (containingShadowRoot())
 529         return true;
 530 
 531     // Add event listener to all shadow tree DOM element instances
 532     ASSERT(!instanceUpdatesBlocked());
 533     for (auto* instance : instances()) {
 534         ASSERT(instance-&gt;correspondingElement() == this);
 535         bool result = instance-&gt;Node::addEventListener(eventType, listener.copyRef(), options);
 536         ASSERT_UNUSED(result, result);
 537     }
 538 
 539     return true;
 540 }
 541 
 542 bool SVGElement::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
 543 {
 544     if (containingShadowRoot())
 545         return Node::removeEventListener(eventType, listener, options);
 546 
 547     // EventTarget::removeEventListener creates a Ref around the given EventListener
 548     // object when creating a temporary RegisteredEventListener object used to look up the
 549     // event listener in a cache. If we want to be able to call removeEventListener() multiple
 550     // times on different nodes, we have to delay its immediate destruction, which would happen
 551     // after the first call below.
 552     Ref&lt;EventListener&gt; protector(listener);
 553 
 554     // Remove event listener from regular DOM element
 555     if (!Node::removeEventListener(eventType, listener, options))
 556         return false;
 557 
 558     // Remove event listener from all shadow tree DOM element instances
 559     ASSERT(!instanceUpdatesBlocked());
 560     for (auto&amp; instance : instances()) {
 561         ASSERT(instance-&gt;correspondingElement() == this);
 562 
 563         if (instance-&gt;Node::removeEventListener(eventType, listener, options))
 564             continue;
 565 
 566         // This case can only be hit for event listeners created from markup
 567         ASSERT(listener.wasCreatedFromMarkup());
 568 
 569         // If the event listener &#39;listener&#39; has been created from markup and has been fired before
 570         // then JSLazyEventListener::parseCode() has been called and m_jsFunction of that listener
 571         // has been created (read: it&#39;s not 0 anymore). During shadow tree creation, the event
 572         // listener DOM attribute has been cloned, and another event listener has been setup in
 573         // the shadow tree. If that event listener has not been used yet, m_jsFunction is still 0,
 574         // and tryRemoveEventListener() above will fail. Work around that very rare problem.
 575         ASSERT(instance-&gt;eventTargetData());
 576         instance-&gt;eventTargetData()-&gt;eventListenerMap.removeFirstEventListenerCreatedFromMarkup(eventType);
 577     }
 578 
 579     return true;
 580 }
 581 
 582 static bool hasLoadListener(Element* element)
 583 {
 584     if (element-&gt;hasEventListeners(eventNames().loadEvent))
 585         return true;
 586 
 587     for (element = element-&gt;parentOrShadowHostElement(); element; element = element-&gt;parentOrShadowHostElement()) {
 588         if (element-&gt;hasCapturingEventListeners(eventNames().loadEvent))
 589             return true;
 590     }
 591 
 592     return false;
 593 }
 594 
 595 void SVGElement::sendSVGLoadEventIfPossible(bool sendParentLoadEvents)
 596 {
 597     if (!isConnected() || !document().frame())
 598         return;
 599 
 600     RefPtr&lt;SVGElement&gt; currentTarget = this;
 601     while (currentTarget &amp;&amp; currentTarget-&gt;haveLoadedRequiredResources()) {
 602         RefPtr&lt;Element&gt; parent;
 603         if (sendParentLoadEvents)
 604             parent = currentTarget-&gt;parentOrShadowHostElement(); // save the next parent to dispatch too incase dispatching the event changes the tree
 605         if (hasLoadListener(currentTarget.get()))
 606             currentTarget-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 607         currentTarget = (parent &amp;&amp; parent-&gt;isSVGElement()) ? static_pointer_cast&lt;SVGElement&gt;(parent) : RefPtr&lt;SVGElement&gt;();
 608         SVGElement* element = currentTarget.get();
 609         if (!element || !element-&gt;isOutermostSVGSVGElement())
 610             continue;
 611 
 612         // Consider &lt;svg onload=&quot;foo()&quot;&gt;&lt;image xlink:href=&quot;foo.png&quot; externalResourcesRequired=&quot;true&quot;/&gt;&lt;/svg&gt;.
 613         // If foo.png is not yet loaded, the first SVGLoad event will go to the &lt;svg&gt; element, sent through
 614         // Document::implicitClose(). Then the SVGLoad event will fire for &lt;image&gt;, once its loaded.
 615         ASSERT(sendParentLoadEvents);
 616 
 617         // If the load event was not sent yet by Document::implicitClose(), but the &lt;image&gt; from the example
 618         // above, just appeared, don&#39;t send the SVGLoad event to the outermost &lt;svg&gt;, but wait for the document
 619         // to be &quot;ready to render&quot;, first.
 620         if (!document().loadEventFinished())
 621             break;
 622     }
 623 }
 624 
 625 void SVGElement::sendSVGLoadEventIfPossibleAsynchronously()
 626 {
 627     svgLoadEventTimer()-&gt;startOneShot(0_s);
 628 }
 629 
 630 void SVGElement::svgLoadEventTimerFired()
 631 {
 632     sendSVGLoadEventIfPossible();
 633 }
 634 
 635 Timer* SVGElement::svgLoadEventTimer()
 636 {
 637     ASSERT_NOT_REACHED();
 638     return nullptr;
 639 }
 640 
 641 void SVGElement::finishParsingChildren()
 642 {
 643     StyledElement::finishParsingChildren();
 644 
 645     // The outermost SVGSVGElement SVGLoad event is fired through Document::dispatchWindowLoadEvent.
 646     if (isOutermostSVGSVGElement())
 647         return;
 648 
 649     // finishParsingChildren() is called when the close tag is reached for an element (e.g. &lt;/svg&gt;)
 650     // we send SVGLoad events here if we can, otherwise they&#39;ll be sent when any required loads finish
 651     sendSVGLoadEventIfPossible();
 652 
 653     // Notify all the elements which have references to this element to rebuild their shadow and render
 654     // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
 655     invalidateInstances();
 656 }
 657 
 658 bool SVGElement::childShouldCreateRenderer(const Node&amp; child) const
 659 {
 660     if (!child.isSVGElement())
 661         return false;
 662     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 663 
 664     static const QualifiedName* const invalidTextContent[] {
 665 #if ENABLE(SVG_FONTS)
 666         &amp;SVGNames::altGlyphTag.get(),
 667 #endif
 668         &amp;SVGNames::textPathTag.get(),
 669         &amp;SVGNames::trefTag.get(),
 670         &amp;SVGNames::tspanTag.get(),
 671     };
 672     auto&amp; name = svgChild.localName();
 673     for (auto* tag : invalidTextContent) {
 674         if (name == tag-&gt;localName())
 675             return false;
 676     }
 677 
 678     return svgChild.isValid();
 679 }
 680 
 681 void SVGElement::attributeChanged(const QualifiedName&amp; name, const AtomicString&amp; oldValue, const AtomicString&amp; newValue, AttributeModificationReason)
 682 {
 683     StyledElement::attributeChanged(name, oldValue, newValue);
 684 
 685     if (name == HTMLNames::idAttr)
 686         document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 687 
 688     // Changes to the style attribute are processed lazily (see Element::getAttribute() and related methods),
 689     // so we don&#39;t want changes to the style attribute to result in extra work here except invalidateInstances().
 690     if (name == HTMLNames::styleAttr)
 691         invalidateInstances();
 692     else
 693         svgAttributeChanged(name);
 694 }
 695 
 696 void SVGElement::synchronizeAllAnimatedSVGAttribute(SVGElement* svgElement)
 697 {
 698     ASSERT(svgElement-&gt;elementData());
 699     ASSERT(svgElement-&gt;elementData()-&gt;animatedSVGAttributesAreDirty());
 700 
 701     svgElement-&gt;synchronizeAttributes();
 702     svgElement-&gt;elementData()-&gt;setAnimatedSVGAttributesAreDirty(false);
 703 }
 704 
 705 void SVGElement::synchronizeAnimatedSVGAttribute(const QualifiedName&amp; name) const
 706 {
 707     if (!elementData() || !elementData()-&gt;animatedSVGAttributesAreDirty())
 708         return;
 709 
 710     SVGElement* nonConstThis = const_cast&lt;SVGElement*&gt;(this);
 711     if (name == anyQName())
 712         synchronizeAllAnimatedSVGAttribute(nonConstThis);
 713     else
 714         nonConstThis-&gt;synchronizeAttribute(name);
 715 }
 716 
 717 Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)
 718 {
 719     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 720     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
 721         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);
 722         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);
 723         return style;
 724     }
 725 
 726     return resolveStyle(&amp;parentStyle);
 727 }
 728 
 729 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 730 {
 731     if (m_svgRareData)
 732         return m_svgRareData-&gt;animatedSMILStyleProperties();
 733     return 0;
 734 }
 735 
 736 MutableStyleProperties&amp; SVGElement::ensureAnimatedSMILStyleProperties()
 737 {
 738     return ensureSVGRareData().ensureAnimatedSMILStyleProperties();
 739 }
 740 
 741 void SVGElement::setUseOverrideComputedStyle(bool value)
 742 {
 743     if (m_svgRareData)
 744         m_svgRareData-&gt;setUseOverrideComputedStyle(value);
 745 }
 746 
 747 const RenderStyle* SVGElement::computedStyle(PseudoId pseudoElementSpecifier)
 748 {
 749     if (!m_svgRareData || !m_svgRareData-&gt;useOverrideComputedStyle())
 750         return Element::computedStyle(pseudoElementSpecifier);
 751 
 752     const RenderStyle* parentStyle = nullptr;
 753     if (auto parent = makeRefPtr(parentOrShadowHostElement())) {
 754         if (auto renderer = parent-&gt;renderer())
 755             parentStyle = &amp;renderer-&gt;style();
 756     }
 757 
 758     return m_svgRareData-&gt;overrideComputedStyle(*this, parentStyle);
 759 }
 760 
 761 QualifiedName SVGElement::animatableAttributeForName(const AtomicString&amp; localName)
 762 {
 763     static const auto animatableAttributes = makeNeverDestroyed([] {
 764         static const QualifiedName* const names[] = {
 765             &amp;HTMLNames::classAttr.get(),
 766             &amp;SVGNames::amplitudeAttr.get(),
 767             &amp;SVGNames::azimuthAttr.get(),
 768             &amp;SVGNames::baseFrequencyAttr.get(),
 769             &amp;SVGNames::biasAttr.get(),
 770             &amp;SVGNames::clipPathUnitsAttr.get(),
 771             &amp;SVGNames::cxAttr.get(),
 772             &amp;SVGNames::cyAttr.get(),
 773             &amp;SVGNames::diffuseConstantAttr.get(),
 774             &amp;SVGNames::divisorAttr.get(),
 775             &amp;SVGNames::dxAttr.get(),
 776             &amp;SVGNames::dyAttr.get(),
 777             &amp;SVGNames::edgeModeAttr.get(),
 778             &amp;SVGNames::elevationAttr.get(),
 779             &amp;SVGNames::exponentAttr.get(),
 780             &amp;SVGNames::externalResourcesRequiredAttr.get(),
 781             &amp;SVGNames::filterUnitsAttr.get(),
 782             &amp;SVGNames::fxAttr.get(),
 783             &amp;SVGNames::fyAttr.get(),
 784             &amp;SVGNames::gradientTransformAttr.get(),
 785             &amp;SVGNames::gradientUnitsAttr.get(),
 786             &amp;SVGNames::heightAttr.get(),
 787             &amp;SVGNames::in2Attr.get(),
 788             &amp;SVGNames::inAttr.get(),
 789             &amp;SVGNames::interceptAttr.get(),
 790             &amp;SVGNames::k1Attr.get(),
 791             &amp;SVGNames::k2Attr.get(),
 792             &amp;SVGNames::k3Attr.get(),
 793             &amp;SVGNames::k4Attr.get(),
 794             &amp;SVGNames::kernelMatrixAttr.get(),
 795             &amp;SVGNames::kernelUnitLengthAttr.get(),
 796             &amp;SVGNames::lengthAdjustAttr.get(),
 797             &amp;SVGNames::limitingConeAngleAttr.get(),
 798             &amp;SVGNames::markerHeightAttr.get(),
 799             &amp;SVGNames::markerUnitsAttr.get(),
 800             &amp;SVGNames::markerWidthAttr.get(),
 801             &amp;SVGNames::maskContentUnitsAttr.get(),
 802             &amp;SVGNames::maskUnitsAttr.get(),
 803             &amp;SVGNames::methodAttr.get(),
 804             &amp;SVGNames::modeAttr.get(),
 805             &amp;SVGNames::numOctavesAttr.get(),
 806             &amp;SVGNames::offsetAttr.get(),
 807             &amp;SVGNames::operatorAttr.get(),
 808             &amp;SVGNames::orderAttr.get(),
 809             &amp;SVGNames::orientAttr.get(),
 810             &amp;SVGNames::pathLengthAttr.get(),
 811             &amp;SVGNames::patternContentUnitsAttr.get(),
 812             &amp;SVGNames::patternTransformAttr.get(),
 813             &amp;SVGNames::patternUnitsAttr.get(),
 814             &amp;SVGNames::pointsAtXAttr.get(),
 815             &amp;SVGNames::pointsAtYAttr.get(),
 816             &amp;SVGNames::pointsAtZAttr.get(),
 817             &amp;SVGNames::preserveAlphaAttr.get(),
 818             &amp;SVGNames::preserveAspectRatioAttr.get(),
 819             &amp;SVGNames::primitiveUnitsAttr.get(),
 820             &amp;SVGNames::radiusAttr.get(),
 821             &amp;SVGNames::rAttr.get(),
 822             &amp;SVGNames::refXAttr.get(),
 823             &amp;SVGNames::refYAttr.get(),
 824             &amp;SVGNames::resultAttr.get(),
 825             &amp;SVGNames::rotateAttr.get(),
 826             &amp;SVGNames::rxAttr.get(),
 827             &amp;SVGNames::ryAttr.get(),
 828             &amp;SVGNames::scaleAttr.get(),
 829             &amp;SVGNames::seedAttr.get(),
 830             &amp;SVGNames::slopeAttr.get(),
 831             &amp;SVGNames::spacingAttr.get(),
 832             &amp;SVGNames::specularConstantAttr.get(),
 833             &amp;SVGNames::specularExponentAttr.get(),
 834             &amp;SVGNames::spreadMethodAttr.get(),
 835             &amp;SVGNames::startOffsetAttr.get(),
 836             &amp;SVGNames::stdDeviationAttr.get(),
 837             &amp;SVGNames::stitchTilesAttr.get(),
 838             &amp;SVGNames::surfaceScaleAttr.get(),
 839             &amp;SVGNames::tableValuesAttr.get(),
 840             &amp;SVGNames::targetAttr.get(),
 841             &amp;SVGNames::targetXAttr.get(),
 842             &amp;SVGNames::targetYAttr.get(),
 843             &amp;SVGNames::transformAttr.get(),
 844             &amp;SVGNames::typeAttr.get(),
 845             &amp;SVGNames::valuesAttr.get(),
 846             &amp;SVGNames::viewBoxAttr.get(),
 847             &amp;SVGNames::widthAttr.get(),
 848             &amp;SVGNames::x1Attr.get(),
 849             &amp;SVGNames::x2Attr.get(),
 850             &amp;SVGNames::xAttr.get(),
 851             &amp;SVGNames::xChannelSelectorAttr.get(),
 852             &amp;SVGNames::y1Attr.get(),
 853             &amp;SVGNames::y2Attr.get(),
 854             &amp;SVGNames::yAttr.get(),
 855             &amp;SVGNames::yChannelSelectorAttr.get(),
 856             &amp;SVGNames::zAttr.get(),
 857             &amp;SVGNames::hrefAttr.get(),
 858         };
 859         HashMap&lt;AtomicString, QualifiedName&gt; map;
 860         for (auto&amp; name : names) {
 861             auto addResult = map.add(name-&gt;localName(), *name);
 862             ASSERT_UNUSED(addResult, addResult.isNewEntry);
 863         }
 864         return map;
 865     }());
 866     return animatableAttributes.get().get(localName);
 867 }
 868 
 869 #ifndef NDEBUG
 870 
 871 bool SVGElement::isAnimatableAttribute(const QualifiedName&amp; name) const
 872 {
 873     if (animatableAttributeForName(name.localName()) == name)
 874         return !filterOutAnimatableAttribute(name);
 875     return false;
 876 }
 877 
 878 bool SVGElement::filterOutAnimatableAttribute(const QualifiedName&amp;) const
 879 {
 880     return false;
 881 }
 882 
 883 #endif
 884 
 885 String SVGElement::title() const
 886 {
 887     // According to spec, for stand-alone SVG documents we should not return a title when
 888     // hovering over the rootmost SVG element (the first &lt;title&gt; element is the title of
 889     // the document, not a tooltip) so we instantly return.
 890     if (isOutermostSVGSVGElement() &amp;&amp; document().topDocument().isSVGDocument())
 891         return String();
 892     auto firstTitle = childrenOfType&lt;SVGTitleElement&gt;(*this).first();
 893     return firstTitle ? const_cast&lt;SVGTitleElement*&gt;(firstTitle)-&gt;innerText() : String();
 894 }
 895 
 896 bool SVGElement::rendererIsNeeded(const RenderStyle&amp; style)
 897 {
 898     // http://www.w3.org/TR/SVG/extend.html#PrivateData
 899     // Prevent anything other than SVG renderers from appearing in our render tree
 900     // Spec: SVG allows inclusion of elements from foreign namespaces anywhere
 901     // with the SVG content. In general, the SVG user agent will include the unknown
 902     // elements in the DOM but will otherwise ignore unknown elements.
 903     if (!parentOrShadowHostElement() || parentOrShadowHostElement()-&gt;isSVGElement())
 904         return StyledElement::rendererIsNeeded(style);
 905 
 906     return false;
 907 }
 908 
 909 CSSPropertyID SVGElement::cssPropertyIdForSVGAttributeName(const QualifiedName&amp; attrName)
 910 {
 911     if (!attrName.namespaceURI().isNull())
 912         return CSSPropertyInvalid;
 913 
 914     static const auto properties = makeNeverDestroyed(createAttributeNameToCSSPropertyIDMap());
 915     return properties.get().get(attrName.localName().impl());
 916 }
 917 
 918 bool SVGElement::isAnimatableCSSProperty(const QualifiedName&amp; attributeName)
 919 {
 920     return attributeNameToAnimatedPropertyTypeMap().contains(attributeName.impl())
 921         || cssPropertyWithSVGDOMNameToAnimatedPropertyTypeMap().contains(attributeName.impl());
 922 }
 923 
 924 bool SVGElement::isPresentationAttributeWithSVGDOM(const QualifiedName&amp; attributeName)
 925 {
 926     return !animatedTypes(attributeName).isEmpty();
 927 }
 928 
 929 bool SVGElement::isPresentationAttribute(const QualifiedName&amp; name) const
 930 {
 931     if (cssPropertyIdForSVGAttributeName(name) &gt; 0)
 932         return true;
 933     return StyledElement::isPresentationAttribute(name);
 934 }
 935 
 936 void SVGElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomicString&amp; value, MutableStyleProperties&amp; style)
 937 {
 938     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(name);
 939     if (propertyID &gt; 0)
 940         addPropertyToPresentationAttributeStyle(style, propertyID, value);
 941 }
 942 
 943 void SVGElement::svgAttributeChanged(const QualifiedName&amp; attrName)
 944 {
 945     CSSPropertyID propId = cssPropertyIdForSVGAttributeName(attrName);
 946     if (propId &gt; 0) {
 947         invalidateInstances();
 948         return;
 949     }
 950 
 951     if (attrName == HTMLNames::classAttr) {
 952         classAttributeChanged(className());
 953         invalidateInstances();
 954         return;
 955     }
 956 
 957     if (attrName == HTMLNames::idAttr) {
 958         auto renderer = this-&gt;renderer();
 959         // Notify resources about id changes, this is important as we cache resources by id in SVGDocumentExtensions
 960         if (is&lt;RenderSVGResourceContainer&gt;(renderer))
 961             downcast&lt;RenderSVGResourceContainer&gt;(*renderer).idChanged();
 962         if (isConnected())
 963             buildPendingResourcesIfNeeded();
 964         invalidateInstances();
 965         return;
 966     }
 967 
 968     SVGLangSpace::svgAttributeChanged(attrName);
 969 }
 970 
 971 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 972 {
 973     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 974     updateRelativeLengthsInformation();
 975     buildPendingResourcesIfNeeded();
 976     return InsertedIntoAncestorResult::Done;
 977 }
 978 
 979 void SVGElement::buildPendingResourcesIfNeeded()
 980 {
 981     if (!needsPendingResourceHandling() || !isConnected() || isInShadowTree())
 982         return;
 983 
 984     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 985     String resourceId = getIdAttribute();
 986     if (!extensions.isIdOfPendingResource(resourceId))
 987         return;
 988 
 989     // Mark pending resources as pending for removal.
 990     extensions.markPendingResourcesForRemoval(resourceId);
 991 
 992     // Rebuild pending resources for each client of a pending resource that is being removed.
 993     while (auto clientElement = extensions.removeElementFromPendingResourcesForRemovalMap(resourceId)) {
 994         ASSERT(clientElement-&gt;hasPendingResources());
 995         if (clientElement-&gt;hasPendingResources()) {
 996             clientElement-&gt;buildPendingResource();
 997             extensions.clearHasPendingResourcesIfPossible(*clientElement);
 998         }
 999     }
1000 }
1001 
1002 void SVGElement::childrenChanged(const ChildChange&amp; change)
1003 {
1004     StyledElement::childrenChanged(change);
1005 
1006     if (change.source == ChildChangeSource::Parser)
1007         return;
1008     invalidateInstances();
1009 }
1010 
1011 RefPtr&lt;DeprecatedCSSOMValue&gt; SVGElement::getPresentationAttribute(const String&amp; name)
1012 {
1013     if (!hasAttributesWithoutUpdate())
1014         return 0;
1015 
1016     QualifiedName attributeName(nullAtom(), name, nullAtom());
1017     const Attribute* attribute = findAttributeByName(attributeName);
1018     if (!attribute)
1019         return 0;
1020 
1021     auto style = MutableStyleProperties::create(SVGAttributeMode);
1022     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(attribute-&gt;name());
1023     style-&gt;setProperty(propertyID, attribute-&gt;value());
1024     auto cssValue = style-&gt;getPropertyCSSValue(propertyID);
1025     if (!cssValue)
1026         return nullptr;
1027     return cssValue-&gt;createDeprecatedCSSOMWrapper(style-&gt;ensureCSSStyleDeclaration());
1028 }
1029 
1030 bool SVGElement::instanceUpdatesBlocked() const
1031 {
1032     return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
1033 }
1034 
1035 void SVGElement::setInstanceUpdatesBlocked(bool value)
1036 {
1037     // Catch any callers that calls setInstanceUpdatesBlocked(true) twice in a row.
1038     // That probably indicates nested use of InstanceUpdateBlocker and a bug.
1039     ASSERT(!value || !instanceUpdatesBlocked());
1040 
1041     if (m_svgRareData)
1042         m_svgRareData-&gt;setInstanceUpdatesBlocked(value);
1043 }
1044 
1045 AffineTransform SVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope) const
1046 {
1047     // To be overridden by SVGGraphicsElement (or as special case SVGTextElement and SVGPatternElement)
1048     return AffineTransform();
1049 }
1050 
1051 void SVGElement::updateRelativeLengthsInformation(bool hasRelativeLengths, SVGElement* element)
1052 {
1053     // If we&#39;re not yet in a document, this function will be called again from insertedIntoAncestor(). Do nothing now.
1054     if (!isConnected())
1055         return;
1056 
1057     // An element wants to notify us that its own relative lengths state changed.
1058     // Register it in the relative length map, and register us in the parent relative length map.
1059     // Register the parent in the grandparents map, etc. Repeat procedure until the root of the SVG tree.
1060 
1061     if (hasRelativeLengths)
1062         m_elementsWithRelativeLengths.add(element);
1063     else {
1064         if (!m_elementsWithRelativeLengths.contains(element)) {
1065             // We were never registered. Do nothing.
1066             return;
1067         }
1068 
1069         m_elementsWithRelativeLengths.remove(element);
1070     }
1071 
1072     if (!element-&gt;isSVGGraphicsElement())
1073         return;
1074 
1075     // Find first styled parent node, and notify it that we&#39;ve changed our relative length state.
1076     auto node = makeRefPtr(parentNode());
1077     while (node) {
1078         if (!node-&gt;isSVGElement())
1079             break;
1080 
1081         // Register us in the parent element map.
1082         downcast&lt;SVGElement&gt;(*node).updateRelativeLengthsInformation(hasRelativeLengths, this);
1083         break;
1084     }
1085 }
1086 
1087 bool SVGElement::hasFocusEventListeners() const
1088 {
1089     Element* eventTarget = const_cast&lt;SVGElement*&gt;(this);
1090     return eventTarget-&gt;hasEventListeners(eventNames().focusinEvent)
1091         || eventTarget-&gt;hasEventListeners(eventNames().focusoutEvent)
1092         || eventTarget-&gt;hasEventListeners(eventNames().focusEvent)
1093         || eventTarget-&gt;hasEventListeners(eventNames().blurEvent);
1094 }
1095 
1096 bool SVGElement::isMouseFocusable() const
1097 {
1098     if (!isFocusable())
1099         return false;
1100     Element* eventTarget = const_cast&lt;SVGElement*&gt;(this);
1101     return hasFocusEventListeners()
1102         || eventTarget-&gt;hasEventListeners(eventNames().keydownEvent)
1103         || eventTarget-&gt;hasEventListeners(eventNames().keyupEvent)
1104         || eventTarget-&gt;hasEventListeners(eventNames().keypressEvent);
1105 }
1106 
1107 void SVGElement::accessKeyAction(bool sendMouseEvents)
1108 {
1109     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
1110 }
1111 
1112 void SVGElement::invalidateInstances()
1113 {
1114     if (instanceUpdatesBlocked())
1115         return;
1116 
1117     auto&amp; instances = this-&gt;instances();
1118     while (!instances.isEmpty()) {
1119         auto instance = makeRefPtr(*instances.begin());
1120         if (auto useElement = instance-&gt;correspondingUseElement())
1121             useElement-&gt;invalidateShadowTree();
1122         instance-&gt;setCorrespondingElement(nullptr);
1123     } while (!instances.isEmpty());
1124 }
1125 
1126 }
    </pre>
  </body>
</html>