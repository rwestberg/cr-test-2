<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProxyConstructor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ProxyObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2017 Apple Inc. All Rights Reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  74     if (!target.isObject())
  75         return globalObject-&gt;proxyObjectStructure();
  76 
  77     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  78     CallData ignoredCallData;
  79     VM&amp; vm = globalObject-&gt;vm();
  80     bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
  81     return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  82 }
  83 
  84 void ProxyObject::finishCreation(VM&amp; vm, ExecState* exec, JSValue target, JSValue handler)
  85 {
  86     auto scope = DECLARE_THROW_SCOPE(vm);
  87     Base::finishCreation(vm);
  88     ASSERT(type() == ProxyObjectType);
  89     if (!target.isObject()) {
  90         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);
  91         return;
  92     }
  93     if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
<span class="line-modified">  94         if (targetAsProxy-&gt;handler().isNull()) {</span>
<span class="line-modified">  95             throwTypeError(exec, scope, &quot;If a Proxy&#39;s handler is another Proxy object, the other Proxy should not have been revoked&quot;_s);</span>
  96             return;
  97         }
  98     }
  99     if (!handler.isObject()) {
 100         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);
 101         return;
 102     }






 103 
 104     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
 105 
 106     CallData ignoredCallData;
 107     m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
 108     if (m_isCallable) {
 109         TypeInfo info = structure(vm)-&gt;typeInfo();
 110         RELEASE_ASSERT(info.implementsHasInstance() &amp;&amp; info.implementsDefaultHasInstance());
 111     }
 112 
 113     m_isConstructible = jsCast&lt;JSObject*&gt;(target)-&gt;isConstructor(vm);
 114 
 115     m_target.set(vm, this, targetAsObject);
 116     m_handler.set(vm, this, handler);
 117 }
 118 
 119 static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
 120 
 121 static JSValue performProxyGet(ExecState* exec, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)
 122 {
</pre>
<hr />
<pre>
 126     auto scope = DECLARE_THROW_SCOPE(vm);
 127     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 128         throwStackOverflowError(exec, scope);
 129         return { };
 130     }
 131 
 132     JSObject* target = proxyObject-&gt;target();
 133 
 134     auto performDefaultGet = [&amp;] {
 135         scope.release();
 136         PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
 137         bool hasProperty = target-&gt;getPropertySlot(exec, propertyName, slot);
 138         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 139         if (hasProperty)
 140             RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 141 
 142         return jsUndefined();
 143     };
 144 
 145     if (propertyName.isPrivateName())
<span class="line-modified"> 146         return performDefaultGet();</span>
 147 
 148     JSValue handlerValue = proxyObject-&gt;handler();
 149     if (handlerValue.isNull())
 150         return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 151 
 152     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 153     CallData callData;
 154     CallType callType;
 155     JSValue getHandler = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);
 156     RETURN_IF_EXCEPTION(scope, { });
 157 
 158     if (getHandler.isUndefined())
 159         return performDefaultGet();
 160 
 161     MarkedArgumentBuffer arguments;
 162     arguments.append(target);
<span class="line-modified"> 163     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 164     arguments.append(receiver);
 165     ASSERT(!arguments.hasOverflowed());
 166     JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);
 167     RETURN_IF_EXCEPTION(scope, { });
 168 
 169     PropertyDescriptor descriptor;
<span class="line-modified"> 170     if (target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor)) {</span>


 171         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
 172             if (!sameValue(exec, descriptor.value(), trapResult))
 173                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);
 174         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
 175             if (!trapResult.isUndefined())
 176                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);
 177         }
 178     }
 179 
 180     RETURN_IF_EXCEPTION(scope, { });
 181 
 182     return trapResult;
 183 }
 184 
 185 bool ProxyObject::performGet(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 186 {
 187     NO_TAIL_CALLS();
 188 
 189     VM&amp; vm = exec-&gt;vm();
 190     auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
 195     return true;
 196 }
 197 
 198 bool ProxyObject::performInternalMethodGetOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 199 {
 200     NO_TAIL_CALLS();
 201 
 202     VM&amp; vm = exec-&gt;vm();
 203     auto scope = DECLARE_THROW_SCOPE(vm);
 204     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 205         throwStackOverflowError(exec, scope);
 206         return false;
 207     }
 208     JSObject* target = this-&gt;target();
 209 
 210     auto performDefaultGetOwnProperty = [&amp;] {
 211         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 212     };
 213 
 214     if (propertyName.isPrivateName())
<span class="line-modified"> 215         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());</span>
 216 
 217     JSValue handlerValue = this-&gt;handler();
 218     if (handlerValue.isNull()) {
 219         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 220         return false;
 221     }
 222 
 223     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 224     CallData callData;
 225     CallType callType;
 226     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 227     RETURN_IF_EXCEPTION(scope, false);
 228     if (getOwnPropertyDescriptorMethod.isUndefined())
 229         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
 230 
 231     MarkedArgumentBuffer arguments;
 232     arguments.append(target);
<span class="line-modified"> 233     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 234     ASSERT(!arguments.hasOverflowed());
 235     JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);
 236     RETURN_IF_EXCEPTION(scope, false);
 237 
 238     if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
 239         throwVMTypeError(exec, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);
 240         return false;
 241     }
 242 
 243     PropertyDescriptor targetPropertyDescriptor;
 244     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetPropertyDescriptor);
 245     RETURN_IF_EXCEPTION(scope, false);
 246 
 247     if (trapResult.isUndefined()) {
 248         if (!isTargetPropertyDescriptorDefined)
 249             return false;
 250         if (!targetPropertyDescriptor.configurable()) {
 251             throwVMTypeError(exec, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);
 252             return false;
 253         }
</pre>
<hr />
<pre>
 268 
 269     bool isExtensible = target-&gt;isExtensible(exec);
 270     RETURN_IF_EXCEPTION(scope, false);
 271     PropertyDescriptor trapResultAsDescriptor;
 272     toPropertyDescriptor(exec, trapResult, trapResultAsDescriptor);
 273     RETURN_IF_EXCEPTION(scope, false);
 274     bool throwException = false;
 275     bool valid = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, isExtensible,
 276         trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
 277     RETURN_IF_EXCEPTION(scope, false);
 278     if (!valid) {
 279         throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);
 280         return false;
 281     }
 282 
 283     if (!trapResultAsDescriptor.configurable()) {
 284         if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
 285             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);
 286             return false;
 287         }




 288     }
 289 
 290     if (trapResultAsDescriptor.isAccessorDescriptor()) {
 291         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(exec);
 292         RETURN_IF_EXCEPTION(scope, false);
 293         slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
 294     } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
 295         slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
 296     else
 297         slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
 298 
 299     return true;
 300 }
 301 
 302 bool ProxyObject::performHasProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 303 {
 304     NO_TAIL_CALLS();
 305 
 306     VM&amp; vm = exec-&gt;vm();
 307     auto scope = DECLARE_THROW_SCOPE(vm);
 308     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 309         throwStackOverflowError(exec, scope);
 310         return false;
 311     }
 312     JSObject* target = this-&gt;target();
 313     slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
 314 
 315     auto performDefaultHasProperty = [&amp;] {
 316         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 317     };
 318 
 319     if (propertyName.isPrivateName())
<span class="line-modified"> 320         RELEASE_AND_RETURN(scope, performDefaultHasProperty());</span>
 321 
 322     JSValue handlerValue = this-&gt;handler();
 323     if (handlerValue.isNull()) {
 324         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 325         return false;
 326     }
 327 
 328     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 329     CallData callData;
 330     CallType callType;
 331     JSValue hasMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 332     RETURN_IF_EXCEPTION(scope, false);
 333     if (hasMethod.isUndefined())
 334         RELEASE_AND_RETURN(scope, performDefaultHasProperty());
 335 
 336     MarkedArgumentBuffer arguments;
 337     arguments.append(target);
<span class="line-modified"> 338     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 339     ASSERT(!arguments.hasOverflowed());
 340     JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);
 341     RETURN_IF_EXCEPTION(scope, false);
 342 
 343     bool trapResultAsBool = trapResult.toBoolean(exec);
 344     RETURN_IF_EXCEPTION(scope, false);
 345 
 346     if (!trapResultAsBool) {
 347         PropertyDescriptor descriptor;
 348         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 349         RETURN_IF_EXCEPTION(scope, false);
 350         if (isPropertyDescriptorDefined) {
 351             if (!descriptor.configurable()) {
 352                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);
 353                 return false;
 354             }
 355             bool isExtensible = target-&gt;isExtensible(exec);
 356             RETURN_IF_EXCEPTION(scope, false);
 357             if (!isExtensible) {
 358                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);
</pre>
<hr />
<pre>
 384     case PropertySlot::InternalMethodType::GetOwnProperty:
 385         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(exec, propertyName, slot));
 386     case PropertySlot::InternalMethodType::HasProperty:
 387         RELEASE_AND_RETURN(scope, performHasProperty(exec, propertyName, slot));
 388     default:
 389         return false;
 390     }
 391 
 392     RELEASE_ASSERT_NOT_REACHED();
 393     return false;
 394 }
 395 
 396 bool ProxyObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 397 {
 398     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 399     return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);
 400 }
 401 
 402 bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
 403 {

 404     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 405     Identifier ident = Identifier::from(exec, propertyName);</span>
 406     return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);
 407 }
 408 
 409 template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified"> 410 bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut)</span>
 411 {
 412     NO_TAIL_CALLS();
 413 
 414     VM&amp; vm = exec-&gt;vm();
 415     auto scope = DECLARE_THROW_SCOPE(vm);
 416     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 417         throwStackOverflowError(exec, scope);
 418         return false;
 419     }
 420 
 421     if (propertyName.isPrivateName())
<span class="line-modified"> 422         RELEASE_AND_RETURN(scope, performDefaultPut());</span>
 423 
 424     JSValue handlerValue = this-&gt;handler();
 425     if (handlerValue.isNull()) {
 426         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 427         return false;
 428     }
 429 
 430     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 431     CallData callData;
 432     CallType callType;
 433     JSValue setMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 434     RETURN_IF_EXCEPTION(scope, false);
 435     JSObject* target = this-&gt;target();
 436     if (setMethod.isUndefined())
 437         RELEASE_AND_RETURN(scope, performDefaultPut());
 438 
 439     MarkedArgumentBuffer arguments;
 440     arguments.append(target);
<span class="line-modified"> 441     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 442     arguments.append(putValue);
 443     arguments.append(thisValue);
 444     ASSERT(!arguments.hasOverflowed());
 445     JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);
 446     RETURN_IF_EXCEPTION(scope, false);
 447     bool trapResultAsBool = trapResult.toBoolean(exec);
 448     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 449     if (!trapResultAsBool)</span>


 450         return false;

 451 
 452     PropertyDescriptor descriptor;
 453     bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 454     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 455     if (hasProperty) {
 456         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
 457             if (!sameValue(exec, descriptor.value(), putValue)) {
 458                 throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);
 459                 return false;
 460             }
 461         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
 462             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);
 463             return false;
 464         }
 465     }
 466     return true;
 467 }
 468 
 469 bool ProxyObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 470 {
 471     VM&amp; vm = exec-&gt;vm();
 472     slot.disableCaching();
 473 
 474     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 475     auto performDefaultPut = [&amp;] () {
 476         JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
 477         return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);
 478     };
<span class="line-modified"> 479     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut);</span>
 480 }
 481 
 482 bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)
 483 {
 484     VM&amp; vm = exec-&gt;vm();
 485     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 486     Identifier ident = Identifier::from(exec, propertyName);</span>
 487     RETURN_IF_EXCEPTION(scope, false);
 488     auto performDefaultPut = [&amp;] () {
 489         JSObject* target = this-&gt;target();
 490         bool isStrictMode = shouldThrow;
 491         PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
 492         return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);
 493     };
<span class="line-modified"> 494     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut));</span>
 495 }
 496 
 497 bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 498 {
 499     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 500     return thisObject-&gt;putByIndexCommon(exec, thisObject, propertyName, value, shouldThrow);
 501 }
 502 
 503 static EncodedJSValue JSC_HOST_CALL performProxyCall(ExecState* exec)
 504 {
 505     NO_TAIL_CALLS();
 506 
 507     VM&amp; vm = exec-&gt;vm();
 508     auto scope = DECLARE_THROW_SCOPE(vm);
 509     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 510         throwStackOverflowError(exec, scope);
 511         return encodedJSValue();
 512     }
 513     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());
 514     JSValue handlerValue = proxy-&gt;handler();
</pre>
<hr />
<pre>
 552 }
 553 
 554 static EncodedJSValue JSC_HOST_CALL performProxyConstruct(ExecState* exec)
 555 {
 556     NO_TAIL_CALLS();
 557 
 558     VM&amp; vm = exec-&gt;vm();
 559     auto scope = DECLARE_THROW_SCOPE(vm);
 560     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 561         throwStackOverflowError(exec, scope);
 562         return encodedJSValue();
 563     }
 564     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());
 565     JSValue handlerValue = proxy-&gt;handler();
 566     if (handlerValue.isNull())
 567         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 568 
 569     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 570     CallData callData;
 571     CallType callType;
<span class="line-modified"> 572     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be constructible&quot;_s);</span>
 573     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 574     JSObject* target = proxy-&gt;target();
 575     if (constructMethod.isUndefined()) {
 576         ConstructData constructData;
 577         ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
 578         RELEASE_ASSERT(constructType != ConstructType::None);
 579         RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, target, constructType, constructData, ArgList(exec), exec-&gt;newTarget())));
 580     }
 581 
 582     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));
 583     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 584     MarkedArgumentBuffer arguments;
 585     arguments.append(target);
 586     arguments.append(argArray);
 587     arguments.append(exec-&gt;newTarget());
 588     ASSERT(!arguments.hasOverflowed());
 589     JSValue result = call(exec, constructMethod, callType, callData, handler, arguments);
 590     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 591     if (!result.isObject())
 592         return throwVMTypeError(exec, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);
</pre>
<hr />
<pre>
 602         return ConstructType::None;
 603     }
 604 
 605     constructData.native.function = performProxyConstruct;
 606     return ConstructType::Host;
 607 }
 608 
 609 template &lt;typename DefaultDeleteFunction&gt;
 610 bool ProxyObject::performDelete(ExecState* exec, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)
 611 {
 612     NO_TAIL_CALLS();
 613 
 614     VM&amp; vm = exec-&gt;vm();
 615     auto scope = DECLARE_THROW_SCOPE(vm);
 616     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 617         throwStackOverflowError(exec, scope);
 618         return false;
 619     }
 620 
 621     if (propertyName.isPrivateName())
<span class="line-modified"> 622         RELEASE_AND_RETURN(scope, performDefaultDelete());</span>
 623 
 624     JSValue handlerValue = this-&gt;handler();
 625     if (handlerValue.isNull()) {
 626         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 627         return false;
 628     }
 629 
 630     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 631     CallData callData;
 632     CallType callType;
 633     JSValue deletePropertyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 634     RETURN_IF_EXCEPTION(scope, false);
 635     JSObject* target = this-&gt;target();
 636     if (deletePropertyMethod.isUndefined())
 637         RELEASE_AND_RETURN(scope, performDefaultDelete());
 638 
 639     MarkedArgumentBuffer arguments;
 640     arguments.append(target);
<span class="line-modified"> 641     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 642     ASSERT(!arguments.hasOverflowed());
 643     JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);
 644     RETURN_IF_EXCEPTION(scope, false);
 645 
 646     bool trapResultAsBool = trapResult.toBoolean(exec);
 647     RETURN_IF_EXCEPTION(scope, false);
 648 
 649     if (!trapResultAsBool)
 650         return false;
 651 
 652     PropertyDescriptor descriptor;
<span class="line-modified"> 653     if (target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor)) {</span>


 654         if (!descriptor.configurable()) {
 655             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);
 656             return false;
 657         }






 658     }
 659 
 660     RETURN_IF_EXCEPTION(scope, false);
 661 
 662     return true;
 663 }
 664 
 665 bool ProxyObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
 666 {
 667     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 668     auto performDefaultDelete = [&amp;] () -&gt; bool {
 669         JSObject* target = thisObject-&gt;target();
 670         return target-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(target, exec, propertyName);
 671     };
 672     return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);
 673 }
 674 
 675 bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
 676 {

 677     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified"> 678     Identifier ident = Identifier::from(exec, propertyName);</span>
 679     auto performDefaultDelete = [&amp;] () -&gt; bool {
 680         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 681         return target-&gt;methodTable(exec-&gt;vm())-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
 682     };
 683     return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);
 684 }
 685 
 686 bool ProxyObject::performPreventExtensions(ExecState* exec)
 687 {
 688     NO_TAIL_CALLS();
 689 
 690     VM&amp; vm = exec-&gt;vm();
 691     auto scope = DECLARE_THROW_SCOPE(vm);
 692     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 693         throwStackOverflowError(exec, scope);
 694         return false;
 695     }
 696 
 697     JSValue handlerValue = this-&gt;handler();
 698     if (handlerValue.isNull()) {
 699         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 700         return false;
 701     }
</pre>
<hr />
<pre>
 793     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(exec);
 794 }
 795 
 796 bool ProxyObject::performDefineOwnProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
 797 {
 798     NO_TAIL_CALLS();
 799 
 800     VM&amp; vm = exec-&gt;vm();
 801     auto scope = DECLARE_THROW_SCOPE(vm);
 802     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 803         throwStackOverflowError(exec, scope);
 804         return false;
 805     }
 806 
 807     JSObject* target = this-&gt;target();
 808     auto performDefaultDefineOwnProperty = [&amp;] {
 809         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));
 810     };
 811 
 812     if (propertyName.isPrivateName())
<span class="line-modified"> 813         return performDefaultDefineOwnProperty();</span>
 814 
 815     JSValue handlerValue = this-&gt;handler();
 816     if (handlerValue.isNull()) {
 817         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 818         return false;
 819     }
 820 
 821     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 822     CallData callData;
 823     CallType callType;
 824     JSValue definePropertyMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 825     RETURN_IF_EXCEPTION(scope, false);
 826 
 827     if (definePropertyMethod.isUndefined())
 828         return performDefaultDefineOwnProperty();
 829 
 830     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);
 831     RETURN_IF_EXCEPTION(scope, false);
 832 
 833     MarkedArgumentBuffer arguments;
 834     arguments.append(target);
<span class="line-modified"> 835     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(&amp;vm, propertyName.uid())));</span>
 836     arguments.append(descriptorObject);
 837     ASSERT(!arguments.hasOverflowed());
 838     JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);
 839     RETURN_IF_EXCEPTION(scope, false);
 840 
 841     bool trapResultAsBool = trapResult.toBoolean(exec);
 842     RETURN_IF_EXCEPTION(scope, false);
 843 
 844     if (!trapResultAsBool)
 845         return false;
 846 
 847     PropertyDescriptor targetDescriptor;
 848     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetDescriptor);
 849     RETURN_IF_EXCEPTION(scope, false);
 850 
 851     bool targetIsExtensible = target-&gt;isExtensible(exec);
 852     RETURN_IF_EXCEPTION(scope, false);
 853     bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
 854 
 855     if (!isTargetDescriptorDefined) {
</pre>
<hr />
<pre>
 862             return false;
 863         }
 864 
 865         return true;
 866     }
 867 
 868     ASSERT(isTargetDescriptorDefined);
 869     bool isCurrentDefined = isTargetDescriptorDefined;
 870     const PropertyDescriptor&amp; current = targetDescriptor;
 871     bool throwException = false;
 872     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);
 873     RETURN_IF_EXCEPTION(scope, false);
 874     if (!isCompatibleDescriptor) {
 875         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);
 876         return false;
 877     }
 878     if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
 879         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);
 880         return false;
 881     }






 882 
 883     return true;
 884 }
 885 
 886 bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
 887 {
 888     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 889     return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);
 890 }
 891 
<span class="line-modified"> 892 void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; trapResult, EnumerationMode enumerationMode)</span>
 893 {
 894     NO_TAIL_CALLS();
 895 
 896     VM&amp; vm = exec-&gt;vm();
 897     auto scope = DECLARE_THROW_SCOPE(vm);
 898     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 899         throwStackOverflowError(exec, scope);
 900         return;
 901     }
 902     JSValue handlerValue = this-&gt;handler();
 903     if (handlerValue.isNull()) {
 904         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 905         return;
 906     }
 907 
 908     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 909     CallData callData;
 910     CallType callType;
 911     JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 912     RETURN_IF_EXCEPTION(scope, void());
 913     JSObject* target = this-&gt;target();
 914     if (ownKeysMethod.isUndefined()) {
 915         scope.release();
<span class="line-modified"> 916         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, trapResult, enumerationMode);</span>
 917         return;
 918     }
 919 
 920     MarkedArgumentBuffer arguments;
 921     arguments.append(target);
 922     ASSERT(!arguments.hasOverflowed());
 923     JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);
 924     RETURN_IF_EXCEPTION(scope, void());
 925 
<span class="line-modified"> 926     PropertyNameMode propertyNameMode = trapResult.propertyNameMode();</span>
<span class="line-removed"> 927     RuntimeTypeMask resultFilter = 0;</span>
<span class="line-removed"> 928     switch (propertyNameMode) {</span>
<span class="line-removed"> 929     case PropertyNameMode::Symbols:</span>
<span class="line-removed"> 930         resultFilter = TypeSymbol;</span>
<span class="line-removed"> 931         break;</span>
<span class="line-removed"> 932     case PropertyNameMode::Strings:</span>
<span class="line-removed"> 933         resultFilter = TypeString;</span>
<span class="line-removed"> 934         break;</span>
<span class="line-removed"> 935     case PropertyNameMode::StringsAndSymbols:</span>
<span class="line-removed"> 936         resultFilter = TypeSymbol | TypeString;</span>
<span class="line-removed"> 937         break;</span>
<span class="line-removed"> 938     }</span>
<span class="line-removed"> 939     ASSERT(resultFilter);</span>
<span class="line-removed"> 940     RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;</span>
 941     HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;


 942 
<span class="line-modified"> 943     auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {</span>
<span class="line-modified"> 944         static const bool doExitEarly = true;</span>
<span class="line-modified"> 945         static const bool dontExitEarly = false;</span>
<span class="line-modified"> 946 </span>
<span class="line-modified"> 947         if (!(type &amp; resultFilter))</span>
<span class="line-modified"> 948             return dontExitEarly;</span>


























 949 
<span class="line-modified"> 950         Identifier ident = value.toPropertyKey(exec);</span>
<span class="line-modified"> 951         RETURN_IF_EXCEPTION(scope, doExitEarly);</span>
 952 
<span class="line-modified"> 953         uncheckedResultKeys.add(ident.impl());</span>
<span class="line-modified"> 954         trapResult.addUnchecked(ident.impl());</span>
<span class="line-modified"> 955         return dontExitEarly;</span>
<span class="line-modified"> 956     };</span>
 957 
<span class="line-modified"> 958     createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
<span class="line-modified"> 959     RETURN_IF_EXCEPTION(scope, void());</span>


 960 
 961     bool targetIsExensible = target-&gt;isExtensible(exec);
 962     RETURN_IF_EXCEPTION(scope, void());
 963 
<span class="line-modified"> 964     PropertyNameArray targetKeys(&amp;vm, propertyNameMode, trapResult.privateSymbolMode());</span>
 965     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);
 966     RETURN_IF_EXCEPTION(scope, void());
 967     Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
 968     Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
 969     for (const Identifier&amp; ident : targetKeys) {
 970         PropertyDescriptor descriptor;
 971         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(exec, ident.impl(), descriptor);
 972         RETURN_IF_EXCEPTION(scope, void());
 973         if (isPropertyDefined &amp;&amp; !descriptor.configurable())
 974             targetNonConfigurableKeys.append(ident.impl());
 975         else
 976             targetConfigurableKeys.append(ident.impl());
 977     }
 978 
 979     enum ContainedIn { IsContainedIn, IsNotContainedIn };
 980     auto removeIfContainedInUncheckedResultKeys = [&amp;] (UniquedStringImpl* impl) -&gt; ContainedIn {
 981         auto iter = uncheckedResultKeys.find(impl);
 982         if (iter == uncheckedResultKeys.end())
 983             return IsNotContainedIn;
 984 
 985         uncheckedResultKeys.remove(iter);
 986         return IsContainedIn;
 987     };
 988 
 989     for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
 990         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
 991             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));
 992             return;
 993         }
 994     }
 995 
<span class="line-modified"> 996     if (targetIsExensible)</span>
<span class="line-modified"> 997         return;</span>





 998 
<span class="line-modified"> 999     for (UniquedStringImpl* impl : targetConfigurableKeys) {</span>
<span class="line-modified">1000         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {</span>
<span class="line-removed">1001             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
1002             return;
1003         }
1004     }
1005 
<span class="line-modified">1006     if (uncheckedResultKeys.size()) {</span>
<span class="line-modified">1007         throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>
<span class="line-modified">1008         return;</span>












1009     }
1010 }
1011 
1012 void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
1013 {
1014     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
1015     thisObject-&gt;performGetOwnPropertyNames(exec, propertyNameArray, enumerationMode);
1016 }
1017 
1018 void ProxyObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
1019 {
1020     NO_TAIL_CALLS();
1021     JSObject::getPropertyNames(object, exec, propertyNameArray, enumerationMode);
1022 }
1023 
1024 void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)
1025 {
1026     RELEASE_ASSERT_NOT_REACHED();
1027 }
1028 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All Rights Reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  74     if (!target.isObject())
  75         return globalObject-&gt;proxyObjectStructure();
  76 
  77     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
  78     CallData ignoredCallData;
  79     VM&amp; vm = globalObject-&gt;vm();
  80     bool isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
  81     return isCallable ? globalObject-&gt;callableProxyObjectStructure() : globalObject-&gt;proxyObjectStructure();
  82 }
  83 
  84 void ProxyObject::finishCreation(VM&amp; vm, ExecState* exec, JSValue target, JSValue handler)
  85 {
  86     auto scope = DECLARE_THROW_SCOPE(vm);
  87     Base::finishCreation(vm);
  88     ASSERT(type() == ProxyObjectType);
  89     if (!target.isObject()) {
  90         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; should be an Object&quot;_s);
  91         return;
  92     }
  93     if (ProxyObject* targetAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, target)) {
<span class="line-modified">  94         if (targetAsProxy-&gt;isRevoked()) {</span>
<span class="line-modified">  95             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;target&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
  96             return;
  97         }
  98     }
  99     if (!handler.isObject()) {
 100         throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; should be an Object&quot;_s);
 101         return;
 102     }
<span class="line-added"> 103     if (ProxyObject* handlerAsProxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, handler)) {</span>
<span class="line-added"> 104         if (handlerAsProxy-&gt;isRevoked()) {</span>
<span class="line-added"> 105             throwTypeError(exec, scope, &quot;A Proxy&#39;s &#39;handler&#39; shouldn&#39;t be a revoked Proxy&quot;_s);</span>
<span class="line-added"> 106             return;</span>
<span class="line-added"> 107         }</span>
<span class="line-added"> 108     }</span>
 109 
 110     JSObject* targetAsObject = jsCast&lt;JSObject*&gt;(target);
 111 
 112     CallData ignoredCallData;
 113     m_isCallable = targetAsObject-&gt;methodTable(vm)-&gt;getCallData(targetAsObject, ignoredCallData) != CallType::None;
 114     if (m_isCallable) {
 115         TypeInfo info = structure(vm)-&gt;typeInfo();
 116         RELEASE_ASSERT(info.implementsHasInstance() &amp;&amp; info.implementsDefaultHasInstance());
 117     }
 118 
 119     m_isConstructible = jsCast&lt;JSObject*&gt;(target)-&gt;isConstructor(vm);
 120 
 121     m_target.set(vm, this, targetAsObject);
 122     m_handler.set(vm, this, handler);
 123 }
 124 
 125 static const ASCIILiteral s_proxyAlreadyRevokedErrorMessage { &quot;Proxy has already been revoked. No more operations are allowed to be performed on it&quot;_s };
 126 
 127 static JSValue performProxyGet(ExecState* exec, ProxyObject* proxyObject, JSValue receiver, PropertyName propertyName)
 128 {
</pre>
<hr />
<pre>
 132     auto scope = DECLARE_THROW_SCOPE(vm);
 133     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 134         throwStackOverflowError(exec, scope);
 135         return { };
 136     }
 137 
 138     JSObject* target = proxyObject-&gt;target();
 139 
 140     auto performDefaultGet = [&amp;] {
 141         scope.release();
 142         PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
 143         bool hasProperty = target-&gt;getPropertySlot(exec, propertyName, slot);
 144         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 145         if (hasProperty)
 146             RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));
 147 
 148         return jsUndefined();
 149     };
 150 
 151     if (propertyName.isPrivateName())
<span class="line-modified"> 152         return jsUndefined();</span>
 153 
 154     JSValue handlerValue = proxyObject-&gt;handler();
 155     if (handlerValue.isNull())
 156         return throwTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 157 
 158     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 159     CallData callData;
 160     CallType callType;
 161     JSValue getHandler = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;get, &quot;&#39;get&#39; property of a Proxy&#39;s handler object should be callable&quot;_s);
 162     RETURN_IF_EXCEPTION(scope, { });
 163 
 164     if (getHandler.isUndefined())
 165         return performDefaultGet();
 166 
 167     MarkedArgumentBuffer arguments;
 168     arguments.append(target);
<span class="line-modified"> 169     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 170     arguments.append(receiver);
 171     ASSERT(!arguments.hasOverflowed());
 172     JSValue trapResult = call(exec, getHandler, callType, callData, handler, arguments);
 173     RETURN_IF_EXCEPTION(scope, { });
 174 
 175     PropertyDescriptor descriptor;
<span class="line-modified"> 176     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
<span class="line-added"> 177     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added"> 178     if (result) {</span>
 179         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
 180             if (!sameValue(exec, descriptor.value(), trapResult))
 181                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable and non-writable property should be the same value as the target&#39;s property&quot;_s);
 182         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.getter().isUndefined()) {
 183             if (!trapResult.isUndefined())
 184                 return throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;get&#39; result of a non-configurable accessor property without a getter should be undefined&quot;_s);
 185         }
 186     }
 187 
 188     RETURN_IF_EXCEPTION(scope, { });
 189 
 190     return trapResult;
 191 }
 192 
 193 bool ProxyObject::performGet(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 194 {
 195     NO_TAIL_CALLS();
 196 
 197     VM&amp; vm = exec-&gt;vm();
 198     auto scope = DECLARE_THROW_SCOPE(vm);
</pre>
<hr />
<pre>
 203     return true;
 204 }
 205 
 206 bool ProxyObject::performInternalMethodGetOwnProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 207 {
 208     NO_TAIL_CALLS();
 209 
 210     VM&amp; vm = exec-&gt;vm();
 211     auto scope = DECLARE_THROW_SCOPE(vm);
 212     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 213         throwStackOverflowError(exec, scope);
 214         return false;
 215     }
 216     JSObject* target = this-&gt;target();
 217 
 218     auto performDefaultGetOwnProperty = [&amp;] {
 219         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 220     };
 221 
 222     if (propertyName.isPrivateName())
<span class="line-modified"> 223         return false;</span>
 224 
 225     JSValue handlerValue = this-&gt;handler();
 226     if (handlerValue.isNull()) {
 227         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 228         return false;
 229     }
 230 
 231     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 232     CallData callData;
 233     CallType callType;
 234     JSValue getOwnPropertyDescriptorMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;getOwnPropertyDescriptor&quot;), &quot;&#39;getOwnPropertyDescriptor&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 235     RETURN_IF_EXCEPTION(scope, false);
 236     if (getOwnPropertyDescriptorMethod.isUndefined())
 237         RELEASE_AND_RETURN(scope, performDefaultGetOwnProperty());
 238 
 239     MarkedArgumentBuffer arguments;
 240     arguments.append(target);
<span class="line-modified"> 241     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 242     ASSERT(!arguments.hasOverflowed());
 243     JSValue trapResult = call(exec, getOwnPropertyDescriptorMethod, callType, callData, handler, arguments);
 244     RETURN_IF_EXCEPTION(scope, false);
 245 
 246     if (!trapResult.isUndefined() &amp;&amp; !trapResult.isObject()) {
 247         throwVMTypeError(exec, scope, &quot;result of &#39;getOwnPropertyDescriptor&#39; call should either be an Object or undefined&quot;_s);
 248         return false;
 249     }
 250 
 251     PropertyDescriptor targetPropertyDescriptor;
 252     bool isTargetPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetPropertyDescriptor);
 253     RETURN_IF_EXCEPTION(scope, false);
 254 
 255     if (trapResult.isUndefined()) {
 256         if (!isTargetPropertyDescriptorDefined)
 257             return false;
 258         if (!targetPropertyDescriptor.configurable()) {
 259             throwVMTypeError(exec, scope, &quot;When the result of &#39;getOwnPropertyDescriptor&#39; is undefined the target must be configurable&quot;_s);
 260             return false;
 261         }
</pre>
<hr />
<pre>
 276 
 277     bool isExtensible = target-&gt;isExtensible(exec);
 278     RETURN_IF_EXCEPTION(scope, false);
 279     PropertyDescriptor trapResultAsDescriptor;
 280     toPropertyDescriptor(exec, trapResult, trapResultAsDescriptor);
 281     RETURN_IF_EXCEPTION(scope, false);
 282     bool throwException = false;
 283     bool valid = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, isExtensible,
 284         trapResultAsDescriptor, isTargetPropertyDescriptorDefined, targetPropertyDescriptor, throwException);
 285     RETURN_IF_EXCEPTION(scope, false);
 286     if (!valid) {
 287         throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; fails the IsCompatiblePropertyDescriptor test&quot;_s);
 288         return false;
 289     }
 290 
 291     if (!trapResultAsDescriptor.configurable()) {
 292         if (!isTargetPropertyDescriptorDefined || targetPropertyDescriptor.configurable()) {
 293             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable when the &#39;target&#39; doesn&#39;t have it as an own property or if it is a configurable own property on &#39;target&#39;&quot;_s);
 294             return false;
 295         }
<span class="line-added"> 296         if (trapResultAsDescriptor.writablePresent() &amp;&amp; !trapResultAsDescriptor.writable() &amp;&amp; targetPropertyDescriptor.writable()) {</span>
<span class="line-added"> 297             throwVMTypeError(exec, scope, &quot;Result from &#39;getOwnPropertyDescriptor&#39; can&#39;t be non-configurable and non-writable when the target&#39;s property is writable&quot;_s);</span>
<span class="line-added"> 298             return false;</span>
<span class="line-added"> 299         }</span>
 300     }
 301 
 302     if (trapResultAsDescriptor.isAccessorDescriptor()) {
 303         GetterSetter* getterSetter = trapResultAsDescriptor.slowGetterSetter(exec);
 304         RETURN_IF_EXCEPTION(scope, false);
 305         slot.setGetterSlot(this, trapResultAsDescriptor.attributes(), getterSetter);
 306     } else if (trapResultAsDescriptor.isDataDescriptor() &amp;&amp; !trapResultAsDescriptor.value().isEmpty())
 307         slot.setValue(this, trapResultAsDescriptor.attributes(), trapResultAsDescriptor.value());
 308     else
 309         slot.setValue(this, trapResultAsDescriptor.attributes(), jsUndefined()); // We use undefined because it&#39;s the default value in object properties.
 310 
 311     return true;
 312 }
 313 
 314 bool ProxyObject::performHasProperty(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 315 {
 316     NO_TAIL_CALLS();
 317 
 318     VM&amp; vm = exec-&gt;vm();
 319     auto scope = DECLARE_THROW_SCOPE(vm);
 320     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 321         throwStackOverflowError(exec, scope);
 322         return false;
 323     }
 324     JSObject* target = this-&gt;target();
 325     slot.setValue(this, static_cast&lt;unsigned&gt;(PropertyAttribute::None), jsUndefined()); // Nobody should rely on our value, but be safe and protect against any bad actors reading our value.
 326 
 327     auto performDefaultHasProperty = [&amp;] {
 328         return target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);
 329     };
 330 
 331     if (propertyName.isPrivateName())
<span class="line-modified"> 332         return false;</span>
 333 
 334     JSValue handlerValue = this-&gt;handler();
 335     if (handlerValue.isNull()) {
 336         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 337         return false;
 338     }
 339 
 340     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 341     CallData callData;
 342     CallType callType;
 343     JSValue hasMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;has, &quot;&#39;has&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 344     RETURN_IF_EXCEPTION(scope, false);
 345     if (hasMethod.isUndefined())
 346         RELEASE_AND_RETURN(scope, performDefaultHasProperty());
 347 
 348     MarkedArgumentBuffer arguments;
 349     arguments.append(target);
<span class="line-modified"> 350     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 351     ASSERT(!arguments.hasOverflowed());
 352     JSValue trapResult = call(exec, hasMethod, callType, callData, handler, arguments);
 353     RETURN_IF_EXCEPTION(scope, false);
 354 
 355     bool trapResultAsBool = trapResult.toBoolean(exec);
 356     RETURN_IF_EXCEPTION(scope, false);
 357 
 358     if (!trapResultAsBool) {
 359         PropertyDescriptor descriptor;
 360         bool isPropertyDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 361         RETURN_IF_EXCEPTION(scope, false);
 362         if (isPropertyDescriptorDefined) {
 363             if (!descriptor.configurable()) {
 364                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for non-configurable properties&quot;_s);
 365                 return false;
 366             }
 367             bool isExtensible = target-&gt;isExtensible(exec);
 368             RETURN_IF_EXCEPTION(scope, false);
 369             if (!isExtensible) {
 370                 throwVMTypeError(exec, scope, &quot;Proxy &#39;has&#39; must return &#39;true&#39; for a non-extensible &#39;target&#39; object with a configurable property&quot;_s);
</pre>
<hr />
<pre>
 396     case PropertySlot::InternalMethodType::GetOwnProperty:
 397         RELEASE_AND_RETURN(scope, performInternalMethodGetOwnProperty(exec, propertyName, slot));
 398     case PropertySlot::InternalMethodType::HasProperty:
 399         RELEASE_AND_RETURN(scope, performHasProperty(exec, propertyName, slot));
 400     default:
 401         return false;
 402     }
 403 
 404     RELEASE_ASSERT_NOT_REACHED();
 405     return false;
 406 }
 407 
 408 bool ProxyObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)
 409 {
 410     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 411     return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);
 412 }
 413 
 414 bool ProxyObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)
 415 {
<span class="line-added"> 416     VM&amp; vm = exec-&gt;vm();</span>
 417     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
<span class="line-modified"> 418     Identifier ident = Identifier::from(vm, propertyName);</span>
 419     return thisObject-&gt;getOwnPropertySlotCommon(exec, ident.impl(), slot);
 420 }
 421 
 422 template &lt;typename PerformDefaultPutFunction&gt;
<span class="line-modified"> 423 bool ProxyObject::performPut(ExecState* exec, JSValue putValue, JSValue thisValue, PropertyName propertyName, PerformDefaultPutFunction performDefaultPut, bool shouldThrow)</span>
 424 {
 425     NO_TAIL_CALLS();
 426 
 427     VM&amp; vm = exec-&gt;vm();
 428     auto scope = DECLARE_THROW_SCOPE(vm);
 429     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 430         throwStackOverflowError(exec, scope);
 431         return false;
 432     }
 433 
 434     if (propertyName.isPrivateName())
<span class="line-modified"> 435         return false;</span>
 436 
 437     JSValue handlerValue = this-&gt;handler();
 438     if (handlerValue.isNull()) {
 439         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 440         return false;
 441     }
 442 
 443     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 444     CallData callData;
 445     CallType callType;
 446     JSValue setMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;set, &quot;&#39;set&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 447     RETURN_IF_EXCEPTION(scope, false);
 448     JSObject* target = this-&gt;target();
 449     if (setMethod.isUndefined())
 450         RELEASE_AND_RETURN(scope, performDefaultPut());
 451 
 452     MarkedArgumentBuffer arguments;
 453     arguments.append(target);
<span class="line-modified"> 454     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 455     arguments.append(putValue);
 456     arguments.append(thisValue);
 457     ASSERT(!arguments.hasOverflowed());
 458     JSValue trapResult = call(exec, setMethod, callType, callData, handler, arguments);
 459     RETURN_IF_EXCEPTION(scope, false);
 460     bool trapResultAsBool = trapResult.toBoolean(exec);
 461     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 462     if (!trapResultAsBool) {</span>
<span class="line-added"> 463         if (shouldThrow)</span>
<span class="line-added"> 464             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;set&#39; trap returned falsy value for property &#39;&quot;, String(propertyName.uid()), &quot;&#39;&quot;));</span>
 465         return false;
<span class="line-added"> 466     }</span>
 467 
 468     PropertyDescriptor descriptor;
 469     bool hasProperty = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);
 470     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 471     if (hasProperty) {
 472         if (descriptor.isDataDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; !descriptor.writable()) {
 473             if (!sameValue(exec, descriptor.value(), putValue)) {
 474                 throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; on a non-configurable and non-writable property on &#39;target&#39; should either return false or be the same value already on the &#39;target&#39;&quot;_s);
 475                 return false;
 476             }
 477         } else if (descriptor.isAccessorDescriptor() &amp;&amp; !descriptor.configurable() &amp;&amp; descriptor.setter().isUndefined()) {
 478             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;set&#39; method on a non-configurable accessor property without a setter should return false&quot;_s);
 479             return false;
 480         }
 481     }
 482     return true;
 483 }
 484 
 485 bool ProxyObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
 486 {
 487     VM&amp; vm = exec-&gt;vm();
 488     slot.disableCaching();
 489 
 490     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 491     auto performDefaultPut = [&amp;] () {
 492         JSObject* target = jsCast&lt;JSObject*&gt;(thisObject-&gt;target());
 493         return target-&gt;methodTable(vm)-&gt;put(target, exec, propertyName, value, slot);
 494     };
<span class="line-modified"> 495     return thisObject-&gt;performPut(exec, value, slot.thisValue(), propertyName, performDefaultPut, slot.isStrictMode());</span>
 496 }
 497 
 498 bool ProxyObject::putByIndexCommon(ExecState* exec, JSValue thisValue, unsigned propertyName, JSValue putValue, bool shouldThrow)
 499 {
 500     VM&amp; vm = exec-&gt;vm();
 501     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 502     Identifier ident = Identifier::from(vm, propertyName);</span>
 503     RETURN_IF_EXCEPTION(scope, false);
 504     auto performDefaultPut = [&amp;] () {
 505         JSObject* target = this-&gt;target();
 506         bool isStrictMode = shouldThrow;
 507         PutPropertySlot slot(thisValue, isStrictMode); // We must preserve the &quot;this&quot; target of the putByIndex.
 508         return target-&gt;methodTable(vm)-&gt;put(target, exec, ident.impl(), putValue, slot);
 509     };
<span class="line-modified"> 510     RELEASE_AND_RETURN(scope, performPut(exec, putValue, thisValue, ident.impl(), performDefaultPut, shouldThrow));</span>
 511 }
 512 
 513 bool ProxyObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
 514 {
 515     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 516     return thisObject-&gt;putByIndexCommon(exec, thisObject, propertyName, value, shouldThrow);
 517 }
 518 
 519 static EncodedJSValue JSC_HOST_CALL performProxyCall(ExecState* exec)
 520 {
 521     NO_TAIL_CALLS();
 522 
 523     VM&amp; vm = exec-&gt;vm();
 524     auto scope = DECLARE_THROW_SCOPE(vm);
 525     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 526         throwStackOverflowError(exec, scope);
 527         return encodedJSValue();
 528     }
 529     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());
 530     JSValue handlerValue = proxy-&gt;handler();
</pre>
<hr />
<pre>
 568 }
 569 
 570 static EncodedJSValue JSC_HOST_CALL performProxyConstruct(ExecState* exec)
 571 {
 572     NO_TAIL_CALLS();
 573 
 574     VM&amp; vm = exec-&gt;vm();
 575     auto scope = DECLARE_THROW_SCOPE(vm);
 576     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 577         throwStackOverflowError(exec, scope);
 578         return encodedJSValue();
 579     }
 580     ProxyObject* proxy = jsCast&lt;ProxyObject*&gt;(exec-&gt;jsCallee());
 581     JSValue handlerValue = proxy-&gt;handler();
 582     if (handlerValue.isNull())
 583         return throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 584 
 585     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 586     CallData callData;
 587     CallType callType;
<span class="line-modified"> 588     JSValue constructMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;construct&quot;), &quot;&#39;construct&#39; property of a Proxy&#39;s handler should be callable&quot;_s);</span>
 589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 590     JSObject* target = proxy-&gt;target();
 591     if (constructMethod.isUndefined()) {
 592         ConstructData constructData;
 593         ConstructType constructType = target-&gt;methodTable(vm)-&gt;getConstructData(target, constructData);
 594         RELEASE_ASSERT(constructType != ConstructType::None);
 595         RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, target, constructType, constructData, ArgList(exec), exec-&gt;newTarget())));
 596     }
 597 
 598     JSArray* argArray = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(nullptr), ArgList(exec));
 599     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 600     MarkedArgumentBuffer arguments;
 601     arguments.append(target);
 602     arguments.append(argArray);
 603     arguments.append(exec-&gt;newTarget());
 604     ASSERT(!arguments.hasOverflowed());
 605     JSValue result = call(exec, constructMethod, callType, callData, handler, arguments);
 606     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 607     if (!result.isObject())
 608         return throwVMTypeError(exec, scope, &quot;Result from Proxy handler&#39;s &#39;construct&#39; method should be an object&quot;_s);
</pre>
<hr />
<pre>
 618         return ConstructType::None;
 619     }
 620 
 621     constructData.native.function = performProxyConstruct;
 622     return ConstructType::Host;
 623 }
 624 
 625 template &lt;typename DefaultDeleteFunction&gt;
 626 bool ProxyObject::performDelete(ExecState* exec, PropertyName propertyName, DefaultDeleteFunction performDefaultDelete)
 627 {
 628     NO_TAIL_CALLS();
 629 
 630     VM&amp; vm = exec-&gt;vm();
 631     auto scope = DECLARE_THROW_SCOPE(vm);
 632     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 633         throwStackOverflowError(exec, scope);
 634         return false;
 635     }
 636 
 637     if (propertyName.isPrivateName())
<span class="line-modified"> 638         return false;</span>
 639 
 640     JSValue handlerValue = this-&gt;handler();
 641     if (handlerValue.isNull()) {
 642         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 643         return false;
 644     }
 645 
 646     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 647     CallData callData;
 648     CallType callType;
 649     JSValue deletePropertyMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;deleteProperty&quot;), &quot;&#39;deleteProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 650     RETURN_IF_EXCEPTION(scope, false);
 651     JSObject* target = this-&gt;target();
 652     if (deletePropertyMethod.isUndefined())
 653         RELEASE_AND_RETURN(scope, performDefaultDelete());
 654 
 655     MarkedArgumentBuffer arguments;
 656     arguments.append(target);
<span class="line-modified"> 657     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 658     ASSERT(!arguments.hasOverflowed());
 659     JSValue trapResult = call(exec, deletePropertyMethod, callType, callData, handler, arguments);
 660     RETURN_IF_EXCEPTION(scope, false);
 661 
 662     bool trapResultAsBool = trapResult.toBoolean(exec);
 663     RETURN_IF_EXCEPTION(scope, false);
 664 
 665     if (!trapResultAsBool)
 666         return false;
 667 
 668     PropertyDescriptor descriptor;
<span class="line-modified"> 669     bool result = target-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
<span class="line-added"> 670     EXCEPTION_ASSERT(!scope.exception() || !result);</span>
<span class="line-added"> 671     if (result) {</span>
 672         if (!descriptor.configurable()) {
 673             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target&#39;s property is not configurable&quot;_s);
 674             return false;
 675         }
<span class="line-added"> 676         bool targetIsExtensible = target-&gt;isExtensible(exec);</span>
<span class="line-added"> 677         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added"> 678         if (!targetIsExtensible) {</span>
<span class="line-added"> 679             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;deleteProperty&#39; method should return false when the target has property and is not extensible&quot;_s);</span>
<span class="line-added"> 680             return false;</span>
<span class="line-added"> 681         }</span>
 682     }
 683 
 684     RETURN_IF_EXCEPTION(scope, false);
 685 
 686     return true;
 687 }
 688 
 689 bool ProxyObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
 690 {
 691     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
 692     auto performDefaultDelete = [&amp;] () -&gt; bool {
 693         JSObject* target = thisObject-&gt;target();
 694         return target-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(target, exec, propertyName);
 695     };
 696     return thisObject-&gt;performDelete(exec, propertyName, performDefaultDelete);
 697 }
 698 
 699 bool ProxyObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)
 700 {
<span class="line-added"> 701     VM&amp; vm = exec-&gt;vm();</span>
 702     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(cell);
<span class="line-modified"> 703     Identifier ident = Identifier::from(vm, propertyName);</span>
 704     auto performDefaultDelete = [&amp;] () -&gt; bool {
 705         JSObject* target = thisObject-&gt;target();
<span class="line-modified"> 706         return target-&gt;methodTable(vm)-&gt;deletePropertyByIndex(target, exec, propertyName);</span>
 707     };
 708     return thisObject-&gt;performDelete(exec, ident.impl(), performDefaultDelete);
 709 }
 710 
 711 bool ProxyObject::performPreventExtensions(ExecState* exec)
 712 {
 713     NO_TAIL_CALLS();
 714 
 715     VM&amp; vm = exec-&gt;vm();
 716     auto scope = DECLARE_THROW_SCOPE(vm);
 717     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 718         throwStackOverflowError(exec, scope);
 719         return false;
 720     }
 721 
 722     JSValue handlerValue = this-&gt;handler();
 723     if (handlerValue.isNull()) {
 724         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 725         return false;
 726     }
</pre>
<hr />
<pre>
 818     return jsCast&lt;ProxyObject*&gt;(object)-&gt;performIsExtensible(exec);
 819 }
 820 
 821 bool ProxyObject::performDefineOwnProperty(ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
 822 {
 823     NO_TAIL_CALLS();
 824 
 825     VM&amp; vm = exec-&gt;vm();
 826     auto scope = DECLARE_THROW_SCOPE(vm);
 827     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 828         throwStackOverflowError(exec, scope);
 829         return false;
 830     }
 831 
 832     JSObject* target = this-&gt;target();
 833     auto performDefaultDefineOwnProperty = [&amp;] {
 834         RELEASE_AND_RETURN(scope, target-&gt;methodTable(vm)-&gt;defineOwnProperty(target, exec, propertyName, descriptor, shouldThrow));
 835     };
 836 
 837     if (propertyName.isPrivateName())
<span class="line-modified"> 838         return false;</span>
 839 
 840     JSValue handlerValue = this-&gt;handler();
 841     if (handlerValue.isNull()) {
 842         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 843         return false;
 844     }
 845 
 846     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 847     CallData callData;
 848     CallType callType;
 849     JSValue definePropertyMethod = handler-&gt;getMethod(exec, callData, callType, vm.propertyNames-&gt;defineProperty, &quot;&#39;defineProperty&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 850     RETURN_IF_EXCEPTION(scope, false);
 851 
 852     if (definePropertyMethod.isUndefined())
 853         return performDefaultDefineOwnProperty();
 854 
 855     JSObject* descriptorObject = constructObjectFromPropertyDescriptor(exec, descriptor);
 856     RETURN_IF_EXCEPTION(scope, false);
 857 
 858     MarkedArgumentBuffer arguments;
 859     arguments.append(target);
<span class="line-modified"> 860     arguments.append(identifierToSafePublicJSValue(vm, Identifier::fromUid(vm, propertyName.uid())));</span>
 861     arguments.append(descriptorObject);
 862     ASSERT(!arguments.hasOverflowed());
 863     JSValue trapResult = call(exec, definePropertyMethod, callType, callData, handler, arguments);
 864     RETURN_IF_EXCEPTION(scope, false);
 865 
 866     bool trapResultAsBool = trapResult.toBoolean(exec);
 867     RETURN_IF_EXCEPTION(scope, false);
 868 
 869     if (!trapResultAsBool)
 870         return false;
 871 
 872     PropertyDescriptor targetDescriptor;
 873     bool isTargetDescriptorDefined = target-&gt;getOwnPropertyDescriptor(exec, propertyName, targetDescriptor);
 874     RETURN_IF_EXCEPTION(scope, false);
 875 
 876     bool targetIsExtensible = target-&gt;isExtensible(exec);
 877     RETURN_IF_EXCEPTION(scope, false);
 878     bool settingConfigurableToFalse = descriptor.configurablePresent() &amp;&amp; !descriptor.configurable();
 879 
 880     if (!isTargetDescriptorDefined) {
</pre>
<hr />
<pre>
 887             return false;
 888         }
 889 
 890         return true;
 891     }
 892 
 893     ASSERT(isTargetDescriptorDefined);
 894     bool isCurrentDefined = isTargetDescriptorDefined;
 895     const PropertyDescriptor&amp; current = targetDescriptor;
 896     bool throwException = false;
 897     bool isCompatibleDescriptor = validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, targetIsExtensible, descriptor, isCurrentDefined, current, throwException);
 898     RETURN_IF_EXCEPTION(scope, false);
 899     if (!isCompatibleDescriptor) {
 900         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a property on its target that is compatible with the trap&#39;s input descriptor&quot;_s);
 901         return false;
 902     }
 903     if (settingConfigurableToFalse &amp;&amp; targetDescriptor.configurable()) {
 904         throwVMTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap did not define a non-configurable property on its target even though the input descriptor to the trap said it must do so&quot;_s);
 905         return false;
 906     }
<span class="line-added"> 907     if (targetDescriptor.isDataDescriptor() &amp;&amp; !targetDescriptor.configurable() &amp;&amp; targetDescriptor.writable()) {</span>
<span class="line-added"> 908         if (descriptor.writablePresent() &amp;&amp; !descriptor.writable()) {</span>
<span class="line-added"> 909             throwTypeError(exec, scope, &quot;Proxy&#39;s &#39;defineProperty&#39; trap returned true for a non-writable input descriptor when the target&#39;s property is non-configurable and writable&quot;_s);</span>
<span class="line-added"> 910             return false;</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912     }</span>
 913 
 914     return true;
 915 }
 916 
 917 bool ProxyObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)
 918 {
 919     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
 920     return thisObject-&gt;performDefineOwnProperty(exec, propertyName, descriptor, shouldThrow);
 921 }
 922 
<span class="line-modified"> 923 void ProxyObject::performGetOwnPropertyNames(ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode enumerationMode)</span>
 924 {
 925     NO_TAIL_CALLS();
 926 
 927     VM&amp; vm = exec-&gt;vm();
 928     auto scope = DECLARE_THROW_SCOPE(vm);
 929     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
 930         throwStackOverflowError(exec, scope);
 931         return;
 932     }
 933     JSValue handlerValue = this-&gt;handler();
 934     if (handlerValue.isNull()) {
 935         throwVMTypeError(exec, scope, s_proxyAlreadyRevokedErrorMessage);
 936         return;
 937     }
 938 
 939     JSObject* handler = jsCast&lt;JSObject*&gt;(handlerValue);
 940     CallData callData;
 941     CallType callType;
 942     JSValue ownKeysMethod = handler-&gt;getMethod(exec, callData, callType, makeIdentifier(vm, &quot;ownKeys&quot;), &quot;&#39;ownKeys&#39; property of a Proxy&#39;s handler should be callable&quot;_s);
 943     RETURN_IF_EXCEPTION(scope, void());
 944     JSObject* target = this-&gt;target();
 945     if (ownKeysMethod.isUndefined()) {
 946         scope.release();
<span class="line-modified"> 947         target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, propertyNames, enumerationMode);</span>
 948         return;
 949     }
 950 
 951     MarkedArgumentBuffer arguments;
 952     arguments.append(target);
 953     ASSERT(!arguments.hasOverflowed());
 954     JSValue arrayLikeObject = call(exec, ownKeysMethod, callType, callData, handler, arguments);
 955     RETURN_IF_EXCEPTION(scope, void());
 956 
<span class="line-modified"> 957     PropertyNameArray trapResult(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>














 958     HashSet&lt;UniquedStringImpl*&gt; uncheckedResultKeys;
<span class="line-added"> 959     {</span>
<span class="line-added"> 960         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;&gt; seenKeys;</span>
 961 
<span class="line-modified"> 962         RuntimeTypeMask resultFilter = 0;</span>
<span class="line-modified"> 963         switch (propertyNames.propertyNameMode()) {</span>
<span class="line-modified"> 964         case PropertyNameMode::Symbols:</span>
<span class="line-modified"> 965             resultFilter = TypeSymbol;</span>
<span class="line-modified"> 966             break;</span>
<span class="line-modified"> 967         case PropertyNameMode::Strings:</span>
<span class="line-added"> 968             resultFilter = TypeString;</span>
<span class="line-added"> 969             break;</span>
<span class="line-added"> 970         case PropertyNameMode::StringsAndSymbols:</span>
<span class="line-added"> 971             resultFilter = TypeSymbol | TypeString;</span>
<span class="line-added"> 972             break;</span>
<span class="line-added"> 973         }</span>
<span class="line-added"> 974         ASSERT(resultFilter);</span>
<span class="line-added"> 975 </span>
<span class="line-added"> 976         auto addPropName = [&amp;] (JSValue value, RuntimeType type) -&gt; bool {</span>
<span class="line-added"> 977             static const bool doExitEarly = true;</span>
<span class="line-added"> 978             static const bool dontExitEarly = false;</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980             Identifier ident = value.toPropertyKey(exec);</span>
<span class="line-added"> 981             RETURN_IF_EXCEPTION(scope, doExitEarly);</span>
<span class="line-added"> 982 </span>
<span class="line-added"> 983             // If trapResult contains any duplicate entries, throw a TypeError exception.</span>
<span class="line-added"> 984             //</span>
<span class="line-added"> 985             // Per spec[1], filtering by type should occur _after_ [[OwnPropertyKeys]], so duplicates</span>
<span class="line-added"> 986             // are tracked in a separate hashtable from uncheckedResultKeys (which only contain the</span>
<span class="line-added"> 987             // keys filtered by type).</span>
<span class="line-added"> 988             //</span>
<span class="line-added"> 989             // [1] Per https://tc39.github.io/ecma262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeysmust not contain any duplicate names&quot;_s);</span>
<span class="line-added"> 990             if (!seenKeys.add(ident.impl()).isNewEntry) {</span>
<span class="line-added"> 991                 throwTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; trap result must not contain any duplicate names&quot;_s);</span>
<span class="line-added"> 992                 return doExitEarly;</span>
<span class="line-added"> 993             }</span>
 994 
<span class="line-modified"> 995             if (!(type &amp; resultFilter))</span>
<span class="line-modified"> 996                 return dontExitEarly;</span>
 997 
<span class="line-modified"> 998             uncheckedResultKeys.add(ident.impl());</span>
<span class="line-modified"> 999             trapResult.add(ident.impl());</span>
<span class="line-modified">1000             return dontExitEarly;</span>
<span class="line-modified">1001         };</span>
1002 
<span class="line-modified">1003         RuntimeTypeMask dontThrowAnExceptionTypeFilter = TypeString | TypeSymbol;</span>
<span class="line-modified">1004         createListFromArrayLike(exec, arrayLikeObject, dontThrowAnExceptionTypeFilter, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an object&quot;_s, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method must return an array-like object containing only Strings and Symbols&quot;_s, addPropName);</span>
<span class="line-added">1005         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">1006     }</span>
1007 
1008     bool targetIsExensible = target-&gt;isExtensible(exec);
1009     RETURN_IF_EXCEPTION(scope, void());
1010 
<span class="line-modified">1011     PropertyNameArray targetKeys(vm, propertyNames.propertyNameMode(), propertyNames.privateSymbolMode());</span>
1012     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, targetKeys, enumerationMode);
1013     RETURN_IF_EXCEPTION(scope, void());
1014     Vector&lt;UniquedStringImpl*&gt; targetConfigurableKeys;
1015     Vector&lt;UniquedStringImpl*&gt; targetNonConfigurableKeys;
1016     for (const Identifier&amp; ident : targetKeys) {
1017         PropertyDescriptor descriptor;
1018         bool isPropertyDefined = target-&gt;getOwnPropertyDescriptor(exec, ident.impl(), descriptor);
1019         RETURN_IF_EXCEPTION(scope, void());
1020         if (isPropertyDefined &amp;&amp; !descriptor.configurable())
1021             targetNonConfigurableKeys.append(ident.impl());
1022         else
1023             targetConfigurableKeys.append(ident.impl());
1024     }
1025 
1026     enum ContainedIn { IsContainedIn, IsNotContainedIn };
1027     auto removeIfContainedInUncheckedResultKeys = [&amp;] (UniquedStringImpl* impl) -&gt; ContainedIn {
1028         auto iter = uncheckedResultKeys.find(impl);
1029         if (iter == uncheckedResultKeys.end())
1030             return IsNotContainedIn;
1031 
1032         uncheckedResultKeys.remove(iter);
1033         return IsContainedIn;
1034     };
1035 
1036     for (UniquedStringImpl* impl : targetNonConfigurableKeys) {
1037         if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {
1038             throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s &#39;target&#39; has the non-configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));
1039             return;
1040         }
1041     }
1042 
<span class="line-modified">1043     if (!targetIsExensible) {</span>
<span class="line-modified">1044         for (UniquedStringImpl* impl : targetConfigurableKeys) {</span>
<span class="line-added">1045             if (removeIfContainedInUncheckedResultKeys(impl) == IsNotContainedIn) {</span>
<span class="line-added">1046                 throwVMTypeError(exec, scope, makeString(&quot;Proxy object&#39;s non-extensible &#39;target&#39; has configurable property &#39;&quot;, String(impl), &quot;&#39; that was not in the result from the &#39;ownKeys&#39; trap&quot;));</span>
<span class="line-added">1047                 return;</span>
<span class="line-added">1048             }</span>
<span class="line-added">1049         }</span>
1050 
<span class="line-modified">1051         if (uncheckedResultKeys.size()) {</span>
<span class="line-modified">1052             throwVMTypeError(exec, scope, &quot;Proxy handler&#39;s &#39;ownKeys&#39; method returned a key that was not present in its non-extensible target&quot;_s);</span>

1053             return;
1054         }
1055     }
1056 
<span class="line-modified">1057     if (!enumerationMode.includeDontEnumProperties()) {</span>
<span class="line-modified">1058         // Filtering DontEnum properties is observable in proxies and must occur following the invariant checks above.</span>
<span class="line-modified">1059         for (auto propertyName : trapResult) {</span>
<span class="line-added">1060             PropertySlot slot(this, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-added">1061             auto result = getOwnPropertySlotCommon(exec, propertyName, slot);</span>
<span class="line-added">1062             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">1063             if (!result)</span>
<span class="line-added">1064                 continue;</span>
<span class="line-added">1065             if (slot.attributes() &amp; PropertyAttribute::DontEnum)</span>
<span class="line-added">1066                 continue;</span>
<span class="line-added">1067             propertyNames.add(propertyName.impl());</span>
<span class="line-added">1068         }</span>
<span class="line-added">1069     } else {</span>
<span class="line-added">1070         for (auto propertyName : trapResult)</span>
<span class="line-added">1071             propertyNames.add(propertyName.impl());</span>
1072     }
1073 }
1074 
1075 void ProxyObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
1076 {
1077     ProxyObject* thisObject = jsCast&lt;ProxyObject*&gt;(object);
1078     thisObject-&gt;performGetOwnPropertyNames(exec, propertyNameArray, enumerationMode);
1079 }
1080 
1081 void ProxyObject::getPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)
1082 {
1083     NO_TAIL_CALLS();
1084     JSObject::getPropertyNames(object, exec, propertyNameArray, enumerationMode);
1085 }
1086 
1087 void ProxyObject::getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode)
1088 {
1089     RELEASE_ASSERT_NOT_REACHED();
1090 }
1091 
</pre>
</td>
</tr>
</table>
<center><a href="ProxyConstructor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProxyObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>