<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Validate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3Validate.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirCode.h&quot;
 32 #include &quot;B3ArgumentRegValue.h&quot;
 33 #include &quot;B3AtomicValue.h&quot;
 34 #include &quot;B3BasicBlockInlines.h&quot;
 35 #include &quot;B3Dominators.h&quot;
 36 #include &quot;B3MemoryValue.h&quot;
 37 #include &quot;B3Procedure.h&quot;
 38 #include &quot;B3SlotBaseValue.h&quot;
 39 #include &quot;B3StackSlot.h&quot;
 40 #include &quot;B3SwitchValue.h&quot;
 41 #include &quot;B3UpsilonValue.h&quot;
 42 #include &quot;B3ValueInlines.h&quot;
 43 #include &quot;B3Variable.h&quot;
 44 #include &quot;B3VariableValue.h&quot;
 45 #include &quot;B3WasmBoundsCheckValue.h&quot;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/StringPrintStream.h&gt;
 48 #include &lt;wtf/text/CString.h&gt;
 49 
 50 namespace JSC { namespace B3 {
 51 
 52 namespace {
 53 
 54 class Validater {
 55 public:
 56     Validater(Procedure&amp; procedure, const char* dumpBefore)
 57         : m_procedure(procedure)
 58         , m_dumpBefore(dumpBefore)
 59     {
 60     }
 61 
 62 #define VALIDATE(condition, message) do {                               \
 63         if (condition)                                                  \
 64             break;                                                      \
 65         fail(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition, toCString message); \
 66     } while (false)
 67 
 68     void run()
 69     {
 70         HashSet&lt;BasicBlock*&gt; blocks;
 71         HashSet&lt;Value*&gt; valueInProc;
 72         HashMap&lt;Value*, unsigned&gt; valueInBlock;
 73         HashMap&lt;Value*, BasicBlock*&gt; valueOwner;
 74         HashMap&lt;Value*, unsigned&gt; valueIndex;
<a name="1" id="anc1"></a><span class="line-added"> 75         HashMap&lt;Value*, Vector&lt;Optional&lt;Type&gt;&gt;&gt; extractions;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77         for (unsigned tuple = 0; tuple &lt; m_procedure.tuples().size(); ++tuple) {</span>
<span class="line-added"> 78             VALIDATE(m_procedure.tuples()[tuple].size(), (&quot;In tuple &quot;, tuple));</span>
<span class="line-added"> 79             for (unsigned i = 0; i &lt; m_procedure.tuples()[tuple].size(); ++i)</span>
<span class="line-added"> 80                 VALIDATE(m_procedure.tuples()[tuple][i].isNumeric(), (&quot;In tuple &quot;, tuple, &quot; at index&quot;, i));</span>
<span class="line-added"> 81         }</span>
 82 
 83         for (BasicBlock* block : m_procedure) {
 84             blocks.add(block);
 85             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 86                 Value* value = block-&gt;at(i);
 87                 valueInBlock.add(value, 0).iterator-&gt;value++;
 88                 valueOwner.add(value, block);
 89                 valueIndex.add(value, i);
 90             }
 91         }
 92 
 93         for (Value* value : m_procedure.values())
 94             valueInProc.add(value);
 95 
 96         for (Value* value : valueInProc)
 97             VALIDATE(valueInBlock.contains(value), (&quot;At &quot;, *value));
 98         for (auto&amp; entry : valueInBlock) {
 99             VALIDATE(valueInProc.contains(entry.key), (&quot;At &quot;, *entry.key));
100             VALIDATE(entry.value == 1, (&quot;At &quot;, *entry.key));
101         }
102 
103         // Compute dominators ourselves to avoid perturbing Procedure.
104         Dominators dominators(m_procedure);
105 
106         for (Value* value : valueInProc) {
107             for (Value* child : value-&gt;children()) {
108                 VALIDATE(child, (&quot;At &quot;, *value));
109                 VALIDATE(valueInProc.contains(child), (&quot;At &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
110                 if (valueOwner.get(child) == valueOwner.get(value))
111                     VALIDATE(valueIndex.get(value) &gt; valueIndex.get(child), (&quot;At &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
112                 else
113                     VALIDATE(dominators.dominates(valueOwner.get(child), valueOwner.get(value)), (&quot;at &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
114             }
115         }
116 
117         HashMap&lt;BasicBlock*, HashSet&lt;BasicBlock*&gt;&gt; allPredecessors;
118         for (BasicBlock* block : blocks) {
119             VALIDATE(block-&gt;size() &gt;= 1, (&quot;At &quot;, *block));
120             for (unsigned i = 0; i &lt; block-&gt;size() - 1; ++i)
121                 VALIDATE(!block-&gt;at(i)-&gt;effects().terminal, (&quot;At &quot;, *block-&gt;at(i)));
122             VALIDATE(block-&gt;last()-&gt;effects().terminal, (&quot;At &quot;, *block-&gt;last()));
123 
124             for (BasicBlock* successor : block-&gt;successorBlocks()) {
125                 allPredecessors.add(successor, HashSet&lt;BasicBlock*&gt;()).iterator-&gt;value.add(block);
126                 VALIDATE(
127                     blocks.contains(successor), (&quot;At &quot;, *block, &quot;-&gt;&quot;, pointerDump(successor)));
128             }
129         }
130 
131         // Note that this totally allows dead code.
132         for (auto&amp; entry : allPredecessors) {
133             BasicBlock* successor = entry.key;
134             HashSet&lt;BasicBlock*&gt;&amp; predecessors = entry.value;
135             VALIDATE(predecessors == successor-&gt;predecessors(), (&quot;At &quot;, *successor));
136         }
137 
138         for (Value* value : m_procedure.values()) {
139             for (Value* child : value-&gt;children())
140                 VALIDATE(child-&gt;type() != Void, (&quot;At &quot;, *value, &quot;-&gt;&quot;, *child));
141             switch (value-&gt;opcode()) {
142             case Nop:
143             case Fence:
144                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
145                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
146                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
147                 break;
148             case Identity:
149             case Opaque:
150                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
151                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
152                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
153                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
154                 break;
155             case Const32:
156                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
157                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
158                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
159                 break;
160             case Const64:
161                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
162                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
163                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
164                 break;
165             case ConstDouble:
166                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
167                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
168                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
169                 break;
170             case ConstFloat:
171                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
172                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
173                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
174                 break;
175             case Set:
176                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
177                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
178                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;VariableValue&gt;()-&gt;variable()-&gt;type(), (&quot;At &quot;, *value));
179                 break;
180             case Get:
181                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
182                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
183                 VALIDATE(value-&gt;type() == value-&gt;as&lt;VariableValue&gt;()-&gt;variable()-&gt;type(), (&quot;At &quot;, *value));
184                 break;
185             case SlotBase:
186             case FramePointer:
187                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
188                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
189                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
190                 break;
191             case ArgumentReg:
192                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
193                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
194                 VALIDATE(
195                     (value-&gt;as&lt;ArgumentRegValue&gt;()-&gt;argumentReg().isGPR() ? pointerType() : Double)
196                     == value-&gt;type(), (&quot;At &quot;, *value));
197                 break;
198             case Add:
199             case Sub:
200             case Mul:
201             case Div:
202             case UDiv:
203             case Mod:
204             case UMod:
205             case BitAnd:
206             case BitOr:
207             case BitXor:
208                 VALIDATE(!value-&gt;kind().traps(), (&quot;At &quot;, *value));
209                 switch (value-&gt;opcode()) {
210                 case Div:
211                 case Mod:
212                     if (value-&gt;isChill()) {
213                         VALIDATE(value-&gt;opcode() == Div || value-&gt;opcode() == Mod, (&quot;At &quot;, *value));
<a name="2" id="anc2"></a><span class="line-modified">214                         VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
215                     }
216                     break;
217                 default:
218                     VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
219                     break;
220                 }
221                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
222                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
223                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<a name="3" id="anc3"></a><span class="line-modified">224                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
225                 break;
226             case Neg:
227                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
228                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
229                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<a name="4" id="anc4"></a><span class="line-modified">230                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
231                 break;
232             case Shl:
233             case SShr:
234             case ZShr:
235             case RotR:
236                 case RotL:
237                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
238                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
239                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
240                 VALIDATE(value-&gt;child(1)-&gt;type() == Int32, (&quot;At &quot;, *value));
<a name="5" id="anc5"></a><span class="line-modified">241                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
242                 break;
243             case BitwiseCast:
244                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
245                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
246                 VALIDATE(value-&gt;type() != value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
247                 VALIDATE(
248                     (value-&gt;type() == Int64 &amp;&amp; value-&gt;child(0)-&gt;type() == Double)
249                     || (value-&gt;type() == Double &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
250                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Int32)
251                     || (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Float),
252                     (&quot;At &quot;, *value));
253                 break;
254             case SExt8:
255             case SExt16:
256                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
257                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
258                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
259                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
260                 break;
261             case SExt32:
262             case ZExt32:
263                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
264                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
265                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
266                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
267                 break;
268             case Clz:
269                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
270                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="6" id="anc6"></a><span class="line-modified">271                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
<span class="line-modified">272                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
273                 break;
274             case Trunc:
275                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
276                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
277                 VALIDATE(
278                     (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
279                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Double),
280                     (&quot;At &quot;, *value));
281                 break;
282             case Abs:
283             case Ceil:
284             case Floor:
285             case Sqrt:
286                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
287                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="7" id="anc7"></a><span class="line-modified">288                 VALIDATE(value-&gt;child(0)-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
<span class="line-modified">289                 VALIDATE(value-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
290                 break;
291             case IToD:
292                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
293                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="8" id="anc8"></a><span class="line-modified">294                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
295                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
296                 break;
297             case IToF:
298                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
299                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="9" id="anc9"></a><span class="line-modified">300                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
301                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
302                 break;
303             case FloatToDouble:
304                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
305                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
306                 VALIDATE(value-&gt;child(0)-&gt;type() == Float, (&quot;At &quot;, *value));
307                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
308                 break;
309             case DoubleToFloat:
310                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
311                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
312                 VALIDATE(value-&gt;child(0)-&gt;type() == Double, (&quot;At &quot;, *value));
313                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
314                 break;
315             case Equal:
316             case NotEqual:
317             case LessThan:
318             case GreaterThan:
319             case LessEqual:
320             case GreaterEqual:
321                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
322                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
323                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
324                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
325                 break;
326             case Above:
327             case Below:
328             case AboveEqual:
329             case BelowEqual:
330                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
331                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
332                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<a name="10" id="anc10"></a><span class="line-modified">333                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
334                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
335                 break;
336             case EqualOrUnordered:
337                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
338                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
339                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<a name="11" id="anc11"></a><span class="line-modified">340                 VALIDATE(value-&gt;child(0)-&gt;type().isFloat(), (&quot;At &quot;, *value));</span>
341                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
342                 break;
343             case Select:
344                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
345                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
<a name="12" id="anc12"></a><span class="line-modified">346                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
347                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
348                 VALIDATE(value-&gt;type() == value-&gt;child(2)-&gt;type(), (&quot;At &quot;, *value));
349                 break;
350             case Load8Z:
351             case Load8S:
352             case Load16Z:
353             case Load16S:
354                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
355                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
356                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
357                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
358                 validateFence(value);
359                 validateStackAccess(value);
360                 break;
361             case Load:
362                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
363                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
364                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
<a name="13" id="anc13"></a><span class="line-modified">365                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
366                 validateFence(value);
367                 validateStackAccess(value);
368                 break;
369             case Store8:
370             case Store16:
371                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
372                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
373                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
374                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
375                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
376                 validateFence(value);
377                 validateStackAccess(value);
378                 break;
379             case Store:
380                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
381                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
382                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
383                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
384                 validateFence(value);
385                 validateStackAccess(value);
386                 break;
387             case AtomicWeakCAS:
388                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
389                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
390                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
391                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<a name="14" id="anc14"></a><span class="line-modified">392                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
393                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
394                 validateAtomic(value);
395                 validateStackAccess(value);
396                 break;
397             case AtomicStrongCAS:
398                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
399                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
400                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
401                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
<a name="15" id="anc15"></a><span class="line-modified">402                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
403                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
404                 validateAtomic(value);
405                 validateStackAccess(value);
406                 break;
407             case AtomicXchgAdd:
408             case AtomicXchgAnd:
409             case AtomicXchgOr:
410             case AtomicXchgSub:
411             case AtomicXchgXor:
412             case AtomicXchg:
413                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
414                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
415                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<a name="16" id="anc16"></a><span class="line-modified">416                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
417                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
418                 validateAtomic(value);
419                 validateStackAccess(value);
420                 break;
421             case Depend:
422                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
423                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
424                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
<a name="17" id="anc17"></a><span class="line-modified">425                 VALIDATE(value-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
426                 break;
427             case WasmAddress:
428                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
429                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
430                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
431                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
432                 break;
433             case CCall:
434                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
435                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
436                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
437                 break;
438             case Patchpoint:
439                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
<a name="18" id="anc18"></a><span class="line-modified">440                 if (value-&gt;type() == Void) {</span>
<span class="line-modified">441                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == 1, (&quot;At &quot;, *value));</span>
<span class="line-modified">442                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[0] == ValueRep::WarmAny, (&quot;At &quot;, *value));</span>
<span class="line-modified">443                 } else {</span>
<span class="line-added">444                     if (value-&gt;type().isNumeric()) {</span>
<span class="line-added">445                         VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == 1, (&quot;At &quot;, *value));</span>
<span class="line-added">446                         validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[0]), ConstraintRole::Def);</span>
<span class="line-added">447                     } else {</span>
<span class="line-added">448                         VALIDATE(m_procedure.isValidTuple(value-&gt;type()), (&quot;At &quot;, *value));</span>
<span class="line-added">449                         VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size() == m_procedure.tupleForType(value-&gt;type()).size(), (&quot;At &quot;, *value));</span>
<span class="line-added">450                         for (unsigned i = 0; i &lt; value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints.size(); ++i)</span>
<span class="line-added">451                             validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraints[i]), ConstraintRole::Def, i);</span>
<span class="line-added">452                     }</span>
<span class="line-added">453                 }</span>
454                 validateStackmap(value);
455                 break;
<a name="19" id="anc19"></a><span class="line-added">456             case Extract: {</span>
<span class="line-added">457                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));</span>
<span class="line-added">458                 VALIDATE(value-&gt;child(0)-&gt;type() == Tuple, (&quot;At &quot;, *value));</span>
<span class="line-added">459                 VALIDATE(value-&gt;type().isNumeric(), (&quot;At &quot;, *value));</span>
<span class="line-added">460                 break;</span>
<span class="line-added">461             }</span>
462             case CheckAdd:
463             case CheckSub:
464             case CheckMul:
465                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
466                 VALIDATE(value-&gt;numChildren() &gt;= 2, (&quot;At &quot;, *value));
<a name="20" id="anc20"></a><span class="line-modified">467                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
<span class="line-modified">468                 VALIDATE(value-&gt;child(1)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
469                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
470                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(1).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
471                 validateStackmap(value);
472                 break;
473             case Check:
474                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
475                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
<a name="21" id="anc21"></a><span class="line-modified">476                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
477                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
478                 validateStackmap(value);
479                 break;
480             case WasmBoundsCheck:
481                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
482                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
483                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
484                 switch (value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;boundsType()) {
485                 case WasmBoundsCheckValue::Type::Pinned:
486                     VALIDATE(m_procedure.code().isPinned(value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;bounds().pinnedSize), (&quot;At &quot;, *value));
487                     break;
488                 case WasmBoundsCheckValue::Type::Maximum:
489                     break;
490                 }
491                 VALIDATE(m_procedure.code().wasmBoundsCheckGenerator(), (&quot;At &quot;, *value));
492                 break;
493             case Upsilon:
494                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
495                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
496                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi(), (&quot;At &quot;, *value));
497                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;opcode() == Phi, (&quot;At &quot;, *value));
<a name="22" id="anc22"></a><span class="line-added">498                 VALIDATE(value-&gt;child(0)-&gt;type() != Void, (&quot;At &quot;, *value));</span>
499                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;type(), (&quot;At &quot;, *value));
500                 VALIDATE(valueInProc.contains(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()), (&quot;At &quot;, *value));
501                 break;
502             case Phi:
503                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
504                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
505                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
506                 break;
507             case Jump:
508                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
509                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
510                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
511                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 1, (&quot;At &quot;, *value));
512                 break;
513             case Oops:
514                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
515                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
516                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
517                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
518                 break;
519             case Return:
520                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
521                 VALIDATE(value-&gt;numChildren() &lt;= 1, (&quot;At &quot;, *value));
522                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
523                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
524                 break;
525             case Branch:
526                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
527                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="23" id="anc23"></a><span class="line-modified">528                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
529                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
530                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 2, (&quot;At &quot;, *value));
531                 break;
532             case Switch: {
533                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
534                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
<a name="24" id="anc24"></a><span class="line-modified">535                 VALIDATE(value-&gt;child(0)-&gt;type().isInt(), (&quot;At &quot;, *value));</span>
536                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
537                 VALIDATE(value-&gt;as&lt;SwitchValue&gt;()-&gt;hasFallThrough(valueOwner.get(value)), (&quot;At &quot;, *value));
538                 // This validates the same thing as hasFallThrough, but more explicitly. We want to
539                 // make sure that if anyone tries to change the definition of hasFallThrough, they
540                 // will feel some pain here, since this is fundamental.
541                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == value-&gt;as&lt;SwitchValue&gt;()-&gt;numCaseValues() + 1, (&quot;At &quot;, *value));
542 
543                 // Check that there are no duplicate cases.
544                 Vector&lt;int64_t&gt; caseValues = value-&gt;as&lt;SwitchValue&gt;()-&gt;caseValues();
545                 std::sort(caseValues.begin(), caseValues.end());
546                 for (unsigned i = 1; i &lt; caseValues.size(); ++i)
547                     VALIDATE(caseValues[i - 1] != caseValues[i], (&quot;At &quot;, *value, &quot;, caseValue = &quot;, caseValues[i]));
548                 break;
549             }
550             case EntrySwitch:
551                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
552                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
553                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
554                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == m_procedure.numEntrypoints(), (&quot;At &quot;, *value));
555                 break;
556             }
557 
558             VALIDATE(!(value-&gt;effects().writes &amp;&amp; value-&gt;key()), (&quot;At &quot;, *value));
559         }
560 
561         for (Variable* variable : m_procedure.variables())
562             VALIDATE(variable-&gt;type() != Void, (&quot;At &quot;, *variable));
563 
564         for (BasicBlock* block : m_procedure) {
565             // We expect the predecessor list to be de-duplicated.
566             HashSet&lt;BasicBlock*&gt; predecessors;
567             for (BasicBlock* predecessor : block-&gt;predecessors())
568                 predecessors.add(predecessor);
569             VALIDATE(block-&gt;numPredecessors() == predecessors.size(), (&quot;At &quot;, *block));
570         }
571     }
572 
573 private:
574     void validateStackmap(Value* value)
575     {
576         StackmapValue* stackmap = value-&gt;as&lt;StackmapValue&gt;();
577         VALIDATE(stackmap, (&quot;At &quot;, *value));
578         VALIDATE(stackmap-&gt;numChildren() &gt;= stackmap-&gt;reps().size(), (&quot;At &quot;, *stackmap));
579         for (ConstrainedValue child : stackmap-&gt;constrainedChildren())
580             validateStackmapConstraint(stackmap, child);
581     }
582 
583     enum class ConstraintRole {
584         Use,
585         Def
586     };
<a name="25" id="anc25"></a><span class="line-modified">587     void validateStackmapConstraint(Value* context, const ConstrainedValue&amp; value, ConstraintRole role = ConstraintRole::Use, unsigned tupleIndex = 0)</span>
588     {
589         switch (value.rep().kind()) {
590         case ValueRep::WarmAny:
591         case ValueRep::SomeRegister:
592         case ValueRep::StackArgument:
593             break;
594         case ValueRep::LateColdAny:
595         case ValueRep::ColdAny:
596             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
597             break;
598         case ValueRep::SomeRegisterWithClobber:
599             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
600             VALIDATE(context-&gt;as&lt;PatchpointValue&gt;(), (&quot;At &quot;, *context));
601             break;
602         case ValueRep::SomeEarlyRegister:
603             VALIDATE(role == ConstraintRole::Def, (&quot;At &quot;, *context, &quot;: &quot;, value));
604             break;
605         case ValueRep::Register:
606         case ValueRep::LateRegister:
<a name="26" id="anc26"></a><span class="line-added">607         case ValueRep::SomeLateRegister:</span>
608             if (value.rep().kind() == ValueRep::LateRegister)
609                 VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
<a name="27" id="anc27"></a><span class="line-modified">610             if (value.rep().reg().isGPR()) {</span>
<span class="line-modified">611                 if (value.value()-&gt;type().isTuple())</span>
<span class="line-modified">612                     VALIDATE(m_procedure.extractFromTuple(value.value()-&gt;type(), tupleIndex).isInt(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-modified">613                 else</span>
<span class="line-added">614                     VALIDATE(value.value()-&gt;type().isInt(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">615             } else {</span>
<span class="line-added">616                 if (value.value()-&gt;type().isTuple())</span>
<span class="line-added">617                     VALIDATE(m_procedure.extractFromTuple(value.value()-&gt;type(), tupleIndex).isFloat(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">618                 else</span>
<span class="line-added">619                     VALIDATE(value.value()-&gt;type().isFloat(), (&quot;At &quot;, *context, &quot;: &quot;, value));</span>
<span class="line-added">620             }</span>
621             break;
622         default:
623             VALIDATE(false, (&quot;At &quot;, *context, &quot;: &quot;, value));
624             break;
625         }
626     }
627 
628     void validateFence(Value* value)
629     {
630         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
631         if (memory-&gt;hasFence())
632             VALIDATE(memory-&gt;accessBank() == GP, (&quot;Fence at &quot;, *memory));
633     }
634 
635     void validateAtomic(Value* value)
636     {
637         AtomicValue* atomic = value-&gt;as&lt;AtomicValue&gt;();
638 
639         VALIDATE(bestType(GP, atomic-&gt;accessWidth()) == atomic-&gt;accessType(), (&quot;At &quot;, *value));
640     }
641 
642     void validateStackAccess(Value* value)
643     {
644         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
645         SlotBaseValue* slotBase = value-&gt;lastChild()-&gt;as&lt;SlotBaseValue&gt;();
646         if (!slotBase)
647             return;
648 
649         VALIDATE(memory-&gt;offset() &gt;= 0, (&quot;At &quot;, *value));
650     }
651 
652     NO_RETURN_DUE_TO_CRASH void fail(
653         const char* filename, int lineNumber, const char* function, const char* condition,
654         CString message)
655     {
656         CString failureMessage;
657         {
658             StringPrintStream out;
659             out.print(&quot;B3 VALIDATION FAILURE\n&quot;);
660             out.print(&quot;    &quot;, condition, &quot; (&quot;, filename, &quot;:&quot;, lineNumber, &quot;)\n&quot;);
661             out.print(&quot;    &quot;, message, &quot;\n&quot;);
662             out.print(&quot;    After &quot;, m_procedure.lastPhaseName(), &quot;\n&quot;);
663             failureMessage = out.toCString();
664         }
665 
666         dataLog(failureMessage);
667         if (m_dumpBefore) {
668             dataLog(&quot;Before &quot;, m_procedure.lastPhaseName(), &quot;:\n&quot;);
669             dataLog(m_dumpBefore);
670         }
671         dataLog(&quot;At time of failure:\n&quot;);
672         dataLog(m_procedure);
673 
674         dataLog(failureMessage);
675         WTFReportAssertionFailure(filename, lineNumber, function, condition);
676         CRASH();
677     }
678 
679     Procedure&amp; m_procedure;
680     const char* m_dumpBefore;
681 };
682 
683 } // anonymous namespace
684 
685 void validate(Procedure&amp; procedure, const char* dumpBefore)
686 {
687     Validater validater(procedure, dumpBefore);
688     validater.run();
689 }
690 
691 } } // namespace JSC::B3
692 
693 #endif // ENABLE(B3_JIT)
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>