<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DisplayListItems.h&quot;
  28 
  29 #include &quot;FontCascade.h&quot;
  30 #include &lt;wtf/text/TextStream.h&gt;
  31 
  32 namespace WebCore {
  33 namespace DisplayList {
  34 
  35 // Should match RenderTheme::platformFocusRingWidth()
  36 static const float platformFocusRingWidth = 3;
  37 
  38 #if !defined(NDEBUG) || !LOG_DISABLED
  39 WTF::CString Item::description() const
  40 {
  41     TextStream ts;
  42     ts &lt;&lt; *this;
  43     return ts.release().utf8();
  44 }
  45 #endif
  46 
  47 size_t Item::sizeInBytes(const Item&amp; item)
  48 {
  49     switch (item.type()) {
  50     case ItemType::Save:
  51         return sizeof(downcast&lt;Save&gt;(item));
  52     case ItemType::Restore:
  53         return sizeof(downcast&lt;Restore&gt;(item));
  54     case ItemType::Translate:
  55         return sizeof(downcast&lt;Translate&gt;(item));
  56     case ItemType::Rotate:
  57         return sizeof(downcast&lt;Rotate&gt;(item));
  58     case ItemType::Scale:
  59         return sizeof(downcast&lt;Scale&gt;(item));
  60     case ItemType::ConcatenateCTM:
  61         return sizeof(downcast&lt;ConcatenateCTM&gt;(item));
  62     case ItemType::SetState:
  63         return sizeof(downcast&lt;SetState&gt;(item));
  64     case ItemType::SetLineCap:
  65         return sizeof(downcast&lt;SetLineCap&gt;(item));
  66     case ItemType::SetLineDash:
  67         return sizeof(downcast&lt;SetLineDash&gt;(item));
  68     case ItemType::SetLineJoin:
  69         return sizeof(downcast&lt;SetLineJoin&gt;(item));
  70     case ItemType::SetMiterLimit:
  71         return sizeof(downcast&lt;SetMiterLimit&gt;(item));
  72     case ItemType::ClearShadow:
  73         return sizeof(downcast&lt;ClearShadow&gt;(item));
  74     case ItemType::Clip:
  75         return sizeof(downcast&lt;Clip&gt;(item));
  76     case ItemType::ClipOut:
  77         return sizeof(downcast&lt;ClipOut&gt;(item));
  78     case ItemType::ClipOutToPath:
  79         return sizeof(downcast&lt;ClipOutToPath&gt;(item));
  80     case ItemType::ClipPath:
  81         return sizeof(downcast&lt;ClipPath&gt;(item));
  82     case ItemType::DrawGlyphs:
  83         return sizeof(downcast&lt;DrawGlyphs&gt;(item));
  84     case ItemType::DrawImage:
  85         return sizeof(downcast&lt;DrawImage&gt;(item));
  86     case ItemType::DrawTiledImage:
  87         return sizeof(downcast&lt;DrawTiledImage&gt;(item));
  88     case ItemType::DrawTiledScaledImage:
  89         return sizeof(downcast&lt;DrawTiledScaledImage&gt;(item));
  90 #if USE(CG) || USE(CAIRO)
  91     case ItemType::DrawNativeImage:
  92         return sizeof(downcast&lt;DrawNativeImage&gt;(item));
  93 #endif
  94     case ItemType::DrawPattern:
  95         return sizeof(downcast&lt;DrawPattern&gt;(item));
  96     case ItemType::DrawRect:
  97         return sizeof(downcast&lt;DrawRect&gt;(item));
  98     case ItemType::DrawLine:
  99         return sizeof(downcast&lt;DrawLine&gt;(item));
 100     case ItemType::DrawLinesForText:
 101         return sizeof(downcast&lt;DrawLinesForText&gt;(item));
 102     case ItemType::DrawDotsForDocumentMarker:
 103         return sizeof(downcast&lt;DrawDotsForDocumentMarker&gt;(item));
 104     case ItemType::DrawEllipse:
 105         return sizeof(downcast&lt;DrawEllipse&gt;(item));
 106     case ItemType::DrawPath:
 107         return sizeof(downcast&lt;DrawPath&gt;(item));
 108     case ItemType::DrawFocusRingPath:
 109         return sizeof(downcast&lt;DrawFocusRingPath&gt;(item));
 110     case ItemType::DrawFocusRingRects:
 111         return sizeof(downcast&lt;DrawFocusRingRects&gt;(item));
 112     case ItemType::FillRect:
 113         return sizeof(downcast&lt;FillRect&gt;(item));
 114     case ItemType::FillRectWithColor:
 115         return sizeof(downcast&lt;FillRectWithColor&gt;(item));
 116     case ItemType::FillRectWithGradient:
 117         return sizeof(downcast&lt;FillRectWithGradient&gt;(item));
 118     case ItemType::FillCompositedRect:
 119         return sizeof(downcast&lt;FillCompositedRect&gt;(item));
 120     case ItemType::FillRoundedRect:
 121         return sizeof(downcast&lt;FillRoundedRect&gt;(item));
 122     case ItemType::FillRectWithRoundedHole:
 123         return sizeof(downcast&lt;FillRectWithRoundedHole&gt;(item));
 124     case ItemType::FillPath:
 125         return sizeof(downcast&lt;FillPath&gt;(item));
 126     case ItemType::FillEllipse:
 127         return sizeof(downcast&lt;FillEllipse&gt;(item));
 128     case ItemType::StrokeRect:
 129         return sizeof(downcast&lt;StrokeRect&gt;(item));
 130     case ItemType::StrokePath:
 131         return sizeof(downcast&lt;StrokePath&gt;(item));
 132     case ItemType::StrokeEllipse:
 133         return sizeof(downcast&lt;StrokeEllipse&gt;(item));
 134     case ItemType::ClearRect:
 135         return sizeof(downcast&lt;ClearRect&gt;(item));
 136     case ItemType::BeginTransparencyLayer:
 137         return sizeof(downcast&lt;BeginTransparencyLayer&gt;(item));
 138     case ItemType::EndTransparencyLayer:
 139         return sizeof(downcast&lt;EndTransparencyLayer&gt;(item));
 140 #if USE(CG)
 141     case ItemType::ApplyStrokePattern:
 142         return sizeof(downcast&lt;ApplyStrokePattern&gt;(item));
 143     case ItemType::ApplyFillPattern:
 144         return sizeof(downcast&lt;ApplyFillPattern&gt;(item));
 145 #endif
 146     case ItemType::ApplyDeviceScaleFactor:
 147         return sizeof(downcast&lt;ApplyDeviceScaleFactor&gt;(item));
 148     }
 149     return 0;
 150 }
 151 
 152 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawingItem&amp; item)
 153 {
 154     ts.startGroup();
 155     ts &lt;&lt; &quot;extent &quot;;
 156     if (item.extentKnown())
 157         ts &lt;&lt; item.extent();
 158     else
 159         ts &lt;&lt; &quot;unknown&quot;;
 160 
 161     ts.endGroup();
 162     return ts;
 163 }
 164 
 165 void Save::apply(GraphicsContext&amp; context) const
 166 {
 167     context.save();
 168 }
 169 
 170 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Save&amp; item)
 171 {
 172     ts.dumpProperty(&quot;restore-index&quot;, item.restoreIndex());
 173     return ts;
 174 }
 175 
 176 void Restore::apply(GraphicsContext&amp; context) const
 177 {
 178     context.restore();
 179 }
 180 
 181 void Translate::apply(GraphicsContext&amp; context) const
 182 {
 183     context.translate(m_x, m_y);
 184 }
 185 
 186 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Translate&amp; item)
 187 {
 188     ts.dumpProperty(&quot;x&quot;, item.x());
 189     ts.dumpProperty(&quot;y&quot;, item.y());
 190 
 191     return ts;
 192 }
 193 
 194 void Rotate::apply(GraphicsContext&amp; context) const
 195 {
 196     context.rotate(m_angle);
 197 }
 198 
 199 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Rotate&amp; item)
 200 {
 201     ts.dumpProperty(&quot;angle&quot;, item.angle());
 202 
 203     return ts;
 204 }
 205 
 206 void Scale::apply(GraphicsContext&amp; context) const
 207 {
 208     context.scale(m_size);
 209 }
 210 
 211 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Scale&amp; item)
 212 {
 213     ts.dumpProperty(&quot;size&quot;, item.amount());
 214 
 215     return ts;
 216 }
 217 
 218 ConcatenateCTM::ConcatenateCTM(const AffineTransform&amp; transform)
 219     : Item(ItemType::ConcatenateCTM)
 220     , m_transform(transform)
 221 {
 222 }
 223 
 224 void ConcatenateCTM::apply(GraphicsContext&amp; context) const
 225 {
 226     context.concatCTM(m_transform);
 227 }
 228 
 229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ConcatenateCTM&amp; item)
 230 {
 231     ts.dumpProperty(&quot;ctm&quot;, item.transform());
 232 
 233     return ts;
 234 }
 235 
 236 void SetState::apply(GraphicsContext&amp; context) const
 237 {
 238     m_state.apply(context);
 239 }
 240 
 241 void SetState::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 242 {
 243     m_state.accumulate(state, flags);
 244 }
 245 
 246 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetState&amp; state)
 247 {
 248     ts &lt;&lt; state.state();
 249     return ts;
 250 }
 251 
 252 void SetLineCap::apply(GraphicsContext&amp; context) const
 253 {
 254     context.setLineCap(m_lineCap);
 255 }
 256 
 257 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineCap&amp; lineCap)
 258 {
 259     ts.dumpProperty(&quot;line-cap&quot;, lineCap.lineCap());
 260     return ts;
 261 }
 262 
 263 void SetLineDash::apply(GraphicsContext&amp; context) const
 264 {
 265     context.setLineDash(m_dashArray, m_dashOffset);
 266 }
 267 
 268 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineDash&amp; lineDash)
 269 {
 270     ts.dumpProperty(&quot;dash-array&quot;, lineDash.dashArray());
 271     ts.dumpProperty(&quot;dash-offset&quot;, lineDash.dashOffset());
 272     return ts;
 273 }
 274 
 275 void SetLineJoin::apply(GraphicsContext&amp; context) const
 276 {
 277     context.setLineJoin(m_lineJoin);
 278 }
 279 
 280 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineJoin&amp; lineJoin)
 281 {
 282     ts.dumpProperty(&quot;line-join&quot;, lineJoin.lineJoin());
 283     return ts;
 284 }
 285 
 286 void SetMiterLimit::apply(GraphicsContext&amp; context) const
 287 {
 288     context.setMiterLimit(m_miterLimit);
 289 }
 290 
 291 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetMiterLimit&amp; miterLimit)
 292 {
 293     ts.dumpProperty(&quot;mitre-limit&quot;, miterLimit.miterLimit());
 294     return ts;
 295 }
 296 
 297 void ClearShadow::apply(GraphicsContext&amp; context) const
 298 {
 299     context.clearShadow();
 300 }
 301 
 302 void Clip::apply(GraphicsContext&amp; context) const
 303 {
 304     context.clip(m_rect);
 305 }
 306 
 307 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Clip&amp; item)
 308 {
 309     ts.dumpProperty(&quot;rect&quot;, item.rect());
 310     return ts;
 311 }
 312 
 313 void ClipOut::apply(GraphicsContext&amp; context) const
 314 {
 315     context.clipOut(m_rect);
 316 }
 317 
 318 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOut&amp; item)
 319 {
 320     ts.dumpProperty(&quot;rect&quot;, item.rect());
 321     return ts;
 322 }
 323 
 324 void ClipOutToPath::apply(GraphicsContext&amp; context) const
 325 {
 326     context.clipOut(m_path);
 327 }
 328 
 329 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOutToPath&amp; item)
 330 {
 331     ts.dumpProperty(&quot;path&quot;, item.path());
 332     return ts;
 333 }
 334 
 335 void ClipPath::apply(GraphicsContext&amp; context) const
 336 {
 337     context.clipPath(m_path, m_windRule);
 338 }
 339 
 340 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipPath&amp; item)
 341 {
 342     ts.dumpProperty(&quot;path&quot;, item.path());
 343     ts.dumpProperty(&quot;wind-rule&quot;, item.windRule());
 344     return ts;
 345 }
 346 
 347 DrawGlyphs::DrawGlyphs(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 348     : DrawingItem(ItemType::DrawGlyphs)
 349     , m_font(const_cast&lt;Font&amp;&gt;(font))
 350     , m_blockLocation(blockLocation)
 351     , m_localAnchor(localAnchor)
 352     , m_smoothingMode(smoothingMode)
 353 {
 354     m_glyphs.reserveInitialCapacity(count);
 355     m_advances.reserveInitialCapacity(count);
 356     for (unsigned i = 0; i &lt; count; ++i) {
 357         m_glyphs.uncheckedAppend(glyphs[i]);
 358         m_advances.uncheckedAppend(advances[i]);
 359     }
 360     computeBounds();
 361 }
 362 
 363 inline GlyphBuffer DrawGlyphs::generateGlyphBuffer() const
 364 {
 365     GlyphBuffer result;
 366     for (size_t i = 0; i &lt; m_glyphs.size(); ++i) {
 367         result.add(m_glyphs[i], &amp;m_font.get(), m_advances[i], GlyphBuffer::noOffset);
 368     }
 369     return result;
 370 }
 371 
 372 void DrawGlyphs::apply(GraphicsContext&amp; context) const
 373 {
 374     context.drawGlyphs(m_font, generateGlyphBuffer(), 0, m_glyphs.size(), anchorPoint(), m_smoothingMode);
 375 }
 376 
 377 void DrawGlyphs::computeBounds()
 378 {
 379     // FIXME: This code doesn&#39;t actually take the extents of the glyphs into consideration. It assumes that
 380     // the glyph lies entirely within its [(ascent + descent), advance] rect.
 381     float ascent = m_font-&gt;fontMetrics().floatAscent();
 382     float descent = m_font-&gt;fontMetrics().floatDescent();
 383     FloatPoint current = toFloatPoint(localAnchor());
 384     size_t numGlyphs = m_glyphs.size();
 385     for (size_t i = 0; i &lt; numGlyphs; ++i) {
 386         GlyphBufferAdvance advance = m_advances[i];
 387         FloatRect glyphRect = FloatRect(current.x(), current.y() - ascent, advance.width(), ascent + descent);
 388         m_bounds.unite(glyphRect);
 389 
 390         current.move(advance.width(), advance.height());
 391     }
 392 }
 393 
 394 Optional&lt;FloatRect&gt; DrawGlyphs::localBounds(const GraphicsContext&amp;) const
 395 {
 396     FloatRect localBounds = m_bounds;
 397     localBounds.move(m_blockLocation.x(), m_blockLocation.y());
 398     return localBounds;
 399 }
 400 
 401 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawGlyphs&amp; item)
 402 {
 403     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 404     // FIXME: dump more stuff.
 405     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 406     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 407     ts.dumpProperty(&quot;anchor-point&quot;, item.anchorPoint());
 408     ts.dumpProperty(&quot;length&quot;, item.glyphs().size());
 409 
 410     return ts;
 411 }
 412 
 413 DrawImage::DrawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 414     : DrawingItem(ItemType::DrawImage)
 415     , m_image(image)
 416     , m_destination(destination)
 417     , m_source(source)
 418     , m_imagePaintingOptions(imagePaintingOptions)
 419 {
 420 }
 421 
 422 void DrawImage::apply(GraphicsContext&amp; context) const
 423 {
 424     context.drawImage(m_image.get(), m_destination, m_source, m_imagePaintingOptions);
 425 }
 426 
 427 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawImage&amp; item)
 428 {
 429     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 430     ts.dumpProperty(&quot;image&quot;, item.image());
 431     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 432     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 433     return ts;
 434 }
 435 
 436 DrawTiledImage::DrawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 437     : DrawingItem(ItemType::DrawTiledImage)
 438     , m_image(image)
 439     , m_destination(destination)
 440     , m_source(source)
 441     , m_tileSize(tileSize)
 442     , m_spacing(spacing)
 443     , m_imagePaintingOptions(imagePaintingOptions)
 444 {
 445 }
 446 
 447 void DrawTiledImage::apply(GraphicsContext&amp; context) const
 448 {
 449     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileSize, m_spacing, m_imagePaintingOptions);
 450 }
 451 
 452 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledImage&amp; item)
 453 {
 454     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 455     ts.dumpProperty(&quot;image&quot;, item.image());
 456     ts.dumpProperty(&quot;source-point&quot;, item.source());
 457     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 458     ts.dumpProperty(&quot;tile-size&quot;, item.tileSize());
 459     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 460     return ts;
 461 }
 462 
 463 DrawTiledScaledImage::DrawTiledScaledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 464     : DrawingItem(ItemType::DrawTiledScaledImage)
 465     , m_image(image)
 466     , m_destination(destination)
 467     , m_source(source)
 468     , m_tileScaleFactor(tileScaleFactor)
 469     , m_hRule(hRule)
 470     , m_vRule(vRule)
 471     , m_imagePaintingOptions(imagePaintingOptions)
 472 {
 473 }
 474 
 475 void DrawTiledScaledImage::apply(GraphicsContext&amp; context) const
 476 {
 477     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileScaleFactor, m_hRule, m_vRule, m_imagePaintingOptions);
 478 }
 479 
 480 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledScaledImage&amp; item)
 481 {
 482     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 483     ts.dumpProperty(&quot;image&quot;, item.image());
 484     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 485     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 486     return ts;
 487 }
 488 
 489 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 490 DrawNativeImage::DrawNativeImage(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 491     : DrawingItem(ItemType::DrawNativeImage)
 492 #if USE(CG)
 493     // FIXME: Need to store an image for Cairo.
 494     , m_image(image)
 495 #endif
 496     , m_imageSize(imageSize)
 497     , m_destination(destRect)
 498     , m_srcRect(srcRect)
 499     , m_options(options)
 500 {
 501 #if !USE(CG)
 502     UNUSED_PARAM(image);
 503 #endif
 504 }
 505 
 506 void DrawNativeImage::apply(GraphicsContext&amp; context) const
 507 {
 508 #if USE(CG)
 509     context.drawNativeImage(m_image, m_imageSize, m_destination, m_srcRect, m_options);
 510 #else
 511     UNUSED_PARAM(context);
 512 #endif
 513 }
 514 
 515 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawNativeImage&amp; item)
 516 {
 517     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 518     // FIXME: dump more stuff.
 519     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 520     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 521     return ts;
 522 }
 523 #endif
 524 
 525 DrawPattern::DrawPattern(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 526     : DrawingItem(ItemType::DrawPattern)
 527     , m_image(image)
 528     , m_patternTransform(patternTransform)
 529     , m_tileRect(tileRect)
 530     , m_destination(destRect)
 531     , m_phase(phase)
 532     , m_spacing(spacing)
 533     , m_options(options)
 534 {
 535 }
 536 
 537 void DrawPattern::apply(GraphicsContext&amp; context) const
 538 {
 539     context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_options);
 540 }
 541 
 542 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPattern&amp; item)
 543 {
 544     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 545     ts.dumpProperty(&quot;image&quot;, item.image());
 546     ts.dumpProperty(&quot;pattern-transform&quot;, item.patternTransform());
 547     ts.dumpProperty(&quot;tile-rect&quot;, item.tileRect());
 548     ts.dumpProperty(&quot;dest-rect&quot;, item.destRect());
 549     ts.dumpProperty(&quot;phase&quot;, item.phase());
 550     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 551     return ts;
 552 }
 553 
 554 void DrawRect::apply(GraphicsContext&amp; context) const
 555 {
 556     context.drawRect(m_rect, m_borderThickness);
 557 }
 558 
 559 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawRect&amp; item)
 560 {
 561     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 562     ts.dumpProperty(&quot;rect&quot;, item.rect());
 563     ts.dumpProperty(&quot;border-thickness&quot;, item.borderThickness());
 564     return ts;
 565 }
 566 
 567 Optional&lt;FloatRect&gt; DrawLine::localBounds(const GraphicsContext&amp;) const
 568 {
 569     FloatRect bounds;
 570     bounds.fitToPoints(m_point1, m_point2);
 571     return bounds;
 572 }
 573 
 574 void DrawLine::apply(GraphicsContext&amp; context) const
 575 {
 576     context.drawLine(m_point1, m_point2);
 577 }
 578 
 579 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLine&amp; item)
 580 {
 581     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 582     ts.dumpProperty(&quot;point-1&quot;, item.point1());
 583     ts.dumpProperty(&quot;point-2&quot;, item.point2());
 584     return ts;
 585 }
 586 
 587 void DrawLinesForText::apply(GraphicsContext&amp; context) const
 588 {
 589     context.drawLinesForText(point(), m_thickness, m_widths, m_printing, m_doubleLines);
 590 }
 591 
 592 Optional&lt;FloatRect&gt; DrawLinesForText::localBounds(const GraphicsContext&amp;) const
 593 {
 594     // This function needs to return a value equal to or enclosing what GraphicsContext::computeLineBoundsAndAntialiasingModeForText() returns.
 595 
 596     if (!m_widths.size())
 597         return FloatRect();
 598 
 599     FloatRect result(point(), FloatSize(m_widths.last(), m_thickness));
 600     result.inflate(1); // Account for pixel snapping. FIXME: This isn&#39;t perfect, as it doesn&#39;t take the CTM into account.
 601     return result;
 602 }
 603 
 604 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLinesForText&amp; item)
 605 {
 606     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 607     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 608     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 609     ts.dumpProperty(&quot;point&quot;, item.point());
 610     ts.dumpProperty(&quot;thickness&quot;, item.thickness());
 611     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 612     ts.dumpProperty(&quot;widths&quot;, item.widths());
 613     ts.dumpProperty(&quot;is-printing&quot;, item.isPrinting());
 614     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 615     return ts;
 616 }
 617 
 618 void DrawDotsForDocumentMarker::apply(GraphicsContext&amp; context) const
 619 {
 620     context.drawDotsForDocumentMarker(m_rect, m_style);
 621 }
 622 
 623 Optional&lt;FloatRect&gt; DrawDotsForDocumentMarker::localBounds(const GraphicsContext&amp;) const
 624 {
 625     return m_rect;
 626 }
 627 
 628 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawDotsForDocumentMarker&amp; item)
 629 {
 630     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 631     ts.dumpProperty(&quot;rect&quot;, item.rect());
 632     return ts;
 633 }
 634 
 635 void DrawEllipse::apply(GraphicsContext&amp; context) const
 636 {
 637     context.drawEllipse(m_rect);
 638 }
 639 
 640 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawEllipse&amp; item)
 641 {
 642     ts.dumpProperty(&quot;rect&quot;, item.rect());
 643     return ts;
 644 }
 645 
 646 void DrawPath::apply(GraphicsContext&amp; context) const
 647 {
 648 #if USE(CG)
 649     context.drawPath(m_path);
 650 #else
 651     UNUSED_PARAM(context);
 652 #endif
 653 }
 654 
 655 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPath&amp; item)
 656 {
 657     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 658 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 659     return ts;
 660 }
 661 
 662 void DrawFocusRingPath::apply(GraphicsContext&amp; context) const
 663 {
 664     context.drawFocusRing(m_path, m_width, m_offset, m_color);
 665 }
 666 
 667 Optional&lt;FloatRect&gt; DrawFocusRingPath::localBounds(const GraphicsContext&amp;) const
 668 {
 669     FloatRect result = m_path.fastBoundingRect();
 670     result.inflate(platformFocusRingWidth);
 671     return result;
 672 }
 673 
 674 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingPath&amp; item)
 675 {
 676     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 677 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 678     ts.dumpProperty(&quot;width&quot;, item.width());
 679     ts.dumpProperty(&quot;offset&quot;, item.offset());
 680     ts.dumpProperty(&quot;color&quot;, item.color());
 681     return ts;
 682 }
 683 
 684 void DrawFocusRingRects::apply(GraphicsContext&amp; context) const
 685 {
 686     context.drawFocusRing(m_rects, m_width, m_offset, m_color);
 687 }
 688 
 689 Optional&lt;FloatRect&gt; DrawFocusRingRects::localBounds(const GraphicsContext&amp;) const
 690 {
 691     FloatRect result;
 692     for (auto&amp; rect : m_rects)
 693         result.unite(rect);
 694     result.inflate(platformFocusRingWidth);
 695     return result;
 696 }
 697 
 698 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingRects&amp; item)
 699 {
 700     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 701     ts.dumpProperty(&quot;rects&quot;, item.rects());
 702     ts.dumpProperty(&quot;width&quot;, item.width());
 703     ts.dumpProperty(&quot;offset&quot;, item.offset());
 704     ts.dumpProperty(&quot;color&quot;, item.color());
 705     return ts;
 706 }
 707 
 708 void FillRect::apply(GraphicsContext&amp; context) const
 709 {
 710     context.fillRect(m_rect);
 711 }
 712 
 713 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRect&amp; item)
 714 {
 715     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 716     ts.dumpProperty(&quot;rect&quot;, item.rect());
 717     return ts;
 718 }
 719 
 720 void FillRectWithColor::apply(GraphicsContext&amp; context) const
 721 {
 722     context.fillRect(m_rect, m_color);
 723 }
 724 
 725 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithColor&amp; item)
 726 {
 727     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 728     ts.dumpProperty(&quot;rect&quot;, item.rect());
 729     ts.dumpProperty(&quot;color&quot;, item.color());
 730     return ts;
 731 }
 732 
 733 void FillRectWithGradient::apply(GraphicsContext&amp; context) const
 734 {
 735     context.fillRect(m_rect, m_gradient.get());
 736 }
 737 
 738 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithGradient&amp; item)
 739 {
 740     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 741     // FIXME: log gradient.
 742     ts.dumpProperty(&quot;rect&quot;, item.rect());
 743     return ts;
 744 }
 745 
 746 void FillCompositedRect::apply(GraphicsContext&amp; context) const
 747 {
 748     context.fillRect(m_rect, m_color, m_op, m_blendMode);
 749 }
 750 
 751 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillCompositedRect&amp; item)
 752 {
 753     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 754     ts.dumpProperty(&quot;rect&quot;, item.rect());
 755     ts.dumpProperty(&quot;color&quot;, item.color());
 756     ts.dumpProperty(&quot;composite-operation&quot;, item.compositeOperator());
 757     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 758     return ts;
 759 }
 760 
 761 void FillRoundedRect::apply(GraphicsContext&amp; context) const
 762 {
 763     context.fillRoundedRect(m_rect, m_color, m_blendMode);
 764 }
 765 
 766 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRoundedRect&amp; item)
 767 {
 768     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 769     ts.dumpProperty(&quot;rect&quot;, item.roundedRect());
 770     ts.dumpProperty(&quot;color&quot;, item.color());
 771     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 772     return ts;
 773 }
 774 
 775 void FillRectWithRoundedHole::apply(GraphicsContext&amp; context) const
 776 {
 777     context.fillRectWithRoundedHole(m_rect, m_roundedHoleRect, m_color);
 778 }
 779 
 780 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithRoundedHole&amp; item)
 781 {
 782     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 783     ts.dumpProperty(&quot;rect&quot;, item.rect());
 784     ts.dumpProperty(&quot;rounded-hole-rect&quot;, item.roundedHoleRect());
 785     ts.dumpProperty(&quot;color&quot;, item.color());
 786     return ts;
 787 }
 788 
 789 void FillPath::apply(GraphicsContext&amp; context) const
 790 {
 791     context.fillPath(m_path);
 792 }
 793 
 794 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillPath&amp; item)
 795 {
 796     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 797     ts.dumpProperty(&quot;path&quot;, item.path());
 798     return ts;
 799 }
 800 
 801 void FillEllipse::apply(GraphicsContext&amp; context) const
 802 {
 803     context.fillEllipse(m_rect);
 804 }
 805 
 806 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillEllipse&amp; item)
 807 {
 808     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 809     ts.dumpProperty(&quot;rect&quot;, item.rect());
 810     return ts;
 811 }
 812 
 813 Optional&lt;FloatRect&gt; StrokeRect::localBounds(const GraphicsContext&amp;) const
 814 {
 815     FloatRect bounds = m_rect;
 816     bounds.expand(m_lineWidth, m_lineWidth);
 817     return bounds;
 818 }
 819 
 820 void StrokeRect::apply(GraphicsContext&amp; context) const
 821 {
 822     context.strokeRect(m_rect, m_lineWidth);
 823 }
 824 
 825 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeRect&amp; item)
 826 {
 827     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 828     ts.dumpProperty(&quot;rect&quot;, item.rect());
 829     ts.dumpProperty(&quot;line-width&quot;, item.lineWidth());
 830     return ts;
 831 }
 832 
 833 Optional&lt;FloatRect&gt; StrokePath::localBounds(const GraphicsContext&amp; context) const
 834 {
 835     // FIXME: Need to take stroke thickness into account correctly, via CGPathByStrokingPath().
 836     float strokeThickness = context.strokeThickness();
 837 
 838     FloatRect bounds = m_path.boundingRect();
 839     bounds.expand(strokeThickness, strokeThickness);
 840     return bounds;
 841 }
 842 
 843 void StrokePath::apply(GraphicsContext&amp; context) const
 844 {
 845     context.strokePath(m_path);
 846 }
 847 
 848 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokePath&amp; item)
 849 {
 850     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 851     ts.dumpProperty(&quot;path&quot;, item.path());
 852     return ts;
 853 }
 854 
 855 Optional&lt;FloatRect&gt; StrokeEllipse::localBounds(const GraphicsContext&amp; context) const
 856 {
 857     float strokeThickness = context.strokeThickness();
 858 
 859     FloatRect bounds = m_rect;
 860     bounds.expand(strokeThickness, strokeThickness);
 861     return bounds;
 862 }
 863 
 864 void StrokeEllipse::apply(GraphicsContext&amp; context) const
 865 {
 866     context.strokeEllipse(m_rect);
 867 }
 868 
 869 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeEllipse&amp; item)
 870 {
 871     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 872     ts.dumpProperty(&quot;rect&quot;, item.rect());
 873     return ts;
 874 }
 875 
 876 void ClearRect::apply(GraphicsContext&amp; context) const
 877 {
 878     context.clearRect(m_rect);
 879 }
 880 
 881 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClearRect&amp; item)
 882 {
 883     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 884     ts.dumpProperty(&quot;rect&quot;, item.rect());
 885     return ts;
 886 }
 887 
 888 void BeginTransparencyLayer::apply(GraphicsContext&amp; context) const
 889 {
 890     context.beginTransparencyLayer(m_opacity);
 891 }
 892 
 893 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BeginTransparencyLayer&amp; item)
 894 {
 895     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 896     ts.dumpProperty(&quot;opacity&quot;, item.opacity());
 897     return ts;
 898 }
 899 
 900 void EndTransparencyLayer::apply(GraphicsContext&amp; context) const
 901 {
 902     context.endTransparencyLayer();
 903 }
 904 
 905 #if USE(CG)
 906 void ApplyStrokePattern::apply(GraphicsContext&amp; context) const
 907 {
 908     context.applyStrokePattern();
 909 }
 910 
 911 void ApplyFillPattern::apply(GraphicsContext&amp; context) const
 912 {
 913     context.applyFillPattern();
 914 }
 915 #endif
 916 
 917 void ApplyDeviceScaleFactor::apply(GraphicsContext&amp; context) const
 918 {
 919     context.applyDeviceScaleFactor(m_scaleFactor);
 920 }
 921 
 922 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ApplyDeviceScaleFactor&amp; item)
 923 {
 924     ts.dumpProperty(&quot;scale-factor&quot;, item.scaleFactor());
 925     return ts;
 926 }
 927 
 928 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ItemType&amp; type)
 929 {
 930     switch (type) {
 931     case ItemType::Save: ts &lt;&lt; &quot;save&quot;; break;
 932     case ItemType::Restore: ts &lt;&lt; &quot;restore&quot;; break;
 933     case ItemType::Translate: ts &lt;&lt; &quot;translate&quot;; break;
 934     case ItemType::Rotate: ts &lt;&lt; &quot;rotate&quot;; break;
 935     case ItemType::Scale: ts &lt;&lt; &quot;scale&quot;; break;
 936     case ItemType::ConcatenateCTM: ts &lt;&lt; &quot;concatentate-ctm&quot;; break;
 937     case ItemType::SetState: ts &lt;&lt; &quot;set-state&quot;; break;
 938     case ItemType::SetLineCap: ts &lt;&lt; &quot;set-line-cap&quot;; break;
 939     case ItemType::SetLineDash: ts &lt;&lt; &quot;set-line-dash&quot;; break;
 940     case ItemType::SetLineJoin: ts &lt;&lt; &quot;set-line-join&quot;; break;
 941     case ItemType::SetMiterLimit: ts &lt;&lt; &quot;set-miter-limit&quot;; break;
 942     case ItemType::Clip: ts &lt;&lt; &quot;clip&quot;; break;
 943     case ItemType::ClipOut: ts &lt;&lt; &quot;clip-out&quot;; break;
 944     case ItemType::ClipOutToPath: ts &lt;&lt; &quot;clip-out-to-path&quot;; break;
 945     case ItemType::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
 946     case ItemType::DrawGlyphs: ts &lt;&lt; &quot;draw-glyphs&quot;; break;
 947     case ItemType::DrawImage: ts &lt;&lt; &quot;draw-image&quot;; break;
 948     case ItemType::DrawTiledImage: ts &lt;&lt; &quot;draw-tiled-image&quot;; break;
 949     case ItemType::DrawTiledScaledImage: ts &lt;&lt; &quot;draw-tiled-scaled-image&quot;; break;
 950 #if USE(CG) || USE(CAIRO)
 951     case ItemType::DrawNativeImage: ts &lt;&lt; &quot;draw-native-image&quot;; break;
 952 #endif
 953     case ItemType::DrawPattern: ts &lt;&lt; &quot;draw-pattern&quot;; break;
 954     case ItemType::DrawRect: ts &lt;&lt; &quot;draw-rect&quot;; break;
 955     case ItemType::DrawLine: ts &lt;&lt; &quot;draw-line&quot;; break;
 956     case ItemType::DrawLinesForText: ts &lt;&lt; &quot;draw-lines-for-text&quot;; break;
 957     case ItemType::DrawDotsForDocumentMarker: ts &lt;&lt; &quot;draw-dots-for-document-marker&quot;; break;
 958     case ItemType::DrawEllipse: ts &lt;&lt; &quot;draw-ellipse&quot;; break;
 959     case ItemType::DrawPath: ts &lt;&lt; &quot;draw-path&quot;; break;
 960     case ItemType::DrawFocusRingPath: ts &lt;&lt; &quot;draw-focus-ring-path&quot;; break;
 961     case ItemType::DrawFocusRingRects: ts &lt;&lt; &quot;draw-focus-ring-rects&quot;; break;
 962     case ItemType::FillRect: ts &lt;&lt; &quot;fill-rect&quot;; break;
 963     case ItemType::FillRectWithColor: ts &lt;&lt; &quot;fill-rect-with-color&quot;; break;
 964     case ItemType::FillRectWithGradient: ts &lt;&lt; &quot;fill-rect-with-gradient&quot;; break;
 965     case ItemType::FillCompositedRect: ts &lt;&lt; &quot;fill-composited-rect&quot;; break;
 966     case ItemType::FillRoundedRect: ts &lt;&lt; &quot;fill-rounded-rect&quot;; break;
 967     case ItemType::FillRectWithRoundedHole: ts &lt;&lt; &quot;fill-rect-with-rounded-hole&quot;; break;
 968     case ItemType::FillPath: ts &lt;&lt; &quot;fill-path&quot;; break;
 969     case ItemType::FillEllipse: ts &lt;&lt; &quot;fill-ellipse&quot;; break;
 970     case ItemType::StrokeRect: ts &lt;&lt; &quot;stroke-rect&quot;; break;
 971     case ItemType::StrokePath: ts &lt;&lt; &quot;stroke-path&quot;; break;
 972     case ItemType::StrokeEllipse: ts &lt;&lt; &quot;stroke-ellipse&quot;; break;
 973     case ItemType::ClearRect: ts &lt;&lt; &quot;clear-rect&quot;; break;
 974     case ItemType::BeginTransparencyLayer: ts &lt;&lt; &quot;begin-transparency-layer&quot;; break;
 975     case ItemType::EndTransparencyLayer: ts &lt;&lt; &quot;end-transparency-layer&quot;; break;
 976 #if USE(CG)
 977     case ItemType::ApplyStrokePattern: ts &lt;&lt; &quot;apply-stroke-pattern&quot;; break;
 978     case ItemType::ApplyFillPattern: ts &lt;&lt; &quot;apply-fill-pattern&quot;; break;
 979 #endif
 980     case ItemType::ApplyDeviceScaleFactor: ts &lt;&lt; &quot;apply-device-scale-factor&quot;; break;
 981     case ItemType::ClearShadow: ts &lt;&lt; &quot;clear-shadow&quot;; break;
 982     }
 983     return ts;
 984 }
 985 
 986 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Item&amp; item)
 987 {
 988     TextStream::GroupScope group(ts);
 989     ts &lt;&lt; item.type();
 990 
 991     // FIXME: Make a macro which takes a macro for all these enumeration switches
 992     switch (item.type()) {
 993     case ItemType::Save:
 994         ts &lt;&lt; downcast&lt;Save&gt;(item);
 995         break;
 996     case ItemType::Translate:
 997         ts &lt;&lt; downcast&lt;Translate&gt;(item);
 998         break;
 999     case ItemType::Rotate:
1000         ts &lt;&lt; downcast&lt;Rotate&gt;(item);
1001         break;
1002     case ItemType::Scale:
1003         ts &lt;&lt; downcast&lt;Scale&gt;(item);
1004         break;
1005     case ItemType::ConcatenateCTM:
1006         ts &lt;&lt; downcast&lt;ConcatenateCTM&gt;(item);
1007         break;
1008     case ItemType::SetState:
1009         ts &lt;&lt; downcast&lt;SetState&gt;(item);
1010         break;
1011     case ItemType::SetLineCap:
1012         ts &lt;&lt; downcast&lt;SetLineCap&gt;(item);
1013         break;
1014     case ItemType::SetLineDash:
1015         ts &lt;&lt; downcast&lt;SetLineDash&gt;(item);
1016         break;
1017     case ItemType::SetLineJoin:
1018         ts &lt;&lt; downcast&lt;SetLineJoin&gt;(item);
1019         break;
1020     case ItemType::SetMiterLimit:
1021         ts &lt;&lt; downcast&lt;SetMiterLimit&gt;(item);
1022         break;
1023     case ItemType::Clip:
1024         ts &lt;&lt; downcast&lt;Clip&gt;(item);
1025         break;
1026     case ItemType::ClipOut:
1027         ts &lt;&lt; downcast&lt;ClipOut&gt;(item);
1028         break;
1029     case ItemType::ClipOutToPath:
1030         ts &lt;&lt; downcast&lt;ClipOutToPath&gt;(item);
1031         break;
1032     case ItemType::ClipPath:
1033         ts &lt;&lt; downcast&lt;ClipPath&gt;(item);
1034         break;
1035     case ItemType::DrawGlyphs:
1036         ts &lt;&lt; downcast&lt;DrawGlyphs&gt;(item);
1037         break;
1038     case ItemType::DrawImage:
1039         ts &lt;&lt; downcast&lt;DrawImage&gt;(item);
1040         break;
1041     case ItemType::DrawTiledImage:
1042         ts &lt;&lt; downcast&lt;DrawTiledImage&gt;(item);
1043         break;
1044     case ItemType::DrawTiledScaledImage:
1045         ts &lt;&lt; downcast&lt;DrawTiledScaledImage&gt;(item);
1046         break;
1047 #if USE(CG) || USE(CAIRO)
1048     case ItemType::DrawNativeImage:
1049         ts &lt;&lt; downcast&lt;DrawNativeImage&gt;(item);
1050         break;
1051 #endif
1052     case ItemType::DrawPattern:
1053         ts &lt;&lt; downcast&lt;DrawPattern&gt;(item);
1054         break;
1055     case ItemType::DrawRect:
1056         ts &lt;&lt; downcast&lt;DrawRect&gt;(item);
1057         break;
1058     case ItemType::DrawLine:
1059         ts &lt;&lt; downcast&lt;DrawLine&gt;(item);
1060         break;
1061     case ItemType::DrawLinesForText:
1062         ts &lt;&lt; downcast&lt;DrawLinesForText&gt;(item);
1063         break;
1064     case ItemType::DrawDotsForDocumentMarker:
1065         ts &lt;&lt; downcast&lt;DrawDotsForDocumentMarker&gt;(item);
1066         break;
1067     case ItemType::DrawEllipse:
1068         ts &lt;&lt; downcast&lt;DrawEllipse&gt;(item);
1069         break;
1070     case ItemType::DrawPath:
1071         ts &lt;&lt; downcast&lt;DrawPath&gt;(item);
1072         break;
1073     case ItemType::DrawFocusRingPath:
1074         ts &lt;&lt; downcast&lt;DrawFocusRingPath&gt;(item);
1075         break;
1076     case ItemType::DrawFocusRingRects:
1077         ts &lt;&lt; downcast&lt;DrawFocusRingRects&gt;(item);
1078         break;
1079     case ItemType::FillRect:
1080         ts &lt;&lt; downcast&lt;FillRect&gt;(item);
1081         break;
1082     case ItemType::FillRectWithColor:
1083         ts &lt;&lt; downcast&lt;FillRectWithColor&gt;(item);
1084         break;
1085     case ItemType::FillRectWithGradient:
1086         ts &lt;&lt; downcast&lt;FillRectWithGradient&gt;(item);
1087         break;
1088     case ItemType::FillCompositedRect:
1089         ts &lt;&lt; downcast&lt;FillCompositedRect&gt;(item);
1090         break;
1091     case ItemType::FillRoundedRect:
1092         ts &lt;&lt; downcast&lt;FillRoundedRect&gt;(item);
1093         break;
1094     case ItemType::FillRectWithRoundedHole:
1095         ts &lt;&lt; downcast&lt;FillRectWithRoundedHole&gt;(item);
1096         break;
1097     case ItemType::FillPath:
1098         ts &lt;&lt; downcast&lt;FillPath&gt;(item);
1099         break;
1100     case ItemType::FillEllipse:
1101         ts &lt;&lt; downcast&lt;FillEllipse&gt;(item);
1102         break;
1103     case ItemType::StrokeRect:
1104         ts &lt;&lt; downcast&lt;StrokeRect&gt;(item);
1105         break;
1106     case ItemType::StrokePath:
1107         ts &lt;&lt; downcast&lt;StrokePath&gt;(item);
1108         break;
1109     case ItemType::StrokeEllipse:
1110         ts &lt;&lt; downcast&lt;StrokeEllipse&gt;(item);
1111         break;
1112     case ItemType::ClearRect:
1113         ts &lt;&lt; downcast&lt;ClearRect&gt;(item);
1114         break;
1115     case ItemType::BeginTransparencyLayer:
1116         ts &lt;&lt; downcast&lt;BeginTransparencyLayer&gt;(item);
1117         break;
1118     case ItemType::ApplyDeviceScaleFactor:
1119         ts &lt;&lt; downcast&lt;ApplyDeviceScaleFactor&gt;(item);
1120         break;
1121 
1122     // Items with no additional data.
1123     case ItemType::Restore:
1124     case ItemType::EndTransparencyLayer:
1125 #if USE(CG)
1126     case ItemType::ApplyStrokePattern:
1127     case ItemType::ApplyFillPattern:
1128 #endif
1129     case ItemType::ClearShadow:
1130         break;
1131     }
1132     return ts;
1133 }
1134 
1135 }
1136 }
    </pre>
  </body>
</html>