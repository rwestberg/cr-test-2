<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FocusController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Frame.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Simon Hausmann &lt;hausmann@kde.org&gt;
   6  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
   7  *                     2001 George Staikos &lt;staikos@kde.org&gt;
<span class="line-modified">   8  * Copyright (C) 2004-2016 Apple Inc. All rights reserved.</span>
   9  * Copyright (C) 2005 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  10  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  11  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  12  * Copyright (C) 2008 Google Inc.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
</pre>
<hr />
<pre>
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserContentURLPattern.h&quot;

  98 #include &quot;UserScript.h&quot;
  99 #include &quot;UserTypingGestureIndicator.h&quot;
 100 #include &quot;VisibleUnits.h&quot;
 101 #include &quot;markup.h&quot;
 102 #include &quot;npruntime_impl.h&quot;
 103 #include &quot;runtime_root.h&quot;
 104 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 105 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 106 #include &lt;wtf/StdLibExtras.h&gt;
 107 #include &lt;wtf/text/StringBuilder.h&gt;
 108 
<span class="line-removed"> 109 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 110 #include &quot;WKContentObservation.h&quot;</span>
<span class="line-removed"> 111 #endif</span>
<span class="line-removed"> 112 </span>
 113 namespace WebCore {
 114 
 115 using namespace HTMLNames;
 116 
 117 #if PLATFORM(IOS_FAMILY)
 118 static const Seconds scrollFrequency { 1000_s / 60. };
 119 #endif
 120 
 121 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, frameCounter, (&quot;Frame&quot;));
 122 



 123 static inline Frame* parentFromOwnerElement(HTMLFrameOwnerElement* ownerElement)
 124 {
 125     if (!ownerElement)
 126         return 0;
 127     return ownerElement-&gt;document().frame();
 128 }
 129 
 130 static inline float parentPageZoomFactor(Frame* frame)
 131 {
 132     Frame* parent = frame-&gt;tree().parent();
 133     if (!parent)
 134         return 1;
 135     return parent-&gt;pageZoomFactor();
 136 }
 137 
 138 static inline float parentTextZoomFactor(Frame* frame)
 139 {
 140     Frame* parent = frame-&gt;tree().parent();
 141     if (!parent)
 142         return 1;
 143     return parent-&gt;textZoomFactor();
 144 }
 145 
 146 Frame::Frame(Page&amp; page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient&amp; frameLoaderClient)
 147     : m_mainFrame(ownerElement ? page.mainFrame() : *this)
 148     , m_page(&amp;page)
 149     , m_settings(&amp;page.settings())
 150     , m_treeNode(*this, parentFromOwnerElement(ownerElement))
 151     , m_loader(makeUniqueRef&lt;FrameLoader&gt;(*this, frameLoaderClient))
 152     , m_navigationScheduler(makeUniqueRef&lt;NavigationScheduler&gt;(*this))
 153     , m_ownerElement(ownerElement)
 154     , m_script(makeUniqueRef&lt;ScriptController&gt;(*this))
 155     , m_editor(makeUniqueRef&lt;Editor&gt;(*this))
 156     , m_selection(makeUniqueRef&lt;FrameSelection&gt;(this))
 157     , m_animationController(makeUniqueRef&lt;CSSAnimationController&gt;(*this))
<span class="line-removed"> 158 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 159     , m_overflowAutoScrollTimer(*this, &amp;Frame::overflowAutoScrollTimerFired)</span>
<span class="line-removed"> 160     , m_selectionChangeCallbacksDisabled(false)</span>
<span class="line-removed"> 161 #endif</span>
 162     , m_pageZoomFactor(parentPageZoomFactor(this))
 163     , m_textZoomFactor(parentTextZoomFactor(this))
<span class="line-removed"> 164     , m_activeDOMObjectsAndAnimationsSuspendedCount(0)</span>
 165     , m_eventHandler(makeUniqueRef&lt;EventHandler&gt;(*this))
 166 {
 167     ProcessWarming::initializeNames();
 168 
 169     if (ownerElement) {
 170         m_mainFrame.selfOnlyRef();
 171         page.incrementSubframeCount();
 172         ownerElement-&gt;setContentFrame(this);
 173     }
 174 
 175 #ifndef NDEBUG
 176     frameCounter.increment();
 177 #endif
 178 
 179     // Pause future ActiveDOMObjects if this frame is being created while the page is in a paused state.
 180     Frame* parent = parentFromOwnerElement(ownerElement);
 181     if (parent &amp;&amp; parent-&gt;activeDOMObjectsAndAnimationsSuspended())
 182         suspendActiveDOMObjectsAndAnimations();
 183 }
 184 
</pre>
<hr />
<pre>
 486 
 487     if (bestPos != -1)
 488         return mutableStringToMatch.substring(bestPos, bestLength);
 489     return String();
 490 }
 491 
 492 String Frame::matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element* element)
 493 {
 494     // Match against the name element, then against the id element if no match is found for the name element.
 495     // See 7538330 for one popular site that benefits from the id element check.
 496     // FIXME: This code is mirrored in FrameMac.mm. It would be nice to make the Mac code call the platform-agnostic
 497     // code, which would require converting the NSArray of NSStrings to a Vector of Strings somewhere along the way.
 498     String resultFromNameAttribute = matchLabelsAgainstString(labels, element-&gt;getNameAttribute());
 499     if (!resultFromNameAttribute.isEmpty())
 500         return resultFromNameAttribute;
 501 
 502     return matchLabelsAgainstString(labels, element-&gt;attributeWithoutSynchronization(idAttr));
 503 }
 504 
 505 #if PLATFORM(IOS_FAMILY)
<span class="line-removed"> 506 void Frame::scrollOverflowLayer(RenderLayer* layer, const IntRect&amp; visibleRect, const IntRect&amp; exposeRect)</span>
<span class="line-removed"> 507 {</span>
<span class="line-removed"> 508     if (!layer)</span>
<span class="line-removed"> 509         return;</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511     RenderBox* box = layer-&gt;renderBox();</span>
<span class="line-removed"> 512     if (!box)</span>
<span class="line-removed"> 513         return;</span>
<span class="line-removed"> 514 </span>
<span class="line-removed"> 515     if (visibleRect.intersects(exposeRect))</span>
<span class="line-removed"> 516         return;</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518     // FIXME: Why isn&#39;t this just calling RenderLayer::scrollRectToVisible()?</span>
<span class="line-removed"> 519     ScrollOffset scrollOffset = layer-&gt;scrollOffset();</span>
<span class="line-removed"> 520     int exposeLeft = exposeRect.x();</span>
<span class="line-removed"> 521     int exposeRight = exposeLeft + exposeRect.width();</span>
<span class="line-removed"> 522     int clientWidth = roundToInt(box-&gt;clientWidth());</span>
<span class="line-removed"> 523     if (exposeLeft &lt;= 0)</span>
<span class="line-removed"> 524         scrollOffset.setX(std::max(0, scrollOffset.x() + exposeLeft - clientWidth / 2));</span>
<span class="line-removed"> 525     else if (exposeRight &gt;= clientWidth)</span>
<span class="line-removed"> 526         scrollOffset.setX(std::min(box-&gt;scrollWidth() - clientWidth, scrollOffset.x() + clientWidth / 2));</span>
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528     int exposeTop = exposeRect.y();</span>
<span class="line-removed"> 529     int exposeBottom = exposeTop + exposeRect.height();</span>
<span class="line-removed"> 530     int clientHeight = roundToInt(box-&gt;clientHeight());</span>
<span class="line-removed"> 531     if (exposeTop &lt;= 0)</span>
<span class="line-removed"> 532         scrollOffset.setY(std::max(0, scrollOffset.y() + exposeTop - clientHeight / 2));</span>
<span class="line-removed"> 533     else if (exposeBottom &gt;= clientHeight)</span>
<span class="line-removed"> 534         scrollOffset.setY(std::min(box-&gt;scrollHeight() - clientHeight, scrollOffset.y() + clientHeight / 2));</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536     layer-&gt;scrollToOffset(scrollOffset, ScrollClamping::Unclamped);</span>
<span class="line-removed"> 537     selection().setCaretRectNeedsUpdate();</span>
<span class="line-removed"> 538     selection().updateAppearance();</span>
<span class="line-removed"> 539 }</span>
 540 
<span class="line-modified"> 541 void Frame::overflowAutoScrollTimerFired()</span>
 542 {
<span class="line-modified"> 543     if (!eventHandler().mousePressed() || checkOverflowScroll(PerformOverflowScroll) == OverflowScrollNone) {</span>
<span class="line-removed"> 544         if (m_overflowAutoScrollTimer.isActive())</span>
<span class="line-removed"> 545             m_overflowAutoScrollTimer.stop();</span>
<span class="line-removed"> 546     }</span>
 547 }
 548 
<span class="line-modified"> 549 void Frame::startOverflowAutoScroll(const IntPoint&amp; mousePosition)</span>
 550 {
<span class="line-modified"> 551     m_overflowAutoScrollPos = mousePosition;</span>
<span class="line-removed"> 552 </span>
<span class="line-removed"> 553     if (m_overflowAutoScrollTimer.isActive())</span>
<span class="line-removed"> 554         return;</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     if (checkOverflowScroll(DoNotPerformOverflowScroll) == OverflowScrollNone)</span>
<span class="line-removed"> 557         return;</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559     m_overflowAutoScrollTimer.startRepeating(scrollFrequency);</span>
<span class="line-removed"> 560     m_overflowAutoScrollDelta = 3;</span>
 561 }

 562 
<span class="line-modified"> 563 int Frame::checkOverflowScroll(OverflowScrollAction action)</span>
 564 {
<span class="line-modified"> 565     Position extent = selection().selection().extent();</span>
<span class="line-modified"> 566     if (extent.isNull())</span>
<span class="line-removed"> 567         return OverflowScrollNone;</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569     RenderObject* renderer = extent.deprecatedNode()-&gt;renderer();</span>
<span class="line-removed"> 570     if (!renderer)</span>
<span class="line-removed"> 571         return OverflowScrollNone;</span>
<span class="line-removed"> 572 </span>
<span class="line-removed"> 573     FrameView* view = this-&gt;view();</span>
<span class="line-removed"> 574     if (!view)</span>
<span class="line-removed"> 575         return OverflowScrollNone;</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577     RenderBlock* containingBlock = renderer-&gt;containingBlock();</span>
<span class="line-removed"> 578     if (!containingBlock || !containingBlock-&gt;hasOverflowClip())</span>
<span class="line-removed"> 579         return OverflowScrollNone;</span>
<span class="line-removed"> 580     RenderLayer* layer = containingBlock-&gt;layer();</span>
<span class="line-removed"> 581     ASSERT(layer);</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     IntRect visibleRect = IntRect(view-&gt;scrollX(), view-&gt;scrollY(), view-&gt;visibleWidth(), view-&gt;visibleHeight());</span>
<span class="line-removed"> 584     IntPoint position = m_overflowAutoScrollPos;</span>
<span class="line-removed"> 585     if (visibleRect.contains(position.x(), position.y()))</span>
<span class="line-removed"> 586         return OverflowScrollNone;</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588     int scrollType = 0;</span>
<span class="line-removed"> 589     int deltaX = 0;</span>
<span class="line-removed"> 590     int deltaY = 0;</span>
<span class="line-removed"> 591     IntPoint selectionPosition;</span>
<span class="line-removed"> 592 </span>
<span class="line-removed"> 593     // This constant will make the selection draw a little bit beyond the edge of the visible area.</span>
<span class="line-removed"> 594     // This prevents a visual glitch, in that you can fail to select a portion of a character that</span>
<span class="line-removed"> 595     // is being rendered right at the edge of the visible rectangle.</span>
<span class="line-removed"> 596     // FIXME: This probably needs improvement, and may need to take the font size into account.</span>
<span class="line-removed"> 597     static const int scrollBoundsAdjustment = 3;</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599     // FIXME: Make a small buffer at the end of a visible rectangle so that autoscrolling works</span>
<span class="line-removed"> 600     // even if the visible extends to the limits of the screen.</span>
<span class="line-removed"> 601     if (position.x() &lt; visibleRect.x()) {</span>
<span class="line-removed"> 602         scrollType |= OverflowScrollLeft;</span>
<span class="line-removed"> 603         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 604             deltaX -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 605             selectionPosition.setX(view-&gt;scrollX() - scrollBoundsAdjustment);</span>
<span class="line-removed"> 606         }</span>
<span class="line-removed"> 607     } else if (position.x() &gt; visibleRect.maxX()) {</span>
<span class="line-removed"> 608         scrollType |= OverflowScrollRight;</span>
<span class="line-removed"> 609         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 610             deltaX += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 611             selectionPosition.setX(view-&gt;scrollX() + view-&gt;visibleWidth() + scrollBoundsAdjustment);</span>
<span class="line-removed"> 612         }</span>
<span class="line-removed"> 613     }</span>
 614 
<span class="line-modified"> 615     if (position.y() &lt; visibleRect.y()) {</span>
<span class="line-modified"> 616         scrollType |= OverflowScrollUp;</span>
<span class="line-removed"> 617         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 618             deltaY -= static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 619             selectionPosition.setY(view-&gt;scrollY() - scrollBoundsAdjustment);</span>
<span class="line-removed"> 620         }</span>
<span class="line-removed"> 621     } else if (position.y() &gt; visibleRect.maxY()) {</span>
<span class="line-removed"> 622         scrollType |= OverflowScrollDown;</span>
<span class="line-removed"> 623         if (action == PerformOverflowScroll) {</span>
<span class="line-removed"> 624             deltaY += static_cast&lt;int&gt;(m_overflowAutoScrollDelta);</span>
<span class="line-removed"> 625             selectionPosition.setY(view-&gt;scrollY() + view-&gt;visibleHeight() + scrollBoundsAdjustment);</span>
<span class="line-removed"> 626         }</span>
<span class="line-removed"> 627     }</span>
<span class="line-removed"> 628 </span>
<span class="line-removed"> 629     Ref&lt;Frame&gt; protectedThis(*this);</span>
 630 
<span class="line-modified"> 631     if (action == PerformOverflowScroll &amp;&amp; (deltaX || deltaY)) {</span>
<span class="line-modified"> 632         layer-&gt;scrollToOffset(layer-&gt;scrollOffset() + IntSize(deltaX, deltaY), ScrollClamping::Unclamped);</span>

 633 
<span class="line-modified"> 634         // Handle making selection.</span>
<span class="line-modified"> 635         VisiblePosition visiblePosition(renderer-&gt;positionForPoint(selectionPosition, nullptr));</span>
<span class="line-modified"> 636         if (visiblePosition.isNotNull()) {</span>
<span class="line-modified"> 637             VisibleSelection visibleSelection = selection().selection();</span>
<span class="line-modified"> 638             visibleSelection.setExtent(visiblePosition);</span>
<span class="line-modified"> 639             if (selection().granularity() != CharacterGranularity)</span>
<span class="line-modified"> 640                 visibleSelection.expandUsingGranularity(selection().granularity());</span>
<span class="line-modified"> 641             if (selection().shouldChangeSelection(visibleSelection))</span>
<span class="line-modified"> 642                 selection().setSelection(visibleSelection);</span>









 643         }
<span class="line-removed"> 644 </span>
<span class="line-removed"> 645         m_overflowAutoScrollDelta *= 1.02f; // Accelerate the scroll</span>
 646     }
<span class="line-modified"> 647     return scrollType;</span>
<span class="line-removed"> 648 }</span>
<span class="line-removed"> 649 </span>
<span class="line-removed"> 650 void Frame::setSelectionChangeCallbacksDisabled(bool selectionChangeCallbacksDisabled)</span>
<span class="line-removed"> 651 {</span>
<span class="line-removed"> 652     m_selectionChangeCallbacksDisabled = selectionChangeCallbacksDisabled;</span>
<span class="line-removed"> 653 }</span>
 654 
<span class="line-modified"> 655 bool Frame::selectionChangeCallbacksDisabled() const</span>
<span class="line-modified"> 656 {</span>
<span class="line-removed"> 657     return m_selectionChangeCallbacksDisabled;</span>
 658 }
<span class="line-removed"> 659 #endif // PLATFORM(IOS_FAMILY)</span>
 660 
 661 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 662 {
 663     if (!view())
 664         return;
 665     // In setting printing, we should not validate resources already cached for the document.
 666     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 667     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 668 
 669     m_doc-&gt;setPrinting(printing);
 670     auto&amp; frameView = *view();
 671     frameView.adjustMediaTypeForPrinting(printing);
 672 
 673     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
 674     if (shouldUsePrintingLayout())
 675         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 676     else {
 677         frameView.forceLayout();
 678         if (shouldAdjustViewSize == AdjustViewSize)
 679             frameView.adjustViewSize();
</pre>
<hr />
<pre>
 717         return;
 718 
 719     if (loader().stateMachine().creatingInitialEmptyDocument() &amp;&amp; !settings().shouldInjectUserScriptsInInitialEmptyDocument())
 720         return;
 721 
 722     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 723         if (script.injectionTime() == injectionTime)
 724             injectUserScriptImmediately(world, script);
 725     });
 726 }
 727 
 728 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 729 {
 730     auto* document = this-&gt;document();
 731     if (!document)
 732         return;
 733     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 734         return;
 735     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 736         return;


 737 
<span class="line-modified"> 738     document-&gt;topDocument().setAsRunningUserScripts();</span>
 739     loader().client().willInjectUserScript(world);
 740     m_script-&gt;evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);
 741 }
 742 
 743 RenderView* Frame::contentRenderer() const
 744 {
 745     return document() ? document()-&gt;renderView() : nullptr;
 746 }
 747 
 748 RenderWidget* Frame::ownerRenderer() const
 749 {
 750     auto* ownerElement = m_ownerElement;
 751     if (!ownerElement)
 752         return nullptr;
 753     auto* object = ownerElement-&gt;renderer();
 754     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 755     // that it has started but canceled, then this can turn into an ASSERT
 756     // since m_ownerElement would be nullptr when the load is canceled.
 757     // https://bugs.webkit.org/show_bug.cgi?id=18585
 758     if (!is&lt;RenderWidget&gt;(object))
</pre>
<hr />
<pre>
 787 {
 788     clearTimers(m_view.get(), document());
 789 }
 790 
 791 void Frame::willDetachPage()
 792 {
 793     if (Frame* parent = tree().parent())
 794         parent-&gt;loader().checkLoadComplete();
 795 
 796     for (auto&amp; observer : m_destructionObservers)
 797         observer-&gt;willDetachPage();
 798 
 799     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 800     // so page() could be NULL.
 801     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 802         page()-&gt;focusController().setFocusedFrame(nullptr);
 803 
 804     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 805         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 806 
<span class="line-removed"> 807 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 808     if (WebThreadCountOfObservedDOMTimers() &gt; 0 &amp;&amp; m_page) {</span>
<span class="line-removed"> 809         LOG(ContentObservation, &quot;Frame::willDetachPage: remove registered timers.&quot;);</span>
<span class="line-removed"> 810         m_page-&gt;chrome().client().clearContentChangeObservers(*this);</span>
<span class="line-removed"> 811     }</span>
<span class="line-removed"> 812 #endif</span>
<span class="line-removed"> 813 </span>
 814     script().clearScriptObjects();
 815     script().updatePlatformScriptObjects();
 816 
 817     // We promise that the Frame is always connected to a Page while the render tree is live.
 818     //
 819     // The render tree can be torn down in a few different ways, but the two important ones are:
 820     //
 821     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 822     //   Frame::willDetachPage (this function.) Hence the assertion below.
 823     //
 824     // - When adding a document to the page cache, the tree is torn down before instantiating
 825     //   the CachedPage+CachedFrame object tree.
 826     ASSERT(!document() || !document()-&gt;renderView());
 827 }
 828 
 829 void Frame::disconnectOwnerElement()
 830 {
 831     if (m_ownerElement) {
 832         m_ownerElement-&gt;clearContentFrame();
 833         if (m_page)
 834             m_page-&gt;decrementSubframeCount();
 835     }
 836     m_ownerElement = nullptr;
 837 
 838     if (auto* document = this-&gt;document())
 839         document-&gt;frameWasDisconnectedFromOwner();
 840 }
 841 
 842 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 843 {
 844     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
 845 }
 846 
 847 VisiblePosition Frame::visiblePositionForPoint(const IntPoint&amp; framePoint) const
 848 {
<span class="line-modified"> 849     HitTestResult result = eventHandler().hitTestResultAtPoint(framePoint, HitTestRequest::ReadOnly | HitTestRequest::Active);</span>
 850     Node* node = result.innerNonSharedNode();
 851     if (!node)
 852         return VisiblePosition();
 853     auto renderer = node-&gt;renderer();
 854     if (!renderer)
 855         return VisiblePosition();
 856     VisiblePosition visiblePos = renderer-&gt;positionForPoint(result.localPoint(), nullptr);
 857     if (visiblePos.isNull())
 858         visiblePos = firstPositionInOrBeforeNode(node);
 859     return visiblePos;
 860 }
 861 
 862 Document* Frame::documentAtPoint(const IntPoint&amp; point)
 863 {
 864     if (!view())
 865         return nullptr;
 866 
 867     IntPoint pt = view()-&gt;windowToContents(point);
 868     HitTestResult result = HitTestResult(pt);
 869 
 870     if (contentRenderer())
<span class="line-modified"> 871         result = eventHandler().hitTestResultAtPoint(pt);</span>
 872     return result.innerNode() ? &amp;result.innerNode()-&gt;document() : 0;
 873 }
 874 
 875 RefPtr&lt;Range&gt; Frame::rangeForPoint(const IntPoint&amp; framePoint)
 876 {
 877     VisiblePosition position = visiblePositionForPoint(framePoint);
 878     if (position.isNull())
 879         return nullptr;
 880 
 881     Position deepPosition = position.deepEquivalent();
 882     Text* containerText = deepPosition.containerText();
 883     if (!containerText || !containerText-&gt;renderer() || containerText-&gt;renderer()-&gt;style().userSelect() == UserSelect::None)
 884         return nullptr;
 885 
 886     VisiblePosition previous = position.previous();
 887     if (previous.isNotNull()) {
 888         RefPtr&lt;Range&gt; previousCharacterRange = makeRange(previous, position);
 889         LayoutRect rect = editor().firstRectForRange(previousCharacterRange.get());
 890         if (rect.contains(framePoint))
 891             return previousCharacterRange;
</pre>
<hr />
<pre>
1064         return;
1065 
1066     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
1067     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
1068 
1069     // Frame::clearTimers() suspended animations and pending relayouts.
1070     animation().resumeAnimationsForDocument(m_doc.get());
1071     if (m_view)
1072         m_view-&gt;layoutContext().scheduleLayout();
1073 }
1074 
1075 void Frame::deviceOrPageScaleFactorChanged()
1076 {
1077     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1078         child-&gt;deviceOrPageScaleFactorChanged();
1079 
1080     if (RenderView* root = contentRenderer())
1081         root-&gt;compositor().deviceOrPageScaleFactorChanged();
1082 }
1083 
<span class="line-removed">1084 bool Frame::isURLAllowed(const URL&amp; url) const</span>
<span class="line-removed">1085 {</span>
<span class="line-removed">1086     // We allow one level of self-reference because some sites depend on that,</span>
<span class="line-removed">1087     // but we don&#39;t allow more than one.</span>
<span class="line-removed">1088     if (m_page-&gt;subframeCount() &gt;= Page::maxNumberOfFrames)</span>
<span class="line-removed">1089         return false;</span>
<span class="line-removed">1090     bool foundSelfReference = false;</span>
<span class="line-removed">1091     for (const Frame* frame = this; frame; frame = frame-&gt;tree().parent()) {</span>
<span class="line-removed">1092         if (equalIgnoringFragmentIdentifier(frame-&gt;document()-&gt;url(), url)) {</span>
<span class="line-removed">1093             if (foundSelfReference)</span>
<span class="line-removed">1094                 return false;</span>
<span class="line-removed">1095             foundSelfReference = true;</span>
<span class="line-removed">1096         }</span>
<span class="line-removed">1097     }</span>
<span class="line-removed">1098     return true;</span>
<span class="line-removed">1099 }</span>
<span class="line-removed">1100 </span>
1101 bool Frame::isAlwaysOnLoggingAllowed() const
1102 {
1103     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
1104 }
1105 
1106 void Frame::dropChildren()
1107 {
1108     ASSERT(isMainFrame());
1109     while (Frame* child = tree().firstChild())
1110         tree().removeChild(*child);
1111 }
1112 













1113 void Frame::selfOnlyRef()
1114 {
1115     ASSERT(isMainFrame());
1116     if (m_selfOnlyRefCount++)
1117         return;
1118 
1119     ref();
1120 }
1121 
1122 void Frame::selfOnlyDeref()
1123 {
1124     ASSERT(isMainFrame());
1125     ASSERT(m_selfOnlyRefCount);
1126     if (--m_selfOnlyRefCount)
1127         return;
1128 
1129     if (hasOneRef())
1130         dropChildren();
1131 
1132     deref();
1133 }
1134 





1135 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Simon Hausmann &lt;hausmann@kde.org&gt;
   6  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
   7  *                     2001 George Staikos &lt;staikos@kde.org&gt;
<span class="line-modified">   8  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
   9  * Copyright (C) 2005 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  10  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  11  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  12  * Copyright (C) 2008 Google Inc.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
</pre>
<hr />
<pre>
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserContentURLPattern.h&quot;
<span class="line-added">  98 #include &quot;UserGestureIndicator.h&quot;</span>
  99 #include &quot;UserScript.h&quot;
 100 #include &quot;UserTypingGestureIndicator.h&quot;
 101 #include &quot;VisibleUnits.h&quot;
 102 #include &quot;markup.h&quot;
 103 #include &quot;npruntime_impl.h&quot;
 104 #include &quot;runtime_root.h&quot;
 105 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 106 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 107 #include &lt;wtf/StdLibExtras.h&gt;
 108 #include &lt;wtf/text/StringBuilder.h&gt;
 109 




 110 namespace WebCore {
 111 
 112 using namespace HTMLNames;
 113 
 114 #if PLATFORM(IOS_FAMILY)
 115 static const Seconds scrollFrequency { 1000_s / 60. };
 116 #endif
 117 
 118 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, frameCounter, (&quot;Frame&quot;));
 119 
<span class="line-added"> 120 // We prewarm local storage for at most 5 origins in a given page.</span>
<span class="line-added"> 121 static const unsigned maxlocalStoragePrewarmingCount { 5 };</span>
<span class="line-added"> 122 </span>
 123 static inline Frame* parentFromOwnerElement(HTMLFrameOwnerElement* ownerElement)
 124 {
 125     if (!ownerElement)
 126         return 0;
 127     return ownerElement-&gt;document().frame();
 128 }
 129 
 130 static inline float parentPageZoomFactor(Frame* frame)
 131 {
 132     Frame* parent = frame-&gt;tree().parent();
 133     if (!parent)
 134         return 1;
 135     return parent-&gt;pageZoomFactor();
 136 }
 137 
 138 static inline float parentTextZoomFactor(Frame* frame)
 139 {
 140     Frame* parent = frame-&gt;tree().parent();
 141     if (!parent)
 142         return 1;
 143     return parent-&gt;textZoomFactor();
 144 }
 145 
 146 Frame::Frame(Page&amp; page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient&amp; frameLoaderClient)
 147     : m_mainFrame(ownerElement ? page.mainFrame() : *this)
 148     , m_page(&amp;page)
 149     , m_settings(&amp;page.settings())
 150     , m_treeNode(*this, parentFromOwnerElement(ownerElement))
 151     , m_loader(makeUniqueRef&lt;FrameLoader&gt;(*this, frameLoaderClient))
 152     , m_navigationScheduler(makeUniqueRef&lt;NavigationScheduler&gt;(*this))
 153     , m_ownerElement(ownerElement)
 154     , m_script(makeUniqueRef&lt;ScriptController&gt;(*this))
 155     , m_editor(makeUniqueRef&lt;Editor&gt;(*this))
 156     , m_selection(makeUniqueRef&lt;FrameSelection&gt;(this))
 157     , m_animationController(makeUniqueRef&lt;CSSAnimationController&gt;(*this))




 158     , m_pageZoomFactor(parentPageZoomFactor(this))
 159     , m_textZoomFactor(parentTextZoomFactor(this))

 160     , m_eventHandler(makeUniqueRef&lt;EventHandler&gt;(*this))
 161 {
 162     ProcessWarming::initializeNames();
 163 
 164     if (ownerElement) {
 165         m_mainFrame.selfOnlyRef();
 166         page.incrementSubframeCount();
 167         ownerElement-&gt;setContentFrame(this);
 168     }
 169 
 170 #ifndef NDEBUG
 171     frameCounter.increment();
 172 #endif
 173 
 174     // Pause future ActiveDOMObjects if this frame is being created while the page is in a paused state.
 175     Frame* parent = parentFromOwnerElement(ownerElement);
 176     if (parent &amp;&amp; parent-&gt;activeDOMObjectsAndAnimationsSuspended())
 177         suspendActiveDOMObjectsAndAnimations();
 178 }
 179 
</pre>
<hr />
<pre>
 481 
 482     if (bestPos != -1)
 483         return mutableStringToMatch.substring(bestPos, bestLength);
 484     return String();
 485 }
 486 
 487 String Frame::matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element* element)
 488 {
 489     // Match against the name element, then against the id element if no match is found for the name element.
 490     // See 7538330 for one popular site that benefits from the id element check.
 491     // FIXME: This code is mirrored in FrameMac.mm. It would be nice to make the Mac code call the platform-agnostic
 492     // code, which would require converting the NSArray of NSStrings to a Vector of Strings somewhere along the way.
 493     String resultFromNameAttribute = matchLabelsAgainstString(labels, element-&gt;getNameAttribute());
 494     if (!resultFromNameAttribute.isEmpty())
 495         return resultFromNameAttribute;
 496 
 497     return matchLabelsAgainstString(labels, element-&gt;attributeWithoutSynchronization(idAttr));
 498 }
 499 
 500 #if PLATFORM(IOS_FAMILY)


































 501 
<span class="line-modified"> 502 void Frame::setSelectionChangeCallbacksDisabled(bool selectionChangeCallbacksDisabled)</span>
 503 {
<span class="line-modified"> 504     m_selectionChangeCallbacksDisabled = selectionChangeCallbacksDisabled;</span>



 505 }
 506 
<span class="line-modified"> 507 bool Frame::selectionChangeCallbacksDisabled() const</span>
 508 {
<span class="line-modified"> 509     return m_selectionChangeCallbacksDisabled;</span>









 510 }
<span class="line-added"> 511 #endif // PLATFORM(IOS_FAMILY)</span>
 512 
<span class="line-modified"> 513 bool Frame::requestDOMPasteAccess()</span>
 514 {
<span class="line-modified"> 515     if (m_settings-&gt;javaScriptCanAccessClipboard() &amp;&amp; m_settings-&gt;DOMPasteAllowed())</span>
<span class="line-modified"> 516         return true;</span>















































 517 
<span class="line-modified"> 518     if (!m_settings-&gt;domPasteAccessRequestsEnabled() || !m_doc)</span>
<span class="line-modified"> 519         return false;</span>













 520 
<span class="line-modified"> 521     auto gestureToken = UserGestureIndicator::currentUserGesture();</span>
<span class="line-modified"> 522     if (!gestureToken || !gestureToken-&gt;processingUserGesture())</span>
<span class="line-added"> 523         return false;</span>
 524 
<span class="line-modified"> 525     switch (gestureToken-&gt;domPasteAccessPolicy()) {</span>
<span class="line-modified"> 526     case DOMPasteAccessPolicy::Granted:</span>
<span class="line-modified"> 527         return true;</span>
<span class="line-modified"> 528     case DOMPasteAccessPolicy::Denied:</span>
<span class="line-modified"> 529         return false;</span>
<span class="line-modified"> 530     case DOMPasteAccessPolicy::NotRequestedYet: {</span>
<span class="line-modified"> 531         auto* client = m_editor-&gt;client();</span>
<span class="line-modified"> 532         if (!client)</span>
<span class="line-modified"> 533             return false;</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535         auto response = client-&gt;requestDOMPasteAccess(m_doc-&gt;originIdentifierForPasteboard());</span>
<span class="line-added"> 536         gestureToken-&gt;didRequestDOMPasteAccess(response);</span>
<span class="line-added"> 537         switch (response) {</span>
<span class="line-added"> 538         case DOMPasteAccessResponse::GrantedForCommand:</span>
<span class="line-added"> 539         case DOMPasteAccessResponse::GrantedForGesture:</span>
<span class="line-added"> 540             return true;</span>
<span class="line-added"> 541         case DOMPasteAccessResponse::DeniedForGesture:</span>
<span class="line-added"> 542             return false;</span>
 543         }


 544     }
<span class="line-modified"> 545     }</span>






 546 
<span class="line-modified"> 547     ASSERT_NOT_REACHED();</span>
<span class="line-modified"> 548     return false;</span>

 549 }

 550 
 551 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 552 {
 553     if (!view())
 554         return;
 555     // In setting printing, we should not validate resources already cached for the document.
 556     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 557     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 558 
 559     m_doc-&gt;setPrinting(printing);
 560     auto&amp; frameView = *view();
 561     frameView.adjustMediaTypeForPrinting(printing);
 562 
 563     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
 564     if (shouldUsePrintingLayout())
 565         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 566     else {
 567         frameView.forceLayout();
 568         if (shouldAdjustViewSize == AdjustViewSize)
 569             frameView.adjustViewSize();
</pre>
<hr />
<pre>
 607         return;
 608 
 609     if (loader().stateMachine().creatingInitialEmptyDocument() &amp;&amp; !settings().shouldInjectUserScriptsInInitialEmptyDocument())
 610         return;
 611 
 612     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 613         if (script.injectionTime() == injectionTime)
 614             injectUserScriptImmediately(world, script);
 615     });
 616 }
 617 
 618 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 619 {
 620     auto* document = this-&gt;document();
 621     if (!document)
 622         return;
 623     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 624         return;
 625     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 626         return;
<span class="line-added"> 627     if (!m_script-&gt;shouldAllowUserAgentScripts(*document))</span>
<span class="line-added"> 628         return;</span>
 629 
<span class="line-modified"> 630     document-&gt;setAsRunningUserScripts();</span>
 631     loader().client().willInjectUserScript(world);
 632     m_script-&gt;evaluateInWorld(ScriptSourceCode(script.source(), URL(script.url())), world);
 633 }
 634 
 635 RenderView* Frame::contentRenderer() const
 636 {
 637     return document() ? document()-&gt;renderView() : nullptr;
 638 }
 639 
 640 RenderWidget* Frame::ownerRenderer() const
 641 {
 642     auto* ownerElement = m_ownerElement;
 643     if (!ownerElement)
 644         return nullptr;
 645     auto* object = ownerElement-&gt;renderer();
 646     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 647     // that it has started but canceled, then this can turn into an ASSERT
 648     // since m_ownerElement would be nullptr when the load is canceled.
 649     // https://bugs.webkit.org/show_bug.cgi?id=18585
 650     if (!is&lt;RenderWidget&gt;(object))
</pre>
<hr />
<pre>
 679 {
 680     clearTimers(m_view.get(), document());
 681 }
 682 
 683 void Frame::willDetachPage()
 684 {
 685     if (Frame* parent = tree().parent())
 686         parent-&gt;loader().checkLoadComplete();
 687 
 688     for (auto&amp; observer : m_destructionObservers)
 689         observer-&gt;willDetachPage();
 690 
 691     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 692     // so page() could be NULL.
 693     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 694         page()-&gt;focusController().setFocusedFrame(nullptr);
 695 
 696     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 697         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 698 







 699     script().clearScriptObjects();
 700     script().updatePlatformScriptObjects();
 701 
 702     // We promise that the Frame is always connected to a Page while the render tree is live.
 703     //
 704     // The render tree can be torn down in a few different ways, but the two important ones are:
 705     //
 706     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 707     //   Frame::willDetachPage (this function.) Hence the assertion below.
 708     //
 709     // - When adding a document to the page cache, the tree is torn down before instantiating
 710     //   the CachedPage+CachedFrame object tree.
 711     ASSERT(!document() || !document()-&gt;renderView());
 712 }
 713 
 714 void Frame::disconnectOwnerElement()
 715 {
 716     if (m_ownerElement) {
 717         m_ownerElement-&gt;clearContentFrame();
 718         if (m_page)
 719             m_page-&gt;decrementSubframeCount();
 720     }
 721     m_ownerElement = nullptr;
 722 
 723     if (auto* document = this-&gt;document())
 724         document-&gt;frameWasDisconnectedFromOwner();
 725 }
 726 
 727 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 728 {
 729     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
 730 }
 731 
 732 VisiblePosition Frame::visiblePositionForPoint(const IntPoint&amp; framePoint) const
 733 {
<span class="line-modified"> 734     HitTestResult result = eventHandler().hitTestResultAtPoint(framePoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);</span>
 735     Node* node = result.innerNonSharedNode();
 736     if (!node)
 737         return VisiblePosition();
 738     auto renderer = node-&gt;renderer();
 739     if (!renderer)
 740         return VisiblePosition();
 741     VisiblePosition visiblePos = renderer-&gt;positionForPoint(result.localPoint(), nullptr);
 742     if (visiblePos.isNull())
 743         visiblePos = firstPositionInOrBeforeNode(node);
 744     return visiblePos;
 745 }
 746 
 747 Document* Frame::documentAtPoint(const IntPoint&amp; point)
 748 {
 749     if (!view())
 750         return nullptr;
 751 
 752     IntPoint pt = view()-&gt;windowToContents(point);
 753     HitTestResult result = HitTestResult(pt);
 754 
 755     if (contentRenderer())
<span class="line-modified"> 756         result = eventHandler().hitTestResultAtPoint(pt, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent);</span>
 757     return result.innerNode() ? &amp;result.innerNode()-&gt;document() : 0;
 758 }
 759 
 760 RefPtr&lt;Range&gt; Frame::rangeForPoint(const IntPoint&amp; framePoint)
 761 {
 762     VisiblePosition position = visiblePositionForPoint(framePoint);
 763     if (position.isNull())
 764         return nullptr;
 765 
 766     Position deepPosition = position.deepEquivalent();
 767     Text* containerText = deepPosition.containerText();
 768     if (!containerText || !containerText-&gt;renderer() || containerText-&gt;renderer()-&gt;style().userSelect() == UserSelect::None)
 769         return nullptr;
 770 
 771     VisiblePosition previous = position.previous();
 772     if (previous.isNotNull()) {
 773         RefPtr&lt;Range&gt; previousCharacterRange = makeRange(previous, position);
 774         LayoutRect rect = editor().firstRectForRange(previousCharacterRange.get());
 775         if (rect.contains(framePoint))
 776             return previousCharacterRange;
</pre>
<hr />
<pre>
 949         return;
 950 
 951     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 952     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 953 
 954     // Frame::clearTimers() suspended animations and pending relayouts.
 955     animation().resumeAnimationsForDocument(m_doc.get());
 956     if (m_view)
 957         m_view-&gt;layoutContext().scheduleLayout();
 958 }
 959 
 960 void Frame::deviceOrPageScaleFactorChanged()
 961 {
 962     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 963         child-&gt;deviceOrPageScaleFactorChanged();
 964 
 965     if (RenderView* root = contentRenderer())
 966         root-&gt;compositor().deviceOrPageScaleFactorChanged();
 967 }
 968 

















 969 bool Frame::isAlwaysOnLoggingAllowed() const
 970 {
 971     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
 972 }
 973 
 974 void Frame::dropChildren()
 975 {
 976     ASSERT(isMainFrame());
 977     while (Frame* child = tree().firstChild())
 978         tree().removeChild(*child);
 979 }
 980 
<span class="line-added"> 981 void Frame::didPrewarmLocalStorage()</span>
<span class="line-added"> 982 {</span>
<span class="line-added"> 983     ASSERT(isMainFrame());</span>
<span class="line-added"> 984     ASSERT(m_localStoragePrewarmingCount &lt; maxlocalStoragePrewarmingCount);</span>
<span class="line-added"> 985     ++m_localStoragePrewarmingCount;</span>
<span class="line-added"> 986 }</span>
<span class="line-added"> 987 </span>
<span class="line-added"> 988 bool Frame::mayPrewarmLocalStorage() const</span>
<span class="line-added"> 989 {</span>
<span class="line-added"> 990     ASSERT(isMainFrame());</span>
<span class="line-added"> 991     return m_localStoragePrewarmingCount &lt; maxlocalStoragePrewarmingCount;</span>
<span class="line-added"> 992 }</span>
<span class="line-added"> 993 </span>
 994 void Frame::selfOnlyRef()
 995 {
 996     ASSERT(isMainFrame());
 997     if (m_selfOnlyRefCount++)
 998         return;
 999 
1000     ref();
1001 }
1002 
1003 void Frame::selfOnlyDeref()
1004 {
1005     ASSERT(isMainFrame());
1006     ASSERT(m_selfOnlyRefCount);
1007     if (--m_selfOnlyRefCount)
1008         return;
1009 
1010     if (hasOneRef())
1011         dropChildren();
1012 
1013     deref();
1014 }
1015 
<span class="line-added">1016 PAL::SessionID Frame::sessionID() const</span>
<span class="line-added">1017 {</span>
<span class="line-added">1018     return m_loader-&gt;client().sessionID();</span>
<span class="line-added">1019 }</span>
<span class="line-added">1020 </span>
1021 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FocusController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Frame.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>