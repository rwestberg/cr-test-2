<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGObjectAllocationSinkingPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 94,11 ***</span>
          asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
          return;
      }
      if (baseValue.isObject()) {
          JSObject* object = asObject(baseValue);
<span class="line-modified">!         if (object-&gt;canSetIndexQuickly(index)) {</span>
              object-&gt;setIndexQuickly(vm, index, value);
              return;
          }
  
          object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);
<span class="line-new-header">--- 94,11 ---</span>
          asObject(baseValue)-&gt;putDirectIndex(exec, index, value, 0, strict ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);
          return;
      }
      if (baseValue.isObject()) {
          JSObject* object = asObject(baseValue);
<span class="line-modified">!         if (object-&gt;canSetIndexQuickly(index, value)) {</span>
              object-&gt;setIndexQuickly(vm, index, value);
              return;
          }
  
          object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, index, value, strict);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,20 ***</span>
  
  template&lt;typename ViewClass&gt;
  char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (size &lt; 0) {
          throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));
          return 0;
      }
  
      if (vector)
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, vector));</span>
  
      RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));
  }
  
  template &lt;bool strict&gt;
<span class="line-new-header">--- 187,20 ---</span>
  
  template&lt;typename ViewClass&gt;
  char* newTypedArrayWithSize(ExecState* exec, Structure* structure, int32_t size, char* vector)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (size &lt; 0) {
          throwException(exec, scope, createRangeError(exec, &quot;Requested length is negative&quot;_s));
          return 0;
      }
  
      if (vector)
<span class="line-modified">!         return bitwise_cast&lt;char*&gt;(ViewClass::createWithFastVector(exec, structure, size, untagArrayPtr(vector, size)));</span>
  
      RELEASE_AND_RETURN(scope, bitwise_cast&lt;char*&gt;(ViewClass::create(exec, structure, size)));
  }
  
  template &lt;bool strict&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,10 ***</span>
<span class="line-new-header">--- 211,64 ---</span>
      JSValue putValue = JSValue::decode(encodedValue);
      PutPropertySlot slot(thisVal, strict);
      baseValue.putInline(exec, ident, putValue, slot);
  }
  
<span class="line-added">+ template&lt;typename BigIntOperation, typename NumberOperation&gt;</span>
<span class="line-added">+ static ALWAYS_INLINE EncodedJSValue binaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, NumberOperation&amp;&amp; numberOp, const char* errorMessage)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added">+     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto leftNumeric = op1.toNumeric(exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+     auto rightNumeric = op2.toNumeric(exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added">+         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))</span>
<span class="line-added">+             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
<span class="line-added">+ </span>
<span class="line-added">+         return throwVMTypeError(exec, scope, errorMessage);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     scope.release();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(jsNumber(numberOp(WTF::get&lt;double&gt;(leftNumeric), WTF::get&lt;double&gt;(rightNumeric))));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename BigIntOperation, typename Int32Operation&gt;</span>
<span class="line-added">+ static ALWAYS_INLINE EncodedJSValue bitwiseBinaryOp(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BigIntOperation&amp;&amp; bigIntOp, Int32Operation&amp;&amp; int32Op, const char* errorMessage)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-added">+     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-added">+         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric))</span>
<span class="line-added">+             RELEASE_AND_RETURN(scope, JSValue::encode(bigIntOp(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric))));</span>
<span class="line-added">+ </span>
<span class="line-added">+         return throwVMTypeError(exec, scope, errorMessage);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     scope.release();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(jsNumber(int32Op(WTF::get&lt;int32_t&gt;(leftNumeric), WTF::get&lt;int32_t&gt;(rightNumeric))));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static ALWAYS_INLINE EncodedJSValue parseIntResult(double input)
  {
      int asInt = static_cast&lt;int&gt;(input);
      if (static_cast&lt;double&gt;(asInt) == input)
          return JSValue::encode(jsNumber(asInt));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,28 ***</span>
  
  extern &quot;C&quot; {
  
  EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));
  }
  
  EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));
  }
  
  JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* object = JSValue::decode(encodedObject).toObject(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
      scope.release();
<span class="line-new-header">--- 287,28 ---</span>
  
  extern &quot;C&quot; {
  
  EncodedJSValue JIT_OPERATION operationToThis(ExecState* exec, EncodedJSValue encodedOp)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, NotStrictMode));
  }
  
  EncodedJSValue JIT_OPERATION operationToThisStrict(ExecState* exec, EncodedJSValue encodedOp)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(encodedOp).toThis(exec, StrictMode));
  }
  
  JSArray* JIT_OPERATION operationObjectKeys(ExecState* exec, EncodedJSValue encodedObject)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* object = JSValue::decode(encodedObject).toObject(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
      scope.release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,18 ***</span>
  }
  
  JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
  }
  
  JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue prototype = JSValue::decode(encodedPrototype);
  
      if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
<span class="line-new-header">--- 316,18 ---</span>
  }
  
  JSArray* JIT_OPERATION operationObjectKeysObject(ExecState* exec, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude);
  }
  
  JSCell* JIT_OPERATION operationObjectCreate(ExecState* exec, EncodedJSValue encodedPrototype)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue prototype = JSValue::decode(encodedPrototype);
  
      if (!prototype.isObject() &amp;&amp; !prototype.isNull()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,23 ***</span>
  }
  
  JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return constructEmptyObject(exec, prototype);
  }
  
  JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
          auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);
          scope.releaseAssertNoException();
<span class="line-modified">!         ObjectAllocationProfile* allocationProfile = rareData-&gt;objectAllocationProfile();</span>
          Structure* structure = allocationProfile-&gt;structure();
          JSObject* result = constructEmptyObject(exec, structure);
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
              ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));
<span class="line-new-header">--- 341,23 ---</span>
  }
  
  JSCell* JIT_OPERATION operationObjectCreateObject(ExecState* exec, JSObject* prototype)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return constructEmptyObject(exec, prototype);
  }
  
  JSCell* JIT_OPERATION operationCreateThis(ExecState* exec, JSObject* constructor, uint32_t inlineCapacity)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) {
          auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity);
          scope.releaseAssertNoException();
<span class="line-modified">!         ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();</span>
          Structure* structure = allocationProfile-&gt;structure();
          JSObject* result = constructEmptyObject(exec, structure);
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
              ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, exec));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 321,11 ***</span>
      return constructEmptyObject(exec);
  }
  
  JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
<span class="line-new-header">--- 375,11 ---</span>
      return constructEmptyObject(exec);
  }
  
  JSCell* JIT_OPERATION operationCallObjectConstructor(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,13 ***</span>
      return value.toObject(exec, globalObject);
  }
  
  JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (UNLIKELY(value.isUndefinedOrNull())) {
<span class="line-new-header">--- 388,13 ---</span>
      return value.toObject(exec, globalObject);
  }
  
  JSCell* JIT_OPERATION operationToObject(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedTarget, UniquedStringImpl* errorMessage)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue value = JSValue::decode(encodedTarget);
      ASSERT(!value.isObject());
  
      if (UNLIKELY(value.isUndefinedOrNull())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,126 ***</span>
      }
  
      RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
<span class="line-modified">!     JSValue op1 = JSValue::decode(encodedOp1);</span>
  
<span class="line-modified">!     int32_t operandValue = op1.toInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return JSValue::encode(jsNumber(~operandValue));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
<span class="line-removed">-     JSValue op2 = JSValue::decode(encodedOp2);</span>
  
<span class="line-modified">!     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified">!         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed">-             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed">-             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-             return JSValue::encode(result);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
<span class="line-modified">!     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified">!     JSValue op2 = JSValue::decode(encodedOp2);</span>
  
<span class="line-modified">!     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
  
<span class="line-modified">!     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified">!         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified">!             return JSValue::encode(result);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed">-     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto leftNumeric = op1.toBigIntOrInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     auto rightNumeric = op2.toBigIntOrInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed">-         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed">-             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed">-             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-             return JSValue::encode(result);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
<span class="line-modified">!     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-modified">!     JSValue op2 = JSValue::decode(encodedOp2);</span>
  
<span class="line-modified">!     int32_t a = op1.toInt32(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     scope.release();</span>
<span class="line-removed">-     uint32_t b = op2.toUInt32(exec);</span>
<span class="line-removed">-     return JSValue::encode(jsNumber(a &lt;&lt; (b &amp; 0x1f)));</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      int32_t a = op1.toInt32(exec);
<span class="line-new-header">--- 405,97 ---</span>
      }
  
      RELEASE_AND_RETURN(scope, value.toObject(exec, globalObject));
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueMod(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::remainder(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-added">+         return jsMod(left, right);</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;);</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitNot(ExecState* exec, EncodedJSValue encodedOp1)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
  
<span class="line-modified">!     auto operandNumeric = op1.toBigIntOrInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric))</span>
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric))));</span>
  
<span class="line-modified">!     return JSValue::encode(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitAnd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseAnd(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified">!         return left &amp; right;</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;_s);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValueBitOr(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseOr(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified">!         return left | right;</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;_s);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitXor(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::bitwiseXor(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified">!         return left ^ right;</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;_s);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitLShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::leftShift(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto int32Op = [] (int32_t left, int32_t right) -&gt; int32_t {</span>
<span class="line-modified">!         return left &lt;&lt; (right &amp; 0x1f);</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return bitwiseBinaryOp(exec, encodedOp1, encodedOp2, bigIntOp, int32Op, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;_s);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitRShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      int32_t a = op1.toInt32(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,13 ***</span>
      return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      uint32_t a = op1.toUInt32(exec);
<span class="line-new-header">--- 505,13 ---</span>
      return JSValue::encode(jsNumber(a &gt;&gt; (b &amp; 0x1f)));
  }
  
  EncodedJSValue JIT_OPERATION operationValueBitURShift(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      uint32_t a = op1.toUInt32(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,164 ***</span>
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      return JSValue::encode(jsAddNonNumber(exec, op1, op2));
  }
  
  EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed">-     JSValue op2 = JSValue::decode(encodedOp2);</span>
  
<span class="line-modified">!     auto leftNumeric = op1.toNumeric(exec);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-modified">!     auto rightNumeric = op2.toNumeric(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
  
<span class="line-modified">!     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-modified">!         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {</span>
<span class="line-removed">-             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
<span class="line-removed">-             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-             return JSValue::encode(result);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     scope.release();</span>
  
<span class="line-modified">!     double a = WTF::get&lt;double&gt;(leftNumeric);</span>
<span class="line-removed">-     double b = WTF::get&lt;double&gt;(rightNumeric);</span>
<span class="line-removed">-     return JSValue::encode(jsNumber(a / b));</span>
  }
  
  double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return fabs(a);
  }
  
  uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      uint32_t value = op1.toUInt32(exec);
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return clz32(value);</span>
  }
  
  double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return static_cast&lt;float&gt;(a);
  }
  
  #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
  double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \
  { \
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm(); \</span>
      NativeCallFrameTracer tracer(vm, exec); \
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm); \</span>
      JSValue op1 = JSValue::decode(encodedOp1); \
      double result = op1.toNumber(exec); \
      RETURN_IF_EXCEPTION(scope, PNaN); \
      return JSC::Math::lowerName(result); \
  }
      FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
  #undef DFG_ARITH_UNARY
  
  double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return sqrt(a);
  }
  
  EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(floor(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(ceil(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(*vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(truncatedValueOfArgument));
  }
  
  static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (base-&gt;isObject()) {
          JSObject* object = asObject(base);
          if (object-&gt;canGetIndexQuickly(index))
              return JSValue::encode(object-&gt;getIndexQuickly(index));
<span class="line-new-header">--- 521,159 ---</span>
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 0x1f))));
  }
  
  EncodedJSValue JIT_OPERATION operationValueAddNotNumber(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue op1 = JSValue::decode(encodedOp1);
      JSValue op2 = JSValue::decode(encodedOp2);
  
      return JSValue::encode(jsAddNonNumber(exec, op1, op2));
  }
  
  EncodedJSValue JIT_OPERATION operationValueDiv(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)
  {
<span class="line-modified">!     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-modified">!         return JSBigInt::divide(exec, left, right);</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-modified">!         return left / right;</span>
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in division operation.&quot;);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationValuePow(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
<span class="line-modified">! {</span>
<span class="line-added">+     auto bigIntOp = [] (ExecState* exec, JSBigInt* left, JSBigInt* right) -&gt; JSBigInt* {</span>
<span class="line-added">+         return JSBigInt::exponentiate(exec, left, right);</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     auto numberOp = [] (double left, double right) -&gt; double {</span>
<span class="line-added">+         return operationMathPow(left, right);</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     return binaryOp(exec, encodedOp1, encodedOp2, bigIntOp, numberOp, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;_s);</span>
  }
  
  double JIT_OPERATION operationArithAbs(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return fabs(a);
  }
  
  uint32_t JIT_OPERATION operationArithClz32(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      uint32_t value = op1.toUInt32(exec);
      RETURN_IF_EXCEPTION(scope, 0);
<span class="line-modified">!     return clz(value);</span>
  }
  
  double JIT_OPERATION operationArithFRound(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return static_cast&lt;float&gt;(a);
  }
  
  #define DFG_ARITH_UNARY(capitalizedName, lowerName) \
  double JIT_OPERATION operationArith##capitalizedName(ExecState* exec, EncodedJSValue encodedOp1) \
  { \
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm(); \</span>
      NativeCallFrameTracer tracer(vm, exec); \
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm); \</span>
      JSValue op1 = JSValue::decode(encodedOp1); \
      double result = op1.toNumber(exec); \
      RETURN_IF_EXCEPTION(scope, PNaN); \
      return JSC::Math::lowerName(result); \
  }
      FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY)
  #undef DFG_ARITH_UNARY
  
  double JIT_OPERATION operationArithSqrt(ExecState* exec, EncodedJSValue encodedOp1)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue op1 = JSValue::decode(encodedOp1);
      double a = op1.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, PNaN);
      return sqrt(a);
  }
  
  EncodedJSValue JIT_OPERATION operationArithRound(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(jsRound(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithFloor(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(floor(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithCeil(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double valueOfArgument = argument.toNumber(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(ceil(valueOfArgument)));
  }
  
  EncodedJSValue JIT_OPERATION operationArithTrunc(ExecState* exec, EncodedJSValue encodedArgument)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
      double truncatedValueOfArgument = argument.toIntegerPreserveNaN(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsNumber(truncatedValueOfArgument));
  }
  
  static ALWAYS_INLINE EncodedJSValue getByVal(ExecState* exec, JSCell* base, uint32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (base-&gt;isObject()) {
          JSObject* object = asObject(base);
          if (object-&gt;canGetIndexQuickly(index))
              return JSValue::encode(object-&gt;getIndexQuickly(index));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue property = JSValue::decode(encodedProperty);
  
<span class="line-new-header">--- 686,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue property = JSValue::decode(encodedProperty);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,12 ***</span>
                  RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
  
          } else if (property.isString()) {
              Structure&amp; structure = *base-&gt;structure(vm);
              if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!                 if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(property)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">!                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>
                          return JSValue::encode(result);
                  }
              }
          }
      }
<span class="line-new-header">--- 707,14 ---</span>
                  RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
  
          } else if (property.isString()) {
              Structure&amp; structure = *base-&gt;structure(vm);
              if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!                 RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">!                 RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+                 if (existingAtomString) {</span>
<span class="line-added">+                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
                          return JSValue::encode(result);
                  }
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 705,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue property = JSValue::decode(encodedProperty);
  
      if (property.isUInt32())
<span class="line-new-header">--- 727,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValCell(ExecState* exec, JSCell* base, EncodedJSValue encodedProperty)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue property = JSValue::decode(encodedProperty);
  
      if (property.isUInt32())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 722,12 ***</span>
              RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
  
      } else if (property.isString()) {
          Structure&amp; structure = *base-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(property)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">!                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>
                      return JSValue::encode(result);
              }
          }
      }
  
<span class="line-new-header">--- 744,14 ---</span>
              RELEASE_AND_RETURN(scope, getByVal(exec, base, propertyAsUInt32));
  
      } else if (property.isString()) {
          Structure&amp; structure = *base-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+             if (existingAtomString) {</span>
<span class="line-added">+                 if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
                      return JSValue::encode(result);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,16 ***</span>
      RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));
  }
  
  ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      if (index &lt; 0) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return JSValue::encode(JSValue(base).get(exec, Identifier::from(exec, index)));</span>
      }
  
      // Use this since we know that the value is out of bounds.
      return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));
  }
<span class="line-new-header">--- 760,16 ---</span>
      RELEASE_AND_RETURN(scope, JSValue::encode(JSValue(base).get(exec, propertyName)));
  }
  
  ALWAYS_INLINE EncodedJSValue getByValCellInt(ExecState* exec, JSCell* base, int32_t index)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      if (index &lt; 0) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return JSValue::encode(JSValue(base).get(exec, Identifier::from(vm, index)));</span>
      }
  
      // Use this since we know that the value is out of bounds.
      return JSValue::encode(JSValue(base).get(exec, static_cast&lt;unsigned&gt;(index)));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 761,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto propertyName = asString(string)-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-new-header">--- 785,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValObjectString(ExecState* exec, JSCell* base, JSCell* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto propertyName = asString(string)-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,288 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     return JSValue::encode(getByValObject(exec, vm, asObject(base), asSymbol(symbol)-&gt;privateName()));</span>
  }
  
  void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, jsValue, true);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(exec, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, jsValue, false);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     object-&gt;methodTable(*vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(exec, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, jsValue);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, asSymbol(symbol)-&gt;privateName(), JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(exec, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;pushInline(exec, JSValue::decode(encodedValue));
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
<span class="line-new-header">--- 798,293 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValObjectSymbol(ExecState* exec, JSCell* base, JSCell* symbol)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">+     return JSValue::encode(getByValObject(exec, vm, asObject(base), propertyName));</span>
  }
  
  void JIT_OPERATION operationPutByValStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;true, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;false, false&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;true, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;false, false&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValCellStringInternal&lt;true, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValCellStringInternal&lt;false, false&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">+     putByValCellInternal&lt;true, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">+     putByValCellInternal&lt;false, false&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), true);
          return;
      }
  
      PutPropertySlot slot(object, true);
      object-&gt;methodTable(vm)-&gt;put(
<span class="line-modified">!         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, JSValue::decode(encodedValue), false);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, jsValue, true);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putByIndexInline(exec, index, jsValue, false);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;put(</span>
<span class="line-modified">!         object, exec, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, jsValue, 0, PutDirectIndexShouldThrow);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutDoubleByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, double value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue jsValue = JSValue(JSValue::EncodeAsDouble, value);
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, jsValue);
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), jsValue, slot);</span>
  }
  
  void JIT_OPERATION operationPutByValDirectStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;true, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectNonStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;false, true&gt;(exec, vm, encodedBase, encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;true, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellNonStrict(ExecState* exec, JSCell* cell, EncodedJSValue encodedProperty, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValInternal&lt;false, true&gt;(exec, vm, JSValue::encode(cell), encodedProperty, encodedValue);
  }
  
  void JIT_OPERATION operationPutByValDirectCellStringStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValCellStringInternal&lt;true, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValDirectCellStringNonStrict(ExecState* exec, JSCell* cell, JSCell* string, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      putByValCellStringInternal&lt;false, true&gt;(exec, vm, cell, asString(string), JSValue::decode(encodedValue));
  }
  
  void JIT_OPERATION operationPutByValDirectCellSymbolStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">+     putByValCellInternal&lt;true, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValDirectCellSymbolNonStrict(ExecState* exec, JSCell* cell, JSCell* symbol, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     auto propertyName = asSymbol(symbol)-&gt;privateName();</span>
<span class="line-added">+     putByValCellInternal&lt;false, true&gt;(exec, vm, cell, propertyName, JSValue::decode(encodedValue));</span>
  }
  
  void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue), 0, PutDirectIndexShouldThrow);
          return;
      }
  
      PutPropertySlot slot(object, true);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  void JIT_OPERATION operationPutByValDirectBeyondArrayBoundsNonStrict(ExecState* exec, JSObject* object, int32_t index, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (index &gt;= 0) {
          object-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));
          return;
      }
  
      PutPropertySlot slot(object, false);
<span class="line-modified">!     CommonSlowPaths::putDirectWithReify(vm, exec, object, Identifier::from(vm, index), JSValue::decode(encodedValue), slot);</span>
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPush(ExecState* exec, EncodedJSValue encodedValue, JSArray* array)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;pushInline(exec, JSValue::decode(encodedValue));
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushDouble(ExecState* exec, double value, JSArray* array)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;pushInline(exec, JSValue(JSValue::EncodeAsDouble, value));
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithInt32/ArrayWithContiguous do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithInt32/ArrayWithContiguous, we can ensure
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1075,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
<span class="line-new-header">--- 1104,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPushDoubleMultiple(ExecState* exec, JSArray* array, void* buffer, int32_t elementCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We assume that multiple JSArray::push calls with ArrayWithDouble do not cause JS traps.
      // If it can cause any JS interactions, we can call the caller JS function of this function and overwrite the
      // content of ScratchBuffer. If the IndexingType is now ArrayWithDouble, we can ensure
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1094,19 ***</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(array-&gt;pop(exec));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
  
      return JSValue::encode(array-&gt;pop(exec));
<span class="line-new-header">--- 1123,19 ---</span>
      return JSValue::encode(jsNumber(array-&gt;length()));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPop(ExecState* exec, JSArray* array)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(array-&gt;pop(exec));
  }
  
  EncodedJSValue JIT_OPERATION operationArrayPopAndRecoverLength(ExecState* exec, JSArray* array)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      array-&gt;butterfly()-&gt;setPublicLength(array-&gt;butterfly()-&gt;publicLength() + 1);
  
      return JSValue::encode(array-&gt;pop(exec));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1115,21 ***</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
  }
  
  EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      JSString* input = argument.toStringOrNull(exec);
<span class="line-new-header">--- 1144,21 ---</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
  }
  
  EncodedJSValue JIT_OPERATION operationRegExpExec(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      JSString* input = argument.toStringOrNull(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1142,11 ***</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-new-header">--- 1171,11 ---</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1164,11 ***</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String input = string-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-new-header">--- 1193,11 ---</span>
  EncodedJSValue JIT_OPERATION operationRegExpExecNonGlobalOrSticky(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String input = string-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, { });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1189,11 ***</span>
  EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!regExpObject-&gt;regExp()-&gt;global())
          return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
      return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));
  }
<span class="line-new-header">--- 1218,11 ---</span>
  EncodedJSValue JIT_OPERATION operationRegExpMatchFastString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* argument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!regExpObject-&gt;regExp()-&gt;global())
          return JSValue::encode(regExpObject-&gt;execInline(exec, globalObject, argument));
      return JSValue::encode(regExpObject-&gt;matchGlobal(exec, globalObject, argument));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1201,11 ***</span>
  EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(regExp-&gt;global());
  
<span class="line-new-header">--- 1230,11 ---</span>
  EncodedJSValue JIT_OPERATION operationRegExpMatchFastGlobalString(ExecState* exec, JSGlobalObject* globalObject, RegExp* regExp, JSString* string)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(regExp-&gt;global());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,22 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
          // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
          return parseIntResult(parseInt(view, 0));
      });
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-new-header">--- 1258,22 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntNoRadixGeneric(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
          // This version is as if radix was undefined. Hence, undefined.toNumber() === 0.
          return parseIntResult(parseInt(view, 0));
      });
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntStringNoRadix(ExecState* exec, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1253,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-new-header">--- 1282,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntString(ExecState* exec, JSString* string, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto viewWithString = string-&gt;viewWithUnderlyingString(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1265,11 ***</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
          return parseIntResult(parseInt(view, radix));
      });
  }
<span class="line-new-header">--- 1294,11 ---</span>
  }
  
  EncodedJSValue JIT_OPERATION operationParseIntGeneric(ExecState* exec, EncodedJSValue value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return toStringView(exec, JSValue::decode(value), [&amp;] (StringView view) {
          return parseIntResult(parseInt(view, radix));
      });
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,21 ***</span>
  size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return regExpObject-&gt;testInline(exec, globalObject, input);
  }
  
  size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      JSString* input = argument.toStringOrNull(exec);
      if (!input)
<span class="line-new-header">--- 1306,21 ---</span>
  size_t JIT_OPERATION operationRegExpTestString(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, JSString* input)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return regExpObject-&gt;testInline(exec, globalObject, input);
  }
  
  size_t JIT_OPERATION operationRegExpTest(ExecState* exec, JSGlobalObject* globalObject, RegExpObject* regExpObject, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      JSString* input = argument.toStringOrNull(exec);
      if (!input)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1302,11 ***</span>
  size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
<span class="line-new-header">--- 1331,11 ---</span>
  size_t JIT_OPERATION operationRegExpTestGeneric(ExecState* exec, JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedArgument)
  {
      SuperSamplerScope superSamplerScope(false);
  
      VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      JSValue argument = JSValue::decode(encodedArgument);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1323,132 ***</span>
      RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));
  }
  
  JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::sub(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::multiply(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::divide(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::add(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);
  }
  
  size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::strictEqualSlowCaseInline(exec, op1, op2);
  }
  
  size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));
  }
  
  EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(value).toPrimitive(exec));
  }
  
  EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             if (RefPtr&lt;AtomicStringImpl&gt; existingAtomicString = asString(subscript)-&gt;toExistingAtomicString(exec)) {</span>
<span class="line-modified">!                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomicString.get()))</span>
                      return JSValue::encode(result);
              }
          }
      }
  
<span class="line-new-header">--- 1352,177 ---</span>
      RELEASE_AND_RETURN(scope, regexp-&gt;test(exec, globalObject, input));
  }
  
  JSCell* JIT_OPERATION operationSubBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::sub(exec, leftOperand, rightOperand);
  }
  
<span class="line-added">+ JSCell* JIT_OPERATION operationBitNotBigInt(ExecState* exec, JSCell* op1)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSBigInt* operand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSBigInt::bitwiseNot(exec, operand);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JSCell* JIT_OPERATION operationMulBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::multiply(exec, leftOperand, rightOperand);
  }
  
<span class="line-added">+ JSCell* JIT_OPERATION operationModBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">+     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSBigInt::remainder(exec, leftOperand, rightOperand);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JSCell* JIT_OPERATION operationDivBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::divide(exec, leftOperand, rightOperand);
  }
  
<span class="line-added">+ JSCell* JIT_OPERATION operationPowBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">+     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSBigInt::exponentiate(exec, leftOperand, rightOperand);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JSCell* JIT_OPERATION operationBitAndBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseAnd(exec, leftOperand, rightOperand);
  }
  
<span class="line-added">+ JSCell* JIT_OPERATION operationBitLShiftBigInt(ExecState* exec, JSCell* op1, JSCell* op2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);</span>
<span class="line-added">+     JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSBigInt::leftShift(exec, leftOperand, rightOperand);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JSCell* JIT_OPERATION operationAddBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::add(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationBitOrBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseOr(exec, leftOperand, rightOperand);
  }
  
  JSCell* JIT_OPERATION operationBitXorBigInt(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSBigInt* leftOperand = jsCast&lt;JSBigInt*&gt;(op1);
      JSBigInt* rightOperand = jsCast&lt;JSBigInt*&gt;(op2);
  
      return JSBigInt::bitwiseXor(exec, leftOperand, rightOperand);
  }
  
  size_t JIT_OPERATION operationCompareStrictEqCell(ExecState* exec, JSCell* op1, JSCell* op2)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::strictEqualSlowCaseInline(exec, op1, op2);
  }
  
  size_t JIT_OPERATION operationSameValue(ExecState* exec, EncodedJSValue arg1, EncodedJSValue arg2)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return sameValue(exec, JSValue::decode(arg1), JSValue::decode(arg2));
  }
  
  EncodedJSValue JIT_OPERATION operationToPrimitive(ExecState* exec, EncodedJSValue value)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(JSValue::decode(value).toPrimitive(exec));
  }
  
  EncodedJSValue JIT_OPERATION operationToNumber(ExecState* exec, EncodedJSValue value)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return JSValue::encode(jsNumber(JSValue::decode(value).toNumber(exec)));
  }
  
  EncodedJSValue JIT_OPERATION operationGetByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue baseValue = JSValue::decode(encodedBase);
      JSValue thisVal = JSValue::decode(encodedThis);
      JSValue subscript = JSValue::decode(encodedSubscript);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+             if (existingAtomString) {</span>
<span class="line-added">+                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
                      return JSValue::encode(result);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1470,27 ***</span>
  }
  
  void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(exec, impl));</span>
  }
  
  void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(exec, impl));</span>
  }
  
  void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-new-header">--- 1544,27 ---</span>
  }
  
  void JIT_OPERATION operationPutByIdWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;true&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
  void JIT_OPERATION operationPutByIdWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedValue, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     putWithThis&lt;false&gt;(exec, encodedBase, encodedThis, encodedValue, Identifier::fromUid(vm, impl));</span>
  }
  
  void JIT_OPERATION operationPutByValWithThisStrict(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1498,11 ***</span>
  }
  
  void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-new-header">--- 1572,11 ---</span>
  }
  
  void JIT_OPERATION operationPutByValWithThis(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedThis, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier property = JSValue::decode(encodedSubscript).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1520,11 ***</span>
  }
  
  void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-new-header">--- 1594,11 ---</span>
  }
  
  void JIT_OPERATION operationDefineDataProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1532,11 ***</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = property-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
<span class="line-new-header">--- 1606,11 ---</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertyString(ExecState* exec, JSObject* base, JSString* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = property-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, void());
      scope.release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1544,18 ***</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">!     defineDataProperty(exec, vm, base, Identifier::fromUid(&amp;vm, property), JSValue::decode(encodedValue), attributes);</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);
  }
  
  ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)
  {
<span class="line-new-header">--- 1618,18 ---</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineDataProperty(exec, vm, base, Identifier::fromUid(vm, property), JSValue::decode(encodedValue), attributes);</span>
  }
  
  void JIT_OPERATION operationDefineDataPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, EncodedJSValue encodedValue, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      defineDataProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), JSValue::decode(encodedValue), attributes);
  }
  
  ALWAYS_INLINE static void defineAccessorProperty(ExecState* exec, VM&amp; vm, JSObject* base, const Identifier&amp; propertyName, JSObject* getter, JSObject* setter, int32_t attributes)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,63 ***</span>
  }
  
  void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
  }
  
  void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = property-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, void());
      defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
  }
  
  void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, Identifier::fromUid(&amp;vm, property), getter, setter, attributes);</span>
  }
  
  void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);
  }
  
  char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));
  }
  
  char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
<span class="line-modified">!     return bitwise_cast&lt;char*&gt;(JSArray::create(*vm, arrayStructure));</span>
  }
  
  char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
          return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
  
<span class="line-new-header">--- 1642,63 ---</span>
  }
  
  void JIT_OPERATION operationDefineAccessorProperty(ExecState* exec, JSObject* base, EncodedJSValue encodedProperty, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = JSValue::decode(encodedProperty).toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, void());
      defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
  }
  
  void JIT_OPERATION operationDefineAccessorPropertyString(ExecState* exec, JSObject* base, JSString* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Identifier propertyName = property-&gt;toIdentifier(exec);
      RETURN_IF_EXCEPTION(scope, void());
      defineAccessorProperty(exec, vm, base, propertyName, getter, setter, attributes);
  }
  
  void JIT_OPERATION operationDefineAccessorPropertyStringIdent(ExecState* exec, JSObject* base, UniquedStringImpl* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     defineAccessorProperty(exec, vm, base, Identifier::fromUid(vm, property), getter, setter, attributes);</span>
  }
  
  void JIT_OPERATION operationDefineAccessorPropertySymbol(ExecState* exec, JSObject* base, Symbol* property, JSObject* getter, JSObject* setter, int32_t attributes)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      defineAccessorProperty(exec, vm, base, Identifier::fromUid(property-&gt;privateName()), getter, setter, attributes);
  }
  
  char* JIT_OPERATION operationNewArray(ExecState* exec, Structure* arrayStructure, void* buffer, size_t size)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      return bitwise_cast&lt;char*&gt;(constructArray(exec, arrayStructure, static_cast&lt;JSValue*&gt;(buffer), size));
  }
  
  char* JIT_OPERATION operationNewEmptyArray(ExecState* exec, Structure* arrayStructure)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
<span class="line-modified">!     return bitwise_cast&lt;char*&gt;(JSArray::create(vm, arrayStructure));</span>
  }
  
  char* JIT_OPERATION operationNewArrayWithSize(ExecState* exec, Structure* arrayStructure, int32_t size, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
          return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1637,11 ***</span>
  }
  
  char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
          return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
  
<span class="line-new-header">--- 1711,11 ---</span>
  }
  
  char* JIT_OPERATION operationNewArrayWithSizeAndHint(ExecState* exec, Structure* arrayStructure, int32_t size, int32_t vectorLengthHint, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(size &lt; 0))
          return bitwise_cast&lt;char*&gt;(throwException(exec, scope, createRangeError(exec, &quot;Array size is not a small enough positive integer.&quot;_s)));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1656,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      ASSERT(!arrayStructure-&gt;outOfLineCapacity());
      auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
      ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
      auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
      ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
<span class="line-new-header">--- 1730,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationNewArrayBuffer(ExecState* exec, Structure* arrayStructure, JSCell* immutableButterflyCell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      ASSERT(!arrayStructure-&gt;outOfLineCapacity());
      auto* immutableButterfly = jsCast&lt;JSImmutableButterfly*&gt;(immutableButterflyCell);
      ASSERT(arrayStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode() || hasAnyArrayStorage(arrayStructure-&gt;indexingMode()));
      auto* result = CommonSlowPaths::allocateNewArrayBuffer(vm, arrayStructure, immutableButterfly);
      ASSERT(result-&gt;indexingMode() == result-&gt;structure(vm)-&gt;indexingMode());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1676,11 ***</span>
  
  char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1750,11 ---</span>
  
  char* JIT_OPERATION operationNewInt8ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewInt16ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1690,11 ***</span>
  
  char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1764,11 ---</span>
  
  char* JIT_OPERATION operationNewInt16ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewInt32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1704,11 ***</span>
  
  char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1778,11 ---</span>
  
  char* JIT_OPERATION operationNewInt32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSInt32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint8ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1718,11 ***</span>
  
  char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1792,11 ---</span>
  
  char* JIT_OPERATION operationNewUint8ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1732,11 ***</span>
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1806,11 ---</span>
  
  char* JIT_OPERATION operationNewUint8ClampedArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint8ClampedArray&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint16ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1746,11 ***</span>
  
  char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1820,11 ---</span>
  
  char* JIT_OPERATION operationNewUint16ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint16Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewUint32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1760,11 ***</span>
  
  char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1834,11 ---</span>
  
  char* JIT_OPERATION operationNewUint32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSUint32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewFloat32ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,11 ***</span>
  
  char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
<span class="line-new-header">--- 1848,11 ---</span>
  
  char* JIT_OPERATION operationNewFloat32ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat32Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  char* JIT_OPERATION operationNewFloat64ArrayWithSize(
      ExecState* exec, Structure* structure, int32_t length, char* vector)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1788,27 ***</span>
  
  char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)
  {
      JSValue initialValue = JSValue::decode(initialValueEncoded);
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
  }
  
  JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer target(&amp;vm, exec);</span>
      DirectArguments* result = DirectArguments::create(
          vm, structure, length, std::max(length, minCapacity));
      // The caller will store to this object without barriers. Most likely, at this point, this is
      // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
      // since the GC should be allowed to do crazy (like pretenuring, for example).
<span class="line-new-header">--- 1862,27 ---</span>
  
  char* JIT_OPERATION operationNewFloat64ArrayWithOneArgument(
      ExecState* exec, Structure* structure, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return reinterpret_cast&lt;char*&gt;(constructGenericTypedArrayViewWithArguments&lt;JSFloat64Array&gt;(exec, structure, encodedValue, 0, WTF::nullopt));
  }
  
  JSCell* JIT_OPERATION operationCreateActivationDirect(ExecState* exec, Structure* structure, JSScope* scope, SymbolTable* table, EncodedJSValue initialValueEncoded)
  {
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue initialValue = JSValue::decode(initialValueEncoded);
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
      return JSLexicalEnvironment::create(vm, structure, scope, table, initialValue);
  }
  
  JSCell* JIT_OPERATION operationCreateDirectArguments(ExecState* exec, Structure* structure, uint32_t length, uint32_t minCapacity)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      DirectArguments* result = DirectArguments::create(
          vm, structure, length, std::max(length, minCapacity));
      // The caller will store to this object without barriers. Most likely, at this point, this is
      // still a young object and so no barriers are needed. But it&#39;s good to be careful anyway,
      // since the GC should be allowed to do crazy (like pretenuring, for example).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1817,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer target(&amp;vm, exec);</span>
  
      // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
      // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
  
<span class="line-new-header">--- 1891,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationCreateScopedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee, JSLexicalEnvironment* scope)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      // We could pass the ScopedArgumentsTable* as an argument. We currently don&#39;t because I
      // didn&#39;t feel like changing the max number of arguments for a slow path call from 6 to 7.
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1830,19 ***</span>
  }
  
  JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer target(&amp;vm, exec);</span>
      return ClonedArguments::createByCopyingFrom(
          exec, structure, argumentStart, length, callee);
  }
  
  JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer target(&amp;vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
<span class="line-new-header">--- 1904,19 ---</span>
  }
  
  JSCell* JIT_OPERATION operationCreateClonedArguments(ExecState* exec, Structure* structure, Register* argumentStart, uint32_t length, JSFunction* callee)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return ClonedArguments::createByCopyingFrom(
          exec, structure, argumentStart, length, callee);
  }
  
  JSCell* JIT_OPERATION operationCreateDirectArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1867,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer target(&amp;vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
<span class="line-new-header">--- 1941,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationCreateClonedArgumentsDuringExit(ExecState* exec, InlineCallFrame* inlineCallFrame, JSFunction* callee, uint32_t argumentCount)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      DeferGCForAWhile deferGC(vm.heap);
  
      CodeBlock* codeBlock;
      if (inlineCallFrame)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1893,11 ***</span>
      return result;
  }
  
  JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
      Structure* structure = globalObject-&gt;restParameterStructure();
      static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
<span class="line-new-header">--- 1967,11 ---</span>
      return result;
  }
  
  JSCell* JIT_OPERATION operationCreateRest(ExecState* exec, Register* argumentStart, unsigned numberOfParamsToSkip, unsigned arraySize)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
  
      JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();
      Structure* structure = globalObject-&gt;restParameterStructure();
      static_assert(sizeof(Register) == sizeof(JSValue), &quot;This is a strong assumption here.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1906,11 ***</span>
  }
  
  size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
<span class="line-new-header">--- 1980,11 ---</span>
  }
  
  size_t JIT_OPERATION operationObjectIsObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1920,11 ***</span>
  }
  
  size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
<span class="line-new-header">--- 1994,11 ---</span>
  }
  
  size_t JIT_OPERATION operationObjectIsFunction(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1934,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return vm.smallStrings.undefinedString();
<span class="line-new-header">--- 2008,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationTypeOfObject(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return vm.smallStrings.undefinedString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1948,11 ***</span>
  }
  
  int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
<span class="line-new-header">--- 2022,11 ---</span>
  }
  
  int32_t JIT_OPERATION operationTypeOfObjectAsTypeofType(ExecState* exec, JSGlobalObject* globalObject, JSCell* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, object));
  
      if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
          return static_cast&lt;int32_t&gt;(TypeofType::Undefined);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1962,48 ***</span>
  }
  
  char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
  }
  
  char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
  }
  
  char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
  }
  
  char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
  }
  
  char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
<span class="line-new-header">--- 2036,48 ---</span>
  }
  
  char* JIT_OPERATION operationAllocateSimplePropertyStorageWithInitialCapacity(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, initialOutOfLineCapacity, false, 0));
  }
  
  char* JIT_OPERATION operationAllocateSimplePropertyStorage(ExecState* exec, size_t newSize)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          Butterfly::createUninitialized(vm, 0, 0, newSize, false, 0));
  }
  
  char* JIT_OPERATION operationAllocateComplexPropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity));
  }
  
  char* JIT_OPERATION operationAllocateComplexPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(
          object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize));
  }
  
  char* JIT_OPERATION operationEnsureInt32(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableInt32(vm).data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2012,11 ***</span>
  }
  
  char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
<span class="line-new-header">--- 2086,11 ---</span>
  }
  
  char* JIT_OPERATION operationEnsureDouble(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableDouble(vm).data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2025,11 ***</span>
  }
  
  char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
<span class="line-new-header">--- 2099,11 ---</span>
  }
  
  char* JIT_OPERATION operationEnsureContiguous(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;tryMakeWritableContiguous(vm).data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,66 ***</span>
  }
  
  char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* propertyName)</span>
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      if (baseValue.isUndefinedOrNull())
          return JSValue::encode(jsBoolean(false));
  
      JSObject* base = baseValue.toObject(exec);
      if (!base)
          return JSValue::encode(JSValue());
<span class="line-modified">!     return JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, asString(propertyName)-&gt;toIdentifier(exec), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
      if (UNLIKELY(subscript &lt; 0)) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return object-&gt;hasPropertyGeneric(exec, Identifier::from(exec, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
      }
      return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
  }
  
  JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      if (base.isUndefinedOrNull())
<span class="line-modified">!         return JSPropertyNameEnumerator::create(vm);</span>
  
      JSObject* baseObject = base.toObject(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
      RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));
  }
  
  JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-new-header">--- 2112,71 ---</span>
  }
  
  char* JIT_OPERATION operationEnsureArrayStorage(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!cell-&gt;isObject())
          return 0;
  
      auto* result = reinterpret_cast&lt;char*&gt;(asObject(cell)-&gt;ensureArrayStorage(vm));
      ASSERT((!isCopyOnWrite(asObject(cell)-&gt;indexingMode()) &amp;&amp; hasAnyArrayStorage(cell-&gt;indexingMode())) || !result);
      return result;
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationHasGenericProperty(ExecState* exec, EncodedJSValue encodedBaseValue, JSCell* property)</span>
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      JSValue baseValue = JSValue::decode(encodedBaseValue);
      if (baseValue.isUndefinedOrNull())
          return JSValue::encode(jsBoolean(false));
  
      JSObject* base = baseValue.toObject(exec);
<span class="line-added">+     ASSERT(!scope.exception() || !base);</span>
      if (!base)
          return JSValue::encode(JSValue());
<span class="line-modified">!     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty))));</span>
  }
  
  size_t JIT_OPERATION operationHasIndexedPropertyByInt(ExecState* exec, JSCell* baseCell, int32_t subscript, int32_t internalMethodType)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSObject* object = baseCell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
      if (UNLIKELY(subscript &lt; 0)) {
          // Go the slowest way possible because negative indices don&#39;t use indexed storage.
<span class="line-modified">!         return object-&gt;hasPropertyGeneric(exec, Identifier::from(vm, subscript), static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));</span>
      }
      return object-&gt;hasPropertyGeneric(exec, subscript, static_cast&lt;PropertySlot::InternalMethodType&gt;(internalMethodType));
  }
  
  JSCell* JIT_OPERATION operationGetPropertyEnumerator(ExecState* exec, EncodedJSValue encodedBase)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue base = JSValue::decode(encodedBase);
      if (base.isUndefinedOrNull())
<span class="line-modified">!         return vm.emptyPropertyNameEnumerator();</span>
  
      JSObject* baseObject = base.toObject(exec);
      RETURN_IF_EXCEPTION(scope, { });
  
      RELEASE_AND_RETURN(scope, propertyNameEnumerator(exec, baseObject));
  }
  
  JSCell* JIT_OPERATION operationGetPropertyEnumeratorCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSObject* base = cell-&gt;toObject(exec, exec-&gt;lexicalGlobalObject());
      RETURN_IF_EXCEPTION(scope, { });
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2105,36 ***</span>
  }
  
  JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-modified">!     return jsString(exec, Identifier::from(exec, index).string());</span>
  }
  
  JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
      ASSERT(regexp-&gt;isValid());
      return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));
  }
  
  StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return string-&gt;value(exec).impl();
  }
  
  JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      if (argument.isString())
<span class="line-new-header">--- 2184,36 ---</span>
  }
  
  JSCell* JIT_OPERATION operationToIndexString(ExecState* exec, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return jsString(vm, Identifier::from(vm, index).string());</span>
  }
  
  JSCell* JIT_OPERATION operationNewRegexpWithLastIndex(ExecState* exec, JSCell* regexpPtr, EncodedJSValue encodedLastIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
      ASSERT(regexp-&gt;isValid());
      return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp, JSValue::decode(encodedLastIndex));
  }
  
  StringImpl* JIT_OPERATION operationResolveRope(ExecState* exec, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return string-&gt;value(exec).impl();
  }
  
  JSString* JIT_OPERATION operationStringValueOf(ExecState* exec, EncodedJSValue encodedArgument)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue argument = JSValue::decode(encodedArgument);
  
      if (argument.isString())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2148,36 ***</span>
  }
  
  JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     auto string = jsCast&lt;JSString*&gt;(cell)-&gt;value(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-removed">-     return jsSubstring(exec, string, from, span);</span>
  }
  
  JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     auto string = jsCast&lt;JSString*&gt;(cell)-&gt;value(exec);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, nullptr);</span>
      static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">! </span>
<span class="line-removed">-     scope.release();</span>
<span class="line-removed">-     return stringSlice(exec, WTFMove(string), start, end);</span>
  }
  
  JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const String&amp; inputString = string-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-new-header">--- 2227,29 ---</span>
  }
  
  JSCell* JIT_OPERATION operationStringSubstr(ExecState* exec, JSCell* cell, int32_t from, int32_t span)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsSubstring(vm, exec, jsCast&lt;JSString*&gt;(cell), from, span);</span>
  }
  
  JSCell* JIT_OPERATION operationStringSlice(ExecState* exec, JSCell* cell, int32_t start, int32_t end)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     JSString* string = asString(cell);</span>
      static_assert(static_cast&lt;uint64_t&gt;(JSString::MaxLength) &lt;= static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()), &quot;&quot;);
<span class="line-modified">!     return stringSlice(exec, vm, string, string-&gt;length(), start, end);</span>
  }
  
  JSString* JIT_OPERATION operationToLowerCase(ExecState* exec, JSString* string, uint32_t failingIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const String&amp; inputString = string-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2185,17 ***</span>
          return vm.smallStrings.emptyString();
  
      String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == inputString.impl())
          return string;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(exec, lowercasedString));</span>
  }
  
  char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
<span class="line-new-header">--- 2257,17 ---</span>
          return vm.smallStrings.emptyString();
  
      String lowercasedString = inputString.is8Bit() ? inputString.convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(failingIndex) : inputString.convertToLowercaseWithoutLocale();
      if (lowercasedString.impl() == inputString.impl())
          return string;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, jsString(vm, lowercasedString));</span>
  }
  
  char* JIT_OPERATION operationInt32ToString(ExecState* exec, int32_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2206,11 ***</span>
  }
  
  char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
<span class="line-new-header">--- 2278,11 ---</span>
  }
  
  char* JIT_OPERATION operationInt52ToString(ExecState* exec, int64_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2221,11 ***</span>
  }
  
  char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
<span class="line-new-header">--- 2293,11 ---</span>
  }
  
  char* JIT_OPERATION operationDoubleToString(ExecState* exec, double value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (radix &lt; 2 || radix &gt; 36) {
          throwVMError(exec, scope, createRangeError(exec, &quot;toString() radix argument must be between 2 and 36&quot;_s));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2236,51 ***</span>
  }
  
  char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
  char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
  char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
  JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     return jsSingleCharacterString(exec, static_cast&lt;UChar&gt;(character));</span>
  }
  
  Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return Symbol::create(vm);
  }
  
  Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String string = description-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
  
<span class="line-new-header">--- 2308,51 ---</span>
  }
  
  char* JIT_OPERATION operationInt32ToStringWithValidRadix(ExecState* exec, int32_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int32ToString(vm, value, radix));
  }
  
  char* JIT_OPERATION operationInt52ToStringWithValidRadix(ExecState* exec, int64_t value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(int52ToString(vm, value, radix));
  }
  
  char* JIT_OPERATION operationDoubleToStringWithValidRadix(ExecState* exec, double value, int32_t radix)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return reinterpret_cast&lt;char*&gt;(numberToString(vm, value, radix));
  }
  
  JSString* JIT_OPERATION operationSingleCharacterString(ExecState* exec, int32_t character)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     return jsSingleCharacterString(vm, static_cast&lt;UChar&gt;(character));</span>
  }
  
  Symbol* JIT_OPERATION operationNewSymbol(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return Symbol::create(vm);
  }
  
  Symbol* JIT_OPERATION operationNewSymbolWithDescription(ExecState* exec, JSString* description)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      String string = description-&gt;value(exec);
      RETURN_IF_EXCEPTION(scope, nullptr);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2288,67 ***</span>
  }
  
  JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return StringObject::create(vm, structure, string);
  }
  
  JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return JSValue(cell).toString(exec);
  }
  
  JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return JSValue::decode(value).toString(exec);
  }
  
  JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return stringConstructor(exec, cell);
  }
  
  JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return stringConstructor(exec, JSValue::decode(value));
  }
  
  JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return jsString(exec, left, right);
  }
  
  JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return jsString(exec, a, b, c);
  }
  
  JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      JSString* str1 = JSValue::decode(a).toString(exec);
<span class="line-new-header">--- 2360,67 ---</span>
  }
  
  JSCell* JIT_OPERATION operationNewStringObject(ExecState* exec, JSString* string, Structure* structure)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return StringObject::create(vm, structure, string);
  }
  
  JSString* JIT_OPERATION operationToStringOnCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return JSValue(cell).toString(exec);
  }
  
  JSString* JIT_OPERATION operationToString(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return JSValue::decode(value).toString(exec);
  }
  
  JSString* JIT_OPERATION operationCallStringConstructorOnCell(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return stringConstructor(exec, cell);
  }
  
  JSString* JIT_OPERATION operationCallStringConstructor(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return stringConstructor(exec, JSValue::decode(value));
  }
  
  JSString* JIT_OPERATION operationMakeRope2(ExecState* exec, JSString* left, JSString* right)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return jsString(exec, left, right);
  }
  
  JSString* JIT_OPERATION operationMakeRope3(ExecState* exec, JSString* a, JSString* b, JSString* c)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return jsString(exec, a, b, c);
  }
  
  JSString* JIT_OPERATION operationStrCat2(ExecState* exec, EncodedJSValue a, EncodedJSValue b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      JSString* str1 = JSValue::decode(a).toString(exec);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2360,11 ***</span>
  }
  
  JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      ASSERT(!JSValue::decode(c).isSymbol());
<span class="line-new-header">--- 2432,11 ---</span>
  }
  
  JSString* JIT_OPERATION operationStrCat3(ExecState* exec, EncodedJSValue a, EncodedJSValue b, EncodedJSValue c)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!JSValue::decode(a).isSymbol());
      ASSERT(!JSValue::decode(b).isSymbol());
      ASSERT(!JSValue::decode(c).isSymbol());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2380,12 ***</span>
  
  char* JIT_OPERATION operationFindSwitchImmTargetForDouble(
      ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
<span class="line-removed">- </span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
      JSValue value = JSValue::decode(encodedValue);
      ASSERT(value.isDouble());
      double asDouble = value.asDouble();
<span class="line-new-header">--- 2452,11 ---</span>
  
  char* JIT_OPERATION operationFindSwitchImmTargetForDouble(
      ExecState* exec, EncodedJSValue encodedValue, size_t tableIndex)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
      SimpleJumpTable&amp; table = codeBlock-&gt;switchJumpTable(tableIndex);
      JSValue value = JSValue::decode(encodedValue);
      ASSERT(value.isDouble());
      double asDouble = value.asDouble();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2396,21 ***</span>
  }
  
  char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(string-&gt;value(exec).impl()).executableAddress&lt;char*&gt;();</span>
  }
  
  int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(string-&gt;value(exec).impl(), std::numeric_limits&lt;int32_t&gt;::min());</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &lt; 0;
<span class="line-new-header">--- 2467,31 ---</span>
  }
  
  char* JIT_OPERATION operationSwitchString(ExecState* exec, size_t tableIndex, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
<span class="line-added">+ </span>
<span class="line-added">+     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
<span class="line-modified">!     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).ctiForValue(strImpl).executableAddress&lt;char*&gt;();</span>
  }
  
  int32_t JIT_OPERATION operationSwitchStringAndGetBranchOffset(ExecState* exec, size_t tableIndex, JSString* string)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     StringImpl* strImpl = string-&gt;value(exec).impl();</span>
  
<span class="line-modified">!     RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return exec-&gt;codeBlock()-&gt;stringSwitchJumpTable(tableIndex).offsetForValue(strImpl, std::numeric_limits&lt;int32_t&gt;::min());</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringImplLess(StringImpl* a, StringImpl* b)
  {
      return codePointCompare(a, b) &lt; 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2432,68 ***</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
  }
  
  void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
  }
  
  void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      throwStackOverflowError(exec, scope);
  }
  
  int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
      return sizeOfVarargs(exec, arguments, firstVarArgOffset);
  }
  
  int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue key = JSValue::decode(encodedKey);
      Identifier propertyName = key.toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-new-header">--- 2513,68 ---</span>
  }
  
  uintptr_t JIT_OPERATION operationCompareStringLess(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringLessEq(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return !codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringGreater(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return codePointCompareLessThan(asString(b)-&gt;value(exec), asString(a)-&gt;value(exec));
  }
  
  uintptr_t JIT_OPERATION operationCompareStringGreaterEq(ExecState* exec, JSString* a, JSString* b)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return !codePointCompareLessThan(asString(a)-&gt;value(exec), asString(b)-&gt;value(exec));
  }
  
  void JIT_OPERATION operationNotifyWrite(ExecState* exec, WatchpointSet* set)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      set-&gt;touch(vm, &quot;Executed NotifyWrite&quot;);
  }
  
  void JIT_OPERATION operationThrowStackOverflowForVarargs(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      throwStackOverflowError(exec, scope);
  }
  
  int32_t JIT_OPERATION operationSizeOfVarargs(ExecState* exec, EncodedJSValue encodedArguments, uint32_t firstVarArgOffset)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
      return sizeOfVarargs(exec, arguments, firstVarArgOffset);
  }
  
  int32_t JIT_OPERATION operationHasOwnProperty(ExecState* exec, JSObject* thisObject, EncodedJSValue encodedKey)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue key = JSValue::decode(encodedKey);
      Identifier propertyName = key.toPropertyKey(exec);
      RETURN_IF_EXCEPTION(scope, false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2509,18 ***</span>
  }
  
  int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return NumberConstructor::isIntegerImpl(JSValue::decode(value));
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
<span class="line-new-header">--- 2590,18 ---</span>
  }
  
  int32_t JIT_OPERATION operationNumberIsInteger(ExecState* exec, EncodedJSValue value)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return NumberConstructor::isIntegerImpl(JSValue::decode(value));
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfString(ExecState* exec, Butterfly* butterfly, JSString* searchElement, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2528,42 ***</span>
          if (!value || !value.isString())
              continue;
          auto* string = asString(value);
          if (string == searchElement)
              return index;
<span class="line-modified">!         if (string-&gt;equal(exec, searchElement))</span>
              return index;
          RETURN_IF_EXCEPTION(scope, { });
      }
      return -1;
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
          JSValue value = data[index].get();
          if (!value)
              continue;
<span class="line-modified">!         if (JSValue::strictEqual(exec, searchElement, value))</span>
<span class="line-removed">-             return index;</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      return -1;
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      if (!searchElement.isNumber())
          return -1;
<span class="line-new-header">--- 2609,45 ---</span>
          if (!value || !value.isString())
              continue;
          auto* string = asString(value);
          if (string == searchElement)
              return index;
<span class="line-modified">!         if (string-&gt;equal(exec, searchElement)) {</span>
<span class="line-added">+             scope.assertNoException();</span>
              return index;
<span class="line-added">+         }</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      return -1;
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfValueInt32OrContiguous(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      int32_t length = butterfly-&gt;publicLength();
      auto data = butterfly-&gt;contiguous().data();
      for (; index &lt; length; ++index) {
          JSValue value = data[index].get();
          if (!value)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
          RETURN_IF_EXCEPTION(scope, { });
<span class="line-added">+         if (isEqual)</span>
<span class="line-added">+             return index;</span>
      }
      return -1;
  }
  
  int32_t JIT_OPERATION operationArrayIndexOfValueDouble(ExecState* exec, Butterfly* butterfly, EncodedJSValue encodedValue, int32_t index)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      JSValue searchElement = JSValue::decode(encodedValue);
  
      if (!searchElement.isNumber())
          return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2580,11 ***</span>
  }
  
  void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
      loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);
  
      for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)
<span class="line-new-header">--- 2664,11 ---</span>
  }
  
  void JIT_OPERATION operationLoadVarargs(ExecState* exec, int32_t firstElementDest, EncodedJSValue encodedArguments, uint32_t offset, uint32_t length, uint32_t mandatoryMinimum)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue arguments = JSValue::decode(encodedArguments);
  
      loadVarargs(exec, VirtualRegister(firstElementDest), arguments, offset, length);
  
      for (uint32_t i = length; i &lt; mandatoryMinimum; ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2603,18 ***</span>
  }
  #endif
  
  JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      return JSC::stringFromCharCode(exec, op1);
  }
  
  EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      JSValue charValue = JSValue::decode(encodedValue);
      int32_t chInt = charValue.toUInt32(exec);
      return JSValue::encode(JSC::stringFromCharCode(exec, chInt));
  }
<span class="line-new-header">--- 2687,18 ---</span>
  }
  #endif
  
  JSCell* JIT_OPERATION operationStringFromCharCode(ExecState* exec, int32_t op1)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      return JSC::stringFromCharCode(exec, op1);
  }
  
  EncodedJSValue JIT_OPERATION operationStringFromCharCodeUntyped(ExecState* exec, EncodedJSValue encodedValue)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
      JSValue charValue = JSValue::decode(encodedValue);
      int32_t chInt = charValue.toUInt32(exec);
      return JSValue::encode(JSC::stringFromCharCode(exec, chInt));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2633,11 ***</span>
  }
  
  char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!butterfly
          &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
          IndexingHeader header;
          header.setVectorLength(length);
<span class="line-new-header">--- 2717,11 ---</span>
  }
  
  char* JIT_OPERATION operationNewRawObject(ExecState* exec, Structure* structure, int32_t length, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!butterfly
          &amp;&amp; (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType()))) {
          IndexingHeader header;
          header.setVectorLength(length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2655,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      if (!butterfly) {
          butterfly = Butterfly::create(
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
      }
<span class="line-new-header">--- 2739,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationNewObjectWithButterfly(ExecState* exec, Structure* structure, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      if (!butterfly) {
          butterfly = Butterfly::create(
              vm, nullptr, 0, structure-&gt;outOfLineCapacity(), false, IndexingHeader(), 0);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2670,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      IndexingHeader header;
      header.setVectorLength(length);
      header.setPublicLength(0);
      if (butterfly)
<span class="line-new-header">--- 2754,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength(ExecState* exec, Structure* structure, unsigned length, Butterfly* butterfly)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      IndexingHeader header;
      header.setVectorLength(length);
      header.setPublicLength(0);
      if (butterfly)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2692,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
<span class="line-new-header">--- 2776,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationNewArrayWithSpreadSlow(ExecState* exec, void* buffer, uint32_t numItems)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      EncodedJSValue* values = static_cast&lt;EncodedJSValue*&gt;(buffer);
      Checked&lt;unsigned, RecordOverflow&gt; checkedLength = 0;
      for (unsigned i = 0; i &lt; numItems; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2750,11 ***</span>
  }
  
  JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))
          return result;
  
<span class="line-new-header">--- 2834,11 ---</span>
  }
  
  JSCell* operationCreateFixedArray(ExecState* exec, unsigned length)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (JSFixedArray* result = JSFixedArray::tryCreate(vm, vm.fixedArrayStructure.get(), length))
          return result;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2763,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (isJSArray(iterable)) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
<span class="line-new-header">--- 2847,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationSpreadGeneric(ExecState* exec, JSCell* iterable)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (isJSArray(iterable)) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2798,11 ***</span>
  }
  
  JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      ASSERT(isJSArray(cell));
      JSArray* array = jsCast&lt;JSArray*&gt;(cell);
      ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
  
<span class="line-new-header">--- 2882,11 ---</span>
  }
  
  JSCell* JIT_OPERATION operationSpreadFastArray(ExecState* exec, JSCell* cell)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      ASSERT(isJSArray(cell));
      JSArray* array = jsCast&lt;JSArray*&gt;(cell);
      ASSERT(array-&gt;isIteratorProtocolFastAndNonObservable());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2810,40 ***</span>
  }
  
  void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
  }
  
  EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(exec, impl));</span>
      return JSValue::encode(resolvedScope);
  }
  
  JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(exec, impl));</span>
      return resolvedScope;
  }
  
  EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier ident = Identifier::fromUid(exec, impl);</span>
      RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
          if (!found) {
              GetPutInfo getPutInfo(getPutInfoBits);
              if (getPutInfo.resolveMode() == ThrowIfNotFound)
                  throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
<span class="line-new-header">--- 2894,40 ---</span>
  }
  
  void JIT_OPERATION operationProcessTypeProfilerLogDFG(ExecState* exec)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside DFG.&quot;_s);
  }
  
  EncodedJSValue JIT_OPERATION operationResolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, Identifier::fromUid(vm, impl));</span>
      return JSValue::encode(resolvedScope);
  }
  
  JSCell* JIT_OPERATION operationResolveScope(ExecState* exec, JSScope* scope, UniquedStringImpl* impl)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(exec, scope, Identifier::fromUid(vm, impl));</span>
      return resolvedScope;
  }
  
  EncodedJSValue JIT_OPERATION operationGetDynamicVar(ExecState* exec, JSObject* scope, UniquedStringImpl* impl, unsigned getPutInfoBits)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Identifier ident = Identifier::fromUid(vm, impl);</span>
      RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {
          if (!found) {
              GetPutInfo getPutInfo(getPutInfoBits);
              if (getPutInfo.resolveMode() == ThrowIfNotFound)
                  throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2862,17 ***</span>
  
          return slot.getValue(exec, ident);
      })));
  }
  
<span class="line-modified">! void JIT_OPERATION operationPutDynamicVar(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const Identifier&amp; ident = Identifier::fromUid(exec, impl);</span>
      GetPutInfo getPutInfo(getPutInfoBits);
      bool hasProperty = scope-&gt;hasProperty(exec, ident);
      RETURN_IF_EXCEPTION(throwScope, void());
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
<span class="line-new-header">--- 2946,15 ---</span>
  
          return slot.getValue(exec, ident);
      })));
  }
  
<span class="line-modified">! ALWAYS_INLINE static void putDynamicVar(ExecState* exec, VM&amp; vm, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits, bool isStrictMode)</span>
  {
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     const Identifier&amp; ident = Identifier::fromUid(vm, impl);</span>
      GetPutInfo getPutInfo(getPutInfoBits);
      bool hasProperty = scope-&gt;hasProperty(exec, ident);
      RETURN_IF_EXCEPTION(throwScope, void());
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2889,94 ***</span>
      if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
          throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
          return;
      }
  
<span class="line-modified">!     CodeOrigin origin = exec-&gt;codeOrigin();</span>
<span class="line-removed">-     bool strictMode;</span>
<span class="line-removed">-     if (origin.inlineCallFrame)</span>
<span class="line-removed">-         strictMode = origin.inlineCallFrame-&gt;baselineCodeBlock-&gt;isStrictMode();</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         strictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
<span class="line-removed">-     PutPropertySlot slot(scope, strictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));</span>
      throwScope.release();
      scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);
  }
  
  int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
  
      return jsMapHash(exec, vm, JSValue::decode(input));
  }
  
  JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
      if (!bucket)
          return vm.sentinelMapBucket();
      return *bucket;
  }
  
  JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
      if (!bucket)
          return vm.sentinelSetBucket();
      return *bucket;
  }
  
  JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);
      if (!bucket)
          return vm.sentinelSetBucket();
      return bucket;
  }
  
  JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);
      if (!bucket)
          return vm.sentinelMapBucket();
      return bucket;
  }
  
  void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
  }
  
  void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
  }
  
  EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));
  }
  
  EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);
      if (thisValue.isUndefinedOrNull())
          return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
<span class="line-new-header">--- 2971,104 ---</span>
      if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
          throwException(exec, throwScope, createUndefinedVariableError(exec, ident));
          return;
      }
  
<span class="line-modified">!     PutPropertySlot slot(scope, isStrictMode, PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));</span>
      throwScope.release();
      scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, JSValue::decode(value), slot);
  }
  
<span class="line-added">+ void JIT_OPERATION operationPutDynamicVarStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     constexpr bool isStrictMode = true;</span>
<span class="line-added">+     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT_OPERATION operationPutDynamicVarNonStrict(ExecState* exec, JSObject* scope, EncodedJSValue value, UniquedStringImpl* impl, unsigned getPutInfoBits)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-added">+     constexpr bool isStrictMode = false;</span>
<span class="line-added">+     return putDynamicVar(exec, vm, scope, value, impl, getPutInfoBits, isStrictMode);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  int32_t JIT_OPERATION operationMapHash(ExecState* exec, EncodedJSValue input)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      return jsMapHash(exec, vm, JSValue::decode(input));
  }
  
  JSCell* JIT_OPERATION operationJSMapFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSMap::BucketType** bucket = jsCast&lt;JSMap*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
      if (!bucket)
          return vm.sentinelMapBucket();
      return *bucket;
  }
  
  JSCell* JIT_OPERATION operationJSSetFindBucket(ExecState* exec, JSCell* map, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSSet::BucketType** bucket = jsCast&lt;JSSet*&gt;(map)-&gt;findBucket(exec, JSValue::decode(key), hash);
      if (!bucket)
          return vm.sentinelSetBucket();
      return *bucket;
  }
  
  JSCell* JIT_OPERATION operationSetAdd(ExecState* exec, JSCell* set, EncodedJSValue key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto* bucket = jsCast&lt;JSSet*&gt;(set)-&gt;addNormalized(exec, JSValue::decode(key), JSValue(), hash);
      if (!bucket)
          return vm.sentinelSetBucket();
      return bucket;
  }
  
  JSCell* JIT_OPERATION operationMapSet(ExecState* exec, JSCell* map, EncodedJSValue key, EncodedJSValue value, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto* bucket = jsCast&lt;JSMap*&gt;(map)-&gt;addNormalized(exec, JSValue::decode(key), JSValue::decode(value), hash);
      if (!bucket)
          return vm.sentinelMapBucket();
      return bucket;
  }
  
  void JIT_OPERATION operationWeakSetAdd(ExecState* exec, JSCell* set, JSCell* key, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      jsCast&lt;JSWeakSet*&gt;(set)-&gt;add(vm, asObject(key), JSValue(), hash);
  }
  
  void JIT_OPERATION operationWeakMapSet(ExecState* exec, JSCell* map, JSCell* key, EncodedJSValue value, int32_t hash)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      jsCast&lt;JSWeakMap*&gt;(map)-&gt;add(vm, asObject(key), JSValue::decode(value), hash);
  }
  
  EncodedJSValue JIT_OPERATION operationGetPrototypeOfObject(ExecState* exec, JSObject* thisObject)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      return JSValue::encode(thisObject-&gt;getPrototype(vm, exec));
  }
  
  EncodedJSValue JIT_OPERATION operationGetPrototypeOf(ExecState* exec, EncodedJSValue encodedValue)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue thisValue = JSValue::decode(encodedValue).toThis(exec, StrictMode);
      if (thisValue.isUndefinedOrNull())
          return throwVMError(exec, scope, createNotAnObjectError(exec, thisValue));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2994,29 ***</span>
  }
  
  void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      scope.throwException(exec, JSValue::decode(valueToThrow));
  }
  
  void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(&amp;vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      String errorMessage = message-&gt;value(exec);
      scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));
  }
  
  extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
  {
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
      // really be profitable.
<span class="line-modified">!     DeferGCForAWhile deferGC(codeBlock-&gt;vm()-&gt;heap);</span>
  
      sanitizeStackForVM(codeBlock-&gt;vm());
  
      if (Options::verboseOSR())
          dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);
<span class="line-new-header">--- 3086,29 ---</span>
  }
  
  void JIT_OPERATION operationThrowDFG(ExecState* exec, EncodedJSValue valueToThrow)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      scope.throwException(exec, JSValue::decode(valueToThrow));
  }
  
  void JIT_OPERATION operationThrowStaticError(ExecState* exec, JSString* message, uint32_t errorType)
  {
      VM&amp; vm = exec-&gt;vm();
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      String errorMessage = message-&gt;value(exec);
      scope.throwException(exec, createError(exec, static_cast&lt;ErrorType&gt;(errorType), errorMessage));
  }
  
  extern &quot;C&quot; void JIT_OPERATION triggerReoptimizationNow(CodeBlock* codeBlock, CodeBlock* optimizedCodeBlock, OSRExitBase* exit)
  {
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
      // really be profitable.
<span class="line-modified">!     DeferGCForAWhile deferGC(codeBlock-&gt;vm().heap);</span>
  
      sanitizeStackForVM(codeBlock-&gt;vm());
  
      if (Options::verboseOSR())
          dataLog(*codeBlock, &quot;: Entered reoptimize\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3039,11 ***</span>
      // to check our logic.
      ASSERT(codeBlock-&gt;hasOptimizedReplacement());
      ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
  
      bool didTryToEnterIntoInlinedLoops = false;
<span class="line-modified">!     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame; inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame) {</span>
          if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
              didTryToEnterIntoInlinedLoops = true;
              break;
          }
      }
<span class="line-new-header">--- 3131,11 ---</span>
      // to check our logic.
      ASSERT(codeBlock-&gt;hasOptimizedReplacement());
      ASSERT(JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
  
      bool didTryToEnterIntoInlinedLoops = false;
<span class="line-modified">!     for (InlineCallFrame* inlineCallFrame = exit-&gt;m_codeOrigin.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {</span>
          if (inlineCallFrame-&gt;baselineCodeBlock-&gt;ownerExecutable()-&gt;didTryToEnterInLoop()) {
              didTryToEnterIntoInlinedLoops = true;
              break;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3085,11 ***</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! static void triggerFTLReplacementCompile(VM* vm, CodeBlock* codeBlock, JITCode* jitCode)</span>
  {
      if (codeBlock-&gt;codeType() == GlobalCode) {
          // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
          // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
          // later want to run faster code. Deferring for warm-up seems safest.
<span class="line-new-header">--- 3177,11 ---</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! static void triggerFTLReplacementCompile(VM&amp; vm, CodeBlock* codeBlock, JITCode* jitCode)</span>
  {
      if (codeBlock-&gt;codeType() == GlobalCode) {
          // Global code runs once, so we don&#39;t want to do anything. We don&#39;t want to defer indefinitely,
          // since this may have been spuriously called from tier-up initiated in a loop, and that loop may
          // later want to run faster code. Deferring for warm-up seems safest.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3098,11 ***</span>
      }
  
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">!             *vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));</span>
      } else
          worklistState = Worklist::NotKnown;
  
      if (worklistState == Worklist::Compiling) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
<span class="line-new-header">--- 3190,11 ---</span>
      }
  
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">!             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLMode));</span>
      } else
          worklistState = Worklist::NotKnown;
  
      if (worklistState == Worklist::Compiling) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;still compiling&quot;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3129,28 ***</span>
      }
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
      // We need to compile the code.
      compile(
<span class="line-modified">!         *vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
          Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
  
      // If we reached here, the counter has not be reset. Do that now.
      jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
          codeBlock, CompilationDeferred);
  }
  
  void JIT_OPERATION triggerTierUpNow(ExecState* exec)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
<span class="line-new-header">--- 3221,28 ---</span>
      }
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLReplacement&quot;, ());
      // We need to compile the code.
      compile(
<span class="line-modified">!         vm, codeBlock-&gt;newReplacement(), codeBlock, FTLMode, UINT_MAX,</span>
          Operands&lt;Optional&lt;JSValue&gt;&gt;(), ToFTLDeferredCompilationCallback::create());
  
      // If we reached here, the counter has not be reset. Do that now.
      jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(
          codeBlock, CompilationDeferred);
  }
  
  void JIT_OPERATION triggerTierUpNow(ExecState* exec)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm.heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3184,18 ***</span>
      }
  }
  
  static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      // Resolve any pending plan for OSR Enter on this function.
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">!             *vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));</span>
      } else
          worklistState = Worklist::NotKnown;
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
<span class="line-new-header">--- 3276,18 ---</span>
      }
  }
  
  static char* tierUpCommon(ExecState* exec, unsigned originBytecodeIndex, bool canOSREnterHere)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      // Resolve any pending plan for OSR Enter on this function.
      Worklist::State worklistState;
      if (Worklist* worklist = existingGlobalFTLWorklistOrNull()) {
          worklistState = worklist-&gt;completeAllReadyPlansForVM(
<span class="line-modified">!             vm, CompilationKey(codeBlock-&gt;baselineVersion(), FTLForOSREntryMode));</span>
      } else
          worklistState = Worklist::NotKnown;
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3294,16 ***</span>
          }
  
          // OSR entry failed. Oh no! This implies that we need to retry. We retry
          // without exponential backoff and we only do this for the entry code block.
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed too many times&quot;));
<span class="line-modified">!         unsigned osrEntryBytecode = entryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;bytecodeIndex();</span>
<span class="line-removed">-         jitCode-&gt;clearOSREntryBlock();</span>
<span class="line-removed">-         jitCode-&gt;osrEntryRetry = 0;</span>
<span class="line-removed">-         jitCode-&gt;tierUpEntryTriggers.set(osrEntryBytecode, JITCode::TriggerReason::DontTrigger);</span>
<span class="line-removed">-         jitCode-&gt;setOptimizationThresholdBasedOnCompilationResult(</span>
<span class="line-removed">-             codeBlock, CompilationDeferred);</span>
          return nullptr;
      }
  
      // It&#39;s time to try to compile code for OSR entry.
  
<span class="line-new-header">--- 3386,11 ---</span>
          }
  
          // OSR entry failed. Oh no! This implies that we need to retry. We retry
          // without exponential backoff and we only do this for the entry code block.
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayFTLCompile&quot;, (&quot;OSR entry failed too many times&quot;));
<span class="line-modified">!         jitCode-&gt;clearOSREntryBlockAndResetThresholds(codeBlock);</span>
          return nullptr;
      }
  
      // It&#39;s time to try to compile code for OSR entry.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3376,11 ***</span>
          exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);
      CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
      CompilationResult forEntryResult = compile(
<span class="line-modified">!         *vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,</span>
          mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
  
      if (jitCode-&gt;neverExecutedEntry)
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
<span class="line-new-header">--- 3463,11 ---</span>
          exec, codeBlock, CodeOrigin(originBytecodeIndex), streamIndex, mustHandleValues);
      CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;triggerFTLOSR&quot;, ());
      CompilationResult forEntryResult = compile(
<span class="line-modified">!         vm, replacementCodeBlock, codeBlock, FTLForOSREntryMode, originBytecodeIndex,</span>
          mustHandleValues, ToFTLForOSREntryDeferredCompilationCallback::create(triggerAddress));
  
      if (jitCode-&gt;neverExecutedEntry)
          triggerFTLReplacementCompile(vm, codeBlock, jitCode);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3405,18 ***</span>
      return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));
  }
  
  void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
<span class="line-new-header">--- 3492,18 ---</span>
      return retagCodePtr&lt;char*&gt;(address, JSEntryPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));
  }
  
  void JIT_OPERATION triggerTierUpNowInLoop(ExecState* exec, unsigned bytecodeIndex)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm.heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL trigger tier up now in loop: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3439,24 ***</span>
      }
  }
  
  char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm-&gt;heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITCode::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
<span class="line-removed">-     jitCode-&gt;tierUpEntrySeen.add(bytecodeIndex);</span>
  
      if (Options::verboseOSR()) {
          dataLog(
              *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,
              jitCode-&gt;tierUpCounter, &quot;\n&quot;);
<span class="line-new-header">--- 3526,23 ---</span>
      }
  }
  
  char* JIT_OPERATION triggerOSREntryNow(ExecState* exec, unsigned bytecodeIndex)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      NativeCallFrameTracer tracer(vm, exec);
<span class="line-modified">!     DeferGCForAWhile deferGC(vm.heap);</span>
      CodeBlock* codeBlock = exec-&gt;codeBlock();
  
      sanitizeStackForVM(vm);
  
<span class="line-modified">!     if (codeBlock-&gt;jitType() != JITType::DFGJIT) {</span>
          dataLog(&quot;Unexpected code block in DFG-&gt;FTL tier-up: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;dfg();
  
      if (Options::verboseOSR()) {
          dataLog(
              *codeBlock, &quot;: Entered triggerOSREntryNow with executeCounter = &quot;,
              jitCode-&gt;tierUpCounter, &quot;\n&quot;);
</pre>
<center><a href="DFGObjectAllocationSinkingPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOperations.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>