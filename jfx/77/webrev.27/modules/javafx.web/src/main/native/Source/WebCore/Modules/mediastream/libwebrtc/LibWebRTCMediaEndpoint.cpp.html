<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 34 #include &quot;LibWebRTCProvider.h&quot;
 35 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 36 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 37 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 38 #include &quot;LibWebRTCStatsCollector.h&quot;
 39 #include &quot;LibWebRTCUtils.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;NotImplemented.h&quot;
 42 #include &quot;Performance.h&quot;
 43 #include &quot;PlatformStrategies.h&quot;
 44 #include &quot;RTCDataChannel.h&quot;
 45 #include &quot;RTCDataChannelEvent.h&quot;
 46 #include &quot;RTCOfferOptions.h&quot;
 47 #include &quot;RTCPeerConnection.h&quot;
 48 #include &quot;RTCSessionDescription.h&quot;
 49 #include &quot;RTCStatsReport.h&quot;
 50 #include &quot;RealtimeIncomingAudioSource.h&quot;
 51 #include &quot;RealtimeIncomingVideoSource.h&quot;
 52 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 53 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;
 56 #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;
 57 #include &lt;webrtc/p2p/client/basicportallocator.h&gt;
 58 #include &lt;webrtc/pc/peerconnectionfactory.h&gt;
 59 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 60 #include &lt;wtf/MainThread.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 65     : m_peerConnectionBackend(peerConnection)
 66     , m_peerConnectionFactory(*client.factory())
 67     , m_createSessionDescriptionObserver(*this)
 68     , m_setLocalSessionDescriptionObserver(*this)
 69     , m_setRemoteSessionDescriptionObserver(*this)
 70     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 71 #if !RELEASE_LOG_DISABLED
 72     , m_logger(peerConnection.logger())
 73     , m_logIdentifier(peerConnection.logIdentifier())
 74 #endif
 75 {
 76     ASSERT(isMainThread());
 77     ASSERT(client.factory());
 78 
 79     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 80         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 81 }
 82 
 83 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 84 {
 85     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
 86         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;
 87 
 88     if (!m_backend) {
 89         if (!m_rtcSocketFactory) {
 90             auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
 91             m_rtcSocketFactory = client.createSocketFactory(document.sessionID(), document.userAgent(document.url()));
 92         }
 93         m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
 94         return !!m_backend;
 95     }
 96     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 97     configuration.certificates = oldConfiguration.certificates;
 98     return m_backend-&gt;SetConfiguration(WTFMove(configuration));
 99 }
100 
101 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
102 {
103     switch (sdpType) {
104     case RTCSdpType::Offer:
105         return &quot;offer&quot;;
106     case RTCSdpType::Pranswer:
107         return &quot;pranswer&quot;;
108     case RTCSdpType::Answer:
109         return &quot;answer&quot;;
110     case RTCSdpType::Rollback:
111         return &quot;rollback&quot;;
112     }
113 
114     ASSERT_NOT_REACHED();
115     return &quot;&quot;;
116 }
117 
118 static inline RTCSdpType fromSessionDescriptionType(const webrtc::SessionDescriptionInterface&amp; description)
119 {
120     auto type = description.type();
121     if (type == webrtc::SessionDescriptionInterface::kOffer)
122         return RTCSdpType::Offer;
123     if (type == webrtc::SessionDescriptionInterface::kAnswer)
124         return RTCSdpType::Answer;
125     ASSERT(type == webrtc::SessionDescriptionInterface::kPrAnswer);
126     return RTCSdpType::Pranswer;
127 }
128 
129 static inline RefPtr&lt;RTCSessionDescription&gt; fromSessionDescription(const webrtc::SessionDescriptionInterface* description)
130 {
131     if (!description)
132         return nullptr;
133 
134     std::string sdp;
135     description-&gt;ToString(&amp;sdp);
136 
137     return RTCSessionDescription::create(fromSessionDescriptionType(*description), fromStdString(sdp));
138 }
139 
140 // FIXME: We might want to create a new object only if the session actually changed for all description getters.
141 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentLocalDescription() const
142 {
143     return m_backend ? fromSessionDescription(m_backend-&gt;current_local_description()) : nullptr;
144 }
145 
146 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentRemoteDescription() const
147 {
148     return m_backend ? fromSessionDescription(m_backend-&gt;current_remote_description()) : nullptr;
149 }
150 
151 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingLocalDescription() const
152 {
153     return m_backend ? fromSessionDescription(m_backend-&gt;pending_local_description()) : nullptr;
154 }
155 
156 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingRemoteDescription() const
157 {
158     return m_backend ? fromSessionDescription(m_backend-&gt;pending_remote_description()) : nullptr;
159 }
160 
161 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::localDescription() const
162 {
163     return m_backend ? fromSessionDescription(m_backend-&gt;local_description()) : nullptr;
164 }
165 
166 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::remoteDescription() const
167 {
168     return m_backend ? fromSessionDescription(m_backend-&gt;remote_description()) : nullptr;
169 }
170 
171 void LibWebRTCMediaEndpoint::doSetLocalDescription(RTCSessionDescription&amp; description)
172 {
173     ASSERT(m_backend);
174 
175     webrtc::SdpParseError error;
176     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
177 
178     if (!sessionDescription) {
179         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { OperationError, fromStdString(error.description) });
180         return;
181     }
182 
183     // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=173783. Remove this test once fixed at LibWebRTC level.
184     if (description.type() == RTCSdpType::Answer &amp;&amp; !m_backend-&gt;pending_remote_description()) {
185         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { InvalidStateError, &quot;Failed to set local answer sdp: no pending remote description.&quot;_s });
186         return;
187     }
188 
189     m_backend-&gt;SetLocalDescription(&amp;m_setLocalSessionDescriptionObserver, sessionDescription.release());
190 }
191 
192 void LibWebRTCMediaEndpoint::doSetRemoteDescription(RTCSessionDescription&amp; description)
193 {
194     ASSERT(m_backend);
195 
196     webrtc::SdpParseError error;
197     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
198     if (!sessionDescription) {
199         m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { SyntaxError, fromStdString(error.description) });
200         return;
201     }
202     m_backend-&gt;SetRemoteDescription(&amp;m_setRemoteSessionDescriptionObserver, sessionDescription.release());
203 
204     startLoggingStats();
205 }
206 
207 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
208 {
209     ASSERT(m_backend);
210 
211     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
212         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];
213         m_localStreams.ensure(mediaStreamId, [&amp;] {
214             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());
215             m_backend-&gt;AddStream(mediaStream);
216             return mediaStream;
217         });
218     }
219 
220     LibWebRTCRtpSenderBackend::Source source;
221     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
222     switch (track.privateTrack().type()) {
223     case RealtimeMediaSource::Type::Audio: {
224         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
225         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
226         source = WTFMove(audioSource);
227         break;
228     }
229     case RealtimeMediaSource::Type::Video: {
230         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
231         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
232         source = WTFMove(videoSource);
233         break;
234     }
235     case RealtimeMediaSource::Type::None:
236         ASSERT_NOT_REACHED();
237         return false;
238     }
239 
240     sender.setSource(WTFMove(source));
241     if (auto rtpSender = sender.rtcSender()) {
242         rtpSender-&gt;SetTrack(rtcTrack.get());
243         return true;
244     }
245 
246     std::vector&lt;std::string&gt; ids;
247     for (auto&amp; id : mediaStreamIds)
248         ids.push_back(id.utf8().data());
249 
250     auto newRTPSender = m_backend-&gt;AddTrack(rtcTrack.get(), WTFMove(ids));
251     if (!newRTPSender.ok())
252         return false;
253     sender.setRTCSender(newRTPSender.MoveValue());
254     return true;
255 }
256 
257 void LibWebRTCMediaEndpoint::removeTrack(LibWebRTCRtpSenderBackend&amp; sender)
258 {
259     ASSERT(m_backend);
260     m_backend-&gt;RemoveTrack(sender.rtcSender());
261     sender.clearSource();
262 }
263 
264 void LibWebRTCMediaEndpoint::doCreateOffer(const RTCOfferOptions&amp; options)
265 {
266     ASSERT(m_backend);
267 
268     m_isInitiator = true;
269     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
270     rtcOptions.ice_restart = options.iceRestart;
271     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
272 
273     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
274         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))
275             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
276         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))
277             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;
278     }
279     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
280 }
281 
282 void LibWebRTCMediaEndpoint::doCreateAnswer()
283 {
284     ASSERT(m_backend);
285 
286     m_isInitiator = false;
287     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
288 }
289 
290 rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
291 {
292     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {
293         ASSERT(isMainThread());
294         if (protectedThis-&gt;isStopped())
295             return nullptr;
296 
297         auto report = RTCStatsReport::create();
298 
299         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());
300 
301         // The promise resolution might fail in which case no backing map will be created.
302         if (!report-&gt;backingMap())
303             return nullptr;
304         return report;
305     });
306 }
307 
308 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
309 {
310     if (m_backend)
311         m_backend-&gt;GetStats(createStatsCollector(WTFMove(promise)));
312 }
313 
314 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
315 {
316     if (m_backend)
317         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver), createStatsCollector(WTFMove(promise)));
318 }
319 
320 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
321 {
322     if (m_backend)
323         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender), createStatsCollector(WTFMove(promise)));
324 }
325 
326 static RTCSignalingState signalingState(webrtc::PeerConnectionInterface::SignalingState state)
327 {
328     switch (state) {
329     case webrtc::PeerConnectionInterface::kStable:
330         return RTCSignalingState::Stable;
331     case webrtc::PeerConnectionInterface::kHaveLocalOffer:
332         return RTCSignalingState::HaveLocalOffer;
333     case webrtc::PeerConnectionInterface::kHaveLocalPrAnswer:
334         return RTCSignalingState::HaveLocalPranswer;
335     case webrtc::PeerConnectionInterface::kHaveRemoteOffer:
336         return RTCSignalingState::HaveRemoteOffer;
337     case webrtc::PeerConnectionInterface::kHaveRemotePrAnswer:
338         return RTCSignalingState::HaveRemotePranswer;
339     case webrtc::PeerConnectionInterface::kClosed:
340         return RTCSignalingState::Stable;
341     }
342 
343     ASSERT_NOT_REACHED();
344     return RTCSignalingState::Stable;
345 }
346 
347 void LibWebRTCMediaEndpoint::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState rtcState)
348 {
349     auto state = signalingState(rtcState);
350     callOnMainThread([protectedThis = makeRef(*this), state] {
351         if (protectedThis-&gt;isStopped())
352             return;
353         protectedThis-&gt;m_peerConnectionBackend.updateSignalingState(state);
354     });
355 }
356 
357 MediaStream&amp; LibWebRTCMediaEndpoint::mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp; rtcStream)
358 {
359     auto label = fromStdString(rtcStream.id());
360     auto mediaStream = m_remoteStreamsById.ensure(label, [label, this]() mutable {
361         auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
362         return MediaStream::create(document, MediaStreamPrivate::create(document.logger(), { }, WTFMove(label)));
363     });
364     return *mediaStream.iterator-&gt;value;
365 }
366 
367 void LibWebRTCMediaEndpoint::addRemoteStream(webrtc::MediaStreamInterface&amp;)
368 {
369 }
370 
371 void LibWebRTCMediaEndpoint::addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; rtcReceiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams)
372 {
373     ASSERT(rtcReceiver);
374     RefPtr&lt;RTCRtpReceiver&gt; receiver;
375     RefPtr&lt;RealtimeMediaSource&gt; remoteSource;
376 
377     auto* rtcTrack = rtcReceiver-&gt;track().get();
378 
379     switch (rtcReceiver-&gt;media_type()) {
380     case cricket::MEDIA_TYPE_DATA:
381         return;
382     case cricket::MEDIA_TYPE_AUDIO: {
383         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack);
384         auto audioReceiver = m_peerConnectionBackend.audioReceiver(fromStdString(rtcTrack-&gt;id()));
385 
386         receiver = WTFMove(audioReceiver.receiver);
387         audioReceiver.source-&gt;setSourceTrack(WTFMove(audioTrack));
388         break;
389     }
390     case cricket::MEDIA_TYPE_VIDEO: {
391         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack);
392         auto videoReceiver = m_peerConnectionBackend.videoReceiver(fromStdString(rtcTrack-&gt;id()));
393 
394         receiver = WTFMove(videoReceiver.receiver);
395         videoReceiver.source-&gt;setSourceTrack(WTFMove(videoTrack));
396         break;
397     }
398     }
399 
400     receiver-&gt;setBackend(makeUnique&lt;LibWebRTCRtpReceiverBackend&gt;(WTFMove(rtcReceiver)));
401     auto&amp; track = receiver-&gt;track();
402     addPendingTrackEvent(receiver.releaseNonNull(), track, rtcStreams, nullptr);
403 }
404 
405 void LibWebRTCMediaEndpoint::addPendingTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp; receiver, MediaStreamTrack&amp; track, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)
406 {
407     Vector&lt;RefPtr&lt;MediaStream&gt;&gt; streams;
408     for (auto&amp; rtcStream : rtcStreams) {
409         auto&amp; mediaStream = mediaStreamFromRTCStream(*rtcStream.get());
410         streams.append(&amp;mediaStream);
411         mediaStream.addTrackFromPlatform(track);
412     }
413     auto streamIds = WTF::map(streams, [](auto&amp; stream) -&gt; String {
414         return stream-&gt;id();
415     });
416     m_remoteStreamsFromRemoteTrack.add(&amp;track, WTFMove(streamIds));
417 
418     m_peerConnectionBackend.addPendingTrackEvent({ WTFMove(receiver), makeRef(track), WTFMove(streams), WTFMove(transceiver) });
419 }
420 
421 static inline void setExistingReceiverSourceTrack(RealtimeMediaSource&amp; existingSource, webrtc::RtpReceiverInterface&amp; rtcReceiver)
422 {
423     switch (rtcReceiver.media_type()) {
424     case cricket::MEDIA_TYPE_AUDIO: {
425         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Audio);
426         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcReceiver.track().get());
427         downcast&lt;RealtimeIncomingAudioSource&gt;(existingSource).setSourceTrack(WTFMove(audioTrack));
428         return;
429     }
430     case cricket::MEDIA_TYPE_VIDEO: {
431         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Video);
432         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcReceiver.track().get());
433         downcast&lt;RealtimeIncomingVideoSource&gt;(existingSource).setSourceTrack(WTFMove(videoTrack));
434         return;
435     }
436     case cricket::MEDIA_TYPE_DATA:
437         ASSERT_NOT_REACHED();
438         return;
439     }
440 }
441 
442 RefPtr&lt;RealtimeMediaSource&gt; LibWebRTCMediaEndpoint::sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp; rtcReceiver)
443 {
444     auto rtcTrack = rtcReceiver.track();
445     switch (rtcReceiver.media_type()) {
446     case cricket::MEDIA_TYPE_DATA:
447         return nullptr;
448     case cricket::MEDIA_TYPE_AUDIO: {
449         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
450         return RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));
451     }
452     case cricket::MEDIA_TYPE_VIDEO: {
453         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
454         return RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));
455     }
456     }
457 
458     RELEASE_ASSERT_NOT_REACHED();
459 }
460 
461 void LibWebRTCMediaEndpoint::collectTransceivers()
462 {
463     if (!m_backend)
464         return;
465 
466     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
467         return;
468 
469     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
470         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
471             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
472         });
473         if (existingTransceiver)
474             continue;
475 
476         auto rtcReceiver = rtcTransceiver-&gt;receiver();
477         auto source = sourceFromNewReceiver(*rtcReceiver);
478         if (!source)
479             return;
480 
481         m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
482     }
483 }
484 
485 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
486 {
487     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
488         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
489     });
490     if (transceiver) {
491         auto rtcReceiver = rtcTransceiver-&gt;receiver();
492         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
493         addPendingTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));
494         return;
495     }
496 
497     auto rtcReceiver = rtcTransceiver-&gt;receiver();
498     auto source = sourceFromNewReceiver(*rtcReceiver);
499     if (!source)
500         return;
501 
502     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
503 
504     addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));
505 }
506 
507 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
508 {
509     // FIXME: Support plan B code path.
510     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
511         return;
512 
513     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
514         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
515         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
516     });
517     if (!transceiver)
518         return;
519 
520     auto&amp; track = transceiver-&gt;receiver().track();
521 
522     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
523         if (auto stream = m_remoteStreamsById.get(id))
524             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
525     }
526 
527     track.source().setMuted(true);
528 }
529 
530 template&lt;typename T&gt;
531 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
532 {
533     auto result = m_backend-&gt;AddTransceiver(WTFMove(trackOrKind), fromRtpTransceiverInit(init));
534     if (!result.ok())
535         return WTF::nullopt;
536 
537     auto transceiver = makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(result.MoveValue());
538     return LibWebRTCMediaEndpoint::Backends { transceiver-&gt;createSenderBackend(m_peerConnectionBackend, WTFMove(source)), transceiver-&gt;createReceiverBackend(), WTFMove(transceiver) };
539 }
540 
541 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
542 {
543     auto type = trackKind == &quot;audio&quot; ? cricket::MediaType::MEDIA_TYPE_AUDIO : cricket::MediaType::MEDIA_TYPE_VIDEO;
544     return createTransceiverBackends(type, init, nullptr);
545 }
546 
547 std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; LibWebRTCMediaEndpoint::createSourceAndRTCTrack(MediaStreamTrack&amp; track)
548 {
549     LibWebRTCRtpSenderBackend::Source source;
550     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
551     switch (track.privateTrack().type()) {
552     case RealtimeMediaSource::Type::None:
553         ASSERT_NOT_REACHED();
554         break;
555     case RealtimeMediaSource::Type::Audio: {
556         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
557         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
558         source = WTFMove(audioSource);
559         break;
560     }
561     case RealtimeMediaSource::Type::Video: {
562         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
563         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
564         source = WTFMove(videoSource);
565         break;
566     }
567     }
568     return std::make_pair(WTFMove(source), WTFMove(rtcTrack));
569 }
570 
571 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(MediaStreamTrack&amp; track, const RTCRtpTransceiverInit&amp; init)
572 {
573     auto sourceAndTrack = createSourceAndRTCTrack(track);
574     return createTransceiverBackends(WTFMove(sourceAndTrack.second), init, WTFMove(sourceAndTrack.first));
575 }
576 
577 void LibWebRTCMediaEndpoint::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
578 {
579     auto sourceAndTrack = createSourceAndRTCTrack(track);
580     sender.setSource(WTFMove(sourceAndTrack.first));
581     sender.rtcSender()-&gt;SetTrack(WTFMove(sourceAndTrack.second));
582 }
583 
584 std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; LibWebRTCMediaEndpoint::transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp; backend)
585 {
586     for (auto&amp; transceiver : m_backend-&gt;GetTransceivers()) {
587         if (transceiver-&gt;sender().get() == backend.rtcSender())
588             return makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;(transceiver));
589     }
590     return nullptr;
591 }
592 
593 
594 void LibWebRTCMediaEndpoint::removeRemoteStream(webrtc::MediaStreamInterface&amp; rtcStream)
595 {
596     bool removed = m_remoteStreamsById.remove(fromStdString(rtcStream.id()));
597     ASSERT_UNUSED(removed, removed);
598 }
599 
600 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
601 {
602     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
603         if (protectedThis-&gt;isStopped())
604             return;
605         ASSERT(stream);
606         protectedThis-&gt;addRemoteStream(*stream.get());
607     });
608 }
609 
610 void LibWebRTCMediaEndpoint::OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
611 {
612     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
613         if (protectedThis-&gt;isStopped())
614             return;
615         ASSERT(stream);
616         protectedThis-&gt;removeRemoteStream(*stream.get());
617     });
618 }
619 
620 void LibWebRTCMediaEndpoint::OnAddTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; streams)
621 {
622     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
623         return;
624 
625     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver), streams]() mutable {
626         if (protectedThis-&gt;isStopped())
627             return;
628         protectedThis-&gt;addRemoteTrack(WTFMove(receiver), streams);
629     });
630 }
631 
632 void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
633 {
634     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
635         return;
636 
637     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
638         if (protectedThis-&gt;isStopped())
639             return;
640         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
641     });
642 }
643 
644 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
645 {
646     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
647         if (protectedThis-&gt;isStopped())
648             return;
649         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
650     });
651 }
652 
653 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
654 {
655     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
656     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
657     return channel ? makeUnique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;
658 }
659 
660 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
661 {
662     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
663         if (protectedThis-&gt;isStopped())
664             return;
665         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
666         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));
667     });
668 }
669 
670 void LibWebRTCMediaEndpoint::stop()
671 {
672     if (!m_backend)
673         return;
674 
675     stopLoggingStats();
676 
677     m_backend-&gt;Close();
678     m_backend = nullptr;
679     m_remoteStreamsById.clear();
680     m_remoteStreamsFromRemoteTrack.clear();
681 }
682 
683 void LibWebRTCMediaEndpoint::OnRenegotiationNeeded()
684 {
685     callOnMainThread([protectedThis = makeRef(*this)] {
686         if (protectedThis-&gt;isStopped())
687             return;
688         protectedThis-&gt;m_peerConnectionBackend.markAsNeedingNegotiation();
689     });
690 }
691 
692 static inline RTCIceConnectionState toRTCIceConnectionState(webrtc::PeerConnectionInterface::IceConnectionState state)
693 {
694     switch (state) {
695     case webrtc::PeerConnectionInterface::kIceConnectionNew:
696         return RTCIceConnectionState::New;
697     case webrtc::PeerConnectionInterface::kIceConnectionChecking:
698         return RTCIceConnectionState::Checking;
699     case webrtc::PeerConnectionInterface::kIceConnectionConnected:
700         return RTCIceConnectionState::Connected;
701     case webrtc::PeerConnectionInterface::kIceConnectionCompleted:
702         return RTCIceConnectionState::Completed;
703     case webrtc::PeerConnectionInterface::kIceConnectionFailed:
704         return RTCIceConnectionState::Failed;
705     case webrtc::PeerConnectionInterface::kIceConnectionDisconnected:
706         return RTCIceConnectionState::Disconnected;
707     case webrtc::PeerConnectionInterface::kIceConnectionClosed:
708         return RTCIceConnectionState::Closed;
709     case webrtc::PeerConnectionInterface::kIceConnectionMax:
710         break;
711     }
712 
713     ASSERT_NOT_REACHED();
714     return RTCIceConnectionState::New;
715 }
716 
717 void LibWebRTCMediaEndpoint::OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState state)
718 {
719     auto connectionState = toRTCIceConnectionState(state);
720     callOnMainThread([protectedThis = makeRef(*this), connectionState] {
721         if (protectedThis-&gt;isStopped())
722             return;
723         if (protectedThis-&gt;m_peerConnectionBackend.connection().iceConnectionState() != connectionState)
724             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceConnectionState(connectionState);
725     });
726 }
727 
728 void LibWebRTCMediaEndpoint::OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState state)
729 {
730     callOnMainThread([protectedThis = makeRef(*this), state] {
731         if (protectedThis-&gt;isStopped())
732             return;
733         if (state == webrtc::PeerConnectionInterface::kIceGatheringComplete)
734             protectedThis-&gt;m_peerConnectionBackend.doneGatheringCandidates();
735         else if (state == webrtc::PeerConnectionInterface::kIceGatheringGathering)
736             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceGatheringState(RTCIceGatheringState::Gathering);
737     });
738 }
739 
740 void LibWebRTCMediaEndpoint::OnIceCandidate(const webrtc::IceCandidateInterface *rtcCandidate)
741 {
742     ASSERT(rtcCandidate);
743 
744     std::string sdp;
745     rtcCandidate-&gt;ToString(&amp;sdp);
746 
747     auto sdpMLineIndex = safeCast&lt;unsigned short&gt;(rtcCandidate-&gt;sdp_mline_index());
748 
749     callOnMainThread([protectedThis = makeRef(*this), mid = fromStdString(rtcCandidate-&gt;sdp_mid()), sdp = fromStdString(sdp), sdpMLineIndex, url = fromStdString(rtcCandidate-&gt;server_url())]() mutable {
750         if (protectedThis-&gt;isStopped())
751             return;
752         protectedThis-&gt;m_peerConnectionBackend.newICECandidate(WTFMove(sdp), WTFMove(mid), sdpMLineIndex, WTFMove(url));
753     });
754 }
755 
756 void LibWebRTCMediaEndpoint::OnIceCandidatesRemoved(const std::vector&lt;cricket::Candidate&gt;&amp;)
757 {
758     ASSERT_NOT_REACHED();
759 }
760 
761 void LibWebRTCMediaEndpoint::createSessionDescriptionSucceeded(std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt;&amp;&amp; description)
762 {
763     std::string sdp;
764     description-&gt;ToString(&amp;sdp);
765 
766     callOnMainThread([protectedThis = makeRef(*this), sdp = fromStdString(sdp)]() mutable {
767         if (protectedThis-&gt;isStopped())
768             return;
769         if (protectedThis-&gt;m_isInitiator)
770             protectedThis-&gt;m_peerConnectionBackend.createOfferSucceeded(WTFMove(sdp));
771         else
772             protectedThis-&gt;m_peerConnectionBackend.createAnswerSucceeded(WTFMove(sdp));
773     });
774 }
775 
776 void LibWebRTCMediaEndpoint::createSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
777 {
778     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
779         if (protectedThis-&gt;isStopped())
780             return;
781         if (protectedThis-&gt;m_isInitiator)
782             protectedThis-&gt;m_peerConnectionBackend.createOfferFailed(Exception { errorCode, WTFMove(errorMessage) });
783         else
784             protectedThis-&gt;m_peerConnectionBackend.createAnswerFailed(Exception { errorCode, WTFMove(errorMessage) });
785     });
786 }
787 
788 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionSucceeded()
789 {
790     callOnMainThread([protectedThis = makeRef(*this)] {
791         if (protectedThis-&gt;isStopped())
792             return;
793         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionSucceeded();
794     });
795 }
796 
797 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
798 {
799     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
800         if (protectedThis-&gt;isStopped())
801             return;
802         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
803     });
804 }
805 
806 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionSucceeded()
807 {
808     callOnMainThread([protectedThis = makeRef(*this)] {
809         if (protectedThis-&gt;isStopped())
810             return;
811         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionSucceeded();
812     });
813 }
814 
815 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
816 {
817     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
818         if (protectedThis-&gt;isStopped())
819             return;
820         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
821     });
822 }
823 
824 void LibWebRTCMediaEndpoint::gatherStatsForLogging()
825 {
826     m_backend-&gt;GetStats(this);
827 }
828 
829 class RTCStatsLogger {
830 public:
831     explicit RTCStatsLogger(const webrtc::RTCStats&amp; stats)
832         : m_stats(stats)
833     {
834     }
835 
836     String toJSONString() const { return String(m_stats.ToJson().c_str()); }
837 
838 private:
839     const webrtc::RTCStats&amp; m_stats;
840 };
841 
842 void LibWebRTCMediaEndpoint::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report)
843 {
844 #if !RELEASE_LOG_DISABLED
845     int64_t timestamp = report-&gt;timestamp_us();
846     if (!m_statsFirstDeliveredTimestamp)
847         m_statsFirstDeliveredTimestamp = timestamp;
848 
849     callOnMainThread([protectedThis = makeRef(*this), this, timestamp, report] {
850         if (m_backend &amp;&amp; m_statsLogTimer.repeatInterval() != statsLogInterval(timestamp)) {
851             m_statsLogTimer.stop();
852             m_statsLogTimer.startRepeating(statsLogInterval(timestamp));
853         }
854 
855         for (auto iterator = report-&gt;begin(); iterator != report-&gt;end(); ++iterator) {
856             if (logger().willLog(logChannel(), WTFLogLevel::Debug)) {
857                 // Stats are very verbose, let&#39;s only display them in inspector console in verbose mode.
858                 logger().debug(LogWebRTC,
859                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
860                     RTCStatsLogger { *iterator });
861             } else {
862                 logger().logAlways(LogWebRTCStats,
863                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
864                     RTCStatsLogger { *iterator });
865             }
866         }
867     });
868 #else
869     UNUSED_PARAM(report);
870 #endif
871 }
872 
873 void LibWebRTCMediaEndpoint::startLoggingStats()
874 {
875 #if !RELEASE_LOG_DISABLED
876     if (m_statsLogTimer.isActive())
877         m_statsLogTimer.stop();
878     m_statsLogTimer.startRepeating(statsLogInterval(0));
879 #endif
880 }
881 
882 void LibWebRTCMediaEndpoint::stopLoggingStats()
883 {
884     m_statsLogTimer.stop();
885 }
886 
887 #if !RELEASE_LOG_DISABLED
888 WTFLogChannel&amp; LibWebRTCMediaEndpoint::logChannel() const
889 {
890     return LogWebRTC;
891 }
892 
893 Seconds LibWebRTCMediaEndpoint::statsLogInterval(int64_t reportTimestamp) const
894 {
895     if (logger().willLog(logChannel(), WTFLogLevel::Info))
896         return 2_s;
897 
898     if (reportTimestamp - m_statsFirstDeliveredTimestamp &gt; 15000000)
899         return 10_s;
900 
901     return 4_s;
902 }
903 #endif
904 
905 } // namespace WebCore
906 
907 namespace WTF {
908 
909 template&lt;typename Type&gt;
910 struct LogArgument;
911 
912 template &lt;&gt;
913 struct LogArgument&lt;WebCore::RTCStatsLogger&gt; {
914     static String toString(const WebCore::RTCStatsLogger&amp; logger)
915     {
916         return String(logger.toJSONString());
917     }
918 };
919 
920 }; // namespace WTF
921 
922 
923 #endif // USE(LIBWEBRTC)
    </pre>
  </body>
</html>