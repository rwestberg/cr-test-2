<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/FrameSelection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004, 2008, 2009, 2010, 2014-2015 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;FrameSelection.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;CharacterData.h&quot;
  31 #include &quot;DeleteSelectionCommand.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;Editing.h&quot;
  34 #include &quot;Editor.h&quot;
  35 #include &quot;EditorClient.h&quot;
  36 #include &quot;Element.h&quot;
  37 #include &quot;ElementIterator.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventNames.h&quot;
  40 #include &quot;FloatQuad.h&quot;
  41 #include &quot;FocusController.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;FrameTree.h&quot;
  44 #include &quot;FrameView.h&quot;
  45 #include &quot;GraphicsContext.h&quot;
  46 #include &quot;HTMLBodyElement.h&quot;
  47 #include &quot;HTMLFormElement.h&quot;
  48 #include &quot;HTMLFrameElement.h&quot;
  49 #include &quot;HTMLIFrameElement.h&quot;
  50 #include &quot;HTMLNames.h&quot;
  51 #include &quot;HTMLSelectElement.h&quot;
  52 #include &quot;HitTestRequest.h&quot;
  53 #include &quot;HitTestResult.h&quot;
  54 #include &quot;InlineTextBox.h&quot;
  55 #include &quot;Page.h&quot;
  56 #include &quot;RenderLayer.h&quot;
  57 #include &quot;RenderText.h&quot;
  58 #include &quot;RenderTextControl.h&quot;
  59 #include &quot;RenderTheme.h&quot;
  60 #include &quot;RenderView.h&quot;
  61 #include &quot;RenderWidget.h&quot;
  62 #include &quot;RenderedPosition.h&quot;
  63 #include &quot;Settings.h&quot;
  64 #include &quot;SpatialNavigation.h&quot;
  65 #include &quot;StyleProperties.h&quot;
  66 #include &quot;TypingCommand.h&quot;
  67 #include &quot;VisibleUnits.h&quot;
  68 #include &lt;stdio.h&gt;
  69 #include &lt;wtf/text/CString.h&gt;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 #include &quot;Chrome.h&quot;
  73 #include &quot;ChromeClient.h&quot;
  74 #include &quot;Color.h&quot;
  75 #include &quot;RenderObject.h&quot;
  76 #include &quot;RenderStyle.h&quot;
  77 #endif
  78 
  79 namespace WebCore {
  80 
  81 using namespace HTMLNames;
  82 
  83 static inline LayoutUnit NoXPosForVerticalArrowNavigation()
  84 {
  85     return LayoutUnit::min();
  86 }
  87 
  88 CaretBase::CaretBase(CaretVisibility visibility)
  89     : m_caretRectNeedsUpdate(true)
  90     , m_caretVisibility(visibility)
  91 {
  92 }
  93 
  94 DragCaretController::DragCaretController()
  95     : CaretBase(Visible)
  96 {
  97 }
  98 
  99 bool DragCaretController::isContentRichlyEditable() const
 100 {
 101     return isRichlyEditablePosition(m_position.deepEquivalent());
 102 }
 103 
 104 IntRect DragCaretController::caretRectInRootViewCoordinates() const
 105 {
 106     if (!hasCaret())
 107         return { };
 108 
 109     if (auto* document = m_position.deepEquivalent().document()) {
 110         if (auto* documentView = document-&gt;view())
 111             return documentView-&gt;contentsToRootView(m_position.absoluteCaretBounds());
 112     }
 113 
 114     return { };
 115 }
 116 
 117 IntRect DragCaretController::editableElementRectInRootViewCoordinates() const
 118 {
 119     if (!hasCaret())
 120         return { };
 121 
 122     RefPtr&lt;ContainerNode&gt; editableContainer;
 123     if (auto* formControl = enclosingTextFormControl(m_position.deepEquivalent()))
 124         editableContainer = formControl;
 125     else
 126         editableContainer = highestEditableRoot(m_position.deepEquivalent());
 127 
 128     if (!editableContainer)
 129         return { };
 130 
 131     auto* renderer = editableContainer-&gt;renderer();
 132     if (!renderer)
 133         return { };
 134 
 135     if (auto* view = editableContainer-&gt;document().view())
 136         return view-&gt;contentsToRootView(renderer-&gt;absoluteBoundingBoxRect()); // FIXME: Wrong for elements with visible layout overflow.
 137 
 138     return { };
 139 }
 140 
 141 static inline bool shouldAlwaysUseDirectionalSelection(Frame* frame)
 142 {
 143     return !frame || frame-&gt;editor().behavior().shouldConsiderSelectionAsDirectional();
 144 }
 145 
 146 FrameSelection::FrameSelection(Frame* frame)
 147     : m_frame(frame)
 148     , m_xPosForVerticalArrowNavigation(NoXPosForVerticalArrowNavigation())
 149     , m_granularity(CharacterGranularity)
 150 #if ENABLE(TEXT_CARET)
 151     , m_caretBlinkTimer(*this, &amp;FrameSelection::caretBlinkTimerFired)
 152 #endif
 153     , m_appearanceUpdateTimer(*this, &amp;FrameSelection::appearanceUpdateTimerFired)
 154     , m_caretInsidePositionFixed(false)
 155     , m_absCaretBoundsDirty(true)
 156     , m_caretPaint(true)
 157     , m_isCaretBlinkingSuspended(false)
 158     , m_focused(frame &amp;&amp; frame-&gt;page() &amp;&amp; frame-&gt;page()-&gt;focusController().focusedFrame() == frame)
 159     , m_shouldShowBlockCursor(false)
 160     , m_pendingSelectionUpdate(false)
 161     , m_alwaysAlignCursorOnScrollWhenRevealingSelection(false)
 162 #if PLATFORM(IOS_FAMILY)
 163     , m_updateAppearanceEnabled(false)
 164     , m_caretBlinks(true)
 165 #endif
 166 {
 167     if (shouldAlwaysUseDirectionalSelection(m_frame))
 168         m_selection.setIsDirectional(true);
 169 }
 170 
 171 Element* FrameSelection::rootEditableElementOrDocumentElement() const
 172 {
 173     Element* selectionRoot = m_selection.rootEditableElement();
 174     return selectionRoot ? selectionRoot : m_frame-&gt;document()-&gt;documentElement();
 175 }
 176 
 177 void FrameSelection::moveTo(const VisiblePosition &amp;pos, EUserTriggered userTriggered, CursorAlignOnScroll align)
 178 {
 179     setSelection(VisibleSelection(pos.deepEquivalent(), pos.deepEquivalent(), pos.affinity(), m_selection.isDirectional()),
 180         defaultSetSelectionOptions(userTriggered), AXTextStateChangeIntent(), align);
 181 }
 182 
 183 void FrameSelection::moveTo(const VisiblePosition &amp;base, const VisiblePosition &amp;extent, EUserTriggered userTriggered)
 184 {
 185     const bool selectionHasDirection = true;
 186     setSelection(VisibleSelection(base.deepEquivalent(), extent.deepEquivalent(), base.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
 187 }
 188 
 189 void FrameSelection::moveTo(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
 190 {
 191     setSelection(VisibleSelection(pos, affinity, m_selection.isDirectional()), defaultSetSelectionOptions(userTriggered));
 192 }
 193 
 194 void FrameSelection::moveTo(const Range* range)
 195 {
 196     VisibleSelection selection = range ? VisibleSelection(range-&gt;startPosition(), range-&gt;endPosition()) : VisibleSelection();
 197     setSelection(selection);
 198 }
 199 
 200 void FrameSelection::moveTo(const Position &amp;base, const Position &amp;extent, EAffinity affinity, EUserTriggered userTriggered)
 201 {
 202     const bool selectionHasDirection = true;
 203     setSelection(VisibleSelection(base, extent, affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
 204 }
 205 
 206 void FrameSelection::moveWithoutValidationTo(const Position&amp; base, const Position&amp; extent, bool selectionHasDirection, bool shouldSetFocus, SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
 207 {
 208     VisibleSelection newSelection;
 209     newSelection.setWithoutValidation(base, extent);
 210     newSelection.setIsDirectional(selectionHasDirection);
 211     AXTextStateChangeIntent newIntent = intent.type == AXTextStateChangeTypeUnknown ? AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false }) : intent;
 212     auto options = defaultSetSelectionOptions();
 213     if (!shouldSetFocus)
 214         options.add(DoNotSetFocus);
 215     switch (revealMode) {
 216     case SelectionRevealMode::DoNotReveal:
 217         break;
 218     case SelectionRevealMode::Reveal:
 219         options.add(RevealSelection);
 220         break;
 221     case SelectionRevealMode::RevealUpToMainFrame:
 222         options.add(RevealSelectionUpToMainFrame);
 223         break;
 224     }
 225     setSelection(newSelection, options, newIntent);
 226 }
 227 
 228 void DragCaretController::setCaretPosition(const VisiblePosition&amp; position)
 229 {
 230     if (Node* node = m_position.deepEquivalent().deprecatedNode())
 231         invalidateCaretRect(node);
 232     m_position = position;
 233     setCaretRectNeedsUpdate();
 234     Document* document = nullptr;
 235     if (Node* node = m_position.deepEquivalent().deprecatedNode()) {
 236         invalidateCaretRect(node);
 237         document = &amp;node-&gt;document();
 238     }
 239     if (m_position.isNull() || m_position.isOrphan())
 240         clearCaretRect();
 241     else
 242         updateCaretRect(document, m_position);
 243 }
 244 
 245 static void adjustEndpointsAtBidiBoundary(VisiblePosition&amp; visibleBase, VisiblePosition&amp; visibleExtent)
 246 {
 247     RenderedPosition base(visibleBase);
 248     RenderedPosition extent(visibleExtent);
 249 
 250     if (base.isNull() || extent.isNull() || base.isEquivalent(extent))
 251         return;
 252 
 253     if (base.atLeftBoundaryOfBidiRun()) {
 254         if (!extent.atRightBoundaryOfBidiRun(base.bidiLevelOnRight())
 255             &amp;&amp; base.isEquivalent(extent.leftBoundaryOfBidiRun(base.bidiLevelOnRight()))) {
 256             visibleBase = base.positionAtLeftBoundaryOfBiDiRun();
 257             return;
 258         }
 259         return;
 260     }
 261 
 262     if (base.atRightBoundaryOfBidiRun()) {
 263         if (!extent.atLeftBoundaryOfBidiRun(base.bidiLevelOnLeft())
 264             &amp;&amp; base.isEquivalent(extent.rightBoundaryOfBidiRun(base.bidiLevelOnLeft()))) {
 265             visibleBase = base.positionAtRightBoundaryOfBiDiRun();
 266             return;
 267         }
 268         return;
 269     }
 270 
 271     if (extent.atLeftBoundaryOfBidiRun() &amp;&amp; extent.isEquivalent(base.leftBoundaryOfBidiRun(extent.bidiLevelOnRight()))) {
 272         visibleExtent = extent.positionAtLeftBoundaryOfBiDiRun();
 273         return;
 274     }
 275 
 276     if (extent.atRightBoundaryOfBidiRun() &amp;&amp; extent.isEquivalent(base.rightBoundaryOfBidiRun(extent.bidiLevelOnLeft()))) {
 277         visibleExtent = extent.positionAtRightBoundaryOfBiDiRun();
 278         return;
 279     }
 280 }
 281 
 282 void FrameSelection::setSelectionByMouseIfDifferent(const VisibleSelection&amp; passedNewSelection, TextGranularity granularity,
 283     EndPointsAdjustmentMode endpointsAdjustmentMode)
 284 {
 285     VisibleSelection newSelection = passedNewSelection;
 286     bool isDirectional = shouldAlwaysUseDirectionalSelection(m_frame) || newSelection.isDirectional();
 287 
 288     VisiblePosition base = m_originalBase.isNotNull() ? m_originalBase : newSelection.visibleBase();
 289     VisiblePosition newBase = base;
 290     VisiblePosition extent = newSelection.visibleExtent();
 291     VisiblePosition newExtent = extent;
 292     if (endpointsAdjustmentMode == AdjustEndpointsAtBidiBoundary)
 293         adjustEndpointsAtBidiBoundary(newBase, newExtent);
 294 
 295     if (newBase != base || newExtent != extent) {
 296         m_originalBase = base;
 297         newSelection.setBase(newBase);
 298         newSelection.setExtent(newExtent);
 299     } else if (m_originalBase.isNotNull()) {
 300         if (m_selection.base() == newSelection.base())
 301             newSelection.setBase(m_originalBase);
 302         m_originalBase.clear();
 303     }
 304 
 305     newSelection.setIsDirectional(isDirectional); // Adjusting base and extent will make newSelection always directional
 306     if (m_selection == newSelection || !shouldChangeSelection(newSelection))
 307         return;
 308 
 309 
 310     AXTextStateChangeIntent intent;
 311     if (AXObjectCache::accessibilityEnabled() &amp;&amp; newSelection.isCaret())
 312         intent = AXTextStateChangeIntent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
 313     else
 314         intent = AXTextStateChangeIntent();
 315     setSelection(newSelection, defaultSetSelectionOptions() | FireSelectEvent, intent, AlignCursorOnScrollIfNeeded, granularity);
 316 }
 317 
 318 bool FrameSelection::setSelectionWithoutUpdatingAppearance(const VisibleSelection&amp; newSelectionPossiblyWithoutDirection, OptionSet&lt;SetSelectionOption&gt; options, CursorAlignOnScroll align, TextGranularity granularity)
 319 {
 320     bool closeTyping = options.contains(CloseTyping);
 321     bool shouldClearTypingStyle = options.contains(ClearTypingStyle);
 322 
 323     VisibleSelection newSelection = newSelectionPossiblyWithoutDirection;
 324     if (shouldAlwaysUseDirectionalSelection(m_frame))
 325         newSelection.setIsDirectional(true);
 326 
 327     if (!m_frame) {
 328         m_selection = newSelection;
 329         return false;
 330     }
 331 
 332     // &lt;http://bugs.webkit.org/show_bug.cgi?id=23464&gt;: Infinite recursion at FrameSelection::setSelection
 333     // if document-&gt;frame() == m_frame we can get into an infinite loop
 334     if (Document* newSelectionDocument = newSelection.base().document()) {
 335         if (RefPtr&lt;Frame&gt; newSelectionFrame = newSelectionDocument-&gt;frame()) {
 336             if (newSelectionFrame != m_frame &amp;&amp; newSelectionDocument != m_frame-&gt;document()) {
 337                 newSelectionFrame-&gt;selection().setSelection(newSelection, options, AXTextStateChangeIntent(), align, granularity);
 338                 // It&#39;s possible that during the above set selection, this FrameSelection has been modified by
 339                 // selectFrameElementInParentIfFullySelected, but that the selection is no longer valid since
 340                 // the frame is about to be destroyed. If this is the case, clear our selection.
 341                 if (newSelectionFrame-&gt;hasOneRef() &amp;&amp; m_selection.isNoneOrOrphaned())
 342                     clear();
 343                 return false;
 344             }
 345         }
 346     }
 347 
 348     m_granularity = granularity;
 349 
 350     if (closeTyping)
 351         TypingCommand::closeTyping(m_frame);
 352 
 353     if (shouldClearTypingStyle)
 354         clearTypingStyle();
 355 
 356     VisibleSelection oldSelection = m_selection;
 357     bool didMutateSelection = oldSelection != newSelection;
 358     if (didMutateSelection)
 359         m_frame-&gt;editor().selectionWillChange();
 360 
 361     m_selection = newSelection;
 362 
 363     // Selection offsets should increase when LF is inserted before the caret in InsertLineBreakCommand. See &lt;https://webkit.org/b/56061&gt;.
 364     if (HTMLTextFormControlElement* textControl = enclosingTextFormControl(newSelection.start()))
 365         textControl-&gt;selectionChanged(options.contains(FireSelectEvent));
 366 
 367     if (!didMutateSelection)
 368         return false;
 369 
 370     setCaretRectNeedsUpdate();
 371 
 372     if (!newSelection.isNone() &amp;&amp; !(options &amp; DoNotSetFocus))
 373         setFocusedElementIfNeeded();
 374 
 375     // Always clear the x position used for vertical arrow navigation.
 376     // It will be restored by the vertical arrow navigation code if necessary.
 377     m_xPosForVerticalArrowNavigation = NoXPosForVerticalArrowNavigation();
 378     selectFrameElementInParentIfFullySelected();
 379     m_frame-&gt;editor().respondToChangedSelection(oldSelection, options);
 380     m_frame-&gt;document()-&gt;enqueueDocumentEvent(Event::create(eventNames().selectionchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 381 
 382     return true;
 383 }
 384 
 385 void FrameSelection::setSelection(const VisibleSelection&amp; selection, OptionSet&lt;SetSelectionOption&gt; options, AXTextStateChangeIntent intent, CursorAlignOnScroll align, TextGranularity granularity)
 386 {
 387     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 388     if (!setSelectionWithoutUpdatingAppearance(selection, options, align, granularity))
 389         return;
 390 
 391     Document* document = m_frame-&gt;document();
 392     if (!document)
 393         return;
 394 
 395     if (options &amp; RevealSelectionUpToMainFrame)
 396         m_selectionRevealMode = SelectionRevealMode::RevealUpToMainFrame;
 397     else if (options &amp; RevealSelection)
 398         m_selectionRevealMode = SelectionRevealMode::Reveal;
 399     else
 400         m_selectionRevealMode = SelectionRevealMode::DoNotReveal;
 401     m_alwaysAlignCursorOnScrollWhenRevealingSelection = align == AlignCursorOnScrollAlways;
 402 
 403     m_selectionRevealIntent = intent;
 404     m_pendingSelectionUpdate = true;
 405 
 406     if (document-&gt;hasPendingStyleRecalc())
 407         return;
 408 
 409     FrameView* frameView = document-&gt;view();
 410     if (frameView &amp;&amp; frameView-&gt;layoutContext().isLayoutPending())
 411         return;
 412 
 413     updateAndRevealSelection(intent);
 414 
 415     if (options &amp; IsUserTriggered) {
 416         if (auto* client = m_frame-&gt;editor().client())
 417             client-&gt;didEndUserTriggeredSelectionChanges();
 418     }
 419 }
 420 
 421 static void updateSelectionByUpdatingLayoutOrStyle(Frame&amp; frame)
 422 {
 423 #if ENABLE(TEXT_CARET)
 424     frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 425 #else
 426     frame.document()-&gt;updateStyleIfNeeded();
 427 #endif
 428 }
 429 
 430 void FrameSelection::setNeedsSelectionUpdate(RevealSelectionAfterUpdate revealMode)
 431 {
 432     m_selectionRevealIntent = AXTextStateChangeIntent();
 433     if (revealMode == RevealSelectionAfterUpdate::Forced)
 434         m_selectionRevealMode = SelectionRevealMode::Reveal;
 435     m_pendingSelectionUpdate = true;
 436     if (RenderView* view = m_frame-&gt;contentRenderer())
 437         view-&gt;selection().clear();
 438 }
 439 
 440 void FrameSelection::updateAndRevealSelection(const AXTextStateChangeIntent&amp; intent)
 441 {
 442     if (!m_pendingSelectionUpdate)
 443         return;
 444 
 445     m_pendingSelectionUpdate = false;
 446 
 447     updateAppearance();
 448 
 449     if (m_selectionRevealMode != SelectionRevealMode::DoNotReveal) {
 450         ScrollAlignment alignment;
 451 
 452         if (m_frame-&gt;editor().behavior().shouldCenterAlignWhenSelectionIsRevealed())
 453             alignment = m_alwaysAlignCursorOnScrollWhenRevealingSelection ? ScrollAlignment::alignCenterAlways : ScrollAlignment::alignCenterIfNeeded;
 454         else
 455             alignment = m_alwaysAlignCursorOnScrollWhenRevealingSelection ? ScrollAlignment::alignTopAlways : ScrollAlignment::alignToEdgeIfNeeded;
 456 
 457         revealSelection(m_selectionRevealMode, alignment, RevealExtent);
 458     }
 459 
 460     notifyAccessibilityForSelectionChange(intent);
 461 }
 462 
 463 void FrameSelection::updateDataDetectorsForSelection()
 464 {
 465 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
 466     m_frame-&gt;editor().scanSelectionForTelephoneNumbers();
 467 #endif
 468 }
 469 
 470 static bool removingNodeRemovesPosition(Node&amp; node, const Position&amp; position)
 471 {
 472     if (!position.anchorNode())
 473         return false;
 474 
 475     if (position.anchorNode() == &amp;node)
 476         return true;
 477 
 478     if (!is&lt;Element&gt;(node))
 479         return false;
 480 
 481     return downcast&lt;Element&gt;(node).containsIncludingShadowDOM(position.anchorNode());
 482 }
 483 
 484 void DragCaretController::nodeWillBeRemoved(Node&amp; node)
 485 {
 486     if (!hasCaret() || !node.isConnected())
 487         return;
 488 
 489     if (!removingNodeRemovesPosition(node, m_position.deepEquivalent()))
 490         return;
 491 
 492     if (RenderView* view = node.document().renderView())
 493         view-&gt;selection().clear();
 494 
 495     clear();
 496 }
 497 
 498 void FrameSelection::nodeWillBeRemoved(Node&amp; node)
 499 {
 500     // There can&#39;t be a selection inside a fragment, so if a fragment&#39;s node is being removed,
 501     // the selection in the document that created the fragment needs no adjustment.
 502     if (isNone() || !node.isConnected())
 503         return;
 504 
 505     respondToNodeModification(node, removingNodeRemovesPosition(node, m_selection.base()), removingNodeRemovesPosition(node, m_selection.extent()),
 506         removingNodeRemovesPosition(node, m_selection.start()), removingNodeRemovesPosition(node, m_selection.end()));
 507 }
 508 
 509 void FrameSelection::respondToNodeModification(Node&amp; node, bool baseRemoved, bool extentRemoved, bool startRemoved, bool endRemoved)
 510 {
 511     bool clearRenderTreeSelection = false;
 512     bool clearDOMTreeSelection = false;
 513 
 514     if (startRemoved || endRemoved) {
 515         Position start = m_selection.start();
 516         Position end = m_selection.end();
 517         if (startRemoved)
 518             updatePositionForNodeRemoval(start, node);
 519         if (endRemoved)
 520             updatePositionForNodeRemoval(end, node);
 521 
 522         if (start.isNotNull() &amp;&amp; end.isNotNull()) {
 523             if (m_selection.isBaseFirst())
 524                 m_selection.setWithoutValidation(start, end);
 525             else
 526                 m_selection.setWithoutValidation(end, start);
 527         } else
 528             clearDOMTreeSelection = true;
 529 
 530         clearRenderTreeSelection = true;
 531     } else if (baseRemoved || extentRemoved) {
 532         // The base and/or extent are about to be removed, but the start and end aren&#39;t.
 533         // Change the base and extent to the start and end, but don&#39;t re-validate the
 534         // selection, since doing so could move the start and end into the node
 535         // that is about to be removed.
 536         if (m_selection.isBaseFirst())
 537             m_selection.setWithoutValidation(m_selection.start(), m_selection.end());
 538         else
 539             m_selection.setWithoutValidation(m_selection.end(), m_selection.start());
 540     } else if (isRange()) {
 541         if (RefPtr&lt;Range&gt; range = m_selection.firstRange()) {
 542             auto compareNodeResult = range-&gt;compareNode(node);
 543             if (!compareNodeResult.hasException()) {
 544                 auto compareResult = compareNodeResult.releaseReturnValue();
 545                 if (compareResult == Range::NODE_BEFORE_AND_AFTER || compareResult == Range::NODE_INSIDE) {
 546                     // If we did nothing here, when this node&#39;s renderer was destroyed, the rect that it
 547                     // occupied would be invalidated, but, selection gaps that change as a result of
 548                     // the removal wouldn&#39;t be invalidated.
 549                     // FIXME: Don&#39;t do so much unnecessary invalidation.
 550                     clearRenderTreeSelection = true;
 551                 }
 552             }
 553         }
 554     }
 555 
 556     if (clearRenderTreeSelection) {
 557         if (auto* renderView = node.document().renderView()) {
 558             renderView-&gt;selection().clear();
 559 
 560             // Trigger a selection update so the selection will be set again.
 561             m_selectionRevealIntent = AXTextStateChangeIntent();
 562             m_pendingSelectionUpdate = true;
 563             renderView-&gt;frameView().scheduleSelectionUpdate();
 564         }
 565     }
 566 
 567     if (clearDOMTreeSelection)
 568         setSelection(VisibleSelection(), DoNotSetFocus);
 569 }
 570 
 571 static void updatePositionAfterAdoptingTextReplacement(Position&amp; position, CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)
 572 {
 573     if (!position.anchorNode() || position.anchorNode() != node || position.anchorType() != Position::PositionIsOffsetInAnchor)
 574         return;
 575 
 576     // See: http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Mutation
 577     ASSERT(position.offsetInContainerNode() &gt;= 0);
 578     unsigned positionOffset = static_cast&lt;unsigned&gt;(position.offsetInContainerNode());
 579     // Replacing text can be viewed as a deletion followed by insertion.
 580     if (positionOffset &gt;= offset &amp;&amp; positionOffset &lt;= offset + oldLength)
 581         position.moveToOffset(offset);
 582 
 583     // Adjust the offset if the position is after the end of the deleted contents
 584     // (positionOffset &gt; offset + oldLength) to avoid having a stale offset.
 585     if (positionOffset &gt; offset + oldLength)
 586         position.moveToOffset(positionOffset - oldLength + newLength);
 587 
 588     ASSERT(static_cast&lt;unsigned&gt;(position.offsetInContainerNode()) &lt;= node-&gt;length());
 589 }
 590 
 591 void FrameSelection::textWasReplaced(CharacterData* node, unsigned offset, unsigned oldLength, unsigned newLength)
 592 {
 593     // The fragment check is a performance optimization. See http://trac.webkit.org/changeset/30062.
 594     if (isNone() || !node || !node-&gt;isConnected())
 595         return;
 596 
 597     Position base = m_selection.base();
 598     Position extent = m_selection.extent();
 599     Position start = m_selection.start();
 600     Position end = m_selection.end();
 601     updatePositionAfterAdoptingTextReplacement(base, node, offset, oldLength, newLength);
 602     updatePositionAfterAdoptingTextReplacement(extent, node, offset, oldLength, newLength);
 603     updatePositionAfterAdoptingTextReplacement(start, node, offset, oldLength, newLength);
 604     updatePositionAfterAdoptingTextReplacement(end, node, offset, oldLength, newLength);
 605 
 606     if (base != m_selection.base() || extent != m_selection.extent() || start != m_selection.start() || end != m_selection.end()) {
 607         VisibleSelection newSelection;
 608         if (base != extent)
 609             newSelection.setWithoutValidation(base, extent);
 610         else if (m_selection.isDirectional() &amp;&amp; !m_selection.isBaseFirst())
 611             newSelection.setWithoutValidation(end, start);
 612         else
 613             newSelection.setWithoutValidation(start, end);
 614 
 615         setSelection(newSelection, DoNotSetFocus);
 616     }
 617 }
 618 
 619 TextDirection FrameSelection::directionOfEnclosingBlock()
 620 {
 621     return WebCore::directionOfEnclosingBlock(m_selection.extent());
 622 }
 623 
 624 TextDirection FrameSelection::directionOfSelection()
 625 {
 626     InlineBox* startBox = nullptr;
 627     InlineBox* endBox = nullptr;
 628     int unusedOffset;
 629     // Cache the VisiblePositions because visibleStart() and visibleEnd()
 630     // can cause layout, which has the potential to invalidate lineboxes.
 631     VisiblePosition startPosition = m_selection.visibleStart();
 632     VisiblePosition endPosition = m_selection.visibleEnd();
 633     if (startPosition.isNotNull())
 634         startPosition.getInlineBoxAndOffset(startBox, unusedOffset);
 635     if (endPosition.isNotNull())
 636         endPosition.getInlineBoxAndOffset(endBox, unusedOffset);
 637     if (startBox &amp;&amp; endBox &amp;&amp; startBox-&gt;direction() == endBox-&gt;direction())
 638         return startBox-&gt;direction();
 639 
 640     return directionOfEnclosingBlock();
 641 }
 642 
 643 void FrameSelection::willBeModified(EAlteration alter, SelectionDirection direction)
 644 {
 645     if (alter != AlterationExtend)
 646         return;
 647 
 648     Position start = m_selection.start();
 649     Position end = m_selection.end();
 650 
 651     bool baseIsStart = true;
 652 
 653     if (m_selection.isDirectional()) {
 654         // Make base and extent match start and end so we extend the user-visible selection.
 655         // This only matters for cases where base and extend point to different positions than
 656         // start and end (e.g. after a double-click to select a word).
 657         if (m_selection.isBaseFirst())
 658             baseIsStart = true;
 659         else
 660             baseIsStart = false;
 661     } else {
 662         switch (direction) {
 663         case DirectionRight:
 664             if (directionOfSelection() == TextDirection::LTR)
 665                 baseIsStart = true;
 666             else
 667                 baseIsStart = false;
 668             break;
 669         case DirectionForward:
 670             baseIsStart = true;
 671             break;
 672         case DirectionLeft:
 673             if (directionOfSelection() == TextDirection::LTR)
 674                 baseIsStart = false;
 675             else
 676                 baseIsStart = true;
 677             break;
 678         case DirectionBackward:
 679             baseIsStart = false;
 680             break;
 681         }
 682     }
 683     if (baseIsStart) {
 684         m_selection.setBase(start);
 685         m_selection.setExtent(end);
 686     } else {
 687         m_selection.setBase(end);
 688         m_selection.setExtent(start);
 689     }
 690 }
 691 
 692 VisiblePosition FrameSelection::positionForPlatform(bool isGetStart) const
 693 {
 694     // FIXME: VisibleSelection should be fixed to ensure as an invariant that
 695     // base/extent always point to the same nodes as start/end, but which points
 696     // to which depends on the value of isBaseFirst. Then this can be changed
 697     // to just return m_sel.extent().
 698     if (m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldAlwaysExtendSelectionFromExtentEndpoint())
 699         return m_selection.isBaseFirst() ? m_selection.visibleEnd() : m_selection.visibleStart();
 700 
 701     return isGetStart ? m_selection.visibleStart() : m_selection.visibleEnd();
 702 }
 703 
 704 VisiblePosition FrameSelection::startForPlatform() const
 705 {
 706     return positionForPlatform(true);
 707 }
 708 
 709 VisiblePosition FrameSelection::endForPlatform() const
 710 {
 711     return positionForPlatform(false);
 712 }
 713 
 714 VisiblePosition FrameSelection::nextWordPositionForPlatform(const VisiblePosition &amp;originalPosition)
 715 {
 716     VisiblePosition positionAfterCurrentWord = nextWordPosition(originalPosition);
 717 
 718     if (m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight()) {
 719         // In order to skip spaces when moving right, we advance one
 720         // word further and then move one word back. Given the
 721         // semantics of previousWordPosition() this will put us at the
 722         // beginning of the word following.
 723         VisiblePosition positionAfterSpacingAndFollowingWord = nextWordPosition(positionAfterCurrentWord);
 724         if (positionAfterSpacingAndFollowingWord != positionAfterCurrentWord)
 725             positionAfterCurrentWord = previousWordPosition(positionAfterSpacingAndFollowingWord);
 726 
 727         bool movingBackwardsMovedPositionToStartOfCurrentWord = positionAfterCurrentWord == previousWordPosition(nextWordPosition(originalPosition));
 728         if (movingBackwardsMovedPositionToStartOfCurrentWord)
 729             positionAfterCurrentWord = positionAfterSpacingAndFollowingWord;
 730     }
 731     return positionAfterCurrentWord;
 732 }
 733 
 734 #if ENABLE(USERSELECT_ALL)
 735 static void adjustPositionForUserSelectAll(VisiblePosition&amp; pos, bool isForward)
 736 {
 737     if (Node* rootUserSelectAll = Position::rootUserSelectAllForNode(pos.deepEquivalent().anchorNode()))
 738         pos = isForward ? positionAfterNode(rootUserSelectAll).downstream(CanCrossEditingBoundary) : positionBeforeNode(rootUserSelectAll).upstream(CanCrossEditingBoundary);
 739 }
 740 #endif
 741 
 742 VisiblePosition FrameSelection::modifyExtendingRight(TextGranularity granularity)
 743 {
 744     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 745 
 746     // The difference between modifyExtendingRight and modifyExtendingForward is:
 747     // modifyExtendingForward always extends forward logically.
 748     // modifyExtendingRight behaves the same as modifyExtendingForward except for extending character or word,
 749     // it extends forward logically if the enclosing block is TextDirection::LTR,
 750     // but it extends backward logically if the enclosing block is TextDirection::RTL.
 751     switch (granularity) {
 752     case CharacterGranularity:
 753         if (directionOfEnclosingBlock() == TextDirection::LTR)
 754             pos = pos.next(CannotCrossEditingBoundary);
 755         else
 756             pos = pos.previous(CannotCrossEditingBoundary);
 757         break;
 758     case WordGranularity:
 759         if (directionOfEnclosingBlock() == TextDirection::LTR)
 760             pos = nextWordPositionForPlatform(pos);
 761         else
 762             pos = previousWordPosition(pos);
 763         break;
 764     case LineBoundary:
 765         if (directionOfEnclosingBlock() == TextDirection::LTR)
 766             pos = modifyExtendingForward(granularity);
 767         else
 768             pos = modifyExtendingBackward(granularity);
 769         break;
 770     case SentenceGranularity:
 771     case LineGranularity:
 772     case ParagraphGranularity:
 773     case SentenceBoundary:
 774     case ParagraphBoundary:
 775     case DocumentBoundary:
 776         // FIXME: implement all of the above?
 777         pos = modifyExtendingForward(granularity);
 778         break;
 779     case DocumentGranularity:
 780         ASSERT_NOT_REACHED();
 781         break;
 782     }
 783 #if ENABLE(USERSELECT_ALL)
 784     adjustPositionForUserSelectAll(pos, directionOfEnclosingBlock() == TextDirection::LTR);
 785 #endif
 786     return pos;
 787 }
 788 
 789 VisiblePosition FrameSelection::modifyExtendingForward(TextGranularity granularity)
 790 {
 791     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 792     switch (granularity) {
 793     case CharacterGranularity:
 794         pos = pos.next(CannotCrossEditingBoundary);
 795         break;
 796     case WordGranularity:
 797         pos = nextWordPositionForPlatform(pos);
 798         break;
 799     case SentenceGranularity:
 800         pos = nextSentencePosition(pos);
 801         break;
 802     case LineGranularity:
 803         pos = nextLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
 804         break;
 805     case ParagraphGranularity:
 806         pos = nextParagraphPosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
 807         break;
 808     case DocumentGranularity:
 809         ASSERT_NOT_REACHED();
 810         break;
 811     case SentenceBoundary:
 812         pos = endOfSentence(endForPlatform());
 813         break;
 814     case LineBoundary:
 815         pos = logicalEndOfLine(endForPlatform());
 816         break;
 817     case ParagraphBoundary:
 818         pos = endOfParagraph(endForPlatform());
 819         break;
 820     case DocumentBoundary:
 821         pos = endForPlatform();
 822         if (isEditablePosition(pos.deepEquivalent()))
 823             pos = endOfEditableContent(pos);
 824         else
 825             pos = endOfDocument(pos);
 826         break;
 827     }
 828 #if ENABLE(USERSELECT_ALL)
 829     adjustPositionForUserSelectAll(pos, directionOfEnclosingBlock() == TextDirection::LTR);
 830 #endif
 831     return pos;
 832 }
 833 
 834 VisiblePosition FrameSelection::modifyMovingRight(TextGranularity granularity, bool* reachedBoundary)
 835 {
 836     if (reachedBoundary)
 837         *reachedBoundary = false;
 838     VisiblePosition pos;
 839     switch (granularity) {
 840     case CharacterGranularity:
 841         if (isRange()) {
 842             if (directionOfSelection() == TextDirection::LTR)
 843                 pos = VisiblePosition(m_selection.end(), m_selection.affinity());
 844             else
 845                 pos = VisiblePosition(m_selection.start(), m_selection.affinity());
 846         } else
 847             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).right(true, reachedBoundary);
 848         break;
 849     case WordGranularity: {
 850         bool skipsSpaceWhenMovingRight = m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight();
 851         VisiblePosition currentPosition(m_selection.extent(), m_selection.affinity());
 852         pos = rightWordPosition(currentPosition, skipsSpaceWhenMovingRight);
 853         if (reachedBoundary)
 854             *reachedBoundary = pos == currentPosition;
 855         break;
 856     }
 857     case SentenceGranularity:
 858     case LineGranularity:
 859     case ParagraphGranularity:
 860     case SentenceBoundary:
 861     case ParagraphBoundary:
 862     case DocumentBoundary:
 863         // FIXME: Implement all of the above.
 864         pos = modifyMovingForward(granularity, reachedBoundary);
 865         break;
 866     case LineBoundary:
 867         pos = rightBoundaryOfLine(startForPlatform(), directionOfEnclosingBlock(), reachedBoundary);
 868         break;
 869     case DocumentGranularity:
 870         ASSERT_NOT_REACHED();
 871         break;
 872     }
 873     return pos;
 874 }
 875 
 876 VisiblePosition FrameSelection::modifyMovingForward(TextGranularity granularity, bool* reachedBoundary)
 877 {
 878     if (reachedBoundary)
 879         *reachedBoundary = false;
 880     VisiblePosition currentPosition;
 881     switch (granularity) {
 882     case WordGranularity:
 883     case SentenceGranularity:
 884         currentPosition = VisiblePosition(m_selection.extent(), m_selection.affinity());
 885         break;
 886     case LineGranularity:
 887     case ParagraphGranularity:
 888     case SentenceBoundary:
 889     case ParagraphBoundary:
 890     case DocumentBoundary:
 891         currentPosition = endForPlatform();
 892         break;
 893     default:
 894         break;
 895     }
 896     VisiblePosition pos;
 897     // FIXME: Stay in editable content for the less common granularities.
 898     switch (granularity) {
 899     case CharacterGranularity:
 900         if (isRange())
 901             pos = VisiblePosition(m_selection.end(), m_selection.affinity());
 902         else
 903             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).next(CannotCrossEditingBoundary, reachedBoundary);
 904         break;
 905     case WordGranularity:
 906         pos = nextWordPositionForPlatform(currentPosition);
 907         break;
 908     case SentenceGranularity:
 909         pos = nextSentencePosition(currentPosition);
 910         break;
 911     case LineGranularity: {
 912         // down-arrowing from a range selection that ends at the start of a line needs
 913         // to leave the selection at that line start (no need to call nextLinePosition!)
 914         pos = currentPosition;
 915         if (!isRange() || !isStartOfLine(pos))
 916             pos = nextLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(START));
 917         break;
 918     }
 919     case ParagraphGranularity:
 920         pos = nextParagraphPosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
 921         break;
 922     case DocumentGranularity:
 923         ASSERT_NOT_REACHED();
 924         break;
 925     case SentenceBoundary:
 926         pos = endOfSentence(currentPosition);
 927         break;
 928     case LineBoundary:
 929         pos = logicalEndOfLine(endForPlatform(), reachedBoundary);
 930         break;
 931     case ParagraphBoundary:
 932         pos = endOfParagraph(currentPosition);
 933         break;
 934     case DocumentBoundary:
 935         pos = currentPosition;
 936         if (isEditablePosition(pos.deepEquivalent()))
 937             pos = endOfEditableContent(pos);
 938         else
 939             pos = endOfDocument(pos);
 940         break;
 941     }
 942     switch (granularity) {
 943     case WordGranularity:
 944     case SentenceGranularity:
 945     case LineGranularity:
 946     case ParagraphGranularity:
 947     case SentenceBoundary:
 948     case ParagraphBoundary:
 949     case DocumentBoundary:
 950         if (reachedBoundary)
 951             *reachedBoundary = pos == currentPosition;
 952         break;
 953     default:
 954         break;
 955     }
 956     return pos;
 957 }
 958 
 959 VisiblePosition FrameSelection::modifyExtendingLeft(TextGranularity granularity)
 960 {
 961     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
 962 
 963     // The difference between modifyExtendingLeft and modifyExtendingBackward is:
 964     // modifyExtendingBackward always extends backward logically.
 965     // modifyExtendingLeft behaves the same as modifyExtendingBackward except for extending character or word,
 966     // it extends backward logically if the enclosing block is TextDirection::LTR,
 967     // but it extends forward logically if the enclosing block is TextDirection::RTL.
 968     switch (granularity) {
 969     case CharacterGranularity:
 970         if (directionOfEnclosingBlock() == TextDirection::LTR)
 971             pos = pos.previous(CannotCrossEditingBoundary);
 972         else
 973             pos = pos.next(CannotCrossEditingBoundary);
 974         break;
 975     case WordGranularity:
 976         if (directionOfEnclosingBlock() == TextDirection::LTR)
 977             pos = previousWordPosition(pos);
 978         else
 979             pos = nextWordPositionForPlatform(pos);
 980         break;
 981     case LineBoundary:
 982         if (directionOfEnclosingBlock() == TextDirection::LTR)
 983             pos = modifyExtendingBackward(granularity);
 984         else
 985             pos = modifyExtendingForward(granularity);
 986         break;
 987     case SentenceGranularity:
 988     case LineGranularity:
 989     case ParagraphGranularity:
 990     case SentenceBoundary:
 991     case ParagraphBoundary:
 992     case DocumentBoundary:
 993         pos = modifyExtendingBackward(granularity);
 994         break;
 995     case DocumentGranularity:
 996         ASSERT_NOT_REACHED();
 997         break;
 998     }
 999 #if ENABLE(USERSELECT_ALL)
1000     adjustPositionForUserSelectAll(pos, !(directionOfEnclosingBlock() == TextDirection::LTR));
1001 #endif
1002     return pos;
1003 }
1004 
1005 VisiblePosition FrameSelection::modifyExtendingBackward(TextGranularity granularity)
1006 {
1007     VisiblePosition pos(m_selection.extent(), m_selection.affinity());
1008 
1009     // Extending a selection backward by word or character from just after a table selects
1010     // the table.  This &quot;makes sense&quot; from the user perspective, esp. when deleting.
1011     // It was done here instead of in VisiblePosition because we want VPs to iterate
1012     // over everything.
1013     switch (granularity) {
1014     case CharacterGranularity:
1015         pos = pos.previous(CannotCrossEditingBoundary);
1016         break;
1017     case WordGranularity:
1018         pos = previousWordPosition(pos);
1019         break;
1020     case SentenceGranularity:
1021         pos = previousSentencePosition(pos);
1022         break;
1023     case LineGranularity:
1024         pos = previousLinePosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
1025         break;
1026     case ParagraphGranularity:
1027         pos = previousParagraphPosition(pos, lineDirectionPointForBlockDirectionNavigation(EXTENT));
1028         break;
1029     case SentenceBoundary:
1030         pos = startOfSentence(startForPlatform());
1031         break;
1032     case LineBoundary:
1033         pos = logicalStartOfLine(startForPlatform());
1034         break;
1035     case ParagraphBoundary:
1036         pos = startOfParagraph(startForPlatform());
1037         break;
1038     case DocumentBoundary:
1039         pos = startForPlatform();
1040         if (isEditablePosition(pos.deepEquivalent()))
1041             pos = startOfEditableContent(pos);
1042         else
1043             pos = startOfDocument(pos);
1044         break;
1045     case DocumentGranularity:
1046         ASSERT_NOT_REACHED();
1047         break;
1048     }
1049 #if ENABLE(USERSELECT_ALL)
1050     adjustPositionForUserSelectAll(pos, !(directionOfEnclosingBlock() == TextDirection::LTR));
1051 #endif
1052     return pos;
1053 }
1054 
1055 VisiblePosition FrameSelection::modifyMovingLeft(TextGranularity granularity, bool* reachedBoundary)
1056 {
1057     if (reachedBoundary)
1058         *reachedBoundary = false;
1059     VisiblePosition pos;
1060     switch (granularity) {
1061     case CharacterGranularity:
1062         if (isRange())
1063             if (directionOfSelection() == TextDirection::LTR)
1064                 pos = VisiblePosition(m_selection.start(), m_selection.affinity());
1065             else
1066                 pos = VisiblePosition(m_selection.end(), m_selection.affinity());
1067         else
1068             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).left(true, reachedBoundary);
1069         break;
1070     case WordGranularity: {
1071         bool skipsSpaceWhenMovingRight = m_frame &amp;&amp; m_frame-&gt;editor().behavior().shouldSkipSpaceWhenMovingRight();
1072         VisiblePosition currentPosition(m_selection.extent(), m_selection.affinity());
1073         pos = leftWordPosition(currentPosition, skipsSpaceWhenMovingRight);
1074         if (reachedBoundary)
1075             *reachedBoundary = pos == currentPosition;
1076         break;
1077     }
1078     case SentenceGranularity:
1079     case LineGranularity:
1080     case ParagraphGranularity:
1081     case SentenceBoundary:
1082     case ParagraphBoundary:
1083     case DocumentBoundary:
1084         // FIXME: Implement all of the above.
1085         pos = modifyMovingBackward(granularity, reachedBoundary);
1086         break;
1087     case LineBoundary:
1088         pos = leftBoundaryOfLine(startForPlatform(), directionOfEnclosingBlock(), reachedBoundary);
1089         break;
1090     case DocumentGranularity:
1091         ASSERT_NOT_REACHED();
1092         break;
1093     }
1094     return pos;
1095 }
1096 
1097 VisiblePosition FrameSelection::modifyMovingBackward(TextGranularity granularity, bool* reachedBoundary)
1098 {
1099     if (reachedBoundary)
1100         *reachedBoundary = false;
1101     VisiblePosition currentPosition;
1102     switch (granularity) {
1103     case WordGranularity:
1104     case SentenceGranularity:
1105         currentPosition = VisiblePosition(m_selection.extent(), m_selection.affinity());
1106         break;
1107     case LineGranularity:
1108     case ParagraphGranularity:
1109     case SentenceBoundary:
1110     case ParagraphBoundary:
1111     case DocumentBoundary:
1112         currentPosition = startForPlatform();
1113         break;
1114     default:
1115         break;
1116     }
1117     VisiblePosition pos;
1118     switch (granularity) {
1119     case CharacterGranularity:
1120         if (isRange())
1121             pos = VisiblePosition(m_selection.start(), m_selection.affinity());
1122         else
1123             pos = VisiblePosition(m_selection.extent(), m_selection.affinity()).previous(CannotCrossEditingBoundary, reachedBoundary);
1124         break;
1125     case WordGranularity:
1126         pos = previousWordPosition(currentPosition);
1127         break;
1128     case SentenceGranularity:
1129         pos = previousSentencePosition(currentPosition);
1130         break;
1131     case LineGranularity:
1132         pos = previousLinePosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
1133         break;
1134     case ParagraphGranularity:
1135         pos = previousParagraphPosition(currentPosition, lineDirectionPointForBlockDirectionNavigation(START));
1136         break;
1137     case SentenceBoundary:
1138         pos = startOfSentence(currentPosition);
1139         break;
1140     case LineBoundary:
1141         pos = logicalStartOfLine(startForPlatform(), reachedBoundary);
1142         break;
1143     case ParagraphBoundary:
1144         pos = startOfParagraph(currentPosition);
1145         break;
1146     case DocumentBoundary:
1147         pos = currentPosition;
1148         if (isEditablePosition(pos.deepEquivalent()))
1149             pos = startOfEditableContent(pos);
1150         else
1151             pos = startOfDocument(pos);
1152         break;
1153     case DocumentGranularity:
1154         ASSERT_NOT_REACHED();
1155         break;
1156     }
1157     switch (granularity) {
1158     case WordGranularity:
1159     case SentenceGranularity:
1160     case LineGranularity:
1161     case ParagraphGranularity:
1162     case SentenceBoundary:
1163     case ParagraphBoundary:
1164     case DocumentBoundary:
1165         if (reachedBoundary)
1166             *reachedBoundary = pos == currentPosition;
1167         break;
1168     default:
1169         break;
1170     }
1171     return pos;
1172 }
1173 
1174 static bool isBoundary(TextGranularity granularity)
1175 {
1176     return granularity == LineBoundary || granularity == ParagraphBoundary || granularity == DocumentBoundary;
1177 }
1178 
1179 AXTextStateChangeIntent FrameSelection::textSelectionIntent(EAlteration alter, SelectionDirection direction, TextGranularity granularity)
1180 {
1181     AXTextStateChangeIntent intent = AXTextStateChangeIntent();
1182     bool flip = false;
1183     if (alter == FrameSelection::AlterationMove) {
1184         intent.type = AXTextStateChangeTypeSelectionMove;
1185         flip = isRange() &amp;&amp; directionOfSelection() == TextDirection::RTL;
1186     } else
1187         intent.type = AXTextStateChangeTypeSelectionExtend;
1188     switch (granularity) {
1189     case CharacterGranularity:
1190         intent.selection.granularity = AXTextSelectionGranularityCharacter;
1191         break;
1192     case WordGranularity:
1193         intent.selection.granularity = AXTextSelectionGranularityWord;
1194         break;
1195     case SentenceGranularity:
1196     case SentenceBoundary:
1197         intent.selection.granularity = AXTextSelectionGranularitySentence;
1198         break;
1199     case LineGranularity:
1200     case LineBoundary:
1201         intent.selection.granularity = AXTextSelectionGranularityLine;
1202         break;
1203     case ParagraphGranularity:
1204     case ParagraphBoundary:
1205         intent.selection.granularity = AXTextSelectionGranularityParagraph;
1206         break;
1207     case DocumentGranularity:
1208     case DocumentBoundary:
1209         intent.selection.granularity = AXTextSelectionGranularityDocument;
1210         break;
1211     }
1212     bool boundary = false;
1213     switch (granularity) {
1214     case CharacterGranularity:
1215     case WordGranularity:
1216     case SentenceGranularity:
1217     case LineGranularity:
1218     case ParagraphGranularity:
1219     case DocumentGranularity:
1220         break;
1221     case SentenceBoundary:
1222     case LineBoundary:
1223     case ParagraphBoundary:
1224     case DocumentBoundary:
1225         boundary = true;
1226         break;
1227     }
1228     switch (direction) {
1229     case DirectionRight:
1230     case DirectionForward:
1231         if (boundary)
1232             intent.selection.direction = flip ? AXTextSelectionDirectionBeginning : AXTextSelectionDirectionEnd;
1233         else
1234             intent.selection.direction = flip ? AXTextSelectionDirectionPrevious : AXTextSelectionDirectionNext;
1235         break;
1236     case DirectionLeft:
1237     case DirectionBackward:
1238         if (boundary)
1239             intent.selection.direction = flip ? AXTextSelectionDirectionEnd : AXTextSelectionDirectionBeginning;
1240         else
1241             intent.selection.direction = flip ? AXTextSelectionDirectionNext : AXTextSelectionDirectionPrevious;
1242         break;
1243     }
1244     return intent;
1245 }
1246 
1247 static AXTextSelection textSelectionWithDirectionAndGranularity(SelectionDirection direction, TextGranularity granularity)
1248 {
1249     // FIXME: Account for BIDI in DirectionRight &amp; DirectionLeft. (In a RTL block, Right would map to Previous/Beginning and Left to Next/End.)
1250     AXTextSelectionDirection intentDirection = AXTextSelectionDirectionUnknown;
1251     switch (direction) {
1252     case DirectionForward:
1253         intentDirection = AXTextSelectionDirectionNext;
1254         break;
1255     case DirectionRight:
1256         intentDirection = AXTextSelectionDirectionNext;
1257         break;
1258     case DirectionBackward:
1259         intentDirection = AXTextSelectionDirectionPrevious;
1260         break;
1261     case DirectionLeft:
1262         intentDirection = AXTextSelectionDirectionPrevious;
1263         break;
1264     }
1265     AXTextSelectionGranularity intentGranularity = AXTextSelectionGranularityUnknown;
1266     switch (granularity) {
1267     case CharacterGranularity:
1268         intentGranularity = AXTextSelectionGranularityCharacter;
1269         break;
1270     case WordGranularity:
1271         intentGranularity = AXTextSelectionGranularityWord;
1272         break;
1273     case SentenceGranularity:
1274     case SentenceBoundary: // FIXME: Boundary should affect direction.
1275         intentGranularity = AXTextSelectionGranularitySentence;
1276         break;
1277     case LineGranularity:
1278         intentGranularity = AXTextSelectionGranularityLine;
1279         break;
1280     case ParagraphGranularity:
1281     case ParagraphBoundary: // FIXME: Boundary should affect direction.
1282         intentGranularity = AXTextSelectionGranularityParagraph;
1283         break;
1284     case DocumentGranularity:
1285     case DocumentBoundary: // FIXME: Boundary should affect direction.
1286         intentGranularity = AXTextSelectionGranularityDocument;
1287         break;
1288     case LineBoundary:
1289         intentGranularity = AXTextSelectionGranularityLine;
1290         switch (direction) {
1291         case DirectionForward:
1292             intentDirection = AXTextSelectionDirectionEnd;
1293             break;
1294         case DirectionRight:
1295             intentDirection = AXTextSelectionDirectionEnd;
1296             break;
1297         case DirectionBackward:
1298             intentDirection = AXTextSelectionDirectionBeginning;
1299             break;
1300         case DirectionLeft:
1301             intentDirection = AXTextSelectionDirectionBeginning;
1302             break;
1303         }
1304         break;
1305     }
1306     return { intentDirection, intentGranularity, false };
1307 }
1308 
1309 bool FrameSelection::modify(EAlteration alter, SelectionDirection direction, TextGranularity granularity, EUserTriggered userTriggered)
1310 {
1311     if (userTriggered == UserTriggered) {
1312         FrameSelection trialFrameSelection;
1313         trialFrameSelection.setSelection(m_selection);
1314         trialFrameSelection.modify(alter, direction, granularity, NotUserTriggered);
1315 
1316         bool change = shouldChangeSelection(trialFrameSelection.selection());
1317         if (!change)
1318             return false;
1319 
1320         if (trialFrameSelection.selection().isRange() &amp;&amp; m_selection.isCaret() &amp;&amp; !dispatchSelectStart())
1321             return false;
1322     }
1323 
1324     willBeModified(alter, direction);
1325 
1326     bool reachedBoundary = false;
1327     bool wasRange = m_selection.isRange();
1328     Position originalStartPosition = m_selection.start();
1329     VisiblePosition position;
1330     switch (direction) {
1331     case DirectionRight:
1332         if (alter == AlterationMove)
1333             position = modifyMovingRight(granularity, &amp;reachedBoundary);
1334         else
1335             position = modifyExtendingRight(granularity);
1336         break;
1337     case DirectionForward:
1338         if (alter == AlterationExtend)
1339             position = modifyExtendingForward(granularity);
1340         else
1341             position = modifyMovingForward(granularity, &amp;reachedBoundary);
1342         break;
1343     case DirectionLeft:
1344         if (alter == AlterationMove)
1345             position = modifyMovingLeft(granularity, &amp;reachedBoundary);
1346         else
1347             position = modifyExtendingLeft(granularity);
1348         break;
1349     case DirectionBackward:
1350         if (alter == AlterationExtend)
1351             position = modifyExtendingBackward(granularity);
1352         else
1353             position = modifyMovingBackward(granularity, &amp;reachedBoundary);
1354         break;
1355     }
1356 
1357     if (reachedBoundary &amp;&amp; !isRange() &amp;&amp; userTriggered == UserTriggered &amp;&amp; m_frame &amp;&amp; AXObjectCache::accessibilityEnabled()) {
1358         notifyAccessibilityForSelectionChange({ AXTextStateChangeTypeSelectionBoundary, textSelectionWithDirectionAndGranularity(direction, granularity) });
1359         return true;
1360     }
1361 
1362     if (position.isNull())
1363         return false;
1364 
1365     if (isSpatialNavigationEnabled(m_frame))
1366         if (!wasRange &amp;&amp; alter == AlterationMove &amp;&amp; position == originalStartPosition)
1367             return false;
1368 
1369     if (m_frame &amp;&amp; AXObjectCache::accessibilityEnabled()) {
1370         if (AXObjectCache* cache = m_frame-&gt;document()-&gt;existingAXObjectCache())
1371             cache-&gt;setTextSelectionIntent(textSelectionIntent(alter, direction, granularity));
1372     }
1373 
1374     // Some of the above operations set an xPosForVerticalArrowNavigation.
1375     // Setting a selection will clear it, so save it to possibly restore later.
1376     // Note: the START position type is arbitrary because it is unused, it would be
1377     // the requested position type if there were no xPosForVerticalArrowNavigation set.
1378     LayoutUnit x = lineDirectionPointForBlockDirectionNavigation(START);
1379     m_selection.setIsDirectional(shouldAlwaysUseDirectionalSelection(m_frame) || alter == AlterationExtend);
1380 
1381     switch (alter) {
1382     case AlterationMove:
1383         moveTo(position, userTriggered);
1384         break;
1385     case AlterationExtend:
1386 
1387         if (!m_selection.isCaret()
1388             &amp;&amp; (granularity == WordGranularity || granularity == ParagraphGranularity || granularity == LineGranularity)
1389             &amp;&amp; m_frame &amp;&amp; !m_frame-&gt;editor().behavior().shouldExtendSelectionByWordOrLineAcrossCaret()) {
1390             // Don&#39;t let the selection go across the base position directly. Needed to match mac
1391             // behavior when, for instance, word-selecting backwards starting with the caret in
1392             // the middle of a word and then word-selecting forward, leaving the caret in the
1393             // same place where it was, instead of directly selecting to the end of the word.
1394             VisibleSelection newSelection = m_selection;
1395             newSelection.setExtent(position);
1396             if (m_selection.isBaseFirst() != newSelection.isBaseFirst())
1397                 position = m_selection.base();
1398         }
1399 
1400         // Standard Mac behavior when extending to a boundary is grow the selection rather than leaving the
1401         // base in place and moving the extent. Matches NSTextView.
1402         if (!m_frame || !m_frame-&gt;editor().behavior().shouldAlwaysGrowSelectionWhenExtendingToBoundary() || m_selection.isCaret() || !isBoundary(granularity))
1403             setExtent(position, userTriggered);
1404         else {
1405             TextDirection textDirection = directionOfEnclosingBlock();
1406             if (direction == DirectionForward || (textDirection == TextDirection::LTR &amp;&amp; direction == DirectionRight) || (textDirection == TextDirection::RTL &amp;&amp; direction == DirectionLeft))
1407                 setEnd(position, userTriggered);
1408             else
1409                 setStart(position, userTriggered);
1410         }
1411         break;
1412     }
1413 
1414     if (granularity == LineGranularity || granularity == ParagraphGranularity)
1415         m_xPosForVerticalArrowNavigation = x;
1416 
1417     if (userTriggered == UserTriggered)
1418         m_granularity = CharacterGranularity;
1419 
1420     setCaretRectNeedsUpdate();
1421 
1422     return true;
1423 }
1424 
1425 // FIXME: Maybe baseline would be better?
1426 static bool absoluteCaretY(const VisiblePosition &amp;c, int &amp;y)
1427 {
1428     IntRect rect = c.absoluteCaretBounds();
1429     if (rect.isEmpty())
1430         return false;
1431     y = rect.y() + rect.height() / 2;
1432     return true;
1433 }
1434 
1435 bool FrameSelection::modify(EAlteration alter, unsigned verticalDistance, VerticalDirection direction, EUserTriggered userTriggered, CursorAlignOnScroll align)
1436 {
1437     if (!verticalDistance)
1438         return false;
1439 
1440     if (userTriggered == UserTriggered) {
1441         FrameSelection trialFrameSelection;
1442         trialFrameSelection.setSelection(m_selection);
1443         trialFrameSelection.modify(alter, verticalDistance, direction, NotUserTriggered);
1444 
1445         bool change = shouldChangeSelection(trialFrameSelection.selection());
1446         if (!change)
1447             return false;
1448     }
1449 
1450     willBeModified(alter, direction == DirectionUp ? DirectionBackward : DirectionForward);
1451 
1452     VisiblePosition pos;
1453     LayoutUnit xPos;
1454     switch (alter) {
1455     case AlterationMove:
1456         pos = VisiblePosition(direction == DirectionUp ? m_selection.start() : m_selection.end(), m_selection.affinity());
1457         xPos = lineDirectionPointForBlockDirectionNavigation(direction == DirectionUp ? START : END);
1458         m_selection.setAffinity(direction == DirectionUp ? UPSTREAM : DOWNSTREAM);
1459         break;
1460     case AlterationExtend:
1461         pos = VisiblePosition(m_selection.extent(), m_selection.affinity());
1462         xPos = lineDirectionPointForBlockDirectionNavigation(EXTENT);
1463         m_selection.setAffinity(DOWNSTREAM);
1464         break;
1465     }
1466 
1467     int startY;
1468     if (!absoluteCaretY(pos, startY))
1469         return false;
1470     if (direction == DirectionUp)
1471         startY = -startY;
1472     int lastY = startY;
1473 
1474     VisiblePosition result;
1475     VisiblePosition next;
1476     for (VisiblePosition p = pos; ; p = next) {
1477         if (direction == DirectionUp)
1478             next = previousLinePosition(p, xPos);
1479         else
1480             next = nextLinePosition(p, xPos);
1481 
1482         if (next.isNull() || next == p)
1483             break;
1484         int nextY;
1485         if (!absoluteCaretY(next, nextY))
1486             break;
1487         if (direction == DirectionUp)
1488             nextY = -nextY;
1489         if (nextY - startY &gt; static_cast&lt;int&gt;(verticalDistance))
1490             break;
1491         if (nextY &gt;= lastY) {
1492             lastY = nextY;
1493             result = next;
1494         }
1495     }
1496 
1497     if (result.isNull())
1498         return false;
1499 
1500     switch (alter) {
1501     case AlterationMove:
1502         moveTo(result, userTriggered, align);
1503         break;
1504     case AlterationExtend:
1505         setExtent(result, userTriggered);
1506         break;
1507     }
1508 
1509     if (userTriggered == UserTriggered)
1510         m_granularity = CharacterGranularity;
1511 
1512     m_selection.setIsDirectional(shouldAlwaysUseDirectionalSelection(m_frame) || alter == AlterationExtend);
1513 
1514     return true;
1515 }
1516 
1517 LayoutUnit FrameSelection::lineDirectionPointForBlockDirectionNavigation(EPositionType type)
1518 {
1519     LayoutUnit x;
1520 
1521     if (isNone())
1522         return x;
1523 
1524     Position pos;
1525     switch (type) {
1526     case START:
1527         pos = m_selection.start();
1528         break;
1529     case END:
1530         pos = m_selection.end();
1531         break;
1532     case BASE:
1533         pos = m_selection.base();
1534         break;
1535     case EXTENT:
1536         pos = m_selection.extent();
1537         break;
1538     }
1539 
1540     Frame* frame = pos.anchorNode()-&gt;document().frame();
1541     if (!frame)
1542         return x;
1543 
1544     if (m_xPosForVerticalArrowNavigation == NoXPosForVerticalArrowNavigation()) {
1545         VisiblePosition visiblePosition(pos, m_selection.affinity());
1546         // VisiblePosition creation can fail here if a node containing the selection becomes visibility:hidden
1547         // after the selection is created and before this function is called.
1548         x = visiblePosition.isNotNull() ? visiblePosition.lineDirectionPointForBlockDirectionNavigation() : 0;
1549         m_xPosForVerticalArrowNavigation = x;
1550     } else
1551         x = m_xPosForVerticalArrowNavigation;
1552 
1553     return x;
1554 }
1555 
1556 void FrameSelection::clear()
1557 {
1558     m_granularity = CharacterGranularity;
1559     setSelection(VisibleSelection());
1560 }
1561 
1562 void FrameSelection::prepareForDestruction()
1563 {
1564     m_granularity = CharacterGranularity;
1565 
1566 #if ENABLE(TEXT_CARET)
1567     m_caretBlinkTimer.stop();
1568 #endif
1569 
1570     if (auto* view = m_frame-&gt;contentRenderer())
1571         view-&gt;selection().clear();
1572 
1573     setSelectionWithoutUpdatingAppearance(VisibleSelection(), defaultSetSelectionOptions(), AlignCursorOnScrollIfNeeded, CharacterGranularity);
1574     m_previousCaretNode = nullptr;
1575     m_typingStyle = nullptr;
1576     m_appearanceUpdateTimer.stop();
1577 }
1578 
1579 void FrameSelection::setStart(const VisiblePosition &amp;pos, EUserTriggered trigger)
1580 {
1581     if (m_selection.isBaseFirst())
1582         setBase(pos, trigger);
1583     else
1584         setExtent(pos, trigger);
1585 }
1586 
1587 void FrameSelection::setEnd(const VisiblePosition &amp;pos, EUserTriggered trigger)
1588 {
1589     if (m_selection.isBaseFirst())
1590         setExtent(pos, trigger);
1591     else
1592         setBase(pos, trigger);
1593 }
1594 
1595 void FrameSelection::setBase(const VisiblePosition &amp;pos, EUserTriggered userTriggered)
1596 {
1597     const bool selectionHasDirection = true;
1598     setSelection(VisibleSelection(pos.deepEquivalent(), m_selection.extent(), pos.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1599 }
1600 
1601 void FrameSelection::setExtent(const VisiblePosition &amp;pos, EUserTriggered userTriggered)
1602 {
1603     const bool selectionHasDirection = true;
1604     setSelection(VisibleSelection(m_selection.base(), pos.deepEquivalent(), pos.affinity(), selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1605 }
1606 
1607 void FrameSelection::setBase(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
1608 {
1609     const bool selectionHasDirection = true;
1610     setSelection(VisibleSelection(pos, m_selection.extent(), affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1611 }
1612 
1613 void FrameSelection::setExtent(const Position &amp;pos, EAffinity affinity, EUserTriggered userTriggered)
1614 {
1615     const bool selectionHasDirection = true;
1616     setSelection(VisibleSelection(m_selection.base(), pos, affinity, selectionHasDirection), defaultSetSelectionOptions(userTriggered));
1617 }
1618 
1619 void CaretBase::clearCaretRect()
1620 {
1621     m_caretLocalRect = LayoutRect();
1622 }
1623 
1624 bool CaretBase::updateCaretRect(Document* document, const VisiblePosition&amp; caretPosition)
1625 {
1626     document-&gt;updateLayoutIgnorePendingStylesheets();
1627     m_caretRectNeedsUpdate = false;
1628     RenderBlock* renderer;
1629     m_caretLocalRect = localCaretRectInRendererForCaretPainting(caretPosition, renderer);
1630     return !m_caretLocalRect.isEmpty();
1631 }
1632 
1633 RenderBlock* FrameSelection::caretRendererWithoutUpdatingLayout() const
1634 {
1635     return rendererForCaretPainting(m_selection.start().deprecatedNode());
1636 }
1637 
1638 RenderBlock* DragCaretController::caretRenderer() const
1639 {
1640     return rendererForCaretPainting(m_position.deepEquivalent().deprecatedNode());
1641 }
1642 
1643 static bool isNonOrphanedCaret(const VisibleSelection&amp; selection)
1644 {
1645     return selection.isCaret() &amp;&amp; !selection.start().isOrphan() &amp;&amp; !selection.end().isOrphan();
1646 }
1647 
1648 IntRect FrameSelection::absoluteCaretBounds(bool* insideFixed)
1649 {
1650     if (!m_frame)
1651         return IntRect();
1652     updateSelectionByUpdatingLayoutOrStyle(*m_frame);
1653     recomputeCaretRect();
1654     if (insideFixed)
1655         *insideFixed = m_caretInsidePositionFixed;
1656     return m_absCaretBounds;
1657 }
1658 
1659 static void repaintCaretForLocalRect(Node* node, const LayoutRect&amp; rect)
1660 {
1661     if (auto* caretPainter = rendererForCaretPainting(node))
1662         caretPainter-&gt;repaintRectangle(rect);
1663 }
1664 
1665 bool FrameSelection::recomputeCaretRect()
1666 {
1667     if (!shouldUpdateCaretRect())
1668         return false;
1669 
1670     if (!m_frame)
1671         return false;
1672 
1673     FrameView* v = m_frame-&gt;document()-&gt;view();
1674     if (!v)
1675         return false;
1676 
1677     LayoutRect oldRect = localCaretRectWithoutUpdate();
1678 
1679     RefPtr&lt;Node&gt; caretNode = m_previousCaretNode;
1680     if (shouldUpdateCaretRect()) {
1681         if (!isNonOrphanedCaret(m_selection))
1682             clearCaretRect();
1683         else {
1684             VisiblePosition visibleStart = m_selection.visibleStart();
1685             if (updateCaretRect(m_frame-&gt;document(), visibleStart)) {
1686                 caretNode = visibleStart.deepEquivalent().deprecatedNode();
1687                 m_absCaretBoundsDirty = true;
1688             }
1689         }
1690     }
1691     LayoutRect newRect = localCaretRectWithoutUpdate();
1692 
1693     if (caretNode == m_previousCaretNode &amp;&amp; oldRect == newRect &amp;&amp; !m_absCaretBoundsDirty)
1694         return false;
1695 
1696     IntRect oldAbsCaretBounds = m_absCaretBounds;
1697     bool isInsideFixed;
1698     m_absCaretBounds = absoluteBoundsForLocalCaretRect(rendererForCaretPainting(caretNode.get()), newRect, &amp;isInsideFixed);
1699     m_caretInsidePositionFixed = isInsideFixed;
1700 
1701     if (m_absCaretBoundsDirty &amp;&amp; m_selection.isCaret()) // We should be able to always assert this condition.
1702         ASSERT(m_absCaretBounds == m_selection.visibleStart().absoluteCaretBounds());
1703 
1704     m_absCaretBoundsDirty = false;
1705 
1706     if (caretNode == m_previousCaretNode &amp;&amp; oldAbsCaretBounds == m_absCaretBounds)
1707         return false;
1708 
1709 #if ENABLE(TEXT_CARET)
1710     if (RenderView* view = m_frame-&gt;document()-&gt;renderView()) {
1711         bool previousOrNewCaretNodeIsContentEditable = m_selection.isContentEditable() || (m_previousCaretNode &amp;&amp; m_previousCaretNode-&gt;isContentEditable());
1712         if (shouldRepaintCaret(view, previousOrNewCaretNodeIsContentEditable)) {
1713             if (m_previousCaretNode)
1714                 repaintCaretForLocalRect(m_previousCaretNode.get(), oldRect);
1715             m_previousCaretNode = caretNode;
1716             repaintCaretForLocalRect(caretNode.get(), newRect);
1717         }
1718     }
1719 #endif
1720     return true;
1721 }
1722 
1723 bool CaretBase::shouldRepaintCaret(const RenderView* view, bool isContentEditable) const
1724 {
1725     ASSERT(view);
1726     Frame* frame = &amp;view-&gt;frameView().frame(); // The frame where the selection started.
1727     bool caretBrowsing = frame &amp;&amp; frame-&gt;settings().caretBrowsingEnabled();
1728     return (caretBrowsing || isContentEditable);
1729 }
1730 
1731 void FrameSelection::invalidateCaretRect()
1732 {
1733     if (!isCaret())
1734         return;
1735 
1736     CaretBase::invalidateCaretRect(m_selection.start().deprecatedNode(), recomputeCaretRect());
1737 }
1738 
1739 void CaretBase::invalidateCaretRect(Node* node, bool caretRectChanged)
1740 {
1741     // EDIT FIXME: This is an unfortunate hack.
1742     // Basically, we can&#39;t trust this layout position since we
1743     // can&#39;t guarantee that the check to see if we are in unrendered
1744     // content will work at this point. We may have to wait for
1745     // a layout and re-render of the document to happen. So, resetting this
1746     // flag will cause another caret layout to happen the first time
1747     // that we try to paint the caret after this call. That one will work since
1748     // it happens after the document has accounted for any editing
1749     // changes which may have been done.
1750     // And, we need to leave this layout here so the caret moves right
1751     // away after clicking.
1752     m_caretRectNeedsUpdate = true;
1753 
1754     if (caretRectChanged)
1755         return;
1756 
1757     if (RenderView* view = node-&gt;document().renderView()) {
1758         if (shouldRepaintCaret(view, isEditableNode(*node)))
1759             repaintCaretForLocalRect(node, localCaretRectWithoutUpdate());
1760     }
1761 }
1762 
1763 void FrameSelection::paintCaret(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect)
1764 {
1765     if (m_selection.isCaret() &amp;&amp; m_caretPaint)
1766         CaretBase::paintCaret(m_selection.start().deprecatedNode(), context, paintOffset, clipRect);
1767 }
1768 
1769 void CaretBase::paintCaret(Node* node, GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect) const
1770 {
1771 #if ENABLE(TEXT_CARET)
1772     if (m_caretVisibility == Hidden)
1773         return;
1774 
1775     LayoutRect drawingRect = localCaretRectWithoutUpdate();
1776     if (auto* renderer = rendererForCaretPainting(node))
1777         renderer-&gt;flipForWritingMode(drawingRect);
1778     drawingRect.moveBy(roundedIntPoint(paintOffset));
1779     LayoutRect caret = intersection(drawingRect, clipRect);
1780     if (caret.isEmpty())
1781         return;
1782 
1783     Color caretColor = Color::black;
1784     Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
1785     if (element &amp;&amp; element-&gt;renderer()) {
1786         auto computeCaretColor = [] (const RenderStyle&amp; elementStyle, const RenderStyle* rootEditableStyle) {
1787             // CSS value &quot;auto&quot; is treated as an invalid color.
1788             if (!elementStyle.caretColor().isValid() &amp;&amp; rootEditableStyle) {
1789                 auto rootEditableBackgroundColor = rootEditableStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1790                 auto elementBackgroundColor = elementStyle.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
1791                 auto disappearsIntoBackground = rootEditableBackgroundColor.blend(elementBackgroundColor) == rootEditableBackgroundColor;
1792                 if (disappearsIntoBackground)
1793                     return rootEditableStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyCaretColor);
1794             }
1795             return elementStyle.visitedDependentColorWithColorFilter(CSSPropertyCaretColor);
1796         };
1797         auto* rootEditableElement = node-&gt;rootEditableElement();
1798         auto* rootEditableStyle = rootEditableElement &amp;&amp; rootEditableElement-&gt;renderer() ? &amp;rootEditableElement-&gt;renderer()-&gt;style() : nullptr;
1799         caretColor = computeCaretColor(element-&gt;renderer()-&gt;style(), rootEditableStyle);
1800     }
1801 
1802     context.fillRect(caret, caretColor);
1803 #else
1804     UNUSED_PARAM(node);
1805     UNUSED_PARAM(context);
1806     UNUSED_PARAM(paintOffset);
1807     UNUSED_PARAM(clipRect);
1808 #endif
1809 }
1810 
1811 void FrameSelection::debugRenderer(RenderObject* renderer, bool selected) const
1812 {
1813     if (is&lt;Element&gt;(*renderer-&gt;node())) {
1814         Element&amp; element = downcast&lt;Element&gt;(*renderer-&gt;node());
1815         fprintf(stderr, &quot;%s%s\n&quot;, selected ? &quot;==&gt; &quot; : &quot;    &quot;, element.localName().string().utf8().data());
1816     } else if (is&lt;RenderText&gt;(*renderer)) {
1817         RenderText&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1818         if (textRenderer.text().isEmpty() || !textRenderer.firstTextBox()) {
1819             fprintf(stderr, &quot;%s#text (empty)\n&quot;, selected ? &quot;==&gt; &quot; : &quot;    &quot;);
1820             return;
1821         }
1822 
1823         static const int max = 36;
1824         String text = textRenderer.text();
1825         int textLength = text.length();
1826         if (selected) {
1827             int offset = 0;
1828             if (renderer-&gt;node() == m_selection.start().containerNode())
1829                 offset = m_selection.start().computeOffsetInContainerNode();
1830             else if (renderer-&gt;node() == m_selection.end().containerNode())
1831                 offset = m_selection.end().computeOffsetInContainerNode();
1832 
1833             int pos;
1834             InlineTextBox* box = textRenderer.findNextInlineTextBox(offset, pos);
1835             text = text.substring(box-&gt;start(), box-&gt;len());
1836 
1837             String show;
1838             int mid = max / 2;
1839             int caret = 0;
1840 
1841             // text is shorter than max
1842             if (textLength &lt; max) {
1843                 show = text;
1844                 caret = pos;
1845             } else if (pos - mid &lt; 0) {
1846                 // too few characters to left
1847                 show = text.left(max - 3) + &quot;...&quot;;
1848                 caret = pos;
1849             } else if (pos - mid &gt;= 0 &amp;&amp; pos + mid &lt;= textLength) {
1850                 // enough characters on each side
1851                 show = &quot;...&quot; + text.substring(pos - mid + 3, max - 6) + &quot;...&quot;;
1852                 caret = mid;
1853             } else {
1854                 // too few characters on right
1855                 show = &quot;...&quot; + text.right(max - 3);
1856                 caret = pos - (textLength - show.length());
1857             }
1858 
1859             show.replace(&#39;\n&#39;, &#39; &#39;);
1860             show.replace(&#39;\r&#39;, &#39; &#39;);
1861             fprintf(stderr, &quot;==&gt; #text : \&quot;%s\&quot; at offset %d\n&quot;, show.utf8().data(), pos);
1862             fprintf(stderr, &quot;           &quot;);
1863             for (int i = 0; i &lt; caret; i++)
1864                 fprintf(stderr, &quot; &quot;);
1865             fprintf(stderr, &quot;^\n&quot;);
1866         } else {
1867             if ((int)text.length() &gt; max)
1868                 text = text.left(max - 3) + &quot;...&quot;;
1869             else
1870                 text = text.left(max);
1871             fprintf(stderr, &quot;    #text : \&quot;%s\&quot;\n&quot;, text.utf8().data());
1872         }
1873     }
1874 }
1875 
1876 bool FrameSelection::contains(const LayoutPoint&amp; point) const
1877 {
1878     // Treat a collapsed selection like no selection.
1879     if (!isRange())
1880         return false;
1881 
1882     auto* document = m_frame-&gt;document();
1883     if (!document)
1884         return false;
1885 
1886     HitTestResult result(point);
1887     document-&gt;hitTest(HitTestRequest(), result);
1888     Node* innerNode = result.innerNode();
1889     if (!innerNode || !innerNode-&gt;renderer())
1890         return false;
1891 
1892     VisiblePosition visiblePos(innerNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
1893     if (visiblePos.isNull())
1894         return false;
1895 
1896     if (m_selection.visibleStart().isNull() || m_selection.visibleEnd().isNull())
1897         return false;
1898 
1899     Position start(m_selection.visibleStart().deepEquivalent());
1900     Position end(m_selection.visibleEnd().deepEquivalent());
1901     Position p(visiblePos.deepEquivalent());
1902 
1903     return comparePositions(start, p) &lt;= 0 &amp;&amp; comparePositions(p, end) &lt;= 0;
1904 }
1905 
1906 // Workaround for the fact that it&#39;s hard to delete a frame.
1907 // Call this after doing user-triggered selections to make it easy to delete the frame you entirely selected.
1908 // Can&#39;t do this implicitly as part of every setSelection call because in some contexts it might not be good
1909 // for the focus to move to another frame. So instead we call it from places where we are selecting with the
1910 // mouse or the keyboard after setting the selection.
1911 void FrameSelection::selectFrameElementInParentIfFullySelected()
1912 {
1913     // Find the parent frame; if there is none, then we have nothing to do.
1914     Frame* parent = m_frame-&gt;tree().parent();
1915     if (!parent)
1916         return;
1917     Page* page = m_frame-&gt;page();
1918     if (!page)
1919         return;
1920 
1921     // Check if the selection contains the entire frame contents; if not, then there is nothing to do.
1922     if (!isRange())
1923         return;
1924     if (!isStartOfDocument(selection().visibleStart()))
1925         return;
1926     if (!isEndOfDocument(selection().visibleEnd()))
1927         return;
1928 
1929     // Get to the &lt;iframe&gt; or &lt;frame&gt; (or even &lt;object&gt;) element in the parent frame.
1930     Element* ownerElement = m_frame-&gt;ownerElement();
1931     if (!ownerElement)
1932         return;
1933     ContainerNode* ownerElementParent = ownerElement-&gt;parentNode();
1934     if (!ownerElementParent)
1935         return;
1936 
1937     // This method&#39;s purpose is it to make it easier to select iframes (in order to delete them).  Don&#39;t do anything if the iframe isn&#39;t deletable.
1938     if (!ownerElementParent-&gt;hasEditableStyle())
1939         return;
1940 
1941     // Create compute positions before and after the element.
1942     unsigned ownerElementNodeIndex = ownerElement-&gt;computeNodeIndex();
1943     VisiblePosition beforeOwnerElement(VisiblePosition(Position(ownerElementParent, ownerElementNodeIndex, Position::PositionIsOffsetInAnchor)));
1944     VisiblePosition afterOwnerElement(VisiblePosition(Position(ownerElementParent, ownerElementNodeIndex + 1, Position::PositionIsOffsetInAnchor), VP_UPSTREAM_IF_POSSIBLE));
1945 
1946     // Focus on the parent frame, and then select from before this element to after.
1947     VisibleSelection newSelection(beforeOwnerElement, afterOwnerElement);
1948     if (parent-&gt;selection().shouldChangeSelection(newSelection)) {
1949         page-&gt;focusController().setFocusedFrame(parent);
1950         parent-&gt;selection().setSelection(newSelection);
1951     }
1952 }
1953 
1954 void FrameSelection::selectAll()
1955 {
1956     Document* document = m_frame-&gt;document();
1957 
1958     Element* focusedElement = document-&gt;focusedElement();
1959     if (is&lt;HTMLSelectElement&gt;(focusedElement)) {
1960         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*focusedElement);
1961         if (selectElement.canSelectAll()) {
1962             selectElement.selectAll();
1963             return;
1964         }
1965     }
1966 
1967     RefPtr&lt;Node&gt; root;
1968     Node* selectStartTarget = nullptr;
1969     if (m_selection.isContentEditable()) {
1970         root = highestEditableRoot(m_selection.start());
1971         if (Node* shadowRoot = m_selection.nonBoundaryShadowTreeRootNode())
1972             selectStartTarget = shadowRoot-&gt;shadowHost();
1973         else
1974             selectStartTarget = root.get();
1975     } else {
1976         if (m_selection.isNone() &amp;&amp; focusedElement) {
1977             if (focusedElement-&gt;isTextField()) {
1978                 downcast&lt;HTMLTextFormControlElement&gt;(*focusedElement).select();
1979                 return;
1980             }
1981             root = focusedElement-&gt;nonBoundaryShadowTreeRootNode();
1982         } else
1983             root = m_selection.nonBoundaryShadowTreeRootNode();
1984 
1985         if (root)
1986             selectStartTarget = root-&gt;shadowHost();
1987         else {
1988             root = document-&gt;documentElement();
1989             selectStartTarget = document-&gt;bodyOrFrameset();
1990         }
1991     }
1992     if (!root)
1993         return;
1994 
1995     if (selectStartTarget) {
1996         auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
1997         selectStartTarget-&gt;dispatchEvent(event);
1998         if (event-&gt;defaultPrevented())
1999             return;
2000     }
2001 
2002     VisibleSelection newSelection(VisibleSelection::selectionFromContentsOfNode(root.get()));
2003 
2004     if (shouldChangeSelection(newSelection)) {
2005         AXTextStateChangeIntent intent(AXTextStateChangeTypeSelectionExtend, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityAll, false });
2006         setSelection(newSelection, defaultSetSelectionOptions() | FireSelectEvent, intent);
2007     }
2008 }
2009 
2010 bool FrameSelection::setSelectedRange(Range* range, EAffinity affinity, ShouldCloseTyping closeTyping, EUserTriggered userTriggered)
2011 {
2012     if (!range)
2013         return false;
2014     ASSERT(&amp;range-&gt;startContainer().document() == &amp;range-&gt;endContainer().document());
2015 
2016     VisibleSelection newSelection(*range, affinity);
2017 
2018 #if PLATFORM(IOS_FAMILY)
2019     // FIXME: Why do we need this check only in iOS?
2020     if (newSelection.isNone())
2021         return false;
2022 #endif
2023 
2024     OptionSet&lt;SetSelectionOption&gt; selectionOptions {  ClearTypingStyle };
2025     if (closeTyping == ShouldCloseTyping::Yes)
2026         selectionOptions.add(CloseTyping);
2027 
2028     if (userTriggered == UserTriggered) {
2029         FrameSelection trialFrameSelection;
2030 
2031         trialFrameSelection.setSelection(newSelection, selectionOptions);
2032 
2033         if (!shouldChangeSelection(trialFrameSelection.selection()))
2034             return false;
2035 
2036         selectionOptions.add(IsUserTriggered);
2037     }
2038 
2039     setSelection(newSelection, selectionOptions);
2040     return true;
2041 }
2042 
2043 void FrameSelection::focusedOrActiveStateChanged()
2044 {
2045     bool activeAndFocused = isFocusedAndActive();
2046     Ref&lt;Document&gt; document(*m_frame-&gt;document());
2047 
2048     document-&gt;updateStyleIfNeeded();
2049 
2050 #if USE(UIKIT_EDITING)
2051     // Caret blinking (blinks | does not blink)
2052     if (activeAndFocused)
2053         setSelectionFromNone();
2054     setCaretVisible(activeAndFocused);
2055 #else
2056     // Because RenderObject::selectionBackgroundColor() and
2057     // RenderObject::selectionForegroundColor() check if the frame is active,
2058     // we have to update places those colors were painted.
2059     if (RenderView* view = document-&gt;renderView())
2060         view-&gt;selection().repaint();
2061 
2062     // Caret appears in the active frame.
2063     if (activeAndFocused)
2064         setSelectionFromNone();
2065     setCaretVisibility(activeAndFocused ? Visible : Hidden);
2066 
2067     // Because StyleResolver::checkOneSelector() and
2068     // RenderTheme::isFocused() check if the frame is active, we have to
2069     // update style and theme state that depended on those.
2070     if (Element* element = document-&gt;focusedElement()) {
2071         element-&gt;invalidateStyleForSubtree();
2072         if (RenderObject* renderer = element-&gt;renderer())
2073             if (renderer &amp;&amp; renderer-&gt;style().hasAppearance())
2074                 renderer-&gt;theme().stateChanged(*renderer, ControlStates::FocusState);
2075     }
2076 #endif
2077 }
2078 
2079 void FrameSelection::pageActivationChanged()
2080 {
2081     focusedOrActiveStateChanged();
2082 }
2083 
2084 void FrameSelection::setFocused(bool flag)
2085 {
2086     if (m_focused == flag)
2087         return;
2088     m_focused = flag;
2089 
2090     focusedOrActiveStateChanged();
2091 }
2092 
2093 bool FrameSelection::isFocusedAndActive() const
2094 {
2095     return m_focused &amp;&amp; m_frame-&gt;page() &amp;&amp; m_frame-&gt;page()-&gt;focusController().isActive();
2096 }
2097 
2098 #if ENABLE(TEXT_CARET)
2099 inline static bool shouldStopBlinkingDueToTypingCommand(Frame* frame)
2100 {
2101     return frame-&gt;editor().lastEditCommand() &amp;&amp; frame-&gt;editor().lastEditCommand()-&gt;shouldStopCaretBlinking();
2102 }
2103 #endif
2104 
2105 void FrameSelection::updateAppearance()
2106 {
2107 #if PLATFORM(IOS_FAMILY)
2108     if (!m_updateAppearanceEnabled)
2109         return;
2110 #endif
2111 
2112     // Paint a block cursor instead of a caret in overtype mode unless the caret is at the end of a line (in this case
2113     // the FrameSelection will paint a blinking caret as usual).
2114     VisibleSelection oldSelection = selection();
2115 
2116 #if ENABLE(TEXT_CARET)
2117     bool paintBlockCursor = m_shouldShowBlockCursor &amp;&amp; m_selection.isCaret() &amp;&amp; !isLogicalEndOfLine(m_selection.visibleEnd());
2118     bool caretRectChangedOrCleared = recomputeCaretRect();
2119 
2120     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2121     bool shouldBlink = !paintBlockCursor &amp;&amp; caretIsVisible() &amp;&amp; isCaret() &amp;&amp; (oldSelection.isContentEditable() || caretBrowsing);
2122 
2123     // If the caret moved, stop the blink timer so we can restart with a
2124     // black caret in the new location.
2125     if (caretRectChangedOrCleared || !shouldBlink || shouldStopBlinkingDueToTypingCommand(m_frame))
2126         m_caretBlinkTimer.stop();
2127 
2128     // Start blinking with a black caret. Be sure not to restart if we&#39;re
2129     // already blinking in the right location.
2130     if (shouldBlink &amp;&amp; !m_caretBlinkTimer.isActive()) {
2131         if (Seconds blinkInterval = RenderTheme::singleton().caretBlinkInterval())
2132             m_caretBlinkTimer.startRepeating(blinkInterval);
2133 
2134         if (!m_caretPaint) {
2135             m_caretPaint = true;
2136             invalidateCaretRect();
2137         }
2138     }
2139 #endif
2140 
2141     RenderView* view = m_frame-&gt;contentRenderer();
2142     if (!view)
2143         return;
2144 
2145     // Construct a new VisibleSolution, since m_selection is not necessarily valid, and the following steps
2146     // assume a valid selection. See &lt;https://bugs.webkit.org/show_bug.cgi?id=69563&gt; and &lt;rdar://problem/10232866&gt;.
2147 #if ENABLE(TEXT_CARET)
2148     VisiblePosition endVisiblePosition = paintBlockCursor ? modifyExtendingForward(CharacterGranularity) : oldSelection.visibleEnd();
2149     VisibleSelection selection(oldSelection.visibleStart(), endVisiblePosition);
2150 #else
2151     VisibleSelection selection(oldSelection.visibleStart(), oldSelection.visibleEnd());
2152 #endif
2153 
2154     if (!selection.isRange()) {
2155         view-&gt;selection().clear();
2156         return;
2157     }
2158 
2159     // Use the rightmost candidate for the start of the selection, and the leftmost candidate for the end of the selection.
2160     // Example: foo &lt;a&gt;bar&lt;/a&gt;.  Imagine that a line wrap occurs after &#39;foo&#39;, and that &#39;bar&#39; is selected.   If we pass [foo, 3]
2161     // as the start of the selection, the selection painting code will think that content on the line containing &#39;foo&#39; is selected
2162     // and will fill the gap before &#39;bar&#39;.
2163     Position startPos = selection.start();
2164     Position candidate = startPos.downstream();
2165     if (candidate.isCandidate())
2166         startPos = candidate;
2167     Position endPos = selection.end();
2168     candidate = endPos.upstream();
2169     if (candidate.isCandidate())
2170         endPos = candidate;
2171 
2172     // We can get into a state where the selection endpoints map to the same VisiblePosition when a selection is deleted
2173     // because we don&#39;t yet notify the FrameSelection of text removal.
2174     if (startPos.isNotNull() &amp;&amp; endPos.isNotNull() &amp;&amp; selection.visibleStart() != selection.visibleEnd()) {
2175         RenderObject* startRenderer = startPos.deprecatedNode()-&gt;renderer();
2176         int startOffset = startPos.deprecatedEditingOffset();
2177         RenderObject* endRenderer = endPos.deprecatedNode()-&gt;renderer();
2178         int endOffset = endPos.deprecatedEditingOffset();
2179         ASSERT(startOffset &gt;= 0 &amp;&amp; endOffset &gt;= 0);
2180         view-&gt;selection().set({ startRenderer, endRenderer, static_cast&lt;unsigned&gt;(startOffset), static_cast&lt;unsigned&gt;(endOffset) });
2181     }
2182 }
2183 
2184 void FrameSelection::setCaretVisibility(CaretVisibility visibility)
2185 {
2186     if (caretVisibility() == visibility)
2187         return;
2188 
2189     // FIXME: We shouldn&#39;t trigger a synchronous layout here.
2190     if (m_frame)
2191         updateSelectionByUpdatingLayoutOrStyle(*m_frame);
2192 
2193 #if ENABLE(TEXT_CARET)
2194     if (m_caretPaint) {
2195         m_caretPaint = false;
2196         invalidateCaretRect();
2197     }
2198     CaretBase::setCaretVisibility(visibility);
2199 #endif
2200 
2201     updateAppearance();
2202 }
2203 
2204 void FrameSelection::caretBlinkTimerFired()
2205 {
2206 #if ENABLE(TEXT_CARET)
2207     ASSERT(caretIsVisible());
2208     ASSERT(isCaret());
2209     bool caretPaint = m_caretPaint;
2210     if (isCaretBlinkingSuspended() &amp;&amp; caretPaint)
2211         return;
2212     m_caretPaint = !caretPaint;
2213     invalidateCaretRect();
2214 #endif
2215 }
2216 
2217 // Helper function that tells whether a particular node is an element that has an entire
2218 // Frame and FrameView, a &lt;frame&gt;, &lt;iframe&gt;, or &lt;object&gt;.
2219 static bool isFrameElement(const Node* n)
2220 {
2221     if (!n)
2222         return false;
2223     RenderObject* renderer = n-&gt;renderer();
2224     if (!is&lt;RenderWidget&gt;(renderer))
2225         return false;
2226     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
2227     return widget &amp;&amp; widget-&gt;isFrameView();
2228 }
2229 
2230 void FrameSelection::setFocusedElementIfNeeded()
2231 {
2232     if (isNone() || !isFocused())
2233         return;
2234 
2235     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2236     if (caretBrowsing) {
2237         if (Element* anchor = enclosingAnchorElement(m_selection.base())) {
2238             m_frame-&gt;page()-&gt;focusController().setFocusedElement(anchor, *m_frame);
2239             return;
2240         }
2241     }
2242 
2243     if (Element* target = m_selection.rootEditableElement()) {
2244         // Walk up the DOM tree to search for an element to focus.
2245         while (target) {
2246             // We don&#39;t want to set focus on a subframe when selecting in a parent frame,
2247             // so add the !isFrameElement check here. There&#39;s probably a better way to make this
2248             // work in the long term, but this is the safest fix at this time.
2249             if (target-&gt;isMouseFocusable() &amp;&amp; !isFrameElement(target)) {
2250                 m_frame-&gt;page()-&gt;focusController().setFocusedElement(target, *m_frame);
2251                 return;
2252             }
2253             target = target-&gt;parentOrShadowHostElement();
2254         }
2255         m_frame-&gt;document()-&gt;setFocusedElement(nullptr);
2256     }
2257 
2258     if (caretBrowsing)
2259         m_frame-&gt;page()-&gt;focusController().setFocusedElement(nullptr, *m_frame);
2260 }
2261 
2262 void DragCaretController::paintDragCaret(Frame* frame, GraphicsContext&amp; p, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; clipRect) const
2263 {
2264 #if ENABLE(TEXT_CARET)
2265     if (m_position.deepEquivalent().deprecatedNode()-&gt;document().frame() == frame)
2266         paintCaret(m_position.deepEquivalent().deprecatedNode(), p, paintOffset, clipRect);
2267 #else
2268     UNUSED_PARAM(frame);
2269     UNUSED_PARAM(p);
2270     UNUSED_PARAM(paintOffset);
2271     UNUSED_PARAM(clipRect);
2272 #endif
2273 }
2274 
2275 RefPtr&lt;MutableStyleProperties&gt; FrameSelection::copyTypingStyle() const
2276 {
2277     if (!m_typingStyle || !m_typingStyle-&gt;style())
2278         return nullptr;
2279     return m_typingStyle-&gt;style()-&gt;mutableCopy();
2280 }
2281 
2282 bool FrameSelection::shouldDeleteSelection(const VisibleSelection&amp; selection) const
2283 {
2284 #if PLATFORM(IOS_FAMILY)
2285     if (m_frame-&gt;selectionChangeCallbacksDisabled())
2286         return true;
2287 #endif
2288     return m_frame-&gt;editor().client()-&gt;shouldDeleteRange(selection.toNormalizedRange().get());
2289 }
2290 
2291 FloatRect FrameSelection::selectionBounds(ClipToVisibleContent clipToVisibleContent) const
2292 {
2293     if (!m_frame-&gt;document())
2294         return LayoutRect();
2295 
2296     updateSelectionByUpdatingLayoutOrStyle(*m_frame);
2297     auto* renderView = m_frame-&gt;contentRenderer();
2298     if (!renderView)
2299         return LayoutRect();
2300 
2301     auto&amp; selection = renderView-&gt;selection();
2302 
2303     if (clipToVisibleContent == ClipToVisibleContent::Yes) {
2304         auto selectionRect = selection.boundsClippedToVisibleContent();
2305         return intersection(selectionRect, renderView-&gt;frameView().visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect));
2306     }
2307 
2308     return selection.bounds();
2309 }
2310 
2311 void FrameSelection::getClippedVisibleTextRectangles(Vector&lt;FloatRect&gt;&amp; rectangles, TextRectangleHeight textRectHeight) const
2312 {
2313     RenderView* root = m_frame-&gt;contentRenderer();
2314     if (!root)
2315         return;
2316 
2317     Vector&lt;FloatRect&gt; textRects;
2318     getTextRectangles(textRects, textRectHeight);
2319 
2320     FloatRect visibleContentRect = m_frame-&gt;view()-&gt;visibleContentRect(ScrollableArea::LegacyIOSDocumentVisibleRect);
2321 
2322     for (const auto&amp; rect : textRects) {
2323         FloatRect intersectionRect = intersection(rect, visibleContentRect);
2324         if (!intersectionRect.isEmpty())
2325             rectangles.append(intersectionRect);
2326     }
2327 }
2328 
2329 void FrameSelection::getTextRectangles(Vector&lt;FloatRect&gt;&amp; rectangles, TextRectangleHeight textRectHeight) const
2330 {
2331     RefPtr&lt;Range&gt; range = toNormalizedRange();
2332     if (!range)
2333         return;
2334 
2335     Vector&lt;FloatQuad&gt; quads;
2336     range-&gt;absoluteTextQuads(quads, textRectHeight == TextRectangleHeight::SelectionHeight);
2337 
2338     for (const auto&amp; quad : quads)
2339         rectangles.append(quad.boundingBox());
2340 }
2341 
2342 // Scans logically forward from &quot;start&quot;, including any child frames.
2343 static HTMLFormElement* scanForForm(Element* start)
2344 {
2345     if (!start)
2346         return nullptr;
2347 
2348     auto descendants = descendantsOfType&lt;HTMLElement&gt;(start-&gt;document());
2349     for (auto it = descendants.from(*start), end = descendants.end(); it != end; ++it) {
2350         HTMLElement&amp; element = *it;
2351         if (is&lt;HTMLFormElement&gt;(element))
2352             return &amp;downcast&lt;HTMLFormElement&gt;(element);
2353         if (is&lt;HTMLFormControlElement&gt;(element))
2354             return downcast&lt;HTMLFormControlElement&gt;(element).form();
2355         if (is&lt;HTMLFrameElementBase&gt;(element)) {
2356             Document* contentDocument = downcast&lt;HTMLFrameElementBase&gt;(element).contentDocument();
2357             if (!contentDocument)
2358                 continue;
2359             if (HTMLFormElement* frameResult = scanForForm(contentDocument-&gt;documentElement()))
2360                 return frameResult;
2361         }
2362     }
2363     return nullptr;
2364 }
2365 
2366 // We look for either the form containing the current focus, or for one immediately after it
2367 HTMLFormElement* FrameSelection::currentForm() const
2368 {
2369     // Start looking either at the active (first responder) node, or where the selection is.
2370     Element* start = m_frame-&gt;document()-&gt;focusedElement();
2371     if (!start)
2372         start = m_selection.start().element();
2373     if (!start)
2374         return nullptr;
2375 
2376     if (auto form = lineageOfType&lt;HTMLFormElement&gt;(*start).first())
2377         return form;
2378     if (auto formControl = lineageOfType&lt;HTMLFormControlElement&gt;(*start).first())
2379         return formControl-&gt;form();
2380 
2381     // Try walking forward in the node tree to find a form element.
2382     return scanForForm(start);
2383 }
2384 
2385 void FrameSelection::revealSelection(SelectionRevealMode revealMode, const ScrollAlignment&amp; alignment, RevealExtentOption revealExtentOption)
2386 {
2387     if (revealMode == SelectionRevealMode::DoNotReveal)
2388         return;
2389 
2390     LayoutRect rect;
2391     bool insideFixed = false;
2392     switch (m_selection.selectionType()) {
2393     case VisibleSelection::NoSelection:
2394         return;
2395     case VisibleSelection::CaretSelection:
2396         rect = absoluteCaretBounds(&amp;insideFixed);
2397         break;
2398     case VisibleSelection::RangeSelection:
2399         rect = revealExtentOption == RevealExtent ? VisiblePosition(m_selection.extent()).absoluteCaretBounds() : enclosingIntRect(selectionBounds(ClipToVisibleContent::No));
2400         break;
2401     }
2402 
2403     Position start = m_selection.start();
2404     ASSERT(start.deprecatedNode());
2405     if (start.deprecatedNode() &amp;&amp; start.deprecatedNode()-&gt;renderer()) {
2406 #if PLATFORM(IOS_FAMILY)
2407         if (RenderLayer* layer = start.deprecatedNode()-&gt;renderer()-&gt;enclosingLayer()) {
2408             if (!m_scrollingSuppressCount) {
2409                 layer-&gt;setAdjustForIOSCaretWhenScrolling(true);
2410                 layer-&gt;scrollRectToVisible(rect, insideFixed, { revealMode, alignment, alignment, ShouldAllowCrossOriginScrolling::Yes });
2411                 layer-&gt;setAdjustForIOSCaretWhenScrolling(false);
2412                 updateAppearance();
2413                 if (m_frame-&gt;page())
2414                     m_frame-&gt;page()-&gt;chrome().client().notifyRevealedSelectionByScrollingFrame(*m_frame);
2415             }
2416         }
2417 #else
2418         // FIXME: This code only handles scrolling the startContainer&#39;s layer, but
2419         // the selection rect could intersect more than just that.
2420         // See &lt;rdar://problem/4799899&gt;.
2421         if (start.deprecatedNode()-&gt;renderer()-&gt;scrollRectToVisible(rect, insideFixed, { revealMode, alignment, alignment, ShouldAllowCrossOriginScrolling::Yes }))
2422             updateAppearance();
2423 #endif
2424     }
2425 }
2426 
2427 void FrameSelection::setSelectionFromNone()
2428 {
2429     // Put a caret inside the body if the entire frame is editable (either the
2430     // entire WebView is editable or designMode is on for this document).
2431 
2432     Document* document = m_frame-&gt;document();
2433 #if !PLATFORM(IOS_FAMILY)
2434     bool caretBrowsing = m_frame-&gt;settings().caretBrowsingEnabled();
2435     if (!isNone() || !(document-&gt;hasEditableStyle() || caretBrowsing))
2436         return;
2437 #else
2438     if (!document || !(isNone() || isStartOfDocument(VisiblePosition(m_selection.start(), m_selection.affinity()))) || !document-&gt;hasEditableStyle())
2439         return;
2440 #endif
2441 
2442     if (auto* body = document-&gt;body())
2443         setSelection(VisibleSelection(firstPositionInOrBeforeNode(body), DOWNSTREAM));
2444 }
2445 
2446 bool FrameSelection::shouldChangeSelection(const VisibleSelection&amp; newSelection) const
2447 {
2448 #if PLATFORM(IOS_FAMILY)
2449     if (m_frame-&gt;selectionChangeCallbacksDisabled())
2450         return true;
2451 #endif
2452     return m_frame-&gt;editor().shouldChangeSelection(selection(), newSelection, newSelection.affinity(), false);
2453 }
2454 
2455 bool FrameSelection::dispatchSelectStart()
2456 {
2457     Node* selectStartTarget = m_selection.extent().containerNode();
2458     if (!selectStartTarget)
2459         return true;
2460 
2461     auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
2462     selectStartTarget-&gt;dispatchEvent(event);
2463     return !event-&gt;defaultPrevented();
2464 }
2465 
2466 void FrameSelection::setShouldShowBlockCursor(bool shouldShowBlockCursor)
2467 {
2468     m_shouldShowBlockCursor = shouldShowBlockCursor;
2469 
2470     m_frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
2471 
2472     updateAppearance();
2473 }
2474 
2475 void FrameSelection::updateAppearanceAfterLayout()
2476 {
2477     m_appearanceUpdateTimer.stop();
2478     updateAppearanceAfterLayoutOrStyleChange();
2479 }
2480 
2481 void FrameSelection::scheduleAppearanceUpdateAfterStyleChange()
2482 {
2483     m_appearanceUpdateTimer.startOneShot(0_s);
2484 }
2485 
2486 void FrameSelection::appearanceUpdateTimerFired()
2487 {
2488     Ref&lt;Frame&gt; protectedFrame(*m_frame);
2489     updateAppearanceAfterLayoutOrStyleChange();
2490 }
2491 
2492 void FrameSelection::updateAppearanceAfterLayoutOrStyleChange()
2493 {
2494     if (auto* client = m_frame-&gt;editor().client())
2495         client-&gt;updateEditorStateAfterLayoutIfEditabilityChanged();
2496 
2497     setCaretRectNeedsUpdate();
2498     updateAndRevealSelection(m_selectionRevealIntent);
2499     updateDataDetectorsForSelection();
2500 }
2501 
2502 #if ENABLE(TREE_DEBUGGING)
2503 
2504 void FrameSelection::formatForDebugger(char* buffer, unsigned length) const
2505 {
2506     m_selection.formatForDebugger(buffer, length);
2507 }
2508 
2509 void FrameSelection::showTreeForThis() const
2510 {
2511     m_selection.showTreeForThis();
2512 }
2513 
2514 #endif
2515 
2516 #if PLATFORM(IOS_FAMILY)
2517 void FrameSelection::expandSelectionToElementContainingCaretSelection()
2518 {
2519     RefPtr&lt;Range&gt; range = elementRangeContainingCaretSelection();
2520     if (!range)
2521         return;
2522     VisibleSelection selection(*range, DOWNSTREAM);
2523     setSelection(selection);
2524 }
2525 
2526 RefPtr&lt;Range&gt; FrameSelection::elementRangeContainingCaretSelection() const
2527 {
2528     if (m_selection.isNone())
2529         return nullptr;
2530 
2531     VisibleSelection selection = m_selection;
2532     if (selection.isNone())
2533         return nullptr;
2534 
2535     VisiblePosition visiblePos(selection.start(), VP_DEFAULT_AFFINITY);
2536     if (visiblePos.isNull())
2537         return nullptr;
2538 
2539     Node* node = visiblePos.deepEquivalent().deprecatedNode();
2540     Element* element = deprecatedEnclosingBlockFlowElement(node);
2541     if (!element)
2542         return nullptr;
2543 
2544     Position startPos = createLegacyEditingPosition(element, 0);
2545     Position endPos = createLegacyEditingPosition(element, element-&gt;countChildNodes());
2546 
2547     VisiblePosition startVisiblePos(startPos, VP_DEFAULT_AFFINITY);
2548     VisiblePosition endVisiblePos(endPos, VP_DEFAULT_AFFINITY);
2549     if (startVisiblePos.isNull() || endVisiblePos.isNull())
2550         return nullptr;
2551 
2552     selection.setBase(startVisiblePos);
2553     selection.setExtent(endVisiblePos);
2554 
2555     return selection.toNormalizedRange();
2556 }
2557 
2558 void FrameSelection::expandSelectionToWordContainingCaretSelection()
2559 {
2560     VisibleSelection selection(wordSelectionContainingCaretSelection(m_selection));
2561     if (selection.isCaretOrRange())
2562         setSelection(selection);
2563 }
2564 
2565 RefPtr&lt;Range&gt; FrameSelection::wordRangeContainingCaretSelection()
2566 {
2567     return wordSelectionContainingCaretSelection(m_selection).toNormalizedRange();
2568 }
2569 
2570 void FrameSelection::expandSelectionToStartOfWordContainingCaretSelection()
2571 {
2572     if (m_selection.isNone() || isStartOfDocument(m_selection.start()))
2573         return;
2574 
2575     VisiblePosition s1(m_selection.start());
2576     VisiblePosition e1(m_selection.end());
2577 
2578     VisibleSelection expanded(wordSelectionContainingCaretSelection(m_selection));
2579     VisiblePosition s2(expanded.start());
2580 
2581     // Don&#39;t allow the start to become greater after the expansion.
2582     if (s2.isNull() || s2 &gt; s1)
2583         s2 = s1;
2584 
2585     moveTo(s2, e1);
2586 }
2587 
2588 UChar FrameSelection::characterInRelationToCaretSelection(int amount) const
2589 {
2590     if (m_selection.isNone())
2591         return 0;
2592 
2593     VisibleSelection selection = m_selection;
2594     ASSERT(selection.isCaretOrRange());
2595 
2596     VisiblePosition visiblePosition(selection.start(), VP_DEFAULT_AFFINITY);
2597 
2598     if (amount &lt; 0) {
2599         int count = abs(amount);
2600         for (int i = 0; i &lt; count; i++)
2601             visiblePosition = visiblePosition.previous();
2602         return visiblePosition.characterBefore();
2603     }
2604     for (int i = 0; i &lt; amount; i++)
2605         visiblePosition = visiblePosition.next();
2606     return visiblePosition.characterAfter();
2607 }
2608 
2609 UChar FrameSelection::characterBeforeCaretSelection() const
2610 {
2611     if (m_selection.isNone())
2612         return 0;
2613 
2614     VisibleSelection selection = m_selection;
2615     ASSERT(selection.isCaretOrRange());
2616 
2617     VisiblePosition visiblePosition(selection.start(), VP_DEFAULT_AFFINITY);
2618     return visiblePosition.characterBefore();
2619 }
2620 
2621 UChar FrameSelection::characterAfterCaretSelection() const
2622 {
2623     if (m_selection.isNone())
2624         return 0;
2625 
2626     VisibleSelection selection = m_selection;
2627     ASSERT(selection.isCaretOrRange());
2628 
2629     VisiblePosition visiblePosition(selection.end(), VP_DEFAULT_AFFINITY);
2630     return visiblePosition.characterAfter();
2631 }
2632 
2633 int FrameSelection::wordOffsetInRange(const Range *range) const
2634 {
2635     if (!range)
2636         return -1;
2637 
2638     VisibleSelection selection = m_selection;
2639     if (!selection.isCaret())
2640         return -1;
2641 
2642     // FIXME: This will only work in cases where the selection remains in
2643     // the same node after it is expanded. Improve to handle more complicated
2644     // cases.
2645     int result = selection.start().deprecatedEditingOffset() - range-&gt;startOffset();
2646     if (result &lt; 0)
2647         result = 0;
2648     return result;
2649 }
2650 
2651 bool FrameSelection::spaceFollowsWordInRange(const Range *range) const
2652 {
2653     if (!range)
2654         return false;
2655     Node&amp; node = range-&gt;endContainer();
2656     int endOffset = range-&gt;endOffset();
2657     VisiblePosition pos(createLegacyEditingPosition(&amp;node, endOffset), VP_DEFAULT_AFFINITY);
2658     return isSpaceOrNewline(pos.characterAfter());
2659 }
2660 
2661 bool FrameSelection::selectionAtDocumentStart() const
2662 {
2663     VisibleSelection selection = m_selection;
2664     if (selection.isNone())
2665         return false;
2666 
2667     Position startPos(selection.start());
2668     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2669     if (pos.isNull())
2670         return false;
2671 
2672     return isStartOfDocument(pos);
2673 }
2674 
2675 bool FrameSelection::selectionAtSentenceStart() const
2676 {
2677     VisibleSelection selection = m_selection;
2678     if (selection.isNone())
2679         return false;
2680 
2681     return actualSelectionAtSentenceStart(selection);
2682 }
2683 
2684 bool FrameSelection::selectionAtWordStart() const
2685 {
2686     VisibleSelection selection = m_selection;
2687     if (selection.isNone())
2688         return false;
2689 
2690     Position startPos(selection.start());
2691     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2692     if (pos.isNull())
2693         return false;
2694 
2695     if (isStartOfParagraph(pos))
2696         return true;
2697 
2698     bool result = true;
2699     unsigned previousCount = 0;
2700     for (pos = pos.previous(); !pos.isNull(); pos = pos.previous()) {
2701         previousCount++;
2702         if (isStartOfParagraph(pos)) {
2703             if (previousCount == 1)
2704                 result = false;
2705             break;
2706         }
2707         UChar c(pos.characterAfter());
2708         if (c) {
2709             result = isSpaceOrNewline(c) || c == noBreakSpace || (u_ispunct(c) &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;-&#39; &amp;&amp; c != &#39;\&#39;&#39;);
2710             break;
2711         }
2712     }
2713 
2714     return result;
2715 }
2716 
2717 RefPtr&lt;Range&gt; FrameSelection::rangeByMovingCurrentSelection(int amount) const
2718 {
2719     return rangeByAlteringCurrentSelection(AlterationMove, amount);
2720 }
2721 
2722 RefPtr&lt;Range&gt; FrameSelection::rangeByExtendingCurrentSelection(int amount) const
2723 {
2724     return rangeByAlteringCurrentSelection(AlterationExtend, amount);
2725 }
2726 
2727 void FrameSelection::selectRangeOnElement(unsigned location, unsigned length, Node&amp; node)
2728 {
2729     RefPtr&lt;Range&gt; resultRange = m_frame-&gt;document()-&gt;createRange();
2730     resultRange-&gt;setStart(node, location);
2731     resultRange-&gt;setEnd(node, location + length);
2732     VisibleSelection selection = VisibleSelection(*resultRange, SEL_DEFAULT_AFFINITY);
2733     // FIXME: The second argument was &quot;true&quot; which implicitly converted to option &quot;FireSelectEvent&quot;. Is this correct?
2734     setSelection(selection, { FireSelectEvent });
2735 }
2736 
2737 VisibleSelection FrameSelection::wordSelectionContainingCaretSelection(const VisibleSelection&amp; selection)
2738 {
2739     if (selection.isNone())
2740         return VisibleSelection();
2741 
2742     ASSERT(selection.isCaretOrRange());
2743     FrameSelection frameSelection;
2744     frameSelection.setSelection(selection);
2745 
2746     Position startPosBeforeExpansion(selection.start());
2747     Position endPosBeforeExpansion(selection.end());
2748     VisiblePosition startVisiblePosBeforeExpansion(startPosBeforeExpansion, VP_DEFAULT_AFFINITY);
2749     VisiblePosition endVisiblePosBeforeExpansion(endPosBeforeExpansion, VP_DEFAULT_AFFINITY);
2750     if (endVisiblePosBeforeExpansion.isNull())
2751         return VisibleSelection();
2752 
2753     if (isEndOfParagraph(endVisiblePosBeforeExpansion)) {
2754         UChar c(endVisiblePosBeforeExpansion.characterBefore());
2755         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2756             // End of paragraph with space.
2757             return VisibleSelection();
2758         }
2759     }
2760 
2761     // If at end of paragraph, move backwards one character.
2762     // This has the effect of selecting the word on the line (which is
2763     // what we want, rather than selecting past the end of the line).
2764     if (isEndOfParagraph(endVisiblePosBeforeExpansion) &amp;&amp; !isStartOfParagraph(endVisiblePosBeforeExpansion))
2765         frameSelection.modify(FrameSelection::AlterationMove, DirectionBackward, CharacterGranularity);
2766 
2767     VisibleSelection newSelection = frameSelection.selection();
2768     newSelection.expandUsingGranularity(WordGranularity);
2769     frameSelection.setSelection(newSelection, defaultSetSelectionOptions(), AXTextStateChangeIntent(), AlignCursorOnScrollIfNeeded, frameSelection.granularity());
2770 
2771     Position startPos(frameSelection.selection().start());
2772     Position endPos(frameSelection.selection().end());
2773 
2774     // Expansion cannot be allowed to change selection so that it is no longer
2775     // touches (or contains) the original, unexpanded selection.
2776     // Enforce this on the way into these additional calculations to give them
2777     // the best chance to yield a suitable answer.
2778     if (startPos &gt; startPosBeforeExpansion)
2779         startPos = startPosBeforeExpansion;
2780     if (endPos &lt; endPosBeforeExpansion)
2781         endPos = endPosBeforeExpansion;
2782 
2783     VisiblePosition startVisiblePos(startPos, VP_DEFAULT_AFFINITY);
2784     VisiblePosition endVisiblePos(endPos, VP_DEFAULT_AFFINITY);
2785 
2786     if (startVisiblePos.isNull() || endVisiblePos.isNull()) {
2787         // Start or end is nil
2788         return VisibleSelection();
2789     }
2790 
2791     if (isEndOfLine(endVisiblePosBeforeExpansion)) {
2792         VisiblePosition previous(endVisiblePos.previous());
2793         if (previous == endVisiblePos) {
2794             // Empty document
2795             return VisibleSelection();
2796         }
2797         UChar c(previous.characterAfter());
2798         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2799             // Space at end of line
2800             return VisibleSelection();
2801         }
2802     }
2803 
2804     // Expansion has selected past end of line.
2805     // Try repositioning backwards.
2806     if (isEndOfLine(startVisiblePos) &amp;&amp; isStartOfLine(endVisiblePos)) {
2807         VisiblePosition previous(startVisiblePos.previous());
2808         if (isEndOfLine(previous)) {
2809             // On empty line
2810             return VisibleSelection();
2811         }
2812         UChar c(previous.characterAfter());
2813         if (isSpaceOrNewline(c) || c == noBreakSpace) {
2814             // Space at end of line
2815             return VisibleSelection();
2816         }
2817         frameSelection.moveTo(startVisiblePos);
2818         frameSelection.modify(FrameSelection::AlterationExtend, DirectionBackward, WordGranularity);
2819         startPos = frameSelection.selection().start();
2820         endPos = frameSelection.selection().end();
2821         startVisiblePos = VisiblePosition(startPos, VP_DEFAULT_AFFINITY);
2822         endVisiblePos = VisiblePosition(endPos, VP_DEFAULT_AFFINITY);
2823         if (startVisiblePos.isNull() || endVisiblePos.isNull()) {
2824             // Start or end is nil
2825             return VisibleSelection();
2826         }
2827     }
2828 
2829     // Now loop backwards until we find a non-space.
2830     while (endVisiblePos != startVisiblePos) {
2831         VisiblePosition previous(endVisiblePos.previous());
2832         UChar c(previous.characterAfter());
2833         if (!isSpaceOrNewline(c) &amp;&amp; c != noBreakSpace)
2834             break;
2835         endVisiblePos = previous;
2836     }
2837 
2838     // Expansion cannot be allowed to change selection so that it is no longer
2839     // touches (or contains) the original, unexpanded selection.
2840     // Enforce this on the way out of the function to preserve the invariant.
2841     if (startVisiblePos &gt; startVisiblePosBeforeExpansion)
2842         startVisiblePos = startVisiblePosBeforeExpansion;
2843     if (endVisiblePos &lt; endVisiblePosBeforeExpansion)
2844         endVisiblePos = endVisiblePosBeforeExpansion;
2845 
2846     return VisibleSelection(startVisiblePos, endVisiblePos);
2847 }
2848 
2849 bool FrameSelection::actualSelectionAtSentenceStart(const VisibleSelection&amp; sel) const
2850 {
2851     Position startPos(sel.start());
2852     VisiblePosition pos(createLegacyEditingPosition(startPos.deprecatedNode(), startPos.deprecatedEditingOffset()), VP_DEFAULT_AFFINITY);
2853     if (pos.isNull())
2854         return false;
2855 
2856     if (isStartOfParagraph(pos))
2857         return true;
2858 
2859     bool result = true;
2860     bool sawSpace = false;
2861     unsigned previousCount = 0;
2862     for (pos = pos.previous(); !pos.isNull(); pos = pos.previous()) {
2863         previousCount++;
2864         if (isStartOfParagraph(pos)) {
2865             if (previousCount == 1 || (previousCount == 2 &amp;&amp; sawSpace))
2866                 result = false;
2867             break;
2868         }
2869         UChar c(pos.characterAfter());
2870         if (c) {
2871             if (isSpaceOrNewline(c) || c == noBreakSpace) {
2872                 sawSpace = true;
2873             }
2874             else {
2875                 result = (c == &#39;.&#39; || c == &#39;!&#39; || c == &#39;?&#39;);
2876                 break;
2877             }
2878         }
2879     }
2880 
2881     return result;
2882 }
2883 
2884 RefPtr&lt;Range&gt; FrameSelection::rangeByAlteringCurrentSelection(EAlteration alteration, int amount) const
2885 {
2886     if (m_selection.isNone())
2887         return nullptr;
2888 
2889     if (!amount)
2890         return toNormalizedRange();
2891 
2892     FrameSelection frameSelection;
2893     frameSelection.setSelection(m_selection);
2894     SelectionDirection direction = amount &gt; 0 ? DirectionForward : DirectionBackward;
2895     for (int i = 0; i &lt; abs(amount); i++)
2896         frameSelection.modify(alteration, direction, CharacterGranularity);
2897     return frameSelection.toNormalizedRange();
2898 }
2899 
2900 void FrameSelection::clearCurrentSelection()
2901 {
2902     setSelection(VisibleSelection());
2903 }
2904 
2905 void FrameSelection::setCaretBlinks(bool caretBlinks)
2906 {
2907     if (m_caretBlinks == caretBlinks)
2908         return;
2909 #if ENABLE(TEXT_CARET)
2910     m_frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
2911     if (m_caretPaint) {
2912         m_caretPaint = false;
2913         invalidateCaretRect();
2914     }
2915 #endif
2916     if (caretBlinks)
2917         setFocusedElementIfNeeded();
2918     m_caretBlinks = caretBlinks;
2919     updateAppearance();
2920 }
2921 
2922 void FrameSelection::setCaretColor(const Color&amp; caretColor)
2923 {
2924     if (m_caretColor != caretColor) {
2925         m_caretColor = caretColor;
2926         if (caretIsVisible() &amp;&amp; m_caretBlinks &amp;&amp; isCaret())
2927             invalidateCaretRect();
2928     }
2929 }
2930 #endif // PLATFORM(IOS_FAMILY)
2931 
2932 }
2933 
2934 #if ENABLE(TREE_DEBUGGING)
2935 
2936 void showTree(const WebCore::FrameSelection&amp; sel)
2937 {
2938     sel.showTreeForThis();
2939 }
2940 
2941 void showTree(const WebCore::FrameSelection* sel)
2942 {
2943     if (sel)
2944         sel-&gt;showTreeForThis();
2945 }
2946 
2947 #endif
    </pre>
  </body>
</html>