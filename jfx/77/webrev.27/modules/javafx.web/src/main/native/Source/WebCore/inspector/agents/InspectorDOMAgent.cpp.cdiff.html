<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCanvasAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2011 Google Inc. All rights reserved.
   * Copyright (C) 2009 Joseph Pecoraro
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2011 Google Inc. All rights reserved.
   * Copyright (C) 2009 Joseph Pecoraro
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,20 ***</span>
<span class="line-new-header">--- 57,23 ---</span>
  #include &quot;Event.h&quot;
  #include &quot;EventListener.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameTree.h&quot;
<span class="line-added">+ #include &quot;FrameView.h&quot;</span>
<span class="line-added">+ #include &quot;FullscreenManager.h&quot;</span>
  #include &quot;HTMLElement.h&quot;
  #include &quot;HTMLFrameOwnerElement.h&quot;
  #include &quot;HTMLMediaElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HTMLParserIdioms.h&quot;
  #include &quot;HTMLScriptElement.h&quot;
  #include &quot;HTMLStyleElement.h&quot;
  #include &quot;HTMLTemplateElement.h&quot;
  #include &quot;HTMLVideoElement.h&quot;
  #include &quot;HitTestResult.h&quot;
<span class="line-added">+ #include &quot;InspectorCSSAgent.h&quot;</span>
  #include &quot;InspectorClient.h&quot;
  #include &quot;InspectorController.h&quot;
  #include &quot;InspectorHistory.h&quot;
  #include &quot;InspectorNodeFinder.h&quot;
  #include &quot;InspectorOverlay.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,11 ***</span>
  
          RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
  
  #if ENABLE(FULLSCREEN_API)
          if (event.type() == eventNames().webkitfullscreenchangeEvent)
<span class="line-modified">!             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().webkitFullscreenElement());</span>
  #endif // ENABLE(FULLSCREEN_API)
  
          auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
          m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
      }
<span class="line-new-header">--- 251,11 ---</span>
  
          RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
  
  #if ENABLE(FULLSCREEN_API)
          if (event.type() == eventNames().webkitfullscreenchangeEvent)
<span class="line-modified">!             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().fullscreenManager().fullscreenElement());</span>
  #endif // ENABLE(FULLSCREEN_API)
  
          auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
          m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,58 ***</span>
  String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
  {
      return DOMException::name(exception.code());
  }
  
<span class="line-modified">! InspectorDOMAgent::InspectorDOMAgent(WebAgentContext&amp; context, InspectorPageAgent* pageAgent, InspectorOverlay* overlay)</span>
      : InspectorAgentBase(&quot;DOM&quot;_s, context)
      , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-modified">!     , m_frontendDispatcher(std::make_unique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))</span>
      , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified">!     , m_pageAgent(pageAgent)</span>
      , m_overlay(overlay)
  #if ENABLE(VIDEO)
      , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
  #endif
  {
  }
  
<span class="line-modified">! InspectorDOMAgent::~InspectorDOMAgent()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     reset();</span>
<span class="line-removed">-     ASSERT(!m_searchingForNode);</span>
<span class="line-removed">- }</span>
  
  void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
  {
<span class="line-modified">!     m_history = std::make_unique&lt;InspectorHistory&gt;();</span>
<span class="line-modified">!     m_domEditor = std::make_unique&lt;DOMEditor&gt;(*m_history);</span>
  
      m_instrumentingAgents.setInspectorDOMAgent(this);
<span class="line-modified">!     m_document = m_pageAgent-&gt;mainFrame().document();</span>
  
  #if ENABLE(VIDEO)
      if (m_document)
          addEventListenersToNode(*m_document);
  
      for (auto* mediaElement : HTMLMediaElement::allMediaElements())
          addEventListenersToNode(*mediaElement);
  #endif
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_nodeToFocus)</span>
<span class="line-removed">-         focusNode();</span>
  }
  
  void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
  {
      m_history.reset();
      m_domEditor.reset();
      m_mousedOverNode = nullptr;
  
<span class="line-modified">!     ErrorString unused;</span>
<span class="line-modified">!     setSearchingForNode(unused, false, nullptr);</span>
<span class="line-modified">!     hideHighlight(unused);</span>
  
      m_instrumentingAgents.setInspectorDOMAgent(nullptr);
      m_documentRequested = false;
      reset();
  }
<span class="line-new-header">--- 278,53 ---</span>
  String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
  {
      return DOMException::name(exception.code());
  }
  
<span class="line-modified">! InspectorDOMAgent::InspectorDOMAgent(PageAgentContext&amp; context, InspectorOverlay* overlay)</span>
      : InspectorAgentBase(&quot;DOM&quot;_s, context)
      , m_injectedScriptManager(context.injectedScriptManager)
<span class="line-modified">!     , m_frontendDispatcher(makeUnique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))</span>
      , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
<span class="line-modified">!     , m_inspectedPage(context.inspectedPage)</span>
      , m_overlay(overlay)
  #if ENABLE(VIDEO)
      , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
  #endif
  {
  }
  
<span class="line-modified">! InspectorDOMAgent::~InspectorDOMAgent() = default;</span>
  
  void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
  {
<span class="line-modified">!     m_history = makeUnique&lt;InspectorHistory&gt;();</span>
<span class="line-modified">!     m_domEditor = makeUnique&lt;DOMEditor&gt;(*m_history);</span>
  
      m_instrumentingAgents.setInspectorDOMAgent(this);
<span class="line-modified">!     m_document = m_inspectedPage.mainFrame().document();</span>
  
  #if ENABLE(VIDEO)
      if (m_document)
          addEventListenersToNode(*m_document);
  
      for (auto* mediaElement : HTMLMediaElement::allMediaElements())
          addEventListenersToNode(*mediaElement);
  #endif
  }
  
  void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
  {
      m_history.reset();
      m_domEditor.reset();
<span class="line-added">+     m_nodeToFocus = nullptr;</span>
      m_mousedOverNode = nullptr;
<span class="line-added">+     m_inspectedNode = nullptr;</span>
  
<span class="line-modified">!     ErrorString ignored;</span>
<span class="line-modified">!     setSearchingForNode(ignored, false, nullptr, false);</span>
<span class="line-modified">!     hideHighlight(ignored);</span>
  
      m_instrumentingAgents.setInspectorDOMAgent(nullptr);
      m_documentRequested = false;
      reset();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 352,15 ***</span>
      if (m_revalidateStyleAttrTask)
          m_revalidateStyleAttrTask-&gt;reset();
      m_document = nullptr;
  }
  
<span class="line-removed">- void InspectorDOMAgent::setDOMListener(DOMListener* listener)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_domListener = listener;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void InspectorDOMAgent::setDocument(Document* document)
  {
      if (document == m_document.get())
          return;
  
<span class="line-new-header">--- 350,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 416,12 ***</span>
          if (PseudoElement* afterElement = element.afterPseudoElement())
              unbind(afterElement, nodesMap);
      }
  
      nodesMap-&gt;remove(node);
<span class="line-modified">!     if (m_domListener)</span>
<span class="line-modified">!         m_domListener-&gt;didRemoveDOMNode(*node, id);</span>
  
      if (m_childrenRequested.remove(id)) {
          // FIXME: Would be better to do this iteratively rather than recursively.
          for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
              unbind(child, nodesMap);
<span class="line-new-header">--- 409,13 ---</span>
          if (PseudoElement* afterElement = element.afterPseudoElement())
              unbind(afterElement, nodesMap);
      }
  
      nodesMap-&gt;remove(node);
<span class="line-modified">! </span>
<span class="line-modified">!     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-added">+         cssAgent-&gt;didRemoveDOMNode(*node, id);</span>
  
      if (m_childrenRequested.remove(id)) {
          // FIXME: Would be better to do this iteratively rather than recursively.
          for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
              unbind(child, nodesMap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,35 ***</span>
  
  Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = nodeForId(nodeId);
      if (!node) {
<span class="line-modified">!         errorString = &quot;Could not find node with given id&quot;_s;</span>
          return nullptr;
      }
      return node;
  }
  
  Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
<span class="line-modified">!     if (!is&lt;Document&gt;(*node)) {</span>
<span class="line-modified">!         errorString = &quot;Document is not available&quot;_s;</span>
          return nullptr;
      }
      return downcast&lt;Document&gt;(node);
  }
  
  Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
<span class="line-modified">!     if (!is&lt;Element&gt;(*node)) {</span>
<span class="line-modified">!         errorString = &quot;Node is not an Element&quot;_s;</span>
          return nullptr;
      }
      return downcast&lt;Element&gt;(node);
  }
  
<span class="line-new-header">--- 424,35 ---</span>
  
  Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = nodeForId(nodeId);
      if (!node) {
<span class="line-modified">!         errorString = &quot;Missing node for given nodeId&quot;_s;</span>
          return nullptr;
      }
      return node;
  }
  
  Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
<span class="line-modified">!     if (!is&lt;Document&gt;(node)) {</span>
<span class="line-modified">!         errorString = &quot;Node for given nodeId is not a document&quot;_s;</span>
          return nullptr;
      }
      return downcast&lt;Document&gt;(node);
  }
  
  Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
<span class="line-modified">!     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified">!         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
          return nullptr;
      }
      return downcast&lt;Element&gt;(node);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,51 ***</span>
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
      if (node-&gt;isInUserAgentShadowTree()) {
<span class="line-modified">!         errorString = &quot;Cannot edit nodes in user agent shadow trees&quot;_s;</span>
          return nullptr;
      }
      if (node-&gt;isPseudoElement()) {
<span class="line-modified">!         errorString = &quot;Cannot edit pseudo elements&quot;_s;</span>
          return nullptr;
      }
      return node;
  }
  
  Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
  {
<span class="line-modified">!     Element* element = assertElement(errorString, nodeId);</span>
<span class="line-modified">!     if (!element)</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">-     if (element-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-removed">-         errorString = &quot;Cannot edit elements in user agent shadow trees&quot;_s;</span>
          return nullptr;
<span class="line-modified">!     }</span>
<span class="line-modified">!     if (element-&gt;isPseudoElement()) {</span>
<span class="line-removed">-         errorString = &quot;Cannot edit pseudo elements&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">!     return element;</span>
  }
  
  void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
  {
      m_documentRequested = true;
  
      if (!m_document) {
<span class="line-modified">!         errorString = &quot;Document is not available&quot;_s;</span>
          return;
      }
  
      // Reset backend state.
      RefPtr&lt;Document&gt; document = m_document;
      reset();
      m_document = document;
  
      root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
  }
  
  void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
  {
      Node* node = nodeForId(nodeId);
<span class="line-new-header">--- 460,50 ---</span>
  {
      Node* node = assertNode(errorString, nodeId);
      if (!node)
          return nullptr;
      if (node-&gt;isInUserAgentShadowTree()) {
<span class="line-modified">!         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
          return nullptr;
      }
      if (node-&gt;isPseudoElement()) {
<span class="line-modified">!         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;</span>
          return nullptr;
      }
      return node;
  }
  
  Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
  {
<span class="line-modified">!     Node* node = assertEditableNode(errorString, nodeId);</span>
<span class="line-modified">!     if (!node)</span>
          return nullptr;
<span class="line-modified">!     if (!is&lt;Element&gt;(node)) {</span>
<span class="line-modified">!         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
          return nullptr;
      }
<span class="line-modified">!     return downcast&lt;Element&gt;(node);</span>
  }
  
  void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
  {
      m_documentRequested = true;
  
      if (!m_document) {
<span class="line-modified">!         errorString = &quot;Internal error: missing document&quot;_s;</span>
          return;
      }
  
      // Reset backend state.
      RefPtr&lt;Document&gt; document = m_document;
      reset();
      m_document = document;
  
      root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
<span class="line-added">+ </span>
<span class="line-added">+     if (m_nodeToFocus)</span>
<span class="line-added">+         focusNode();</span>
  }
  
  void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
  {
      Node* node = nodeForId(nodeId);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,11 ***</span>
  {
      Document* document = assertDocument(errorString, documentNodeId);
      if (!document)
          return 0;
      if (&amp;nodeToPush-&gt;document() != document) {
<span class="line-modified">!         errorString = &quot;Node is not part of the document with given id&quot;_s;</span>
          return 0;
      }
  
      return pushNodePathToFrontend(nodeToPush);
  }
<span class="line-new-header">--- 545,11 ---</span>
  {
      Document* document = assertDocument(errorString, documentNodeId);
      if (!document)
          return 0;
      if (&amp;nodeToPush-&gt;document() != document) {
<span class="line-modified">!         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;</span>
          return 0;
      }
  
      return pushNodePathToFrontend(nodeToPush);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,11 ***</span>
      else if (*depth == -1)
          sanitizedDepth = INT_MAX;
      else if (*depth &gt; 0)
          sanitizedDepth = *depth;
      else {
<span class="line-modified">!         errorString = &quot;Please provide a positive integer as a depth or -1 for entire subtree&quot;_s;</span>
          return;
      }
  
      pushChildNodesToFrontend(nodeId, sanitizedDepth);
  }
<span class="line-new-header">--- 571,11 ---</span>
      else if (*depth == -1)
          sanitizedDepth = INT_MAX;
      else if (*depth &gt; 0)
          sanitizedDepth = *depth;
      else {
<span class="line-modified">!         errorString = &quot;Unexpected value below -1 for given depth&quot;_s;</span>
          return;
      }
  
      pushChildNodesToFrontend(nodeId, sanitizedDepth);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 598,11 ***</span>
          return;
      }
  
      auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying&quot;_s;</span>
          return;
      }
  
      if (auto* element = queryResult.releaseReturnValue())
          *elementId = pushNodePathToFrontend(element);
<span class="line-new-header">--- 591,11 ---</span>
          return;
      }
  
      auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
          return;
      }
  
      if (auto* element = queryResult.releaseReturnValue())
          *elementId = pushNodePathToFrontend(element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,11 ***</span>
          return;
      }
  
      auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying&quot;_s;</span>
          return;
      }
  
      auto nodes = queryResult.releaseReturnValue();
      result = JSON::ArrayOf&lt;int&gt;::create();
<span class="line-new-header">--- 611,11 ---</span>
          return;
      }
  
      auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying with given selectors&quot;_s;</span>
          return;
      }
  
      auto nodes = queryResult.releaseReturnValue();
      result = JSON::ArrayOf&lt;int&gt;::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,11 ***</span>
  
      while (true) {
          Node* parent = innerParentNode(node);
          if (!parent) {
              // Node being pushed is detached -&gt; push subtree root.
<span class="line-modified">!             auto newMap = std::make_unique&lt;NodeToIdMap&gt;();</span>
              danglingMap = newMap.get();
              m_danglingNodeToIdMaps.append(newMap.release());
              auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
              children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
              m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
<span class="line-new-header">--- 643,11 ---</span>
  
      while (true) {
          Node* parent = innerParentNode(node);
          if (!parent) {
              // Node being pushed is detached -&gt; push subtree root.
<span class="line-modified">!             auto newMap = makeUnique&lt;NodeToIdMap&gt;();</span>
              danglingMap = newMap.get();
              m_danglingNodeToIdMaps.append(newMap.release());
              auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
              children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
              m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,11 ***</span>
          return;
      }
  
      Node* child = parsedElement-&gt;firstChild();
      if (!child) {
<span class="line-modified">!         errorString = &quot;Could not parse value as attributes&quot;_s;</span>
          return;
      }
  
      Element* childElement = downcast&lt;Element&gt;(child);
      if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
<span class="line-new-header">--- 697,11 ---</span>
          return;
      }
  
      Node* child = parsedElement-&gt;firstChild();
      if (!child) {
<span class="line-modified">!         errorString = &quot;Could not parse given text&quot;_s;</span>
          return;
      }
  
      Element* childElement = downcast&lt;Element&gt;(child);
      if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 807,11 ***</span>
      if (!node)
          return;
  
      Document&amp; document = node-&gt;document();
      if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
<span class="line-modified">!         errorString = &quot;Not an HTML/XML document&quot;_s;</span>
          return;
      }
  
      Node* newNode = nullptr;
      if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
<span class="line-new-header">--- 800,11 ---</span>
      if (!node)
          return;
  
      Document&amp; document = node-&gt;document();
      if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
<span class="line-modified">!         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;</span>
          return;
      }
  
      Node* newNode = nullptr;
      if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,11 ***</span>
      Node* node = assertEditableNode(errorString, nodeId);
      if (!node)
          return;
  
      if (!is&lt;Element&gt;(node)) {
<span class="line-modified">!         errorString = &quot;Can only call insertAdjacentHTML on Elements.&quot;_s;</span>
          return;
      }
  
      m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
  }
<span class="line-new-header">--- 827,11 ---</span>
      Node* node = assertEditableNode(errorString, nodeId);
      if (!node)
          return;
  
      if (!is&lt;Element&gt;(node)) {
<span class="line-modified">!         errorString = &quot;Node for given nodeId is not an element&quot;_s;</span>
          return;
      }
  
      m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,11 ***</span>
      Node* node = assertEditableNode(errorString, nodeId);
      if (!node)
          return;
  
      if (!is&lt;Text&gt;(*node)) {
<span class="line-modified">!         errorString = &quot;Can only set value of text nodes&quot;_s;</span>
          return;
      }
  
      m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
  }
<span class="line-new-header">--- 841,11 ---</span>
      Node* node = assertEditableNode(errorString, nodeId);
      if (!node)
          return;
  
      if (!is&lt;Text&gt;(*node)) {
<span class="line-modified">!         errorString = &quot;Node for given nodeId is not text&quot;_s;</span>
          return;
      }
  
      m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,124 ***</span>
  #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
      DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
  #undef DOM_EVENT_NAMES_ADD
  }
  
<span class="line-modified">! void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)</span>
  {
      listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
<span class="line-modified">!     Node* node = assertNode(errorString, nodeId);</span>
      if (!node)
          return;
      Vector&lt;EventListenerInfo&gt; eventInformation;
<span class="line-modified">!     getEventListeners(node, eventInformation, true);</span>
  
      auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
          int identifier = 0;
          bool disabled = false;
          bool hasBreakpoint = false;
  
          for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
<span class="line-modified">!             if (inspectorEventListener.matches(*info.node, info.eventType, listener.callback(), listener.useCapture())) {</span>
                  identifier = inspectorEventListener.identifier;
                  disabled = inspectorEventListener.disabled;
                  hasBreakpoint = inspectorEventListener.hasBreakpoint;
                  break;
              }
          }
  
          if (!identifier) {
<span class="line-modified">!             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.node, info.eventType, listener.callback(), listener.useCapture());</span>
  
              identifier = inspectorEventListener.identifier;
              disabled = inspectorEventListener.disabled;
              hasBreakpoint = inspectorEventListener.hasBreakpoint;
  
              m_eventListenerEntries.add(identifier, inspectorEventListener);
          }
  
<span class="line-modified">!         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, info.eventType, info.node, objectGroup, disabled, hasBreakpoint));</span>
      };
  
      // Get Capturing Listeners (in this order)
      size_t eventInformationLength = eventInformation.size();
      for (auto&amp; info : eventInformation) {
<span class="line-modified">!         for (auto&amp; listener : info.eventListenerVector) {</span>
              if (listener-&gt;useCapture())
                  addListener(*listener, info);
          }
      }
  
      // Get Bubbling Listeners (reverse order)
      for (size_t i = eventInformationLength; i; --i) {
          const EventListenerInfo&amp; info = eventInformation[i - 1];
<span class="line-modified">!         for (auto&amp; listener : info.eventListenerVector) {</span>
              if (!listener-&gt;useCapture())
                  addListener(*listener, info);
          }
      }
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InspectorDOMAgent::getEventListeners(Node* node, Vector&lt;EventListenerInfo&gt;&amp; eventInformation, bool includeAncestors)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // The Node&#39;s Ancestors including self.</span>
<span class="line-removed">-     Vector&lt;Node*&gt; ancestors;</span>
<span class="line-removed">-     // Push this node as the firs element.</span>
<span class="line-removed">-     ancestors.append(node);</span>
<span class="line-removed">-     if (includeAncestors) {</span>
<span class="line-removed">-         for (ContainerNode* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())</span>
<span class="line-removed">-             ancestors.append(ancestor);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     // Nodes and their Listeners for the concerned event types (order is top to bottom)</span>
<span class="line-modified">!     for (size_t i = ancestors.size(); i; --i) {</span>
<span class="line-removed">-         Node* ancestor = ancestors[i - 1];</span>
<span class="line-removed">-         EventTargetData* d = ancestor-&gt;eventTargetData();</span>
<span class="line-removed">-         if (!d)</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         // Get the list of event types this Node is concerned with</span>
<span class="line-removed">-         for (auto&amp; type : d-&gt;eventListenerMap.eventTypes()) {</span>
<span class="line-removed">-             auto&amp; listeners = ancestor-&gt;eventListeners(type);</span>
<span class="line-removed">-             EventListenerVector filteredListeners;</span>
<span class="line-removed">-             filteredListeners.reserveInitialCapacity(listeners.size());</span>
<span class="line-removed">-             for (auto&amp; listener : listeners) {</span>
<span class="line-removed">-                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)</span>
<span class="line-removed">-                     filteredListeners.uncheckedAppend(listener);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (!filteredListeners.isEmpty())</span>
<span class="line-removed">-                 eventInformation.append(EventListenerInfo(ancestor, type, WTFMove(filteredListeners)));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
  
  void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
          return;
      }
  
      it-&gt;value.disabled = disabled;
  }
  
  void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
          return;
      }
  
      it-&gt;value.hasBreakpoint = true;
  }
  
  void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;No event listener for given identifier.&quot;_s;</span>
          return;
      }
  
      it-&gt;value.hasBreakpoint = false;
  }
<span class="line-new-header">--- 857,131 ---</span>
  #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
      DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
  #undef DOM_EVENT_NAMES_ADD
  }
  
<span class="line-modified">! void InspectorDOMAgent::getDataBindingsForNode(ErrorString&amp; errorString, int /* nodeId */, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; /* dataBindings */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorDOMAgent::getAssociatedDataForNode(ErrorString&amp; errorString, int /* nodeId */, Optional&lt;String&gt;&amp; /* associatedData */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)</span>
  {
      listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
<span class="line-modified">! </span>
<span class="line-added">+     auto* node = assertNode(errorString, nodeId);</span>
      if (!node)
          return;
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;RefPtr&lt;EventTarget&gt;&gt; ancestors;</span>
<span class="line-added">+     ancestors.append(node);</span>
<span class="line-added">+     for (auto* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())</span>
<span class="line-added">+         ancestors.append(ancestor);</span>
<span class="line-added">+     if (auto* window = node-&gt;document().domWindow())</span>
<span class="line-added">+         ancestors.append(window);</span>
<span class="line-added">+ </span>
<span class="line-added">+     struct EventListenerInfo {</span>
<span class="line-added">+         RefPtr&lt;EventTarget&gt; eventTarget;</span>
<span class="line-added">+         const AtomString eventType;</span>
<span class="line-added">+         const EventListenerVector eventListeners;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      Vector&lt;EventListenerInfo&gt; eventInformation;
<span class="line-modified">!     for (size_t i = ancestors.size(); i; --i) {</span>
<span class="line-added">+         auto&amp; ancestor = ancestors[i - 1];</span>
<span class="line-added">+         for (auto&amp; eventType : ancestor-&gt;eventTypes()) {</span>
<span class="line-added">+             EventListenerVector filteredListeners;</span>
<span class="line-added">+             for (auto&amp; listener : ancestor-&gt;eventListeners(eventType)) {</span>
<span class="line-added">+                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)</span>
<span class="line-added">+                     filteredListeners.append(listener);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!filteredListeners.isEmpty())</span>
<span class="line-added">+                 eventInformation.append({ ancestor, eventType, WTFMove(filteredListeners) });</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
          int identifier = 0;
          bool disabled = false;
          bool hasBreakpoint = false;
  
          for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
<span class="line-modified">!             if (inspectorEventListener.matches(*info.eventTarget, info.eventType, listener.callback(), listener.useCapture())) {</span>
                  identifier = inspectorEventListener.identifier;
                  disabled = inspectorEventListener.disabled;
                  hasBreakpoint = inspectorEventListener.hasBreakpoint;
                  break;
              }
          }
  
          if (!identifier) {
<span class="line-modified">!             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.eventTarget, info.eventType, listener.callback(), listener.useCapture());</span>
  
              identifier = inspectorEventListener.identifier;
              disabled = inspectorEventListener.disabled;
              hasBreakpoint = inspectorEventListener.hasBreakpoint;
  
              m_eventListenerEntries.add(identifier, inspectorEventListener);
          }
  
<span class="line-modified">!         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, *info.eventTarget, info.eventType, disabled, hasBreakpoint));</span>
      };
  
      // Get Capturing Listeners (in this order)
      size_t eventInformationLength = eventInformation.size();
      for (auto&amp; info : eventInformation) {
<span class="line-modified">!         for (auto&amp; listener : info.eventListeners) {</span>
              if (listener-&gt;useCapture())
                  addListener(*listener, info);
          }
      }
  
      // Get Bubbling Listeners (reverse order)
      for (size_t i = eventInformationLength; i; --i) {
          const EventListenerInfo&amp; info = eventInformation[i - 1];
<span class="line-modified">!         for (auto&amp; listener : info.eventListeners) {</span>
              if (!listener-&gt;useCapture())
                  addListener(*listener, info);
          }
      }
  
<span class="line-modified">!     if (m_inspectedNode == node)</span>
<span class="line-modified">!         m_suppressEventListenerChangedEvent = false;</span>
  }
  
  void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
          return;
      }
  
      it-&gt;value.disabled = disabled;
  }
  
  void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
          return;
      }
  
      it-&gt;value.hasBreakpoint = true;
  }
  
  void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
  {
      auto it = m_eventListenerEntries.find(eventListenerId);
      if (it == m_eventListenerEntries.end()) {
<span class="line-modified">!         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;</span>
          return;
      }
  
      it-&gt;value.hasBreakpoint = false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,24 ***</span>
          return;
  
      axProperties = buildObjectForAccessibilityProperties(node);
  }
  
<span class="line-modified">! void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; whitespaceTrimmedQuery, const JSON::Array* nodeIds, String* searchId, int* resultCount)</span>
  {
      // FIXME: Search works with node granularity - number of matches within node is not calculated.
<span class="line-modified">!     InspectorNodeFinder finder(whitespaceTrimmedQuery);</span>
  
      if (nodeIds) {
          for (auto&amp; nodeValue : *nodeIds) {
              if (!nodeValue) {
<span class="line-modified">!                 errorString = &quot;Invalid nodeIds item.&quot;_s;</span>
                  return;
              }
              int nodeId = 0;
              if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">!                 errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;</span>
                  return;
              }
              Node* node = assertNode(errorString, nodeId);
              if (!node) {
                  // assertNode should have filled the errorString for us.
<span class="line-new-header">--- 993,24 ---</span>
          return;
  
      axProperties = buildObjectForAccessibilityProperties(node);
  }
  
<span class="line-modified">! void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount)</span>
  {
      // FIXME: Search works with node granularity - number of matches within node is not calculated.
<span class="line-modified">!     InspectorNodeFinder finder(query, caseSensitive &amp;&amp; *caseSensitive);</span>
  
      if (nodeIds) {
          for (auto&amp; nodeValue : *nodeIds) {
              if (!nodeValue) {
<span class="line-modified">!                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
                  return;
              }
              int nodeId = 0;
              if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">!                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
                  return;
              }
              Node* node = assertNode(errorString, nodeId);
              if (!node) {
                  // assertNode should have filled the errorString for us.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1036,17 ***</span>
  
  void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
  {
      SearchResults::iterator it = m_searchResults.find(searchId);
      if (it == m_searchResults.end()) {
<span class="line-modified">!         errorString = &quot;No search session with given id found&quot;_s;</span>
          return;
      }
  
      int size = it-&gt;value.size();
      if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
<span class="line-modified">!         errorString = &quot;Invalid search result range&quot;_s;</span>
          return;
      }
  
      nodeIds = JSON::ArrayOf&lt;int&gt;::create();
      for (int i = fromIndex; i &lt; toIndex; ++i)
<span class="line-new-header">--- 1036,17 ---</span>
  
  void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
  {
      SearchResults::iterator it = m_searchResults.find(searchId);
      if (it == m_searchResults.end()) {
<span class="line-modified">!         errorString = &quot;Missing search result for given searchId&quot;_s;</span>
          return;
      }
  
      int size = it-&gt;value.size();
      if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
<span class="line-modified">!         errorString = &quot;Invalid search result range for given fromIndex and toIndex&quot;_s;</span>
          return;
      }
  
      nodeIds = JSON::ArrayOf&lt;int&gt;::create();
      for (int i = fromIndex; i &lt; toIndex; ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1082,13 ***</span>
      return false;
  }
  
  void InspectorDOMAgent::inspect(Node* inspectedNode)
  {
<span class="line-modified">!     ErrorString unused;</span>
      RefPtr&lt;Node&gt; node = inspectedNode;
<span class="line-modified">!     setSearchingForNode(unused, false, nullptr);</span>
  
      if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
          node = node-&gt;parentNode();
      m_nodeToFocus = node;
  
<span class="line-new-header">--- 1082,13 ---</span>
      return false;
  }
  
  void InspectorDOMAgent::inspect(Node* inspectedNode)
  {
<span class="line-modified">!     ErrorString ignored;</span>
      RefPtr&lt;Node&gt; node = inspectedNode;
<span class="line-modified">!     setSearchingForNode(ignored, false, nullptr, false);</span>
  
      if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
          node = node-&gt;parentNode();
      m_nodeToFocus = node;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1098,11 ***</span>
      focusNode();
  }
  
  void InspectorDOMAgent::focusNode()
  {
<span class="line-modified">!     if (!m_frontendDispatcher)</span>
          return;
  
      ASSERT(m_nodeToFocus);
  
      RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
<span class="line-new-header">--- 1098,11 ---</span>
      focusNode();
  }
  
  void InspectorDOMAgent::focusNode()
  {
<span class="line-modified">!     if (!m_documentRequested)</span>
          return;
  
      ASSERT(m_nodeToFocus);
  
      RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1137,39 ***</span>
          node = node-&gt;parentNode();
      if (node &amp;&amp; m_inspectModeHighlightConfig)
          m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
  }
  
<span class="line-modified">! void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject)</span>
  {
      if (m_searchingForNode == enabled)
          return;
  
      m_searchingForNode = enabled;
  
<span class="line-modified">!     if (enabled) {</span>
          m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
          if (!m_inspectModeHighlightConfig)
              return;
          highlightMousedOverNode();
      } else
          hideHighlight(errorString);
  
      m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
  
<span class="line-modified">!     if (InspectorClient* client = m_pageAgent-&gt;page().inspectorController().inspectorClient())</span>
          client-&gt;elementSelectionChanged(m_searchingForNode);
  }
  
  std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
  {
      if (!highlightInspectorObject) {
          errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
          return nullptr;
      }
  
<span class="line-modified">!     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
      bool showInfo = false; // Default: false (do not show a tooltip).
      highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
      highlightConfig-&gt;showInfo = showInfo;
      highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
      highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
<span class="line-new-header">--- 1137,41 ---</span>
          node = node-&gt;parentNode();
      if (node &amp;&amp; m_inspectModeHighlightConfig)
          m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
  }
  
<span class="line-modified">! void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject, bool showRulers)</span>
  {
      if (m_searchingForNode == enabled)
          return;
  
      m_searchingForNode = enabled;
  
<span class="line-modified">!     m_overlay-&gt;setShowRulersDuringElementSelection(m_searchingForNode &amp;&amp; showRulers);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_searchingForNode) {</span>
          m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
          if (!m_inspectModeHighlightConfig)
              return;
          highlightMousedOverNode();
      } else
          hideHighlight(errorString);
  
      m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
  
<span class="line-modified">!     if (InspectorClient* client = m_inspectedPage.inspectorController().inspectorClient())</span>
          client-&gt;elementSelectionChanged(m_searchingForNode);
  }
  
  std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
  {
      if (!highlightInspectorObject) {
          errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
          return nullptr;
      }
  
<span class="line-modified">!     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
      bool showInfo = false; // Default: false (do not show a tooltip).
      highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
      highlightConfig-&gt;showInfo = showInfo;
      highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
      highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1177,34 ***</span>
      highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
      highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
      return highlightConfig;
  }
  
<span class="line-modified">! void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig)</span>
  {
<span class="line-modified">!     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr);</span>
  }
  
  void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto quad = std::make_unique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));</span>
      innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
  }
  
  void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto quad = std::make_unique&lt;FloatQuad&gt;();</span>
      if (!parseQuad(quadArray, quad.get())) {
<span class="line-modified">!         errorString = &quot;Invalid Quad format&quot;_s;</span>
          return;
      }
      innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
  }
  
  void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
      highlightConfig-&gt;content = parseColor(color);
      highlightConfig-&gt;contentOutline = parseColor(outlineColor);
      highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
      m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
  }
<span class="line-new-header">--- 1179,34 ---</span>
      highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
      highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
      return highlightConfig;
  }
  
<span class="line-modified">! void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers)</span>
  {
<span class="line-modified">!     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr, showRulers &amp;&amp; *showRulers);</span>
  }
  
  void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto quad = makeUnique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));</span>
      innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
  }
  
  void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto quad = makeUnique&lt;FloatQuad&gt;();</span>
      if (!parseQuad(quadArray, quad.get())) {
<span class="line-modified">!         errorString = &quot;Unexpected invalid quadArray&quot;_s;</span>
          return;
      }
      innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
  }
  
  void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
  {
<span class="line-modified">!     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
      highlightConfig-&gt;content = parseColor(color);
      highlightConfig-&gt;contentOutline = parseColor(outlineColor);
      highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
      m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1212,29 ***</span>
  void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
  {
      RefPtr&lt;Document&gt; document;
  
      if (frameId) {
<span class="line-modified">!         Frame* frame = m_pageAgent-&gt;frameForId(*frameId);</span>
<span class="line-modified">!         if (!frame) {</span>
<span class="line-modified">!             errorString = &quot;No frame for given id found&quot;_s;</span>
              return;
          }
  
          document = frame-&gt;document();
      } else
          document = m_document;
  
      if (!document) {
<span class="line-modified">!         errorString = &quot;Document could not be found&quot;_s;</span>
          return;
      }
  
      auto queryResult = document-&gt;querySelectorAll(selectorString);
      // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying&quot;_s;</span>
          return;
      }
  
      auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
      if (!highlightConfig)
<span class="line-new-header">--- 1214,33 ---</span>
  void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
  {
      RefPtr&lt;Document&gt; document;
  
      if (frameId) {
<span class="line-modified">!         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-modified">!         if (!pageAgent) {</span>
<span class="line-modified">!             errorString = &quot;Page domain must be enabled&quot;_s;</span>
              return;
          }
  
<span class="line-added">+         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);</span>
<span class="line-added">+         if (!frame)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
          document = frame-&gt;document();
      } else
          document = m_document;
  
      if (!document) {
<span class="line-modified">!         errorString = &quot;Missing document of frame for given frameId&quot;_s;</span>
          return;
      }
  
      auto queryResult = document-&gt;querySelectorAll(selectorString);
      // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;
      if (queryResult.hasException()) {
<span class="line-modified">!         errorString = &quot;DOM Error while querying with given selectorString&quot;_s;</span>
          return;
      }
  
      auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
      if (!highlightConfig)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,11 ***</span>
      if (nodeId)
          node = assertNode(errorString, *nodeId);
      else if (objectId) {
          node = nodeForObjectId(*objectId);
          if (!node)
<span class="line-modified">!             errorString = &quot;Node for given objectId not found&quot;_s;</span>
      } else
          errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
  
      if (!node)
          return;
<span class="line-new-header">--- 1255,11 ---</span>
      if (nodeId)
          node = assertNode(errorString, *nodeId);
      else if (objectId) {
          node = nodeForObjectId(*objectId);
          if (!node)
<span class="line-modified">!             errorString = &quot;Missing node for given objectId&quot;_s;</span>
      } else
          errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
  
      if (!node)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,17 ***</span>
  void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
  {
      Vector&lt;Ref&lt;Node&gt;&gt; nodes;
      for (auto&amp; nodeValue : nodeIds) {
          if (!nodeValue) {
<span class="line-modified">!             errorString = &quot;Invalid nodeIds item.&quot;_s;</span>
              return;
          }
  
          int nodeId = 0;
          if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">!             errorString = &quot;Invalid nodeIds item type. Expecting integer types.&quot;_s;</span>
              return;
          }
  
          // In the case that a node is removed in the time between when highlightNodeList is invoked
          // by the frontend and it is executed by the backend, we should still attempt to highlight
<span class="line-new-header">--- 1274,17 ---</span>
  void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
  {
      Vector&lt;Ref&lt;Node&gt;&gt; nodes;
      for (auto&amp; nodeValue : nodeIds) {
          if (!nodeValue) {
<span class="line-modified">!             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
              return;
          }
  
          int nodeId = 0;
          if (!nodeValue-&gt;asInteger(nodeId)) {
<span class="line-modified">!             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;</span>
              return;
          }
  
          // In the case that a node is removed in the time between when highlightNodeList is invoked
          // by the frontend and it is executed by the backend, we should still attempt to highlight
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1299,16 ***</span>
      m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
  }
  
  void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
  {
<span class="line-modified">!     Frame* frame = m_pageAgent-&gt;assertFrame(errorString, frameId);</span>
      if (!frame)
          return;
  
      if (frame-&gt;ownerElement()) {
<span class="line-modified">!         auto highlightConfig = std::make_unique&lt;HighlightConfig&gt;();</span>
          highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
          highlightConfig-&gt;content = parseColor(color);
          highlightConfig-&gt;contentOutline = parseColor(outlineColor);
          m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
      }
<span class="line-new-header">--- 1305,22 ---</span>
      m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
  }
  
  void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
  {
<span class="line-modified">!     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">+     if (!pageAgent) {</span>
<span class="line-added">+         errorString = &quot;Page domain must be enabled&quot;_s;</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* frame = pageAgent-&gt;assertFrame(errorString, frameId);</span>
      if (!frame)
          return;
  
      if (frame-&gt;ownerElement()) {
<span class="line-modified">!         auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();</span>
          highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
          highlightConfig-&gt;content = parseColor(color);
          highlightConfig-&gt;contentOutline = parseColor(outlineColor);
          m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1333,11 ***</span>
      if (anchorNodeId &amp;&amp; *anchorNodeId) {
          anchorNode = assertEditableNode(errorString, *anchorNodeId);
          if (!anchorNode)
              return;
          if (anchorNode-&gt;parentNode() != targetElement) {
<span class="line-modified">!             errorString = &quot;Anchor node must be child of the target element&quot;_s;</span>
              return;
          }
      }
  
      if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
<span class="line-new-header">--- 1345,11 ---</span>
      if (anchorNodeId &amp;&amp; *anchorNodeId) {
          anchorNode = assertEditableNode(errorString, *anchorNodeId);
          if (!anchorNode)
              return;
          if (anchorNode-&gt;parentNode() != targetElement) {
<span class="line-modified">!             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;</span>
              return;
          }
      }
  
      if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1369,39 ***</span>
  {
      Element* element = assertElement(errorString, nodeId);
      if (!element)
          return;
      if (!element-&gt;isFocusable()) {
<span class="line-modified">!         errorString = &quot;Element is not focusable&quot;_s;</span>
          return;
      }
      element-&gt;focus();
  }
  
  void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
  {
<span class="line-modified">!     Node* node = nodeForId(nodeId);</span>
<span class="line-modified">!     if (!node || node-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-modified">!         errorString = &quot;No node with given id found&quot;_s;</span>
          return;
      }
  
<span class="line-modified">!     if (CommandLineAPIHost* commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())</span>
<span class="line-modified">!         commandLineAPIHost-&gt;addInspectedObject(std::make_unique&lt;InspectableNode&gt;(node));</span>
  }
  
  void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
  {
      String objectGroupName = objectGroup ? *objectGroup : emptyString();
<span class="line-modified">!     Node* node = nodeForId(nodeId);</span>
<span class="line-modified">!     if (!node) {</span>
<span class="line-removed">-         errorString = &quot;No node with given id found&quot;_s;</span>
          return;
<span class="line-removed">-     }</span>
      RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
      if (!object) {
<span class="line-modified">!         errorString = &quot;Node with given id does not belong to the document&quot;_s;</span>
          return;
      }
      result = object;
  }
  
<span class="line-new-header">--- 1381,44 ---</span>
  {
      Element* element = assertElement(errorString, nodeId);
      if (!element)
          return;
      if (!element-&gt;isFocusable()) {
<span class="line-modified">!         errorString = &quot;Element for given nodeId is not focusable&quot;_s;</span>
          return;
      }
      element-&gt;focus();
  }
  
  void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
  {
<span class="line-modified">!     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">!     if (!node)</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (node-&gt;isInUserAgentShadowTree()) {</span>
<span class="line-added">+         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;</span>
          return;
      }
  
<span class="line-modified">!     m_inspectedNode = node;</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())</span>
<span class="line-added">+         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_suppressEventListenerChangedEvent = false;</span>
  }
  
  void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
  {
      String objectGroupName = objectGroup ? *objectGroup : emptyString();
<span class="line-modified">!     Node* node = assertNode(errorString, nodeId);</span>
<span class="line-modified">!     if (!node)</span>
          return;
      RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
      if (!object) {
<span class="line-modified">!         errorString = &quot;Missing injected script for given nodeId&quot;_s;</span>
          return;
      }
      result = object;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1535,20 ***</span>
          Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
          if (children-&gt;length() &gt; 0)
              value-&gt;setChildren(WTFMove(children));
      }
  
      if (is&lt;Element&gt;(*node)) {
          Element&amp; element = downcast&lt;Element&gt;(*node);
          value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
          if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
<span class="line-modified">!             HTMLFrameOwnerElement&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(element);</span>
<span class="line-removed">-             Frame* frame = frameOwner.contentFrame();</span>
<span class="line-removed">-             if (frame)</span>
<span class="line-removed">-                 value-&gt;setFrameId(m_pageAgent-&gt;frameId(frame));</span>
<span class="line-removed">-             Document* document = frameOwner.contentDocument();</span>
<span class="line-removed">-             if (document)</span>
                  value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
          }
  
          if (ShadowRoot* root = element.shadowRoot()) {
              auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
<span class="line-new-header">--- 1552,21 ---</span>
          Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
          if (children-&gt;length() &gt; 0)
              value-&gt;setChildren(WTFMove(children));
      }
  
<span class="line-added">+     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();</span>
<span class="line-added">+     if (pageAgent) {</span>
<span class="line-added">+         if (auto* frameView = node-&gt;document().view())</span>
<span class="line-added">+             value-&gt;setFrameId(pageAgent-&gt;frameId(&amp;frameView-&gt;frame()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (is&lt;Element&gt;(*node)) {
          Element&amp; element = downcast&lt;Element&gt;(*node);
          value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
          if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
<span class="line-modified">!             if (auto* document = downcast&lt;HTMLFrameOwnerElement&gt;(element).contentDocument())</span>
                  value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
          }
  
          if (ShadowRoot* root = element.shadowRoot()) {
              auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1572,14 ***</span>
                  value-&gt;setPseudoType(pseudoType);
          } else {
              if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
                  value-&gt;setPseudoElements(WTFMove(pseudoElements));
          }
<span class="line-removed">- </span>
      } else if (is&lt;Document&gt;(*node)) {
          Document&amp; document = downcast&lt;Document&gt;(*node);
<span class="line-modified">!         value-&gt;setFrameId(m_pageAgent-&gt;frameId(document.frame()));</span>
          value-&gt;setDocumentURL(documentURLString(&amp;document));
          value-&gt;setBaseURL(documentBaseURLString(&amp;document));
          value-&gt;setXmlVersion(document.xmlVersion());
      } else if (is&lt;DocumentType&gt;(*node)) {
          DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
<span class="line-new-header">--- 1590,14 ---</span>
                  value-&gt;setPseudoType(pseudoType);
          } else {
              if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
                  value-&gt;setPseudoElements(WTFMove(pseudoElements));
          }
      } else if (is&lt;Document&gt;(*node)) {
          Document&amp; document = downcast&lt;Document&gt;(*node);
<span class="line-modified">!         if (pageAgent)</span>
<span class="line-added">+             value-&gt;setFrameId(pageAgent-&gt;frameId(document.frame()));</span>
          value-&gt;setDocumentURL(documentURLString(&amp;document));
          value-&gt;setBaseURL(documentBaseURLString(&amp;document));
          value-&gt;setXmlVersion(document.xmlVersion());
      } else if (is&lt;DocumentType&gt;(*node)) {
          DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1645,54 ***</span>
      auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
      if (beforeElement)
          pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
      if (afterElement)
          pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
<span class="line-modified">!     return WTFMove(pseudoElements);</span>
  }
  
<span class="line-modified">! Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, const AtomicString&amp; eventType, Node* node, const String* objectGroupId, bool disabled, bool hasBreakpoint)</span>
  {
      Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
  
<span class="line-removed">-     JSC::ExecState* exec = nullptr;</span>
<span class="line-removed">-     JSC::JSObject* handlerObject = nullptr;</span>
<span class="line-removed">-     JSC::JSFunction* handlerFunction = nullptr;</span>
      String handlerName;
      int lineNumber = 0;
      int columnNumber = 0;
      String scriptID;
      if (is&lt;JSEventListener&gt;(eventListener.get())) {
          auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
  
          JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
  
<span class="line-modified">!         exec = execStateFromNode(scriptListener.isolatedWorld(), &amp;node-&gt;document());</span>
<span class="line-modified">!         handlerObject = scriptListener.jsFunction(node-&gt;document());</span>
          if (handlerObject &amp;&amp; exec) {
<span class="line-modified">!             handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handlerObject);</span>
  
              if (!handlerFunction) {
<span class="line-modified">!                 auto scope = DECLARE_CATCH_SCOPE(exec-&gt;vm());</span>
  
                  // If the handler is not actually a function, see if it implements the EventListener interface and use that.
<span class="line-modified">!                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(exec, &quot;handleEvent&quot;));</span>
  
                  if (UNLIKELY(scope.exception()))
                      scope.clearException();
  
                  if (handleEventValue)
<span class="line-modified">!                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(exec-&gt;vm(), handleEventValue);</span>
              }
  
              if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
                  // If the listener implements the EventListener interface, use the class name instead of
                  // &quot;handleEvent&quot;, unless it is a plain object.
                  if (handlerFunction != handlerObject)
                      handlerName = JSC::JSObject::calculatedClassName(handlerObject);
                  if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
<span class="line-modified">!                     handlerName = handlerFunction-&gt;calculatedDisplayName(exec-&gt;vm());</span>
  
                  if (auto executable = handlerFunction-&gt;jsExecutable()) {
                      lineNumber = executable-&gt;firstLine() - 1;
                      columnNumber = executable-&gt;startColumn() - 1;
                      scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
<span class="line-new-header">--- 1663,65 ---</span>
      auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
      if (beforeElement)
          pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
      if (afterElement)
          pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
<span class="line-modified">!     return pseudoElements;</span>
  }
  
<span class="line-modified">! Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)</span>
  {
      Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
  
      String handlerName;
      int lineNumber = 0;
      int columnNumber = 0;
      String scriptID;
      if (is&lt;JSEventListener&gt;(eventListener.get())) {
          auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
  
<span class="line-added">+         Document* document = nullptr;</span>
<span class="line-added">+         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {</span>
<span class="line-added">+             if (is&lt;Document&gt;(scriptExecutionContext))</span>
<span class="line-added">+                 document = downcast&lt;Document&gt;(scriptExecutionContext);</span>
<span class="line-added">+         } else if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-added">+             document = &amp;downcast&lt;Node&gt;(eventTarget).document();</span>
<span class="line-added">+ </span>
<span class="line-added">+         JSC::JSObject* handlerObject = nullptr;</span>
<span class="line-added">+         JSC::ExecState* exec = nullptr;</span>
<span class="line-added">+ </span>
          JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
  
<span class="line-modified">!         if (document) {</span>
<span class="line-modified">!             handlerObject = scriptListener.jsFunction(*document);</span>
<span class="line-added">+             exec = execStateFromNode(scriptListener.isolatedWorld(), document);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          if (handlerObject &amp;&amp; exec) {
<span class="line-modified">!             JSC::VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added">+             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);</span>
  
              if (!handlerFunction) {
<span class="line-modified">!                 auto scope = DECLARE_CATCH_SCOPE(vm);</span>
  
                  // If the handler is not actually a function, see if it implements the EventListener interface and use that.
<span class="line-modified">!                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
  
                  if (UNLIKELY(scope.exception()))
                      scope.clearException();
  
                  if (handleEventValue)
<span class="line-modified">!                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handleEventValue);</span>
              }
  
              if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
                  // If the listener implements the EventListener interface, use the class name instead of
                  // &quot;handleEvent&quot;, unless it is a plain object.
                  if (handlerFunction != handlerObject)
                      handlerName = JSC::JSObject::calculatedClassName(handlerObject);
                  if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
<span class="line-modified">!                     handlerName = handlerFunction-&gt;calculatedDisplayName(vm);</span>
  
                  if (auto executable = handlerFunction-&gt;jsExecutable()) {
                      lineNumber = executable-&gt;firstLine() - 1;
                      columnNumber = executable-&gt;startColumn() - 1;
                      scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1704,17 ***</span>
      auto value = Inspector::Protocol::DOM::EventListener::create()
          .setEventListenerId(identifier)
          .setType(eventType)
          .setUseCapture(registeredEventListener.useCapture())
          .setIsAttribute(eventListener-&gt;isAttribute())
<span class="line-removed">-         .setNodeId(pushNodePathToFrontend(node))</span>
          .release();
<span class="line-modified">!     if (objectGroupId &amp;&amp; handlerObject &amp;&amp; exec) {</span>
<span class="line-modified">!         InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(exec);</span>
<span class="line-modified">!         if (!injectedScript.hasNoValue())</span>
<span class="line-modified">!             value-&gt;setHandlerObject(injectedScript.wrapObject(handlerObject, *objectGroupId));</span>
<span class="line-removed">-     }</span>
      if (!scriptID.isNull()) {
          auto location = Inspector::Protocol::Debugger::Location::create()
              .setScriptId(scriptID)
              .setLineNumber(lineNumber)
              .release();
<span class="line-new-header">--- 1733,15 ---</span>
      auto value = Inspector::Protocol::DOM::EventListener::create()
          .setEventListenerId(identifier)
          .setType(eventType)
          .setUseCapture(registeredEventListener.useCapture())
          .setIsAttribute(eventListener-&gt;isAttribute())
          .release();
<span class="line-modified">!     if (is&lt;Node&gt;(eventTarget))</span>
<span class="line-modified">!         value-&gt;setNodeId(pushNodePathToFrontend(&amp;downcast&lt;Node&gt;(eventTarget)));</span>
<span class="line-modified">!     else if (is&lt;DOMWindow&gt;(eventTarget))</span>
<span class="line-modified">!         value-&gt;setOnWindow(true);</span>
      if (!scriptID.isNull()) {
          auto location = Inspector::Protocol::Debugger::Location::create()
              .setScriptId(scriptID)
              .setLineNumber(lineNumber)
              .release();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2048,11 ***</span>
              value-&gt;setHierarchyLevel(level);
          if (isPopupButton)
              value-&gt;setIsPopUpButton(isPopupButton);
      }
  
<span class="line-modified">!     return WTFMove(value);</span>
  }
  
  static bool containsOnlyHTMLWhitespace(Node* node)
  {
      // FIXME: Respect ignoreWhitespace setting from inspector front end?
<span class="line-new-header">--- 2075,11 ---</span>
              value-&gt;setHierarchyLevel(level);
          if (isPopupButton)
              value-&gt;setIsPopUpButton(isPopupButton);
      }
  
<span class="line-modified">!     return value;</span>
  }
  
  static bool containsOnlyHTMLWhitespace(Node* node)
  {
      // FIXME: Respect ignoreWhitespace setting from inspector front end?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2101,10 ***</span>
<span class="line-new-header">--- 2128,19 ---</span>
      return node-&gt;parentNode();
  }
  
  void InspectorDOMAgent::didCommitLoad(Document* document)
  {
<span class="line-added">+     if (m_nodeToFocus &amp;&amp; &amp;m_nodeToFocus-&gt;document() == document)</span>
<span class="line-added">+         m_nodeToFocus = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_mousedOverNode &amp;&amp; &amp;m_mousedOverNode-&gt;document() == document)</span>
<span class="line-added">+         m_mousedOverNode = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_inspectedNode &amp;&amp; &amp;m_inspectedNode-&gt;document() == document)</span>
<span class="line-added">+         m_inspectedNode = nullptr;</span>
<span class="line-added">+ </span>
      RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
      if (!frameOwner)
          return;
  
      int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2130,11 ***</span>
  void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
  {
  #if ENABLE(VIDEO)
      auto callback = EventFiredCallback::create(*this);
  
<span class="line-modified">!     auto createEventListener = [&amp;] (const AtomicString&amp; eventName) {</span>
          node.addEventListener(eventName, callback.copyRef(), false);
      };
  
  #if ENABLE(FULLSCREEN_API)
      if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
<span class="line-new-header">--- 2166,11 ---</span>
  void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
  {
  #if ENABLE(VIDEO)
      auto callback = EventFiredCallback::create(*this);
  
<span class="line-modified">!     auto createEventListener = [&amp;] (const AtomString&amp; eventName) {</span>
          node.addEventListener(eventName, callback.copyRef(), false);
      };
  
  #if ENABLE(FULLSCREEN_API)
      if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2216,57 ***</span>
      } else
          m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
      unbind(&amp;node, &amp;m_documentNodeToIdMap);
  }
  
<span class="line-modified">! void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomicString&amp; oldValue, const AtomicString&amp; newValue)</span>
  {
      m_suppressAttributeModifiedEvent = (oldValue == newValue);
  }
  
<span class="line-modified">! void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomicString&amp; name, const AtomicString&amp; value)</span>
  {
      bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
      m_suppressAttributeModifiedEvent = false;
      if (shouldSuppressEvent)
          return;
  
      int id = boundNodeId(&amp;element);
<span class="line-removed">-     // If node is not mapped yet -&gt; ignore the event.</span>
      if (!id)
          return;
  
<span class="line-modified">!     if (m_domListener)</span>
<span class="line-modified">!         m_domListener-&gt;didModifyDOMAttr(element);</span>
  
      m_frontendDispatcher-&gt;attributeModified(id, name, value);
  }
  
<span class="line-modified">! void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomicString&amp; name)</span>
  {
      int id = boundNodeId(&amp;element);
<span class="line-removed">-     // If node is not mapped yet -&gt; ignore the event.</span>
      if (!id)
          return;
  
<span class="line-modified">!     if (m_domListener)</span>
<span class="line-modified">!         m_domListener-&gt;didModifyDOMAttr(element);</span>
  
      m_frontendDispatcher-&gt;attributeRemoved(id, name);
  }
  
  void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
  {
      auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
      for (auto&amp; element : elements) {
          int id = boundNodeId(element);
<span class="line-removed">-         // If node is not mapped yet -&gt; ignore the event.</span>
          if (!id)
              continue;
  
<span class="line-modified">!         if (m_domListener)</span>
<span class="line-modified">!             m_domListener-&gt;didModifyDOMAttr(*element);</span>
          nodeIds-&gt;addItem(id);
      }
      m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
  }
  
<span class="line-new-header">--- 2252,55 ---</span>
      } else
          m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
      unbind(&amp;node, &amp;m_documentNodeToIdMap);
  }
  
<span class="line-modified">! void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue)</span>
  {
      m_suppressAttributeModifiedEvent = (oldValue == newValue);
  }
  
<span class="line-modified">! void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomString&amp; name, const AtomString&amp; value)</span>
  {
      bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
      m_suppressAttributeModifiedEvent = false;
      if (shouldSuppressEvent)
          return;
  
      int id = boundNodeId(&amp;element);
      if (!id)
          return;
  
<span class="line-modified">!     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">!         cssAgent-&gt;didModifyDOMAttr(element);</span>
  
      m_frontendDispatcher-&gt;attributeModified(id, name, value);
  }
  
<span class="line-modified">! void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomString&amp; name)</span>
  {
      int id = boundNodeId(&amp;element);
      if (!id)
          return;
  
<span class="line-modified">!     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">!         cssAgent-&gt;didModifyDOMAttr(element);</span>
  
      m_frontendDispatcher-&gt;attributeRemoved(id, name);
  }
  
  void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
  {
      auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
      for (auto&amp; element : elements) {
          int id = boundNodeId(element);
          if (!id)
              continue;
  
<span class="line-modified">!         if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())</span>
<span class="line-modified">!             cssAgent-&gt;didModifyDOMAttr(*element);</span>
<span class="line-added">+ </span>
          nodeIds-&gt;addItem(id);
      }
      m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2279,20 ***</span>
          return;
      }
      m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
  }
  
<span class="line-modified">! void InspectorDOMAgent::didInvalidateStyleAttr(Node&amp; node)</span>
  {
<span class="line-modified">!     int id = m_documentNodeToIdMap.get(&amp;node);</span>
<span class="line-removed">-     // If node is not mapped yet -&gt; ignore the event.</span>
      if (!id)
          return;
  
      if (!m_revalidateStyleAttrTask)
<span class="line-modified">!         m_revalidateStyleAttrTask = std::make_unique&lt;RevalidateStyleAttributeTask&gt;(this);</span>
<span class="line-modified">!     m_revalidateStyleAttrTask-&gt;scheduleFor(downcast&lt;Element&gt;(&amp;node));</span>
  }
  
  void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
  {
      int hostId = m_documentNodeToIdMap.get(&amp;host);
<span class="line-new-header">--- 2313,19 ---</span>
          return;
      }
      m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
  }
  
<span class="line-modified">! void InspectorDOMAgent::didInvalidateStyleAttr(Element&amp; element)</span>
  {
<span class="line-modified">!     int id = m_documentNodeToIdMap.get(&amp;element);</span>
      if (!id)
          return;
  
      if (!m_revalidateStyleAttrTask)
<span class="line-modified">!         m_revalidateStyleAttrTask = makeUnique&lt;RevalidateStyleAttributeTask&gt;(this);</span>
<span class="line-modified">!     m_revalidateStyleAttrTask-&gt;scheduleFor(&amp;element);</span>
  }
  
  void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
  {
      int hostId = m_documentNodeToIdMap.get(&amp;host);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2364,22 ***</span>
  void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
  {
      if (!is&lt;Node&gt;(target))
          return;
  
<span class="line-modified">!     int nodeId = boundNodeId(&amp;downcast&lt;Node&gt;(target));</span>
      if (!nodeId)
          return;
  
      m_frontendDispatcher-&gt;didAddEventListener(nodeId);
  }
  
<span class="line-modified">! void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      if (!is&lt;Node&gt;(target))
          return;
      auto&amp; node = downcast&lt;Node&gt;(target);
  
      int nodeId = boundNodeId(&amp;node);
      if (!nodeId)
          return;
  
<span class="line-new-header">--- 2397,34 ---</span>
  void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
  {
      if (!is&lt;Node&gt;(target))
          return;
  
<span class="line-modified">!     auto&amp; node = downcast&lt;Node&gt;(target);</span>
<span class="line-added">+     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     int nodeId = boundNodeId(&amp;node);</span>
      if (!nodeId)
          return;
  
<span class="line-added">+     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">+ </span>
      m_frontendDispatcher-&gt;didAddEventListener(nodeId);
  }
  
<span class="line-modified">! void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      if (!is&lt;Node&gt;(target))
          return;
<span class="line-added">+ </span>
      auto&amp; node = downcast&lt;Node&gt;(target);
<span class="line-added">+     if (!node.contains(m_inspectedNode.get()))</span>
<span class="line-added">+         return;</span>
  
      int nodeId = boundNodeId(&amp;node);
      if (!nodeId)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2396,14 ***</span>
  
      m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
          return entry.value.matches(target, eventType, listener, capture);
      });
  
      m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
  }
  
<span class="line-modified">! bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.disabled;
      }
<span class="line-new-header">--- 2441,19 ---</span>
  
      m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
          return entry.value.matches(target, eventType, listener, capture);
      });
  
<span class="line-added">+     if (m_suppressEventListenerChangedEvent)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_suppressEventListenerChangedEvent = true;</span>
<span class="line-added">+ </span>
      m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
  }
  
<span class="line-modified">! bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.disabled;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2413,20 ***</span>
  void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
  {
      m_dispatchedEvents.remove(&amp;event);
  }
  
<span class="line-modified">! bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.hasBreakpoint;
      }
      return false;
  }
  
<span class="line-modified">! int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomicString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.identifier;
      }
<span class="line-new-header">--- 2463,20 ---</span>
  void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
  {
      m_dispatchedEvents.remove(&amp;event);
  }
  
<span class="line-modified">! bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.hasBreakpoint;
      }
      return false;
  }
  
<span class="line-modified">! int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)</span>
  {
      for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
          if (inspectorEventListener.matches(target, eventType, listener, capture))
              return inspectorEventListener.identifier;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2456,18 ***</span>
          if (iterator == m_mediaMetrics.end()) {
              m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
              continue;
          }
  
<span class="line-modified">!         bool isLowPower = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;</span>
<span class="line-modified">!         if (iterator-&gt;value.isLowPower != isLowPower) {</span>
<span class="line-modified">!             iterator-&gt;value.isLowPower = isLowPower;</span>
  
              int nodeId = pushNodePathToFrontend(mediaElement);
              if (nodeId) {
                  auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
<span class="line-modified">!                 m_frontendDispatcher-&gt;videoLowPowerChanged(nodeId, timestamp, iterator-&gt;value.isLowPower);</span>
              }
          }
  
          iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
      }
<span class="line-new-header">--- 2506,18 ---</span>
          if (iterator == m_mediaMetrics.end()) {
              m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
              continue;
          }
  
<span class="line-modified">!         bool isPowerEfficient = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;</span>
<span class="line-modified">!         if (iterator-&gt;value.isPowerEfficient != isPowerEfficient) {</span>
<span class="line-modified">!             iterator-&gt;value.isPowerEfficient = isPowerEfficient;</span>
  
              int nodeId = pushNodePathToFrontend(mediaElement);
              if (nodeId) {
                  auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
<span class="line-modified">!                 m_frontendDispatcher-&gt;powerEfficientPlaybackStateChanged(nodeId, timestamp, iterator-&gt;value.isPowerEfficient);</span>
              }
          }
  
          iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,16 ***</span>
  void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
  {
      if (Node* node = nodeForPath(path))
          *nodeId = pushNodePathToFrontend(node);
      else
<span class="line-modified">!         errorString = &quot;No node with given path found&quot;_s;</span>
  }
  
  RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
  {
<span class="line-modified">!     auto* frame = node-&gt;document().frame();</span>
      if (!frame)
          return nullptr;
  
      auto&amp; state = *mainWorldExecState(frame);
      auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
<span class="line-new-header">--- 2579,19 ---</span>
  void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
  {
      if (Node* node = nodeForPath(path))
          *nodeId = pushNodePathToFrontend(node);
      else
<span class="line-modified">!         errorString = &quot;Missing node for given path&quot;_s;</span>
  }
  
  RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
  {
<span class="line-modified">!     Document* document = &amp;node-&gt;document();</span>
<span class="line-added">+     if (auto* templateHost = document-&gt;templateDocumentHost())</span>
<span class="line-added">+         document = templateHost;</span>
<span class="line-added">+     auto* frame =  document-&gt;frame();</span>
      if (!frame)
          return nullptr;
  
      auto&amp; state = *mainWorldExecState(frame);
      auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2550,11 ***</span>
  
  Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
  {
      if (!value || !value.isObject())
          return nullptr;
<span class="line-modified">!     return JSNode::toWrapped(*value.getObject()-&gt;vm(), value.getObject());</span>
  }
  
  JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
  {
      JSC::JSLockHolder lock(&amp;state);
<span class="line-new-header">--- 2603,11 ---</span>
  
  Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
  {
      if (!value || !value.isObject())
          return nullptr;
<span class="line-modified">!     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());</span>
  }
  
  JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)
  {
      JSC::JSLockHolder lock(&amp;state);
</pre>
<center><a href="InspectorCanvasAgent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>