<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/mathml/MathOperator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../line/LineWidth.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MathOperator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/mathml/MathOperator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 };
 70 // The first leftRightPairsCount pairs correspond to left/right fences that can easily be mirrored in RTL.
 71 static const short leftRightPairsCount = 5;
 72 static const StretchyCharacter stretchyCharacters[14] = {
 73     { 0x28  , 0x239b, 0x239c, 0x239d, 0x0    }, // left parenthesis
 74     { 0x29  , 0x239e, 0x239f, 0x23a0, 0x0    }, // right parenthesis
 75     { 0x5b  , 0x23a1, 0x23a2, 0x23a3, 0x0    }, // left square bracket
 76     { 0x5d  , 0x23a4, 0x23a5, 0x23a6, 0x0    }, // right square bracket
 77     { 0x7b  , 0x23a7, 0x23aa, 0x23a9, 0x23a8 }, // left curly bracket
 78     { 0x7d  , 0x23ab, 0x23aa, 0x23ad, 0x23ac }, // right curly bracket
 79     { 0x2308, 0x23a1, 0x23a2, 0x23a2, 0x0    }, // left ceiling
 80     { 0x2309, 0x23a4, 0x23a5, 0x23a5, 0x0    }, // right ceiling
 81     { 0x230a, 0x23a2, 0x23a2, 0x23a3, 0x0    }, // left floor
 82     { 0x230b, 0x23a5, 0x23a5, 0x23a6, 0x0    }, // right floor
 83     { 0x7c  , 0x7c,   0x7c,   0x7c,   0x0    }, // vertical bar
 84     { 0x2016, 0x2016, 0x2016, 0x2016, 0x0    }, // double vertical line
 85     { 0x2225, 0x2225, 0x2225, 0x2225, 0x0    }, // parallel to
 86     { 0x222b, 0x2320, 0x23ae, 0x2321, 0x0    } // integral sign
 87 };
 88 
<span class="line-removed"> 89 void MathOperator::GlyphAssemblyData::initialize()</span>
<span class="line-removed"> 90 {</span>
<span class="line-removed"> 91     topOrRightCodePoint = 0;</span>
<span class="line-removed"> 92     topOrRightFallbackGlyph = 0;</span>
<span class="line-removed"> 93     extensionCodePoint = 0;</span>
<span class="line-removed"> 94     extensionFallbackGlyph = 0;</span>
<span class="line-removed"> 95     bottomOrLeftCodePoint = 0;</span>
<span class="line-removed"> 96     bottomOrLeftFallbackGlyph = 0;</span>
<span class="line-removed"> 97     middleCodePoint = 0;</span>
<span class="line-removed"> 98     middleFallbackGlyph = 0;</span>
<span class="line-removed"> 99 }</span>
<span class="line-removed">100 </span>
101 MathOperator::MathOperator()
102 {
<span class="line-removed">103     m_assembly.initialize();</span>
104     m_variantGlyph = 0;
105 }
106 
107 void MathOperator::setOperator(const RenderStyle&amp; style, UChar32 baseCharacter, Type operatorType)
108 {
109     m_baseCharacter = baseCharacter;
110     m_operatorType = operatorType;
111     reset(style);
112 }
113 
114 void MathOperator::reset(const RenderStyle&amp; style)
115 {
116     m_stretchType = StretchType::Unstretched;
117     m_maxPreferredWidth = 0;
118     m_width = 0;
119     m_ascent = 0;
120     m_descent = 0;
121     m_italicCorrection = 0;
122     m_radicalVerticalScale = 1;
123 
</pre>
<hr />
<pre>
167         fallback.glyph = fallbackGlyph;
168         fallback.font = &amp;style.fontCascade().primaryFont();
169     }
170 
171     return fallback;
172 }
173 
174 void MathOperator::setGlyphAssembly(const RenderStyle&amp; style, const GlyphAssemblyData&amp; assemblyData)
175 {
176     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
177     m_stretchType = StretchType::GlyphAssembly;
178     m_assembly = assemblyData;
179 
180     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
181     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
182     auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
183     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
184 
185     if (m_operatorType == Type::VerticalOperator) {
186         m_width = 0;
<span class="line-modified">187         m_width = std::max&lt;LayoutUnit&gt;(m_width, advanceWidthForGlyph(topOrRight));</span>
<span class="line-modified">188         m_width = std::max&lt;LayoutUnit&gt;(m_width, advanceWidthForGlyph(extension));</span>
<span class="line-modified">189         m_width = std::max&lt;LayoutUnit&gt;(m_width, advanceWidthForGlyph(bottomOrLeft));</span>
<span class="line-modified">190         m_width = std::max&lt;LayoutUnit&gt;(m_width, advanceWidthForGlyph(middle));</span>
191     } else {
192         m_ascent = 0;
193         m_descent = 0;
194         LayoutUnit ascent, descent;
195         getAscentAndDescentForGlyph(bottomOrLeft, ascent, descent);
196         m_ascent = std::max(m_ascent, ascent);
197         m_descent = std::max(m_descent, descent);
198         getAscentAndDescentForGlyph(extension, ascent, descent);
199         m_ascent = std::max(m_ascent, ascent);
200         m_descent = std::max(m_descent, descent);
201         getAscentAndDescentForGlyph(topOrRight, ascent, descent);
202         m_ascent = std::max(m_ascent, ascent);
203         m_descent = std::max(m_descent, descent);
204         getAscentAndDescentForGlyph(middle, ascent, descent);
205         m_ascent = std::max(m_ascent, ascent);
206         m_descent = std::max(m_descent, descent);
207     }
208 }
209 
210 // The MathML specification recommends avoiding combining characters.
</pre>
<hr />
<pre>
384     GlyphData baseGlyph;
385     if (!getBaseGlyph(style, baseGlyph))
386         return;
387 
388     if (!calculateMaxPreferredWidth) {
389         // We do not stretch if the base glyph is large enough.
390         float baseSize = isVertical ? heightForGlyph(baseGlyph) : advanceWidthForGlyph(baseGlyph);
391         if (targetSize &lt;= baseSize)
392             return;
393     }
394 
395     GlyphAssemblyData assemblyData;
396     if (baseGlyph.font-&gt;mathData()) {
397         Vector&lt;Glyph&gt; sizeVariants;
398         Vector&lt;OpenTypeMathData::AssemblyPart&gt; assemblyParts;
399         getMathVariantsWithFallback(style, isVertical, sizeVariants, assemblyParts);
400         // We verify the size variants.
401         for (auto&amp; sizeVariant : sizeVariants) {
402             GlyphData glyphData(sizeVariant, baseGlyph.font);
403             if (calculateMaxPreferredWidth)
<span class="line-modified">404                 m_maxPreferredWidth = std::max&lt;LayoutUnit&gt;(m_maxPreferredWidth, advanceWidthForGlyph(glyphData));</span>
405             else {
406                 setSizeVariant(glyphData);
<span class="line-modified">407                 LayoutUnit size = isVertical ? heightForGlyph(glyphData) : advanceWidthForGlyph(glyphData);</span>
408                 if (size &gt;= targetSize)
409                     return;
410             }
411         }
412 
413         // We verify if there is a construction.
414         if (!calculateGlyphAssemblyFallback(assemblyParts, assemblyData))
415             return;
416     } else {
417         if (!isVertical)
418             return;
419 
420         // If the font does not have a MATH table, we fallback to the Unicode-only constructions.
421         const StretchyCharacter* stretchyCharacter = nullptr;
422         const unsigned maxIndex = WTF_ARRAY_LENGTH(stretchyCharacters);
423         for (unsigned index = 0; index &lt; maxIndex; ++index) {
424             if (stretchyCharacters[index].character == m_baseCharacter) {
425                 stretchyCharacter = &amp;stretchyCharacters[index];
426                 if (!style.isLeftToRightDirection() &amp;&amp; index &lt; leftRightPairsCount * 2) {
427                     // If we are in right-to-left direction we select the mirrored form by adding -1 or +1 according to the parity of index.
</pre>
<hr />
<pre>
445         }
446 
447         // If we didn&#39;t find a stretchy character set for this character, we don&#39;t know how to stretch it.
448         if (!stretchyCharacter)
449             return;
450 
451         // We convert the list of Unicode characters into a list of glyph data.
452         assemblyData.topOrRightCodePoint = stretchyCharacter-&gt;topChar;
453         assemblyData.extensionCodePoint = stretchyCharacter-&gt;extensionChar;
454         assemblyData.bottomOrLeftCodePoint = stretchyCharacter-&gt;bottomChar;
455         assemblyData.middleCodePoint = stretchyCharacter-&gt;middleChar;
456     }
457 
458     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.topOrRightCodePoint, assemblyData.topOrRightFallbackGlyph);
459     auto extension = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.extensionCodePoint, assemblyData.extensionFallbackGlyph);
460     auto middle = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.middleCodePoint, assemblyData.middleFallbackGlyph);
461     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.bottomOrLeftCodePoint, assemblyData.bottomOrLeftFallbackGlyph);
462 
463     // If we are measuring the maximum width, verify each component.
464     if (calculateMaxPreferredWidth) {
<span class="line-modified">465         m_maxPreferredWidth = std::max&lt;LayoutUnit&gt;(m_maxPreferredWidth, advanceWidthForGlyph(topOrRight));</span>
<span class="line-modified">466         m_maxPreferredWidth = std::max&lt;LayoutUnit&gt;(m_maxPreferredWidth, advanceWidthForGlyph(extension));</span>
<span class="line-modified">467         m_maxPreferredWidth = std::max&lt;LayoutUnit&gt;(m_maxPreferredWidth, advanceWidthForGlyph(middle));</span>
<span class="line-modified">468         m_maxPreferredWidth = std::max&lt;LayoutUnit&gt;(m_maxPreferredWidth, advanceWidthForGlyph(bottomOrLeft));</span>
469         return;
470     }
471 
472     // We ensure that the size is large enough to avoid glyph overlaps.
473     float minSize = isVertical ?
474         heightForGlyph(topOrRight) + heightForGlyph(middle) + heightForGlyph(bottomOrLeft)
475         : advanceWidthForGlyph(bottomOrLeft) + advanceWidthForGlyph(middle) + advanceWidthForGlyph(topOrRight);
476     if (minSize &gt; targetSize)
477         return;
478 
479     setGlyphAssembly(style, assemblyData);
480 }
481 
482 void MathOperator::stretchTo(const RenderStyle&amp; style, LayoutUnit targetSize)
483 {
484     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
485     calculateStretchyData(style, false, targetSize);
486     if (m_stretchType == StretchType::GlyphAssembly) {
487         if (m_operatorType == Type::VerticalOperator) {
488             m_ascent = targetSize;
</pre>
<hr />
<pre>
554     ASSERT(extension.font);
555     ASSERT(from.y() &lt;= to.y());
556 
557     // If there is no space for the extension glyph, we don&#39;t need to do anything.
558     if (from.y() == to.y())
559         return;
560 
561     GraphicsContextStateSaver stateSaver(info.context());
562 
563     FloatRect glyphBounds = boundsForGlyph(extension);
564 
565     // Clipping the extender region here allows us to draw the bottom extender glyph into the
566     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
567     LayoutRect clipBounds = info.rect;
568     clipBounds.shiftYEdgeTo(from.y());
569     clipBounds.shiftMaxYEdgeTo(to.y());
570     info.context().clip(clipBounds);
571 
572     // Trimming may remove up to two pixels from the top of the extender glyph, so we move it up by two pixels.
573     float offsetToGlyphTop = glyphBounds.y() + 2;
<span class="line-modified">574     LayoutPoint glyphOrigin = LayoutPoint(from.x(), from.y() - offsetToGlyphTop);</span>
575     FloatRect lastPaintedGlyphRect(from, FloatSize());
576 
577     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
578     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxY() &lt; to.y() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
579         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimTopAndBottom);
580         glyphOrigin.setY(glyphOrigin.y() + lastPaintedGlyphRect.height());
581 
582         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
583         // with trimming. In that case we just draw nothing.
584         if (lastPaintedGlyphRect.isEmpty())
585             break;
586     }
587 }
588 
589 void MathOperator::fillWithHorizontalExtensionGlyph(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; from, const LayoutPoint&amp; to)
590 {
591     ASSERT(m_operatorType == Type::HorizontalOperator);
592     ASSERT(m_stretchType == StretchType::GlyphAssembly);
593 
594     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
595 
596     ASSERT(extension.font);
597     ASSERT(from.x() &lt;= to.x());
598     ASSERT(from.y() == to.y());
599 
600     // If there is no space for the extension glyph, we don&#39;t need to do anything.
601     if (from.x() == to.x())
602         return;
603 
604     GraphicsContextStateSaver stateSaver(info.context());
605 
606     // Clipping the extender region here allows us to draw the bottom extender glyph into the
607     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
608     LayoutRect clipBounds = info.rect;
609     clipBounds.shiftXEdgeTo(from.x());
610     clipBounds.shiftMaxXEdgeTo(to.x());
611     info.context().clip(clipBounds);
612 
613     // Trimming may remove up to two pixels from the left of the extender glyph, so we move it left by two pixels.
614     float offsetToGlyphLeft = -2;
<span class="line-modified">615     LayoutPoint glyphOrigin = LayoutPoint(from.x() + offsetToGlyphLeft, from.y());</span>
616     FloatRect lastPaintedGlyphRect(from, FloatSize());
617 
618     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
619     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxX() &lt; to.x() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
620         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimLeftAndRight);
621         glyphOrigin.setX(glyphOrigin.x() + lastPaintedGlyphRect.width());
622 
623         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
624         // with trimming. In that case we just draw nothing.
625         if (lastPaintedGlyphRect.isEmpty())
626             break;
627     }
628 }
629 
630 void MathOperator::paintVerticalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
631 {
632     ASSERT(m_operatorType == Type::VerticalOperator);
633     ASSERT(m_stretchType == StretchType::GlyphAssembly);
634 
635     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
636     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
637 
638     ASSERT(topOrRight.font);
639     ASSERT(bottomOrLeft.font);
640     if (!topOrRight.font || !bottomOrLeft.font) {
641         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
642         return;
643     }
644 
645     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
646     LayoutPoint operatorTopLeft = paintOffset;
647     FloatRect topGlyphBounds = boundsForGlyph(topOrRight);
<span class="line-modified">648     LayoutPoint topGlyphOrigin(operatorTopLeft.x(), operatorTopLeft.y() - topGlyphBounds.y());</span>
649     LayoutRect topGlyphPaintRect = paintGlyph(style, info, topOrRight, topGlyphOrigin, TrimBottom);
650 
651     FloatRect bottomGlyphBounds = boundsForGlyph(bottomOrLeft);
<span class="line-modified">652     LayoutPoint bottomGlyphOrigin(operatorTopLeft.x(), operatorTopLeft.y() + stretchSize() - (bottomGlyphBounds.height() + bottomGlyphBounds.y()));</span>
653     LayoutRect bottomGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, bottomGlyphOrigin, TrimTop);
654 
655     if (m_assembly.hasMiddle()) {
656         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
657 
658         // Center the glyph origin between the start and end glyph paint extents. Then shift it half the paint height toward the bottom glyph.
659         FloatRect middleGlyphBounds = boundsForGlyph(middle);
660         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), topGlyphOrigin.y());
661         middleGlyphOrigin.moveBy(LayoutPoint(0, (bottomGlyphPaintRect.y() - topGlyphPaintRect.maxY()) / 2.0));
662         middleGlyphOrigin.moveBy(LayoutPoint(0, middleGlyphBounds.height() / 2.0));
663 
664         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimTopAndBottom);
665         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), middleGlyphPaintRect.minXMinYCorner());
666         fillWithVerticalExtensionGlyph(style, info, middleGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
667     } else
668         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
669 }
670 
671 void MathOperator::paintHorizontalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
672 {
673     ASSERT(m_operatorType == Type::HorizontalOperator);
674     ASSERT(m_stretchType == StretchType::GlyphAssembly);
675 
676     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
677     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
678 
679     ASSERT(bottomOrLeft.font);
680     ASSERT(topOrRight.font);
681     if (!topOrRight.font || !bottomOrLeft.font) {
682         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
683         return;
684     }
685 
686     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
687     LayoutPoint operatorTopLeft = paintOffset;
688     LayoutUnit baselineY = operatorTopLeft.y() + m_ascent;
689     LayoutPoint leftGlyphOrigin(operatorTopLeft.x(), baselineY);
690     LayoutRect leftGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, leftGlyphOrigin, TrimRight);
691 
692     FloatRect rightGlyphBounds = boundsForGlyph(topOrRight);
<span class="line-modified">693     LayoutPoint rightGlyphOrigin(operatorTopLeft.x() + stretchSize() - rightGlyphBounds.width(), baselineY);</span>
694     LayoutRect rightGlyphPaintRect = paintGlyph(style, info, topOrRight, rightGlyphOrigin, TrimLeft);
695 
696     if (m_assembly.hasMiddle()) {
697         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
698 
699         // Center the glyph origin between the start and end glyph paint extents.
700         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), baselineY);
701         middleGlyphOrigin.moveBy(LayoutPoint((rightGlyphPaintRect.x() - leftGlyphPaintRect.maxX()) / 2.0, 0));
702         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimLeftAndRight);
703         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(middleGlyphPaintRect.x(), baselineY));
704         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(middleGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
705     } else
706         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
707 }
708 
709 void MathOperator::paint(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
710 {
711     if (info.context().paintingDisabled() || info.phase != PaintPhase::Foreground || style.visibility() != Visibility::Visible)
712         return;
713 
</pre>
<hr />
<pre>
728 
729     if (m_stretchType == StretchType::GlyphAssembly) {
730         if (m_operatorType == Type::VerticalOperator)
731             paintVerticalGlyphAssembly(style, info, paintOffset);
732         else
733             paintHorizontalGlyphAssembly(style, info, paintOffset);
734         return;
735     }
736 
737     GlyphData glyphData;
738     ASSERT(m_stretchType == StretchType::Unstretched || m_stretchType == StretchType::SizeVariant);
739     if (!getBaseGlyph(style, glyphData))
740         return;
741     if (m_stretchType == StretchType::SizeVariant)
742         glyphData.glyph = m_variantGlyph;
743 
744     GlyphBuffer buffer;
745     buffer.add(glyphData.glyph, glyphData.font, advanceWidthForGlyph(glyphData));
746     LayoutPoint operatorTopLeft = paintOffset;
747     FloatRect glyphBounds = boundsForGlyph(glyphData);
<span class="line-modified">748     LayoutPoint operatorOrigin(operatorTopLeft.x(), operatorTopLeft.y() - glyphBounds.y());</span>
749     paintInfo.context().drawGlyphs(*glyphData.font, buffer, 0, 1, operatorOrigin, style.fontCascade().fontDescription().fontSmoothing());
750 }
751 
752 }
753 
754 #endif
</pre>
</td>
<td>
<hr />
<pre>
 69 };
 70 // The first leftRightPairsCount pairs correspond to left/right fences that can easily be mirrored in RTL.
 71 static const short leftRightPairsCount = 5;
 72 static const StretchyCharacter stretchyCharacters[14] = {
 73     { 0x28  , 0x239b, 0x239c, 0x239d, 0x0    }, // left parenthesis
 74     { 0x29  , 0x239e, 0x239f, 0x23a0, 0x0    }, // right parenthesis
 75     { 0x5b  , 0x23a1, 0x23a2, 0x23a3, 0x0    }, // left square bracket
 76     { 0x5d  , 0x23a4, 0x23a5, 0x23a6, 0x0    }, // right square bracket
 77     { 0x7b  , 0x23a7, 0x23aa, 0x23a9, 0x23a8 }, // left curly bracket
 78     { 0x7d  , 0x23ab, 0x23aa, 0x23ad, 0x23ac }, // right curly bracket
 79     { 0x2308, 0x23a1, 0x23a2, 0x23a2, 0x0    }, // left ceiling
 80     { 0x2309, 0x23a4, 0x23a5, 0x23a5, 0x0    }, // right ceiling
 81     { 0x230a, 0x23a2, 0x23a2, 0x23a3, 0x0    }, // left floor
 82     { 0x230b, 0x23a5, 0x23a5, 0x23a6, 0x0    }, // right floor
 83     { 0x7c  , 0x7c,   0x7c,   0x7c,   0x0    }, // vertical bar
 84     { 0x2016, 0x2016, 0x2016, 0x2016, 0x0    }, // double vertical line
 85     { 0x2225, 0x2225, 0x2225, 0x2225, 0x0    }, // parallel to
 86     { 0x222b, 0x2320, 0x23ae, 0x2321, 0x0    } // integral sign
 87 };
 88 












 89 MathOperator::MathOperator()
 90 {

 91     m_variantGlyph = 0;
 92 }
 93 
 94 void MathOperator::setOperator(const RenderStyle&amp; style, UChar32 baseCharacter, Type operatorType)
 95 {
 96     m_baseCharacter = baseCharacter;
 97     m_operatorType = operatorType;
 98     reset(style);
 99 }
100 
101 void MathOperator::reset(const RenderStyle&amp; style)
102 {
103     m_stretchType = StretchType::Unstretched;
104     m_maxPreferredWidth = 0;
105     m_width = 0;
106     m_ascent = 0;
107     m_descent = 0;
108     m_italicCorrection = 0;
109     m_radicalVerticalScale = 1;
110 
</pre>
<hr />
<pre>
154         fallback.glyph = fallbackGlyph;
155         fallback.font = &amp;style.fontCascade().primaryFont();
156     }
157 
158     return fallback;
159 }
160 
161 void MathOperator::setGlyphAssembly(const RenderStyle&amp; style, const GlyphAssemblyData&amp; assemblyData)
162 {
163     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
164     m_stretchType = StretchType::GlyphAssembly;
165     m_assembly = assemblyData;
166 
167     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
168     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
169     auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
170     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
171 
172     if (m_operatorType == Type::VerticalOperator) {
173         m_width = 0;
<span class="line-modified">174         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(topOrRight)));</span>
<span class="line-modified">175         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(extension)));</span>
<span class="line-modified">176         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(bottomOrLeft)));</span>
<span class="line-modified">177         m_width = std::max(m_width, LayoutUnit(advanceWidthForGlyph(middle)));</span>
178     } else {
179         m_ascent = 0;
180         m_descent = 0;
181         LayoutUnit ascent, descent;
182         getAscentAndDescentForGlyph(bottomOrLeft, ascent, descent);
183         m_ascent = std::max(m_ascent, ascent);
184         m_descent = std::max(m_descent, descent);
185         getAscentAndDescentForGlyph(extension, ascent, descent);
186         m_ascent = std::max(m_ascent, ascent);
187         m_descent = std::max(m_descent, descent);
188         getAscentAndDescentForGlyph(topOrRight, ascent, descent);
189         m_ascent = std::max(m_ascent, ascent);
190         m_descent = std::max(m_descent, descent);
191         getAscentAndDescentForGlyph(middle, ascent, descent);
192         m_ascent = std::max(m_ascent, ascent);
193         m_descent = std::max(m_descent, descent);
194     }
195 }
196 
197 // The MathML specification recommends avoiding combining characters.
</pre>
<hr />
<pre>
371     GlyphData baseGlyph;
372     if (!getBaseGlyph(style, baseGlyph))
373         return;
374 
375     if (!calculateMaxPreferredWidth) {
376         // We do not stretch if the base glyph is large enough.
377         float baseSize = isVertical ? heightForGlyph(baseGlyph) : advanceWidthForGlyph(baseGlyph);
378         if (targetSize &lt;= baseSize)
379             return;
380     }
381 
382     GlyphAssemblyData assemblyData;
383     if (baseGlyph.font-&gt;mathData()) {
384         Vector&lt;Glyph&gt; sizeVariants;
385         Vector&lt;OpenTypeMathData::AssemblyPart&gt; assemblyParts;
386         getMathVariantsWithFallback(style, isVertical, sizeVariants, assemblyParts);
387         // We verify the size variants.
388         for (auto&amp; sizeVariant : sizeVariants) {
389             GlyphData glyphData(sizeVariant, baseGlyph.font);
390             if (calculateMaxPreferredWidth)
<span class="line-modified">391                 m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(glyphData)));</span>
392             else {
393                 setSizeVariant(glyphData);
<span class="line-modified">394                 LayoutUnit size { isVertical ? heightForGlyph(glyphData) : advanceWidthForGlyph(glyphData) };</span>
395                 if (size &gt;= targetSize)
396                     return;
397             }
398         }
399 
400         // We verify if there is a construction.
401         if (!calculateGlyphAssemblyFallback(assemblyParts, assemblyData))
402             return;
403     } else {
404         if (!isVertical)
405             return;
406 
407         // If the font does not have a MATH table, we fallback to the Unicode-only constructions.
408         const StretchyCharacter* stretchyCharacter = nullptr;
409         const unsigned maxIndex = WTF_ARRAY_LENGTH(stretchyCharacters);
410         for (unsigned index = 0; index &lt; maxIndex; ++index) {
411             if (stretchyCharacters[index].character == m_baseCharacter) {
412                 stretchyCharacter = &amp;stretchyCharacters[index];
413                 if (!style.isLeftToRightDirection() &amp;&amp; index &lt; leftRightPairsCount * 2) {
414                     // If we are in right-to-left direction we select the mirrored form by adding -1 or +1 according to the parity of index.
</pre>
<hr />
<pre>
432         }
433 
434         // If we didn&#39;t find a stretchy character set for this character, we don&#39;t know how to stretch it.
435         if (!stretchyCharacter)
436             return;
437 
438         // We convert the list of Unicode characters into a list of glyph data.
439         assemblyData.topOrRightCodePoint = stretchyCharacter-&gt;topChar;
440         assemblyData.extensionCodePoint = stretchyCharacter-&gt;extensionChar;
441         assemblyData.bottomOrLeftCodePoint = stretchyCharacter-&gt;bottomChar;
442         assemblyData.middleCodePoint = stretchyCharacter-&gt;middleChar;
443     }
444 
445     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.topOrRightCodePoint, assemblyData.topOrRightFallbackGlyph);
446     auto extension = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.extensionCodePoint, assemblyData.extensionFallbackGlyph);
447     auto middle = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.middleCodePoint, assemblyData.middleFallbackGlyph);
448     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, assemblyData.bottomOrLeftCodePoint, assemblyData.bottomOrLeftFallbackGlyph);
449 
450     // If we are measuring the maximum width, verify each component.
451     if (calculateMaxPreferredWidth) {
<span class="line-modified">452         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(topOrRight)));</span>
<span class="line-modified">453         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(extension)));</span>
<span class="line-modified">454         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(middle)));</span>
<span class="line-modified">455         m_maxPreferredWidth = std::max(m_maxPreferredWidth, LayoutUnit(advanceWidthForGlyph(bottomOrLeft)));</span>
456         return;
457     }
458 
459     // We ensure that the size is large enough to avoid glyph overlaps.
460     float minSize = isVertical ?
461         heightForGlyph(topOrRight) + heightForGlyph(middle) + heightForGlyph(bottomOrLeft)
462         : advanceWidthForGlyph(bottomOrLeft) + advanceWidthForGlyph(middle) + advanceWidthForGlyph(topOrRight);
463     if (minSize &gt; targetSize)
464         return;
465 
466     setGlyphAssembly(style, assemblyData);
467 }
468 
469 void MathOperator::stretchTo(const RenderStyle&amp; style, LayoutUnit targetSize)
470 {
471     ASSERT(m_operatorType == Type::VerticalOperator || m_operatorType == Type::HorizontalOperator);
472     calculateStretchyData(style, false, targetSize);
473     if (m_stretchType == StretchType::GlyphAssembly) {
474         if (m_operatorType == Type::VerticalOperator) {
475             m_ascent = targetSize;
</pre>
<hr />
<pre>
541     ASSERT(extension.font);
542     ASSERT(from.y() &lt;= to.y());
543 
544     // If there is no space for the extension glyph, we don&#39;t need to do anything.
545     if (from.y() == to.y())
546         return;
547 
548     GraphicsContextStateSaver stateSaver(info.context());
549 
550     FloatRect glyphBounds = boundsForGlyph(extension);
551 
552     // Clipping the extender region here allows us to draw the bottom extender glyph into the
553     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
554     LayoutRect clipBounds = info.rect;
555     clipBounds.shiftYEdgeTo(from.y());
556     clipBounds.shiftMaxYEdgeTo(to.y());
557     info.context().clip(clipBounds);
558 
559     // Trimming may remove up to two pixels from the top of the extender glyph, so we move it up by two pixels.
560     float offsetToGlyphTop = glyphBounds.y() + 2;
<span class="line-modified">561     LayoutPoint glyphOrigin { from.x(), LayoutUnit(from.y() - offsetToGlyphTop) };</span>
562     FloatRect lastPaintedGlyphRect(from, FloatSize());
563 
564     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
565     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxY() &lt; to.y() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
566         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimTopAndBottom);
567         glyphOrigin.setY(glyphOrigin.y() + lastPaintedGlyphRect.height());
568 
569         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
570         // with trimming. In that case we just draw nothing.
571         if (lastPaintedGlyphRect.isEmpty())
572             break;
573     }
574 }
575 
576 void MathOperator::fillWithHorizontalExtensionGlyph(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; from, const LayoutPoint&amp; to)
577 {
578     ASSERT(m_operatorType == Type::HorizontalOperator);
579     ASSERT(m_stretchType == StretchType::GlyphAssembly);
580 
581     auto extension = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.extensionCodePoint, m_assembly.extensionFallbackGlyph);
582 
583     ASSERT(extension.font);
584     ASSERT(from.x() &lt;= to.x());
585     ASSERT(from.y() == to.y());
586 
587     // If there is no space for the extension glyph, we don&#39;t need to do anything.
588     if (from.x() == to.x())
589         return;
590 
591     GraphicsContextStateSaver stateSaver(info.context());
592 
593     // Clipping the extender region here allows us to draw the bottom extender glyph into the
594     // regions of the bottom glyph without worrying about overdraw (hairy pixels) and simplifies later clipping.
595     LayoutRect clipBounds = info.rect;
596     clipBounds.shiftXEdgeTo(from.x());
597     clipBounds.shiftMaxXEdgeTo(to.x());
598     info.context().clip(clipBounds);
599 
600     // Trimming may remove up to two pixels from the left of the extender glyph, so we move it left by two pixels.
601     float offsetToGlyphLeft = -2;
<span class="line-modified">602     LayoutPoint glyphOrigin { LayoutUnit(from.x() + offsetToGlyphLeft), from.y() };</span>
603     FloatRect lastPaintedGlyphRect(from, FloatSize());
604 
605     // In practice, only small stretch sizes are requested but we limit the number of glyphs to avoid hangs.
606     for (unsigned extensionCount = 0; lastPaintedGlyphRect.maxX() &lt; to.x() &amp;&amp; extensionCount &lt; kMaximumExtensionCount; extensionCount++) {
607         lastPaintedGlyphRect = paintGlyph(style, info, extension, glyphOrigin, TrimLeftAndRight);
608         glyphOrigin.setX(glyphOrigin.x() + lastPaintedGlyphRect.width());
609 
610         // There&#39;s a chance that if the font size is small enough the glue glyph has been reduced to an empty rectangle
611         // with trimming. In that case we just draw nothing.
612         if (lastPaintedGlyphRect.isEmpty())
613             break;
614     }
615 }
616 
617 void MathOperator::paintVerticalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
618 {
619     ASSERT(m_operatorType == Type::VerticalOperator);
620     ASSERT(m_stretchType == StretchType::GlyphAssembly);
621 
622     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
623     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
624 
625     ASSERT(topOrRight.font);
626     ASSERT(bottomOrLeft.font);
627     if (!topOrRight.font || !bottomOrLeft.font) {
628         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
629         return;
630     }
631 
632     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
633     LayoutPoint operatorTopLeft = paintOffset;
634     FloatRect topGlyphBounds = boundsForGlyph(topOrRight);
<span class="line-modified">635     LayoutPoint topGlyphOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() - topGlyphBounds.y()) };</span>
636     LayoutRect topGlyphPaintRect = paintGlyph(style, info, topOrRight, topGlyphOrigin, TrimBottom);
637 
638     FloatRect bottomGlyphBounds = boundsForGlyph(bottomOrLeft);
<span class="line-modified">639     LayoutPoint bottomGlyphOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() + stretchSize() - (bottomGlyphBounds.height() + bottomGlyphBounds.y())) };</span>
640     LayoutRect bottomGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, bottomGlyphOrigin, TrimTop);
641 
642     if (m_assembly.hasMiddle()) {
643         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
644 
645         // Center the glyph origin between the start and end glyph paint extents. Then shift it half the paint height toward the bottom glyph.
646         FloatRect middleGlyphBounds = boundsForGlyph(middle);
647         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), topGlyphOrigin.y());
648         middleGlyphOrigin.moveBy(LayoutPoint(0, (bottomGlyphPaintRect.y() - topGlyphPaintRect.maxY()) / 2.0));
649         middleGlyphOrigin.moveBy(LayoutPoint(0, middleGlyphBounds.height() / 2.0));
650 
651         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimTopAndBottom);
652         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), middleGlyphPaintRect.minXMinYCorner());
653         fillWithVerticalExtensionGlyph(style, info, middleGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
654     } else
655         fillWithVerticalExtensionGlyph(style, info, topGlyphPaintRect.minXMaxYCorner(), bottomGlyphPaintRect.minXMinYCorner());
656 }
657 
658 void MathOperator::paintHorizontalGlyphAssembly(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
659 {
660     ASSERT(m_operatorType == Type::HorizontalOperator);
661     ASSERT(m_stretchType == StretchType::GlyphAssembly);
662 
663     auto topOrRight = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.topOrRightCodePoint, m_assembly.topOrRightFallbackGlyph);
664     auto bottomOrLeft = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.bottomOrLeftCodePoint, m_assembly.bottomOrLeftFallbackGlyph);
665 
666     ASSERT(bottomOrLeft.font);
667     ASSERT(topOrRight.font);
668     if (!topOrRight.font || !bottomOrLeft.font) {
669         LOG_ERROR(&quot;MathML: no font can be found for Unicode code point.&quot;);
670         return;
671     }
672 
673     // We are positioning the glyphs so that the edge of the tight glyph bounds line up exactly with the edges of our paint box.
674     LayoutPoint operatorTopLeft = paintOffset;
675     LayoutUnit baselineY = operatorTopLeft.y() + m_ascent;
676     LayoutPoint leftGlyphOrigin(operatorTopLeft.x(), baselineY);
677     LayoutRect leftGlyphPaintRect = paintGlyph(style, info, bottomOrLeft, leftGlyphOrigin, TrimRight);
678 
679     FloatRect rightGlyphBounds = boundsForGlyph(topOrRight);
<span class="line-modified">680     LayoutPoint rightGlyphOrigin { LayoutUnit(operatorTopLeft.x() + stretchSize() - rightGlyphBounds.width()), baselineY };</span>
681     LayoutRect rightGlyphPaintRect = paintGlyph(style, info, topOrRight, rightGlyphOrigin, TrimLeft);
682 
683     if (m_assembly.hasMiddle()) {
684         auto middle = glyphDataForCodePointOrFallbackGlyph(style, m_assembly.middleCodePoint, m_assembly.middleFallbackGlyph);
685 
686         // Center the glyph origin between the start and end glyph paint extents.
687         LayoutPoint middleGlyphOrigin(operatorTopLeft.x(), baselineY);
688         middleGlyphOrigin.moveBy(LayoutPoint((rightGlyphPaintRect.x() - leftGlyphPaintRect.maxX()) / 2.0, 0));
689         LayoutRect middleGlyphPaintRect = paintGlyph(style, info, middle, middleGlyphOrigin, TrimLeftAndRight);
690         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(middleGlyphPaintRect.x(), baselineY));
691         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(middleGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
692     } else
693         fillWithHorizontalExtensionGlyph(style, info, LayoutPoint(leftGlyphPaintRect.maxX(), baselineY), LayoutPoint(rightGlyphPaintRect.x(), baselineY));
694 }
695 
696 void MathOperator::paint(const RenderStyle&amp; style, PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
697 {
698     if (info.context().paintingDisabled() || info.phase != PaintPhase::Foreground || style.visibility() != Visibility::Visible)
699         return;
700 
</pre>
<hr />
<pre>
715 
716     if (m_stretchType == StretchType::GlyphAssembly) {
717         if (m_operatorType == Type::VerticalOperator)
718             paintVerticalGlyphAssembly(style, info, paintOffset);
719         else
720             paintHorizontalGlyphAssembly(style, info, paintOffset);
721         return;
722     }
723 
724     GlyphData glyphData;
725     ASSERT(m_stretchType == StretchType::Unstretched || m_stretchType == StretchType::SizeVariant);
726     if (!getBaseGlyph(style, glyphData))
727         return;
728     if (m_stretchType == StretchType::SizeVariant)
729         glyphData.glyph = m_variantGlyph;
730 
731     GlyphBuffer buffer;
732     buffer.add(glyphData.glyph, glyphData.font, advanceWidthForGlyph(glyphData));
733     LayoutPoint operatorTopLeft = paintOffset;
734     FloatRect glyphBounds = boundsForGlyph(glyphData);
<span class="line-modified">735     LayoutPoint operatorOrigin { operatorTopLeft.x(), LayoutUnit(operatorTopLeft.y() - glyphBounds.y()) };</span>
736     paintInfo.context().drawGlyphs(*glyphData.font, buffer, 0, 1, operatorOrigin, style.fontCascade().fontDescription().fontSmoothing());
737 }
738 
739 }
740 
741 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../line/LineWidth.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MathOperator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>