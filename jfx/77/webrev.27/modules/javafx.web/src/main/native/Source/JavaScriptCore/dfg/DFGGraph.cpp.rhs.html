<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGGraph.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;BytecodeKills.h&quot;
  32 #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;CodeBlockWithJITType.h&quot;
  35 #include &quot;DFGBackwardsCFG.h&quot;
  36 #include &quot;DFGBackwardsDominators.h&quot;
  37 #include &quot;DFGBlockWorklist.h&quot;
  38 #include &quot;DFGCFG.h&quot;
  39 #include &quot;DFGClobberSet.h&quot;
  40 #include &quot;DFGClobbersExitState.h&quot;
  41 #include &quot;DFGControlEquivalenceAnalysis.h&quot;
  42 #include &quot;DFGDominators.h&quot;
  43 #include &quot;DFGFlowIndexing.h&quot;
  44 #include &quot;DFGFlowMap.h&quot;
  45 #include &quot;DFGJITCode.h&quot;
  46 #include &quot;DFGMayExit.h&quot;
  47 #include &quot;DFGNaturalLoops.h&quot;
  48 #include &quot;DFGVariableAccessDataDump.h&quot;
  49 #include &quot;FullBytecodeLiveness.h&quot;
  50 #include &quot;FunctionExecutableDump.h&quot;
  51 #include &quot;GetterSetter.h&quot;
  52 #include &quot;JIT.h&quot;
  53 #include &quot;JSLexicalEnvironment.h&quot;
  54 #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
  55 #include &quot;OperandsInlines.h&quot;
  56 #include &quot;JSCInlines.h&quot;
  57 #include &quot;StackAlignment.h&quot;
  58 #include &lt;wtf/CommaPrinter.h&gt;
  59 #include &lt;wtf/ListDump.h&gt;
  60 
  61 namespace JSC { namespace DFG {
  62 
  63 static constexpr bool dumpOSRAvailabilityData = false;
  64 
  65 // Creates an array of stringized names.
  66 static const char* dfgOpNames[] = {
  67 #define STRINGIZE_DFG_OP_ENUM(opcode, flags) #opcode ,
  68     FOR_EACH_DFG_OP(STRINGIZE_DFG_OP_ENUM)
  69 #undef STRINGIZE_DFG_OP_ENUM
  70 };
  71 
  72 Graph::Graph(VM&amp; vm, Plan&amp; plan)
  73     : m_vm(vm)
  74     , m_plan(plan)
  75     , m_codeBlock(m_plan.codeBlock())
  76     , m_profiledBlock(m_codeBlock-&gt;alternative())
<a name="2" id="anc2"></a><span class="line-modified">  77     , m_ssaCFG(makeUnique&lt;SSACFG&gt;(*this))</span>
  78     , m_nextMachineLocal(0)
  79     , m_fixpointState(BeforeFixpoint)
  80     , m_structureRegistrationState(HaveNotStartedRegistering)
  81     , m_form(LoadStore)
  82     , m_unificationState(LocallyUnified)
  83     , m_refCountState(EverythingIsLive)
  84 {
  85     ASSERT(m_profiledBlock);
  86 
  87     m_hasDebuggerEnabled = m_profiledBlock-&gt;wasCompiledWithDebuggingOpcodes() || Options::forceDebuggerBytecodeGeneration();
  88 
<a name="3" id="anc3"></a><span class="line-modified">  89     m_indexingCache = makeUnique&lt;FlowIndexing&gt;(*this);</span>
<span class="line-modified">  90     m_abstractValuesCache = makeUnique&lt;FlowMap&lt;AbstractValue&gt;&gt;(*this);</span>
  91 
  92     registerStructure(vm.structureStructure.get());
  93     this-&gt;stringStructure = registerStructure(vm.stringStructure.get());
  94     this-&gt;symbolStructure = registerStructure(vm.symbolStructure.get());
  95 }
  96 
  97 Graph::~Graph()
  98 {
  99 }
 100 
 101 const char *Graph::opName(NodeType op)
 102 {
 103     return dfgOpNames[op];
 104 }
 105 
 106 static void printWhiteSpace(PrintStream&amp; out, unsigned amount)
 107 {
 108     while (amount-- &gt; 0)
 109         out.print(&quot; &quot;);
 110 }
 111 
<a name="4" id="anc4"></a><span class="line-modified"> 112 bool Graph::dumpCodeOrigin(PrintStream&amp; out, const char* prefixStr, Node*&amp; previousNodeRef, Node* currentNode, DumpContext* context)</span>
 113 {
<a name="5" id="anc5"></a><span class="line-added"> 114     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 115     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 116 </span>
 117     if (!currentNode-&gt;origin.semantic)
 118         return false;
 119 
 120     Node* previousNode = previousNodeRef;
 121     previousNodeRef = currentNode;
 122 
 123     if (!previousNode)
 124         return false;
 125 
<a name="6" id="anc6"></a><span class="line-modified"> 126     if (previousNode-&gt;origin.semantic.inlineCallFrame() == currentNode-&gt;origin.semantic.inlineCallFrame())</span>
 127         return false;
 128 
 129     Vector&lt;CodeOrigin&gt; previousInlineStack = previousNode-&gt;origin.semantic.inlineStack();
 130     Vector&lt;CodeOrigin&gt; currentInlineStack = currentNode-&gt;origin.semantic.inlineStack();
 131     unsigned commonSize = std::min(previousInlineStack.size(), currentInlineStack.size());
 132     unsigned indexOfDivergence = commonSize;
 133     for (unsigned i = 0; i &lt; commonSize; ++i) {
<a name="7" id="anc7"></a><span class="line-modified"> 134         if (previousInlineStack[i].inlineCallFrame() != currentInlineStack[i].inlineCallFrame()) {</span>
 135             indexOfDivergence = i;
 136             break;
 137         }
 138     }
 139 
 140     bool hasPrinted = false;
 141 
 142     // Print the pops.
 143     for (unsigned i = previousInlineStack.size(); i-- &gt; indexOfDivergence;) {
 144         out.print(prefix);
 145         printWhiteSpace(out, i * 2);
<a name="8" id="anc8"></a><span class="line-modified"> 146         out.print(&quot;&lt;-- &quot;, inContext(*previousInlineStack[i].inlineCallFrame(), context), &quot;\n&quot;);</span>
 147         hasPrinted = true;
 148     }
 149 
 150     // Print the pushes.
 151     for (unsigned i = indexOfDivergence; i &lt; currentInlineStack.size(); ++i) {
 152         out.print(prefix);
 153         printWhiteSpace(out, i * 2);
<a name="9" id="anc9"></a><span class="line-modified"> 154         out.print(&quot;--&gt; &quot;, inContext(*currentInlineStack[i].inlineCallFrame(), context), &quot;\n&quot;);</span>
 155         hasPrinted = true;
 156     }
 157 
 158     return hasPrinted;
 159 }
 160 
 161 int Graph::amountOfNodeWhiteSpace(Node* node)
 162 {
 163     return (node-&gt;origin.semantic.inlineDepth() - 1) * 2;
 164 }
 165 
 166 void Graph::printNodeWhiteSpace(PrintStream&amp; out, Node* node)
 167 {
 168     printWhiteSpace(out, amountOfNodeWhiteSpace(node));
 169 }
 170 
<a name="10" id="anc10"></a><span class="line-modified"> 171 void Graph::dump(PrintStream&amp; out, const char* prefixStr, Node* node, DumpContext* context)</span>
 172 {
<a name="11" id="anc11"></a><span class="line-added"> 173     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 174     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 175 </span>
 176     NodeType op = node-&gt;op();
 177 
 178     unsigned refCount = node-&gt;refCount();
 179     bool mustGenerate = node-&gt;mustGenerate();
 180     if (mustGenerate)
 181         --refCount;
 182 
 183     out.print(prefix);
 184     printNodeWhiteSpace(out, node);
 185 
 186     // Example/explanation of dataflow dump output
 187     //
 188     //   14:   &lt;!2:7&gt;  GetByVal(@3, @13)
 189     //   ^1     ^2 ^3     ^4       ^5
 190     //
 191     // (1) The nodeIndex of this operation.
 192     // (2) The reference count. The number printed is the &#39;real&#39; count,
 193     //     not including the &#39;mustGenerate&#39; ref. If the node is
 194     //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
 195     // (3) The virtual register slot assigned to this node.
 196     // (4) The name of the operation.
 197     // (5) The arguments to the operation. The may be of the form:
 198     //         @#   - a NodeIndex referencing a prior node in the graph.
 199     //         arg# - an argument number.
 200     //         id#  - the index in the CodeBlock of an identifier { if codeBlock is passed to dump(), the string representation is displayed }.
 201     //         var# - the index of a var on the global object, used by GetGlobalVar/GetGlobalLexicalVariable/PutGlobalVariable operations.
 202     out.printf(&quot;% 4d:&lt;%c%u:&quot;, (int)node-&gt;index(), mustGenerate ? &#39;!&#39; : &#39; &#39;, refCount);
 203     if (node-&gt;hasResult() &amp;&amp; node-&gt;hasVirtualRegister() &amp;&amp; node-&gt;virtualRegister().isValid())
 204         out.print(node-&gt;virtualRegister());
 205     else
 206         out.print(&quot;-&quot;);
 207     out.print(&quot;&gt;\t&quot;, opName(op), &quot;(&quot;);
 208     CommaPrinter comma;
 209     if (node-&gt;flags() &amp; NodeHasVarArgs) {
 210         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
 211             if (!m_varArgChildren[childIdx])
 212                 continue;
 213             out.print(comma, m_varArgChildren[childIdx]);
 214         }
 215     } else {
 216         if (!!node-&gt;child1() || !!node-&gt;child2() || !!node-&gt;child3())
 217             out.print(comma, node-&gt;child1());
 218         if (!!node-&gt;child2() || !!node-&gt;child3())
 219             out.print(comma, node-&gt;child2());
 220         if (!!node-&gt;child3())
 221             out.print(comma, node-&gt;child3());
 222     }
 223 
 224     if (toCString(NodeFlagsDump(node-&gt;flags())) != &quot;&lt;empty&gt;&quot;)
 225         out.print(comma, NodeFlagsDump(node-&gt;flags()));
 226     if (node-&gt;prediction())
 227         out.print(comma, SpeculationDump(node-&gt;prediction()));
 228     if (node-&gt;hasNumberOfArgumentsToSkip())
 229         out.print(comma, &quot;numberOfArgumentsToSkip = &quot;, node-&gt;numberOfArgumentsToSkip());
 230     if (node-&gt;hasArrayMode())
 231         out.print(comma, node-&gt;arrayMode());
 232     if (node-&gt;hasArithUnaryType())
 233         out.print(comma, &quot;Type:&quot;, node-&gt;arithUnaryType());
 234     if (node-&gt;hasArithMode())
 235         out.print(comma, node-&gt;arithMode());
 236     if (node-&gt;hasArithRoundingMode())
 237         out.print(comma, &quot;Rounding:&quot;, node-&gt;arithRoundingMode());
 238     if (node-&gt;hasScopeOffset())
 239         out.print(comma, node-&gt;scopeOffset());
 240     if (node-&gt;hasDirectArgumentsOffset())
 241         out.print(comma, node-&gt;capturedArgumentsOffset());
 242     if (node-&gt;hasArgumentIndex())
 243         out.print(comma, node-&gt;argumentIndex());
 244     if (node-&gt;hasRegisterPointer())
 245         out.print(comma, &quot;global&quot;, &quot;(&quot;, RawPointer(node-&gt;variablePointer()), &quot;)&quot;);
 246     if (node-&gt;hasIdentifier())
 247         out.print(comma, &quot;id&quot;, node-&gt;identifierNumber(), &quot;{&quot;, identifiers()[node-&gt;identifierNumber()], &quot;}&quot;);
 248     if (node-&gt;hasPromotedLocationDescriptor())
 249         out.print(comma, node-&gt;promotedLocationDescriptor());
 250     if (node-&gt;hasClassInfo())
 251         out.print(comma, *node-&gt;classInfo());
 252     if (node-&gt;hasStructureSet())
 253         out.print(comma, inContext(node-&gt;structureSet().toStructureSet(), context));
 254     if (node-&gt;hasStructure())
 255         out.print(comma, inContext(*node-&gt;structure().get(), context));
 256     if (node-&gt;op() == CPUIntrinsic)
 257         out.print(comma, intrinsicName(node-&gt;intrinsic()));
 258     if (node-&gt;hasTransition()) {
 259         out.print(comma, pointerDumpInContext(node-&gt;transition(), context));
 260 #if USE(JSVALUE64)
 261         out.print(&quot;, ID:&quot;, node-&gt;transition()-&gt;next-&gt;id());
 262 #else
 263         out.print(&quot;, ID:&quot;, RawPointer(node-&gt;transition()-&gt;next.get()));
 264 #endif
 265     }
 266     if (node-&gt;hasCellOperand()) {
 267         if (!node-&gt;cellOperand()-&gt;value() || !node-&gt;cellOperand()-&gt;value().isCell())
 268             out.print(comma, &quot;invalid cell operand: &quot;, node-&gt;cellOperand()-&gt;value());
 269         else {
 270             out.print(comma, pointerDump(node-&gt;cellOperand()-&gt;value().asCell()));
 271             if (node-&gt;cellOperand()-&gt;value().isCell()) {
 272                 CallVariant variant(node-&gt;cellOperand()-&gt;value().asCell());
 273                 if (ExecutableBase* executable = variant.executable()) {
 274                     if (executable-&gt;isHostFunction())
 275                         out.print(comma, &quot;&lt;host function&gt;&quot;);
 276                     else if (FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, executable))
 277                         out.print(comma, FunctionExecutableDump(functionExecutable));
 278                     else
 279                         out.print(comma, &quot;&lt;non-function executable&gt;&quot;);
 280                 }
 281             }
 282         }
 283     }
 284     if (node-&gt;hasSpeculatedTypeForQuery())
 285         out.print(comma, SpeculationDump(node-&gt;speculatedTypeForQuery()));
 286     if (node-&gt;hasStorageAccessData()) {
 287         StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
 288         out.print(comma, &quot;id&quot;, storageAccessData.identifierNumber, &quot;{&quot;, identifiers()[storageAccessData.identifierNumber], &quot;}&quot;);
 289         out.print(&quot;, &quot;, static_cast&lt;ptrdiff_t&gt;(storageAccessData.offset));
 290     }
 291     if (node-&gt;hasMultiGetByOffsetData()) {
 292         MultiGetByOffsetData&amp; data = node-&gt;multiGetByOffsetData();
 293         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 294         for (unsigned i = 0; i &lt; data.cases.size(); ++i)
 295             out.print(comma, inContext(data.cases[i], context));
 296     }
 297     if (node-&gt;hasMultiPutByOffsetData()) {
 298         MultiPutByOffsetData&amp; data = node-&gt;multiPutByOffsetData();
 299         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 300         for (unsigned i = 0; i &lt; data.variants.size(); ++i)
 301             out.print(comma, inContext(data.variants[i], context));
 302     }
 303     if (node-&gt;hasMatchStructureData()) {
 304         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants)
 305             out.print(comma, inContext(*variant.structure.get(), context), &quot;=&gt;&quot;, variant.result);
 306     }
 307     ASSERT(node-&gt;hasVariableAccessData(*this) == node-&gt;accessesStack(*this));
 308     if (node-&gt;hasVariableAccessData(*this)) {
 309         VariableAccessData* variableAccessData = node-&gt;tryGetVariableAccessData();
 310         if (variableAccessData) {
 311             VirtualRegister operand = variableAccessData-&gt;local();
 312             out.print(comma, variableAccessData-&gt;local(), &quot;(&quot;, VariableAccessDataDump(*this, variableAccessData), &quot;)&quot;);
 313             operand = variableAccessData-&gt;machineLocal();
 314             if (operand.isValid())
 315                 out.print(comma, &quot;machine:&quot;, operand);
 316         }
 317     }
 318     if (node-&gt;hasStackAccessData()) {
 319         StackAccessData* data = node-&gt;stackAccessData();
 320         out.print(comma, data-&gt;local);
 321         if (data-&gt;machineLocal.isValid())
 322             out.print(comma, &quot;machine:&quot;, data-&gt;machineLocal);
 323         out.print(comma, data-&gt;format);
 324     }
 325     if (node-&gt;hasUnlinkedLocal())
 326         out.print(comma, node-&gt;unlinkedLocal());
 327     if (node-&gt;hasVectorLengthHint())
 328         out.print(comma, &quot;vectorLengthHint = &quot;, node-&gt;vectorLengthHint());
 329     if (node-&gt;hasLazyJSValue())
 330         out.print(comma, node-&gt;lazyJSValue());
 331     if (node-&gt;hasIndexingType())
 332         out.print(comma, IndexingTypeDump(node-&gt;indexingMode()));
 333     if (node-&gt;hasTypedArrayType())
 334         out.print(comma, node-&gt;typedArrayType());
 335     if (node-&gt;hasPhi())
 336         out.print(comma, &quot;^&quot;, node-&gt;phi()-&gt;index());
 337     if (node-&gt;hasExecutionCounter())
 338         out.print(comma, RawPointer(node-&gt;executionCounter()));
 339     if (node-&gt;hasWatchpointSet())
 340         out.print(comma, RawPointer(node-&gt;watchpointSet()));
 341     if (node-&gt;hasStoragePointer())
 342         out.print(comma, RawPointer(node-&gt;storagePointer()));
 343     if (node-&gt;hasObjectMaterializationData())
 344         out.print(comma, node-&gt;objectMaterializationData());
 345     if (node-&gt;hasCallVarargsData())
 346         out.print(comma, &quot;firstVarArgOffset = &quot;, node-&gt;callVarargsData()-&gt;firstVarArgOffset);
 347     if (node-&gt;hasLoadVarargsData()) {
 348         LoadVarargsData* data = node-&gt;loadVarargsData();
 349         out.print(comma, &quot;start = &quot;, data-&gt;start, &quot;, count = &quot;, data-&gt;count);
 350         if (data-&gt;machineStart.isValid())
 351             out.print(&quot;, machineStart = &quot;, data-&gt;machineStart);
 352         if (data-&gt;machineCount.isValid())
 353             out.print(&quot;, machineCount = &quot;, data-&gt;machineCount);
 354         out.print(&quot;, offset = &quot;, data-&gt;offset, &quot;, mandatoryMinimum = &quot;, data-&gt;mandatoryMinimum);
 355         out.print(&quot;, limit = &quot;, data-&gt;limit);
 356     }
 357     if (node-&gt;hasCallDOMGetterData()) {
 358         CallDOMGetterData* data = node-&gt;callDOMGetterData();
 359         out.print(comma, &quot;id&quot;, data-&gt;identifierNumber, &quot;{&quot;, identifiers()[data-&gt;identifierNumber], &quot;}&quot;);
 360         out.print(&quot;, domJIT = &quot;, RawPointer(data-&gt;domJIT));
 361     }
 362     if (node-&gt;hasIgnoreLastIndexIsWritable())
 363         out.print(comma, &quot;ignoreLastIndexIsWritable = &quot;, node-&gt;ignoreLastIndexIsWritable());
 364     if (node-&gt;isConstant())
 365         out.print(comma, pointerDumpInContext(node-&gt;constant(), context));
 366     if (node-&gt;hasCallLinkStatus())
 367         out.print(comma, *node-&gt;callLinkStatus());
 368     if (node-&gt;hasGetByIdStatus())
 369         out.print(comma, *node-&gt;getByIdStatus());
 370     if (node-&gt;hasInByIdStatus())
 371         out.print(comma, *node-&gt;inByIdStatus());
 372     if (node-&gt;hasPutByIdStatus())
 373         out.print(comma, *node-&gt;putByIdStatus());
 374     if (node-&gt;isJump())
 375         out.print(comma, &quot;T:&quot;, *node-&gt;targetBlock());
 376     if (node-&gt;isBranch())
 377         out.print(comma, &quot;T:&quot;, node-&gt;branchData()-&gt;taken, &quot;, F:&quot;, node-&gt;branchData()-&gt;notTaken);
 378     if (node-&gt;isSwitch()) {
 379         SwitchData* data = node-&gt;switchData();
 380         out.print(comma, data-&gt;kind);
 381         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 382             out.print(comma, inContext(data-&gt;cases[i].value, context), &quot;:&quot;, data-&gt;cases[i].target);
 383         out.print(comma, &quot;default:&quot;, data-&gt;fallThrough);
 384     }
 385     if (node-&gt;isEntrySwitch()) {
 386         EntrySwitchData* data = node-&gt;entrySwitchData();
 387         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 388             out.print(comma, BranchTarget(data-&gt;cases[i]));
 389     }
 390     ClobberSet reads;
 391     ClobberSet writes;
 392     addReadsAndWrites(*this, node, reads, writes);
 393     if (!reads.isEmpty())
 394         out.print(comma, &quot;R:&quot;, sortedListDump(reads.direct(), &quot;,&quot;));
 395     if (!writes.isEmpty())
 396         out.print(comma, &quot;W:&quot;, sortedListDump(writes.direct(), &quot;,&quot;));
 397     ExitMode exitMode = mayExit(*this, node);
 398     if (exitMode != DoesNotExit)
 399         out.print(comma, exitMode);
 400     if (clobbersExitState(*this, node))
 401         out.print(comma, &quot;ClobbersExit&quot;);
 402     if (node-&gt;origin.isSet()) {
<a name="12" id="anc12"></a><span class="line-modified"> 403         out.print(comma, &quot;bc#&quot;, node-&gt;origin.semantic.bytecodeIndex());</span>
 404         if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
 405             out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
 406     }
 407     out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
 408     if (node-&gt;origin.wasHoisted)
 409         out.print(comma, &quot;WasHoisted&quot;);
 410     out.print(&quot;)&quot;);
 411 
 412     if (node-&gt;accessesStack(*this) &amp;&amp; node-&gt;tryGetVariableAccessData())
 413         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;tryGetVariableAccessData()-&gt;prediction()));
 414     else if (node-&gt;hasHeapPrediction())
 415         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;getHeapPrediction()));
 416 
 417     out.print(&quot;\n&quot;);
 418 }
 419 
 420 bool Graph::terminalsAreValid()
 421 {
 422     for (BasicBlock* block : blocksInNaturalOrder()) {
 423         if (!block-&gt;terminal())
 424             return false;
 425     }
 426     return true;
 427 }
 428 
 429 static BasicBlock* unboxLoopNode(const CPSCFG::Node&amp; node) { return node.node(); }
 430 static BasicBlock* unboxLoopNode(BasicBlock* block) { return block; }
 431 
<a name="13" id="anc13"></a><span class="line-modified"> 432 void Graph::dumpBlockHeader(PrintStream&amp; out, const char* prefixStr, BasicBlock* block, PhiNodeDumpMode phiNodeDumpMode, DumpContext* context)</span>
 433 {
<a name="14" id="anc14"></a><span class="line-added"> 434     Prefix myPrefix(prefixStr);</span>
<span class="line-added"> 435     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;</span>
<span class="line-added"> 436 </span>
 437     out.print(prefix, &quot;Block &quot;, *block, &quot; (&quot;, inContext(block-&gt;at(0)-&gt;origin.semantic, context), &quot;):&quot;,
 438         block-&gt;isReachable ? &quot;&quot; : &quot; (skipped)&quot;, block-&gt;isOSRTarget ? &quot; (OSR target)&quot; : &quot;&quot;, block-&gt;isCatchEntrypoint ? &quot; (Catch Entrypoint)&quot; : &quot;&quot;, &quot;\n&quot;);
 439     if (block-&gt;executionCount == block-&gt;executionCount)
 440         out.print(prefix, &quot;  Execution count: &quot;, block-&gt;executionCount, &quot;\n&quot;);
 441     out.print(prefix, &quot;  Predecessors:&quot;);
 442     for (size_t i = 0; i &lt; block-&gt;predecessors.size(); ++i)
 443         out.print(&quot; &quot;, *block-&gt;predecessors[i]);
 444     out.print(&quot;\n&quot;);
 445     out.print(prefix, &quot;  Successors:&quot;);
 446     if (block-&gt;terminal()) {
 447         for (BasicBlock* successor : block-&gt;successors()) {
 448             out.print(&quot; &quot;, *successor);
 449         }
 450     } else
 451         out.print(&quot; &lt;invalid&gt;&quot;);
 452     out.print(&quot;\n&quot;);
 453 
 454     auto printDominators = [&amp;] (auto&amp; dominators) {
 455         out.print(prefix, &quot;  Dominated by: &quot;, dominators.dominatorsOf(block), &quot;\n&quot;);
 456         out.print(prefix, &quot;  Dominates: &quot;, dominators.blocksDominatedBy(block), &quot;\n&quot;);
 457         out.print(prefix, &quot;  Dominance Frontier: &quot;, dominators.dominanceFrontierOf(block), &quot;\n&quot;);
 458         out.print(prefix, &quot;  Iterated Dominance Frontier: &quot;,
 459             dominators.iteratedDominanceFrontierOf(typename std::remove_reference&lt;decltype(dominators)&gt;::type::List { block }), &quot;\n&quot;);
 460     };
 461 
 462     if (terminalsAreValid()) {
 463         if (m_ssaDominators)
 464             printDominators(*m_ssaDominators);
 465         else if (m_cpsDominators)
 466             printDominators(*m_cpsDominators);
 467     }
 468 
 469     if (m_backwardsDominators &amp;&amp; terminalsAreValid()) {
 470         out.print(prefix, &quot;  Backwards dominates by: &quot;, m_backwardsDominators-&gt;dominatorsOf(block), &quot;\n&quot;);
 471         out.print(prefix, &quot;  Backwards dominates: &quot;, m_backwardsDominators-&gt;blocksDominatedBy(block), &quot;\n&quot;);
 472     }
 473     if (m_controlEquivalenceAnalysis &amp;&amp; terminalsAreValid()) {
 474         out.print(prefix, &quot;  Control equivalent to:&quot;);
 475         for (BasicBlock* otherBlock : blocksInNaturalOrder()) {
 476             if (m_controlEquivalenceAnalysis-&gt;areEquivalent(block, otherBlock))
 477                 out.print(&quot; &quot;, *otherBlock);
 478         }
 479         out.print(&quot;\n&quot;);
 480     }
 481 
 482     auto printNaturalLoops = [&amp;] (auto&amp; naturalLoops) {
 483         if (const auto* loop = naturalLoops-&gt;headerOf(block)) {
 484             out.print(prefix, &quot;  Loop header, contains:&quot;);
 485             Vector&lt;BlockIndex&gt; sortedBlockList;
 486             for (unsigned i = 0; i &lt; loop-&gt;size(); ++i)
 487                 sortedBlockList.append(unboxLoopNode(loop-&gt;at(i))-&gt;index);
 488             std::sort(sortedBlockList.begin(), sortedBlockList.end());
 489             for (unsigned i = 0; i &lt; sortedBlockList.size(); ++i)
 490                 out.print(&quot; #&quot;, sortedBlockList[i]);
 491             out.print(&quot;\n&quot;);
 492         }
 493 
 494         auto containingLoops = naturalLoops-&gt;loopsOf(block);
 495         if (!containingLoops.isEmpty()) {
 496             out.print(prefix, &quot;  Containing loop headers:&quot;);
 497             for (unsigned i = 0; i &lt; containingLoops.size(); ++i)
 498                 out.print(&quot; &quot;, *unboxLoopNode(containingLoops[i]-&gt;header()));
 499             out.print(&quot;\n&quot;);
 500         }
 501     };
 502 
 503     if (m_ssaNaturalLoops)
 504         printNaturalLoops(m_ssaNaturalLoops);
 505     else if (m_cpsNaturalLoops)
 506         printNaturalLoops(m_cpsNaturalLoops);
 507 
 508     if (!block-&gt;phis.isEmpty()) {
 509         out.print(prefix, &quot;  Phi Nodes:&quot;);
 510         for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 511             Node* phiNode = block-&gt;phis[i];
 512             if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
 513                 continue;
 514             out.print(&quot; @&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;local(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);
 515             if (phiNode-&gt;child1()) {
 516                 out.print(&quot;@&quot;, phiNode-&gt;child1()-&gt;index());
 517                 if (phiNode-&gt;child2()) {
 518                     out.print(&quot;, @&quot;, phiNode-&gt;child2()-&gt;index());
 519                     if (phiNode-&gt;child3())
 520                         out.print(&quot;, @&quot;, phiNode-&gt;child3()-&gt;index());
 521                 }
 522             }
 523             out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
 524         }
 525         out.print(&quot;\n&quot;);
 526     }
 527 }
 528 
 529 void Graph::dump(PrintStream&amp; out, DumpContext* context)
 530 {
<a name="15" id="anc15"></a><span class="line-added"> 531     Prefix&amp; prefix = m_prefix;</span>
 532     DumpContext myContext;
 533     myContext.graph = this;
 534     if (!context)
 535         context = &amp;myContext;
 536 
 537     out.print(&quot;\n&quot;);
<a name="16" id="anc16"></a><span class="line-modified"> 538     out.print(prefix, &quot;DFG for &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT), &quot;:\n&quot;);</span>
<span class="line-modified"> 539     out.print(prefix, &quot;  Fixpoint state: &quot;, m_fixpointState, &quot;; Form: &quot;, m_form, &quot;; Unification state: &quot;, m_unificationState, &quot;; Ref count state: &quot;, m_refCountState, &quot;\n&quot;);</span>
 540     if (m_form == SSA) {
 541         for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
<a name="17" id="anc17"></a><span class="line-modified"> 542             out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);</span>
 543     }
 544     else {
 545         for (auto pair : m_rootToArguments)
<a name="18" id="anc18"></a><span class="line-modified"> 546             out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);</span>
 547     }
 548     out.print(&quot;\n&quot;);
 549 
 550     Node* lastNode = nullptr;
 551     for (size_t b = 0; b &lt; m_blocks.size(); ++b) {
 552         BasicBlock* block = m_blocks[b].get();
 553         if (!block)
 554             continue;
<a name="19" id="anc19"></a><span class="line-modified"> 555         prefix.blockIndex = block-&gt;index;</span>
<span class="line-modified"> 556         dumpBlockHeader(out, Prefix::noString, block, DumpAllPhis, context);</span>
<span class="line-added"> 557         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaStructureClobberStateAtHead);</span>
 558         if (!block-&gt;cfaHasVisited)
 559             out.print(&quot;, CurrentlyCFAUnreachable&quot;);
 560         if (!block-&gt;intersectionOfCFAHasVisited)
 561             out.print(&quot;, CFAUnreachable&quot;);
 562         out.print(&quot;\n&quot;);
 563         switch (m_form) {
 564         case LoadStore:
 565         case ThreadedCPS: {
<a name="20" id="anc20"></a><span class="line-modified"> 566             out.print(prefix, &quot;  Vars Before: &quot;);</span>
 567             if (block-&gt;cfaHasVisited)
 568                 out.print(inContext(block-&gt;valuesAtHead, context));
 569             else
 570                 out.print(&quot;&lt;empty&gt;&quot;);
 571             out.print(&quot;\n&quot;);
<a name="21" id="anc21"></a><span class="line-modified"> 572             out.print(prefix, &quot;  Intersected Vars Before: &quot;);</span>
 573             if (block-&gt;intersectionOfCFAHasVisited)
 574                 out.print(inContext(block-&gt;intersectionOfPastValuesAtHead, context));
 575             else
 576                 out.print(&quot;&lt;empty&gt;&quot;);
 577             out.print(&quot;\n&quot;);
<a name="22" id="anc22"></a><span class="line-modified"> 578             out.print(prefix, &quot;  Var Links: &quot;, block-&gt;variablesAtHead, &quot;\n&quot;);</span>
 579             break;
 580         }
 581 
 582         case SSA: {
 583             RELEASE_ASSERT(block-&gt;ssa);
 584             if (dumpOSRAvailabilityData)
<a name="23" id="anc23"></a><span class="line-modified"> 585                 out.print(prefix, &quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtHead, &quot;\n&quot;);</span>
<span class="line-modified"> 586             out.print(prefix, &quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtHead), &quot;\n&quot;);</span>
<span class="line-modified"> 587             out.print(prefix, &quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtHead, context), &quot;\n&quot;);</span>
 588             break;
 589         } }
 590         for (size_t i = 0; i &lt; block-&gt;size(); ++i) {
<a name="24" id="anc24"></a><span class="line-modified"> 591             prefix.clearNodeIndex();</span>
<span class="line-modified"> 592             dumpCodeOrigin(out, Prefix::noString, lastNode, block-&gt;at(i), context);</span>
<span class="line-added"> 593             prefix.nodeIndex = i;</span>
<span class="line-added"> 594             dump(out, Prefix::noString, block-&gt;at(i), context);</span>
 595         }
<a name="25" id="anc25"></a><span class="line-modified"> 596         prefix.clearNodeIndex();</span>
<span class="line-added"> 597         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaBranchDirection, &quot;, &quot;, block-&gt;cfaStructureClobberStateAtTail);</span>
 598         if (!block-&gt;cfaDidFinish)
 599             out.print(&quot;, CFAInvalidated&quot;);
 600         out.print(&quot;\n&quot;);
 601         switch (m_form) {
 602         case LoadStore:
 603         case ThreadedCPS: {
<a name="26" id="anc26"></a><span class="line-modified"> 604             out.print(prefix, &quot;  Vars After: &quot;);</span>
 605             if (block-&gt;cfaHasVisited)
 606                 out.print(inContext(block-&gt;valuesAtTail, context));
 607             else
 608                 out.print(&quot;&lt;empty&gt;&quot;);
 609             out.print(&quot;\n&quot;);
<a name="27" id="anc27"></a><span class="line-modified"> 610             out.print(prefix, &quot;  Var Links: &quot;, block-&gt;variablesAtTail, &quot;\n&quot;);</span>
 611             break;
 612         }
 613 
 614         case SSA: {
 615             RELEASE_ASSERT(block-&gt;ssa);
 616             if (dumpOSRAvailabilityData)
<a name="28" id="anc28"></a><span class="line-modified"> 617                 out.print(prefix, &quot;  Availability: &quot;, block-&gt;ssa-&gt;availabilityAtTail, &quot;\n&quot;);</span>
<span class="line-modified"> 618             out.print(prefix, &quot;  Live: &quot;, nodeListDump(block-&gt;ssa-&gt;liveAtTail), &quot;\n&quot;);</span>
<span class="line-modified"> 619             out.print(prefix, &quot;  Values: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtTail, context), &quot;\n&quot;);</span>
 620             break;
 621         } }
 622         out.print(&quot;\n&quot;);
 623     }
<a name="29" id="anc29"></a><span class="line-added"> 624     prefix.clearBlockIndex();</span>
 625 
<a name="30" id="anc30"></a><span class="line-modified"> 626     out.print(prefix, &quot;GC Values:\n&quot;);</span>
 627     for (FrozenValue* value : m_frozenValues) {
 628         if (value-&gt;pointsToHeap())
<a name="31" id="anc31"></a><span class="line-modified"> 629             out.print(prefix, &quot;    &quot;, inContext(*value, &amp;myContext), &quot;\n&quot;);</span>
 630     }
 631 
 632     out.print(inContext(watchpoints(), &amp;myContext));
 633 
 634     if (!myContext.isEmpty()) {
<a name="32" id="anc32"></a><span class="line-modified"> 635         StringPrintStream prefixStr;</span>
<span class="line-added"> 636         prefixStr.print(prefix);</span>
<span class="line-added"> 637         myContext.dump(out, prefixStr.toCString().data());</span>
 638         out.print(&quot;\n&quot;);
 639     }
 640 }
 641 
 642 void Graph::deleteNode(Node* node)
 643 {
 644     if (validationEnabled() &amp;&amp; m_form == SSA) {
 645         for (BasicBlock* block : blocksInNaturalOrder()) {
 646             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtHead.contains(node));
 647             DFG_ASSERT(*this, node, !block-&gt;ssa-&gt;liveAtTail.contains(node));
 648         }
 649     }
 650 
 651     m_nodes.remove(node);
 652 }
 653 
 654 void Graph::packNodeIndices()
 655 {
 656     m_nodes.packIndices();
 657 }
 658 
 659 void Graph::dethread()
 660 {
 661     if (m_form == LoadStore || m_form == SSA)
 662         return;
 663 
 664     if (logCompilationChanges())
 665         dataLog(&quot;Dethreading DFG graph.\n&quot;);
 666 
 667     for (BlockIndex blockIndex = m_blocks.size(); blockIndex--;) {
 668         BasicBlock* block = m_blocks[blockIndex].get();
 669         if (!block)
 670             continue;
 671         for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;) {
 672             Node* phi = block-&gt;phis[phiIndex];
 673             phi-&gt;children.reset();
 674         }
 675     }
 676 
 677     m_form = LoadStore;
 678 }
 679 
 680 void Graph::handleSuccessor(Vector&lt;BasicBlock*, 16&gt;&amp; worklist, BasicBlock* block, BasicBlock* successor)
 681 {
 682     if (!successor-&gt;isReachable) {
 683         successor-&gt;isReachable = true;
 684         worklist.append(successor);
 685     }
 686 
 687     if (!successor-&gt;predecessors.contains(block))
 688         successor-&gt;predecessors.append(block);
 689 }
 690 
 691 void Graph::determineReachability()
 692 {
 693     Vector&lt;BasicBlock*, 16&gt; worklist;
 694     for (BasicBlock* entrypoint : m_roots) {
 695         entrypoint-&gt;isReachable = true;
 696         worklist.append(entrypoint);
 697     }
 698     while (!worklist.isEmpty()) {
 699         BasicBlock* block = worklist.takeLast();
 700         for (unsigned i = block-&gt;numSuccessors(); i--;)
 701             handleSuccessor(worklist, block, block-&gt;successor(i));
 702     }
 703 }
 704 
 705 void Graph::resetReachability()
 706 {
 707     for (BlockIndex blockIndex = m_blocks.size(); blockIndex--;) {
 708         BasicBlock* block = m_blocks[blockIndex].get();
 709         if (!block)
 710             continue;
 711         block-&gt;isReachable = false;
 712         block-&gt;predecessors.clear();
 713     }
 714 
 715     determineReachability();
 716 }
 717 
 718 namespace {
 719 
 720 class RefCountCalculator {
 721 public:
 722     RefCountCalculator(Graph&amp; graph)
 723         : m_graph(graph)
 724     {
 725     }
 726 
 727     void calculate()
 728     {
 729         // First reset the counts to 0 for all nodes.
 730         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 731             BasicBlock* block = m_graph.block(blockIndex);
 732             if (!block)
 733                 continue;
 734             for (unsigned indexInBlock = block-&gt;size(); indexInBlock--;)
 735                 block-&gt;at(indexInBlock)-&gt;setRefCount(0);
 736             for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
 737                 block-&gt;phis[phiIndex]-&gt;setRefCount(0);
 738         }
 739 
 740         // Now find the roots:
 741         // - Nodes that are must-generate.
 742         // - Nodes that are reachable from type checks.
 743         // Set their ref counts to 1 and put them on the worklist.
 744         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 745             BasicBlock* block = m_graph.block(blockIndex);
 746             if (!block)
 747                 continue;
 748             for (unsigned indexInBlock = block-&gt;size(); indexInBlock--;) {
 749                 Node* node = block-&gt;at(indexInBlock);
 750                 DFG_NODE_DO_TO_CHILDREN(m_graph, node, findTypeCheckRoot);
 751                 if (!(node-&gt;flags() &amp; NodeMustGenerate))
 752                     continue;
 753                 if (!node-&gt;postfixRef())
 754                     m_worklist.append(node);
 755             }
 756         }
 757 
 758         while (!m_worklist.isEmpty()) {
 759             while (!m_worklist.isEmpty()) {
 760                 Node* node = m_worklist.last();
 761                 m_worklist.removeLast();
 762                 ASSERT(node-&gt;shouldGenerate()); // It should not be on the worklist unless it&#39;s ref&#39;ed.
 763                 DFG_NODE_DO_TO_CHILDREN(m_graph, node, countEdge);
 764             }
 765 
 766             if (m_graph.m_form == SSA) {
 767                 // Find Phi-&gt;Upsilon edges, which are represented as meta-data in the
 768                 // Upsilon.
 769                 for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 770                     BasicBlock* block = m_graph.block(blockIndex);
 771                     if (!block)
 772                         continue;
 773                     for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 774                         Node* node = block-&gt;at(nodeIndex);
 775                         if (node-&gt;op() != Upsilon)
 776                             continue;
 777                         if (node-&gt;shouldGenerate())
 778                             continue;
 779                         if (node-&gt;phi()-&gt;shouldGenerate())
 780                             countNode(node);
 781                     }
 782                 }
 783             }
 784         }
 785     }
 786 
 787 private:
 788     void findTypeCheckRoot(Node*, Edge edge)
 789     {
 790         // We may have an &quot;unproved&quot; untyped use for code that is unreachable. The CFA
 791         // will just not have gotten around to it.
 792         if (edge.isProved() || edge.willNotHaveCheck())
 793             return;
 794         if (!edge-&gt;postfixRef())
 795             m_worklist.append(edge.node());
 796     }
 797 
 798     void countNode(Node* node)
 799     {
 800         if (node-&gt;postfixRef())
 801             return;
 802         m_worklist.append(node);
 803     }
 804 
 805     void countEdge(Node*, Edge edge)
 806     {
 807         // Don&#39;t count edges that are already counted for their type checks.
 808         if (!(edge.isProved() || edge.willNotHaveCheck()))
 809             return;
 810         countNode(edge.node());
 811     }
 812 
 813     Graph&amp; m_graph;
 814     Vector&lt;Node*, 128&gt; m_worklist;
 815 };
 816 
 817 } // anonymous namespace
 818 
 819 void Graph::computeRefCounts()
 820 {
 821     RefCountCalculator calculator(*this);
 822     calculator.calculate();
 823 }
 824 
 825 void Graph::killBlockAndItsContents(BasicBlock* block)
 826 {
 827     if (auto&amp; ssaData = block-&gt;ssa)
 828         ssaData-&gt;invalidate();
 829     for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
 830         deleteNode(block-&gt;phis[phiIndex]);
 831     for (Node* node : *block)
 832         deleteNode(node);
 833 
 834     killBlock(block);
 835 }
 836 
 837 void Graph::killUnreachableBlocks()
 838 {
 839     invalidateNodeLiveness();
 840 
 841     for (BlockIndex blockIndex = 0; blockIndex &lt; numBlocks(); ++blockIndex) {
 842         BasicBlock* block = this-&gt;block(blockIndex);
 843         if (!block)
 844             continue;
 845         if (block-&gt;isReachable)
 846             continue;
 847 
 848         dataLogIf(Options::verboseDFGBytecodeParsing(), &quot;Basic block #&quot;, blockIndex, &quot; was killed because it was unreachable\n&quot;);
 849         killBlockAndItsContents(block);
 850     }
 851 }
 852 
 853 void Graph::invalidateCFG()
 854 {
 855     m_cpsDominators = nullptr;
 856     m_ssaDominators = nullptr;
 857     m_cpsNaturalLoops = nullptr;
 858     m_ssaNaturalLoops = nullptr;
 859     m_controlEquivalenceAnalysis = nullptr;
 860     m_backwardsDominators = nullptr;
 861     m_backwardsCFG = nullptr;
 862     m_cpsCFG = nullptr;
 863 }
 864 
 865 void Graph::invalidateNodeLiveness()
 866 {
 867     if (m_form != SSA)
 868         return;
 869 
 870     for (BasicBlock* block : blocksInNaturalOrder())
 871         block-&gt;ssa-&gt;invalidate();
 872 }
 873 
 874 void Graph::substituteGetLocal(BasicBlock&amp; block, unsigned startIndexInBlock, VariableAccessData* variableAccessData, Node* newGetLocal)
 875 {
 876     for (unsigned indexInBlock = startIndexInBlock; indexInBlock &lt; block.size(); ++indexInBlock) {
 877         Node* node = block[indexInBlock];
 878         bool shouldContinue = true;
 879         switch (node-&gt;op()) {
 880         case SetLocal: {
 881             if (node-&gt;local() == variableAccessData-&gt;local())
 882                 shouldContinue = false;
 883             break;
 884         }
 885 
 886         case GetLocal: {
 887             if (node-&gt;variableAccessData() != variableAccessData)
 888                 continue;
 889             substitute(block, indexInBlock, node, newGetLocal);
 890             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;local());
 891             if (oldTailNode == node)
 892                 block.variablesAtTail.operand(variableAccessData-&gt;local()) = newGetLocal;
 893             shouldContinue = false;
 894             break;
 895         }
 896 
 897         default:
 898             break;
 899         }
 900         if (!shouldContinue)
 901             break;
 902     }
 903 }
 904 
 905 BlockList Graph::blocksInPreOrder()
 906 {
 907     BlockList result;
<a name="33" id="anc33"></a><span class="line-added"> 908     result.reserveInitialCapacity(m_blocks.size());</span>
 909     BlockWorklist worklist;
 910     for (BasicBlock* entrypoint : m_roots)
 911         worklist.push(entrypoint);
 912     while (BasicBlock* block = worklist.pop()) {
 913         result.append(block);
 914         for (unsigned i = block-&gt;numSuccessors(); i--;)
 915             worklist.push(block-&gt;successor(i));
 916     }
 917 
 918     if (validationEnabled()) {
 919         // When iterating over pre order, we should see dominators
 920         // before things they dominate.
 921         auto validateResults = [&amp;] (auto&amp; dominators) {
 922             for (unsigned i = 0; i &lt; result.size(); ++i) {
 923                 BasicBlock* a = result[i];
 924                 if (!a)
 925                     continue;
 926                 for (unsigned j = 0; j &lt; result.size(); ++j) {
 927                     BasicBlock* b = result[j];
 928                     if (!b || a == b)
 929                         continue;
 930                     if (dominators.dominates(a, b))
 931                         RELEASE_ASSERT(i &lt; j);
 932                 }
 933             }
 934         };
 935 
 936         if (m_form == SSA || m_isInSSAConversion)
 937             validateResults(ensureSSADominators());
 938         else
 939             validateResults(ensureCPSDominators());
 940     }
 941     return result;
 942 }
 943 
 944 BlockList Graph::blocksInPostOrder(bool isSafeToValidate)
 945 {
 946     BlockList result;
<a name="34" id="anc34"></a><span class="line-added"> 947     result.reserveInitialCapacity(m_blocks.size());</span>
 948     PostOrderBlockWorklist worklist;
 949     for (BasicBlock* entrypoint : m_roots)
 950         worklist.push(entrypoint);
 951     while (BlockWithOrder item = worklist.pop()) {
 952         switch (item.order) {
 953         case VisitOrder::Pre:
 954             worklist.pushPost(item.node);
 955             for (unsigned i = item.node-&gt;numSuccessors(); i--;)
 956                 worklist.push(item.node-&gt;successor(i));
 957             break;
 958         case VisitOrder::Post:
 959             result.append(item.node);
 960             break;
 961         }
 962     }
 963 
 964     if (isSafeToValidate &amp;&amp; validationEnabled()) { // There are users of this where we haven&#39;t yet built of the CFG enough to be able to run dominators.
 965         auto validateResults = [&amp;] (auto&amp; dominators) {
 966             // When iterating over reverse post order, we should see dominators
 967             // before things they dominate.
 968             for (unsigned i = 0; i &lt; result.size(); ++i) {
 969                 BasicBlock* a = result[i];
 970                 if (!a)
 971                     continue;
 972                 for (unsigned j = 0; j &lt; result.size(); ++j) {
 973                     BasicBlock* b = result[j];
 974                     if (!b || a == b)
 975                         continue;
 976                     if (dominators.dominates(a, b))
 977                         RELEASE_ASSERT(i &gt; j);
 978                 }
 979             }
 980         };
 981 
 982         if (m_form == SSA || m_isInSSAConversion)
 983             validateResults(ensureSSADominators());
 984         else
 985             validateResults(ensureCPSDominators());
 986     }
 987 
 988     return result;
 989 }
 990 
 991 void Graph::clearReplacements()
 992 {
 993     for (BlockIndex blockIndex = numBlocks(); blockIndex--;) {
 994         BasicBlock* block = m_blocks[blockIndex].get();
 995         if (!block)
 996             continue;
 997         for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
 998             block-&gt;phis[phiIndex]-&gt;setReplacement(nullptr);
 999         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;)
1000             block-&gt;at(nodeIndex)-&gt;setReplacement(nullptr);
1001     }
1002 }
1003 
1004 void Graph::clearEpochs()
1005 {
1006     for (BlockIndex blockIndex = numBlocks(); blockIndex--;) {
1007         BasicBlock* block = m_blocks[blockIndex].get();
1008         if (!block)
1009             continue;
1010         for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
1011             block-&gt;phis[phiIndex]-&gt;setEpoch(Epoch());
1012         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;)
1013             block-&gt;at(nodeIndex)-&gt;setEpoch(Epoch());
1014     }
1015 }
1016 
1017 void Graph::initializeNodeOwners()
1018 {
1019     for (BlockIndex blockIndex = numBlocks(); blockIndex--;) {
1020         BasicBlock* block = m_blocks[blockIndex].get();
1021         if (!block)
1022             continue;
1023         for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
1024             block-&gt;phis[phiIndex]-&gt;owner = block;
1025         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;)
1026             block-&gt;at(nodeIndex)-&gt;owner = block;
1027     }
1028 }
1029 
1030 void Graph::clearFlagsOnAllNodes(NodeFlags flags)
1031 {
1032     for (BlockIndex blockIndex = numBlocks(); blockIndex--;) {
1033         BasicBlock* block = m_blocks[blockIndex].get();
1034         if (!block)
1035             continue;
1036         for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
1037             block-&gt;phis[phiIndex]-&gt;clearFlags(flags);
1038         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;)
1039             block-&gt;at(nodeIndex)-&gt;clearFlags(flags);
1040     }
1041 }
1042 
1043 bool Graph::watchCondition(const ObjectPropertyCondition&amp; key)
1044 {
1045     if (!key.isWatchable())
1046         return false;
1047 
1048     DesiredWeakReferences&amp; weakReferences = m_plan.weakReferences();
1049     weakReferences.addLazily(key.object());
1050     if (key.hasPrototype())
1051         weakReferences.addLazily(key.prototype());
1052     if (key.hasRequiredValue())
1053         weakReferences.addLazily(key.requiredValue());
1054 
1055     m_plan.watchpoints().addLazily(key);
1056 
1057     if (key.kind() == PropertyCondition::Presence)
1058         m_safeToLoad.add(std::make_pair(key.object(), key.offset()));
1059 
1060     return true;
1061 }
1062 
1063 bool Graph::watchConditions(const ObjectPropertyConditionSet&amp; keys)
1064 {
1065     if (!keys.isValid())
1066         return false;
1067 
1068     for (const ObjectPropertyCondition&amp; key : keys) {
1069         if (!watchCondition(key))
1070             return false;
1071     }
1072     return true;
1073 }
1074 
1075 bool Graph::isSafeToLoad(JSObject* base, PropertyOffset offset)
1076 {
1077     return m_safeToLoad.contains(std::make_pair(base, offset));
1078 }
1079 
1080 bool Graph::watchGlobalProperty(JSGlobalObject* globalObject, unsigned identifierNumber)
1081 {
1082     UniquedStringImpl* uid = identifiers()[identifierNumber];
1083     // If we already have a WatchpointSet, and it is already invalidated, it means that this scope operation must be changed from GlobalProperty to GlobalLexicalVar,
1084     // but we still have stale metadata here since we have not yet executed this bytecode operation since the invalidation. Just emitting ForceOSRExit to update the
1085     // metadata when it reaches to this code.
1086     if (auto* watchpoint = globalObject-&gt;getReferencedPropertyWatchpointSet(uid)) {
1087         if (!watchpoint-&gt;isStillValid())
1088             return false;
1089     }
1090     globalProperties().addLazily(DesiredGlobalProperty(globalObject, identifierNumber));
1091     return true;
1092 }
1093 
1094 FullBytecodeLiveness&amp; Graph::livenessFor(CodeBlock* codeBlock)
1095 {
1096     HashMap&lt;CodeBlock*, std::unique_ptr&lt;FullBytecodeLiveness&gt;&gt;::iterator iter = m_bytecodeLiveness.find(codeBlock);
1097     if (iter != m_bytecodeLiveness.end())
1098         return *iter-&gt;value;
1099 
<a name="35" id="anc35"></a><span class="line-modified">1100     std::unique_ptr&lt;FullBytecodeLiveness&gt; liveness = makeUnique&lt;FullBytecodeLiveness&gt;();</span>
1101     codeBlock-&gt;livenessAnalysis().computeFullLiveness(codeBlock, *liveness);
1102     FullBytecodeLiveness&amp; result = *liveness;
1103     m_bytecodeLiveness.add(codeBlock, WTFMove(liveness));
1104     return result;
1105 }
1106 
1107 FullBytecodeLiveness&amp; Graph::livenessFor(InlineCallFrame* inlineCallFrame)
1108 {
1109     return livenessFor(baselineCodeBlockFor(inlineCallFrame));
1110 }
1111 
1112 BytecodeKills&amp; Graph::killsFor(CodeBlock* codeBlock)
1113 {
1114     HashMap&lt;CodeBlock*, std::unique_ptr&lt;BytecodeKills&gt;&gt;::iterator iter = m_bytecodeKills.find(codeBlock);
1115     if (iter != m_bytecodeKills.end())
1116         return *iter-&gt;value;
1117 
<a name="36" id="anc36"></a><span class="line-modified">1118     std::unique_ptr&lt;BytecodeKills&gt; kills = makeUnique&lt;BytecodeKills&gt;();</span>
1119     codeBlock-&gt;livenessAnalysis().computeKills(codeBlock, *kills);
1120     BytecodeKills&amp; result = *kills;
1121     m_bytecodeKills.add(codeBlock, WTFMove(kills));
1122     return result;
1123 }
1124 
1125 BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
1126 {
1127     return killsFor(baselineCodeBlockFor(inlineCallFrame));
1128 }
1129 
1130 bool Graph::isLiveInBytecode(VirtualRegister operand, CodeOrigin codeOrigin)
1131 {
1132     static const bool verbose = false;
1133 
1134     if (verbose)
1135         dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
1136     CodeOrigin* codeOriginPtr = &amp;codeOrigin;
1137     for (;;) {
1138         VirtualRegister reg = VirtualRegister(
1139             operand.offset() - codeOriginPtr-&gt;stackOffset());
1140 
1141         if (verbose)
1142             dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
1143 
<a name="37" id="anc37"></a><span class="line-added">1144         auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
1145         if (operand.offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {
1146             if (reg.isArgument()) {
1147                 RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
1148 
<a name="38" id="anc38"></a><span class="line-modified">1149 </span>
<span class="line-added">1150                 if (inlineCallFrame-&gt;isClosureCall</span>
1151                     &amp;&amp; reg.offset() == CallFrameSlot::callee) {
1152                     if (verbose)
1153                         dataLog(&quot;Looks like a callee.\n&quot;);
1154                     return true;
1155                 }
1156 
<a name="39" id="anc39"></a><span class="line-modified">1157                 if (inlineCallFrame-&gt;isVarargs()</span>
1158                     &amp;&amp; reg.offset() == CallFrameSlot::argumentCount) {
1159                     if (verbose)
1160                         dataLog(&quot;Looks like the argument count.\n&quot;);
1161                     return true;
1162                 }
1163 
1164                 return false;
1165             }
1166 
1167             if (verbose)
1168                 dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<a name="40" id="anc40"></a><span class="line-modified">1169             return livenessFor(inlineCallFrame).operandIsLive(reg.offset(), codeOriginPtr-&gt;bytecodeIndex());</span>

1170         }
1171 
<a name="41" id="anc41"></a>
1172         if (!inlineCallFrame) {
1173             if (verbose)
1174                 dataLog(&quot;Ran out of stack, returning true.\n&quot;);
1175             return true;
1176         }
1177 
1178         // Arguments are always live. This would be redundant if it wasn&#39;t for our
1179         // op_call_varargs inlining.
1180         if (reg.isArgument()
1181             &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
1182             if (verbose)
1183                 dataLog(&quot;Argument is live.\n&quot;);
1184             return true;
1185         }
1186 
<a name="42" id="anc42"></a><span class="line-modified">1187         // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-modified">1188         // the return bytecode following the tail call.</span>
<span class="line-modified">1189         codeOriginPtr = &amp;inlineCallFrame-&gt;directCaller;</span>





1190     }
1191 
1192     RELEASE_ASSERT_NOT_REACHED();
1193 }
1194 
1195 BitVector Graph::localsLiveInBytecode(CodeOrigin codeOrigin)
1196 {
1197     BitVector result;
1198     result.ensureSize(block(0)-&gt;variablesAtHead.numberOfLocals());
1199     forAllLocalsLiveInBytecode(
1200         codeOrigin,
1201         [&amp;] (VirtualRegister reg) {
1202             ASSERT(reg.isLocal());
1203             result.quickSet(reg.toLocal());
1204         });
1205     return result;
1206 }
1207 
1208 unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
1209 {
1210     size_t frameSize = CallFrame::headerSizeInRegisters + argCount;
1211     size_t alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
1212     return alignedFrameSize - CallerFrameAndPC::sizeInRegisters;
1213 }
1214 
1215 unsigned Graph::frameRegisterCount()
1216 {
1217     unsigned result = m_nextMachineLocal + std::max(m_parameterSlots, static_cast&lt;unsigned&gt;(maxFrameExtentForSlowPathCallInRegisters));
1218     return roundLocalRegisterCountForFramePointerOffset(result);
1219 }
1220 
1221 unsigned Graph::stackPointerOffset()
1222 {
1223     return virtualRegisterForLocal(frameRegisterCount() - 1).offset();
1224 }
1225 
1226 unsigned Graph::requiredRegisterCountForExit()
1227 {
1228     unsigned count = JIT::frameRegisterCountFor(m_profiledBlock);
1229     for (InlineCallFrameSet::iterator iter = m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
1230         InlineCallFrame* inlineCallFrame = *iter;
1231         CodeBlock* codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
1232         unsigned requiredCount = VirtualRegister(inlineCallFrame-&gt;stackOffset).toLocal() + 1 + JIT::frameRegisterCountFor(codeBlock);
1233         count = std::max(count, requiredCount);
1234     }
1235     return count;
1236 }
1237 
1238 unsigned Graph::requiredRegisterCountForExecutionAndExit()
1239 {
1240     // FIXME: We should make sure that frameRegisterCount() and requiredRegisterCountForExit()
1241     // never overflows. https://bugs.webkit.org/show_bug.cgi?id=173852
1242     return std::max(frameRegisterCount(), requiredRegisterCountForExit());
1243 }
1244 
1245 JSValue Graph::tryGetConstantProperty(
1246     JSValue base, const RegisteredStructureSet&amp; structureSet, PropertyOffset offset)
1247 {
1248     if (!base || !base.isObject())
1249         return JSValue();
1250 
1251     JSObject* object = asObject(base);
1252 
1253     for (unsigned i = structureSet.size(); i--;) {
1254         RegisteredStructure structure = structureSet[i];
1255 
1256         WatchpointSet* set = structure-&gt;propertyReplacementWatchpointSet(offset);
1257         if (!set || !set-&gt;isStillValid())
1258             return JSValue();
1259 
1260         ASSERT(structure-&gt;isValidOffset(offset));
1261         ASSERT(!structure-&gt;isUncacheableDictionary());
1262 
1263         watchpoints().addLazily(set);
1264     }
1265 
1266     // What follows may require some extra thought. We need this load to load a valid JSValue. If
1267     // our profiling makes sense and we&#39;re still on track to generate code that won&#39;t be
1268     // invalidated, then we have nothing to worry about. We do, however, have to worry about
1269     // loading - and then using - an invalid JSValue in the case that unbeknownst to us our code
1270     // is doomed.
1271     //
1272     // One argument in favor of this code is that it should definitely work because the butterfly
1273     // is always set before the structure. However, we don&#39;t currently have a fence between those
1274     // stores. It&#39;s not clear if this matters, however. We only shrink the propertyStorage while
1275     // holding the Structure&#39;s lock. So, for this to fail, you&#39;d need an access on a constant
1276     // object pointer such that the inline caches told us that the object had a structure that it
1277     // did not *yet* have, and then later,the object transitioned to that structure that the inline
1278     // caches had already seen. And then the processor reordered the stores. Seems unlikely and
1279     // difficult to test. I believe that this is worth revisiting but it isn&#39;t worth losing sleep
1280     // over. Filed:
1281     // https://bugs.webkit.org/show_bug.cgi?id=134641
1282     //
1283     // For now, we just do the minimal thing: defend against the structure right now being
1284     // incompatible with the getDirect we&#39;re trying to do. The easiest way to do that is to
1285     // determine if the structure belongs to the proven set.
1286 
1287     Structure* structure = object-&gt;structure(m_vm);
1288     if (!structureSet.toStructureSet().contains(structure))
1289         return JSValue();
1290 
1291     return object-&gt;getDirectConcurrently(structure, offset);
1292 }
1293 
1294 JSValue Graph::tryGetConstantProperty(JSValue base, Structure* structure, PropertyOffset offset)
1295 {
1296     return tryGetConstantProperty(base, RegisteredStructureSet(registerStructure(structure)), offset);
1297 }
1298 
1299 JSValue Graph::tryGetConstantProperty(
1300     JSValue base, const StructureAbstractValue&amp; structure, PropertyOffset offset)
1301 {
1302     if (structure.isInfinite()) {
1303         // FIXME: If we just converted the offset to a uid, we could do ObjectPropertyCondition
1304         // watching to constant-fold the property.
1305         // https://bugs.webkit.org/show_bug.cgi?id=147271
1306         return JSValue();
1307     }
1308 
1309     return tryGetConstantProperty(base, structure.set(), offset);
1310 }
1311 
1312 JSValue Graph::tryGetConstantProperty(const AbstractValue&amp; base, PropertyOffset offset)
1313 {
1314     return tryGetConstantProperty(base.m_value, base.m_structure, offset);
1315 }
1316 
1317 AbstractValue Graph::inferredValueForProperty(
1318     const AbstractValue&amp; base, PropertyOffset offset,
1319     StructureClobberState clobberState)
1320 {
1321     if (JSValue value = tryGetConstantProperty(base, offset)) {
1322         AbstractValue result;
1323         result.set(*this, *freeze(value), clobberState);
1324         return result;
1325     }
1326 
1327     return AbstractValue::heapTop();
1328 }
1329 
1330 JSValue Graph::tryGetConstantClosureVar(JSValue base, ScopeOffset offset)
1331 {
1332     // This has an awesome concurrency story. See comment for GetGlobalVar in ByteCodeParser.
1333 
1334     if (!base)
1335         return JSValue();
1336 
1337     JSLexicalEnvironment* activation = jsDynamicCast&lt;JSLexicalEnvironment*&gt;(m_vm, base);
1338     if (!activation)
1339         return JSValue();
1340 
1341     SymbolTable* symbolTable = activation-&gt;symbolTable();
1342     JSValue value;
1343     WatchpointSet* set;
1344     {
1345         ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
1346 
1347         SymbolTableEntry* entry = symbolTable-&gt;entryFor(locker, offset);
1348         if (!entry)
1349             return JSValue();
1350 
1351         set = entry-&gt;watchpointSet();
1352         if (!set)
1353             return JSValue();
1354 
1355         if (set-&gt;state() != IsWatched)
1356             return JSValue();
1357 
1358         ASSERT(entry-&gt;scopeOffset() == offset);
1359         value = activation-&gt;variableAt(offset).get();
1360         if (!value)
1361             return JSValue();
1362     }
1363 
1364     watchpoints().addLazily(set);
1365 
1366     return value;
1367 }
1368 
1369 JSValue Graph::tryGetConstantClosureVar(const AbstractValue&amp; value, ScopeOffset offset)
1370 {
1371     return tryGetConstantClosureVar(value.m_value, offset);
1372 }
1373 
1374 JSValue Graph::tryGetConstantClosureVar(Node* node, ScopeOffset offset)
1375 {
1376     if (!node-&gt;hasConstant())
1377         return JSValue();
1378     return tryGetConstantClosureVar(node-&gt;asJSValue(), offset);
1379 }
1380 
1381 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value)
1382 {
1383     if (!value)
1384         return nullptr;
1385     JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(m_vm, value);
1386     if (!view)
1387         return nullptr;
1388     if (!view-&gt;length())
1389         return nullptr;
1390     WTF::loadLoadFence();
1391     watchpoints().addLazily(view);
1392     return view;
1393 }
1394 
1395 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value, ArrayMode arrayMode)
1396 {
1397     if (arrayMode.type() != Array::AnyTypedArray &amp;&amp; arrayMode.typedArrayType() == NotTypedArray)
1398         return nullptr;
1399     return tryGetFoldableView(value);
1400 }
1401 
1402 void Graph::registerFrozenValues()
1403 {
1404     m_codeBlock-&gt;constants().shrink(0);
1405     m_codeBlock-&gt;constantsSourceCodeRepresentation().resize(0);
1406     for (FrozenValue* value : m_frozenValues) {
1407         if (!value-&gt;pointsToHeap())
1408             continue;
1409 
1410         ASSERT(value-&gt;structure());
1411         ASSERT(m_plan.weakReferences().contains(value-&gt;structure()));
1412 
1413         switch (value-&gt;strength()) {
1414         case WeakValue: {
1415             m_plan.weakReferences().addLazily(value-&gt;value().asCell());
1416             break;
1417         }
1418         case StrongValue: {
1419             unsigned constantIndex = m_codeBlock-&gt;addConstantLazily();
1420             // We already have a barrier on the code block.
1421             m_codeBlock-&gt;constants()[constantIndex].setWithoutWriteBarrier(value-&gt;value());
1422             break;
1423         } }
1424     }
1425     m_codeBlock-&gt;constants().shrinkToFit();
1426     m_codeBlock-&gt;constantsSourceCodeRepresentation().shrinkToFit();
1427 }
1428 
1429 void Graph::visitChildren(SlotVisitor&amp; visitor)
1430 {
1431     for (FrozenValue* value : m_frozenValues) {
1432         visitor.appendUnbarriered(value-&gt;value());
1433         visitor.appendUnbarriered(value-&gt;structure());
1434     }
1435 }
1436 
1437 FrozenValue* Graph::freeze(JSValue value)
1438 {
1439     if (UNLIKELY(!value))
1440         return FrozenValue::emptySingleton();
1441 
1442     // There are weird relationships in how optimized CodeBlocks
1443     // point to other CodeBlocks. We don&#39;t want to have them be
1444     // part of the weak pointer set. For example, an optimized CodeBlock
1445     // having a weak pointer to itself will cause it to get collected.
1446     RELEASE_ASSERT(!jsDynamicCast&lt;CodeBlock*&gt;(m_vm, value));
1447 
1448     auto result = m_frozenValueMap.add(JSValue::encode(value), nullptr);
1449     if (LIKELY(!result.isNewEntry))
1450         return result.iterator-&gt;value;
1451 
1452     if (value.isUInt32())
1453         m_uint32ValuesInUse.append(value.asUInt32());
1454 
1455     FrozenValue frozenValue = FrozenValue::freeze(value);
1456     if (Structure* structure = frozenValue.structure())
1457         registerStructure(structure);
1458 
1459     return result.iterator-&gt;value = m_frozenValues.add(frozenValue);
1460 }
1461 
1462 FrozenValue* Graph::freezeStrong(JSValue value)
1463 {
1464     FrozenValue* result = freeze(value);
1465     result-&gt;strengthenTo(StrongValue);
1466     return result;
1467 }
1468 
1469 void Graph::convertToConstant(Node* node, FrozenValue* value)
1470 {
1471     if (value-&gt;structure())
1472         assertIsRegistered(value-&gt;structure());
1473     node-&gt;convertToConstant(value);
1474 }
1475 
1476 void Graph::convertToConstant(Node* node, JSValue value)
1477 {
1478     convertToConstant(node, freeze(value));
1479 }
1480 
1481 void Graph::convertToStrongConstant(Node* node, JSValue value)
1482 {
1483     convertToConstant(node, freezeStrong(value));
1484 }
1485 
1486 RegisteredStructure Graph::registerStructure(Structure* structure, StructureRegistrationResult&amp; result)
1487 {
1488     m_plan.weakReferences().addLazily(structure);
1489     if (m_plan.watchpoints().consider(structure))
1490         result = StructureRegisteredAndWatched;
1491     else
1492         result = StructureRegisteredNormally;
1493     return RegisteredStructure::createPrivate(structure);
1494 }
1495 
1496 void Graph::registerAndWatchStructureTransition(Structure* structure)
1497 {
1498     m_plan.weakReferences().addLazily(structure);
1499     m_plan.watchpoints().addLazily(structure-&gt;transitionWatchpointSet());
1500 }
1501 
1502 void Graph::assertIsRegistered(Structure* structure)
1503 {
1504     // It&#39;s convenient to be able to call this with a maybe-null structure.
1505     if (!structure)
1506         return;
1507 
1508     DFG_ASSERT(*this, nullptr, m_plan.weakReferences().contains(structure));
1509 
1510     if (!structure-&gt;dfgShouldWatch())
1511         return;
1512     if (watchpoints().isWatched(structure-&gt;transitionWatchpointSet()))
1513         return;
1514 
1515     DFG_CRASH(*this, nullptr, toCString(&quot;Structure &quot;, pointerDump(structure), &quot; is watchable but isn&#39;t being watched.&quot;).data());
1516 }
1517 
1518 static void logDFGAssertionFailure(
1519     Graph&amp; graph, const CString&amp; whileText, const char* file, int line, const char* function,
1520     const char* assertion)
1521 {
1522     startCrashing();
1523     dataLog(&quot;DFG ASSERTION FAILED: &quot;, assertion, &quot;\n&quot;);
1524     dataLog(file, &quot;(&quot;, line, &quot;) : &quot;, function, &quot;\n&quot;);
1525     dataLog(&quot;\n&quot;);
1526     dataLog(whileText);
1527     dataLog(&quot;Graph at time of failure:\n&quot;);
1528     graph.dump();
1529     dataLog(&quot;\n&quot;);
1530     dataLog(&quot;DFG ASSERTION FAILED: &quot;, assertion, &quot;\n&quot;);
1531     dataLog(file, &quot;(&quot;, line, &quot;) : &quot;, function, &quot;\n&quot;);
1532 }
1533 
1534 void Graph::logAssertionFailure(
1535     std::nullptr_t, const char* file, int line, const char* function, const char* assertion)
1536 {
1537     logDFGAssertionFailure(*this, &quot;&quot;, file, line, function, assertion);
1538 }
1539 
1540 void Graph::logAssertionFailure(
1541     Node* node, const char* file, int line, const char* function, const char* assertion)
1542 {
1543     logDFGAssertionFailure(*this, toCString(&quot;While handling node &quot;, node, &quot;\n\n&quot;), file, line, function, assertion);
1544 }
1545 
1546 void Graph::logAssertionFailure(
1547     BasicBlock* block, const char* file, int line, const char* function, const char* assertion)
1548 {
1549     logDFGAssertionFailure(*this, toCString(&quot;While handling block &quot;, pointerDump(block), &quot;\n\n&quot;), file, line, function, assertion);
1550 }
1551 
1552 CPSCFG&amp; Graph::ensureCPSCFG()
1553 {
1554     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1555     if (!m_cpsCFG)
<a name="43" id="anc43"></a><span class="line-modified">1556         m_cpsCFG = makeUnique&lt;CPSCFG&gt;(*this);</span>
1557     return *m_cpsCFG;
1558 }
1559 
1560 CPSDominators&amp; Graph::ensureCPSDominators()
1561 {
1562     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1563     if (!m_cpsDominators)
<a name="44" id="anc44"></a><span class="line-modified">1564         m_cpsDominators = makeUnique&lt;CPSDominators&gt;(*this);</span>
1565     return *m_cpsDominators;
1566 }
1567 
1568 SSADominators&amp; Graph::ensureSSADominators()
1569 {
1570     RELEASE_ASSERT(m_form == SSA || m_isInSSAConversion);
1571     if (!m_ssaDominators)
<a name="45" id="anc45"></a><span class="line-modified">1572         m_ssaDominators = makeUnique&lt;SSADominators&gt;(*this);</span>
1573     return *m_ssaDominators;
1574 }
1575 
1576 CPSNaturalLoops&amp; Graph::ensureCPSNaturalLoops()
1577 {
1578     RELEASE_ASSERT(m_form != SSA &amp;&amp; !m_isInSSAConversion);
1579     ensureCPSDominators();
1580     if (!m_cpsNaturalLoops)
<a name="46" id="anc46"></a><span class="line-modified">1581         m_cpsNaturalLoops = makeUnique&lt;CPSNaturalLoops&gt;(*this);</span>
1582     return *m_cpsNaturalLoops;
1583 }
1584 
1585 SSANaturalLoops&amp; Graph::ensureSSANaturalLoops()
1586 {
1587     RELEASE_ASSERT(m_form == SSA);
1588     ensureSSADominators();
1589     if (!m_ssaNaturalLoops)
<a name="47" id="anc47"></a><span class="line-modified">1590         m_ssaNaturalLoops = makeUnique&lt;SSANaturalLoops&gt;(*this);</span>
1591     return *m_ssaNaturalLoops;
1592 }
1593 
1594 BackwardsCFG&amp; Graph::ensureBackwardsCFG()
1595 {
1596     // We could easily relax this in the future to work over CPS, but today, it&#39;s only used in SSA.
1597     RELEASE_ASSERT(m_form == SSA);
1598     if (!m_backwardsCFG)
<a name="48" id="anc48"></a><span class="line-modified">1599         m_backwardsCFG = makeUnique&lt;BackwardsCFG&gt;(*this);</span>
1600     return *m_backwardsCFG;
1601 }
1602 
1603 BackwardsDominators&amp; Graph::ensureBackwardsDominators()
1604 {
1605     RELEASE_ASSERT(m_form == SSA);
1606     if (!m_backwardsDominators)
<a name="49" id="anc49"></a><span class="line-modified">1607         m_backwardsDominators = makeUnique&lt;BackwardsDominators&gt;(*this);</span>
1608     return *m_backwardsDominators;
1609 }
1610 
1611 ControlEquivalenceAnalysis&amp; Graph::ensureControlEquivalenceAnalysis()
1612 {
1613     RELEASE_ASSERT(m_form == SSA);
1614     if (!m_controlEquivalenceAnalysis)
<a name="50" id="anc50"></a><span class="line-modified">1615         m_controlEquivalenceAnalysis = makeUnique&lt;ControlEquivalenceAnalysis&gt;(*this);</span>
1616     return *m_controlEquivalenceAnalysis;
1617 }
1618 
1619 MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
1620 {
1621     // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
1622 
1623     for (Node* node = operandNode; node;) {
1624         // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
1625         if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
1626             CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
1627 
1628             if (node-&gt;accessesStack(*this)) {
1629                 if (m_form != SSA &amp;&amp; node-&gt;local().isArgument()) {
1630                     int argument = node-&gt;local().toArgument();
1631                     Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];
<a name="51" id="anc51"></a><span class="line-modified">1632                     // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
1633                     // https://bugs.webkit.org/show_bug.cgi?id=175841
1634                     if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData())
1635                         return &amp;profiledBlock-&gt;valueProfileForArgument(argument);
1636                 }
1637 
1638                 if (node-&gt;op() == GetLocal) {
1639                     return MethodOfGettingAValueProfile::fromLazyOperand(
1640                         profiledBlock,
1641                         LazyOperandValueProfileKey(
<a name="52" id="anc52"></a><span class="line-modified">1642                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;local()));</span>
1643                 }
1644             }
1645 
1646             if (node-&gt;hasHeapPrediction())
<a name="53" id="anc53"></a><span class="line-modified">1647                 return &amp;profiledBlock-&gt;valueProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex());</span>
1648 
1649             if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<a name="54" id="anc54"></a><span class="line-modified">1650                 if (ArithProfile* result = profiledBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex()))</span>
1651                     return result;
1652             }
1653         }
1654 
1655         switch (node-&gt;op()) {
1656         case BooleanToNumber:
1657         case Identity:
1658         case ValueRep:
1659         case DoubleRep:
1660         case Int52Rep:
1661             node = node-&gt;child1().node();
1662             break;
1663         default:
1664             node = nullptr;
1665         }
1666     }
1667 
1668     return MethodOfGettingAValueProfile();
1669 }
1670 
1671 bool Graph::getRegExpPrototypeProperty(JSObject* regExpPrototype, Structure* regExpPrototypeStructure, UniquedStringImpl* uid, JSValue&amp; returnJSValue)
1672 {
1673     unsigned attributesUnused;
1674     PropertyOffset offset = regExpPrototypeStructure-&gt;getConcurrently(uid, attributesUnused);
1675     if (!isValidOffset(offset))
1676         return false;
1677 
1678     JSValue value = tryGetConstantProperty(regExpPrototype, regExpPrototypeStructure, offset);
1679     if (!value)
1680         return false;
1681 
1682     // We only care about functions and getters at this point. If you want to access other properties
1683     // you&#39;ll have to add code for those types.
1684     JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
1685     if (!function) {
1686         GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, value);
1687 
1688         if (!getterSetter)
1689             return false;
1690 
1691         returnJSValue = JSValue(getterSetter);
1692         return true;
1693     }
1694 
1695     returnJSValue = value;
1696     return true;
1697 }
1698 
1699 bool Graph::isStringPrototypeMethodSane(JSGlobalObject* globalObject, UniquedStringImpl* uid)
1700 {
1701     ObjectPropertyConditionSet conditions = generateConditionsForPrototypeEquivalenceConcurrently(m_vm, globalObject, globalObject-&gt;stringObjectStructure(), globalObject-&gt;stringPrototype(), uid);
1702 
1703     if (!conditions.isValid())
1704         return false;
1705 
1706     ObjectPropertyCondition equivalenceCondition = conditions.slotBaseCondition();
1707     RELEASE_ASSERT(equivalenceCondition.hasRequiredValue());
1708     JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, equivalenceCondition.condition().requiredValue());
1709     if (!function)
1710         return false;
1711 
1712     if (function-&gt;executable()-&gt;intrinsicFor(CodeForCall) != StringPrototypeValueOfIntrinsic)
1713         return false;
1714 
1715     return watchConditions(conditions);
1716 }
1717 
1718 
1719 bool Graph::canOptimizeStringObjectAccess(const CodeOrigin&amp; codeOrigin)
1720 {
1721     if (hasExitSite(codeOrigin, BadCache) || hasExitSite(codeOrigin, BadConstantCache))
1722         return false;
1723 
1724     JSGlobalObject* globalObject = globalObjectFor(codeOrigin);
1725     Structure* stringObjectStructure = globalObjectFor(codeOrigin)-&gt;stringObjectStructure();
1726     registerStructure(stringObjectStructure);
1727     ASSERT(stringObjectStructure-&gt;storedPrototype().isObject());
<a name="55" id="anc55"></a><span class="line-modified">1728     ASSERT(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;classInfo(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;vm()) == StringPrototype::info());</span>
1729 
1730     if (!watchConditions(generateConditionsForPropertyMissConcurrently(m_vm, globalObject, stringObjectStructure, m_vm.propertyNames-&gt;toPrimitiveSymbol.impl())))
1731         return false;
1732 
1733     // We&#39;re being conservative here. We want DFG&#39;s ToString on StringObject to be
1734     // used in both numeric contexts (that would call valueOf()) and string contexts
1735     // (that would call toString()). We don&#39;t want the DFG to have to distinguish
1736     // between the two, just because that seems like it would get confusing. So we
1737     // just require both methods to be sane.
1738     if (!isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;valueOf.impl()))
1739         return false;
1740     return isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;toString.impl());
1741 }
1742 
1743 bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
1744 {
1745     if (!m_hasExceptionHandlers)
1746         return false;
1747 
<a name="56" id="anc56"></a><span class="line-modified">1748     unsigned bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
1749     while (1) {
<a name="57" id="anc57"></a><span class="line-modified">1750         InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();</span>
1751         CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
1752         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {
1753             opCatchOriginOut = CodeOrigin(handler-&gt;target, inlineCallFrame);
1754             catchHandlerOut = handler;
1755             return true;
1756         }
1757 
1758         if (!inlineCallFrame)
1759             return false;
1760 
<a name="58" id="anc58"></a><span class="line-modified">1761         bytecodeIndexToCheck = inlineCallFrame-&gt;directCaller.bytecodeIndex();</span>
<span class="line-modified">1762         codeOrigin = inlineCallFrame-&gt;directCaller;</span>
1763     }
1764 
1765     RELEASE_ASSERT_NOT_REACHED();
1766 }
1767 
1768 bool Graph::canDoFastSpread(Node* node, const AbstractValue&amp; value)
1769 {
1770     // The parameter &#39;value&#39; is the AbstractValue for child1 (the thing being spread).
1771     ASSERT(node-&gt;op() == Spread);
1772 
1773     if (node-&gt;child1().useKind() != ArrayUse) {
1774         // Note: we only speculate on ArrayUse when we&#39;ve set up the necessary watchpoints
1775         // to prove that the iteration protocol is non-observable starting from ArrayPrototype.
1776         return false;
1777     }
1778 
1779     // FIXME: We should add profiling of the incoming operand to Spread
1780     // so we can speculate in such a way that we guarantee that this
1781     // function would return true:
1782     // https://bugs.webkit.org/show_bug.cgi?id=171198
1783 
1784     if (!value.m_structure.isFinite())
1785         return false;
1786 
1787     ArrayPrototype* arrayPrototype = globalObjectFor(node-&gt;child1()-&gt;origin.semantic)-&gt;arrayPrototype();
1788     bool allGood = true;
1789     value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
1790         allGood &amp;= structure-&gt;hasMonoProto()
1791             &amp;&amp; structure-&gt;storedPrototype() == arrayPrototype
1792             &amp;&amp; !structure-&gt;isDictionary()
1793             &amp;&amp; structure-&gt;getConcurrently(m_vm.propertyNames-&gt;iteratorSymbol.impl()) == invalidOffset
1794             &amp;&amp; !structure-&gt;mayInterceptIndexedAccesses();
1795     });
1796 
1797     return allGood;
1798 }
1799 
1800 void Graph::clearCPSCFGData()
1801 {
1802     m_cpsNaturalLoops = nullptr;
1803     m_cpsDominators = nullptr;
1804     m_cpsCFG = nullptr;
1805 }
1806 
<a name="59" id="anc59"></a><span class="line-added">1807 void Prefix::dump(PrintStream&amp; out) const</span>
<span class="line-added">1808 {</span>
<span class="line-added">1809     if (!m_enabled)</span>
<span class="line-added">1810         return;</span>
<span class="line-added">1811 </span>
<span class="line-added">1812     if (!noHeader) {</span>
<span class="line-added">1813         if (nodeIndex &gt;= 0)</span>
<span class="line-added">1814             out.printf(&quot;%3d &quot;, nodeIndex);</span>
<span class="line-added">1815         else</span>
<span class="line-added">1816             out.printf(&quot;    &quot;);</span>
<span class="line-added">1817 </span>
<span class="line-added">1818         if (blockIndex &gt;= 0)</span>
<span class="line-added">1819             out.printf(&quot;%2d &quot;, blockIndex);</span>
<span class="line-added">1820         else</span>
<span class="line-added">1821             out.printf(&quot;   &quot;);</span>
<span class="line-added">1822 </span>
<span class="line-added">1823         if (phaseNumber &gt;= 0)</span>
<span class="line-added">1824             out.printf(&quot;%2d: &quot;, phaseNumber);</span>
<span class="line-added">1825         else</span>
<span class="line-added">1826             out.printf(&quot;  : &quot;);</span>
<span class="line-added">1827     }</span>
<span class="line-added">1828     if (prefixStr)</span>
<span class="line-added">1829         out.printf(&quot;%s&quot;, prefixStr);</span>
<span class="line-added">1830 }</span>
<span class="line-added">1831 </span>
1832 } } // namespace JSC::DFG
1833 
1834 #endif // ENABLE(DFG_JIT)
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>