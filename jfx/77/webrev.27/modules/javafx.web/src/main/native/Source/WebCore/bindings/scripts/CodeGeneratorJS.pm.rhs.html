<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   6 # Copyright (C) 2006-2019 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
  27 # along with this library; see the file COPYING.LIB.  If not, write to
  28 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29 # Boston, MA 02110-1301, USA.
  30 
  31 
  32 package CodeGeneratorJS;
  33 
  34 use strict;
  35 use constant FileNamePrefix =&gt; &quot;JS&quot;;
  36 use Carp qw&lt;longmess&gt;;
  37 use Data::Dumper;
  38 use Hasher;
  39 
  40 my $codeGenerator;
  41 my $writeDependencies;
  42 
  43 my @headerContentHeader = ();
  44 my @headerContent = ();
  45 my %headerIncludes = ();
  46 my %headerTrailingIncludes = ();
  47 
  48 my @implContentHeader = ();
  49 my @implContent = ();
  50 my %implIncludes = ();
  51 my @depsContent = ();
  52 my $numCachedAttributes = 0;
  53 
  54 my $beginAppleCopyrightForHeaderFiles = &lt;&lt;END;
  55 // ------- Begin Apple Copyright -------
  56 /*
  57  * Copyright (C) 2008 Apple Inc. All rights reserved.
  58  *
  59  * Permission is granted by Apple to use this file to the extent
  60  * necessary to relink with LGPL WebKit files.
  61  *
  62  * No license or rights are granted by Apple expressly or by
  63  * implication, estoppel, or otherwise, to Apple patents and
  64  * trademarks. For the sake of clarity, no license or rights are
  65  * granted by Apple expressly or by implication, estoppel, or otherwise,
  66  * under any Apple patents, copyrights and trademarks to underlying
  67  * implementations of any application programming interfaces (APIs)
  68  * or to any functionality that is invoked by calling any API.
  69  */
  70 
  71 END
  72 my $beginAppleCopyrightForSourceFiles = &lt;&lt;END;
  73 // ------- Begin Apple Copyright -------
  74 /*
  75  * Copyright (C) 2008 Apple Inc. All rights reserved.
  76  *
  77  * No license or rights are granted by Apple expressly or by implication,
  78  * estoppel, or otherwise, to Apple copyrights, patents, trademarks, trade
  79  * secrets or other rights.
  80  */
  81 
  82 END
  83 my $endAppleCopyright   = &lt;&lt;END;
  84 // ------- End Apple Copyright   -------
  85 
  86 END
  87 
  88 # Default .h template
  89 my $headerTemplate = &lt;&lt; &quot;EOF&quot;;
  90 /*
  91     This file is part of the WebKit open source project.
  92     This file has been generated by generate-bindings.pl. DO NOT MODIFY!
  93 
  94     This library is free software; you can redistribute it and/or
  95     modify it under the terms of the GNU Library General Public
  96     License as published by the Free Software Foundation; either
  97     version 2 of the License, or (at your option) any later version.
  98 
  99     This library is distributed in the hope that it will be useful,
 100     but WITHOUT ANY WARRANTY; without even the implied warranty of
 101     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 102     Library General Public License for more details.
 103 
 104     You should have received a copy of the GNU Library General Public License
 105     along with this library; see the file COPYING.LIB.  If not, write to
 106     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 107     Boston, MA 02110-1301, USA.
 108 */
 109 EOF
 110 
 111 sub assert
 112 {
 113     my $message = shift;
 114 
 115     my $mess = longmess();
 116     print Dumper($mess);
 117 
 118     die $message;
 119 }
 120 
 121 # Default constructor
 122 sub new
 123 {
 124     my $object = shift;
 125     my $reference = { };
 126 
 127     $codeGenerator = shift;
 128     $writeDependencies = shift;
 129 
 130     bless($reference, $object);
 131     return $reference;
 132 }
 133 
 134 sub GenerateEnumeration
 135 {
 136     my ($object, $enumeration) = @_;
 137 
 138     my $className = GetEnumerationClassName($enumeration-&gt;type);
 139     $object-&gt;GenerateEnumerationHeader($enumeration, $className);
 140     $object-&gt;GenerateEnumerationImplementation($enumeration, $className);
 141 }
 142 
 143 sub GenerateDictionary
 144 {
 145     my ($object, $dictionary, $enumerations, $otherDictionaries) = @_;
 146 
 147     my $className = GetDictionaryClassName($dictionary-&gt;type);
 148     $object-&gt;GenerateDictionaryHeader($dictionary, $className, $enumerations, $otherDictionaries);
 149     $object-&gt;GenerateDictionaryImplementation($dictionary, $className, $enumerations, $otherDictionaries);
 150 }
 151 
 152 sub GenerateCallbackFunction
 153 {
 154     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
 155 
 156     $object-&gt;GenerateCallbackFunctionHeader($callbackFunction, $enumerations, $dictionaries);
 157     $object-&gt;GenerateCallbackFunctionImplementation($callbackFunction, $enumerations, $dictionaries);
 158 }
 159 
 160 sub GenerateInterface
 161 {
 162     my ($object, $interface, $defines, $enumerations, $dictionaries) = @_;
 163 
 164     $codeGenerator-&gt;LinkOverloadedOperations($interface);
 165 
 166     AddStringifierOperationIfNeeded($interface);
 167     AddLegacyCallerOperationIfNeeded($interface);
 168 
 169     if ($interface-&gt;isCallback) {
 170         $object-&gt;GenerateCallbackInterfaceHeader($interface, $enumerations, $dictionaries);
 171         $object-&gt;GenerateCallbackInterfaceImplementation($interface, $enumerations, $dictionaries);
 172     } else {
 173         $object-&gt;GenerateHeader($interface, $enumerations, $dictionaries);
 174         $object-&gt;GenerateImplementation($interface, $enumerations, $dictionaries);
 175     }
 176 }
 177 
 178 sub AddStringifierOperationIfNeeded
 179 {
 180     my $interface = shift;
 181 
 182     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 183         next unless $property-&gt;isStringifier;
 184 
 185         if (ref($property) eq &quot;IDLAttribute&quot;) {
 186             assert(&quot;stringifier can only be used on attributes with type DOMString or USVString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot; || $property-&gt;type-&gt;name eq &quot;USVString&quot;;
 187         }
 188 
 189         if (ref($property) eq &quot;IDLOperation&quot;) {
 190             assert(&quot;stringifier can only be used on operations with a return type of DOMString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot;;
 191             assert(&quot;stringifier can only be used on operations with zero arguments&quot;) unless scalar(@{$property-&gt;arguments}) == 0;
 192 
 193             # Don&#39;t duplicate the operation if it was declared with the name &#39;toString&#39;.
 194             return if $property-&gt;name eq &quot;toString&quot;;
 195         }
 196 
 197         my $stringifier = IDLOperation-&gt;new();
 198         $stringifier-&gt;name(&quot;toString&quot;);
 199         $stringifier-&gt;type(IDLParser::cloneType($property-&gt;type));
 200         $stringifier-&gt;isStringifier(1);
 201 
 202         IDLParser::copyExtendedAttributes($stringifier-&gt;extendedAttributes, $property-&gt;extendedAttributes);
 203 
 204         if ($property-&gt;name &amp;&amp; !$stringifier-&gt;extendedAttributes-&gt;{ImplementedAs}) {
 205             $stringifier-&gt;extendedAttributes-&gt;{ImplementedAs} = $property-&gt;name;
 206         }
 207 
 208         # If the stringifier was declared as read-write attribute and had [CEReactions], we need to remove
 209         # it from the operation, as the operation should act like attribute getter, which doesn&#39;t respect
 210         # [CEReactions].
 211         if (ref($property) eq &quot;IDLAttribute&quot; &amp;&amp; !$property-&gt;isReadOnly &amp;&amp; $stringifier-&gt;extendedAttributes-&gt;{CEReactions}) {
 212              delete $stringifier-&gt;extendedAttributes-&gt;{CEReactions};
 213         }
 214 
 215         push(@{$interface-&gt;operations}, $stringifier);
 216         return;
 217     }
 218 }
 219 
 220 sub AddLegacyCallerOperationIfNeeded
 221 {
 222     my $interface = shift;
 223 
 224     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 225         my $isLegacyCaller = grep { $_ eq &quot;legacycaller&quot; } @{$operation-&gt;specials};
 226         if ($isLegacyCaller) {
 227             $interface-&gt;{LegacyCallers} = [] if !exists $interface-&gt;{LegacyCallers};
 228 
 229             my $clonedOperation = IDLParser::cloneOperation($operation);
 230             push(@{$interface-&gt;{LegacyCallers}}, $clonedOperation);
 231     
 232             $clonedOperation-&gt;{overloads} = $interface-&gt;{LegacyCallers};
 233             $clonedOperation-&gt;{overloadIndex} = @{$interface-&gt;{LegacyCallers}};
 234         }
 235     }
 236 }
 237 
 238 sub EventHandlerAttributeEventName
 239 {
 240     my $attribute = shift;
 241     my $eventType = $attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name;
 242 
 243     # Remove the &quot;on&quot; prefix.
 244     $eventType = substr($eventType, 2);
 245 
 246     return &quot;eventNames().${eventType}Event&quot;;
 247 }
 248 
 249 sub GetParentClassName
 250 {
 251     my $interface = shift;
 252 
 253     return $interface-&gt;extendedAttributes-&gt;{JSLegacyParent} if $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
 254     return &quot;JSDOMObject&quot; unless NeedsImplementationClass($interface);
 255     return &quot;JSDOMWrapper&lt;&quot; . GetImplClassName($interface) . &quot;&gt;&quot; unless $interface-&gt;parentType;
 256     return &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
 257 }
 258 
 259 sub GetCallbackClassName
 260 {
 261     my $className = shift;
 262 
 263     return &quot;JS$className&quot;;
 264 }
 265 
 266 sub GetExportMacroForJSClass
 267 {
 268     my $interface = shift;
 269 
 270     return $interface-&gt;extendedAttributes-&gt;{ExportMacro} . &quot; &quot; if $interface-&gt;extendedAttributes-&gt;{ExportMacro};
 271     return &quot;&quot;;
 272 }
 273 
 274 sub AddIncludesForImplementationTypeInImpl
 275 {
 276     my $implementationType = shift;
 277     
 278     AddIncludesForImplementationType($implementationType, \%implIncludes);
 279 }
 280 
 281 sub AddIncludesForImplementationTypeInHeader
 282 {
 283     my $implementationType = shift;
 284     
 285     AddIncludesForImplementationType($implementationType, \%headerIncludes);
 286 }
 287 
 288 sub AddIncludesForImplementationType
 289 {
 290     my ($implementationType, $includesRef) = @_;
 291 
 292     $includesRef-&gt;{&quot;${implementationType}.h&quot;} = 1;
 293 }
 294 
 295 sub AddToImplIncludesForIDLType
 296 {
 297     my ($type, $conditional) = @_;
 298 
 299     return AddToIncludesForIDLType($type, \%implIncludes, $conditional)
 300 }
 301 
 302 sub AddToIncludesForIDLType
 303 {
 304     my ($type, $includesRef, $conditional) = @_;
 305 
 306     if ($type-&gt;isNullable) {
 307         AddToIncludes(&quot;JSDOMConvertNullable.h&quot;, $includesRef, $conditional);
 308     }
 309 
 310     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
 311         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
 312         if ($overrideTypeName eq &quot;IDLIDBKey&quot;) {
 313             AddToIncludes(&quot;JSDOMConvertIndexedDB.h&quot;, $includesRef, $conditional);
 314             return;
 315         }
 316 
 317         if ($overrideTypeName eq &quot;IDLWebGLAny&quot; || $overrideTypeName eq &quot;IDLWebGLExtension&quot;) {
 318             AddToIncludes(&quot;JSDOMConvertWebGL.h&quot;, $includesRef, $conditional);
 319             return;
 320         }
 321     }
 322 
 323     if ($type-&gt;name eq &quot;any&quot;) {
 324         AddToIncludes(&quot;JSDOMConvertAny.h&quot;, $includesRef, $conditional);
 325         return;
 326     }
 327 
 328     if ($type-&gt;name eq &quot;boolean&quot;) {
 329         AddToIncludes(&quot;JSDOMConvertBoolean.h&quot;, $includesRef, $conditional);
 330         return;
 331     }
 332 
 333     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
 334         AddToIncludes(&quot;JSDOMConvertBufferSource.h&quot;, $includesRef, $conditional);
 335         return;
 336     }
 337 
 338     if ($codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsCallbackInterface($type)) {
 339         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 340         AddToIncludes(&quot;JSDOMConvertCallbacks.h&quot;, $includesRef, $conditional);
 341         return;
 342     }
 343 
 344     if ($type-&gt;name eq &quot;Date&quot;) {
 345         AddToIncludes(&quot;JSDOMConvertDate.h&quot;, $includesRef, $conditional);
 346         return;
 347     }
 348 
 349     if ($codeGenerator-&gt;IsExternalDictionaryType($type)) {
 350         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 351         AddToIncludes(&quot;JSDOMConvertDictionary.h&quot;, $includesRef, $conditional);
 352         return;
 353     }
 354 
 355     if ($codeGenerator-&gt;IsExternalEnumType($type)) {
 356         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 357         AddToIncludes(&quot;JSDOMConvertEnumeration.h&quot;, $includesRef, $conditional);
 358         return;
 359     }
 360 
 361     if ($type-&gt;name eq &quot;EventListener&quot;) {
 362         AddToIncludes(&quot;JSEventListener.h&quot;, $includesRef, $conditional);
 363         AddToIncludes(&quot;JSDOMConvertEventListener.h&quot;, $includesRef, $conditional);
 364         return;
 365     }
 366 
 367     if ($codeGenerator-&gt;IsInterfaceType($type)) {
 368         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 369         AddToIncludes(&quot;JSDOMConvertInterface.h&quot;, $includesRef, $conditional);
 370         return;
 371     }
 372 
 373     if ($type-&gt;name eq &quot;JSON&quot;) {
 374         AddToIncludes(&quot;JSDOMConvertJSON.h&quot;, $includesRef, $conditional);
 375         return;
 376     }
 377 
 378     if ($codeGenerator-&gt;IsNumericType($type)) {
 379         AddToIncludes(&quot;JSDOMConvertNumbers.h&quot;, $includesRef, $conditional);
 380         return;
 381     }
 382 
 383     if ($type-&gt;name eq &quot;object&quot;) {
 384         AddToIncludes(&quot;JSDOMConvertObject.h&quot;, $includesRef, $conditional);
 385         return;
 386     }
 387 
 388     if ($codeGenerator-&gt;IsPromiseType($type)) {
 389         AddToIncludes(&quot;DOMPromiseProxy.h&quot;, $includesRef, $conditional);
 390         AddToIncludes(&quot;JSDOMConvertPromise.h&quot;, $includesRef, $conditional);
 391 
 392         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 393         return;
 394     }
 395 
 396     if ($codeGenerator-&gt;IsRecordType($type)) {
 397         AddToIncludes(&quot;&lt;wtf/Vector.h&gt;&quot;, $includesRef, $conditional);
 398         AddToIncludes(&quot;JSDOMConvertRecord.h&quot;, $includesRef, $conditional);
 399 
 400         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 401         AddToIncludesForIDLType(@{$type-&gt;subtypes}[1], $includesRef, $conditional);
 402         return;
 403     }
 404 
 405     if ($codeGenerator-&gt;IsSequenceOrFrozenArrayType($type)) {
 406         AddToIncludes(&quot;&lt;JavaScriptCore/JSArray.h&gt;&quot;, $includesRef, $conditional);
 407         AddToIncludes(&quot;JSDOMConvertSequences.h&quot;, $includesRef, $conditional);
 408 
 409         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 410         return;
 411     }
 412 
 413     if ($type-&gt;name eq &quot;ScheduledAction&quot;) {
 414         AddToIncludes(&quot;JSDOMConvertScheduledAction.h&quot;, $includesRef, $conditional);
 415         return;
 416     }
 417 
 418     if ($type-&gt;name eq &quot;SerializedScriptValue&quot;) {
 419         AddToIncludes(&quot;SerializedScriptValue.h&quot;, $includesRef, $conditional);
 420         AddToIncludes(&quot;JSDOMConvertSerializedScriptValue.h&quot;, $includesRef, $conditional);
 421         return;
 422     }
 423 
 424     if ($codeGenerator-&gt;IsStringType($type)) {
 425         AddToIncludes(&quot;JSDOMConvertStrings.h&quot;, $includesRef, $conditional);
 426         return;
 427     }
 428 
 429     if ($type-&gt;isUnion) {
 430         AddToIncludes(&quot;&lt;wtf/Variant.h&gt;&quot;, $includesRef, $conditional);
 431         AddToIncludes(&quot;JSDOMConvertUnion.h&quot;, $includesRef, $conditional);
 432 
 433         foreach my $memberType (@{$type-&gt;subtypes}) {
 434             AddToIncludesForIDLType($memberType, $includesRef, $conditional);
 435         }
 436 
 437         return;
 438     }
 439 
 440     if ($type-&gt;name eq &quot;XPathNSResolver&quot;) {
 441         AddToIncludes(&quot;JSXPathNSResolver.h&quot;, $includesRef, $conditional);
 442         AddToIncludes(&quot;JSDOMConvertXPathNSResolver.h&quot;, $includesRef, $conditional);
 443         return;
 444     }
 445 }
 446 
 447 sub AddToImplIncludes
 448 {
 449     my ($header, $conditional) = @_;
 450 
 451     AddToIncludes($header, \%implIncludes, $conditional);
 452 }
 453 
 454 sub AddToIncludes
 455 {
 456     my ($header, $includesRef, $conditional) = @_;
 457 
 458     if (not $conditional) {
 459         $includesRef-&gt;{$header} = 1;
 460     } elsif (not exists($includesRef-&gt;{$header})) {
 461         $includesRef-&gt;{$header} = $conditional;
 462     } else {
 463         my $oldValue = $includesRef-&gt;{$header};
 464         $includesRef-&gt;{$header} = &quot;$oldValue|$conditional&quot; if $oldValue ne 1;
 465     }
 466 }
 467 
 468 sub IsReadonly
 469 {
 470     my $attribute = shift;
 471     return $attribute-&gt;isReadOnly &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{Replaceable} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{PutForwards};
 472 }
 473 
 474 sub AddClassForwardIfNeeded
 475 {
 476     my $type = shift;
 477 
 478     # SVGAnimatedLength/Number/etc. are not classes so they can&#39;t be forward declared as classes.
 479     return if $codeGenerator-&gt;IsSVGAnimatedType($type);
 480     return if $codeGenerator-&gt;IsBufferSourceType($type);
 481 
 482     push(@headerContent, &quot;class &quot; . $type-&gt;name . &quot;;\n\n&quot;);
 483 }
 484 
 485 sub GetGenerateIsReachable
 486 {
 487     my $interface = shift;
 488     return $interface-&gt;extendedAttributes-&gt;{GenerateIsReachable};
 489 }
 490 
 491 sub GetCustomIsReachable
 492 {
 493     my $interface = shift;
 494     return $interface-&gt;extendedAttributes-&gt;{CustomIsReachable};
 495 }
 496 
 497 sub IsDOMGlobalObject
 498 {
 499     my $interface = shift;
 500     return $interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; || $interface-&gt;type-&gt;name eq &quot;RemoteDOMWindow&quot; || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;) || $interface-&gt;type-&gt;name eq &quot;TestGlobalObject&quot;;
 501 }
 502 
 503 sub ShouldUseGlobalObjectPrototype
 504 {
 505     my $interface = shift;
 506 
 507     # For workers, the global object is a DedicatedWorkerGlobalScope.
 508     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;;
 509     # For worklets, the global object is a PaintWorkletGlobalScope.
 510     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkletGlobalScope&quot;;
 511 
 512     return IsDOMGlobalObject($interface);
 513 }
 514 
 515 sub GenerateIndexedGetter
 516 {
 517     my ($interface, $indexedGetterOperation, $indexExpression) = @_;
 518     
 519     # NOTE: This abstractly implements steps 1.2.1 - 1.2.8 of the LegacyPlatformObjectGetOwnProperty
 520     #       algorithm. Returing the conversion expression and attributes expression for use
 521     #       by the caller.
 522     
 523     # 1.2.1 Let operation be the operation used to declare the indexed property getter.
 524     # 1.2.2 Let value be an uninitialized variable.
 525     # 1.2.3 If operation was defined without an identifier, then set value to the result
 526     #       of performing the steps listed in the interface description to determine the
 527     #       value of an indexed property with index as the index.
 528     # 1.2.4 Otherwise, operation was defined with an identifier. Set value to the result
 529     #       of performing the steps listed in the description of operation with index as
 530     #       the only argument value.
 531     # 1.2.5 Let desc be a newly created Property Descriptor with no fields.
 532     # 1.2.6 Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 533     # 1.2.7 If O implements an interface with an indexed property setter, then set
 534     #       desc.[[Writable]] to true, otherwise set it to false.
 535     # 1.2.8 Return desc.
 536     
 537     my @attributes = ();
 538     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetIndexedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 539     
 540     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 541 
 542     my $indexedGetterFunctionName = $indexedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $indexedGetterOperation-&gt;name || &quot;item&quot;;
 543     my $nativeToJSConversion = NativeToJSValueUsingPointers($indexedGetterOperation, $interface, &quot;thisObject-&gt;wrapped().${indexedGetterFunctionName}(${indexExpression})&quot;, &quot;*thisObject-&gt;globalObject()&quot;);
 544     
 545     return ($nativeToJSConversion, $attributeString);
 546 }
 547 
 548 sub GenerateNamedGetter
 549 {
 550     my ($interface, $namedGetterOperation, $namedPropertyExpression) = @_;
 551     
 552     # NOTE: This abstractly implements steps 2.1 - 2.10 of the LegacyPlatformObjectGetOwnProperty
 553     #       algorithm. Returing the conversion expression and attributes expression for use
 554     #       by the caller.
 555     
 556     # 2.1  Let operation be the operation used to declare the named property getter.
 557     # 2.2  Let value be an uninitialized variable.
 558     # 2.3  If operation was defined without an identifier, then set value to the result
 559     #      of performing the steps listed in the interface description to determine the
 560     #      value of a named property with P as the name.
 561     # 2.4  Otherwise, operation was defined with an identifier. Set value to the result
 562     #      of performing the steps listed in the description of operation with P as the
 563     #      only argument value..
 564     # 2.5  Let desc be a newly created Property Descriptor with no fields.
 565     # 2.6  Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 566     # 2.7  If O implements an interface with a named property setter, then set desc.[[Writable]]
 567     #      to true, otherwise set it to false.
 568     # 2.8  If O implements an interface with the [LegacyUnenumerableNamedProperties]
 569     #      extended attribute, then set desc.[[Enumerable]] to false, otherwise set it
 570     #      to true.
 571     # 2.9  Set desc.[[Configurable]] to true.
 572     # 2.10 Return desc.
 573     
 574     my @attributes = ();
 575     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetNamedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 576     push(@attributes, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties};
 577     
 578     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 579     my $nativeToJSConversion = NativeToJSValueUsingPointers($namedGetterOperation, $interface, $namedPropertyExpression, &quot;*thisObject-&gt;globalObject()&quot;);
 580     
 581     return ($nativeToJSConversion, $attributeString);
 582 }
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 603     push(@arguments, &quot;propertyNameToAtomString(propertyName)&quot;);</span>
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
<a name="2" id="anc2"></a><span class="line-modified"> 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
 731         $didGeneratePropertyName = 1;
 732     };
 733     
<a name="3" id="anc3"></a><span class="line-added"> 734     my $namedGetterOperation = GetNamedGetterOperation($interface);</span>
<span class="line-added"> 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);</span>
<span class="line-added"> 736     </span>
 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);
 738     push(@$outputArray, &quot;{\n&quot;);
<a name="4" id="anc4"></a><span class="line-added"> 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {</span>
<span class="line-added"> 740         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added"> 741     }</span>
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     
<a name="5" id="anc5"></a>


 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<a name="6" id="anc6"></a><span class="line-modified"> 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);</span>
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 767         
 768         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 769         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 770         
 771         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 772         push(@$outputArray, &quot;            return true;\n&quot;);
 773         
 774         push(@$outputArray, &quot;        }\n&quot;);
 775         
 776         # 1.3. Set ignoreNamedProps to true.
 777         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 778         #       rather than going through the paces of having an actual ignoreNamedProps update.
 779         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 780             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 781         }
 782         push(@$outputArray, &quot;    }\n&quot;);
 783     }
 784     
 785     # 2. If O supports named properties, the result of running the named property visibility
 786     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 787     if ($namedGetterOperation) {
 788         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 789         #       to true, due to the early return in step 1.3
 790         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 791                 
 792         &amp;$propertyNameGeneration();
 793         
 794         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 795         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 796         
 797         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 798         
 799         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 800         
 801         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 802         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 803         
 804         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 805         
 806         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 807 
 808         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 809         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 810         
 811         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 812         push(@$outputArray, &quot;        return true;\n&quot;);
 813         push(@$outputArray, &quot;    }\n&quot;);
 814     }
 815     
 816     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 817         &amp;$propertyNameGeneration();
 818 
 819         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 820         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);
 821         push(@$outputArray, &quot;        return true;\n&quot;);
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 841     push(@$outputArray, &quot;{\n&quot;);
<a name="7" id="anc7"></a><span class="line-added"> 842     if ($indexedGetterOperation || $namedGetterOperation) {</span>
<span class="line-added"> 843         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added"> 844     }</span>
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
<a name="8" id="anc8"></a><span class="line-modified"> 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);</span>
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);</span>
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
<a name="10" id="anc10"></a><span class="line-modified"> 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);</span>
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 887     
 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 889     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 890     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 891     
 892     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 893     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 894     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
 895     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);
 896     
 897     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 898 }
 899 
 900 # https://heycam.github.io/webidl/#invoke-named-setter
 901 sub GenerateInvokeNamedPropertySetter
 902 {
 903     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 904     
 905     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
 906     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 907     
 908     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
 909     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 910     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 911 
 912     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 913 
 914     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 915     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 916 
 917     my @arguments = ();
 918     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 919     push(@arguments, $nativeValuePassExpression);
 920     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 921 
 922     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
 923     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);
 924 
 925     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 926 }
 927 
 928 sub GeneratePut
 929 {
 930     my ($outputArray, $interface, $className) = @_;
 931     
 932     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 933     
 934     my $namedSetterOperation = GetNamedSetterOperation($interface);
 935     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 936     
 937     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);
 938     push(@$outputArray, &quot;{\n&quot;);
 939     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 940     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 941 
 942     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 943         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 944     if ($namedSetterOperation) {
 945         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
 946     }
 947     if ($indexedSetterOperation) {
 948         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
 949     }
 950     
 951     if ($indexedSetterOperation) {
 952         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 953         
 954         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 955         
 956         push(@$outputArray, &quot;        return true;\n&quot;);
 957         push(@$outputArray, &quot;    }\n\n&quot;);
 958     }
 959     
 960     if ($namedSetterOperation) {
 961         # FIMXE: We need a more comprehensive story for Symbols.
 962         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 963         
 964         my $additionalIndent = &quot;&quot;;
 965         
 966         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 967         if (!$overrideBuiltins) {
 968             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
 969             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);
 970             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
 971             $additionalIndent .= &quot;    &quot;;
 972         }
 973 
 974         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 975         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 976             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
 977             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 978         }
 979         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 980 
 981         if (!$overrideBuiltins) {
 982             push(@$outputArray, &quot;        }\n&quot;);
 983         }
 984         
 985         push(@$outputArray, &quot;    }\n\n&quot;);
 986     }
 987     
 988     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 989     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 990         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 991 
 992         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
 993         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
 994         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 995     }
 996 
 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1014     push(@$outputArray, &quot;{\n&quot;);
<a name="11" id="anc11"></a><span class="line-added">1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {</span>
<span class="line-added">1016         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added">1017     }</span>
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1025     }
1026     if ($indexedSetterOperation) {
1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1028     }
1029     
<a name="12" id="anc12"></a><span class="line-modified">1030     if ($indexedSetterOperation) {</span>
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
<a name="13" id="anc13"></a><span class="line-modified">1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<a name="14" id="anc14"></a><span class="line-modified">1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);</span>
1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<a name="15" id="anc15"></a><span class="line-modified">1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
1086         
1087         if (IsUnforgeable($interface, $property)) {
1088             push(@unforgeablePropertyNames, $property-&gt;name);
1089         }
1090     }
1091     
1092     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1093     
1094     my $condition = join(&quot; || &quot;, map { &quot;propertyName == \&quot;&quot; . $_ . &quot;\&quot;&quot; } @unforgeablePropertyNames);
1095     
1096     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1097     push(@$outputArray, &quot;{\n&quot;);
1098     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1099     push(@$outputArray, &quot;}\n\n&quot;);
1100     
1101     return 1;
1102 }
1103 
1104 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1105 sub GenerateDefineOwnProperty
1106 {
1107     my ($outputArray, $interface, $className) = @_;
1108     
1109     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1110     
1111     my $namedSetterOperation = GetNamedSetterOperation($interface);
1112     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1113     
1114     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1115     
1116     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, ExecState* state, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);
1117     push(@$outputArray, &quot;{\n&quot;);
1118     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1119     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1120 
1121     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1122         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1123     if ($namedSetterOperation) {
1124         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);
1125     }
1126     if ($indexedSetterOperation) {
1127         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);
1128     }
1129     
1130     # 1. If O supports indexed properties and P is an array index property name, then:
1131     if (GetIndexedGetterOperation($interface)) {
1132         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1133         # is no indexed property setter.
1134 
1135         if (!$indexedSetterOperation) {
1136             # 2. If O does not implement an interface with an indexed property setter, then return false.
1137             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1138             push(@$outputArray, &quot;        return false;\n\n&quot;);
1139         } else {
1140             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1141 
1142             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1143             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1144             push(@$outputArray, &quot;            return false;\n&quot;);
1145             
1146             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1147             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1148             
1149             # 4. Return true.
1150             push(@$outputArray, &quot;        return true;\n&quot;);
1151             push(@$outputArray, &quot;    }\n\n&quot;);
1152         }
1153     }
1154     
1155     # 2. If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal]
1156     #    extended attribute and P is not an unforgeable property name of O, then:
1157     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
1158         # FIMXE: We need a more comprehensive story for Symbols.
1159         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1160         
1161         my $additionalIndent = &quot;&quot;;
1162         
1163         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1164         if ($hasUnforgableProperties) {
1165             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1166             $additionalIndent .= &quot;    &quot;;
1167         }
1168         
1169         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1170         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1171         
1172         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1173         #    does not have an own property named P, then:
1174         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1175         if (!$overrideBuiltins) {
1176             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1177             #        only look at the actual properties, and not call into our implementation of the
1178             #        [[GetOwnProperty]] hook?
1179             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1180             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, state, propertyName, slot)) {\n&quot;);
1181             $additionalIndent .= &quot;    &quot;;
1182         }
1183         if (!$namedSetterOperation) {
1184             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1185             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1186             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1187         } else {
1188             # 2.2. If O implements an interface with a named property setter, then:
1189             
1190             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1191             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1192             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1193             
1194             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1195             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1196             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1197                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1198                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, state, propertyName, propertyDescriptor, shouldThrow);\n&quot;);
1199             }
1200             # 2.2.3. Return true.
1201             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1202         }
1203         
1204         if (!$overrideBuiltins) {
1205             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1206         }
1207         
1208         if ($hasUnforgableProperties) {
1209             push(@$outputArray, &quot;        }\n&quot;);
1210         }
1211         
1212         # Close the !propertyName.isSymbol() condition.
1213         push(@$outputArray, &quot;    }\n\n&quot;);
1214     }
1215     
1216     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1217         
1218     # 3. If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute,
1219     #    then set Desc.[[Configurable]] to true.
1220     if (!IsGlobalOrPrimaryGlobalInterface($interface)) {
1221         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1222     }
1223     
1224     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1225     # FIXME: Does this do the same thing?
1226     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, state, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);
1227     
1228     push(@$outputArray, &quot;}\n\n&quot;);
1229 }
1230 
1231 sub GenerateDeletePropertyCommon
1232 {
1233     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1234     
1235     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1236     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1237 
1238     # 2. If O supports named properties, O does not implement an interface with the
1239     #    [Global] or [PrimaryGlobal] extended attribute and the result of calling the
1240     #    named property visibility algorithm with property name P and object O is true,
1241     #    then:
1242     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1243     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);
1244 
1245     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1246     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
1247     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, thisObject, propertyName)) {\n&quot;);
1248 
1249     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);
1250 
1251     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1252     # 2.2. Let operation be the operation used to declare the named property deleter.
1253     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1254 
1255     # 2.3. If operation was defined without an identifier, then:
1256     #      1. Perform the steps listed in the interface description to delete an existing named
1257     #         property with P as the name.
1258     #      2. If the steps indicated that the deletion failed, then return false.
1259     # 2.4. Otherwise, operation was defined with an identifier:
1260     #      1. Perform the steps listed in the description of operation with P as the only argument
1261     #         value.
1262     #      2. If operation was declared with a return type of boolean and the steps returned false,
1263     #         then return false.
1264 
1265     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1266     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1267 
1268     # NOTE: We expect the implementation function of named deleters without an identifier to
1269     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1270     #       with an identifier have no restriction, but if the return value of the operation is
1271     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1272 
1273     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1274         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1275         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
1276         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);
1277         push(@$outputArray, &quot;            propagateException(*state, throwScope, result.releaseException());\n&quot;);
1278         push(@$outputArray, &quot;            return true;\n&quot;);
1279         push(@$outputArray, &quot;        }\n\n&quot;);
1280 
1281         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1282             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1283         } else {
1284             push(@$outputArray, &quot;        return true;\n&quot;);
1285         }
1286     } else {
1287         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1288             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1289         } else {
1290             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1291             push(@$outputArray, &quot;        return true;\n&quot;);
1292         }
1293     }
1294 
1295     push(@$outputArray, &quot;    }\n&quot;);
1296 }
1297 
1298 sub GenerateDeleteProperty
1299 {
1300     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1301 
1302     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1303     # for the deleteProperty override hook.
1304 
1305     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, ExecState* state, PropertyName propertyName)\n&quot;);
1306     push(@$outputArray, &quot;{\n&quot;);
1307 
1308     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1309     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1310 
1311     # 1. If O supports indexed properties and P is an array index property name, then:
1312     #    1. Let index be the result of calling ToUint32(P).
1313     #    2. If index is not a supported property index, then return true.
1314     #    3. Return false.
1315     if (GetIndexedGetterOperation($interface)) {
1316         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1317         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1318     }
1319 
1320     # GenerateDeletePropertyCommon implements step 2.
1321     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1322 
1323     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1324     # the remained of the algorithm ourselves.
1325     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, state, propertyName);\n&quot;);
1326     push(@$outputArray, &quot;}\n\n&quot;);
1327 }
1328 
1329 sub GenerateDeletePropertyByIndex
1330 {
1331     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1332 
1333     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1334     # for the deletePropertyByIndex override hook.
1335 
1336     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);
1337     push(@$outputArray, &quot;{\n&quot;);
1338 
1339     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1340     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1341 
1342     # 1. If O supports indexed properties and P is an array index property name, then:
1343     #    1. Let index be the result of calling ToUint32(P).
1344     #    2. If index is not a supported property index, then return true.
1345     #    3. Return false.
1346 
1347     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1348     #       is all that needs to be done, no need to generate the .
1349 
1350     if (GetIndexedGetterOperation($interface)) {
1351         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1352     } else {
<a name="16" id="anc16"></a><span class="line-modified">1353         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-added">1354         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);</span>
1355 
1356         # GenerateDeletePropertyCommon implements step 2.
1357         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1358 
1359         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1360         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1361         
1362         # 3. If O has an own property with name P, then:
1363         #    1. If the property is not configurable, then return false.
1364         #    2. Otherwise, remove the property from O.
1365         # 3. Return true.
1366         
1367         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);
1368     }
1369 
1370     push(@$outputArray, &quot;}\n\n&quot;);
1371 }
1372 
1373 
1374 sub GenerateNamedDeleterDefinition
1375 {
1376     my ($outputArray, $interface, $className) = @_;
1377     
1378     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1379 
1380     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1381     
1382     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1383     # the deleteProperty and deletePropertyByIndex override hooks.
1384 
1385     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1386     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);
1387 
1388     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1389     if ($conditional) {
1390         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1391         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1392     }
1393 
1394     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1395     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1396 
1397     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1398 }
1399 
1400 sub GenerateHeaderContentHeader
1401 {
1402     my $interface = shift;
1403     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1404 
1405     my @headerContentHeader;
1406     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1407         @headerContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForHeaderFiles);
1408     } else {
1409         @headerContentHeader = split(&quot;\r&quot;, $headerTemplate);
1410     }
1411 
1412     push(@headerContentHeader, &quot;\n#pragma once\n\n&quot;);
1413 
1414     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1415     push(@headerContentHeader, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
1416     return @headerContentHeader;
1417 }
1418 
1419 sub GenerateImplementationContentHeader
1420 {
1421     my $interface = shift;
1422     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1423 
1424     my @implContentHeader;
1425     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1426         @implContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForSourceFiles);
1427     } else {
1428         @implContentHeader = split(&quot;\r&quot;, $headerTemplate);
1429     }
1430 
1431     push(@implContentHeader, &quot;\n#include \&quot;config.h\&quot;\n&quot;);
1432     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1433     push(@implContentHeader, &quot;\n#if ${conditionalString}\n\n&quot;) if $conditionalString;
1434     push(@implContentHeader, &quot;#include \&quot;$className.h\&quot;\n\n&quot;);
1435     return @implContentHeader;
1436 }
1437 
1438 sub NeedsImplementationClass
1439 {
1440     my ($interface) = @_;
1441 
1442     return 0 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
1443     return 1;
1444 }
1445 
1446 sub ShouldGenerateToWrapped
1447 {
1448     my ($hasParent, $interface) = @_;
1449 
1450     return 0 if not NeedsImplementationClass($interface);
1451     return 1 if !$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
1452     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1453     return 0;
1454 }
1455 
1456 sub ShouldGenerateWrapperOwnerCode
1457 {
1458     my ($hasParent, $interface) = @_;
1459 
1460     return 0 if not NeedsImplementationClass($interface);
1461     return 1 if !$hasParent;
1462     return 1 if GetGenerateIsReachable($interface);
1463     return 1 if GetCustomIsReachable($interface);
1464     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomFinalize};
1465     return 1 if $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;);
1466     return 0;
1467 }
1468 
1469 sub ShouldGenerateToJSDeclaration
1470 {
1471     my ($hasParent, $interface) = @_;
1472 
1473     return 0 if ($interface-&gt;extendedAttributes-&gt;{SuppressToJSObject});
1474     return 0 if not NeedsImplementationClass($interface);
1475     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1476     return 1 if (!$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToJSObject} or $interface-&gt;extendedAttributes-&gt;{CustomToJSObject});
1477     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1478     return 1 if $interface-&gt;extendedAttributes-&gt;{Constructor} or $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
1479     return 0;
1480 }
1481 
1482 sub ShouldGenerateToJSImplementation
1483 {
1484     my ($hasParent, $interface) = @_;
1485 
1486     return 0 if not ShouldGenerateToJSDeclaration($hasParent, $interface);
1487     return 1 if not $interface-&gt;extendedAttributes-&gt;{CustomToJSObject};
1488     return 0;
1489 }
1490 
1491 sub GetTypeNameForDisplayInException
1492 {
1493     my ($type) = @_;
1494 
1495     # FIXME: Add more type specializations.
1496     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1497     return $type-&gt;name;
1498 }
1499 
1500 sub GetArgumentExceptionFunction
1501 {
1502     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1503 
1504     my $name = $argument-&gt;name;
1505     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1506     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1507 
1508     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1509         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
1510         return &quot;throwArgumentMustBeFunctionError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;
1511     }
1512 
1513     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
1514         return &quot;throwArgumentTypeError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;
1515     }
1516 
1517     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1518         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
1519         return &quot;throwArgumentMustBeEnumError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;
1520     }
1521 
1522     return undef;
1523 }
1524 
1525 sub GetArgumentExceptionThrower
1526 {
1527     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1528 
1529     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
1530     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1531 }
1532 
1533 sub GetAttributeExceptionFunction
1534 {
1535     my ($interface, $attribute) = @_;
1536     
1537     my $name = $attribute-&gt;name;
1538     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1539     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1540 
1541     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
1542         return &quot;throwAttributeTypeError(state, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;
1543     }
1544 }
1545 
1546 sub GetAttributeExceptionThrower
1547 {
1548     my ($interface, $attribute) = @_;
1549 
1550     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
1551     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1552 
1553 }
1554 
1555 sub PassArgumentExpression
1556 {
1557     my ($name, $context) = @_;
1558 
1559     my $type = $context-&gt;type;
1560 
1561     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1562 
1563     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1564         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1565         return &quot;${name}.releaseNonNull()&quot;;
1566     }
1567 
1568     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1569     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1570     return &quot;WTFMove(${name})&quot;;
1571 }
1572 
1573 sub GetAttributeGetterName
1574 {
1575     my ($interface, $className, $attribute) = @_;
1576 
1577     return $codeGenerator-&gt;WK_lcfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1578     return GetJSBuiltinFunctionName($className, $attribute) if IsJSBuiltin($interface, $attribute);
1579     return &quot;js&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1580 }
1581 
1582 sub GetAttributeSetterName
1583 {
1584     my ($interface, $className, $attribute) = @_;
1585 
1586     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1587     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst(GetJSBuiltinFunctionName($className, $attribute)) if IsJSBuiltin($interface, $attribute);
1588     return &quot;setJS&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1589 }
1590 
1591 sub GetFunctionName
1592 {
1593     my ($interface, $className, $operation) = @_;
1594 
1595     return GetJSBuiltinFunctionName($className, $operation) if IsJSBuiltin($interface, $operation);
1596 
1597     my $functionName = $operation-&gt;name;
1598     $functionName = &quot;SymbolIterator&quot; if $functionName eq &quot;[Symbol.Iterator]&quot;;
1599 
1600     my $kind = $operation-&gt;isStatic ? &quot;Constructor&quot; : (OperationShouldBeOnInstance($interface, $operation) ? &quot;Instance&quot; : &quot;Prototype&quot;);
1601     return $codeGenerator-&gt;WK_lcfirst($className) . $kind . &quot;Function&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
1602 }
1603 
1604 sub GetFullyQualifiedImplementationCallName
1605 {
1606     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1607     
1608     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1609     if ($implementedBy) {
1610         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1611         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1612     }
1613     
1614     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1615         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1616     }
1617     
1618     if ($property-&gt;isMapLike) {
1619         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1620     }
1621     
1622     return &quot;${implExpression}.${implementationName}&quot;;
1623 }
1624 
1625 sub AddAdditionalArgumentsForImplementationCall
1626 {
1627     my ($arguments, $interface, $property, $implExpression, $stateExpression, $thisObjectExpression) = @_;
1628     
1629     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1630         unshift(@$arguments, $implExpression);
1631     }
1632     
1633     if ($property-&gt;isMapLike) {
1634         push(@$arguments, $stateExpression);
1635         push(@$arguments, $thisObjectExpression);
1636     }
1637 }
1638 
1639 sub GetSpecialAccessorOperationForType
1640 {
1641     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1642 
1643     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1644         my $specials = $operation-&gt;specials;
1645         my $specialExists = grep { $_ eq $special } @$specials;
1646         my $arguments = $operation-&gt;arguments;
1647         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1648             return $operation;
1649         }
1650     }
1651 
1652     return 0;
1653 }
1654 
1655 sub IsGlobalOrPrimaryGlobalInterface
1656 {
1657     my $interface = shift;
1658 
1659     return $interface-&gt;extendedAttributes-&gt;{Global} || $interface-&gt;extendedAttributes-&gt;{PrimaryGlobal};
1660 }
1661 
1662 sub AttributeShouldBeOnInstance
1663 {
1664     my $interface = shift;
1665     my $attribute = shift;
1666 
1667     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1668     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1669 
1670     # [Unforgeable] attributes should be on the instance.
1671     # https://heycam.github.io/webidl/#Unforgeable
1672     return 1 if IsUnforgeable($interface, $attribute);
1673 
1674     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1675         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1676         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1677         return 1;
1678     }
1679 
1680     return 0;
1681 }
1682 
1683 sub IsAlwaysExposedOnInterface
1684 {
1685     my ($interfaceExposures, $contextExposures) = @_;
1686 
1687     my %contextExposureSet = ();
1688 
1689     if (ref($contextExposures) eq &quot;ARRAY&quot;) {
1690         foreach my $contextExposure (@$contextExposures) {
1691             $contextExposureSet{$contextExposure} = 1;
1692         }
1693     } else {
1694         $contextExposureSet{$contextExposures} = 1;
1695     }
1696 
1697     if (ref($interfaceExposures) ne &quot;ARRAY&quot;) {
1698         $interfaceExposures = [$interfaceExposures];
1699     }
1700 
1701     foreach my $interfaceExposure (@$interfaceExposures) {
1702         return 0 unless exists $contextExposureSet{$interfaceExposure};
1703     }
1704 
1705     return 1;
1706 }
1707 
1708 sub NeedsRuntimeCheck
1709 {
1710     my ($interface, $context) = @_;
1711 
1712     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1713         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1714         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1715     }
1716 
1717     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
<a name="17" id="anc17"></a><span class="line-added">1718         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}</span>
1719         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1720         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1721         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1722         || $context-&gt;extendedAttributes-&gt;{SecureContext}
<a name="18" id="anc18"></a><span class="line-modified">1723         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}</span>
<span class="line-added">1724         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};</span>
1725 }
1726 
1727 # https://heycam.github.io/webidl/#es-operations
1728 sub OperationShouldBeOnInstance
1729 {
1730     my ($interface, $operation) = @_;
1731 
1732     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);
1733 
1734     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1735     if (IsUnforgeable($interface, $operation)) {
1736         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1737         return 1;
1738     }
1739 
1740     return 0;
1741 }
1742 
1743 sub OperationHasForcedReturnValue
1744 {
1745     my ($operation) = @_;
1746 
1747     foreach my $argument (@{$operation-&gt;arguments}) {
1748         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1749     }
1750     return 0;
1751 }
1752 
1753 sub IsAcceleratedDOMAttribute
1754 {
1755     my ($interface, $attribute) = @_;
1756 
1757     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1758     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1759     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1760 
1761     # If the interface has special logic for casting we cannot hoist type check to JSC.
1762     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1763     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1764 
1765     return 0 if $attribute-&gt;isStatic;
1766     return 0 if $attribute-&gt;isMapLike;
1767     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1768     return 0 if IsJSBuiltin($interface, $attribute);
1769     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1770     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1771     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1772     return 1;
1773 }
1774 
1775 sub GetJSCAttributesForAttribute
1776 {
1777     my $interface = shift;
1778     my $attribute = shift;
1779 
1780     my @specials = ();
1781     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1782 
1783     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1784     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1785     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1786     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
1787     push(@specials, &quot;JSC::PropertyAttribute::CustomAccessor&quot;) unless $isGlobalConstructor or IsJSBuiltin($interface, $attribute);
1788     push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
1789     push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1790     push(@specials, &quot;JSC::PropertyAttribute::Accessor | JSC::PropertyAttribute::Builtin&quot;) if  IsJSBuiltin($interface, $attribute);
1791     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
1792 }
1793 
1794 sub GetIndexedGetterOperation
1795 {
1796     my $interface = shift;
1797     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;unsigned long&quot;, 1);
1798 }
1799 
1800 sub GetIndexedSetterOperation
1801 {
1802     my $interface = shift;
1803     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;unsigned long&quot;, 2);
1804 }
1805 
1806 sub GetNamedGetterOperation
1807 {
1808     my $interface = shift;
1809     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;DOMString&quot;, 1);
1810 }
1811 
1812 sub GetNamedSetterOperation
1813 {
1814     my $interface = shift;
1815     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;DOMString&quot;, 2);
1816 }
1817 
1818 sub GetNamedDeleterOperation
1819 {
1820     my $interface = shift;
1821     return GetSpecialAccessorOperationForType($interface, &quot;deleter&quot;, &quot;DOMString&quot;, 1);
1822 }
1823 
1824 sub InstanceOperationCount
1825 {
1826     my $interface = shift;
1827     my $count = 0;
1828 
1829     foreach my $operation (@{$interface-&gt;operations}) {
1830         $count++ if OperationShouldBeOnInstance($interface, $operation);
1831     }
1832 
1833     return $count;
1834 }
1835 
1836 sub PrototypeOperationCount
1837 {
1838     my $interface = shift;
1839     my $count = 0;
1840 
1841     foreach my $operation (@{$interface-&gt;operations}) {
1842         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1843     }
1844 
1845     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1846     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
1847     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1848 
1849     return $count;
1850 }
1851 
1852 sub InstancePropertyCount
1853 {
1854     my $interface = shift;
1855     my $count = 0;
1856     foreach my $attribute (@{$interface-&gt;attributes}) {
1857         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1858     }
1859     $count += InstanceOperationCount($interface);
1860     return $count;
1861 }
1862 
1863 sub PrototypePropertyCount
1864 {
1865     my $interface = shift;
1866     my $count = 0;
1867     foreach my $attribute (@{$interface-&gt;attributes}) {
1868         $count++ if !AttributeShouldBeOnInstance($interface, $attribute);
1869     }
1870     $count += PrototypeOperationCount($interface);
1871     $count++ if NeedsConstructorProperty($interface);
1872     return $count;
1873 }
1874 
1875 sub InstanceOverridesGetOwnPropertySlot
1876 {
1877     my $interface = shift;
1878     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot}
1879         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1880         || GetIndexedGetterOperation($interface)
1881         || GetNamedGetterOperation($interface);
1882 }
1883 
1884 sub InstanceOverridesGetOwnPropertyNames
1885 {
1886     my $interface = shift;
1887     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames}
1888         || GetIndexedGetterOperation($interface)
1889         || GetNamedGetterOperation($interface);
1890 }
1891 
1892 sub InstanceOverridesPut
1893 {
1894     my $interface = shift;
1895     return $interface-&gt;extendedAttributes-&gt;{CustomPut}
1896         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1897         || GetIndexedSetterOperation($interface)
1898         || GetNamedSetterOperation($interface);
1899 }
1900 
1901 sub InstanceOverridesDefineOwnProperty
1902 {
1903     my $interface = shift;
1904 
1905     return 0 if $interface-&gt;extendedAttributes-&gt;{DefaultDefineOwnProperty};
1906 
1907     return $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty}
1908         || GetIndexedSetterOperation($interface)
1909         || GetNamedSetterOperation($interface);
1910 }
1911 
1912 sub InstanceOverridesDeleteProperty
1913 {
1914     my $interface = shift;
1915     return $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty}
1916         || GetNamedDeleterOperation($interface);
1917 }
1918 
1919 sub PrototypeHasStaticPropertyTable
1920 {
1921     my $interface = shift;
1922     my $numConstants = @{$interface-&gt;constants};
1923     return $numConstants &gt; 0 || PrototypePropertyCount($interface) &gt; 0;
1924 }
1925 
1926 sub InstanceNeedsVisitChildren
1927 {
1928     my $interface = shift;
1929     
1930     foreach my $attribute (@{$interface-&gt;attributes}) {
1931         return 1 if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
1932     }
1933 
1934     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
1935     return 1 if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1936     return 0;
1937 }
1938 
1939 sub InstanceNeedsEstimatedSize
1940 {
1941     my $interface = shift;
1942     return $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1943 }
1944 
1945 sub GetImplClassName
1946 {
1947     my $interface = shift;
1948 
1949     return $interface-&gt;type-&gt;name;
1950 }
1951 
1952 sub IsClassNameWordBoundary
1953 {
1954     my ($name, $i) = @_;
1955 
1956     # Interpret negative numbers as distance from end of string, just as the substr function does.
1957     $i += length($name) if $i &lt; 0;
1958 
1959     return 0 if $i &lt; 0;
1960     return 1 if $i == 0;
1961     return 1 if $i == length($name);
1962     return 0 if $i &gt; length($name);
1963 
1964     my $checkString = substr($name, $i - 1);
1965     return $checkString =~ /^[^A-Z][A-Z]/ || $checkString =~ /^[A-Z][A-Z][^A-Z]/;
1966 }
1967 
1968 sub IsPrefixRemovable
1969 {
1970     my ($class, $name, $i) = @_;
1971 
1972     return IsClassNameWordBoundary($name, $i)
1973         &amp;&amp; (IsClassNameWordBoundary($class, $i) &amp;&amp; substr($class, 0, $i) eq substr($name, 0, $i)
1974             || IsClassNameWordBoundary($class, -$i) &amp;&amp; substr($class, -$i) eq substr($name, 0, $i));
1975 }
1976 
1977 sub GetNestedClassName
1978 {
1979     my ($interface, $name) = @_;
1980 
1981     my $class = GetImplClassName($interface);
1982     my $member = $codeGenerator-&gt;WK_ucfirst($name);
1983 
1984     # Since the enumeration name will be nested in the class name&#39;s namespace, remove any words
1985     # that happen to match the start or end of the class name. If an enumeration is named TrackType or
1986     # TextTrackType, and the class is named TextTrack, then we will get a name like TextTrack::Type.
1987     my $memberLength = length($member);
1988     my $longestPrefixLength = 0;
1989     if ($member =~ /^[A-Z]./) {
1990         for (my $i = 2; $i &lt; $memberLength - 1; $i++) {
1991             $longestPrefixLength = $i if IsPrefixRemovable($class, $member, $i);
1992         }
1993     }
1994     $member = substr($member, $longestPrefixLength);
1995 
1996     return &quot;${class}::$member&quot;;
1997 }
1998 
1999 sub GetEnumerationClassName
2000 {
2001     my ($type, $interface) = @_;
2002 
2003     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
2004 
2005     if ($codeGenerator-&gt;HasEnumImplementationNameOverride($type)) {
2006         return $codeGenerator-&gt;GetEnumImplementationNameOverride($type);
2007     }
2008 
2009     my $name = $type-&gt;name;
2010 
2011     return $name if $codeGenerator-&gt;IsExternalEnumType($type);
2012     return $name unless defined($interface);
2013 
2014     return GetNestedClassName($interface, $name);
2015 }
2016 
2017 sub GetEnumerationValueName
2018 {
2019     my ($name) = @_;
2020 
2021     return &quot;EmptyString&quot; if $name eq &quot;&quot;;
2022     $name = join(&quot;&quot;, map { $codeGenerator-&gt;WK_ucfirst($_) } split(&quot;-&quot;, $name));
2023     $name = &quot;_$name&quot; if $name =~ /^\d/;
2024     return $name;
2025 }
2026 
2027 sub GenerateEnumerationHeader
2028 {
2029     my ($object, $enumeration, $className) = @_;
2030  
2031     # - Add default header template and header protection.
2032     push(@headerContentHeader, GenerateHeaderContentHeader($enumeration));
2033 
2034     $headerIncludes{&quot;${className}.h&quot;} = 1;
2035 
2036     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2037     push(@headerContent, GenerateEnumerationHeaderContent($enumeration, $className));
2038     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
2039      
2040     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2041     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2042 }
2043  
2044 sub GenerateEnumerationImplementation
2045 {
2046     my ($object, $enumeration, $className) = @_;
2047  
2048     # - Add default header template
2049     push(@implContentHeader, GenerateImplementationContentHeader($enumeration));
2050 
2051     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
2052     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
2053     push(@implContent, GenerateEnumerationImplementationContent($enumeration, $className));
2054     push(@implContent, &quot;} // namespace WebCore\n&quot;);
2055      
2056     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2057     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2058 }
2059 
2060 sub GenerateEnumerationImplementationContent
2061 {
2062     my ($enumeration, $className, $interface, $conditionalString) = @_;
2063 
2064     # FIXME: A little ugly to have this be a side effect instead of a return value.
2065     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSString.h&gt;&quot;);
2066     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2067     AddToImplIncludes(&quot;JSDOMConvertEnumeration.h&quot;);
2068 
2069     my $result = &quot;&quot;;
2070     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2071 
2072 
2073     $result .= &quot;String convertEnumerationToString($className enumerationValue)\n&quot;;
2074     $result .= &quot;{\n&quot;;
2075     AddToImplIncludes(&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;);
2076     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2077     foreach my $value (@{$enumeration-&gt;values}) {
2078         if ($value eq &quot;&quot;) {
2079             $result .= &quot;        emptyString(),\n&quot;;
2080         } else {
2081             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2082         }
2083     }
2084     $result .= &quot;    };\n&quot;;
2085     my $index = 0;
2086     foreach my $value (@{$enumeration-&gt;values}) {
2087         my $enumerationValueName = GetEnumerationValueName($value);
2088         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2089         $index++;
2090     }
2091     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2092     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2093     $result .= &quot;}\n\n&quot;;
2094 
2095 
2096     # FIXME: Change to take VM&amp; instead of ExecState*.
2097     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(ExecState&amp; state, $className enumerationValue)\n&quot;;
2098     $result .= &quot;{\n&quot;;
2099     $result .= &quot;    return jsStringWithCache(&amp;state, convertEnumerationToString(enumerationValue));\n&quot;;
2100     $result .= &quot;}\n\n&quot;;
2101 
2102     # FIXME: Change to take VM&amp; instead of ExecState&amp;.
2103     # FIXME: Consider using toStringOrNull to make exception checking faster.
2104     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
2105     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;
2106     $result .= &quot;{\n&quot;;
2107     $result .= &quot;    auto stringValue = value.toWTFString(&amp;state);\n&quot;;
2108     foreach my $value (@{$enumeration-&gt;values}) {
2109         my $enumerationValueName = GetEnumerationValueName($value);
2110         if ($value eq &quot;&quot;) {
2111             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2112         } else {
2113             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2114         }
2115         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2116     }
2117     $result .= &quot;    return WTF::nullopt;\n&quot;;
2118     $result .= &quot;}\n\n&quot;;
2119 
2120     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2121     $result .= &quot;{\n&quot;;
2122     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2123     $result .= &quot;}\n\n&quot;;
2124 
2125     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2126 
2127     return $result;
2128 }
2129 
2130 sub GenerateEnumerationsImplementationContent
2131 {
2132     my ($interface, $enumerations) = @_;
2133 
2134     return &quot;&quot; unless @$enumerations;
2135 
2136     my $result = &quot;&quot;;
2137     foreach my $enumeration (@$enumerations) {
2138         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2139         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2140         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2141     }
2142     return $result;
2143 }
2144 
2145 sub GenerateEnumerationHeaderContent
2146 {
2147     my ($enumeration, $className, $conditionalString) = @_;
2148 
2149     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2150 
2151     my $result = &quot;&quot;;
2152     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2153 
2154     my $exportMacro = GetExportMacroForJSClass($enumeration);
2155 
2156     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
2157     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::ExecState&amp;, $className);\n\n&quot;;
2158     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;;
2159     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2160     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2161     
2162     return $result;
2163 }
2164 
2165 sub GenerateEnumerationsHeaderContent
2166 {
2167     my ($interface, $enumerations) = @_;
2168 
2169     return &quot;&quot; unless @$enumerations;
2170 
2171     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2172     # used, which would require iterating over everything in the interface.
2173 
2174     my $result = &quot;&quot;;
2175     foreach my $enumeration (@$enumerations) {
2176         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2177         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2178         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
2179     }
2180     return $result;
2181 }
2182 
2183 sub GetDictionaryClassName
2184 {
2185     my ($type, $interface) = @_;
2186 
2187     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2188         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2189     }
2190 
2191     my $name = $type-&gt;name;
2192     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2193     return $name unless defined($interface);
2194     return GetNestedClassName($interface, $name);
2195 }
2196 
2197 sub GenerateDefaultValue
2198 {
2199     my ($typeScope, $context, $type, $defaultValue) = @_;
2200 
2201     if ($codeGenerator-&gt;IsStringType($type)) {
<a name="19" id="anc19"></a><span class="line-modified">2202         my $useAtomString = $type-&gt;extendedAttributes-&gt;{AtomString};</span>
2203         if ($defaultValue eq &quot;null&quot;) {
<a name="20" id="anc20"></a><span class="line-modified">2204             return $useAtomString ? &quot;nullAtom()&quot; : &quot;String()&quot;;</span>
2205         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
<a name="21" id="anc21"></a><span class="line-modified">2206             return $useAtomString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;</span>
2207         } else {
<a name="22" id="anc22"></a><span class="line-modified">2208             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;</span>
2209         }
2210     }
2211 
2212     if ($codeGenerator-&gt;IsEnumType($type)) {
2213         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2214         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2215         if ($defaultValue eq &quot;null&quot;) {
2216             die if !$type-&gt;isNullable;
2217             return &quot;WTF::nullopt&quot;;
2218         }
2219         my $className = GetEnumerationClassName($type, $typeScope);
2220         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2221         return $className . &quot;::&quot; . $enumerationValueName;
2222     }
2223     if ($defaultValue eq &quot;null&quot;) {
2224         if ($type-&gt;isUnion) {
2225             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2226 
2227             my $IDLType = GetIDLType($typeScope, $type);
2228             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;
2229         }
2230 
2231         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2232         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2233         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2234         return &quot;WTF::nullopt&quot;;
2235     }
2236 
2237     if ($defaultValue eq &quot;[]&quot;) {
2238         my $IDLType = GetIDLType($typeScope, $type);
2239         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2240     }
2241 
2242     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2243     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2244 
2245     return $defaultValue;
2246 }
2247 
2248 sub GenerateDictionaryHeaderContent
2249 {
2250     my ($dictionary, $className, $conditionalString) = @_;
2251 
2252     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2253 
2254     my $exportMacro = GetExportMacroForJSClass($dictionary);
2255 
2256     my $result = &quot;&quot;;
2257     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2258     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::ExecState&amp;, JSC::JSValue);\n\n&quot;;
2259 
2260     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2261         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;
2262     }
2263 
2264     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2265     return $result;
2266 }
2267 
2268 sub GenerateDictionariesHeaderContent
2269 {
2270     my ($typeScope, $allDictionaries) = @_;
2271 
2272     return &quot;&quot; unless @$allDictionaries;
2273 
2274     my $result = &quot;&quot;;
2275     foreach my $dictionary (@$allDictionaries) {
2276         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2277         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2278         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2279         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2280     }
2281     return $result;
2282 }
2283 
2284 sub GenerateDictionaryImplementationContent
2285 {
2286     my ($dictionary, $className, $interface) = @_;
2287 
2288     my $result = &quot;&quot;;
2289 
2290     my $name = $dictionary-&gt;type-&gt;name;
2291     my $typeScope = $interface || $dictionary;
2292 
2293     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2294     if ($conditional) {
2295         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2296         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2297     }
2298 
2299     # FIXME: A little ugly to have this be a side effect instead of a return value.
2300     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2301     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2302 
2303     # https://heycam.github.io/webidl/#es-dictionary
2304     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;
2305     $result .= &quot;{\n&quot;;
2306     $result .= &quot;    VM&amp; vm = state.vm();\n&quot;;
2307     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2308     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2309     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2310 
2311     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2312     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
2313     $result .= &quot;        throwTypeError(&amp;state, throwScope);\n&quot;;
2314     $result .= &quot;        return { };\n&quot;;
2315     $result .= &quot;    }\n&quot;;
2316 
2317     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2318 
2319     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2320     my @dictionaries;
2321     push(@dictionaries, $dictionary);
2322     my $parentType = $dictionary-&gt;parentType;
2323     while (defined($parentType)) {
2324         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2325         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2326         unshift(@dictionaries, $parentDictionary);
2327         $parentType = $parentDictionary-&gt;parentType;
2328     }
2329 
2330     my $arguments = &quot;&quot;;
2331     my $comma = &quot;&quot;;
2332 
2333     $result .= &quot;    $className result;\n&quot;;
2334 
2335     # 4. For each dictionary dictionary in dictionaries, in order:
2336     foreach my $dictionary (@dictionaries) {
2337         # For each dictionary member member declared on dictionary, in lexicographical order:
2338         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2339         foreach my $member (@sortedMembers) {
2340             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2341 
2342             my $type = $member-&gt;type;
2343             AddToImplIncludesForIDLType($type);
2344 
<a name="23" id="anc23"></a><span class="line-added">2345             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};</span>
<span class="line-added">2346             if ($conditional) {</span>
<span class="line-added">2347                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);</span>
<span class="line-added">2348                 $result .= &quot;#if ${conditionalString}\n&quot;;</span>
<span class="line-added">2349             }</span>
<span class="line-added">2350 </span>
2351             # 4.1. Let key be the identifier of member.
2352             my $key = $member-&gt;name;
2353             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2354 
2355             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2356             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2357             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2358             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2359             $result .= &quot;    else {\n&quot;;
<a name="24" id="anc24"></a><span class="line-modified">2360             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
2361             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2362             $result .= &quot;    }\n&quot;;
2363 
2364             my $IDLType = GetIDLType($typeScope, $type);
2365 
2366             # 4.3. If value is not undefined, then:
2367             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2368 
2369             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);
2370             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2371             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2372 
2373             # Value is undefined.
2374             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2375             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2376                 $result .= &quot;    } else\n&quot;;
2377                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2378             } elsif ($member-&gt;isRequired) {
2379                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2380                 $result .= &quot;    } else {\n&quot;;
2381                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2382                 $result .= &quot;        return { };\n&quot;;
2383                 $result .= &quot;    }\n&quot;;
2384             } else {
2385                 $result .= &quot;    }\n&quot;;
2386             }
<a name="25" id="anc25"></a><span class="line-added">2387 </span>
<span class="line-added">2388             $result .= &quot;#endif\n&quot; if $conditional;</span>
2389         }
2390     }
2391 
2392     # 5. Return dict.
2393     $result .= &quot;    return result;\n&quot;;
2394     $result .= &quot;}\n\n&quot;;
2395 
2396     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2397         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2398         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2399 
2400         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2401         $result .= &quot;{\n&quot;;
2402         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;
2403 
2404         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2405         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;
2406 
2407         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2408         #    in order from least to most derived.
2409         #    NOTE: This was done above.
2410 
2411         # 3. For each dictionary dictionary in dictionaries, in order:
2412         foreach my $dictionary (@dictionaries) {
2413             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2414             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2415             foreach my $member (@sortedMembers) {
2416                 my $key = $member-&gt;name;
2417                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2418                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2419 
<a name="26" id="anc26"></a><span class="line-added">2420                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};</span>
<span class="line-added">2421                 if ($conditional) {</span>
<span class="line-added">2422                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);</span>
<span class="line-added">2423                     $result .= &quot;#if ${conditionalString}\n&quot;;</span>
<span class="line-added">2424                 }</span>
<span class="line-added">2425 </span>
2426                 # 1. Let key be the identifier of member.
2427                 # 2. If the dictionary member named key is present in V, then:
2428                     # 1. Let idlValue be the value of member on V.
2429                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2430                     # 3. Perform ! CreateDataProperty(O, key, value).
2431 
<a name="27" id="anc27"></a><span class="line-added">2432                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);</span>
<span class="line-added">2433                 my $indent = &quot;&quot;;</span>
<span class="line-added">2434                 if ($needsRuntimeCheck) {</span>
<span class="line-added">2435                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;true&quot;);</span>
<span class="line-added">2436                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;</span>
<span class="line-added">2437                     $indent = &quot;    &quot;;</span>
<span class="line-added">2438                 }</span>
<span class="line-added">2439 </span>
2440                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2441                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2442                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2443 
<a name="28" id="anc28"></a><span class="line-modified">2444                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;</span>
<span class="line-modified">2445                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2446                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>
<span class="line-modified">2447                     $result .= &quot;${indent}    }\n&quot;;</span>
2448                 } else {
2449                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2450 
<a name="29" id="anc29"></a><span class="line-modified">2451                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;</span>
<span class="line-modified">2452                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;</span>
<span class="line-added">2453                 }</span>
<span class="line-added">2454                 if ($needsRuntimeCheck) {</span>
<span class="line-added">2455                     $result .= &quot;    }\n&quot;;</span>
2456                 }
<a name="30" id="anc30"></a><span class="line-added">2457 </span>
<span class="line-added">2458                 $result .= &quot;#endif\n&quot; if $conditional;</span>
2459             }
2460         }
2461 
2462         $result .= &quot;    return result;\n&quot;;
2463         $result .= &quot;}\n\n&quot;;
2464     }
2465 
2466     $result .= &quot;#endif\n\n&quot; if $conditional;
2467 
2468     return $result;
2469 }
2470 
2471 sub GenerateDictionariesImplementationContent
2472 {
2473     my ($typeScope, $allDictionaries) = @_;
2474 
2475     my $result = &quot;&quot;;
2476     foreach my $dictionary (@$allDictionaries) {
2477         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2478         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
2479     }
2480     return $result;
2481 }
2482 
2483 sub GetJSTypeForNode
2484 {
2485     my ($interface) = @_;
2486 
2487     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Document&quot;)) {
2488         return &quot;JSDocumentWrapperType&quot;;
2489     }
2490     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentFragment&quot;)) {
2491         return &quot;JSDocumentFragmentNodeType&quot;;
2492     }
2493     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentType&quot;)) {
2494         return &quot;JSDocumentTypeNodeType&quot;;
2495     }
2496     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;ProcessingInstruction&quot;)) {
2497         return &quot;JSProcessingInstructionNodeType&quot;;
2498     }
2499     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;CDATASection&quot;)) {
2500         return &quot;JSCDATASectionNodeType&quot;;
2501     }
2502     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Attr&quot;)) {
2503         return &quot;JSAttrNodeType&quot;;
2504     }
2505     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Comment&quot;)) {
2506         return &quot;JSCommentNodeType&quot;;
2507     }
2508     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Text&quot;)) {
2509         return &quot;JSTextNodeType&quot;;
2510     }
2511     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Element&quot;)) {
2512         return &quot;JSElementType&quot;;
2513     }
2514     return &quot;JSNodeType&quot;;
2515 }
2516 
2517 sub GenerateHeader
2518 {
2519     my ($object, $interface, $enumerations, $dictionaries) = @_;
2520 
2521     my $interfaceName = $interface-&gt;type-&gt;name;
2522     my $className = &quot;JS$interfaceName&quot;;
2523     my %structureFlags = ();
2524 
2525     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2526     my $parentClassName = GetParentClassName($interface);
2527     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2528 
2529     # - Add default header template and header protection
2530     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2531 
2532     if ($hasParent) {
2533         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2534     } else {
2535         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2536         if ($interface-&gt;isException) {
2537             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2538         }
2539     }
2540 
<a name="31" id="anc31"></a>

2541     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2542 
2543     my $implType = GetImplClassName($interface);
2544 
2545     my $numConstants = @{$interface-&gt;constants};
2546     my $numAttributes = @{$interface-&gt;attributes};
2547     my $numOperations = @{$interface-&gt;operations};
2548 
2549     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2550 
2551     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
<a name="32" id="anc32"></a><span class="line-modified">2552         $headerIncludes{&quot;SVGAnimatedPropertyImpl.h&quot;} = 1;</span>
<span class="line-added">2553     } elsif ($codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {</span>
<span class="line-added">2554         $headerIncludes{&quot;SVGPathSegImpl.h&quot;} = 1;</span>
2555     } else {
<a name="33" id="anc33"></a><span class="line-added">2556         $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};</span>
2557         # Implementation class forward declaration
2558         if (IsDOMGlobalObject($interface)) {
2559             AddClassForwardIfNeeded($interface-&gt;type);
2560         }
2561     }
2562 
2563     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2564 
2565     my $exportMacro = GetExportMacroForJSClass($interface);
2566 
2567     # Class declaration
2568     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2569 
2570     # Static create methods
2571     push(@headerContent, &quot;public:\n&quot;);
2572     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2573     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2574 
2575     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2576         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
2577         push(@headerContent, &quot;    {\n&quot;);
2578         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl), proxy);\n&quot;);
2579         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2580         push(@headerContent, &quot;        return ptr;\n&quot;);
2581         push(@headerContent, &quot;    }\n\n&quot;);
2582     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2583         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSC::JSProxy* proxy)\n&quot;);
2584         push(@headerContent, &quot;    {\n&quot;);
2585         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl));\n&quot;);
2586         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2587         push(@headerContent, &quot;        return ptr;\n&quot;);
2588         push(@headerContent, &quot;    }\n\n&quot;);
2589     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2590         AddIncludesForImplementationTypeInHeader($implType);
2591         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2592         push(@headerContent, &quot;    {\n&quot;);
2593         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2594         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2595         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2596         push(@headerContent, &quot;        return ptr;\n&quot;);
2597         push(@headerContent, &quot;    }\n\n&quot;);
2598     } elsif (!NeedsImplementationClass($interface)) {
2599         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2600         push(@headerContent, &quot;    {\n&quot;);
2601         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2602         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2603         push(@headerContent, &quot;        return ptr;\n&quot;);
2604         push(@headerContent, &quot;    }\n\n&quot;);  
2605     } else {
<a name="34" id="anc34"></a><span class="line-modified">2606         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {</span>
<span class="line-added">2607             AddIncludesForImplementationTypeInHeader($implType);</span>
<span class="line-added">2608         }</span>
2609         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2610         push(@headerContent, &quot;    {\n&quot;);
2611         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2612         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2613         push(@headerContent, &quot;        return ptr;\n&quot;);
2614         push(@headerContent, &quot;    }\n\n&quot;);
2615     }
2616 
2617     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);
2618 
2619     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2620     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2621     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2622     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2623     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2624         
2625     # Prototype
2626     unless (ShouldUseGlobalObjectPrototype($interface)) {
2627         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2628         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2629     }
2630 
2631     # JSValue to implementation type
2632     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2633         # FIXME: Add extended attribute for this.
2634         my @toWrappedArguments = ();
2635         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
2636         push(@toWrappedArguments, &quot;JSC::ExecState&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;
2637         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2638 
2639         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2640 
2641         my $export = &quot;&quot;;
2642         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2643         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2644     }
2645 
2646     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2647 
2648     my $namedGetterOperation = GetNamedGetterOperation($interface);
2649     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2650 
2651     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2652     if ($namedGetterOperation) {
2653         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2654             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2655         } else {
2656             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2657         }
2658     }
2659     
2660     # ClassInfo MethodTable declarations.
2661     
2662     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2663         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2664         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2665         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2666         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2667     }
<a name="35" id="anc35"></a><span class="line-added">2668 </span>
<span class="line-added">2669     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {</span>
<span class="line-added">2670         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="line-added">2671         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;</span>
<span class="line-added">2672     }</span>
2673     
2674     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2675         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2676         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2677     }
2678     
2679     if (InstanceOverridesPut($interface)) {
2680         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2681         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2682     }
2683     
2684     if (InstanceOverridesDefineOwnProperty($interface)) {
2685         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2686     }
2687 
2688     if (InstanceOverridesDeleteProperty($interface)) {
2689         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);
2690         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);
2691     }
2692 
2693     if (InstanceOverridesGetCallData($interface)) {
2694         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2695         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2696         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2697     }
2698     
2699     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
2700         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::ExecState*);\n&quot;);
2701     }
2702     
2703     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
2704         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::ExecState*);\n&quot;);
2705     }
2706     
2707     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
2708         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::ExecState*);\n&quot;);
2709     }
2710 
2711     if (InstanceNeedsEstimatedSize($interface)) {
2712         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2713     }
2714     
2715     if (!$hasParent) {
2716         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2717     }
2718 
2719     # Class info
2720     if ($interfaceName eq &quot;Node&quot;) {
2721         push(@headerContent, &quot;\n&quot;);
2722         push(@headerContent, &quot;protected:\n&quot;);
2723         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2724         push(@headerContent, &quot;public:\n&quot;);
2725         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2726     } else {
2727         push(@headerContent, &quot;\n&quot;);
2728         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2729     }
2730 
2731     # Structure ID
2732     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2733     push(@headerContent, &quot;    {\n&quot;);
2734     if (IsDOMGlobalObject($interface)) {
2735         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n&quot;);
2736     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2737         my $type = GetJSTypeForNode($interface);
2738         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n&quot;);
2739     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2740         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n&quot;);
2741     } else {
2742         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
2743     }
2744     push(@headerContent, &quot;    }\n\n&quot;);
2745 
2746     # Custom pushEventHandlerScope function
2747     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
2748         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::ExecState*, JSC::JSScope*) const;\n\n&quot;);
2749     }
2750     
2751     # Constructor object getter
2752     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2753         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2754         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2755     }
2756 
2757     # Serializer function.
2758     if ($interface-&gt;serializable) {
2759         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::ExecState&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);
2760     }
2761     
2762     my $numCustomOperations = 0;
2763     my $numCustomAttributes = 0;
2764 
2765     my $hasForwardDeclaringOperations = 0;
2766     my $hasForwardDeclaringAttributes = 0;
2767 
2768     my $hasDOMJITAttributes = 0;
2769 
2770     # Attribute and function enums
2771     if ($numAttributes &gt; 0) {
2772         foreach my $attribute (@{$interface-&gt;attributes}) {
2773             $numCustomAttributes++ if HasCustomGetter($attribute);
2774             $numCustomAttributes++ if HasCustomSetter($attribute);
2775             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2776                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2777                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2778                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2779                 $numCachedAttributes++;
2780                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2781             }
2782             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2783 
2784             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2785         }
2786     }
2787 
2788     # visit function
2789     if ($needsVisitChildren) {
2790         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2791         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2792         push(@headerContent, &quot;\n&quot;);
2793 
2794         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2795             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2796             # concurrent GC or in between eden GCs something may happen that would lead to this
2797             # logic behaving differently. Since this could mark objects or add opaque roots, this
2798             # means that after any increment of mutator resumption in a concurrent GC and at least
2799             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2800             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2801             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2802             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2803             # that the GC calls to ask an object is it would like to mark anything else after the
2804             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2805             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2806             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2807             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;
2808             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);
2809         }
2810     }
2811 
2812     if (NeedsImplementationClass($interface)) {
<a name="36" id="anc36"></a><span class="line-modified">2813         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);</span>
2814     }
2815     
2816     if ($numCustomAttributes &gt; 0) {
2817         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2818 
2819         foreach my $attribute (@{$interface-&gt;attributes}) {
2820             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2821             if (HasCustomGetter($attribute)) {
2822                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2823                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2824                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);
2825                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2826             }
2827             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2828                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2829                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);
2830                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2831             }
2832         }
2833     }
2834 
2835     foreach my $operation (@{$interface-&gt;operations}) {
2836         $numCustomOperations++ if HasCustomMethod($operation);
2837         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2838     }
2839 
2840     if ($numCustomOperations &gt; 0) {
2841         my $inAppleCopyright = 0;
2842         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2843         foreach my $operation (@{$interface-&gt;operations}) {
2844             next unless HasCustomMethod($operation);
2845             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2846 
2847             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2848                 if (!$inAppleCopyright) {
2849                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2850                     $inAppleCopyright = 1;
2851                 }
2852             } elsif ($inAppleCopyright) {
2853                 push(@headerContent, $endAppleCopyright);
2854                 $inAppleCopyright = 0;
2855             }
2856 
2857             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2858             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2859 
2860             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2861 
2862             my @functionArguments = ();
2863             push(@functionArguments, &quot;JSC::ExecState&amp;&quot;);
2864             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2865 
2866             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2867 
2868             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2869         }
2870         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2871     }
2872 
2873     if (NeedsImplementationClass($interface)) {
2874         if ($hasParent) {
2875             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2876             push(@headerContent, &quot;    {\n&quot;);
2877             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2878             push(@headerContent, &quot;    }\n&quot;);
2879         }
2880     }
2881 
2882     # structure flags
2883     if (%structureFlags) {
2884         push(@headerContent, &quot;public:\n&quot;);
2885         push(@headerContent, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);
2886         foreach my $structureFlag (sort (keys %structureFlags)) {
2887             push(@headerContent, &quot; | &quot; . $structureFlag);
2888         }
2889         push(@headerContent, &quot;;\n&quot;);
2890     }
2891 
2892     push(@headerContent, &quot;protected:\n&quot;);
2893 
2894     # Constructor
2895     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2896         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2897     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2898         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2899     } elsif (!NeedsImplementationClass($interface)) {
2900         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2901      } else {
2902         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2903     }
2904 
2905     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2906         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSWindowProxy*);\n&quot;);
2907     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2908         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSC::JSProxy*);\n&quot;);
2909     } else {
2910         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
2911     }
2912 
2913     push(@headerContent, &quot;};\n\n&quot;);
2914 
2915     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface)) {
2916         if ($interfaceName ne &quot;Node&quot; &amp;&amp; $codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2917             $headerIncludes{&quot;JSNode.h&quot;} = 1;
2918             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSNodeOwner {\n&quot;);
2919         } else {
2920             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSC::WeakHandleOwner {\n&quot;);
2921         }
2922         $headerIncludes{&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;} = 1;
2923         push(@headerContent, &quot;public:\n&quot;);
2924         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2925         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2926         push(@headerContent, &quot;};\n&quot;);
2927         push(@headerContent, &quot;\n&quot;);
2928         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2929         push(@headerContent, &quot;{\n&quot;);
2930         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2931         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2932         push(@headerContent, &quot;}\n&quot;);
2933         push(@headerContent, &quot;\n&quot;);
2934         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2935         push(@headerContent, &quot;{\n&quot;);
2936         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2937         push(@headerContent, &quot;}\n&quot;);
2938         push(@headerContent, &quot;\n&quot;);
2939     }
2940     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2941         # Node and NodeList have custom inline implementations which thus cannot be exported.
2942         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2943         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
2944             push(@headerContent, &quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2945         } else {
2946             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2947         }
2948         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(state, globalObject, *impl) : JSC::jsNull(); }\n&quot;);
2949 
2950         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2951         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::ExecState* state, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(state, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);
2952    }
2953 
2954     push(@headerContent, &quot;\n&quot;);
2955 
2956     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2957 
2958     if ($hasForwardDeclaringOperations) {
2959         my $inAppleCopyright = 0;
2960         push(@headerContent,&quot;// Functions\n\n&quot;);
2961         foreach my $operation (@{$interface-&gt;operations}) {
2962             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2963             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2964 
2965             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2966                 if (!$inAppleCopyright) {
2967                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2968                     $inAppleCopyright = 1;
2969                 }
2970             } elsif ($inAppleCopyright) {
2971                 push(@headerContent, $endAppleCopyright);
2972                 $inAppleCopyright = 0;
2973             }
2974 
2975             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2976             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2977             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2978             my $functionName = GetFunctionName($interface, $className, $operation);
2979             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
2980             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2981         }
2982 
2983         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2984         push(@headerContent,&quot;\n&quot;);
2985     }
2986 
2987     if ($hasForwardDeclaringAttributes) {
2988         push(@headerContent,&quot;// Attributes\n\n&quot;);
2989         foreach my $attribute (@{$interface-&gt;attributes}) {
2990             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2991 
2992             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2993             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2994             my $getter = GetAttributeGetterName($interface, $className, $attribute);
2995             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
2996             if (!IsReadonly($attribute)) {
2997                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
2998                 push(@headerContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
2999             }
3000             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3001         }
3002     }
3003 
3004     # CheckSubClass Snippet function.
3005     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
3006         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
3007         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3008         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
3009         push(@headerContent, &quot;#endif\n&quot;);
3010     }
3011 
3012     if ($hasDOMJITAttributes) {
3013         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
3014         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
3015         foreach my $attribute (@{$interface-&gt;attributes}) {
3016             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3017             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
3018 
3019             my $interfaceName = $interface-&gt;type-&gt;name;
3020             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
3021             my $domJITClassName = $className . &quot;Attribute&quot;;
3022 
3023             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3024             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
3025             push(@headerContent, &quot;#endif\n\n&quot;);
3026         }
3027     }
3028 
3029     if (HasCustomConstructor($interface)) {
3030         push(@headerContent, &quot;// Custom constructor\n&quot;);
3031         push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL construct${className}(JSC::ExecState&amp;);\n\n&quot;);
3032     }
3033 
3034     if (NeedsImplementationClass($interface)) {
3035         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
3036         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
3037 
3038         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
3039         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
3040         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
3041         push(@headerContent, &quot;};\n&quot;);
3042     }
3043 
3044     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
3045     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
3046 
3047     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3048     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3049     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3050 
3051     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3052         push(@headerContent, &quot;\n&quot;);
3053         push(@headerContent, split(&quot;\r&quot;, $endAppleCopyright));
3054     }
3055 
3056     # - Generate dependencies.
3057     if ($writeDependencies) {
3058         my @ancestors;
3059         $codeGenerator-&gt;ForAllParents($interface, sub {
3060             my $currentInterface = shift;
3061             push(@ancestors, $currentInterface-&gt;type-&gt;name);
3062         }, 0);
3063         for my $dictionary (@$dictionaries) {
3064             my $parentType = $dictionary-&gt;parentType;
3065             while (defined($parentType)) {
3066                 push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
3067                 my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
3068                 assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
3069                 $parentType = $parentDictionary-&gt;parentType;
3070             }
3071         }
3072         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
3073         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
3074     }
3075 }
3076 
3077 sub GeneratePropertiesHashTable
3078 {
3079     my ($object, $interface, $isInstance, $hashKeys, $hashSpecials, $hashValue1, $hashValue2, $conditionals, $readWriteConditionals, $runtimeEnabledOperations, $runtimeEnabledAttributes) = @_;
3080 
3081     # FIXME: These should be functions on $interface.
3082     my $interfaceName = $interface-&gt;type-&gt;name;
3083     my $className = &quot;JS$interfaceName&quot;;
3084     
3085     # - Add all properties in a hashtable definition
3086     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3087 
3088     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3089         die if !$propertyCount;
3090         push(@$hashKeys, &quot;constructor&quot;);
3091         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3092         push(@$hashValue1, $getter);
3093 
3094         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3095         push(@$hashValue2, $setter);
3096         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3097     }
3098 
3099     return 0 if !$propertyCount;
3100 
3101     my @attributes = @{$interface-&gt;attributes};
3102     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3103 
3104     foreach my $attribute (@attributes) {
3105         next if ($attribute-&gt;isStatic);
3106         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3107         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3108 
3109         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3110         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3111             $propertyCount -= 1;
3112             next;
3113         }
3114 
3115         my $name = $attribute-&gt;name;
3116         push(@$hashKeys, $name);
3117 
3118         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3119         push(@$hashSpecials, $special);
3120 
3121         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3122             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3123         } else {
3124             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3125             push(@$hashValue1, $getter);
3126         }
3127 
3128         if (IsReadonly($attribute)) {
3129             push(@$hashValue2, &quot;0&quot;);
3130         } else {
3131             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3132             push(@$hashValue2, $setter);
3133         }
3134 
3135         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3136         $conditionals-&gt;{$name} = $conditional if $conditional;
3137         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3138         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3139 
3140         if (NeedsRuntimeCheck($interface, $attribute)) {
3141             push(@$runtimeEnabledAttributes, $attribute);
3142         }
3143     }
3144 
3145     my @operations = @{$interface-&gt;operations};
3146     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3147     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3148     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3149     foreach my $operation (@operations) {
3150         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3151         next if ($operation-&gt;isStatic);
3152         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3153         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3154         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3155 
3156         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3157         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3158             $propertyCount -= 1;
3159             next;
3160         }
3161 
3162         my $name = $operation-&gt;name;
3163         push(@$hashKeys, $name);
3164 
3165         my $functionName = GetFunctionName($interface, $className, $operation);
3166         push(@$hashValue1, $functionName);
3167 
3168         my $functionLength = GetFunctionLength($operation);
3169 
3170         if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3171             push(@$hashValue2, &quot;&amp;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
3172         } else {
3173             push(@$hashValue2, $functionLength);
3174         }
3175 
3176         push(@$hashSpecials, ComputeFunctionSpecial($interface, $operation));
3177 
3178         my $conditional = GetConditionalForOperationConsideringOverloads($operation);
3179         $conditionals-&gt;{$name} = $conditional if $conditional;
3180 
3181         if (NeedsRuntimeCheck($interface, $operation)) {
3182             push(@$runtimeEnabledOperations, $operation);
3183         }
3184     }
3185 
3186     return $propertyCount;
3187 }
3188 
3189 # This computes an effective overload set for a given operation / constructor,
3190 # which represents the allowable invocations.This set is used as input for
3191 # the Web IDL overload resolution algorithm.
3192 # http://heycam.github.io/webidl/#dfn-effective-overload-set
3193 sub ComputeEffectiveOverloadSet
3194 {
3195     my ($overloads) = @_;
3196 
3197     my %allSets;
3198     my $addTuple = sub {
3199         my $tuple = shift;
3200         # The Web IDL specification uses a flat set of tuples but we use a hash where the key is the
3201         # number of parameters and the value is the set of tuples for the given number of parameters.
3202         my $length = scalar(@{@$tuple[1]});
3203         if (!exists($allSets{$length})) {
3204             $allSets{$length} = [ $tuple ];
3205         } else {
3206             push(@{$allSets{$length}}, $tuple);
3207         }
3208     };
3209 
3210     my $m = LengthOfLongestOperationParameterList($overloads);
3211     foreach my $overload (@{$overloads}) {
3212         my $n = @{$overload-&gt;arguments};
3213         my @t;
3214         my @o;
3215         my $isVariadic = 0;
3216         foreach my $argument (@{$overload-&gt;arguments}) {
3217             push(@t, $argument-&gt;type);
3218             if ($argument-&gt;isOptional) {
3219                 push(@o, &quot;optional&quot;);
3220             } elsif ($argument-&gt;isVariadic) {
3221                 push(@o, &quot;variadic&quot;);
3222                 $isVariadic = 1;
3223             } else {
3224                 push(@o, &quot;required&quot;);
3225             }
3226         }
3227         &amp;$addTuple([$overload, [@t], [@o]]);
3228         if ($isVariadic) {
3229             my @newT = @t;
3230             my @newO = @o;
3231             for (my $i = $n; $i &lt; $m; $i++) {
3232                 push(@newT, $t[-1]);
3233                 push(@newO, &quot;variadic&quot;);
3234                 &amp;$addTuple([$overload, [@newT], [@newO]]);
3235             }
3236         }
3237         for (my $i = $n - 1; $i &gt;= 0; $i--) {
3238             my $argument = @{$overload-&gt;arguments}[$i];
3239             last unless ($argument-&gt;isOptional || $argument-&gt;isVariadic);
3240             pop(@t);
3241             pop(@o);
3242             &amp;$addTuple([$overload, [@t], [@o]]);
3243         }
3244     }
3245     return %allSets;
3246 }
3247 
3248 sub IsIDLTypeDistinguishableWithUnionForOverloadResolution
3249 {
3250     my ($type, $unionSubtypes) = @_;
3251 
3252     assert(&quot;First type should not be a union&quot;) if $type-&gt;isUnion;
3253     for my $unionSubType (@$unionSubtypes) {
3254         return 0 unless AreTypesDistinguishableForOverloadResolution($type, $unionSubType);
3255     }
3256     return 1;
3257 }
3258 
3259 # Determines if two types are distinguishable in the context of overload resolution,
3260 # according to the Web IDL specification:
3261 # http://heycam.github.io/webidl/#dfn-distinguishable
3262 sub AreTypesDistinguishableForOverloadResolution
3263 {
3264     my ($typeA, $typeB) = @_;
3265 
3266     my $isCallbackFunctionOrDictionary = sub {
3267         my $type = shift;
3268         return $codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsDictionaryType($type);
3269     };
3270 
3271     # Two types are distinguishable for overload resolution if at most one of the two includes a nullable type.
3272     return 0 if $typeA-&gt;isNullable &amp;&amp; $typeB-&gt;isNullable;
3273 
3274     # Union types: typeA and typeB  are distinguishable if:
3275     # - Both types are either a union type or nullable union type, and each member type of the one is
3276     #   distinguishable with each member type of the other.
3277     # - One type is a union type or nullable union type, the other is neither a union type nor a nullable
3278     #   union type, and each member type of the first is distinguishable with the second.
3279     if ($typeA-&gt;isUnion &amp;&amp; $typeB-&gt;isUnion) {
3280         for my $unionASubType (@{$typeA-&gt;subtypes}) {
3281             return 0 unless IsIDLTypeDistinguishableWithUnionForOverloadResolution($unionASubType, $typeB-&gt;subtypes);
3282         }
3283         return 1;
3284     } elsif ($typeA-&gt;isUnion) {
3285         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeB, $typeA-&gt;subtypes);
3286     } elsif ($typeB-&gt;isUnion) {
3287         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeA, $typeB-&gt;subtypes);
3288     }
3289 
3290     return 0 if $typeA-&gt;name eq $typeB-&gt;name;
3291     return 0 if $typeA-&gt;name eq &quot;object&quot; or $typeB-&gt;name eq &quot;object&quot;;
3292     return 0 if $codeGenerator-&gt;IsNumericType($typeA) &amp;&amp; $codeGenerator-&gt;IsNumericType($typeB);
3293     return 0 if $codeGenerator-&gt;IsStringOrEnumType($typeA) &amp;&amp; $codeGenerator-&gt;IsStringOrEnumType($typeB);
3294     return 0 if $codeGenerator-&gt;IsDictionaryType($typeA) &amp;&amp; $codeGenerator-&gt;IsDictionaryType($typeB);
3295     return 0 if $codeGenerator-&gt;IsCallbackInterface($typeA) &amp;&amp; $codeGenerator-&gt;IsCallbackInterface($typeB);
3296     return 0 if &amp;$isCallbackFunctionOrDictionary($typeA) &amp;&amp; &amp;$isCallbackFunctionOrDictionary($typeB);
3297     return 0 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeA) &amp;&amp; $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeB);
3298     # FIXME: return 0 if $typeA and $typeB are both exception types.
3299     return 1;
3300 }
3301 
3302 # If there is more than one entry in an effective overload set that has a given type list length,
3303 # then for those entries there must be an index i such that for each pair of entries the types
3304 # at index i are distinguishable. The lowest such index is termed the distinguishing argument index.
3305 # http://heycam.github.io/webidl/#dfn-distinguishing-argument-index
3306 sub GetDistinguishingArgumentIndex
3307 {
3308     my ($operation, $S) = @_;
3309 
3310     # FIXME: Consider all the tuples, not just the 2 first ones?
3311     my $firstTupleTypes = @{@{$S}[0]}[1];
3312     my $secondTupleTypes = @{@{$S}[1]}[1];
3313     for (my $index = 0; $index &lt; scalar(@$firstTupleTypes); $index++) {
3314         return $index if AreTypesDistinguishableForOverloadResolution(@{$firstTupleTypes}[$index], @{$secondTupleTypes}[$index]);
3315     }
3316     die &quot;Undistinguishable overloads for operation &quot; . $operation-&gt;name . &quot; with length: &quot; . scalar(@$firstTupleTypes);
3317 }
3318 
3319 sub GetOverloadThatMatches
3320 {
3321     my ($S, $parameterIndex, $matches) = @_;
3322 
3323     for my $tuple (@{$S}) {
3324         my $type = @{@{$tuple}[1]}[$parameterIndex];
3325         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3326         if ($type-&gt;isUnion) {
3327             for my $subtype (GetFlattenedMemberTypes($type)) {
3328                 return @{$tuple}[0] if $matches-&gt;($subtype, $optionality);
3329             }
3330         } else {
3331             return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3332         }
3333     }
3334 }
3335 
3336 sub GetOverloadThatMatchesIgnoringUnionSubtypes
3337 {
3338     my ($S, $parameterIndex, $matches) = @_;
3339 
3340     for my $tuple (@{$S}) {
3341         my $type = @{@{$tuple}[1]}[$parameterIndex];
3342         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3343         return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3344     }
3345 }
3346 
3347 sub GetConditionalForOperationConsideringOverloads
3348 {
3349     my $operation = shift;
3350 
3351     return $operation-&gt;extendedAttributes-&gt;{Conditional} unless $operation-&gt;{overloads};
3352 
3353     my %conditions;
3354     foreach my $overload (@{$operation-&gt;{overloads}}) {
3355         my $conditional = $overload-&gt;extendedAttributes-&gt;{Conditional};
3356         return unless $conditional;
3357         $conditions{$conditional} = 1;
3358     }
3359     return join(&quot;|&quot;, keys %conditions);
3360 }
3361 
3362 # Implements the overload resolution algorithm, as defined in the Web IDL specification:
3363 # http://heycam.github.io/webidl/#es-overloads
3364 sub GenerateOverloadDispatcher
3365 {
3366     my ($operation, $interface, $overloadFunctionPrefix, $overloadFunctionSuffix, $parametersToForward) = @_;
3367     
3368     my %allSets = ComputeEffectiveOverloadSet($operation-&gt;{overloads});
3369 
3370     my $generateOverloadCallIfNecessary = sub {
3371         my ($overload, $condition, $include) = @_;
3372         return unless $overload;
3373         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($overload);
3374         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3375         push(@implContent, &quot;        if ($condition)\n    &quot;) if $condition;
3376         push(@implContent, &quot;        return &quot; . $overloadFunctionPrefix . $overload-&gt;{overloadIndex} . $overloadFunctionSuffix . &quot;(${parametersToForward});\n&quot;);
3377         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3378         AddToImplIncludes($include, $overload-&gt;extendedAttributes-&gt;{Conditional}) if $include;
3379     };
3380     my $isOptionalParameter = sub {
3381         my ($type, $optionality) = @_;
3382         return $optionality eq &quot;optional&quot;;
3383     };
3384     my $isDictionaryOrRecordParameter = sub {
3385         my ($type, $optionality) = @_;
3386         return $codeGenerator-&gt;IsDictionaryType($type) || $codeGenerator-&gt;IsRecordType($type);
3387     };
3388     my $isNullableOrDictionaryOrRecordOrUnionContainingOne = sub {
3389         my ($type, $optionality) = @_;
3390         return 1 if $type-&gt;isNullable;
3391         if ($type-&gt;isUnion) {
3392             for my $subtype (GetFlattenedMemberTypes($type)) {
3393                 return 1 if $type-&gt;isNullable || &amp;$isDictionaryOrRecordParameter($subtype, $optionality);
3394             }
3395             return 0;
3396         } else {
3397             return &amp;$isDictionaryOrRecordParameter($type, $optionality);
3398         }
3399     };
3400     my $isObjectOrErrorParameter = sub {
3401         my ($type, $optionality) = @_;
3402         return $type-&gt;name eq &quot;object&quot; || $type-&gt;name eq &quot;Error&quot;;
3403     };
3404     my $isObjectOrErrorOrDOMExceptionParameter = sub {
3405         my ($type, $optionality) = @_;
3406         return 1 if &amp;$isObjectOrErrorParameter($type, $optionality);
3407         return $type-&gt;name eq &quot;DOMException&quot;;
3408     };
3409     my $isObjectOrCallbackFunctionParameter = sub {
3410         my ($type, $optionality) = @_;
3411         return $type-&gt;name eq &quot;object&quot; || $codeGenerator-&gt;IsCallbackFunction($type);
3412     };
3413     my $isSequenceOrFrozenArrayParameter = sub {
3414         my ($type, $optionality) = @_;
3415         return $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
3416     };
3417     my $isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter = sub {
3418         my ($type, $optionality) = @_;
3419         return 1 if &amp;$isDictionaryOrRecordParameter($type, $optionality);
3420         return 1 if $type-&gt;name eq &quot;object&quot;;
3421         return 1 if $codeGenerator-&gt;IsCallbackInterface($type) &amp;&amp; !$codeGenerator-&gt;IsCallbackFunction($type);
3422         return 0;
3423     };
3424     my $isBooleanParameter = sub {
3425         my ($type, $optionality) = @_;
3426         return $type-&gt;name eq &quot;boolean&quot;;
3427     };
3428     my $isNumericParameter = sub {
3429         my ($type, $optionality) = @_;
3430         return $codeGenerator-&gt;IsNumericType($type);
3431     };
3432     my $isStringOrEnumParameter = sub {
3433         my ($type, $optionality) = @_;
3434         return $codeGenerator-&gt;IsStringOrEnumType($type);
3435     };
3436     my $isAnyParameter = sub {
3437         my ($type, $optionality) = @_;
3438         return $type-&gt;name eq &quot;any&quot;;
3439     };
3440 
3441     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3442 
3443     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, state-&gt;argumentCount());\n&quot;);
3444 
3445     for my $length ( sort keys %allSets ) {
3446         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3447 
3448         my $S = $allSets{$length};
3449         if (scalar(@$S) &gt; 1) {
3450             my $d = GetDistinguishingArgumentIndex($operation, $S);
3451             push(@implContent, &quot;        JSValue distinguishingArg = state-&gt;uncheckedArgument($d);\n&quot;);
3452 
3453             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3454             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3455 
3456             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3457             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3458 
3459             for my $tuple (@{$S}) {
3460                 my $overload = @{$tuple}[0];
3461                 my $type = @{@{$tuple}[1]}[$d];
3462 
3463                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3464                 for my $subtype (@subtypes) {
3465                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3466                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3467                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3468                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3469                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3470                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3471                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3472                         } else {
3473                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3474                         }
3475                     }
3476                 }
3477             }
3478 
3479             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3480             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3481 
3482             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3483             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3484 
3485             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3486             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3487 
3488             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3489             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
3490             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(*state, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);
3491 
3492             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3493             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3494 
3495             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3496             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3497 
3498             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3499             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3500 
3501             # Fallbacks.
3502             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3503             if ($overload) {
3504                 &amp;$generateOverloadCallIfNecessary($overload);
3505             } elsif ($numericOverload) {
3506                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3507             } elsif ($booleanOverload) {
3508                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3509             } else {
3510                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3511                 &amp;$generateOverloadCallIfNecessary($overload);
3512             }
3513         } else {
3514             # Only 1 overload with this number of parameters.
3515             my $overload = @{@{$S}[0]}[0];
3516             &amp;$generateOverloadCallIfNecessary($overload);
3517         }
3518         push(@implContent, &lt;&lt;END);
3519     }
3520 END
3521     }
3522     my $minArgCount = GetFunctionLength($operation);
3523     if ($minArgCount &gt; 0) {
3524         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);\n&quot;)
3525     } else {
3526         push(@implContent, &quot;    return throwVMTypeError(state, throwScope);\n&quot;)
3527     }
3528 }
3529 
3530 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3531 sub GetFunctionLength
3532 {
3533     my $operation = shift;
3534 
3535     my $getOverloadLength = sub {
3536         my $operation = shift;
3537 
3538         my $length = 0;
3539         foreach my $argument (@{$operation-&gt;arguments}) {
3540             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3541             $length++;
3542         }
3543         return $length;
3544     };
3545 
3546     my $length = &amp;$getOverloadLength($operation);
3547     foreach my $overload (@{$operation-&gt;{overloads}}) {
3548         my $newLength = &amp;$getOverloadLength($overload);
3549         $length = $newLength if $newLength &lt; $length;
3550     }
3551     return $length;
3552 }
3553 
3554 sub LengthOfLongestOperationParameterList
3555 {
3556     my ($overloads) = @_;
3557     my $result = 0;
3558     foreach my $overload (@{$overloads}) {
3559         my @arguments = @{$overload-&gt;arguments};
3560         $result = @arguments if $result &lt; @arguments;
3561     }
3562     return $result;
3563 }
3564 
3565 # See http://refspecs.linux-foundation.org/cxxabi-1.83.html.
3566 sub GetGnuVTableRefForInterface
3567 {
3568     my $interface = shift;
3569     my $vtableName = GetGnuVTableNameForInterface($interface);
3570     if (!$vtableName) {
3571         return &quot;0&quot;;
3572     }
3573     my $typename = $interface-&gt;type-&gt;name;
3574     my $offset = GetGnuVTableOffsetForType($typename);
3575     return &quot;&amp;&quot; . $vtableName . &quot;[&quot; . $offset . &quot;]&quot;;
3576 }
3577 
3578 sub GetGnuVTableNameForInterface
3579 {
3580     my $interface = shift;
3581     my $typename = $interface-&gt;type-&gt;name;
3582     my $templatePosition = index($typename, &quot;&lt;&quot;);
3583     return &quot;&quot; if $templatePosition != -1;
3584     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3585     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3586     return &quot;_ZTV&quot; . GetGnuMangledNameForInterface($interface);
3587 }
3588 
3589 sub GetGnuMangledNameForInterface
3590 {
3591     my $interface = shift;
3592     my $typename = $interface-&gt;type-&gt;name;
3593     my $templatePosition = index($typename, &quot;&lt;&quot;);
3594     if ($templatePosition != -1) {
3595         return &quot;&quot;;
3596     }
3597     my $mangledType = length($typename) . $typename;
3598     my $namespace = &quot;WebCore&quot;;
3599     my $mangledNamespace =  &quot;N&quot; . length($namespace) . $namespace;
3600     return $mangledNamespace . $mangledType . &quot;E&quot;;
3601 }
3602 
3603 sub GetGnuVTableOffsetForType
3604 {
3605     my $typename = shift;
3606     if ($typename eq &quot;ApplePaySession&quot;
3607         || $typename eq &quot;SVGAElement&quot;
3608         || $typename eq &quot;SVGCircleElement&quot;
3609         || $typename eq &quot;SVGClipPathElement&quot;
3610         || $typename eq &quot;SVGDefsElement&quot;
3611         || $typename eq &quot;SVGEllipseElement&quot;
3612         || $typename eq &quot;SVGForeignObjectElement&quot;
3613         || $typename eq &quot;SVGGElement&quot;
3614         || $typename eq &quot;SVGImageElement&quot;
3615         || $typename eq &quot;SVGLineElement&quot;
3616         || $typename eq &quot;SVGPathElement&quot;
3617         || $typename eq &quot;SVGPolyElement&quot;
3618         || $typename eq &quot;SVGPolygonElement&quot;
3619         || $typename eq &quot;SVGPolylineElement&quot;
3620         || $typename eq &quot;SVGRectElement&quot;
3621         || $typename eq &quot;SVGSVGElement&quot;
3622         || $typename eq &quot;SVGGeometryElement&quot;
3623         || $typename eq &quot;SVGGraphicsElement&quot;
3624         || $typename eq &quot;SVGSwitchElement&quot;
3625         || $typename eq &quot;SVGTextElement&quot;
3626         || $typename eq &quot;SVGUseElement&quot;) {
3627         return &quot;3&quot;;
3628     }
3629     return &quot;2&quot;;
3630 }
3631 
3632 # See http://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B_Name_Mangling.
3633 sub GetWinVTableRefForInterface
3634 {
3635     my $interface = shift;
3636     my $vtableName = GetWinVTableNameForInterface($interface);
3637     return 0 if !$vtableName;
3638     return &quot;__identifier(\&quot;&quot; . $vtableName . &quot;\&quot;)&quot;;
3639 }
3640 
3641 sub GetWinVTableNameForInterface
3642 {
3643     my $interface = shift;
3644     my $typename = $interface-&gt;type-&gt;name;
3645     my $templatePosition = index($typename, &quot;&lt;&quot;);
3646     return &quot;&quot; if $templatePosition != -1;
3647     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3648     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3649     return &quot;??_7&quot; . GetWinMangledNameForInterface($interface) . &quot;6B@&quot;;
3650 }
3651 
3652 sub GetWinMangledNameForInterface
3653 {
3654     my $interface = shift;
3655     my $typename = $interface-&gt;type-&gt;name;
3656     my $namespace = &quot;WebCore&quot;;
3657     return $typename . &quot;@&quot; . $namespace . &quot;@@&quot;;
3658 }
3659 
3660 sub GetImplementationLacksVTableForInterface
3661 {
3662     my $interface = shift;
3663     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3664 }
3665 
3666 sub GetSkipVTableValidationForInterface
3667 {
3668     my $interface = shift;
3669     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3670 }
3671 
3672 # URL becomes url, but SetURL becomes setURL.
3673 sub ToMethodName
3674 {
3675     my $param = shift;
3676     my $ret = lcfirst($param);
3677     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3678     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3679     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
3680     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3681     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3682     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3683     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3684 
3685     # For HTML5 FileSystem API Flags attributes.
3686     # (create is widely used to instantiate an object and must be avoided.)
3687     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3688     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3689 
3690     return $ret;
3691 }
3692 
3693 sub GenerateRuntimeEnableConditionalStringForExposed
3694 {
3695     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3696 
3697     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3698 
3699     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3700 
3701     my $exposed = $context-&gt;extendedAttributes-&gt;{Exposed};
3702     if (ref($exposed) eq &#39;ARRAY&#39;) {
3703         if (scalar(@$exposed) &gt; 1) {
3704             return;
3705         }
3706         $exposed = @$exposed[0];
3707     }
3708 
3709     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3710 
3711     if ($exposed eq &quot;Window&quot;) {
3712         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3713     } elsif ($exposed eq &quot;Worker&quot;) {
3714         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3715     } elsif ($exposed eq &quot;Worklet&quot;) {
3716         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3717     } else {
3718         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3719     }
3720 }
3721 
3722 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3723 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3724 # true or its EnabledForWorld function returns true (or both).
3725 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3726 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3727 sub GenerateRuntimeEnableConditionalString
3728 {
3729     my ($interface, $context, $globalObjectIsParam) = @_;
3730 
3731     my @conjuncts;
3732     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3733     
3734     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3735         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3736 
3737         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3738             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3739                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3740         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3741             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3742                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3743         } else {
3744             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3745         }
3746     } else {
3747         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3748             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3749 
3750             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3751         }
3752     }
3753 
3754     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
3755         GenerateRuntimeEnableConditionalStringForExposed($interface, $context, \@conjuncts);
3756     }
3757 
3758     if ($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) {
3759         assert(&quot;Must specify value for EnabledForWorld.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledForWorld} eq &quot;VALUE_IS_MISSING&quot;;
3760 
3761         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3762 
3763         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3764     }
3765 
3766     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3767         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3768 
3769         AddToImplIncludes(&quot;Document.h&quot;);
3770         AddToImplIncludes(&quot;Settings.h&quot;);
3771 
3772         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3773 
3774         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3775         foreach my $flag (@flags) {
3776             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3777         }
3778     }
3779 
<a name="37" id="anc37"></a><span class="line-added">3780     if ($context-&gt;extendedAttributes-&gt;{CustomEnabled}) {</span>
<span class="line-added">3781         assert(&quot;CustomEnabled can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;</span>
<span class="line-added">3782 </span>
<span class="line-added">3783         my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;</span>
<span class="line-added">3784         push(@conjuncts, &quot;${className}&quot; . $codeGenerator-&gt;WK_ucfirst($context-&gt;name) . &quot;IsEnabled()&quot;);</span>
<span class="line-added">3785     }</span>
<span class="line-added">3786 </span>
3787     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3788         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3789 
3790         AddToImplIncludes(&quot;Document.h&quot;);
3791         AddToImplIncludes(&quot;Quirks.h&quot;);
3792 
3793         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3794 
3795         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3796         foreach my $flag (@flags) {
3797             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3798         }
3799     }
3800 
3801     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3802         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3803 
3804         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3805 
3806         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3807         foreach my $flag (@flags) {
3808             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3809         }
3810     }
3811 
<a name="38" id="anc38"></a><span class="line-added">3812     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {</span>
<span class="line-added">3813         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="line-added">3814         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);</span>
<span class="line-added">3815 </span>
<span class="line-added">3816         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;</span>
<span class="line-added">3817         my $name = $context-&gt;name;</span>
<span class="line-added">3818         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);</span>
<span class="line-added">3819     }</span>
<span class="line-added">3820 </span>
3821     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3822     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3823     return $result;
3824 }
3825 
3826 sub GetCastingHelperForThisObject
3827 {
3828     my $interface = shift;
3829     my $interfaceName = $interface-&gt;type-&gt;name;
3830     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3831 }
3832 
3833 # http://heycam.github.io/webidl/#Unscopable
3834 sub addUnscopableProperties
3835 {
3836     my $interface = shift;
3837 
3838     my @unscopables;
3839     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3840         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3841     }
3842     return if scalar(@unscopables) == 0;
3843 
3844     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3845     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3846     foreach my $unscopable (@unscopables) {
<a name="39" id="anc39"></a><span class="line-modified">3847         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);</span>
3848     }
3849     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3850 }
3851 
<a name="40" id="anc40"></a><span class="line-modified">3852 sub GetArgumentTypeForFunctionWithoutTypeCheck</span>
3853 {
3854     my ($interface, $type) = @_;
3855 
3856     my $IDLType = GetIDLType($interface, $type);
3857     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3858 }
3859 
3860 sub GetArgumentTypeFilter
3861 {
3862     my ($interface, $type) = @_;
3863 
3864     my $IDLType = GetIDLType($interface, $type);
3865     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3866 }
3867 
3868 sub GetResultTypeFilter
3869 {
3870     my ($interface, $type) = @_;
3871 
3872     my $IDLType = GetIDLType($interface, $type);
3873     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3874 }
3875 
3876 sub GetAttributeWithName
3877 {
3878     my ($interface, $attributeName) = @_;
3879     
3880     foreach my $attribute (@{$interface-&gt;attributes}) {
3881         return $attribute if $attribute-&gt;name eq $attributeName;
3882     }
3883 }
3884 
3885 # https://heycam.github.io/webidl/#es-iterator
3886 sub InterfaceNeedsIterator
3887 {
3888     my ($interface) = @_;
3889 
3890     # FIXME: This should return 1 for setlike once we support it.
3891     return 1 if $interface-&gt;mapLike;
3892     return 1 if $interface-&gt;iterable;
3893 
3894     if (GetIndexedGetterOperation($interface)) {
3895         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3896         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3897     }
3898     return 0;
3899 }
3900 
3901 sub GenerateImplementation
3902 {
3903     my ($object, $interface, $enumerations, $dictionaries) = @_;
3904 
3905     my $interfaceName = $interface-&gt;type-&gt;name;
3906     my $className = &quot;JS$interfaceName&quot;;
3907 
3908     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3909     my $parentClassName = GetParentClassName($interface);
3910     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3911     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3912 
3913     my $namedGetterOperation = GetNamedGetterOperation($interface);
3914     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3915 
3916     # - Add default header template
3917     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3918 
3919     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3920     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3921     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3922     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3923     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3924     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3925     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3926     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
3927     AddJSBuiltinIncludesIfNeeded($interface);
3928 
3929     my $implType = GetImplClassName($interface);
3930 
3931     @implContent = ();
3932 
3933     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3934     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3935 
3936     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3937     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3938 
3939     my @operations = @{$interface-&gt;operations};
3940     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3941     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3942     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3943 
3944     my @attributes = @{$interface-&gt;attributes};
3945     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3946 
3947     my $numConstants = @{$interface-&gt;constants};
3948     my $numOperations = @operations;
3949     my $numAttributes = @attributes;
3950 
3951     if ($numOperations &gt; 0) {
3952         my $inAppleCopyright = 0;
3953         push(@implContent,&quot;// Functions\n\n&quot;);
3954         foreach my $operation (@operations) {
3955             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3956             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3957             next if IsJSBuiltin($interface, $operation);
3958 
3959             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3960                 if (!$inAppleCopyright) {
3961                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
3962                     $inAppleCopyright = 1;
3963                 }
3964             } elsif ($inAppleCopyright) {
3965                 push(@implContent, $endAppleCopyright);
3966                 $inAppleCopyright = 0;
3967             }
3968 
3969             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
3970             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
3971             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3972             my $functionName = GetFunctionName($interface, $className, $operation);
3973             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);
3974             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3975                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
<a name="41" id="anc41"></a><span class="line-modified">3976                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
<span class="line-modified">3977                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState*, $className*&quot;;</span>
3978                 foreach my $argument (@{$operation-&gt;arguments}) {
3979                     my $type = $argument-&gt;type;
<a name="42" id="anc42"></a><span class="line-modified">3980                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);</span>
3981                     $functionSignature .= &quot;, ${argumentType}&quot;;
3982                 }
3983                 push(@implContent, $functionSignature . &quot;);\n&quot;);
3984             }
3985             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3986         }
3987 
3988         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
3989         push(@implContent, &quot;\n&quot;);
3990     }
3991 
3992     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3993         push(@implContent, &quot;// Attributes\n\n&quot;);
3994 
3995         if (NeedsConstructorProperty($interface)) {
3996             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3997             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3998 
3999             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4000             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4001         }
4002 
4003         foreach my $attribute (@attributes) {
4004             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4005             next if IsJSBuiltin($interface, $attribute);
4006 
4007             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4008             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4009             my $getter = GetAttributeGetterName($interface, $className, $attribute);
4010             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
4011             if (!IsReadonly($attribute)) {
4012                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4013                 if ($readWriteConditional) {
4014                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
4015                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
4016                 }
4017                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4018                 push(@implContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4019                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4020             }
4021             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4022         }
4023 
4024         push(@implContent, &quot;\n&quot;);
4025     }
4026 
4027     if ($numOperations &gt; 0) {
4028         foreach my $operation (@operations) {
4029             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4030             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4031             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4032 
4033             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4034             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4035             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4036 
4037             my $interfaceName = $interface-&gt;type-&gt;name;
4038             my $functionName = GetFunctionName($interface, $className, $operation);
<a name="43" id="anc43"></a><span class="line-modified">4039             my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
4040             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
4041             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
4042             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
<a name="44" id="anc44"></a><span class="line-modified">4043             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}(${nameOfFunctionWithoutTypeCheck},&quot;;</span>
4044             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
4045             foreach my $argument (@{$operation-&gt;arguments}) {
4046                 my $type = $argument-&gt;type;
4047                 my $argumentType = GetArgumentTypeFilter($interface, $type);
4048                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
4049             }
4050             $domJITSignatureFooter .= &quot;);&quot;;
4051             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4052             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4053             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
4054             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4055             push(@implContent, &quot;\n&quot;);
4056         }
4057     }
4058 
4059     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4060         foreach my $attribute (@attributes) {
4061             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4062             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4063 
4064             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4065             push(@implContent, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
4066             AddToImplIncludes(&quot;DOMJITIDLTypeFilter.h&quot;, $conditionalString);
4067             my $interfaceName = $interface-&gt;type-&gt;name;
4068             my $generatorName = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4069             my $domJITClassName = $generatorName . &quot;Attribute&quot;;
4070             my $getter = GetAttributeGetterName($interface, $generatorName, $attribute);
4071             my $resultType = &quot;JSC::SpecBytecodeTop&quot;;
4072             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4073                 $resultType = GetResultTypeFilter($interface, $attribute-&gt;type);
4074             }
4075             push(@implContent, &quot;static const JSC::DOMJIT::GetterSetter DOMJITAttributeFor${generatorName} {\n&quot;);
4076             push(@implContent, &quot;    $getter,\n&quot;);
4077             push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4078             push(@implContent, &quot;    &amp;compile${domJITClassName},\n&quot;);
4079             push(@implContent, &quot;#else\n&quot;);
4080             push(@implContent, &quot;    nullptr,\n&quot;);
4081             push(@implContent, &quot;#endif\n&quot;);
4082             push(@implContent, &quot;    $resultType\n&quot;);
4083             push(@implContent, &quot;};\n\n&quot;);
4084             push(@implContent, &quot;#endif\n\n&quot;) if $conditionalString;
4085         }
4086     }
4087 
4088     GeneratePrototypeDeclaration(\@implContent, $className, $interface) if !HeaderNeedsPrototypeDeclaration($interface);
4089 
4090     GenerateConstructorDeclaration(\@implContent, $className, $interface) if NeedsConstructorProperty($interface);
4091 
4092     my @hashKeys = ();
4093     my @hashValue1 = ();
4094     my @hashValue2 = ();
4095     my @hashSpecials = ();
4096     my %conditionals = ();
4097     my %readWriteConditionals = ();
4098     my $hashName = $className . &quot;Table&quot;;
4099     my @runtimeEnabledOperations = ();
4100     my @runtimeEnabledAttributes = ();
4101 
4102     # Generate hash table for properties on the instance.
4103     my $numInstanceProperties = GeneratePropertiesHashTable($object, $interface, 1, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4104     $object-&gt;GenerateHashTable($className, $hashName, $numInstanceProperties, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 0) if $numInstanceProperties &gt; 0;
4105 
4106     # - Add all interface object (aka constructor) properties (constants, static attributes, static operations).
4107     if (NeedsConstructorProperty($interface)) {
4108         my $hashSize = 0;
4109         my $hashName = $className . &quot;ConstructorTable&quot;;
4110 
4111         my @hashKeys = ();
4112         my @hashValue1 = ();
4113         my @hashValue2 = ();
4114         my @hashSpecials = ();
4115         my %conditionals = ();
4116         my %readWriteConditionals = ();
4117 
4118         my $needsConstructorTable = 0;
4119 
4120         foreach my $constant (@{$interface-&gt;constants}) {
4121             my $name = $constant-&gt;name;
4122             push(@hashKeys, $name);
4123             push(@hashValue1, $constant-&gt;value);
4124             push(@hashValue2, &quot;0&quot;);
4125             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4126 
4127             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
4128             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
4129 
4130             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4131             $conditionals{$name} = $conditional if $conditional;
4132 
4133             $hashSize++;
4134         }
4135 
4136         foreach my $attribute (@{$interface-&gt;attributes}) {
4137             next unless ($attribute-&gt;isStatic);
4138             my $name = $attribute-&gt;name;
4139             push(@hashKeys, $name);
4140 
4141             my @specials = ();
4142             push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
4143             push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
4144             push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
4145             push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4146             my $special = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
4147             push(@hashSpecials, $special);
4148 
4149             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4150                 push(@hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
4151             } else {
4152                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4153                 push(@hashValue1, $getter);
4154             }
4155 
4156             if (IsReadonly($attribute)) {
4157                 push(@hashValue2, &quot;0&quot;);
4158             } else {
4159                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4160                 push(@hashValue2, $setter);
4161             }
4162 
4163             my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4164             $conditionals{$name} = $conditional if $conditional;
4165 
4166             my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4167             $readWriteConditionals{$name} = $readWriteConditional if $readWriteConditional;
4168 
4169             $hashSize++;
4170         }
4171 
4172         foreach my $operation (@{$interface-&gt;operations}) {
4173             next unless ($operation-&gt;isStatic);
4174             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4175             my $name = $operation-&gt;name;
4176             push(@hashKeys, $name);
4177 
4178             my $functionName = GetFunctionName($interface, $className, $operation);
4179             push(@hashValue1, $functionName);
4180 
4181             my $functionLength = GetFunctionLength($operation);
4182             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4183                 push(@hashValue2, &quot;DOMJITFunctionFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
4184             } else {
4185                 push(@hashValue2, $functionLength);
4186             }
4187 
4188             push(@hashSpecials, ComputeFunctionSpecial($interface, $operation));
4189 
4190             my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
4191             $conditionals{$name} = $conditional if $conditional;
4192 
4193             $hashSize++;
4194         }
4195 
4196         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
4197 
4198         push(@implContent, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interface));
4199 
4200         my $protoClassName = &quot;${className}Prototype&quot;;
4201         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $visibleInterfaceName, $interface);
4202 
4203         my $namedConstructor = $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
4204         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $namedConstructor, $interface, &quot;GeneratingNamedConstructor&quot;) if $namedConstructor;
4205     }
4206 
4207     # - Add functions and constants to a hashtable definition
4208 
4209     $hashName = $className . &quot;PrototypeTable&quot;;
4210 
4211     @hashKeys = ();
4212     @hashValue1 = ();
4213     @hashValue2 = ();
4214     @hashSpecials = ();
4215     %conditionals = ();
4216     %readWriteConditionals = ();
4217     @runtimeEnabledOperations = ();
4218     @runtimeEnabledAttributes = ();
4219 
4220     # Generate hash table for properties on the prototype.
4221     my $numPrototypeProperties = GeneratePropertiesHashTable($object, $interface, 0,
4222         \@hashKeys, \@hashSpecials,
4223         \@hashValue1, \@hashValue2,
4224         \%conditionals, \%readWriteConditionals,
4225         \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4226 
4227     my $hashSize = $numPrototypeProperties;
4228 
4229     foreach my $constant (@{$interface-&gt;constants}) {
4230         my $name = $constant-&gt;name;
4231 
4232         push(@hashKeys, $name);
4233         push(@hashValue1, $constant-&gt;value);
4234         push(@hashValue2, &quot;0&quot;);
4235         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4236 
4237         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4238         $conditionals{$name} = $conditional if $conditional;
4239 
4240         $hashSize++;
4241     }
4242 
4243     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4244 
4245     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4246 
4247     if ($justGenerateValueArray) {
4248         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4249     } else {
4250         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4251     }
4252 
4253     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {
4254         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4255         push(@implContent, &quot;{\n&quot;);
4256         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4257         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4258 
4259         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4260         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4261 
4262         if (@runtimeEnabledProperties) {
4263             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4264         }
4265 
4266         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4267             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4268             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4269             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4270             my $name = $operationOrAttribute-&gt;name;
4271             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4272             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
<a name="45" id="anc45"></a><span class="line-modified">4273             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
4274             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4275             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);
4276             push(@implContent, &quot;    }\n&quot;);
4277             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4278         }
4279 
4280         if (@runtimeEnabledProperties) {
4281             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4282             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4283         }
4284 
4285         foreach my $operation (@{$interface-&gt;operations}) {
4286             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4287             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4288             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4289             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4290             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4291             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4292         }
4293 
4294         if (InterfaceNeedsIterator($interface)) {
4295             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
4296             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike) {
4297                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4298             } else {
4299                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4300                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4301             }
4302         }
4303         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4304 
4305         addUnscopableProperties($interface);
4306 
4307         push(@implContent, &quot;}\n\n&quot;);
4308     }
4309 
4310     # - Initialize static ClassInfo object
4311     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4312 
4313     if ($numInstanceProperties &gt; 0) {
4314         push(@implContent, &quot;&amp;${className}Table&quot;);
4315     } else {
4316         push(@implContent, &quot;nullptr&quot;);
4317     }
4318     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
4319         push(@implContent, &quot;\n&quot;);
4320         push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4321         push(@implContent, &quot;, &amp;checkSubClassSnippetFor${className}\n&quot;);
4322         push(@implContent, &quot;#else\n&quot;);
4323         push(@implContent, &quot;, nullptr\n&quot;);
4324         push(@implContent, &quot;#endif\n&quot;);
4325     } else {
4326         push(@implContent, &quot;, nullptr&quot;);
4327     }
4328     push(@implContent, &quot;, CREATE_METHOD_TABLE($className) };\n\n&quot;);
4329 
4330     # Constructor
4331     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4332         AddIncludesForImplementationTypeInImpl(&quot;JSWindowProxy&quot;);
4333         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
4334         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl), proxy)\n&quot;);
4335         push(@implContent, &quot;{\n&quot;);
4336         push(@implContent, &quot;}\n\n&quot;);
4337     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4338         AddIncludesForImplementationTypeInImpl($interfaceName);
4339         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4340         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl))\n&quot;);
4341         push(@implContent, &quot;{\n&quot;);
4342         push(@implContent, &quot;}\n\n&quot;);
4343     } elsif (!NeedsImplementationClass($interface)) {
4344         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4345         push(@implContent, &quot;    : $parentClassName(structure, globalObject) { }\n\n&quot;);
4346     } else {
4347         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4348         push(@implContent, &quot;    : $parentClassName(structure, globalObject, WTFMove(impl))\n&quot;);
4349         push(@implContent, &quot;{\n&quot;);
4350         push(@implContent, &quot;}\n\n&quot;);
4351     }
4352 
4353     # Finish Creation
4354     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4355         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4356         push(@implContent, &quot;{\n&quot;);
4357         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4358     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4359         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4360         push(@implContent, &quot;{\n&quot;);
4361         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4362     } else {
4363         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4364         push(@implContent, &quot;{\n&quot;);
4365         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4366         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4367     }
4368 
4369     if ($interfaceName eq &quot;Location&quot;) {
4370         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4371         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4372     }
4373 
4374     if ($interface-&gt;mapLike) {
4375         push(@implContent, &quot;    synchronizeBackingMap(*globalObject()-&gt;globalExec(), *globalObject(), *this);\n&quot;);
4376     }
4377 
4378     # Support for RuntimeEnabled attributes on instances.
4379     foreach my $attribute (@{$interface-&gt;attributes}) {
4380         next unless NeedsRuntimeCheck($interface, $attribute);
4381         next unless AttributeShouldBeOnInstance($interface, $attribute);
4382 
4383         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4384         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4385         my $attributeName = $attribute-&gt;name;
4386         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4387         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4388         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4389 
4390         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4391         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4392         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4393         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4394         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4395     }
4396 
4397     # Support PrivateIdentifier attributes on instances.
4398     foreach my $attribute (@{$interface-&gt;attributes}) {
4399         next unless $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier};
4400         next unless AttributeShouldBeOnInstance($interface, $attribute);
4401 
4402         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4403         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4404         my $attributeName = $attribute-&gt;name;
4405         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4406 
4407         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4408         push(@implContent, &quot;    putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PrivateName(), CustomGetterSetter::create(vm, $getter, nullptr), attributesForStructure(JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly));\n&quot;);
4409         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4410     }
4411 
4412     # Support for RuntimeEnabled operations on instances.
4413     foreach my $operation (@{$interface-&gt;operations}) {
4414         next unless NeedsRuntimeCheck($interface, $operation);
4415         next unless OperationShouldBeOnInstance($interface, $operation);
4416         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4417 
4418         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4419         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation);
4420         my $functionName = $operation-&gt;name;
4421         my $implementationFunction = GetFunctionName($interface, $className, $operation);
4422         my $functionLength = GetFunctionLength($operation);
4423         my $jsAttributes = ComputeFunctionSpecial($interface, $operation);
4424 
4425         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4426         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4427         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4428         my $propertyName = &quot;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $functionName . ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} ? &quot;PrivateName()&quot; : &quot;PublicName()&quot;);
4429         if (IsJSBuiltin($interface, $operation)) {
4430             push(@implContent, &quot;        putDirectBuiltinFunction(vm, this, $propertyName, $implementationFunction(vm), attributesForStructure($jsAttributes));\n&quot;);
4431         } else {
4432             push(@implContent, &quot;        putDirectNativeFunction(vm, this, $propertyName, $functionLength, $implementationFunction, NoIntrinsic, attributesForStructure($jsAttributes));\n&quot;);
4433         }
4434         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4435     }
4436     push(@implContent, &quot;}\n\n&quot;);
4437 
4438     unless (ShouldUseGlobalObjectPrototype($interface)) {
4439         push(@implContent, &quot;JSObject* ${className}::createPrototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4440         push(@implContent, &quot;{\n&quot;);
4441         if ($interface-&gt;parentType) {
4442             my $parentClassNameForPrototype = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
4443             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, ${parentClassNameForPrototype}::prototype(vm, globalObject)));\n&quot;);
4444         } else {
4445             my $prototype = $interface-&gt;isException ? &quot;errorPrototype&quot; : &quot;objectPrototype&quot;;
4446             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, globalObject.${prototype}()));\n&quot;);
4447         }
4448         push(@implContent, &quot;}\n\n&quot;);
4449 
4450         push(@implContent, &quot;JSObject* ${className}::prototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4451         push(@implContent, &quot;{\n&quot;);
4452         push(@implContent, &quot;    return getDOMPrototype&lt;${className}&gt;(vm, globalObject);\n&quot;);
4453         push(@implContent, &quot;}\n\n&quot;);
4454     }
4455 
4456     if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4457         push(@implContent, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
4458         push(@implContent, &quot;{\n&quot;);
4459         push(@implContent, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4460         push(@implContent, &quot;}\n\n&quot;);
4461 
4462         if ($interface-&gt;extendedAttributes-&gt;{NamedConstructor}) {
4463             push(@implContent, &quot;JSValue ${className}::getNamedConstructor(VM&amp; vm, JSGlobalObject* globalObject)\n&quot;);
4464             push(@implContent, &quot;{\n&quot;);
4465             push(@implContent, &quot;    return getDOMConstructor&lt;${className}NamedConstructor&gt;(vm, *jsCast&lt;JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4466             push(@implContent, &quot;}\n\n&quot;);
4467         }
4468     }
4469 
4470     if (!$hasParent) {
4471         push(@implContent, &quot;void ${className}::destroy(JSC::JSCell* cell)\n&quot;);
4472         push(@implContent, &quot;{\n&quot;);
4473         push(@implContent, &quot;    ${className}* thisObject = static_cast&lt;${className}*&gt;(cell);\n&quot;);
4474         push(@implContent, &quot;    thisObject-&gt;${className}::~${className}();\n&quot;);
4475         push(@implContent, &quot;}\n\n&quot;);
4476     }
4477 
4478     if (InstanceOverridesGetOwnPropertySlot($interface)) {
4479         GenerateGetOwnPropertySlot(\@implContent, $interface, $className);
4480         GenerateGetOwnPropertySlotByIndex(\@implContent, $interface, $className);
4481     }
4482     
4483     if (InstanceOverridesGetOwnPropertyNames($interface)) {
4484         GenerateGetOwnPropertyNames(\@implContent, $interface, $className);
4485     }
4486     
4487     if (InstanceOverridesPut($interface)) {
4488         GeneratePut(\@implContent, $interface, $className);
4489         GeneratePutByIndex(\@implContent, $interface, $className);
4490     }
4491     
4492     if (InstanceOverridesDefineOwnProperty($interface)) {
4493         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4494     }
4495 
4496     if (InstanceOverridesDeleteProperty($interface)) {
4497         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4498     }
4499     
4500     if (InstanceOverridesGetCallData($interface)) {
4501         GenerateGetCallData(\@implContent, $interface, $className);
4502     }
4503     
4504     if ($numAttributes &gt; 0) {
4505         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4506 
4507         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4508         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4509         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4510             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4511             push(@implContent, &quot;{\n&quot;);
<a name="46" id="anc46"></a><span class="line-added">4512             push(@implContent, &quot;    VM&amp; vm = state.vm();\n&quot;);</span>
4513             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4514             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4515             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);
<a name="47" id="anc47"></a><span class="line-modified">4516             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);&quot;);</span>
4517             push(@implContent, &quot;}\n\n&quot;);
4518         } else {
4519             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);
4520             push(@implContent, &quot;{\n&quot;);
4521             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);
4522             push(@implContent, &quot;}\n\n&quot;);
4523         }
4524     }
4525 
4526     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4527         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4528 
4529         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4530         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4531         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;
4532         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);
4533         push(@implContent, &quot;{\n&quot;);
4534         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);
4535         push(@implContent, &quot;}\n\n&quot;);
4536     }
4537 
4538     if (NeedsConstructorProperty($interface)) {
4539         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4540 
4541         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);
4542         push(@implContent, &quot;{\n&quot;);
4543         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
4544         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4545         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4546         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
4547         push(@implContent, &quot;        return throwVMTypeError(state, throwScope);\n&quot;);
4548 
4549         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4550             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(state-&gt;vm(), prototype-&gt;globalObject()));\n&quot;);
4551         } else {
4552             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(state-&gt;vm(), ${className}Constructor::createStructure(state-&gt;vm(), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);
4553             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4554             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4555             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4556         }
4557         push(@implContent, &quot;}\n\n&quot;);
4558 
4559         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4560 
4561         push(@implContent, &quot;bool ${constructorSetter}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
4562         push(@implContent, &quot;{\n&quot;);
4563         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
4564         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4565         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4566         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
4567         push(@implContent, &quot;        throwVMTypeError(state, throwScope);\n&quot;);
4568         push(@implContent, &quot;        return false;\n&quot;);
4569         push(@implContent, &quot;    }\n&quot;);
4570         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4571         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4572         push(@implContent, &quot;}\n\n&quot;);
4573 
4574     }
4575 
4576     foreach my $attribute (@attributes) {
4577         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4578         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4579     }
4580 
4581     foreach my $operation (@operations) {
4582         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4583     }
4584     
4585     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4586     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4587 
4588     if ($needsVisitChildren) {
4589         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4590         push(@implContent, &quot;{\n&quot;);
4591         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4592         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4593         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4594         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4595         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4596             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4597             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4598                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4599                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4600                 push(@implContent, &quot;#endif\n&quot;);
4601             }
4602         }
4603         if ($numCachedAttributes &gt; 0) {
4604             foreach my $attribute (@{$interface-&gt;attributes}) {
4605                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4606                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4607                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4608                     push(@implContent, &quot;    visitor.append(thisObject-&gt;m_&quot; . $attribute-&gt;name . &quot;);\n&quot;);
4609                     push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4610                 }
4611             }
4612         }
4613         push(@implContent, &quot;}\n\n&quot;);
4614         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4615             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4616             push(@implContent, &quot;{\n&quot;);
4617             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4618             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4619             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4620             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4621             push(@implContent, &quot;}\n\n&quot;);
4622         }
4623     }
4624 
4625     if (InstanceNeedsEstimatedSize($interface)) {
4626         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4627         push(@implContent, &quot;{\n&quot;);
4628         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4629         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4630         push(@implContent, &quot;}\n\n&quot;);
4631     }
4632 
4633     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
<a name="48" id="anc48"></a><span class="line-modified">4634         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapAnalyzer.h&gt;&quot;);</span>
4635         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4636         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
<a name="49" id="anc49"></a><span class="line-modified">4637         push(@implContent, &quot;void ${className}::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)\n&quot;);</span>
4638         push(@implContent, &quot;{\n&quot;);
4639         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
<a name="50" id="anc50"></a><span class="line-modified">4640         push(@implContent, &quot;    analyzer.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);</span>
4641         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
<a name="51" id="anc51"></a><span class="line-modified">4642         push(@implContent, &quot;        analyzer.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);</span>
<span class="line-modified">4643         push(@implContent, &quot;    Base::analyzeHeap(cell, analyzer);\n&quot;);</span>
4644         push(@implContent, &quot;}\n\n&quot;);
4645     }
4646 
4647     if ($indexedGetterOperation) {
4648         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4649         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4650             $implIncludes{&quot;JSNode.h&quot;} = 1;
4651             $implIncludes{&quot;Node.h&quot;} = 1;
4652         }
4653     }
4654 
4655     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4656         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4657         push(@implContent, &quot;{\n&quot;);
4658         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4659         # increment their C++ reference counts when hasPendingActivity() becomes
4660         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4661         # their pending activities complete. To wallpaper over this bug, JavaScript
4662         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4663         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
4664         # check just above the (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) check below.
4665         my $emittedJSCast = 0;
4666         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4667             push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4668             $emittedJSCast = 1;
4669             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().hasPendingActivity()) {\n&quot;);
4670             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4671             push(@implContent, &quot;            *reason = \&quot;ActiveDOMObject with pending activity\&quot;;\n&quot;);
4672             push(@implContent, &quot;        return true;\n&quot;);
4673             push(@implContent, &quot;     }\n&quot;);
4674         }
4675         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;EventTarget&quot;)) {
4676             if (!$emittedJSCast) {
4677                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4678                 $emittedJSCast = 1;
4679             }
4680             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().isFiringEventListeners()) {\n&quot;);
4681             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4682             push(@implContent, &quot;            *reason = \&quot;EventTarget firing event listeners\&quot;;\n&quot;);
4683             push(@implContent, &quot;        return true;\n&quot;);
4684             push(@implContent, &quot;    }\n&quot;);
4685         }
4686         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
4687             if (!$emittedJSCast) {
4688                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4689                 $emittedJSCast = 1;
4690             }
4691             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4692             push(@implContent, &quot;        return true;\n&quot;);
4693         }
4694         if (GetGenerateIsReachable($interface)) {
4695             if (!$emittedJSCast) {
4696                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4697                 $emittedJSCast = 1;
4698             }
4699 
4700             my $rootString;
4701             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4702                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4703                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4704                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4705             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4706                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4707                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4708                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
<a name="52" id="anc52"></a><span class="line-modified">4709             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromDOMWindow&quot;) {</span>
<span class="line-modified">4710                 $rootString  = &quot;    auto* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().window());\n&quot;;</span>
4711                 $rootString .= &quot;    if (!root)\n&quot;;
4712                 $rootString .= &quot;        return false;\n&quot;;
4713                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
<a name="53" id="anc53"></a><span class="line-modified">4714                 $rootString .= &quot;        *reason = \&quot;Reachable from Window\&quot;;\n&quot;;</span>
<span class="line-added">4715             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromNavigator&quot;) {</span>
<span class="line-added">4716                 $implIncludes{&quot;Navigator.h&quot;} = 1;</span>
<span class="line-added">4717                 $implIncludes{&quot;WorkerNavigator.h&quot;} = 1;</span>
<span class="line-added">4718                 $rootString  = &quot;    NavigatorBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().navigator());\n&quot;;</span>
<span class="line-added">4719                 $rootString .= &quot;    if (!root)\n&quot;;</span>
<span class="line-added">4720                 $rootString .= &quot;        return false;\n&quot;;</span>
<span class="line-added">4721                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;</span>
<span class="line-added">4722                 $rootString .= &quot;        *reason = \&quot;Reachable from Navigator\&quot;;\n&quot;;</span>
4723             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4724                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4725                 $rootString .= &quot;    if (!root)\n&quot;;
4726                 $rootString .= &quot;        return false;\n&quot;;
4727                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4728                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4729             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4730                 $implIncludes{&quot;Element.h&quot;} = 1;
4731                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4732                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4733                 $rootString .= &quot;    if (!element)\n&quot;;
4734                 $rootString .= &quot;        return false;\n&quot;;
4735                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4736                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4737                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4738             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4739                 $implIncludes{&quot;Element.h&quot;} = 1;
4740                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4741                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4742                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4743                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4744             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4745                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4746                 $rootString .= &quot;    if (!root)\n&quot;;
4747                 $rootString .= &quot;        return false;\n&quot;;
4748                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4749                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4750             } else {
4751                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4752                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4753                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4754             }
4755 
4756             push(@implContent, $rootString);
<a name="54" id="anc54"></a><span class="line-modified">4757             push(@implContent, &quot;    return visitor.containsOpaqueRoot(root);\n&quot;);</span>
4758         } else {
4759             if (!$emittedJSCast) {
4760                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4761             }
4762             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4763             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4764             push(@implContent, &quot;    return false;\n&quot;);
4765         }
4766         push(@implContent, &quot;}\n\n&quot;);
4767     }
4768 
4769     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4770         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4771         push(@implContent, &quot;{\n&quot;);
4772         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4773         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4774         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4775         push(@implContent, &quot;}\n\n&quot;);
4776     }
4777 
4778     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4779         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4780         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4781         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4782 
4783         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4784 #if ENABLE(BINDING_INTEGRITY)
4785 #if PLATFORM(WIN)
4786 #pragma warning(disable: 4483)
4787 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4788 #else
4789 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4790 #endif
4791 #endif
4792 
4793 END
4794 
4795         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4796         push(@implContent, &quot;{\n&quot;);
4797         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4798 
4799 #if ENABLE(BINDING_INTEGRITY)
4800     void* actualVTablePointer = *(reinterpret_cast&lt;void**&gt;(impl.ptr()));
4801 #if PLATFORM(WIN)
4802     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefWin});
4803 #else
4804     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefGnu});
4805 #endif
4806 
4807     // If this fails ${implType} does not have a vtable, so you need to add the
4808     // ImplementationLacksVTable attribute to the interface definition
4809     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4810 
4811     // If you hit this assertion you either have a use after free bug, or
4812     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4813     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4814     // by adding the SkipVTableValidation attribute to the interface IDL definition
4815     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4816 #endif
4817 END
4818         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4819     // If you hit this failure the interface definition has the ImplementationLacksVTable
4820     // attribute. You should remove that attribute. If the class has subclasses
4821     // that may be passed through this toJS() function you should use the SkipVTableValidation
4822     // attribute to $interfaceName.
4823     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4824 END
4825         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4826     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4827 END
4828 
4829         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4830         push(@implContent, &quot;}\n\n&quot;);
4831 
4832         push(@implContent, &quot;JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);
4833         push(@implContent, &quot;{\n&quot;);
4834         push(@implContent, &quot;    return wrap(state, globalObject, impl);\n&quot;);
4835         push(@implContent, &quot;}\n\n&quot;);
4836     }
4837 
4838     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4839         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4840         push(@implContent, &quot;{\n&quot;);
4841         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4842         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4843         push(@implContent, &quot;    return nullptr;\n&quot;);
4844         push(@implContent, &quot;}\n&quot;);
4845     }
4846 
4847     push(@implContent, &quot;\n}\n&quot;);
4848 
4849     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4850     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4851 }
4852 
4853 sub GenerateAttributeGetterBodyDefinition
4854 {
4855     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4856     
4857     my @signatureArguments = ();
4858     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4859     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4860     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4861     
4862     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4863     push(@$outputArray, &quot;{\n&quot;);
4864     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4865     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
4866 
4867     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4868         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4869         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4870         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4871         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4872             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4873         } else {
4874             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4875         }
4876         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4877     }
4878     
4879     if (HasCustomGetter($attribute)) {
4880         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
4881         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(state);\n&quot;);
4882     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4883         $implIncludes{&quot;EventNames.h&quot;} = 1;
4884         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4885             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4886             : &quot;eventHandlerAttribute&quot;;
4887         my $eventName = EventHandlerAttributeEventName($attribute);
4888         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4889     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4890         my $constructorType = $attribute-&gt;type-&gt;name;
4891         $constructorType =~ s/Constructor$//;
4892         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4893         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4894         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4895             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4896             $constructorType =~ s/Named$//;
4897             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(state.vm(), &amp;thisObject);\n&quot;);
4898         } else {
4899             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4900             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(state.vm(), thisObject.globalObject());\n&quot;);
4901         }
4902     } else {
4903         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4904             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4905             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4906         }
4907         
4908         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4909         
4910         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4911         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
4912         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
4913         
4914         unshift(@arguments, @callWithArgs);
4915 
4916         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
4917         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
4918         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike;
4919 
4920         if (!IsReadonly($attribute)) {
4921             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
4922             if ($callTracingCallback) {
4923                 my @callTracerArguments = ();
4924                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
4925             }
4926         }
4927 
4928         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
4929         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(state.vm(), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
4930         push(@$outputArray, &quot;    return result;\n&quot;);
4931     }
4932     push(@$outputArray, &quot;}\n\n&quot;);
4933 }
4934 
4935 sub GenerateAttributeGetterTrampolineDefinition
4936 {
4937     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
4938     
4939     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
4940     
4941     my $callAttributeGetterName = &quot;get&quot;;
4942     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
4943     
4944     my @templateParameters = ();
4945     push(@templateParameters, $attributeGetterBodyName);
4946     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
4947         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
4948     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
4949         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
4950     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
4951         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
4952     }
4953     
4954     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);
4955     push(@$outputArray, &quot;{\n&quot;);
4956     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);
4957     push(@$outputArray, &quot;}\n\n&quot;);
4958 }
4959 
4960 sub GenerateAttributeGetterDefinition
4961 {
4962     my ($outputArray, $interface, $className, $attribute) = @_;
4963 
4964     return if IsJSBuiltin($interface, $attribute);
4965 
4966     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
4967     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
4968     
4969     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4970     if ($conditional) {
4971         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
4972         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
4973     }
4974     
4975     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
4976     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
4977     
4978     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
4979 }
4980 
4981 sub GenerateAttributeSetterBodyDefinition
4982 {
4983     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
4984 
4985     my @signatureArguments = ();
4986     push(@signatureArguments, &quot;ExecState&amp; state&quot;);
4987     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4988     push(@signatureArguments, &quot;JSValue value&quot;);
4989     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4990     
4991     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4992     push(@$outputArray, &quot;{\n&quot;);
<a name="55" id="anc55"></a><span class="line-modified">4993     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="line-added">4994     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {</span>
<span class="line-added">4995         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);</span>
<span class="line-added">4996     } else {</span>
<span class="line-added">4997         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);</span>
<span class="line-added">4998     }</span>
4999 
5000     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);
5001 
5002     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5003         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5004         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5005             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
5006         } else {
5007             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
5008         }
5009         push(@$outputArray, &quot;        return false;\n&quot;);
5010     }
5011     
5012     if (HasCustomSetter($attribute)) {
5013         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
5014         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);
5015         push(@$outputArray, &quot;    return true;\n&quot;);
5016     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5017         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5018         my $eventName = EventHandlerAttributeEventName($attribute);
5019         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
5020         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
5021             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
5022             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
5023         } else {
5024             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5025             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5026                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5027                 : &quot;setEventHandlerAttribute&quot;;
5028             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
5029         }
5030         push(@$outputArray, &quot;    return true;\n&quot;);
5031     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5032         my $constructorType = $attribute-&gt;type-&gt;name;
5033         $constructorType =~ s/Constructor$//;
5034         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5035         # We do not generate the header file for NamedConstructor of class XXXX,
5036         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5037         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5038             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5039         }
5040         my $id = $attribute-&gt;name;
5041         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
<a name="56" id="anc56"></a><span class="line-modified">5042         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5043     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5044         my $id = $attribute-&gt;name;
5045         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5046         if (AttributeShouldBeOnInstance($interface, $attribute)) {
<a name="57" id="anc57"></a><span class="line-modified">5047             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5048         } else {
<a name="58" id="anc58"></a><span class="line-modified">5049             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);</span>
5050         }
5051     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5052         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5053         
5054         # 3.5.9.1. Let Q be ? Get(O, id).
5055         my $id = $attribute-&gt;name;
<a name="59" id="anc59"></a><span class="line-modified">5056         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);</span>
5057         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);
5058         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5059         
5060         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5061         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
5062         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);
5063         push(@$outputArray, &quot;        return false;\n&quot;);
5064         push(@$outputArray, &quot;    }\n&quot;);
5065         
5066         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5067         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
<a name="60" id="anc60"></a><span class="line-modified">5068         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);</span>
5069         
5070         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5071         # FIXME: What should the second value to the PutPropertySlot be?
5072         # (https://github.com/heycam/webidl/issues/368)
5073         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<a name="61" id="anc61"></a><span class="line-modified">5074         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);</span>
5075         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5076         
5077         push(@$outputArray, &quot;    return true;\n&quot;);
5078     } else {
5079         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5080        
5081         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5082             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5083             # the standard conversion, but rather silently fail on invalid enumeration values.
5084             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);
5085             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5086             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5087             push(@$outputArray, &quot;        return false;\n&quot;);
5088             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5089         } else {
5090             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;
5091             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5092 
5093             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5094             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5095             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5096         }
5097 
5098         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5099 
5100         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5101 
5102         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5103         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);
5104 
5105         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5106         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5107 
5108         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5109         if ($callTracingCallback) {
5110             my $indent = &quot;    &quot;;
<a name="62" id="anc62"></a><span class="line-modified">5111             my @callTracerArguments = (&quot;nativeValue&quot;);</span>

5112             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5113         }
5114 
5115         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5116         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);
5117         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5118         push(@$outputArray, &quot;    });\n&quot;);
5119         push(@$outputArray, &quot;    return true;\n&quot;);
5120     }
5121     push(@$outputArray, &quot;}\n\n&quot;);
5122 }
5123 
5124 sub GenerateAttributeSetterTrampolineDefinition
5125 {
5126     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5127     
5128     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5129     
5130     my $callAttributeSetterName = &quot;set&quot;;
5131     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5132     
5133     my @templateParameters = ();
5134     push(@templateParameters, $attributeSetterBodyName);
5135     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5136     
5137     push(@$outputArray, &quot;bool ${attributeSetterName}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
5138     push(@$outputArray, &quot;{\n&quot;);
5139     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);
5140     push(@$outputArray, &quot;}\n\n&quot;);
5141 }
5142 
5143 sub GenerateAttributeSetterDefinition
5144 {
5145     my ($outputArray, $interface, $className, $attribute) = @_;
5146     
5147     return if IsReadonly($attribute);
5148     return if IsJSBuiltin($interface, $attribute);
5149     
5150     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5151     if ($conditional) {
5152         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5153         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5154     }
5155 
5156     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5157     if ($readWriteConditional) {
5158         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5159         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5160     }
5161 
5162     my $attributeSetterName = GetAttributeSetterName($interface, $className, $attribute);
5163     my $attributeSetterBodyName = $attributeSetterName . &quot;Setter&quot;;
5164     
5165     GenerateAttributeSetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional);
5166     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5167 
5168     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5169     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5170 }
5171 
5172 sub GenerateOperationTrampolineDefinition
5173 {
5174     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5175 
5176     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5177     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5178     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5179 
5180     my $callFunctionName = &quot;call&quot;;
5181     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5182     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5183 
5184     my @callFunctionTemplateArguments = ();
5185     push(@callFunctionTemplateArguments, $functionBodyName);
5186     push(@callFunctionTemplateArguments, &quot;PromiseExecutionScope::${exposureScope}&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5187     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5188 
5189     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(ExecState* state)\n&quot;);
5190     push(@$outputArray, &quot;{\n&quot;);
5191     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*state, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);
5192     push(@$outputArray, &quot;}\n\n&quot;);
5193 }
5194 
5195 sub GenerateOperationBodyDefinition
5196 {
5197     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $generatingOverloadDispatcher) = @_;
5198 
5199     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5200     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5201     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5202 
5203     my @signatureArguments = ();
5204     push(@signatureArguments, &quot;JSC::ExecState* state&quot;);
5205     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5206     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5207     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5208 
5209     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5210     push(@$outputArray, &quot;{\n&quot;);
5211     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5212     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5213 
5214     if (!$generatingOverloadDispatcher) {
5215         GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);
5216 
5217         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5218             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5219             
5220             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5221             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5222                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);
5223                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5224             } else {
5225                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);
5226                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5227             }
5228         }
5229     }
5230 
5231     my $indent = &quot;    &quot;;
5232 
5233     if ($generatingOverloadDispatcher) {
5234         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5235         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5236 
5237         my @argumentsToForward = ();
5238         push(@argumentsToForward, &quot;state&quot;);
5239         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5240         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5241         push(@argumentsToForward, &quot;throwScope&quot;);
5242 
5243         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5244     } elsif (HasCustomMethod($operation)) {
5245         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5246     } else {
5247         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isStatic) {
5248             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5249         }
5250 
5251         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5252         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5253 
5254         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5255             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5256             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5257             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5258         } else {
5259             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5260         }
5261     }
5262 
5263     push(@$outputArray, &quot;}\n\n&quot;);
5264 }
5265 
5266 sub GenerateOperationDefinition
5267 {
5268     my ($outputArray, $interface, $className, $operation) = @_;
5269 
5270     return if IsJSBuiltin($interface, $operation);
5271     return if $operation-&gt;isIterable;
5272     return if $operation-&gt;isSerializer;
5273 
5274     my $isCustom = HasCustomMethod($operation);
5275     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5276 
5277     assert(&quot;[Custom] is not supported for overloaded operations.&quot;) if $isCustom &amp;&amp; $isOverloaded;
5278 
5279     my $inAppleCopyright = 0;
5280 
5281     if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
5282         if (!$inAppleCopyright) {
5283             push(@$outputArray, $beginAppleCopyrightForSourceFiles);
5284             $inAppleCopyright = 1;
5285         }
5286     } elsif ($inAppleCopyright) {
5287         push(@$outputArray, $endAppleCopyright);
5288         $inAppleCopyright = 0;
5289     }
5290 
5291     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5292     if ($conditional) {
5293         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5294         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5295     }
5296 
5297     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5298 
5299     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5300     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5301     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5302 
5303     my $functionName = GetFunctionName($interface, $className, $operation);
5304     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5305     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5306 
5307     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName);
5308 
5309     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5310     # that gets generated after the last overload body has been generated.
5311     unless ($isOverloaded) {
5312         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5313     }
5314 
5315     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5316 
5317     # Generate a function dispatching call to the rest of the overloads.
5318     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5319         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5320         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5321         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5322 
5323         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5324         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);
5325         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5326     
5327         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5328     }
5329 
5330 
5331     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5332         if ($conditional) {
5333             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5334             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5335         }
5336 
5337         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
<a name="63" id="anc63"></a><span class="line-modified">5338         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;</span>
<span class="line-modified">5339         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState* state, $className* castedThis&quot;);</span>
5340         foreach my $argument (@{$operation-&gt;arguments}) {
5341             my $type = $argument-&gt;type;
<a name="64" id="anc64"></a><span class="line-modified">5342             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);</span>
5343             my $name = $argument-&gt;name;
5344             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5345             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5346         }
5347         push(@$outputArray, &quot;)\n&quot;);
5348         push(@$outputArray, &quot;{\n&quot;);
5349         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);
5350         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
<a name="65" id="anc65"></a><span class="line-modified">5351         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(vm, state);\n&quot;);</span>
5352         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5353         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5354         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5355         
5356         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5357         
5358         my @arguments = ();
5359         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5360         
5361         foreach my $argument (@{$operation-&gt;arguments}) {
5362             my $value = &quot;&quot;;
5363             my $type = $argument-&gt;type;
5364             my $name = $argument-&gt;name;
5365             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5366             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5367 
<a name="66" id="anc66"></a><span class="line-modified">5368             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});</span>
5369             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5370             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5371             $value = &quot;WTFMove($name)&quot;;
5372 
5373             if ($shouldPassByReference) {
5374                 $value = &quot;*$name&quot;;
5375             }
5376             push(@arguments, $value);
5377         }
5378         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5379         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5380         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5381         push(@$outputArray, &quot;}\n\n&quot;);
5382 
5383         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5384     }
5385 
5386     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5387 }
5388 
5389 sub GenerateSerializerDefinition
5390 {
5391     my ($interface, $className) = @_;
5392 
5393     my $interfaceName = $interface-&gt;type-&gt;name;
5394 
5395     my $parentSerializerInterface = 0;
5396     if ($interface-&gt;serializable-&gt;hasInherit) {
5397         $codeGenerator-&gt;ForAllParents($interface, sub {
5398             my $parentInterface = shift;
5399             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
5400                 $parentSerializerInterface = $parentInterface;
5401             }
5402         }, 0);
5403         die &quot;Failed to find parent interface with \&quot;serializer\&quot; for \&quot;inherit\&quot; serializer in $interfaceName\n&quot; if !$parentSerializerInterface;
5404     }
5405 
5406     my @serializedAttributes = ();
5407 
5408     foreach my $attributeName (@{$interface-&gt;serializable-&gt;attributes}) {
5409         my $foundAttribute = 0;
5410         foreach my $attribute (@{$interface-&gt;attributes}) {
5411             if ($attributeName eq $attribute-&gt;name) {
5412                 $foundAttribute = 1;
5413                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5414                     push(@serializedAttributes, $attribute);                
5415                     last;
5416                 }                    
5417                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5418                 last;
5419             }
5420         }
5421         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5422     }
5423 
5424     my $serializerFunctionName = &quot;toJSON&quot;;
5425     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5426 
5427     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5428 
5429     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(ExecState&amp; state, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);
5430     push(@implContent, &quot;{\n&quot;);
5431     push(@implContent, &quot;    auto&amp; vm = state.vm();\n&quot;);
5432 
5433     if ($interface-&gt;serializable-&gt;hasInherit) {
5434         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5435         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);
5436     } else {
5437         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);
5438     }
5439     push(@implContent, &quot;\n&quot;);
5440 
5441     foreach my $attribute (@serializedAttributes) {
5442         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5443 
5444         my $name = $attribute-&gt;name;
5445         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5446         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);
5447         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5448 
5449         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5450             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5451             if ($attribute-&gt;type-&gt;isNullable) {
5452                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5453                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<a name="67" id="anc67"></a><span class="line-modified">5454                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5455                 push(@implContent, &quot;    } else\n&quot;);
<a name="68" id="anc68"></a><span class="line-modified">5456                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5457             } else {
5458                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
<a name="69" id="anc69"></a><span class="line-modified">5459                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);</span>
5460             }
5461         } else {
<a name="70" id="anc70"></a><span class="line-modified">5462             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);</span>
5463         }
5464 
5465         push(@implContent, &quot;\n&quot;);
5466     }
5467 
5468     push(@implContent, &quot;    return result;\n&quot;);
5469     push(@implContent, &quot;}\n&quot;);
5470     push(@implContent, &quot;\n&quot;);
5471 
5472     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5473     push(@implContent, &quot;{\n&quot;);
5474     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5475     push(@implContent, &quot;}\n&quot;);
5476     push(@implContent, &quot;\n&quot;);
5477     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);
5478     push(@implContent, &quot;{\n&quot;);
5479     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5480     push(@implContent, &quot;}\n&quot;);
5481     push(@implContent, &quot;\n&quot;);
5482 }
5483 
5484 sub GenerateGetCallData
5485 {
5486     my ($outputArray, $interface, $className) = @_;
5487 
5488     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5489 
5490     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5491         GeneratePluginCall($outputArray, $interface, $className);
5492     } else {
5493         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5494     }
5495 }
5496 
5497 sub GeneratePluginCall
5498 {
5499     my ($outputArray, $interface, $className) = @_;
5500 
5501     AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
5502 
5503     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell* cell, CallData&amp; callData)\n&quot;);
5504     push(@$outputArray, &quot;{\n&quot;);
5505     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5506     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5507 
5508     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5509     push(@$outputArray, &quot;}\n&quot;);
5510     push(@$outputArray, &quot;\n&quot;);
5511 }
5512 
5513 sub GenerateLegacyCallerDefinitions
5514 {
5515     my ($outputArray, $interface, $className) = @_;
5516 
5517     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5518     if (@legacyCallers &gt; 1) {
5519         foreach my $legacyCaller (@legacyCallers) {
5520             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5521         }
5522 
5523         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5524 
5525         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(ExecState* state)\n&quot;);
5526         push(@$outputArray, &quot;{\n&quot;);
5527         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5528         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5529         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5530 
5531         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);
5532 
5533         push(@$outputArray, &quot;}\n\n&quot;);
5534     } else {
5535         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5536     }
5537 
5538     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5539     push(@$outputArray, &quot;{\n&quot;);
5540     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5541     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5542     push(@$outputArray, &quot;}\n&quot;);
5543     push(@$outputArray, &quot;\n&quot;);
5544 }
5545 
5546 sub GenerateLegacyCallerDefinition
5547 {
5548     my ($outputArray, $interface, $className, $operation) = @_;
5549 
5550     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5551     if ($isOverloaded) {
5552         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);
5553     } else {
5554         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(ExecState* state)\n&quot;);
5555     }
5556 
5557     push(@$outputArray, &quot;{\n&quot;);
5558     push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
5559     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5560     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5561 
5562     my $indent = &quot;    &quot;;
5563     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5564 
5565     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(state-&gt;jsCallee());\n&quot;);
5566     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5567     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5568 
5569     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5570     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5571 
5572     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5573 
5574     push(@$outputArray, &quot;}\n\n&quot;);
5575 }
5576 
5577 sub GenerateCallWithUsingReferences
5578 {
5579     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5580 
5581     my $statePointer = &quot;&amp;state&quot;;
5582     my $stateReference = &quot;state&quot;;
5583     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;;
5584 
5585     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);
5586 }
5587 
5588 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5589 sub GenerateCallWithUsingPointers
5590 {
5591     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5592 
5593     my $statePointer = &quot;state&quot;;
5594     my $stateReference = &quot;*state&quot;;
5595     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot;;
5596 
5597     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);
5598 }
5599 
5600 sub GenerateConstructorCallWithUsingPointers
5601 {
5602     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5603 
5604     my $statePointer = &quot;state&quot;;
5605     my $stateReference = &quot;*state&quot;;
5606     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
5607     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*state, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;
5608     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5609 
5610     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);
5611 }
5612 
5613 sub GenerateCallWith
5614 {
5615     my ($callWith, $outputArray, $returnValue, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;
5616 
5617     return () unless $callWith;
5618 
5619     $indent ||= &quot;    &quot;;
5620 
5621     my @callWithArgs;
5622     push(@callWithArgs, $stateReference) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;);
5623     push(@callWithArgs, &quot;*${globalObject}&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;);
5624     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5625         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5626         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5627         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5628         push(@callWithArgs, &quot;*context&quot;);
5629     }
5630     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5631         AddToImplIncludes(&quot;Document.h&quot;);
5632         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5633         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5634         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5635         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5636         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5637         push(@callWithArgs, &quot;document&quot;);
5638     }
5639     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5640         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5641         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5642         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow($stateReference).document();\n&quot;);
5643         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5644         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5645         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5646     }
5647     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5648         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5649         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5650         push(@callWithArgs, &quot;responsibleDocument($stateReference)&quot;);
5651     }
5652     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5653         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5654         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5655         push(@callWithArgs, &quot;activeDOMWindow($stateReference)&quot;);
5656     }
5657     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5658         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5659         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5660         push(@callWithArgs, &quot;firstDOMWindow($stateReference)&quot;);
5661     }
5662     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5663         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5664         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5665         push(@callWithArgs, &quot;incumbentDOMWindow($stateReference)&quot;);
5666     }
5667     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5668         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5669     }
5670     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5671         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5672     }
5673 
5674     return @callWithArgs;
5675 }
5676 
5677 sub GenerateArgumentsCountCheck
5678 {
5679     my ($outputArray, $operation, $interface, $indent) = @_;
5680 
5681     # Overloaded operations don&#39;t need to check the argument count since the 
5682     # dispatch function does for them.
5683     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5684 
5685     my $numMandatoryArguments = @{$operation-&gt;arguments};
5686     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5687         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5688             $numMandatoryArguments--;
5689         } else {
5690             last;
5691         }
5692     }
5693     if ($numMandatoryArguments &gt;= 1) {
5694         push(@$outputArray, $indent . &quot;if (UNLIKELY(state-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);
5695         push(@$outputArray, $indent . &quot;    return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));\n&quot;);
5696     }
5697 }
5698 
5699 my %automaticallyGeneratedDefaultValues = (
5700     &quot;any&quot; =&gt; &quot;undefined&quot;,
5701 
5702     # toString() will convert undefined to the string &quot;undefined&quot;;
5703     # (note that this optimizes a behavior that is almost never useful)
5704     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5705     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5706 
5707     # JSValue::toBoolean() will convert undefined to false.
5708     &quot;boolean&quot; =&gt; &quot;false&quot;,
5709 
5710     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5711     &quot;byte&quot; =&gt; &quot;0&quot;,
5712     &quot;long long&quot; =&gt; &quot;0&quot;,
5713     &quot;long&quot; =&gt; &quot;0&quot;,
5714     &quot;octet&quot; =&gt; &quot;0&quot;,
5715     &quot;short&quot; =&gt; &quot;0&quot;,
5716     &quot;unsigned long long&quot; =&gt; &quot;0&quot;,
5717     &quot;unsigned long&quot; =&gt; &quot;0&quot;,
5718     &quot;unsigned short&quot; =&gt; &quot;0&quot;,
5719 
5720     # toNumber() / toFloat() convert undefined to NaN.
5721     &quot;double&quot; =&gt; &quot;NaN&quot;,
5722     &quot;float&quot; =&gt; &quot;NaN&quot;,
5723     &quot;unrestricted double&quot; =&gt; &quot;NaN&quot;,
5724     &quot;unrestricted float&quot; =&gt; &quot;NaN&quot;,
5725 );
5726 
5727 sub WillConvertUndefinedToDefaultParameterValue
5728 {
5729     my ($parameterType, $defaultValue) = @_;
5730 
5731     my $automaticallyGeneratedDefaultValue = $automaticallyGeneratedDefaultValues{$parameterType-&gt;name};
5732     return 1 if defined $automaticallyGeneratedDefaultValue &amp;&amp; $automaticallyGeneratedDefaultValue eq $defaultValue;
5733 
5734     return 1 if $defaultValue eq &quot;null&quot; &amp;&amp; $codeGenerator-&gt;IsWrapperType($parameterType);
5735     return 1 if $defaultValue eq &quot;[]&quot; &amp;&amp; $codeGenerator-&gt;IsDictionaryType($parameterType);
5736 
5737     return 0;
5738 }
5739 
5740 sub NeedsExplicitPropagateExceptionCall
5741 {
5742     my ($operation) = @_;
5743 
5744     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5745 
5746     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5747 }
5748 
5749 sub GenerateParametersCheck
5750 {
5751     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5752 
5753     my $interfaceName = $interface-&gt;type-&gt;name;
5754     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5755     my $numArguments = @{$operation-&gt;arguments};
5756     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5757     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5758 
5759     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5760     
5761     my @arguments = ();
5762     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);
5763     
5764     my $quotedFunctionName;
5765     if (!$isConstructor) {
5766         my $name = $operation-&gt;name;
5767         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5768         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5769     } else {
5770         $quotedFunctionName = &quot;nullptr&quot;;
5771         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5772     }
5773 
5774     my $argumentIndex = 0;
5775     foreach my $argument (@{$operation-&gt;arguments}) {
5776         my $type = $argument-&gt;type;
5777 
5778         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5779 
5780         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5781             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5782             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
5783 
5784             # Treat undefined the same as an empty sequence Or frozen array.
5785             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
5786 
5787             # We use undefined as default value for optional arguments of type &#39;any&#39; unless specified otherwise.
5788             $argument-&gt;default(&quot;undefined&quot;) if $type-&gt;name eq &quot;any&quot;;
5789 
5790             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5791             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5792 
5793             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5794             # default value for nullable arguments unless otherwise specified.
5795             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5796 
5797             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5798             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5799         }
5800 
5801         my $name = $argument-&gt;name;
5802         my $value = $name;
5803 
5804         if ($argument-&gt;isVariadic) {
5805             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5806             AddToImplIncludesForIDLType($type, $conditional);
5807         
5808             my $IDLType = GetIDLType($interface, $type);
5809 
5810             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*state, ${argumentIndex});\n&quot;);
5811             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5812 
5813             $value = &quot;WTFMove(${name})&quot;;
5814         } else {
5815             my $argumentLookupForConversion;
5816             my $optionalCheck;
5817             my $nativeValueCastFunction;
5818 
5819             if ($argument-&gt;isOptional) {
5820                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5821 
5822                 if (defined($argument-&gt;default)) {
5823                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
5824                         $argumentLookupForConversion = &quot;state-&gt;argument($argumentIndex)&quot;;
5825                     } else {
5826                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
5827                         $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5828                         $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;
5829                     }
5830                 } else {
5831                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5832 
5833                     my $defaultValue;
5834                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5835                         $defaultValue = &quot;nullptr&quot;;
5836                     } else {
5837                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5838                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5839                     }
5840 
5841                     $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5842                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;
5843                 }
5844             } else {
5845                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
5846                     push(@$outputArray, $indent . &quot;auto returnValue = state-&gt;uncheckedArgument($argumentIndex);\n&quot;);
5847                     $argumentLookupForConversion = &quot;returnValue&quot;;
5848                 } else {
5849                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;
5850                 }
5851             }
5852 
5853             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
5854             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5855 
5856             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;state&quot;, &quot;*state&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);
5857 
5858             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5859             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5860 
5861             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5862             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5863 
5864             $value = PassArgumentExpression($name, $argument);
5865         }
5866 
5867         push(@arguments, $value);
5868         $argumentIndex++;
5869     }
5870 
5871     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5872 
5873     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5874     $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5875 
5876     return $functionString;
5877 }
5878 
5879 sub GenerateDictionaryHeader
5880 {
5881     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5882 
5883     # - Add default header template and header protection.
5884     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5885 
5886     $headerIncludes{&quot;${className}.h&quot;} = 1;
5887 
5888     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5889     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5890     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5891     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5892     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5893 
5894     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5895     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5896     
5897     # - Generate dependencies.
5898     if ($writeDependencies) {
5899         my @ancestors;
5900         my $parentType = $dictionary-&gt;parentType;
5901         while (defined($parentType)) {
5902             push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
5903             my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
5904             assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless $parentDictionary;
5905             $parentType = $parentDictionary-&gt;parentType;
5906         }
5907         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
5908         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
5909     }
5910 }
5911 
5912 sub GenerateDictionaryImplementation
5913 {
5914     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5915 
5916     # - Add default header template
5917     push(@implContentHeader, GenerateImplementationContentHeader($dictionary));
5918 
5919     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
5920     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
5921     push(@implContent, GenerateDictionaryImplementationContent($dictionary, $className));
5922     push(@implContent, GenerateEnumerationsImplementationContent($dictionary, $enumerations));
5923     push(@implContent, GenerateDictionariesImplementationContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5924     push(@implContent, &quot;} // namespace WebCore\n&quot;);
5925 
5926     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5927     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5928 }
5929 
5930 sub GenerateCallbackFunctionHeader
5931 {
5932     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
5933 
5934     push(@headerContentHeader, GenerateHeaderContentHeader($callbackFunction));
5935 
5936     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5937 
5938     my @operations = ();
5939     push(@operations, $callbackFunction-&gt;operation);
5940     my @constants = ();
5941 
5942     $object-&gt;GenerateCallbackHeaderContent($callbackFunction, \@operations, \@constants, \@headerContent, \%headerIncludes);
5943 
5944     push(@headerContent, GenerateEnumerationsHeaderContent($callbackFunction, $enumerations));
5945     push(@headerContent, GenerateDictionariesHeaderContent($callbackFunction, $dictionaries));
5946 
5947     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5948 
5949     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
5950     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5951 }
5952 
5953 sub GenerateCallbackFunctionImplementation
5954 {
5955     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
5956 
5957     push(@implContentHeader, GenerateImplementationContentHeader($callbackFunction));
5958 
5959     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
5960     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
5961 
5962     push(@implContent, GenerateEnumerationsImplementationContent($callbackFunction, $enumerations));
5963     push(@implContent, GenerateDictionariesImplementationContent($callbackFunction, $dictionaries));
5964 
5965     my @operations = ();
5966     push(@operations, $callbackFunction-&gt;operation);
5967     my @constants = ();
5968 
5969     $object-&gt;GenerateCallbackImplementationContent($callbackFunction, \@operations, \@constants, \@implContent, \%implIncludes);
5970 
5971     push(@implContent, &quot;} // namespace WebCore\n&quot;);
5972 
5973     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
5974     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5975 }
5976 
5977 sub GenerateCallbackInterfaceHeader
5978 {
5979     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
5980 
5981     push(@headerContentHeader, GenerateHeaderContentHeader($callbackInterface));
5982 
5983     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5984     
5985     $object-&gt;GenerateCallbackHeaderContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@headerContent, \%headerIncludes);
5986 
5987     push(@headerContent, GenerateEnumerationsHeaderContent($callbackInterface, $enumerations));
5988     push(@headerContent, GenerateDictionariesHeaderContent($callbackInterface, $dictionaries));
5989 
5990     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5991 
5992     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
5993     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5994 }
5995 
5996 sub GenerateCallbackInterfaceImplementation
5997 {
5998     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
5999 
6000     push(@implContentHeader, GenerateImplementationContentHeader($callbackInterface));
6001 
6002     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6003     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6004 
6005     push(@implContent, GenerateEnumerationsImplementationContent($callbackInterface, $enumerations));
6006     push(@implContent, GenerateDictionariesImplementationContent($callbackInterface, $dictionaries));
6007 
6008     $object-&gt;GenerateCallbackImplementationContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@implContent, \%implIncludes);
6009 
6010     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6011 
6012     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
6013     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6014 }
6015 
6016 sub GenerateCallbackHeaderContent
6017 {
6018     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6019 
6020     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6021     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6022     my $className = &quot;JS${name}&quot;;
6023 
6024     $includesRef-&gt;{&quot;IDLTypes.h&quot;} = 1;
6025     $includesRef-&gt;{&quot;JSCallbackData.h&quot;} = 1;
6026     $includesRef-&gt;{&quot;&lt;wtf/Forward.h&gt;&quot;} = 1;
6027     $includesRef-&gt;{&quot;${name}.h&quot;} = 1;
6028 
6029     my $exportMacro = GetExportMacroForJSClass($interfaceOrCallback);
6030 
6031     push(@$contentRef, &quot;class $exportMacro$className final : public ${name} {\n&quot;);
6032     push(@$contentRef, &quot;public:\n&quot;);
6033 
6034     # The static create() method.
6035     push(@$contentRef, &quot;    static Ref&lt;$className&gt; create(JSC::JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6036     push(@$contentRef, &quot;    {\n&quot;);
6037     push(@$contentRef, &quot;        return adoptRef(*new ${className}(callback, globalObject));\n&quot;);
6038     push(@$contentRef, &quot;    }\n\n&quot;);
6039 
6040     push(@$contentRef, &quot;    virtual ScriptExecutionContext* scriptExecutionContext() const { return ContextDestructionObserver::scriptExecutionContext(); }\n\n&quot;);
6041 
6042     push(@$contentRef, &quot;    virtual ~$className();\n&quot;);
6043 
6044     push(@$contentRef, &quot;    ${callbackDataType}* callbackData() { return m_data; }\n&quot;);
6045 
6046     push(@$contentRef, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;) if @{$constants};
6047 
6048     push(@$contentRef, &quot;    virtual bool operator==(const ${name}&amp;) const override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual};
6049 
6050     # Operations
6051     my $numOperations = @{$operations};
6052     if ($numOperations &gt; 0) {
6053         push(@$contentRef, &quot;\n    // Functions\n&quot;);
6054         foreach my $operation (@{$operations}) {
6055             my @arguments = ();
6056 
6057             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6058             if ($callbackThisObject) {
6059                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6060                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6061                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6062             }
6063 
6064             foreach my $argument (@{$operation-&gt;arguments}) {
6065                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6066                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6067             }
6068 
6069             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6070             
6071             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6072             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6073 
6074             push(@$contentRef, &quot;    ${nativeReturnType} ${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;) override;\n&quot;);
6075         }
6076     }
6077 
6078     push(@$contentRef, &quot;\nprivate:\n&quot;);
6079 
6080     push(@$contentRef, &quot;    ${className}(JSC::JSObject*, JSDOMGlobalObject*);\n\n&quot;);
6081 
6082     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6083         push(@$contentRef, &quot;    bool hasCallback() const final { return m_data &amp;&amp; m_data-&gt;callback(); }\n\n&quot;);
6084     }
6085 
6086     push(@$contentRef, &quot;    void visitJSFunction(JSC::SlotVisitor&amp;) override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback};
6087 
6088     push(@$contentRef, &quot;    ${callbackDataType}* m_data;\n&quot;);
6089     push(@$contentRef, &quot;};\n\n&quot;);
6090 
6091     # toJS().
6092     push(@$contentRef, $exportMacro . &quot;JSC::JSValue toJS(${name}&amp;);\n&quot;);
6093     push(@$contentRef, &quot;inline JSC::JSValue toJS(${name}* impl) { return impl ? toJS(*impl) : JSC::jsNull(); }\n\n&quot;);
6094 }
6095 
6096 sub GenerateCallbackImplementationContent
6097 {
6098     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6099 
6100     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6101     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6102     my $visibleName = $codeGenerator-&gt;GetVisibleInterfaceName($interfaceOrCallback);
6103     my $className = &quot;JS${name}&quot;;
6104 
6105     $includesRef-&gt;{&quot;ScriptExecutionContext.h&quot;} = 1;
6106 
6107     # Constructor
6108     push(@$contentRef, &quot;${className}::${className}(JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6109     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6110         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext(), ${className}Type)\n&quot;);
6111     } else {
6112         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext())\n&quot;);
6113     }
6114     push(@$contentRef, &quot;    , m_data(new ${callbackDataType}(callback, globalObject, this))\n&quot;);
6115     push(@$contentRef, &quot;{\n&quot;);
6116     push(@$contentRef, &quot;}\n\n&quot;);
6117 
6118     # Destructor
6119     push(@$contentRef, &quot;${className}::~${className}()\n&quot;);
6120     push(@$contentRef, &quot;{\n&quot;);
6121     push(@$contentRef, &quot;    ScriptExecutionContext* context = scriptExecutionContext();\n&quot;);
6122     push(@$contentRef, &quot;    // When the context is destroyed, all tasks with a reference to a callback\n&quot;);
6123     push(@$contentRef, &quot;    // should be deleted. So if the context is 0, we are on the context thread.\n&quot;);
6124     push(@$contentRef, &quot;    if (!context || context-&gt;isContextThread())\n&quot;);
6125     push(@$contentRef, &quot;        delete m_data;\n&quot;);
6126     push(@$contentRef, &quot;    else\n&quot;);
6127     push(@$contentRef, &quot;        context-&gt;postTask(DeleteCallbackDataTask(m_data));\n&quot;);
6128     push(@$contentRef, &quot;#ifndef NDEBUG\n&quot;);
6129     push(@$contentRef, &quot;    m_data = nullptr;\n&quot;);
6130     push(@$contentRef, &quot;#endif\n&quot;);
6131     push(@$contentRef, &quot;}\n\n&quot;);
6132 
6133     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6134         push(@$contentRef, &quot;bool ${className}::operator==(const ${name}&amp; other) const\n&quot;);
6135         push(@$contentRef, &quot;{\n&quot;);
6136         push(@$contentRef, &quot;    if (other.type() != type())\n&quot;);
6137         push(@$contentRef, &quot;        return false;\n&quot;);
6138         push(@$contentRef, &quot;    return static_cast&lt;const ${className}*&gt;(&amp;other)-&gt;m_data-&gt;callback() == m_data-&gt;callback();\n&quot;);
6139         push(@$contentRef, &quot;}\n\n&quot;);
6140     }
6141 
6142     # Constants.
6143     my $numConstants = @{$constants};
6144     if ($numConstants &gt; 0) {
6145         GenerateConstructorDeclaration($contentRef, $className, $interfaceOrCallback, $name);
6146 
6147         my $hashSize = 0;
6148         my $hashName = $className . &quot;ConstructorTable&quot;;
6149 
6150         my @hashKeys = ();
6151         my @hashValue1 = ();
6152         my @hashValue2 = ();
6153         my @hashSpecials = ();
6154         my %conditionals = ();
6155         my %readWriteConditionals = ();
6156 
6157         foreach my $constant (@{$constants}) {
6158             my $name = $constant-&gt;name;
6159             push(@hashKeys, $name);
6160             push(@hashValue1, $constant-&gt;value);
6161             push(@hashValue2, &quot;0&quot;);
6162             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
6163 
6164             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
6165             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
6166 
6167             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
6168             $conditionals{$name} = $conditional if $conditional;
6169 
6170             $hashSize++;
6171         }
6172         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
6173 
6174         push(@$contentRef, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interfaceOrCallback));
6175 
6176         GenerateConstructorDefinitions($contentRef, $className, &quot;&quot;, $visibleName, $interfaceOrCallback);
6177 
6178         push(@$contentRef, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
6179         push(@$contentRef, &quot;{\n&quot;);
6180         push(@$contentRef, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
6181         push(@$contentRef, &quot;}\n\n&quot;);
6182     }
6183 
6184     # Operations
6185     my $numOperations = @{$operations};
6186     if ($numOperations &gt; 0) {
6187         foreach my $operation (@{$operations}) {
6188             next if $operation-&gt;extendedAttributes-&gt;{Custom};
6189         
6190             AddToIncludesForIDLType($operation-&gt;type, $includesRef);
6191 
6192             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6193             
6194             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6195             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6196 
6197             my @arguments = ();
6198 
6199             my $thisValue = &quot;jsUndefined()&quot;;
6200 
6201             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6202             if ($callbackThisObject) {
6203                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6204 
6205                 AddToIncludesForIDLType($thisObjectType, $includesRef, 1);
6206                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6207                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6208 
6209                 my $thisObjectArgument = IDLArgument-&gt;new();
6210                 $thisObjectArgument-&gt;type($thisObjectType);
6211 
6212                 $thisValue = NativeToJSValueUsingReferences($thisObjectArgument, $interfaceOrCallback, &quot;thisObject&quot;, &quot;globalObject&quot;);
6213             }
6214 
6215             foreach my $argument (@{$operation-&gt;arguments}) {
6216                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6217                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6218                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6219             }
6220             
6221             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6222             push(@$contentRef, &quot;{\n&quot;);
6223 
6224             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6225             # if that behavior is needed for other callbacks.
6226             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6227                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6228                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6229             }
6230 
6231             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6232             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6233             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6234             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6235 
6236             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);
6237 
6238             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6239             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6240 
6241             foreach my $argument (@{$operation-&gt;arguments}) {
6242                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6243             }
6244             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6245 
6246             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6247 
6248             my $callbackInvocation;
6249             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6250                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6251             } else {
6252                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
<a name="71" id="anc71"></a><span class="line-modified">6253                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;</span>
6254             }
6255 
6256             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6257                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6258             } else {
6259                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6260             }
6261 
6262             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6263             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6264             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6265                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6266                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);
6267             } else {
6268                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);
6269             }
6270             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6271             push(@$contentRef, &quot;     }\n\n&quot;);
6272 
6273             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6274                 push(@$contentRef, &quot;    return { };\n&quot;);
6275             } else {
6276                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);
6277             
6278                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6279                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6280                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
<a name="72" id="anc72"></a><span class="line-modified">6281                 push(@$contentRef, &quot;    return returnValue;\n&quot;);</span>
6282             }
6283 
6284             push(@$contentRef, &quot;}\n\n&quot;);
6285         }
6286     }
6287 
6288     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6289         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6290         push(@$contentRef, &quot;{\n&quot;);
6291         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6292         push(@$contentRef, &quot;}\n\n&quot;);
6293     }
6294 
6295     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6296     push(@$contentRef, &quot;{\n&quot;);
6297     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6298     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6299     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6300     push(@$contentRef, &quot;}\n\n&quot;);
6301 }
6302 
6303 sub GenerateImplementationFunctionCall
6304 {
6305     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6306 
6307     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6308     if ($callTracingCallback) {
<a name="73" id="anc73"></a><span class="line-modified">6309         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};</span>



6310         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6311     }
6312 
6313     if (OperationHasForcedReturnValue($operation)) {
6314         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6315         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6316     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6317         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6318         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6319     } else {
6320         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6321         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6322     }
6323 }
6324 
6325 sub GenerateImplementationCustomFunctionCall
6326 {
6327     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6328 
6329     my @customFunctionArguments = ();
6330     push(@customFunctionArguments, &quot;*state&quot;);
6331     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6332 
6333     if ($operation-&gt;isStatic) {
6334         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6335     } else {
6336         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6337     }
6338 }
6339 
6340 sub IsValueIterableInterface
6341 {
6342     my $interface = shift;
6343     return 0 unless $interface-&gt;iterable;
6344     return 0 if length $interface-&gt;iterable-&gt;keyType;
6345     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6346     return 0 unless GetIndexedGetterOperation($interface);
6347     return 1;
6348 }
6349 
6350 sub IsKeyValueIterableInterface
6351 {
6352     my $interface = shift;
6353     return 0 unless $interface-&gt;iterable;
6354     return 0 if IsValueIterableInterface($interface);
6355     return 1;
6356 }
6357 
6358 sub GenerateIterableDefinition
6359 {
6360     my $interface = shift;
6361 
6362     my $interfaceName = $interface-&gt;type-&gt;name;
6363     my $className = &quot;JS$interfaceName&quot;;
6364     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6365 
6366     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6367 
6368     return unless IsKeyValueIterableInterface($interface);
6369 
6370     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6371     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6372 
6373     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6374     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6375     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6376     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6377 
6378     push(@implContent,  &lt;&lt;END);
6379 struct ${iteratorTraitsName} {
6380     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6381     using KeyType = ${iteratorTraitsKeyType};
6382     using ValueType = ${iteratorTraitsValueType};
6383 };
6384 
6385 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6386 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6387 
6388 template&lt;&gt;
6389 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6390 
6391 template&lt;&gt;
6392 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6393 
6394 END
6395 
6396     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6397         my $propertyName = $operation-&gt;name;
6398         my $functionName = GetFunctionName($interface, $className, $operation);
6399 
6400         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6401 
6402         if ($propertyName eq &quot;forEach&quot;) {
6403             push(@implContent,  &lt;&lt;END);
6404 static inline EncodedJSValue ${functionName}Caller(ExecState* state, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)
6405 {
6406     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*state, *thisObject, throwScope));
6407 }
6408 
6409 END
6410         } else {
6411             my $iterationKind = &quot;KeyValue&quot;;
6412             $iterationKind = &quot;Key&quot; if $propertyName eq &quot;keys&quot;;
6413             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;values&quot;;
6414             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;
6415 
6416             push(@implContent,  &lt;&lt;END);
6417 static inline EncodedJSValue ${functionName}Caller(ExecState*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)
6418 {
6419     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6420 }
6421 
6422 END
6423         }
6424 
6425         push(@implContent,  &lt;&lt;END);
6426 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState* state)
6427 {
6428     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*state, &quot;${propertyName}&quot;);
6429 }
6430 
6431 END
6432     }
6433 }
6434 
6435 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6436 sub GetFlattenedMemberTypes
6437 {
6438     my ($idlUnionType) = @_;
6439 
6440     my @flattenedMemberTypes = ();
6441 
6442     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6443         if ($memberType-&gt;isUnion) {
6444             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6445         } else {
6446             push(@flattenedMemberTypes, $memberType);
6447         }
6448     }
6449 
6450     return @flattenedMemberTypes;
6451 }
6452 
6453 # http://heycam.github.io/webidl/#dfn-number-of-nullable-member-types
6454 sub GetNumberOfNullableMemberTypes
6455 {
6456     my ($idlUnionType) = @_;
6457 
6458     my $count = 0;
6459 
6460     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6461         $count++ if $memberType-&gt;isNullable;
6462         $count += GetNumberOfNullableMemberTypes($memberType) if $memberType-&gt;isUnion;
6463     }
6464 
6465     return $count;
6466 }
6467 
6468 sub GetIDLUnionMemberTypes
6469 {
6470     my ($interface, $idlUnionType) = @_;
6471 
6472     my $numberOfNullableMembers = GetNumberOfNullableMemberTypes($idlUnionType);
6473     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6474 
6475     my @idlUnionMemberTypes = ();
6476 
6477     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6478 
6479     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6480         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6481     }
6482 
6483     return @idlUnionMemberTypes;
6484 }
6485 
6486 sub IsAnnotatedType
6487 {
6488     my ($type) = @_;
6489 
6490     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6491     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6492     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<a name="74" id="anc74"></a><span class="line-modified">6493     return 1 if $type-&gt;extendedAttributes-&gt;{AtomString};</span>
<span class="line-modified">6494     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};</span>
6495 }
6496 
6497 sub GetAnnotatedIDLType
6498 {
6499     my ($type) = @_;
6500 
6501     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6502     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6503     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
<a name="75" id="anc75"></a><span class="line-modified">6504     return &quot;IDLAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomString};</span>
<span class="line-modified">6505     return &quot;IDLRequiresExistingAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};</span>
6506 }
6507 
6508 sub GetBaseIDLType
6509 {
6510     my ($interface, $type) = @_;
6511 
6512     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6513         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6514     }
6515 
6516     my %IDLTypes = (
6517         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6518         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6519         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6520         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6521         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6522         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6523         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6524         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6525         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
6526         &quot;long long&quot; =&gt; &quot;IDLLongLong&quot;,
6527         &quot;unsigned long long&quot; =&gt; &quot;IDLUnsignedLongLong&quot;,
6528         &quot;float&quot; =&gt; &quot;IDLFloat&quot;,
6529         &quot;unrestricted float&quot; =&gt; &quot;IDLUnrestrictedFloat&quot;,
6530         &quot;double&quot; =&gt; &quot;IDLDouble&quot;,
6531         &quot;unrestricted double&quot; =&gt; &quot;IDLUnrestrictedDouble&quot;,
6532         &quot;DOMString&quot; =&gt; &quot;IDLDOMString&quot;,
6533         &quot;ByteString&quot; =&gt; &quot;IDLByteString&quot;,
6534         &quot;USVString&quot; =&gt; &quot;IDLUSVString&quot;,
6535         &quot;object&quot; =&gt; &quot;IDLObject&quot;,
6536         &quot;ArrayBuffer&quot; =&gt; &quot;IDLArrayBuffer&quot;,
6537         &quot;ArrayBufferView&quot; =&gt; &quot;IDLArrayBufferView&quot;,
6538         &quot;DataView&quot; =&gt; &quot;IDLDataView&quot;,
6539         &quot;Int8Array&quot; =&gt; &quot;IDLInt8Array&quot;,
6540         &quot;Int16Array&quot; =&gt; &quot;IDLInt16Array&quot;,
6541         &quot;Int32Array&quot; =&gt; &quot;IDLInt32Array&quot;,
6542         &quot;Uint8Array&quot; =&gt; &quot;IDLUint8Array&quot;,
6543         &quot;Uint16Array&quot; =&gt; &quot;IDLUint16Array&quot;,
6544         &quot;Uint32Array&quot; =&gt; &quot;IDLUint32Array&quot;,
6545         &quot;Uint8ClampedArray&quot; =&gt; &quot;IDLUint8ClampedArray&quot;,
6546         &quot;Float32Array&quot; =&gt; &quot;IDLFloat32Array&quot;,
6547         &quot;Float64Array&quot; =&gt; &quot;IDLFloat64Array&quot;,
6548 
6549         # Non-WebIDL extensions
6550         &quot;Date&quot; =&gt; &quot;IDLDate&quot;,
6551         &quot;EventListener&quot; =&gt; &quot;IDLEventListener&lt;JSEventListener&gt;&quot;,
6552         &quot;JSON&quot; =&gt; &quot;IDLJSON&quot;,
6553         &quot;ScheduledAction&quot; =&gt; &quot;IDLScheduledAction&quot;,
6554         &quot;SerializedScriptValue&quot; =&gt; &quot;IDLSerializedScriptValue&lt;SerializedScriptValue&gt;&quot;,
6555         &quot;XPathNSResolver&quot; =&gt; &quot;IDLXPathNSResolver&lt;XPathNSResolver&gt;&quot;,
6556     );
6557 
6558     return $IDLTypes{$type-&gt;name} if exists $IDLTypes{$type-&gt;name};
6559     return &quot;IDLEnumeration&lt;&quot; . GetEnumerationClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsEnumType($type);
6560     return &quot;IDLDictionary&lt;&quot; . GetDictionaryClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsDictionaryType($type);
6561     return &quot;IDLSequence&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsSequenceType($type);
6562     return &quot;IDLFrozenArray&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsFrozenArrayType($type);
6563     return &quot;IDLRecord&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;, &quot; . GetIDLType($interface, @{$type-&gt;subtypes}[1]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsRecordType($type);
6564     return &quot;IDLPromise&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsPromiseType($type);
6565     return &quot;IDLUnion&lt;&quot; . join(&quot;, &quot;, GetIDLUnionMemberTypes($interface, $type)) . &quot;&gt;&quot; if $type-&gt;isUnion;
6566     return &quot;IDLCallbackFunction&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackFunction($type);
6567     return &quot;IDLCallbackInterface&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackInterface($type);
6568 
6569     assert(&quot;Unknown type &#39;&quot; . $type-&gt;name . &quot;&#39;.\n&quot;) unless $codeGenerator-&gt;IsInterfaceType($type);
6570     return &quot;IDLInterface&lt;&quot; . $type-&gt;name . &quot;&gt;&quot;;
6571 }
6572 
6573 sub GetIDLTypeExcludingNullability
6574 {
6575     my ($interface, $type) = @_;
6576 
6577     my $baseIDLType = GetBaseIDLType($interface, $type);
6578     $baseIDLType = GetAnnotatedIDLType($type) . &quot;&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if IsAnnotatedType($type);
6579     return $baseIDLType;
6580 }
6581 
6582 sub GetIDLType
6583 {
6584     my ($interface, $type) = @_;
6585 
6586     my $baseIDLType = GetIDLTypeExcludingNullability($interface, $type);
6587     $baseIDLType = &quot;IDLNullable&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if $type-&gt;isNullable;
6588     return $baseIDLType;
6589 }
6590 
6591 sub ShouldPassArgumentByReference
6592 {
6593     my ($argument) = @_;
6594 
6595     my $type = $argument-&gt;type;
6596 
6597     return 0 if $type-&gt;isNullable;
6598     return 0 if $codeGenerator-&gt;IsCallbackInterface($type);
6599     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6600     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6601 
6602     return 1;
6603 }
6604 
6605 sub JSValueToNativeDOMConvertNeedsThisObject
6606 {
6607     my $type = shift;
6608 
6609     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6610     return 0;
6611 }
6612 
6613 sub JSValueToNativeDOMConvertNeedsGlobalObject
6614 {
6615     my $type = shift;
6616 
6617     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6618     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
6619     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6620     return 0;
6621 }
6622 
6623 sub IsValidContextForJSValueToNative
6624 {
6625     my $context = shift;
6626     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6627 }
6628 
6629 sub JSValueToNative
6630 {
6631     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;
6632 
6633     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6634 
6635     my $type = $context-&gt;type;
6636 
6637     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6638     $statePointer = &quot;state&quot; unless $statePointer;
6639     $stateReference = &quot;*state&quot; unless $stateReference;
6640     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6641 
6642     AddToImplIncludesForIDLType($type, $conditional);
6643     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6644 
6645     my $IDLType = GetIDLType($interface, $type);
6646 
6647     my @conversionArguments = ();
6648     push(@conversionArguments, $stateReference);
6649     push(@conversionArguments, $value);
6650     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6651     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6652     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6653 
6654     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6655 }
6656 
<a name="76" id="anc76"></a><span class="line-modified">6657 sub ToNativeForFunctionWithoutTypeCheck</span>
6658 {
6659     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;
6660 
6661     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6662 
6663     my $type = $context-&gt;type;
6664 
6665     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6666     $statePointer = &quot;state&quot; unless $statePointer;
6667     $stateReference = &quot;*state&quot; unless $stateReference;
6668     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6669 
6670     AddToImplIncludesForIDLType($type, $conditional);
6671 
6672     # FIXME: Support more types.
6673 
6674     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6675 
6676     my $IDLType = GetIDLType($interface, $type);
6677 
6678     my @conversionArguments = ();
6679     push(@conversionArguments, &quot;$stateReference&quot;);
6680     push(@conversionArguments, &quot;$value&quot;);
6681 
6682     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6683 }
6684 
6685 sub NativeToJSValueDOMConvertNeedsState
6686 {
6687     my ($type) = @_;
6688 
6689     # FIXME: We need a more robust way to specify this requirement so as not
6690     # to require specializing each type. Perhaps just requiring all override
6691     # types to take both state and the global object would work?
6692     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6693         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6694         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6695         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6696         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6697 
6698         return 0;
6699     }
6700 
6701     # FIXME: This should actually check if all the sub-objects of the union need the state.
6702     return 1 if $type-&gt;isUnion;
6703     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6704     return 1 if $codeGenerator-&gt;IsRecordType($type);
6705     return 1 if $codeGenerator-&gt;IsStringType($type);
6706     return 1 if $codeGenerator-&gt;IsEnumType($type);
6707     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6708     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6709     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6710     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6711     return 1 if $type-&gt;name eq &quot;Date&quot;;
6712     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6713     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6714     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6715     
6716     return 0;
6717 }
6718 
6719 sub NativeToJSValueDOMConvertNeedsGlobalObject
6720 {
6721     my ($type) = @_;
6722     
6723     # FIXME: We need a more robust way to specify this requirement so as not
6724     # to require specializing each type. Perhaps just requiring all override
6725     # types to take both state and the global object would work?
6726     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6727         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6728         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6729         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6730         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6731 
6732         return 0;
6733     }
6734 
6735     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6736     return 1 if $type-&gt;isUnion;
6737     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6738     return 1 if $codeGenerator-&gt;IsRecordType($type);
6739     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6740     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6741     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6742     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6743     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6744     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6745 
6746     return 0;
6747 }
6748 
6749 sub NativeToJSValueUsingReferences
6750 {
6751     my ($context, $interface, $value, $globalObjectReference) = @_;
6752 
6753     return NativeToJSValue($context, $interface, $value, &quot;state&quot;, $globalObjectReference);
6754 }
6755 
6756 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6757 sub NativeToJSValueUsingPointers
6758 {
6759     my ($context, $interface, $value, $globalObjectReference) = @_;
6760 
6761     return NativeToJSValue($context, $interface, $value, &quot;*state&quot;, $globalObjectReference);
6762 }
6763 
6764 sub IsValidContextForNativeToJSValue
6765 {
6766     my $context = shift;
6767     
6768     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6769 }
6770 
6771 sub NativeToJSValue
6772 {
6773     my ($context, $interface, $value, $stateReference, $globalObjectReference) = @_;
6774 
6775     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6776 
6777     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6778     my $type = $context-&gt;type;
6779     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6780 
6781     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6782     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6783     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6784         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6785         $value = &quot;std::max(0, $value)&quot;;
6786     }
6787 
6788     AddToImplIncludesForIDLType($type, $conditional);
6789     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6790 
6791     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6792         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
6793         $value = &quot;BindingSecurity::checkSecurityForNode($stateReference, $value)&quot;;
6794     }
6795 
6796     my $IDLType = GetIDLType($interface, $type);
6797 
6798     my @conversionArguments = ();
6799     push(@conversionArguments, $stateReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;
6800     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6801     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6802     push(@conversionArguments, $value);
6803 
6804     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6805 
6806     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6807 }
6808 
6809 sub ceilingToPowerOf2
6810 {
6811     my ($size) = @_;
6812 
6813     my $powerOf2 = 1;
6814     while ($size &gt; $powerOf2) {
6815         $powerOf2 &lt;&lt;= 1;
6816     }
6817 
6818     return $powerOf2;
6819 }
6820 
6821 # Internal Helper
6822 sub GenerateHashTableValueArray
6823 {
6824     my $keys = shift;
6825     my $specials = shift;
6826     my $value1 = shift;
6827     my $value2 = shift;
6828     my $conditionals = shift;
6829     my $readWriteConditionals = shift;
6830     my $nameEntries = shift;
6831 
6832     my $packedSize = scalar @{$keys};
6833     push(@implContent, &quot;\nstatic const HashTableValue $nameEntries\[\] =\n\{\n&quot;);
6834 
6835     my $hasSetter = &quot;false&quot;;
6836 
6837     my $i = 0;
6838     foreach my $key (@{$keys}) {
6839         my $firstTargetType;
6840         my $secondTargetType = &quot;&quot;;
6841         my $conditional;
6842 
6843         if ($conditionals) {
6844             $conditional = $conditionals-&gt;{$key};
6845         }
6846         if ($conditional) {
6847             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
6848             push(@implContent, &quot;#if ${conditionalString}\n&quot;);
6849         }
6850 
6851         if (&quot;@$specials[$i]&quot; =~ m/DOMJITFunction/) {
6852             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6853             $secondTargetType = &quot;static_cast&lt;const JSC::DOMJIT::Signature*&gt;&quot;;
6854         } elsif (&quot;@$specials[$i]&quot; =~ m/Function/) {
6855             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6856         } elsif (&quot;@$specials[$i]&quot; =~ m/Builtin/) {
6857             $firstTargetType = &quot;static_cast&lt;BuiltinGenerator&gt;&quot;;
6858         } elsif (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6859             $firstTargetType = &quot;&quot;;
6860         } elsif (&quot;@$specials[$i]&quot; =~ m/DOMJITAttribute/) {
6861             $firstTargetType = &quot;static_cast&lt;const JSC::DOMJIT::GetterSetter*&gt;&quot;;
6862         } else {
6863             $firstTargetType = &quot;static_cast&lt;PropertySlot::GetValueFunc&gt;&quot;;
6864             $secondTargetType = &quot;static_cast&lt;PutPropertySlot::PutValueFunc&gt;&quot;;
6865             $hasSetter = &quot;true&quot;;
6866         }
6867         if (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6868             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (long long)&quot; . $firstTargetType . &quot;(@$value1[$i]) } },\n&quot;);
6869         } else {
6870             my $readWriteConditional = $readWriteConditionals ? $readWriteConditionals-&gt;{$key} : undef;
6871             if ($readWriteConditional) {
6872                 my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
6873                 push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
6874             }
6875 
6876             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) &quot; . $secondTargetType . &quot;(@$value2[$i]) } },\n&quot;);
6877 
6878             if ($readWriteConditional) {
6879                 push(@implContent, &quot;#else\n&quot;) ;
6880                 push(@implContent, &quot;    { \&quot;$key\&quot;, JSC::PropertyAttribute::ReadOnly | @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) static_cast&lt;PutPropertySlot::PutValueFunc&gt;(0) } },\n&quot;);
6881                 push(@implContent, &quot;#endif\n&quot;);
6882             }
6883         }
6884         if ($conditional) {
6885             push(@implContent, &quot;#else\n&quot;);
6886             push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } },\n&quot;);
6887             push(@implContent, &quot;#endif\n&quot;);
6888         }
6889         ++$i;
6890     }
6891 
6892     push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } }\n&quot;) if (!$packedSize);
6893     push(@implContent, &quot;};\n\n&quot;);
6894 
6895     return $hasSetter;
6896 }
6897 
6898 sub GenerateHashTable
6899 {
6900     my $object = shift;
6901 
6902     my $className = shift;
6903     my $name = shift;
6904     my $size = shift;
6905     my $keys = shift;
6906     my $specials = shift;
6907     my $value1 = shift;
6908     my $value2 = shift;
6909     my $conditionals = shift;
6910     my $readWriteConditionals = shift;
6911     my $justGenerateValueArray = shift;
6912 
6913     my $nameEntries = &quot;${name}Values&quot;;
6914     $nameEntries =~ s/:/_/g;
6915     my $nameIndex = &quot;${name}Index&quot;;
6916     $nameIndex =~ s/:/_/g;
6917 
6918     if (($name =~ /Prototype/) or ($name =~ /Constructor/)) {
6919         my $type = $name;
6920         my $implClass;
6921 
6922         if ($name =~ /Prototype/) {
6923             $type =~ s/Prototype.*//;
6924             $implClass = $type; $implClass =~ s/Wrapper$//;
6925             push(@implContent, &quot;/* Hash table for prototype */\n&quot;);
6926         } else {
6927             $type =~ s/Constructor.*//;
6928             $implClass = $type; $implClass =~ s/Constructor$//;
6929             push(@implContent, &quot;/* Hash table for constructor */\n&quot;);
6930         }
6931     } else {
6932         push(@implContent, &quot;/* Hash table */\n&quot;);
6933     }
6934 
6935     if ($justGenerateValueArray) {
6936         GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries) if $size;
6937         return;
6938     }
6939 
6940     # Generate size data for compact&#39; size hash table
6941 
6942     my @table = ();
6943     my @links = ();
6944 
6945     my $compactSize = ceilingToPowerOf2($size * 2);
6946 
6947     my $maxDepth = 0;
6948     my $collisions = 0;
6949     my $numEntries = $compactSize;
6950 
6951     my $i = 0;
6952     foreach (@{$keys}) {
6953         my $depth = 0;
6954         my $h = Hasher::GenerateHashValue($_) % $numEntries;
6955 
6956         while (defined($table[$h])) {
6957             if (defined($links[$h])) {
6958                 $h = $links[$h];
6959                 $depth++;
6960             } else {
6961                 $collisions++;
6962                 $links[$h] = $compactSize;
6963                 $h = $compactSize;
6964                 $compactSize++;
6965             }
6966         }
6967 
6968         $table[$h] = $i;
6969 
6970         $i++;
6971         $maxDepth = $depth if ($depth &gt; $maxDepth);
6972     }
6973 
6974     push(@implContent, &quot;\nstatic const struct CompactHashIndex ${nameIndex}\[$compactSize\] = {\n&quot;);
6975     for (my $i = 0; $i &lt; $compactSize; $i++) {
6976         my $T = -1;
6977         if (defined($table[$i])) { $T = $table[$i]; }
6978         my $L = -1;
6979         if (defined($links[$i])) { $L = $links[$i]; }
6980         push(@implContent, &quot;    { $T, $L },\n&quot;);
6981     }
6982     push(@implContent, &quot;};\n\n&quot;);
6983 
6984     # Dump the hash table
6985     my $hasSetter = GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries);
6986     my $packedSize = scalar @{$keys};
6987 
6988     my $compactSizeMask = $numEntries - 1;
6989     push(@implContent, &quot;static const HashTable $name = { $packedSize, $compactSizeMask, $hasSetter, ${className}::info(), $nameEntries, $nameIndex };\n&quot;);
6990 }
6991 
6992 sub WriteData
6993 {
6994     my $object = shift;
6995     my $interface = shift;
6996     my $outputDir = shift;
6997 
6998     my $name = $interface-&gt;type-&gt;name;
6999     my $headerFileName = &quot;$outputDir/JS$name.h&quot;;
7000     my $implFileName = &quot;$outputDir/JS$name.cpp&quot;;
7001     my $depsFileName = &quot;$outputDir/JS$name.dep&quot;;
7002 
7003     # Update a .cpp file if the contents are changed.
7004     my $contents = join &quot;&quot;, @implContentHeader;
7005 
7006     my @includes = ();
7007     my %implIncludeConditions = ();
7008     foreach my $include (keys %implIncludes) {
7009         next if $headerIncludes{$include};
7010         next if $headerTrailingIncludes{$include};
7011 
7012         my $condition = $implIncludes{$include};
7013 
7014         my $checkType = $include;
7015         $checkType =~ s/\.h//;
7016         next if $codeGenerator-&gt;IsSVGAnimatedTypeName($checkType);
7017 
7018         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7019 
7020         if ($condition eq 1) {
7021             push @includes, $include;
7022         } else {
7023             push @{$implIncludeConditions{$codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($condition)}}, $include;
7024         }
7025     }
7026     foreach my $include (sort @includes) {
7027         $contents .= &quot;#include $include\n&quot;;
7028     }
7029     foreach my $condition (sort keys %implIncludeConditions) {
7030         $contents .= &quot;\n#if &quot; . $condition . &quot;\n&quot;;
7031         foreach my $include (sort @{$implIncludeConditions{$condition}}) {
7032             $contents .= &quot;#include $include\n&quot;;
7033         }
7034         $contents .= &quot;#endif\n&quot;;
7035     }
7036 
7037     $contents .= join &quot;&quot;, @implContent;
7038     $codeGenerator-&gt;UpdateFile($implFileName, $contents);
7039 
7040     @implContentHeader = ();
7041     @implContent = ();
7042     %implIncludes = ();
7043 
7044     # Update a .h file if the contents are changed.
7045     $contents = join &quot;&quot;, @headerContentHeader;
7046 
7047     @includes = ();
7048     foreach my $include (keys %headerIncludes) {
7049         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7050         push @includes, $include;
7051     }
7052     foreach my $include (sort @includes) {
7053         # &quot;JSClassName.h&quot; is already included right after config.h.
7054         next if $include eq &quot;\&quot;JS$name.h\&quot;&quot;;
7055         $contents .= &quot;#include $include\n&quot;;
7056     }
7057 
7058     $contents .= join &quot;&quot;, @headerContent;
7059 
7060     @includes = ();
7061     foreach my $include (keys %headerTrailingIncludes) {
7062         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7063         push @includes, $include;
7064     }
7065     foreach my $include (sort @includes) {
7066         $contents .= &quot;#include $include\n&quot;;
7067     }
7068     $codeGenerator-&gt;UpdateFile($headerFileName, $contents);
7069 
7070     @headerContentHeader = ();
7071     @headerContent = ();
7072     %headerIncludes = ();
7073     %headerTrailingIncludes = ();
7074 
7075     if (@depsContent) {
7076         # Update a .dep file if the contents are changed.
7077         $contents = join &quot;&quot;, @depsContent;
7078         $codeGenerator-&gt;UpdateFile($depsFileName, $contents);
7079 
7080         @depsContent = ();
7081     }
7082 }
7083 
7084 sub GeneratePrototypeDeclaration
7085 {
7086     my ($outputArray, $className, $interface) = @_;
7087 
7088     my $prototypeClassName = &quot;${className}Prototype&quot;;
7089 
7090     my %structureFlags = ();
7091     push(@$outputArray, &quot;class ${prototypeClassName} : public JSC::JSNonFinalObject {\n&quot;);
7092     push(@$outputArray, &quot;public:\n&quot;);
7093     push(@$outputArray, &quot;    using Base = JSC::JSNonFinalObject;\n&quot;);
7094 
7095     push(@$outputArray, &quot;    static ${prototypeClassName}* create(JSC::VM&amp; vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)\n&quot;);
7096     push(@$outputArray, &quot;    {\n&quot;);
7097     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7098     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7099     push(@$outputArray, &quot;        return ptr;\n&quot;);
7100     push(@$outputArray, &quot;    }\n\n&quot;);
7101 
7102     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7103 
7104     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7105     push(@$outputArray, &quot;    {\n&quot;);
7106     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7107     push(@$outputArray, &quot;    }\n&quot;);
7108 
7109     push(@$outputArray, &quot;\nprivate:\n&quot;);
7110     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7111     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7112     push(@$outputArray, &quot;    {\n&quot;);
7113     push(@$outputArray, &quot;    }\n&quot;);
7114 
7115     if (PrototypeHasStaticPropertyTable($interface)) {
7116         if (IsGlobalOrPrimaryGlobalInterface($interface)) {
7117             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7118         } else {
7119             push(@$outputArray, &quot;\n&quot;);
7120             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7121         }
7122     }
7123 
7124     # FIXME: Should this override putByIndex as well?
7125     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7126         push(@$outputArray, &quot;\n&quot;);
7127         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
7128     }
7129 
7130     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7131         push(@$outputArray, &quot;\n&quot;);
7132         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
7133     }
7134 
7135     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7136 
7137     # structure flags
7138     if (%structureFlags) {
7139         push(@$outputArray, &quot;public:\n&quot;);
7140         push(@$outputArray, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);
7141         foreach my $structureFlag (sort (keys %structureFlags)) {
7142             push(@$outputArray, &quot; | &quot; . $structureFlag);
7143         }
7144         push(@$outputArray, &quot;;\n&quot;);
7145     }
7146 
7147     push(@$outputArray, &quot;};\n\n&quot;);
7148 }
7149 
7150 sub GetConstructorTemplateClassName
7151 {
7152     my $interface = shift;
7153     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7154     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7155     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7156     return &quot;JSDOMConstructor&quot;;
7157 }
7158 
7159 sub GenerateConstructorDeclaration
7160 {
7161     my ($outputArray, $className, $interface) = @_;
7162 
7163     my $interfaceName = $interface-&gt;type-&gt;name;
7164     my $constructorClassName = &quot;${className}Constructor&quot;;
7165     my $templateClassName = GetConstructorTemplateClassName($interface);
7166 
7167     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7168     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7169 
7170     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7171     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7172     push(@$outputArray, &quot;\n&quot;);
7173 }
7174 
7175 sub GenerateConstructorDefinitions
7176 {
7177     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7178 
7179     if (IsConstructable($interface)) {
7180         my @constructors = @{$interface-&gt;constructors};
7181         if (@constructors &gt; 1) {
7182             foreach my $constructor (@constructors) {
7183                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7184             }
7185 
7186             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7187 
7188             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(ExecState* state)\n&quot;);
7189             push(@implContent, &quot;{\n&quot;);
7190             push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
7191             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7192             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7193 
7194             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);
7195 
7196             push(@implContent, &quot;}\n\n&quot;);
7197         } elsif (@constructors == 1) {
7198             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7199         } else {
7200             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7201         }
7202     }
7203 
7204     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7205 }
7206 
7207 sub GenerateConstructorDefinition
7208 {
7209     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7210 
7211     return if IsJSBuiltinConstructor($interface);
7212 
7213     my $interfaceName = $interface-&gt;type-&gt;name;
7214     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7215 
7216     if (IsConstructable($interface)) {
7217         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7218             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::ExecState* exec)\n&quot;);
7219             push(@$outputArray, &quot;{\n&quot;);
7220             push(@$outputArray, &quot;    ASSERT(exec);\n&quot;);
7221             push(@$outputArray, &quot;    return construct${className}(*exec);\n&quot;);
7222             push(@$outputArray, &quot;}\n\n&quot;);
7223          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7224             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7225             if ($isOverloaded) {
7226                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);
7227             } else {
7228                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(ExecState* state)\n&quot;);
7229             }
7230 
7231             push(@$outputArray, &quot;{\n&quot;);
7232             push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);
7233             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7234             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7235             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(state-&gt;jsCallee());\n&quot;);
7236             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7237 
7238             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7239 
7240             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7241             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7242 
7243             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7244             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7245 
7246             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7247 
7248             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7249 
7250             my @constructionConversionArguments = ();
7251             push(@constructionConversionArguments, &quot;*state&quot;);
7252             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7253             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7254             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7255 
7256             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7257             push(@$outputArray, &quot;}\n\n&quot;);
7258         }
7259     }
7260 }
7261 
7262 sub ConstructorHasProperties
7263 {
7264     my $interface = shift;
7265 
7266     foreach my $constant (@{$interface-&gt;constants}) {
7267         return 1;
7268     }
7269 
7270     foreach my $attribute (@{$interface-&gt;attributes}) {
7271         next unless ($attribute-&gt;isStatic);
7272         return 1;
7273     }
7274 
7275     foreach my $operation (@{$interface-&gt;operations}) {
7276         next unless ($operation-&gt;isStatic);
7277         return 1;
7278     }
7279 
7280     return 0;
7281 }
7282 
7283 sub GetRuntimeEnabledStaticProperties
7284 {
7285     my ($interface) = @_;
7286 
7287     my @runtimeEnabledProperties = ();
7288 
7289     my @attributes = @{$interface-&gt;attributes};
7290     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
7291 
7292     foreach my $attribute (@attributes) {
7293         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7294         next if not $attribute-&gt;isStatic;
7295 
7296         if (NeedsRuntimeCheck($interface, $attribute)) {
7297             push(@runtimeEnabledProperties, $attribute);
7298         }
7299     }
7300 
7301     my @operations = @{$interface-&gt;operations};
7302     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7303     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
7304     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7305     foreach my $operation (@operations) {
7306         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7307         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7308         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7309         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7310         next if not $operation-&gt;isStatic;
7311 
7312         if (NeedsRuntimeCheck($interface, $operation)) {
7313             push(@runtimeEnabledProperties, $operation);
7314         }
7315     }
7316 
7317     return @runtimeEnabledProperties;
7318 }
7319 
7320 sub GenerateConstructorHelperMethods
7321 {
7322     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7323 
7324     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7325     my $leastConstructorLength = 0;
7326     if ($interface-&gt;extendedAttributes-&gt;{Constructor} || $interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7327         my @constructors = @{$interface-&gt;constructors};
7328         my @customConstructors = @{$interface-&gt;customConstructors};
7329         $leastConstructorLength = 255;
7330         foreach my $constructor (@constructors, @customConstructors) {
7331             my $constructorLength = GetFunctionLength($constructor);
7332             $leastConstructorLength = $constructorLength if ($constructorLength &lt; $leastConstructorLength);
7333         }
7334     } else {
7335         $leastConstructorLength = 0;
7336     }
7337 
7338     # If the interface has a parent interface which does not have [NoInterfaceObject], then use its interface object as prototype,
7339     # otherwise use FunctionPrototype: http://heycam.github.io/webidl/#interface-object
7340     push(@$outputArray, &quot;template&lt;&gt; JSValue ${constructorClassName}::prototypeForStructure(JSC::VM&amp; vm, const JSDOMGlobalObject&amp; globalObject)\n&quot;);
7341     push(@$outputArray, &quot;{\n&quot;);
7342 
7343     assert(&quot;An interface cannot inherit from another interface that is marked as [NoInterfaceObject]&quot;) if $interface-&gt;parentType &amp;&amp; $codeGenerator-&gt;GetInterfaceExtendedAttributesFromName($interface-&gt;parentType-&gt;name)-&gt;{NoInterfaceObject};
7344 
7345     if (!$generatingNamedConstructor and $interface-&gt;parentType) {
7346         my $parentClassName = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
7347         push(@$outputArray, &quot;    return ${parentClassName}::getConstructor(vm, &amp;globalObject);\n&quot;);
7348     } else {
7349         AddToImplIncludes(&quot;&lt;JavaScriptCore/FunctionPrototype.h&gt;&quot;);
7350         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7351         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7352     }
7353     push(@$outputArray, &quot;}\n\n&quot;);
7354 
7355 
7356     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7357     push(@$outputArray, &quot;{\n&quot;);
7358 
7359     # There must exist an interface prototype object for every non-callback interface defined, regardless
7360     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7361     # https://heycam.github.io/webidl/#interface-prototype-object
7362     if (ShouldUseGlobalObjectPrototype($interface)) {
7363         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7364     } elsif ($interface-&gt;isCallback) {
7365         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7366     } else {
7367         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7368     }
7369 
<a name="77" id="anc77"></a><span class="line-modified">7370     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
7371     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;
7372 
7373     my $classForThis = &quot;${className}::info()&quot;;
7374     if ($interface-&gt;isCallback) {
7375         $classForThis = &quot;nullptr&quot;;
7376     }
7377     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7378 
7379     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7380 
7381     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7382         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7383         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7384         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);
7385         my $name = $operationOrAttribute-&gt;name;
7386         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
<a name="78" id="anc78"></a><span class="line-modified">7387         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);</span>
7388         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7389         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);
7390         push(@$outputArray, &quot;    }\n&quot;);
7391         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7392     }
7393 
7394     push(@$outputArray, &quot;}\n\n&quot;);
7395 
7396     if (IsJSBuiltinConstructor($interface)) {
7397         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7398         push(@$outputArray, &quot;{\n&quot;);
7399         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7400         push(@$outputArray, &quot;}\n&quot;);
7401         push(@$outputArray, &quot;\n&quot;);
7402     }
7403     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7404 }
7405 
7406 sub HasCustomConstructor
7407 {
7408     my $interface = shift;
7409     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7410 }
7411 
7412 sub HasCustomGetter
7413 {
7414     my $attribute = shift;
7415     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
7416 }
7417 
7418 sub HasCustomSetter
7419 {
7420     my $attribute = shift;
7421     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomSetter};
7422 }
7423 
7424 sub HasCustomMethod
7425 {
7426     my $operation = shift;
7427     return $operation-&gt;extendedAttributes-&gt;{Custom};
7428 }
7429 
7430 sub NeedsConstructorProperty
7431 {
7432     my $interface = shift;
7433     
7434     return !$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject};
7435 }
7436 
7437 sub IsConstructable
7438 {
7439     my $interface = shift;
7440     return HasCustomConstructor($interface)
7441         || $interface-&gt;extendedAttributes-&gt;{Constructor}
7442         || $interface-&gt;extendedAttributes-&gt;{NamedConstructor}
7443         || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7444 }
7445 
7446 sub InstanceOverridesGetCallData
7447 {
7448     my $interface = shift;
7449     return $interface-&gt;{LegacyCallers} || $interface-&gt;extendedAttributes-&gt;{CustomGetCallData} || $interface-&gt;extendedAttributes-&gt;{Plugin};
7450 }
7451 
7452 sub HeaderNeedsPrototypeDeclaration
7453 {
7454     my $interface = shift;
7455     return IsDOMGlobalObject($interface)
7456         || $interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}
7457         || $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype};
7458 }
7459 
7460 sub IsUnforgeable
7461 {
7462     my ($interface, $property) = @_;
7463 
7464     return $property-&gt;extendedAttributes-&gt;{Unforgeable} || $interface-&gt;extendedAttributes-&gt;{Unforgeable};
7465 }
7466 
7467 sub ComputeFunctionSpecial
7468 {
7469     my ($interface, $operation) = @_;
7470 
7471     my @specials = ();
7472     push(@specials, (&quot;JSC::PropertyAttribute::DontDelete&quot;, &quot;JSC::PropertyAttribute::ReadOnly&quot;)) if IsUnforgeable($interface, $operation);
7473     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $operation-&gt;extendedAttributes-&gt;{NotEnumerable};
7474     if (IsJSBuiltin($interface, $operation)) {
7475         push(@specials, &quot;JSC::PropertyAttribute::Builtin&quot;);
7476     } else {
7477         push(@specials, &quot;JSC::PropertyAttribute::Function&quot;);
7478     }
7479     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
7480         push(@specials, &quot;JSC::PropertyAttribute::DOMJITFunction&quot;) if $operation-&gt;extendedAttributes-&gt;{DOMJIT};
7481     }
7482     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
7483 }
7484 
7485 sub IsJSBuiltin
7486 {
7487     my ($interface, $object) = @_;
7488 
7489     return 0 if $object-&gt;extendedAttributes-&gt;{Custom};
7490     return 0 if $object-&gt;extendedAttributes-&gt;{CustomGetter};
7491     return 0 if $object-&gt;extendedAttributes-&gt;{CustomSetter};
7492 
7493     return 1 if $object-&gt;extendedAttributes-&gt;{JSBuiltin};
7494     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7495 
7496     return 0;
7497 }
7498 
7499 sub IsJSBuiltinConstructor
7500 {
7501     my ($interface) = @_;
7502 
7503     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7504     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7505     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7506     return 0;
7507 }
7508 
7509 sub GetJSBuiltinFunctionName
7510 {
7511     my ($className, $operation) = @_;
7512 
7513     my $scopeName = $operation-&gt;extendedAttributes-&gt;{ImplementedBy};
7514     $scopeName = substr $className, 2 unless $scopeName;
7515     return GetJSBuiltinFunctionNameFromString($scopeName, $operation-&gt;name);
7516 }
7517 
7518 sub GetJSBuiltinFunctionNameFromString
7519 {
7520     my ($scopeName, $functionName) = @_;
7521 
7522     return $codeGenerator-&gt;WK_lcfirst($scopeName) . $codeGenerator-&gt;WK_ucfirst($functionName) . &quot;CodeGenerator&quot;;
7523 }
7524 
7525 sub GetJSBuiltinScopeName
7526 {
7527     my ($interface, $object) = @_;
7528     return $object-&gt;extendedAttributes-&gt;{ImplementedBy} || $interface-&gt;type-&gt;name;
7529 }
7530 
7531 sub AddJSBuiltinIncludesIfNeeded()
7532 {
7533     my $interface = shift;
7534 
7535     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7536         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7537         return;
7538     }
7539 
7540     foreach my $operation (@{$interface-&gt;operations}) {
7541         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7542     }
7543 
7544     foreach my $attribute (@{$interface-&gt;attributes}) {
7545         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7546     }
7547 }
7548 
<a name="79" id="anc79"></a>



























7549 sub GenerateCallTracer()
7550 {
7551     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7552 
7553     AddToImplIncludes(&quot;CallTracer.h&quot;);
7554 
<a name="80" id="anc80"></a><span class="line-modified">7555     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))\n&quot;);</span>








7556     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
<a name="81" id="anc81"></a><span class="line-modified">7557     if (scalar(@$arguments)) {</span>
<span class="line-modified">7558         push(@$outputArray, &quot;, { &quot; . join(&quot;, &quot;, @$arguments) . &quot; }&quot;);</span>
7559     }
7560     push(@$outputArray, &quot;);\n&quot;);
<a name="82" id="anc82"></a>


7561 }
7562 
7563 sub GenerateCustomElementReactionsStackIfNeeded
7564 {
7565     my ($outputArray, $context, $stateVariable) = @_;
7566 
7567     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7568 
7569     return if !$CEReactions;
7570 
7571     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7572 
7573     if ($CEReactions eq &quot;NotNeeded&quot;) {
7574         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7575     } else {
7576         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7577     }
7578 }
7579 
7580 1;
<a name="83" id="anc83"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="83" type="hidden" />
</body>
</html>