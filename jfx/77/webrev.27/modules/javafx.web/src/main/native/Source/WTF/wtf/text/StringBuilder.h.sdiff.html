<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringCommon.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-modified"> 30 #include &lt;wtf/text/AtomicString.h&gt;</span>
 31 #include &lt;wtf/text/IntegerToStringConversion.h&gt;

 32 #include &lt;wtf/text/StringView.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 namespace WTF {
 36 
 37 // StringBuilder currently uses a Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; for m_length.
 38 // Ideally, we would want to make StringBuilder a template with an OverflowHandler parameter, and
 39 // m_length can be instantiated based on that OverflowHandler instead. However, currently, we&#39;re
 40 // not able to get clang to export explicitly instantiated template methods (which would be needed
 41 // if we templatize StringBuilder). As a workaround, we use the ConditionalCrashOnOverflow handler
 42 // instead to do a runtime check on whether it should crash on overflows or not.
 43 //
 44 // When clang is able to export explicitly instantiated template methods, we can templatize
 45 // StringBuilder and do away with ConditionalCrashOnOverflow.
 46 // See https://bugs.webkit.org/show_bug.cgi?id=191050.
 47 
 48 class StringBuilder {
 49     // Disallow copying since it&#39;s expensive and we don&#39;t want code to do it by accident.
 50     WTF_MAKE_NONCOPYABLE(StringBuilder);

 51 
 52 public:
 53     enum class OverflowHandler {
 54         CrashOnOverflow,
 55         RecordOverflow
 56     };
 57 
 58     StringBuilder(OverflowHandler handler = OverflowHandler::CrashOnOverflow)
 59         : m_bufferCharacters8(nullptr)
 60     {
 61         m_length.setShouldCrashOnOverflow(handler == OverflowHandler::CrashOnOverflow);
 62     }
 63     StringBuilder(StringBuilder&amp;&amp;) = default;
 64     StringBuilder&amp; operator=(StringBuilder&amp;&amp;) = default;
 65 
 66     ALWAYS_INLINE void didOverflow() { m_length.overflowed(); }
 67     ALWAYS_INLINE bool hasOverflowed() const { return m_length.hasOverflowed(); }
 68     ALWAYS_INLINE bool crashesOnOverflow() const { return m_length.shouldCrashOnOverflow(); }
 69 
<span class="line-modified"> 70     WTF_EXPORT_PRIVATE void append(const UChar*, unsigned);</span>
<span class="line-modified"> 71     WTF_EXPORT_PRIVATE void append(const LChar*, unsigned);</span>
 72 
<span class="line-modified"> 73     ALWAYS_INLINE void append(const char* characters, unsigned length) { append(reinterpret_cast&lt;const LChar*&gt;(characters), length); }</span>
 74 
<span class="line-modified"> 75     void append(const AtomicString&amp; atomicString)</span>
 76     {
<span class="line-modified"> 77         append(atomicString.string());</span>
 78     }
 79 
 80     void append(const String&amp; string)
 81     {
 82         if (hasOverflowed())
 83             return;
 84 
 85         if (!string.length())
 86             return;
 87 
 88         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
 89         // then just retain the string.
 90         if (!m_length &amp;&amp; !m_buffer) {
 91             m_string = string;
 92             m_length = string.length();
 93             m_is8Bit = m_string.is8Bit();
 94             return;
 95         }
 96 
 97         if (string.is8Bit())
<span class="line-modified"> 98             append(string.characters8(), string.length());</span>
 99         else
<span class="line-modified">100             append(string.characters16(), string.length());</span>
101     }
102 
103     void append(const StringBuilder&amp; other)
104     {
105         if (hasOverflowed())
106             return;
107         if (other.hasOverflowed())
108             return didOverflow();
109 
110         if (!other.m_length)
111             return;
112 
113         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
114         // then just retain the string.
115         if (!m_length &amp;&amp; !m_buffer &amp;&amp; !other.m_string.isNull()) {
116             m_string = other.m_string;
117             m_length = other.m_length;

118             return;
119         }
120 
121         if (other.is8Bit())
<span class="line-modified">122             append(other.characters8(), other.m_length.unsafeGet());</span>
123         else
<span class="line-modified">124             append(other.characters16(), other.m_length.unsafeGet());</span>
125     }
126 
127     void append(StringView stringView)
128     {
129         if (stringView.is8Bit())
<span class="line-modified">130             append(stringView.characters8(), stringView.length());</span>
131         else
<span class="line-modified">132             append(stringView.characters16(), stringView.length());</span>
133     }
134 
135 #if USE(CF)
136     WTF_EXPORT_PRIVATE void append(CFStringRef);
137 #endif
138 #if USE(CF) &amp;&amp; defined(__OBJC__)
139     void append(NSString *string) { append((__bridge CFStringRef)string); }
140 #endif
141 
<span class="line-modified">142     void append(const String&amp; string, unsigned offset, unsigned length)</span>
143     {
144         if (!string.length())
145             return;
146 
147         if ((offset + length) &gt; string.length())
148             return;
149 
150         if (string.is8Bit())
<span class="line-modified">151             append(string.characters8() + offset, length);</span>
152         else
<span class="line-modified">153             append(string.characters16() + offset, length);</span>
154     }
155 
156     void append(const char* characters)
157     {
158         if (characters)
<span class="line-modified">159             append(characters, strlen(characters));</span>
160     }
161 

162     void append(UChar c)
163     {
164         if (hasOverflowed())
165             return;
166         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
167         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
168             if (!m_is8Bit) {
169                 m_bufferCharacters16[length] = c;
170                 m_length++;
171                 return;
172             }
173 
<span class="line-modified">174             if (!(c &amp; ~0xff)) {</span>
175                 m_bufferCharacters8[length] = static_cast&lt;LChar&gt;(c);
176                 m_length++;
177                 return;
178             }
179         }
<span class="line-modified">180         append(&amp;c, 1);</span>
181     }
182 

183     void append(LChar c)
184     {
185         if (hasOverflowed())
186             return;
187         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
188         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
189             if (m_is8Bit)
190                 m_bufferCharacters8[length] = c;
191             else
192                 m_bufferCharacters16[length] = c;
193             m_length++;
194         } else
<span class="line-modified">195             append(&amp;c, 1);</span>
196     }
197 

198     void append(char c)
199     {
200         append(static_cast&lt;LChar&gt;(c));
201     }
202 
<span class="line-modified">203     void append(UChar32 c)</span>
204     {
205         if (U_IS_BMP(c)) {
206             append(static_cast&lt;UChar&gt;(c));
207             return;
208         }
209         append(U16_LEAD(c));
210         append(U16_TRAIL(c));
211     }
212 
213     WTF_EXPORT_PRIVATE void appendQuotedJSONString(const String&amp;);
214 
215     template&lt;unsigned characterCount&gt;
<span class="line-modified">216     ALWAYS_INLINE void appendLiteral(const char (&amp;characters)[characterCount]) { append(characters, characterCount - 1); }</span>
217 
218     WTF_EXPORT_PRIVATE void appendNumber(int);
<span class="line-modified">219     WTF_EXPORT_PRIVATE void appendNumber(unsigned int);</span>
220     WTF_EXPORT_PRIVATE void appendNumber(long);
221     WTF_EXPORT_PRIVATE void appendNumber(unsigned long);
222     WTF_EXPORT_PRIVATE void appendNumber(long long);
223     WTF_EXPORT_PRIVATE void appendNumber(unsigned long long);
<span class="line-modified">224     WTF_EXPORT_PRIVATE void appendNumber(double, unsigned precision = 6, TrailingZerosTruncatingPolicy = TruncateTrailingZeros);</span>
<span class="line-modified">225     WTF_EXPORT_PRIVATE void appendECMAScriptNumber(double);</span>




226     WTF_EXPORT_PRIVATE void appendFixedWidthNumber(double, unsigned decimalPlaces);
227 


228     String toString()
229     {
230         if (!m_string.isNull()) {
231             ASSERT(!m_buffer || m_isReified);
232             ASSERT(!hasOverflowed());
233             return m_string;
234         }
235 
236         RELEASE_ASSERT(!hasOverflowed());
237         shrinkToFit();
238         reifyString();
239         return m_string;
240     }
241 
242     const String&amp; toStringPreserveCapacity() const
243     {
244         RELEASE_ASSERT(!hasOverflowed());
245         if (m_string.isNull())
246             reifyString();
247         return m_string;
248     }
249 
<span class="line-modified">250     AtomicString toAtomicString() const</span>
251     {
252         RELEASE_ASSERT(!hasOverflowed());
253         if (!m_length)
254             return emptyAtom();
255 
<span class="line-modified">256         // If the buffer is sufficiently over-allocated, make a new AtomicString from a copy so its buffer is not so large.</span>
257         if (canShrink()) {
258             if (is8Bit())
<span class="line-modified">259                 return AtomicString(characters8(), length());</span>
<span class="line-modified">260             return AtomicString(characters16(), length());</span>
261         }
262 
263         if (!m_string.isNull())
<span class="line-modified">264             return AtomicString(m_string);</span>
265 
266         ASSERT(m_buffer);
<span class="line-modified">267         return AtomicString(m_buffer.get(), 0, m_length.unsafeGet());</span>
268     }
269 
270     unsigned length() const
271     {
272         RELEASE_ASSERT(!hasOverflowed());
273         return m_length.unsafeGet();
274     }
275 
276     bool isEmpty() const { return !m_length; }
277 
278     WTF_EXPORT_PRIVATE void reserveCapacity(unsigned newCapacity);
279 
280     unsigned capacity() const
281     {
282         RELEASE_ASSERT(!hasOverflowed());
283         return m_buffer ? m_buffer-&gt;length() : m_length.unsafeGet();
284     }
285 
286     WTF_EXPORT_PRIVATE void resize(unsigned newSize);
287 
288     WTF_EXPORT_PRIVATE bool canShrink() const;
289 
290     WTF_EXPORT_PRIVATE void shrinkToFit();
291 
292     UChar operator[](unsigned i) const
293     {
294         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!hasOverflowed() &amp;&amp; i &lt; m_length.unsafeGet&lt;unsigned&gt;());
295         if (m_is8Bit)
296             return characters8()[i];
297         return characters16()[i];
298     }
299 
300     const LChar* characters8() const
301     {
302         ASSERT(m_is8Bit);
303         if (!m_length)
<span class="line-modified">304             return 0;</span>
305         if (!m_string.isNull())
306             return m_string.characters8();
307         ASSERT(m_buffer);
308         return m_buffer-&gt;characters8();
309     }
310 
311     const UChar* characters16() const
312     {
313         ASSERT(!m_is8Bit);
314         if (!m_length)
<span class="line-modified">315             return 0;</span>
316         if (!m_string.isNull())
317             return m_string.characters16();
318         ASSERT(m_buffer);
319         return m_buffer-&gt;characters16();
320     }
321 
322     bool is8Bit() const { return m_is8Bit; }
323 
324     void clear()
325     {
326         m_length = 0;
327         m_string = String();
328         m_buffer = nullptr;
<span class="line-modified">329         m_bufferCharacters8 = 0;</span>
330         m_is8Bit = true;
331     }
332 
333     void swap(StringBuilder&amp; stringBuilder)
334     {
335         std::swap(m_length, stringBuilder.m_length);
336         m_string.swap(stringBuilder.m_string);
337         m_buffer.swap(stringBuilder.m_buffer);
338         std::swap(m_is8Bit, stringBuilder.m_is8Bit);
339         std::swap(m_bufferCharacters8, stringBuilder.m_bufferCharacters8);
340         ASSERT(!m_buffer || hasOverflowed() || m_buffer-&gt;length() &gt;= m_length.unsafeGet&lt;unsigned&gt;());
341     }
342 
343 private:
344     void allocateBuffer(const LChar* currentCharacters, unsigned requiredLength);
345     void allocateBuffer(const UChar* currentCharacters, unsigned requiredLength);
346     void allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength);
<span class="line-modified">347     template &lt;typename CharType&gt;</span>
<span class="line-modified">348     void reallocateBuffer(unsigned requiredLength);</span>
<span class="line-modified">349     template &lt;typename CharType&gt;</span>
<span class="line-modified">350     ALWAYS_INLINE CharType* appendUninitialized(unsigned length);</span>
<span class="line-modified">351     template &lt;typename CharType&gt;</span>
<span class="line-modified">352     CharType* appendUninitializedSlow(unsigned length);</span>
<span class="line-modified">353     template &lt;typename CharType&gt;</span>
<span class="line-modified">354     ALWAYS_INLINE CharType * getBufferCharacters();</span>
355     WTF_EXPORT_PRIVATE void reifyString() const;
356 


357     mutable String m_string;
358     RefPtr&lt;StringImpl&gt; m_buffer;
359     union {
360         LChar* m_bufferCharacters8;
361         UChar* m_bufferCharacters16;
362     };
363     static_assert(String::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
364     Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; m_length;
365     bool m_is8Bit { true };
366 #if !ASSERT_DISABLED
367     mutable bool m_isReified { false };
368 #endif
369 };
370 
<span class="line-modified">371 template &lt;&gt;</span>
372 ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters&lt;LChar&gt;()
373 {
374     ASSERT(m_is8Bit);
375     return m_bufferCharacters8;
376 }
377 
<span class="line-modified">378 template &lt;&gt;</span>
379 ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters&lt;UChar&gt;()
380 {
381     ASSERT(!m_is8Bit);
382     return m_bufferCharacters16;
383 }
384 
<span class="line-modified">385 template &lt;typename CharType&gt;</span>
<span class="line-modified">386 bool equal(const StringBuilder&amp; s, const CharType* buffer, unsigned length)</span>



























387 {
388     if (s.length() != length)
389         return false;
390 
391     if (s.is8Bit())
392         return equal(s.characters8(), buffer, length);
393 
394     return equal(s.characters16(), buffer, length);
395 }
396 
<span class="line-modified">397 template &lt;typename StringType&gt;</span>
398 bool equal(const StringBuilder&amp; a, const StringType&amp; b)
399 {
400     if (a.length() != b.length())
401         return false;
402 
403     if (!a.length())
404         return true;
405 
406     if (a.is8Bit()) {
407         if (b.is8Bit())
408             return equal(a.characters8(), b.characters8(), a.length());
409         return equal(a.characters8(), b.characters16(), a.length());
410     }
411 
412     if (b.is8Bit())
413         return equal(a.characters16(), b.characters8(), a.length());
414     return equal(a.characters16(), b.characters16(), a.length());
415 }
416 
417 inline bool operator==(const StringBuilder&amp; a, const StringBuilder&amp; b) { return equal(a, b); }
418 inline bool operator!=(const StringBuilder&amp; a, const StringBuilder&amp; b) { return !equal(a, b); }
419 inline bool operator==(const StringBuilder&amp; a, const String&amp; b) { return equal(a, b); }
420 inline bool operator!=(const StringBuilder&amp; a, const String&amp; b) { return !equal(a, b); }
421 inline bool operator==(const String&amp; a, const StringBuilder&amp; b) { return equal(b, a); }
422 inline bool operator!=(const String&amp; a, const StringBuilder&amp; b) { return !equal(b, a); }
423 
424 template&lt;&gt; struct IntegerToStringConversionTrait&lt;StringBuilder&gt; {
425     using ReturnType = void;
426     using AdditionalArgumentType = StringBuilder;
<span class="line-modified">427     static void flush(LChar* characters, unsigned length, StringBuilder* stringBuilder) { stringBuilder-&gt;append(characters, length); }</span>
428 };
429 
430 } // namespace WTF
431 
432 using WTF::StringBuilder;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-modified"> 30 #include &lt;wtf/text/AtomString.h&gt;</span>
 31 #include &lt;wtf/text/IntegerToStringConversion.h&gt;
<span class="line-added"> 32 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
 33 #include &lt;wtf/text/StringView.h&gt;
 34 #include &lt;wtf/text/WTFString.h&gt;
 35 
 36 namespace WTF {
 37 
 38 // StringBuilder currently uses a Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; for m_length.
 39 // Ideally, we would want to make StringBuilder a template with an OverflowHandler parameter, and
 40 // m_length can be instantiated based on that OverflowHandler instead. However, currently, we&#39;re
 41 // not able to get clang to export explicitly instantiated template methods (which would be needed
 42 // if we templatize StringBuilder). As a workaround, we use the ConditionalCrashOnOverflow handler
 43 // instead to do a runtime check on whether it should crash on overflows or not.
 44 //
 45 // When clang is able to export explicitly instantiated template methods, we can templatize
 46 // StringBuilder and do away with ConditionalCrashOnOverflow.
 47 // See https://bugs.webkit.org/show_bug.cgi?id=191050.
 48 
 49 class StringBuilder {
 50     // Disallow copying since it&#39;s expensive and we don&#39;t want code to do it by accident.
 51     WTF_MAKE_NONCOPYABLE(StringBuilder);
<span class="line-added"> 52     WTF_MAKE_FAST_ALLOCATED;</span>
 53 
 54 public:
 55     enum class OverflowHandler {
 56         CrashOnOverflow,
 57         RecordOverflow
 58     };
 59 
 60     StringBuilder(OverflowHandler handler = OverflowHandler::CrashOnOverflow)
 61         : m_bufferCharacters8(nullptr)
 62     {
 63         m_length.setShouldCrashOnOverflow(handler == OverflowHandler::CrashOnOverflow);
 64     }
 65     StringBuilder(StringBuilder&amp;&amp;) = default;
 66     StringBuilder&amp; operator=(StringBuilder&amp;&amp;) = default;
 67 
 68     ALWAYS_INLINE void didOverflow() { m_length.overflowed(); }
 69     ALWAYS_INLINE bool hasOverflowed() const { return m_length.hasOverflowed(); }
 70     ALWAYS_INLINE bool crashesOnOverflow() const { return m_length.shouldCrashOnOverflow(); }
 71 
<span class="line-modified"> 72     WTF_EXPORT_PRIVATE void appendCharacters(const UChar*, unsigned);</span>
<span class="line-modified"> 73     WTF_EXPORT_PRIVATE void appendCharacters(const LChar*, unsigned);</span>
 74 
<span class="line-modified"> 75     ALWAYS_INLINE void appendCharacters(const char* characters, unsigned length) { appendCharacters(reinterpret_cast&lt;const LChar*&gt;(characters), length); }</span>
 76 
<span class="line-modified"> 77     void append(const AtomString&amp; atomString)</span>
 78     {
<span class="line-modified"> 79         append(atomString.string());</span>
 80     }
 81 
 82     void append(const String&amp; string)
 83     {
 84         if (hasOverflowed())
 85             return;
 86 
 87         if (!string.length())
 88             return;
 89 
 90         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
 91         // then just retain the string.
 92         if (!m_length &amp;&amp; !m_buffer) {
 93             m_string = string;
 94             m_length = string.length();
 95             m_is8Bit = m_string.is8Bit();
 96             return;
 97         }
 98 
 99         if (string.is8Bit())
<span class="line-modified">100             appendCharacters(string.characters8(), string.length());</span>
101         else
<span class="line-modified">102             appendCharacters(string.characters16(), string.length());</span>
103     }
104 
105     void append(const StringBuilder&amp; other)
106     {
107         if (hasOverflowed())
108             return;
109         if (other.hasOverflowed())
110             return didOverflow();
111 
112         if (!other.m_length)
113             return;
114 
115         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
116         // then just retain the string.
117         if (!m_length &amp;&amp; !m_buffer &amp;&amp; !other.m_string.isNull()) {
118             m_string = other.m_string;
119             m_length = other.m_length;
<span class="line-added">120             m_is8Bit = other.m_is8Bit;</span>
121             return;
122         }
123 
124         if (other.is8Bit())
<span class="line-modified">125             appendCharacters(other.characters8(), other.m_length.unsafeGet());</span>
126         else
<span class="line-modified">127             appendCharacters(other.characters16(), other.m_length.unsafeGet());</span>
128     }
129 
130     void append(StringView stringView)
131     {
132         if (stringView.is8Bit())
<span class="line-modified">133             appendCharacters(stringView.characters8(), stringView.length());</span>
134         else
<span class="line-modified">135             appendCharacters(stringView.characters16(), stringView.length());</span>
136     }
137 
138 #if USE(CF)
139     WTF_EXPORT_PRIVATE void append(CFStringRef);
140 #endif
141 #if USE(CF) &amp;&amp; defined(__OBJC__)
142     void append(NSString *string) { append((__bridge CFStringRef)string); }
143 #endif
144 
<span class="line-modified">145     void appendSubstring(const String&amp; string, unsigned offset, unsigned length)</span>
146     {
147         if (!string.length())
148             return;
149 
150         if ((offset + length) &gt; string.length())
151             return;
152 
153         if (string.is8Bit())
<span class="line-modified">154             appendCharacters(string.characters8() + offset, length);</span>
155         else
<span class="line-modified">156             appendCharacters(string.characters16() + offset, length);</span>
157     }
158 
159     void append(const char* characters)
160     {
161         if (characters)
<span class="line-modified">162             appendCharacters(characters, strlen(characters));</span>
163     }
164 
<span class="line-added">165     void appendCharacter(UChar) = delete;</span>
166     void append(UChar c)
167     {
168         if (hasOverflowed())
169             return;
170         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
171         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
172             if (!m_is8Bit) {
173                 m_bufferCharacters16[length] = c;
174                 m_length++;
175                 return;
176             }
177 
<span class="line-modified">178             if (isLatin1(c)) {</span>
179                 m_bufferCharacters8[length] = static_cast&lt;LChar&gt;(c);
180                 m_length++;
181                 return;
182             }
183         }
<span class="line-modified">184         appendCharacters(&amp;c, 1);</span>
185     }
186 
<span class="line-added">187     void appendCharacter(LChar) = delete;</span>
188     void append(LChar c)
189     {
190         if (hasOverflowed())
191             return;
192         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
193         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
194             if (m_is8Bit)
195                 m_bufferCharacters8[length] = c;
196             else
197                 m_bufferCharacters16[length] = c;
198             m_length++;
199         } else
<span class="line-modified">200             appendCharacters(&amp;c, 1);</span>
201     }
202 
<span class="line-added">203     void appendCharacter(char) = delete;</span>
204     void append(char c)
205     {
206         append(static_cast&lt;LChar&gt;(c));
207     }
208 
<span class="line-modified">209     void appendCharacter(UChar32 c)</span>
210     {
211         if (U_IS_BMP(c)) {
212             append(static_cast&lt;UChar&gt;(c));
213             return;
214         }
215         append(U16_LEAD(c));
216         append(U16_TRAIL(c));
217     }
218 
219     WTF_EXPORT_PRIVATE void appendQuotedJSONString(const String&amp;);
220 
221     template&lt;unsigned characterCount&gt;
<span class="line-modified">222     ALWAYS_INLINE void appendLiteral(const char (&amp;characters)[characterCount]) { appendCharacters(characters, characterCount - 1); }</span>
223 
224     WTF_EXPORT_PRIVATE void appendNumber(int);
<span class="line-modified">225     WTF_EXPORT_PRIVATE void appendNumber(unsigned);</span>
226     WTF_EXPORT_PRIVATE void appendNumber(long);
227     WTF_EXPORT_PRIVATE void appendNumber(unsigned long);
228     WTF_EXPORT_PRIVATE void appendNumber(long long);
229     WTF_EXPORT_PRIVATE void appendNumber(unsigned long long);
<span class="line-modified">230     WTF_EXPORT_PRIVATE void appendNumber(float);</span>
<span class="line-modified">231     WTF_EXPORT_PRIVATE void appendNumber(double);</span>
<span class="line-added">232 </span>
<span class="line-added">233     WTF_EXPORT_PRIVATE void appendFixedPrecisionNumber(float, unsigned precision = 6, TrailingZerosTruncatingPolicy = TruncateTrailingZeros);</span>
<span class="line-added">234     WTF_EXPORT_PRIVATE void appendFixedPrecisionNumber(double, unsigned precision = 6, TrailingZerosTruncatingPolicy = TruncateTrailingZeros);</span>
<span class="line-added">235     WTF_EXPORT_PRIVATE void appendFixedWidthNumber(float, unsigned decimalPlaces);</span>
236     WTF_EXPORT_PRIVATE void appendFixedWidthNumber(double, unsigned decimalPlaces);
237 
<span class="line-added">238     template&lt;typename... StringTypes&gt; void append(StringTypes...);</span>
<span class="line-added">239 </span>
240     String toString()
241     {
242         if (!m_string.isNull()) {
243             ASSERT(!m_buffer || m_isReified);
244             ASSERT(!hasOverflowed());
245             return m_string;
246         }
247 
248         RELEASE_ASSERT(!hasOverflowed());
249         shrinkToFit();
250         reifyString();
251         return m_string;
252     }
253 
254     const String&amp; toStringPreserveCapacity() const
255     {
256         RELEASE_ASSERT(!hasOverflowed());
257         if (m_string.isNull())
258             reifyString();
259         return m_string;
260     }
261 
<span class="line-modified">262     AtomString toAtomString() const</span>
263     {
264         RELEASE_ASSERT(!hasOverflowed());
265         if (!m_length)
266             return emptyAtom();
267 
<span class="line-modified">268         // If the buffer is sufficiently over-allocated, make a new AtomString from a copy so its buffer is not so large.</span>
269         if (canShrink()) {
270             if (is8Bit())
<span class="line-modified">271                 return AtomString(characters8(), length());</span>
<span class="line-modified">272             return AtomString(characters16(), length());</span>
273         }
274 
275         if (!m_string.isNull())
<span class="line-modified">276             return AtomString(m_string);</span>
277 
278         ASSERT(m_buffer);
<span class="line-modified">279         return AtomString(m_buffer.get(), 0, m_length.unsafeGet());</span>
280     }
281 
282     unsigned length() const
283     {
284         RELEASE_ASSERT(!hasOverflowed());
285         return m_length.unsafeGet();
286     }
287 
288     bool isEmpty() const { return !m_length; }
289 
290     WTF_EXPORT_PRIVATE void reserveCapacity(unsigned newCapacity);
291 
292     unsigned capacity() const
293     {
294         RELEASE_ASSERT(!hasOverflowed());
295         return m_buffer ? m_buffer-&gt;length() : m_length.unsafeGet();
296     }
297 
298     WTF_EXPORT_PRIVATE void resize(unsigned newSize);
299 
300     WTF_EXPORT_PRIVATE bool canShrink() const;
301 
302     WTF_EXPORT_PRIVATE void shrinkToFit();
303 
304     UChar operator[](unsigned i) const
305     {
306         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!hasOverflowed() &amp;&amp; i &lt; m_length.unsafeGet&lt;unsigned&gt;());
307         if (m_is8Bit)
308             return characters8()[i];
309         return characters16()[i];
310     }
311 
312     const LChar* characters8() const
313     {
314         ASSERT(m_is8Bit);
315         if (!m_length)
<span class="line-modified">316             return nullptr;</span>
317         if (!m_string.isNull())
318             return m_string.characters8();
319         ASSERT(m_buffer);
320         return m_buffer-&gt;characters8();
321     }
322 
323     const UChar* characters16() const
324     {
325         ASSERT(!m_is8Bit);
326         if (!m_length)
<span class="line-modified">327             return nullptr;</span>
328         if (!m_string.isNull())
329             return m_string.characters16();
330         ASSERT(m_buffer);
331         return m_buffer-&gt;characters16();
332     }
333 
334     bool is8Bit() const { return m_is8Bit; }
335 
336     void clear()
337     {
338         m_length = 0;
339         m_string = String();
340         m_buffer = nullptr;
<span class="line-modified">341         m_bufferCharacters8 = nullptr;</span>
342         m_is8Bit = true;
343     }
344 
345     void swap(StringBuilder&amp; stringBuilder)
346     {
347         std::swap(m_length, stringBuilder.m_length);
348         m_string.swap(stringBuilder.m_string);
349         m_buffer.swap(stringBuilder.m_buffer);
350         std::swap(m_is8Bit, stringBuilder.m_is8Bit);
351         std::swap(m_bufferCharacters8, stringBuilder.m_bufferCharacters8);
352         ASSERT(!m_buffer || hasOverflowed() || m_buffer-&gt;length() &gt;= m_length.unsafeGet&lt;unsigned&gt;());
353     }
354 
355 private:
356     void allocateBuffer(const LChar* currentCharacters, unsigned requiredLength);
357     void allocateBuffer(const UChar* currentCharacters, unsigned requiredLength);
358     void allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength);
<span class="line-modified">359     template&lt;typename CharacterType&gt; void reallocateBuffer(unsigned requiredLength);</span>
<span class="line-modified">360     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppending(unsigned additionalLength);</span>
<span class="line-modified">361     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppendingWithoutOverflowCheck(CheckedInt32 requiredLength);</span>
<span class="line-modified">362     template&lt;typename CharacterType&gt; CharacterType* extendBufferForAppendingSlowCase(unsigned requiredLength);</span>
<span class="line-modified">363     WTF_EXPORT_PRIVATE LChar* extendBufferForAppending8(CheckedInt32 requiredLength);</span>
<span class="line-modified">364     WTF_EXPORT_PRIVATE UChar* extendBufferForAppending16(CheckedInt32 requiredLength);</span>
<span class="line-modified">365 </span>
<span class="line-modified">366     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* getBufferCharacters();</span>
367     WTF_EXPORT_PRIVATE void reifyString() const;
368 
<span class="line-added">369     template&lt;typename... StringTypeAdapters&gt; void appendFromAdapters(StringTypeAdapters...);</span>
<span class="line-added">370 </span>
371     mutable String m_string;
372     RefPtr&lt;StringImpl&gt; m_buffer;
373     union {
374         LChar* m_bufferCharacters8;
375         UChar* m_bufferCharacters16;
376     };
377     static_assert(String::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
378     Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; m_length;
379     bool m_is8Bit { true };
380 #if !ASSERT_DISABLED
381     mutable bool m_isReified { false };
382 #endif
383 };
384 
<span class="line-modified">385 template&lt;&gt;</span>
386 ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters&lt;LChar&gt;()
387 {
388     ASSERT(m_is8Bit);
389     return m_bufferCharacters8;
390 }
391 
<span class="line-modified">392 template&lt;&gt;</span>
393 ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters&lt;UChar&gt;()
394 {
395     ASSERT(!m_is8Bit);
396     return m_bufferCharacters16;
397 }
398 
<span class="line-modified">399 template&lt;typename... StringTypeAdapters&gt;</span>
<span class="line-modified">400 void StringBuilder::appendFromAdapters(StringTypeAdapters... adapters)</span>
<span class="line-added">401 {</span>
<span class="line-added">402     auto requiredLength = checkedSum&lt;int32_t&gt;(m_length, adapters.length()...);</span>
<span class="line-added">403     if (m_is8Bit &amp;&amp; are8Bit(adapters...)) {</span>
<span class="line-added">404         LChar* destination = extendBufferForAppending8(requiredLength);</span>
<span class="line-added">405         if (!destination) {</span>
<span class="line-added">406             ASSERT(hasOverflowed());</span>
<span class="line-added">407             return;</span>
<span class="line-added">408         }</span>
<span class="line-added">409         stringTypeAdapterAccumulator(destination, adapters...);</span>
<span class="line-added">410     } else {</span>
<span class="line-added">411         UChar* destination = extendBufferForAppending16(requiredLength);</span>
<span class="line-added">412         if (!destination) {</span>
<span class="line-added">413             ASSERT(hasOverflowed());</span>
<span class="line-added">414             return;</span>
<span class="line-added">415         }</span>
<span class="line-added">416         stringTypeAdapterAccumulator(destination, adapters...);</span>
<span class="line-added">417     }</span>
<span class="line-added">418 }</span>
<span class="line-added">419 </span>
<span class="line-added">420 template&lt;typename... StringTypes&gt;</span>
<span class="line-added">421 void StringBuilder::append(StringTypes... strings)</span>
<span class="line-added">422 {</span>
<span class="line-added">423     appendFromAdapters(StringTypeAdapter&lt;StringTypes&gt;(strings)...);</span>
<span class="line-added">424 }</span>
<span class="line-added">425 </span>
<span class="line-added">426 template&lt;typename CharacterType&gt;</span>
<span class="line-added">427 bool equal(const StringBuilder&amp; s, const CharacterType* buffer, unsigned length)</span>
428 {
429     if (s.length() != length)
430         return false;
431 
432     if (s.is8Bit())
433         return equal(s.characters8(), buffer, length);
434 
435     return equal(s.characters16(), buffer, length);
436 }
437 
<span class="line-modified">438 template&lt;typename StringType&gt;</span>
439 bool equal(const StringBuilder&amp; a, const StringType&amp; b)
440 {
441     if (a.length() != b.length())
442         return false;
443 
444     if (!a.length())
445         return true;
446 
447     if (a.is8Bit()) {
448         if (b.is8Bit())
449             return equal(a.characters8(), b.characters8(), a.length());
450         return equal(a.characters8(), b.characters16(), a.length());
451     }
452 
453     if (b.is8Bit())
454         return equal(a.characters16(), b.characters8(), a.length());
455     return equal(a.characters16(), b.characters16(), a.length());
456 }
457 
458 inline bool operator==(const StringBuilder&amp; a, const StringBuilder&amp; b) { return equal(a, b); }
459 inline bool operator!=(const StringBuilder&amp; a, const StringBuilder&amp; b) { return !equal(a, b); }
460 inline bool operator==(const StringBuilder&amp; a, const String&amp; b) { return equal(a, b); }
461 inline bool operator!=(const StringBuilder&amp; a, const String&amp; b) { return !equal(a, b); }
462 inline bool operator==(const String&amp; a, const StringBuilder&amp; b) { return equal(b, a); }
463 inline bool operator!=(const String&amp; a, const StringBuilder&amp; b) { return !equal(b, a); }
464 
465 template&lt;&gt; struct IntegerToStringConversionTrait&lt;StringBuilder&gt; {
466     using ReturnType = void;
467     using AdditionalArgumentType = StringBuilder;
<span class="line-modified">468     static void flush(LChar* characters, unsigned length, StringBuilder* stringBuilder) { stringBuilder-&gt;appendCharacters(characters, length); }</span>
469 };
470 
471 } // namespace WTF
472 
473 using WTF::StringBuilder;
</pre>
</td>
</tr>
</table>
<center><a href="StringBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringCommon.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>