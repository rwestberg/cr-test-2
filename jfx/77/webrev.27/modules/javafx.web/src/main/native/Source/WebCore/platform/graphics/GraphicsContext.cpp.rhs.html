<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2003, 2004, 2005, 2006, 2009, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;GraphicsContext.h&quot;
  28 
  29 #include &quot;BidiResolver.h&quot;
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;FloatRoundedRect.h&quot;
  32 #include &quot;Gradient.h&quot;
  33 #include &quot;GraphicsContextImpl.h&quot;
  34 #include &quot;ImageBuffer.h&quot;
  35 #include &quot;IntRect.h&quot;
  36 #include &quot;RoundedRect.h&quot;
  37 #include &quot;TextRun.h&quot;
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 class TextRunIterator {
  43 public:
  44     TextRunIterator()
  45         : m_textRun(0)
  46         , m_offset(0)
  47     {
  48     }
  49 
  50     TextRunIterator(const TextRun* textRun, unsigned offset)
  51         : m_textRun(textRun)
  52         , m_offset(offset)
  53     {
  54     }
  55 
<a name="1" id="anc1"></a>





  56     unsigned offset() const { return m_offset; }
  57     void increment() { m_offset++; }
  58     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  59     UChar current() const { return (*m_textRun)[m_offset]; }
  60     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  61 
  62     bool operator==(const TextRunIterator&amp; other)
  63     {
  64         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  65     }
  66 
  67     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  68 
  69 private:
  70     const TextRun* m_textRun;
  71     unsigned m_offset;
  72 };
  73 
  74 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
  75     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \
  76         changeFlags |= GraphicsContextState::flag;
  77 
  78 GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  79 {
  80     GraphicsContextState::StateChangeFlags changeFlags = GraphicsContextState::NoChange;
  81 
  82     CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
  83     CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
  84     CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
  85     CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  86 
  87     if ((m_changeFlags &amp; GraphicsContextState::ShadowChange)
  88         &amp;&amp; (m_state.shadowOffset != state.shadowOffset
  89             || m_state.shadowBlur != state.shadowBlur
  90             || m_state.shadowColor != state.shadowColor))
  91         changeFlags |= GraphicsContextState::ShadowChange;
  92 
  93     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
  94     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
  95     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
  96     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
  97     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
  98     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
  99     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 100 
 101     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 102         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))
 103         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);
 104 
 105     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 106     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 107     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 108     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 109     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 110     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 111 
<a name="2" id="anc2"></a><span class="line-added"> 112 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 113     CHECK_FOR_CHANGED_PROPERTY(UseDarkAppearanceChange, useDarkAppearance);</span>
<span class="line-added"> 114 #endif</span>
<span class="line-added"> 115 </span>
 116     return changeFlags;
 117 }
 118 
 119 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 120 {
 121     // FIXME: This code should move to GraphicsContextState.
 122     if (flags &amp; GraphicsContextState::StrokeGradientChange)
 123         m_state.strokeGradient = state.strokeGradient;
 124 
 125     if (flags &amp; GraphicsContextState::StrokePatternChange)
 126         m_state.strokePattern = state.strokePattern;
 127 
 128     if (flags &amp; GraphicsContextState::FillGradientChange)
 129         m_state.fillGradient = state.fillGradient;
 130 
 131     if (flags &amp; GraphicsContextState::FillPatternChange)
 132         m_state.fillPattern = state.fillPattern;
 133 
 134     if (flags &amp; GraphicsContextState::ShadowChange) {
 135         // FIXME: Deal with state.shadowsUseLegacyRadius.
 136         m_state.shadowOffset = state.shadowOffset;
 137         m_state.shadowBlur = state.shadowBlur;
 138         m_state.shadowColor = state.shadowColor;
 139     }
 140 
 141     if (flags &amp; GraphicsContextState::StrokeThicknessChange)
 142         m_state.strokeThickness = state.strokeThickness;
 143 
 144     if (flags &amp; GraphicsContextState::TextDrawingModeChange)
 145         m_state.textDrawingMode = state.textDrawingMode;
 146 
 147     if (flags &amp; GraphicsContextState::StrokeColorChange)
 148         m_state.strokeColor = state.strokeColor;
 149 
 150     if (flags &amp; GraphicsContextState::FillColorChange)
 151         m_state.fillColor = state.fillColor;
 152 
 153     if (flags &amp; GraphicsContextState::StrokeStyleChange)
 154         m_state.strokeStyle = state.strokeStyle;
 155 
 156     if (flags &amp; GraphicsContextState::FillRuleChange)
 157         m_state.fillRule = state.fillRule;
 158 
 159     if (flags &amp; GraphicsContextState::AlphaChange)
 160         m_state.alpha = state.alpha;
 161 
 162     if (flags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange)) {
 163         m_state.compositeOperator = state.compositeOperator;
 164         m_state.blendMode = state.blendMode;
 165     }
 166 
 167     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)
 168         m_state.shouldAntialias = state.shouldAntialias;
 169 
 170     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 171         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 172 
 173     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 174         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 175 
 176     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 177         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 178 
 179     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 180         m_state.drawLuminanceMask = state.drawLuminanceMask;
 181 
 182     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 183         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 184 
<a name="3" id="anc3"></a><span class="line-added"> 185 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 186     if (flags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 187         m_state.useDarkAppearance = state.useDarkAppearance;</span>
<span class="line-added"> 188 #endif</span>
<span class="line-added"> 189 </span>
 190     m_changeFlags |= flags;
 191 }
 192 
 193 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 194 {
 195     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 196         context.setStrokeGradient(*m_state.strokeGradient);
 197 
 198     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 199         context.setStrokePattern(*m_state.strokePattern);
 200 
 201     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 202         context.setFillGradient(*m_state.fillGradient);
 203 
 204     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 205         context.setFillPattern(*m_state.fillPattern);
 206 
 207     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 208 #if USE(CG)
 209         if (m_state.shadowsUseLegacyRadius)
 210             context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 211         else
 212 #endif
 213             context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 214     }
 215 
 216     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)
 217         context.setStrokeThickness(m_state.strokeThickness);
 218 
 219     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)
 220         context.setTextDrawingMode(m_state.textDrawingMode);
 221 
 222     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)
 223         context.setStrokeColor(m_state.strokeColor);
 224 
 225     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)
 226         context.setFillColor(m_state.fillColor);
 227 
 228     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)
 229         context.setStrokeStyle(m_state.strokeStyle);
 230 
 231     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)
 232         context.setFillRule(m_state.fillRule);
 233 
 234     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)
 235         context.setAlpha(m_state.alpha);
 236 
 237     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))
 238         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 239 
 240     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 241         context.setShouldAntialias(m_state.shouldAntialias);
 242 
 243     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 244         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 245 
 246     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 247         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 248 
 249     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 250         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 251 
 252     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 253         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 254 
 255     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)
 256         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
<a name="4" id="anc4"></a><span class="line-added"> 257 </span>
<span class="line-added"> 258 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 259     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 260         context.setUseDarkAppearance(m_state.useDarkAppearance);</span>
<span class="line-added"> 261 #endif</span>
 262 }
 263 
 264 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 265 {
 266     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);
 267 
 268     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)
 269         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 270 
 271     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)
 272         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 273 
 274     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)
 275         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 276 
 277     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)
 278         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 279 
 280     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {
 281         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
 282         ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
 283 #if USE(CG)
 284         ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
 285 #endif
 286     }
 287 
 288     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)
 289         ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
 290 
 291     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)
 292         ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
 293 
 294     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)
 295         ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
 296 
 297     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)
 298         ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
 299 
 300     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)
 301         ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
 302 
 303     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)
 304         ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
 305 
 306     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)
 307         ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
 308 
 309     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)
 310         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 311 
 312     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)
 313         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 314 
 315     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)
 316         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 317 
 318     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)
 319         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 320 
 321     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)
 322         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 323 
 324     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)
 325         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 326 
 327     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)
 328         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
<a name="5" id="anc5"></a><span class="line-added"> 329 </span>
<span class="line-added"> 330 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 331     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
<span class="line-added"> 332         ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);</span>
<span class="line-added"> 333 #endif</span>
 334 }
 335 
 336 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 337 {
 338     stateChange.dump(ts);
 339     return ts;
 340 }
 341 
 342 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 343     : m_paintInvalidationReasons(paintInvalidationReasons)
 344 {
 345 }
 346 
 347 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 348 {
 349     platformInit(platformGraphicsContext);
 350 }
 351 
 352 GraphicsContext::GraphicsContext(const GraphicsContextImplFactory&amp; factoryFunction)
 353     : m_impl(factoryFunction(*this))
 354 {
 355 }
 356 
 357 GraphicsContext::~GraphicsContext()
 358 {
 359     ASSERT(m_stack.isEmpty());
 360     ASSERT(!m_transparencyCount);
 361     platformDestroy();
 362 }
 363 
 364 bool GraphicsContext::hasPlatformContext() const
 365 {
 366     if (m_impl)
 367         return m_impl-&gt;hasPlatformContext();
 368     return !!m_data;
 369 }
 370 
 371 void GraphicsContext::save()
 372 {
 373     if (paintingDisabled())
 374         return;
 375 
 376     m_stack.append(m_state);
 377 
 378     if (m_impl) {
 379         m_impl-&gt;save();
 380         return;
 381     }
 382 
 383     savePlatformState();
 384 }
 385 
 386 void GraphicsContext::restore()
 387 {
 388     if (paintingDisabled())
 389         return;
 390 
 391     if (m_stack.isEmpty()) {
 392         LOG_ERROR(&quot;ERROR void GraphicsContext::restore() stack is empty&quot;);
 393         return;
 394     }
 395 
 396     m_state = m_stack.last();
 397     m_stack.removeLast();
 398 
 399     // Make sure we deallocate the state stack buffer when it goes empty.
 400     // Canvas elements will immediately save() again, but that goes into inline capacity.
 401     if (m_stack.isEmpty())
 402         m_stack.clear();
 403 
 404     if (m_impl) {
 405         m_impl-&gt;restore();
 406         return;
 407     }
 408 
 409     restorePlatformState();
 410 }
 411 
 412 void GraphicsContext::drawRaisedEllipse(const FloatRect&amp; rect, const Color&amp; ellipseColor, const Color&amp; shadowColor)
 413 {
 414     if (paintingDisabled())
 415         return;
 416 
 417     save();
 418 
 419     setStrokeColor(shadowColor);
 420     setFillColor(shadowColor);
 421 
 422     drawEllipse(FloatRect(rect.x(), rect.y() + 1, rect.width(), rect.height()));
 423 
 424     setStrokeColor(ellipseColor);
 425     setFillColor(ellipseColor);
 426 
 427     drawEllipse(rect);
 428 
 429     restore();
 430 }
 431 
 432 void GraphicsContext::setStrokeThickness(float thickness)
 433 {
 434     m_state.strokeThickness = thickness;
 435     if (m_impl) {
 436         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeThicknessChange);
 437         return;
 438     }
 439 
 440     setPlatformStrokeThickness(thickness);
 441 }
 442 
 443 void GraphicsContext::setStrokeStyle(StrokeStyle style)
 444 {
 445     m_state.strokeStyle = style;
 446     if (m_impl) {
 447         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeStyleChange);
 448         return;
 449     }
 450     setPlatformStrokeStyle(style);
 451 }
 452 
 453 void GraphicsContext::setStrokeColor(const Color&amp; color)
 454 {
 455     m_state.strokeColor = color;
 456     m_state.strokeGradient = nullptr;
 457     m_state.strokePattern = nullptr;
 458     if (m_impl) {
 459         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeColorChange);
 460         return;
 461     }
 462     setPlatformStrokeColor(color);
 463 }
 464 
 465 void GraphicsContext::setShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 466 {
 467     m_state.shadowOffset = offset;
 468     m_state.shadowBlur = blur;
 469     m_state.shadowColor = color;
 470 #if USE(CG)
 471     m_state.shadowsUseLegacyRadius = false;
 472 #endif
 473     if (m_impl) {
 474         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 475         return;
 476     }
 477     setPlatformShadow(offset, blur, color);
 478 }
 479 
 480 void GraphicsContext::setLegacyShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 481 {
 482     m_state.shadowOffset = offset;
 483     m_state.shadowBlur = blur;
 484     m_state.shadowColor = color;
 485 #if USE(CG)
 486     m_state.shadowsUseLegacyRadius = true;
 487 #endif
 488     if (m_impl) {
 489         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 490         return;
 491     }
 492     setPlatformShadow(offset, blur, color);
 493 }
 494 
 495 void GraphicsContext::clearShadow()
 496 {
 497     m_state.shadowOffset = FloatSize();
 498     m_state.shadowBlur = 0;
 499     m_state.shadowColor = Color();
 500 #if USE(CG)
 501     m_state.shadowsUseLegacyRadius = false;
 502 #endif
 503 
 504     if (m_impl) {
 505         m_impl-&gt;clearShadow();
 506         return;
 507     }
 508     clearPlatformShadow();
 509 }
 510 
 511 bool GraphicsContext::getShadow(FloatSize&amp; offset, float&amp; blur, Color&amp; color) const
 512 {
 513     offset = m_state.shadowOffset;
 514     blur = m_state.shadowBlur;
 515     color = m_state.shadowColor;
 516 
 517     return hasShadow();
 518 }
 519 
 520 void GraphicsContext::setFillColor(const Color&amp; color)
 521 {
 522     m_state.fillColor = color;
 523     m_state.fillGradient = nullptr;
 524     m_state.fillPattern = nullptr;
 525 
 526     if (m_impl) {
 527         m_impl-&gt;updateState(m_state, GraphicsContextState::FillColorChange);
 528         return;
 529     }
 530 
 531     setPlatformFillColor(color);
 532 }
 533 
 534 void GraphicsContext::setShadowsIgnoreTransforms(bool shadowsIgnoreTransforms)
 535 {
 536     m_state.shadowsIgnoreTransforms = shadowsIgnoreTransforms;
 537     if (m_impl)
 538         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowsIgnoreTransformsChange);
 539 }
 540 
 541 void GraphicsContext::setShouldAntialias(bool shouldAntialias)
 542 {
 543     m_state.shouldAntialias = shouldAntialias;
 544 
 545     if (m_impl) {
 546         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldAntialiasChange);
 547         return;
 548     }
 549 
 550     setPlatformShouldAntialias(shouldAntialias);
 551 }
 552 
 553 void GraphicsContext::setShouldSmoothFonts(bool shouldSmoothFonts)
 554 {
 555     m_state.shouldSmoothFonts = shouldSmoothFonts;
 556 
 557     if (m_impl) {
 558         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSmoothFontsChange);
 559         return;
 560     }
 561 
 562     setPlatformShouldSmoothFonts(shouldSmoothFonts);
 563 }
 564 
 565 void GraphicsContext::setShouldSubpixelQuantizeFonts(bool shouldSubpixelQuantizeFonts)
 566 {
 567     m_state.shouldSubpixelQuantizeFonts = shouldSubpixelQuantizeFonts;
 568     if (m_impl)
 569         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSubpixelQuantizeFontsChange);
 570 }
 571 
 572 void GraphicsContext::setImageInterpolationQuality(InterpolationQuality imageInterpolationQuality)
 573 {
 574     m_state.imageInterpolationQuality = imageInterpolationQuality;
 575 
 576     if (paintingDisabled())
 577         return;
 578 
 579     if (m_impl) {
 580         m_impl-&gt;updateState(m_state, GraphicsContextState::ImageInterpolationQualityChange);
 581         return;
 582     }
 583 
 584     setPlatformImageInterpolationQuality(imageInterpolationQuality);
 585 }
 586 
 587 void GraphicsContext::setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 588 {
 589     m_state.strokeGradient = nullptr;
 590     m_state.strokePattern = WTFMove(pattern);
 591     if (m_impl)
 592         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokePatternChange);
 593 }
 594 
 595 void GraphicsContext::setFillPattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 596 {
 597     m_state.fillGradient = nullptr;
 598     m_state.fillPattern = WTFMove(pattern);
 599     if (m_impl)
 600         m_impl-&gt;updateState(m_state, GraphicsContextState::FillPatternChange);
 601 }
 602 
 603 void GraphicsContext::setStrokeGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 604 {
 605     m_state.strokeGradient = WTFMove(gradient);
 606     m_state.strokePattern = nullptr;
 607     if (m_impl)
 608         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeGradientChange);
 609 }
 610 
 611 void GraphicsContext::setFillRule(WindRule fillRule)
 612 {
 613     m_state.fillRule = fillRule;
 614     if (m_impl)
 615         m_impl-&gt;updateState(m_state, GraphicsContextState::FillRuleChange);
 616 }
 617 
 618 void GraphicsContext::setFillGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 619 {
 620     m_state.fillGradient = WTFMove(gradient);
 621     m_state.fillPattern = nullptr;
 622     if (m_impl)
 623         m_impl-&gt;updateState(m_state, GraphicsContextState::FillGradientChange); // FIXME: also fill pattern?
 624 }
 625 
 626 void GraphicsContext::beginTransparencyLayer(float opacity)
 627 {
 628     if (m_impl) {
 629         m_impl-&gt;beginTransparencyLayer(opacity);
 630         return;
 631     }
 632     beginPlatformTransparencyLayer(opacity);
 633     ++m_transparencyCount;
 634 }
 635 
 636 void GraphicsContext::endTransparencyLayer()
 637 {
 638     if (m_impl) {
 639         m_impl-&gt;endTransparencyLayer();
 640         return;
 641     }
 642     endPlatformTransparencyLayer();
 643     ASSERT(m_transparencyCount &gt; 0);
 644     --m_transparencyCount;
 645 }
 646 
 647 float GraphicsContext::drawText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)
 648 {
 649     if (paintingDisabled())
 650         return 0;
 651 
 652     // Display list recording for text content is done at glyphs level. See GraphicsContext::drawGlyphs.
 653     return font.drawText(*this, run, point, from, to);
 654 }
 655 
 656 void GraphicsContext::drawGlyphs(const Font&amp; font, const GlyphBuffer&amp; buffer, unsigned from, unsigned numGlyphs, const FloatPoint&amp; point, FontSmoothingMode fontSmoothingMode)
 657 {
 658     if (paintingDisabled())
 659         return;
 660 
 661     if (m_impl) {
 662         m_impl-&gt;drawGlyphs(font, buffer, from, numGlyphs, point, fontSmoothingMode);
 663         return;
 664     }
 665 
 666     FontCascade::drawGlyphs(*this, font, buffer, from, numGlyphs, point, fontSmoothingMode);
 667 }
 668 
<a name="6" id="anc6"></a><span class="line-modified"> 669 void GraphicsContext::drawEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)</span>
 670 {
 671     if (paintingDisabled())
 672         return;
 673 
 674     font.drawEmphasisMarks(*this, run, mark, point, from, to);
 675 }
 676 
 677 void GraphicsContext::drawBidiText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
 678 {
 679     if (paintingDisabled())
 680         return;
 681 
 682     BidiResolver&lt;TextRunIterator, BidiCharacterRun&gt; bidiResolver;
 683     bidiResolver.setStatus(BidiStatus(run.direction(), run.directionalOverride()));
 684     bidiResolver.setPositionIgnoringNestedIsolates(TextRunIterator(&amp;run, 0));
 685 
 686     // FIXME: This ownership should be reversed. We should pass BidiRunList
 687     // to BidiResolver in createBidiRunsForLine.
 688     BidiRunList&lt;BidiCharacterRun&gt;&amp; bidiRuns = bidiResolver.runs();
 689     bidiResolver.createBidiRunsForLine(TextRunIterator(&amp;run, run.length()));
 690 
 691     if (!bidiRuns.runCount())
 692         return;
 693 
 694     FloatPoint currPoint = point;
 695     BidiCharacterRun* bidiRun = bidiRuns.firstRun();
 696     while (bidiRun) {
 697         TextRun subrun = run.subRun(bidiRun-&gt;start(), bidiRun-&gt;stop() - bidiRun-&gt;start());
 698         bool isRTL = bidiRun-&gt;level() % 2;
 699         subrun.setDirection(isRTL ? TextDirection::RTL : TextDirection::LTR);
 700         subrun.setDirectionalOverride(bidiRun-&gt;dirOverride(false));
 701 
 702         float width = font.drawText(*this, subrun, currPoint, 0, WTF::nullopt, customFontNotReadyAction);
 703         currPoint.move(width, 0);
 704 
 705         bidiRun = bidiRun-&gt;next();
 706     }
 707 
 708     bidiRuns.clear();
 709 }
 710 
 711 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 712 {
 713     return drawImage(image, FloatRect(destination, image.size()), FloatRect(FloatPoint(), image.size()), imagePaintingOptions);
 714 }
 715 
 716 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 717 {
<a name="7" id="anc7"></a>


 718     FloatRect srcRect(FloatPoint(), image.size());
<a name="8" id="anc8"></a>

 719     return drawImage(image, destination, srcRect, imagePaintingOptions);
 720 }
 721 
<a name="9" id="anc9"></a><span class="line-modified"> 722 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 723 {
 724     if (paintingDisabled())
 725         return ImageDrawResult::DidNothing;
 726 
 727     if (m_impl)
<a name="10" id="anc10"></a><span class="line-modified"> 728         return m_impl-&gt;drawImage(image, destination, source, options);</span>
 729 
<a name="11" id="anc11"></a><span class="line-modified"> 730     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 731     return image.draw(*this, destination, source, options);</span>
 732 }
 733 
<a name="12" id="anc12"></a><span class="line-modified"> 734 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)</span>
 735 {
 736     if (paintingDisabled())
 737         return ImageDrawResult::DidNothing;
 738 
 739     if (m_impl)
<a name="13" id="anc13"></a><span class="line-modified"> 740         return m_impl-&gt;drawTiledImage(image, destination, source, tileSize, spacing, options);</span>
 741 
<a name="14" id="anc14"></a><span class="line-modified"> 742     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 743     return image.drawTiled(*this, destination, source, tileSize, spacing, options);</span>
 744 }
 745 
 746 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,
<a name="15" id="anc15"></a><span class="line-modified"> 747     Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; options)</span>
 748 {
 749     if (paintingDisabled())
 750         return ImageDrawResult::DidNothing;
 751 
 752     if (m_impl)
<a name="16" id="anc16"></a><span class="line-modified"> 753         return m_impl-&gt;drawTiledImage(image, destination, source, tileScaleFactor, hRule, vRule, options);</span>
 754 
 755     if (hRule == Image::StretchTile &amp;&amp; vRule == Image::StretchTile) {
 756         // Just do a scale.
<a name="17" id="anc17"></a><span class="line-modified"> 757         return drawImage(image, destination, source, options);</span>
 758     }
 759 
<a name="18" id="anc18"></a><span class="line-modified"> 760     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 761     return image.drawTiled(*this, destination, source, tileScaleFactor, hRule, vRule, options.compositeOperator());</span>
 762 }
 763 
 764 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 765 {
 766     drawImageBuffer(image, FloatRect(destination, image.logicalSize()), FloatRect(FloatPoint(), image.logicalSize()), imagePaintingOptions);
 767 }
 768 
 769 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 770 {
 771     drawImageBuffer(image, destination, FloatRect(FloatPoint(), FloatSize(image.logicalSize())), imagePaintingOptions);
 772 }
 773 
<a name="19" id="anc19"></a><span class="line-modified"> 774 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 775 {
 776     if (paintingDisabled())
 777         return;
 778 
<a name="20" id="anc20"></a><span class="line-modified"> 779     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 780     image.draw(*this, destination, source, options);</span>
 781 }
 782 
 783 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 784 {
 785     if (!image)
 786         return;
 787     IntSize imageLogicalSize = image-&gt;logicalSize();
 788     drawConsumingImageBuffer(WTFMove(image), FloatRect(destination, imageLogicalSize), FloatRect(FloatPoint(), imageLogicalSize), imagePaintingOptions);
 789 }
 790 
 791 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 792 {
 793     if (!image)
 794         return;
 795     IntSize imageLogicalSize = image-&gt;logicalSize();
 796     drawConsumingImageBuffer(WTFMove(image), destination, FloatRect(FloatPoint(), FloatSize(imageLogicalSize)), imagePaintingOptions);
 797 }
 798 
<a name="21" id="anc21"></a><span class="line-modified"> 799 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)</span>
 800 {
 801     if (paintingDisabled() || !image)
 802         return;
 803 
<a name="22" id="anc22"></a><span class="line-modified"> 804     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());</span>
<span class="line-modified"> 805     ImageBuffer::drawConsuming(WTFMove(image), *this, destination, source, options);</span>
 806 }
 807 
 808 void GraphicsContext::clipRoundedRect(const FloatRoundedRect&amp; rect)
 809 {
 810     if (paintingDisabled())
 811         return;
 812 
 813     Path path;
 814     path.addRoundedRect(rect);
 815     clipPath(path);
 816 }
 817 
 818 void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect&amp; rect)
 819 {
 820     if (paintingDisabled())
 821         return;
 822 
 823     if (!rect.isRounded()) {
 824         clipOut(rect.rect());
 825         return;
 826     }
 827 
 828     Path path;
 829     path.addRoundedRect(rect);
 830     clipOut(path);
 831 }
 832 
 833 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 834 IntRect GraphicsContext::clipBounds() const
 835 {
 836     ASSERT_NOT_REACHED();
 837     return IntRect();
 838 }
 839 #endif
 840 
 841 void GraphicsContext::setTextDrawingMode(TextDrawingModeFlags mode)
 842 {
 843     m_state.textDrawingMode = mode;
 844     if (paintingDisabled())
 845         return;
 846 
 847     if (m_impl) {
 848         m_impl-&gt;updateState(m_state, GraphicsContextState::TextDrawingModeChange);
 849         return;
 850     }
 851     setPlatformTextDrawingMode(mode);
 852 }
 853 
 854 void GraphicsContext::fillRect(const FloatRect&amp; rect, Gradient&amp; gradient)
 855 {
 856     if (paintingDisabled())
 857         return;
 858 
 859     if (m_impl) {
 860         m_impl-&gt;fillRect(rect, gradient);
 861         return;
 862     }
 863 
 864     gradient.fill(*this, rect);
 865 }
 866 
 867 void GraphicsContext::fillRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
 868 {
 869     if (paintingDisabled())
 870         return;
 871 
 872     if (m_impl) {
 873         m_impl-&gt;fillRect(rect, color, op, blendMode);
 874         return;
 875     }
 876 
 877     CompositeOperator previousOperator = compositeOperation();
 878     setCompositeOperation(op, blendMode);
 879     fillRect(rect, color);
 880     setCompositeOperation(previousOperator);
 881 }
 882 
 883 #if !PLATFORM(JAVA) // FIXME-java: recheck
 884 void GraphicsContext::fillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
 885 {
 886     if (paintingDisabled())
 887         return;
 888 
 889     if (m_impl) {
 890         m_impl-&gt;fillRoundedRect(rect, color, blendMode);
 891         return;
 892     }
 893 
 894     if (rect.isRounded()) {
 895         setCompositeOperation(compositeOperation(), blendMode);
 896         platformFillRoundedRect(rect, color);
 897         setCompositeOperation(compositeOperation());
 898     } else
 899         fillRect(rect.rect(), color, compositeOperation(), blendMode);
 900 }
 901 #endif
 902 
 903 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 904 void GraphicsContext::fillRectWithRoundedHole(const IntRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
 905 {
 906     if (paintingDisabled())
 907         return;
 908 
 909     Path path;
 910     path.addRect(rect);
 911 
 912     if (!roundedHoleRect.radii().isZero())
 913         path.addRoundedRect(roundedHoleRect);
 914     else
 915         path.addRect(roundedHoleRect.rect());
 916 
 917     WindRule oldFillRule = fillRule();
 918     Color oldFillColor = fillColor();
 919 
 920     setFillRule(WindRule::EvenOdd);
 921     setFillColor(color);
 922 
 923     fillPath(path);
 924 
 925     setFillRule(oldFillRule);
 926     setFillColor(oldFillColor);
 927 }
 928 #endif
 929 
 930 void GraphicsContext::setAlpha(float alpha)
 931 {
 932     m_state.alpha = alpha;
 933     if (m_impl) {
 934         m_impl-&gt;updateState(m_state, GraphicsContextState::AlphaChange);
 935         return;
 936     }
 937     setPlatformAlpha(alpha);
 938 }
 939 
 940 void GraphicsContext::setCompositeOperation(CompositeOperator compositeOperation, BlendMode blendMode)
 941 {
 942     m_state.compositeOperator = compositeOperation;
 943     m_state.blendMode = blendMode;
 944     if (m_impl) {
 945         m_impl-&gt;updateState(m_state, GraphicsContextState::CompositeOperationChange);
 946         return;
 947     }
 948     setPlatformCompositeOperation(compositeOperation, blendMode);
 949 }
 950 
 951 void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
 952 {
 953     m_state.drawLuminanceMask = drawLuminanceMask;
 954     if (m_impl)
 955         m_impl-&gt;updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 956 }
 957 
<a name="23" id="anc23"></a><span class="line-added"> 958 #if HAVE(OS_DARK_MODE_SUPPORT)</span>
<span class="line-added"> 959 void GraphicsContext::setUseDarkAppearance(bool useDarkAppearance)</span>
<span class="line-added"> 960 {</span>
<span class="line-added"> 961     m_state.useDarkAppearance = useDarkAppearance;</span>
<span class="line-added"> 962     if (m_impl)</span>
<span class="line-added"> 963         m_impl-&gt;updateState(m_state, GraphicsContextState::UseDarkAppearanceChange);</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 #endif</span>
<span class="line-added"> 966 </span>
 967 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 968 // Implement this if you want to go push the drawing mode into your native context immediately.
 969 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 970 {
 971 }
 972 #endif
 973 
 974 #if !USE(CAIRO) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 975 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 976 {
 977 }
 978 #endif
 979 
 980 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
 981 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 982 {
 983 }
 984 #endif
 985 
 986 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO)
 987 bool GraphicsContext::isAcceleratedContext() const
 988 {
 989     return false;
 990 }
 991 #endif
 992 
 993 void GraphicsContext::adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle penStyle)
 994 {
 995     // For odd widths, we add in 0.5 to the appropriate x/y so that the float arithmetic
 996     // works out.  For example, with a border width of 3, WebKit will pass us (y1+y2)/2, e.g.,
 997     // (50+53)/2 = 103/2 = 51 when we want 51.5.  It is always true that an even width gave
 998     // us a perfect position, but an odd width gave us a position that is off by exactly 0.5.
 999     if (penStyle == DottedStroke || penStyle == DashedStroke) {
1000         if (p1.x() == p2.x()) {
1001             p1.setY(p1.y() + strokeWidth);
1002             p2.setY(p2.y() - strokeWidth);
1003         } else {
1004             p1.setX(p1.x() + strokeWidth);
1005             p2.setX(p2.x() - strokeWidth);
1006         }
1007     }
1008 
1009     if (static_cast&lt;int&gt;(strokeWidth) % 2) { //odd
1010         if (p1.x() == p2.x()) {
1011             // We&#39;re a vertical line.  Adjust our x.
1012             p1.setX(p1.x() + 0.5f);
1013             p2.setX(p2.x() + 0.5f);
1014         } else {
1015             // We&#39;re a horizontal line. Adjust our y.
1016             p1.setY(p1.y() + 0.5f);
1017             p2.setY(p2.y() + 0.5f);
1018         }
1019     }
1020 }
1021 
1022 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1023 void GraphicsContext::platformApplyDeviceScaleFactor(float)
1024 {
1025 }
1026 #endif
1027 
1028 void GraphicsContext::applyDeviceScaleFactor(float deviceScaleFactor)
1029 {
1030     scale(deviceScaleFactor);
1031 
1032     if (m_impl) {
1033         m_impl-&gt;applyDeviceScaleFactor(deviceScaleFactor);
1034         return;
1035     }
1036 
1037     platformApplyDeviceScaleFactor(deviceScaleFactor);
1038 }
1039 
1040 FloatSize GraphicsContext::scaleFactor() const
1041 {
1042     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1043     return FloatSize(transform.xScale(), transform.yScale());
1044 }
1045 
1046 FloatSize GraphicsContext::scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const
1047 {
1048     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1049     auto transformedDestRect = transform.mapRect(destRect);
1050     return transformedDestRect.size() / srcRect.size();
1051 }
1052 
1053 void GraphicsContext::fillEllipse(const FloatRect&amp; ellipse)
1054 {
1055     if (m_impl) {
1056         m_impl-&gt;fillEllipse(ellipse);
1057         return;
1058     }
1059 
1060     platformFillEllipse(ellipse);
1061 }
1062 
1063 void GraphicsContext::strokeEllipse(const FloatRect&amp; ellipse)
1064 {
1065     if (m_impl) {
1066         m_impl-&gt;strokeEllipse(ellipse);
1067         return;
1068     }
1069 
1070     platformStrokeEllipse(ellipse);
1071 }
1072 
1073 void GraphicsContext::fillEllipseAsPath(const FloatRect&amp; ellipse)
1074 {
1075     Path path;
1076     path.addEllipse(ellipse);
1077     fillPath(path);
1078 }
1079 
1080 void GraphicsContext::strokeEllipseAsPath(const FloatRect&amp; ellipse)
1081 {
1082     Path path;
1083     path.addEllipse(ellipse);
1084     strokePath(path);
1085 }
1086 
1087 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1088 void GraphicsContext::platformFillEllipse(const FloatRect&amp; ellipse)
1089 {
1090     if (paintingDisabled())
1091         return;
1092 
1093     fillEllipseAsPath(ellipse);
1094 }
1095 
1096 void GraphicsContext::platformStrokeEllipse(const FloatRect&amp; ellipse)
1097 {
1098     if (paintingDisabled())
1099         return;
1100 
1101     strokeEllipseAsPath(ellipse);
1102 }
1103 #endif
1104 
1105 FloatRect GraphicsContext::computeUnderlineBoundsForText(const FloatRect&amp; rect, bool printing)
1106 {
1107     Color dummyColor;
1108     return computeLineBoundsAndAntialiasingModeForText(rect, printing, dummyColor);
1109 }
1110 
1111 FloatRect GraphicsContext::computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp; rect, bool printing, Color&amp; color)
1112 {
1113     FloatPoint origin = rect.location();
1114     float thickness = std::max(rect.height(), 0.5f);
1115     if (printing)
1116         return FloatRect(origin, FloatSize(rect.width(), thickness));
1117 
1118     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1119     // Just compute scale in x dimension, assuming x and y scales are equal.
1120     float scale = transform.b() ? sqrtf(transform.a() * transform.a() + transform.b() * transform.b()) : transform.a();
1121     if (scale &lt; 1.0) {
1122         // This code always draws a line that is at least one-pixel line high,
1123         // which tends to visually overwhelm text at small scales. To counter this
1124         // effect, an alpha is applied to the underline color when text is at small scales.
1125         static const float minimumUnderlineAlpha = 0.4f;
1126         float shade = scale &gt; minimumUnderlineAlpha ? scale : minimumUnderlineAlpha;
1127         color = color.colorWithAlphaMultipliedBy(shade);
1128     }
1129 
1130     FloatPoint devicePoint = transform.mapPoint(rect.location());
1131     // Visual overflow might occur here due to integral roundf/ceilf. visualOverflowForDecorations adjusts the overflow value for underline decoration.
1132     FloatPoint deviceOrigin = FloatPoint(roundf(devicePoint.x()), ceilf(devicePoint.y()));
1133     if (auto inverse = transform.inverse())
1134         origin = inverse.value().mapPoint(deviceOrigin);
1135     return FloatRect(origin, FloatSize(rect.width(), thickness));
1136 }
1137 
1138 void GraphicsContext::applyState(const GraphicsContextState&amp; state)
1139 {
1140     setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
1141     setPlatformStrokeThickness(state.strokeThickness);
1142     setPlatformTextDrawingMode(state.textDrawingMode);
1143     setPlatformStrokeColor(state.strokeColor);
1144     setPlatformFillColor(state.fillColor);
1145     setPlatformStrokeStyle(state.strokeStyle);
1146     setPlatformAlpha(state.alpha);
1147     setPlatformCompositeOperation(state.compositeOperator, state.blendMode);
1148     setPlatformShouldAntialias(state.shouldAntialias);
1149     setPlatformShouldSmoothFonts(state.shouldSmoothFonts);
1150 }
1151 
1152 float GraphicsContext::dashedLineCornerWidthForStrokeWidth(float strokeWidth) const
1153 {
1154     float thickness = strokeThickness();
1155     return strokeStyle() == DottedStroke ? thickness : std::min(2.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1156 }
1157 
1158 float GraphicsContext::dashedLinePatternWidthForStrokeWidth(float strokeWidth) const
1159 {
1160     float thickness = strokeThickness();
1161     return strokeStyle() == DottedStroke ? thickness : std::min(3.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1162 }
1163 
1164 float GraphicsContext::dashedLinePatternOffsetForPatternAndStrokeWidth(float patternWidth, float strokeWidth) const
1165 {
1166     // Pattern starts with full fill and ends with the empty fill.
1167     // 1. Let&#39;s start with the empty phase after the corner.
1168     // 2. Check if we&#39;ve got odd or even number of patterns and whether they fully cover the line.
1169     // 3. In case of even number of patterns and/or remainder, move the pattern start position
1170     // so that the pattern is balanced between the corners.
1171     float patternOffset = patternWidth;
1172     int numberOfSegments = std::floor(strokeWidth / patternWidth);
1173     bool oddNumberOfSegments = numberOfSegments % 2;
1174     float remainder = strokeWidth - (numberOfSegments * patternWidth);
1175     if (oddNumberOfSegments &amp;&amp; remainder)
1176         patternOffset -= remainder / 2.0f;
1177     else if (!oddNumberOfSegments) {
1178         if (remainder)
1179             patternOffset += patternOffset - (patternWidth + remainder) / 2.0f;
1180         else
1181             patternOffset += patternWidth / 2.0f;
1182     }
1183 
1184     return patternOffset;
1185 }
1186 
1187 Vector&lt;FloatPoint&gt; GraphicsContext::centerLineAndCutOffCorners(bool isVerticalLine, float cornerWidth, FloatPoint point1, FloatPoint point2) const
1188 {
1189     // Center line and cut off corners for pattern painting.
1190     if (isVerticalLine) {
1191         float centerOffset = (point2.x() - point1.x()) / 2.0f;
1192         point1.move(centerOffset, cornerWidth);
1193         point2.move(-centerOffset, -cornerWidth);
1194     } else {
1195         float centerOffset = (point2.y() - point1.y()) / 2.0f;
1196         point1.move(cornerWidth, centerOffset);
1197         point2.move(-cornerWidth, -centerOffset);
1198     }
1199 
1200     return { point1, point2 };
1201 }
1202 
1203 #if !USE(CG)
1204 bool GraphicsContext::supportsInternalLinks() const
1205 {
1206     return false;
1207 }
1208 
1209 void GraphicsContext::setDestinationForRect(const String&amp;, const FloatRect&amp;)
1210 {
1211 }
1212 
1213 void GraphicsContext::addDestinationAtPoint(const String&amp;, const FloatPoint&amp;)
1214 {
1215 }
1216 #endif
1217 
1218 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>