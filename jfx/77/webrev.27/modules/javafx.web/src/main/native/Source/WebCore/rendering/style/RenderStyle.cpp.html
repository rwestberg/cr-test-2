<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
   3  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderStyle.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSParser.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSPropertyParser.h&quot;
  31 #include &quot;ContentData.h&quot;
  32 #include &quot;CursorList.h&quot;
  33 #include &quot;FloatRoundedRect.h&quot;
  34 #include &quot;FontCascade.h&quot;
  35 #include &quot;FontSelector.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;Pagination.h&quot;
  38 #include &quot;QuotesData.h&quot;
  39 #include &quot;RenderObject.h&quot;
  40 #include &quot;RenderTheme.h&quot;
  41 #include &quot;RuntimeEnabledFeatures.h&quot;
  42 #include &quot;ScaleTransformOperation.h&quot;
  43 #include &quot;ShadowData.h&quot;
  44 #include &quot;StyleBuilderConverter.h&quot;
  45 #include &quot;StyleImage.h&quot;
  46 #include &quot;StyleInheritedData.h&quot;
  47 #include &quot;StyleResolver.h&quot;
  48 #include &quot;StyleScrollSnapPoints.h&quot;
  49 #include &quot;StyleSelfAlignmentData.h&quot;
  50 #include &quot;StyleTreeResolver.h&quot;
  51 #include &quot;WillChangeData.h&quot;
  52 #include &lt;wtf/MathExtras.h&gt;
  53 #include &lt;wtf/PointerComparison.h&gt;
  54 #include &lt;wtf/StdLibExtras.h&gt;
  55 #include &lt;algorithm&gt;
  56 
  57 #if ENABLE(TEXT_AUTOSIZING)
  58 #include &lt;wtf/text/StringHash.h&gt;
  59 #endif
  60 
  61 namespace WebCore {
  62 
  63 struct SameSizeAsBorderValue {
  64     Color m_color;
  65     float m_width;
  66     int m_restBits;
  67 };
  68 
  69 COMPILE_ASSERT(sizeof(BorderValue) == sizeof(SameSizeAsBorderValue), BorderValue_should_not_grow);
  70 
  71 struct SameSizeAsRenderStyle {
  72     void* dataRefs[7];
  73     void* ownPtrs[1];
  74     void* dataRefSvgStyle;
  75     struct InheritedFlags {
  76         unsigned m_bitfields[2];
  77     } m_inheritedFlags;
  78 
  79     struct NonInheritedFlags {
  80         unsigned m_bitfields[2];
  81     } m_nonInheritedFlags;
  82 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
  83     bool deletionCheck;
  84 #endif
  85 };
  86 
  87 static_assert(sizeof(RenderStyle) == sizeof(SameSizeAsRenderStyle), &quot;RenderStyle should stay small&quot;);
  88 
  89 RenderStyle&amp; RenderStyle::defaultStyle()
  90 {
  91     static NeverDestroyed&lt;RenderStyle&gt; style { CreateDefaultStyle };
  92     return style;
  93 }
  94 
  95 RenderStyle RenderStyle::create()
  96 {
  97     return clone(defaultStyle());
  98 }
  99 
 100 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 101 {
 102     return clonePtr(defaultStyle());
 103 }
 104 
 105 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 106 {
 107     return RenderStyle(style, Clone);
 108 }
 109 
 110 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::clonePtr(const RenderStyle&amp; style)
 111 {
 112     return makeUnique&lt;RenderStyle&gt;(style, Clone);
 113 }
 114 
 115 RenderStyle RenderStyle::createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType display)
 116 {
 117     auto newStyle = create();
 118     newStyle.inheritFrom(parentStyle);
 119     newStyle.inheritUnicodeBidiFrom(&amp;parentStyle);
 120     newStyle.setDisplay(display);
 121     return newStyle;
 122 }
 123 
 124 RenderStyle RenderStyle::createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle)
 125 {
 126     ASSERT(pseudoStyle.styleType() == PseudoId::Before || pseudoStyle.styleType() == PseudoId::After);
 127 
 128     auto style = create();
 129     style.inheritFrom(pseudoStyle);
 130     return style;
 131 }
 132 
 133 RenderStyle::RenderStyle(RenderStyle&amp;&amp;) = default;
 134 RenderStyle&amp; RenderStyle::operator=(RenderStyle&amp;&amp;) = default;
 135 
 136 RenderStyle::RenderStyle(CreateDefaultStyleTag)
 137     : m_boxData(StyleBoxData::create())
 138     , m_visualData(StyleVisualData::create())
 139     , m_backgroundData(StyleBackgroundData::create())
 140     , m_surroundData(StyleSurroundData::create())
 141     , m_rareNonInheritedData(StyleRareNonInheritedData::create())
 142     , m_rareInheritedData(StyleRareInheritedData::create())
 143     , m_inheritedData(StyleInheritedData::create())
 144     , m_svgStyle(SVGRenderStyle::create())
 145 {
 146     m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(initialEmptyCells());
 147     m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(initialCaptionSide());
 148     m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(initialListStyleType());
 149     m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(initialListStylePosition());
 150     m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(initialVisibility());
 151     m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(initialTextAlign());
 152     m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(initialTextTransform());
 153     m_inheritedFlags.textDecorations = initialTextDecoration().toRaw();
 154     m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(initialCursor());
 155 #if ENABLE(CURSOR_VISIBILITY)
 156     m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(initialCursorVisibility());
 157 #endif
 158     m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(initialDirection());
 159     m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(initialWhiteSpace());
 160     m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(initialBorderCollapse());
 161     m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(initialRTLOrdering());
 162     m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(initialBoxDirection());
 163     m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(initialPrintColorAdjust());
 164     m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(initialPointerEvents());
 165     m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(InsideLink::NotInside);
 166     m_inheritedFlags.insideDefaultButton = false;
 167     m_inheritedFlags.writingMode = initialWritingMode();
 168 #if ENABLE(TEXT_AUTOSIZING)
 169     m_inheritedFlags.autosizeStatus = 0;
 170 #endif
 171 
 172     m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 173     m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 174     m_nonInheritedFlags.overflowX = static_cast&lt;unsigned&gt;(initialOverflowX());
 175     m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(initialOverflowY());
 176     m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(initialVerticalAlign());
 177     m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(initialClear());
 178     m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(initialPosition());
 179     m_nonInheritedFlags.unicodeBidi = initialUnicodeBidi();
 180     m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(initialFloating());
 181     m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(initialTableLayout());
 182     m_nonInheritedFlags.hasExplicitlySetDirection = false;
 183     m_nonInheritedFlags.hasExplicitlySetWritingMode = false;
 184     m_nonInheritedFlags.hasExplicitlySetTextAlign = false;
 185     m_nonInheritedFlags.hasViewportUnits = false;
 186     m_nonInheritedFlags.hasExplicitlyInheritedProperties = false;
 187     m_nonInheritedFlags.isUnique = false;
 188     m_nonInheritedFlags.emptyState = false;
 189     m_nonInheritedFlags.firstChildState = false;
 190     m_nonInheritedFlags.lastChildState = false;
 191     m_nonInheritedFlags.affectedByHover = false;
 192     m_nonInheritedFlags.affectedByActive = false;
 193     m_nonInheritedFlags.affectedByDrag = false;
 194     m_nonInheritedFlags.isLink = false;
 195     m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(PseudoId::None);
 196     m_nonInheritedFlags.pseudoBits = static_cast&lt;unsigned&gt;(PseudoId::None);
 197 
 198     static_assert((sizeof(InheritedFlags) &lt;= 8), &quot;InheritedFlags does not grow&quot;);
 199     static_assert((sizeof(NonInheritedFlags) &lt;= 8), &quot;NonInheritedFlags does not grow&quot;);
 200 }
 201 
 202 inline RenderStyle::RenderStyle(const RenderStyle&amp; other, CloneTag)
 203     : m_boxData(other.m_boxData)
 204     , m_visualData(other.m_visualData)
 205     , m_backgroundData(other.m_backgroundData)
 206     , m_surroundData(other.m_surroundData)
 207     , m_rareNonInheritedData(other.m_rareNonInheritedData)
 208     , m_nonInheritedFlags(other.m_nonInheritedFlags)
 209     , m_rareInheritedData(other.m_rareInheritedData)
 210     , m_inheritedData(other.m_inheritedData)
 211     , m_inheritedFlags(other.m_inheritedFlags)
 212     , m_svgStyle(other.m_svgStyle)
 213 {
 214 }
 215 
 216 inline RenderStyle::RenderStyle(RenderStyle&amp; a, RenderStyle&amp;&amp; b)
 217     : m_boxData(a.m_boxData.replace(WTFMove(b.m_boxData)))
 218     , m_visualData(a.m_visualData.replace(WTFMove(b.m_visualData)))
 219     , m_backgroundData(a.m_backgroundData.replace(WTFMove(b.m_backgroundData)))
 220     , m_surroundData(a.m_surroundData.replace(WTFMove(b.m_surroundData)))
 221     , m_rareNonInheritedData(a.m_rareNonInheritedData.replace(WTFMove(b.m_rareNonInheritedData)))
 222     , m_nonInheritedFlags(std::exchange(a.m_nonInheritedFlags, b.m_nonInheritedFlags))
 223     , m_rareInheritedData(a.m_rareInheritedData.replace(WTFMove(b.m_rareInheritedData)))
 224     , m_inheritedData(a.m_inheritedData.replace(WTFMove(b.m_inheritedData)))
 225     , m_inheritedFlags(std::exchange(a.m_inheritedFlags, b.m_inheritedFlags))
 226     , m_cachedPseudoStyles(std::exchange(a.m_cachedPseudoStyles, WTFMove(b.m_cachedPseudoStyles)))
 227     , m_svgStyle(a.m_svgStyle.replace(WTFMove(b.m_svgStyle)))
 228 {
 229 }
 230 
 231 RenderStyle::~RenderStyle()
 232 {
 233 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)
 234     ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 235     m_deletionHasBegun = true;
 236 #endif
 237 }
 238 
 239 RenderStyle RenderStyle::replace(RenderStyle&amp;&amp; newStyle)
 240 {
 241     return RenderStyle { *this, WTFMove(newStyle) };
 242 }
 243 
 244 static StyleSelfAlignmentData resolvedSelfAlignment(const StyleSelfAlignmentData&amp; value, ItemPosition normalValueBehavior)
 245 {
 246     if (value.position() == ItemPosition::Legacy || value.position() == ItemPosition::Normal || value.position() == ItemPosition::Auto)
 247         return { normalValueBehavior, OverflowAlignment::Default };
 248     return value;
 249 }
 250 
 251 StyleSelfAlignmentData RenderStyle::resolvedAlignItems(ItemPosition normalValueBehaviour) const
 252 {
 253     return resolvedSelfAlignment(alignItems(), normalValueBehaviour);
 254 }
 255 
 256 StyleSelfAlignmentData RenderStyle::resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 257 {
 258     // The auto keyword computes to the parent&#39;s align-items computed value.
 259     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 260     if (!parentStyle || alignSelf().position() != ItemPosition::Auto)
 261         return resolvedSelfAlignment(alignSelf(), normalValueBehaviour);
 262     return parentStyle-&gt;resolvedAlignItems(normalValueBehaviour);
 263 }
 264 
 265 StyleSelfAlignmentData RenderStyle::resolvedJustifyItems(ItemPosition normalValueBehaviour) const
 266 {
 267     return resolvedSelfAlignment(justifyItems(), normalValueBehaviour);
 268 }
 269 
 270 StyleSelfAlignmentData RenderStyle::resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 271 {
 272     // The auto keyword computes to the parent&#39;s justify-items computed value.
 273     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 274     if (!parentStyle || justifySelf().position() != ItemPosition::Auto)
 275         return resolvedSelfAlignment(justifySelf(), normalValueBehaviour);
 276     return parentStyle-&gt;resolvedJustifyItems(normalValueBehaviour);
 277 }
 278 
 279 static inline StyleContentAlignmentData resolvedContentAlignment(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 280 {
 281     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior : value;
 282 }
 283 
 284 StyleContentAlignmentData RenderStyle::resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 285 {
 286     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 287     return resolvedContentAlignment(alignContent(), normalValueBehavior);
 288 }
 289 
 290 StyleContentAlignmentData RenderStyle::resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 291 {
 292     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 293     return resolvedContentAlignment(justifyContent(), normalValueBehavior);
 294 }
 295 
 296 static inline ContentPosition resolvedContentAlignmentPosition(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 297 {
 298     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.position() : value.position();
 299 }
 300 
 301 static inline ContentDistribution resolvedContentAlignmentDistribution(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 302 {
 303     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.distribution() : value.distribution();
 304 }
 305 
 306 ContentPosition RenderStyle::resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 307 {
 308     return resolvedContentAlignmentPosition(justifyContent(), normalValueBehavior);
 309 }
 310 
 311 ContentDistribution RenderStyle::resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 312 {
 313     return resolvedContentAlignmentDistribution(justifyContent(), normalValueBehavior);
 314 }
 315 
 316 ContentPosition RenderStyle::resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 317 {
 318     return resolvedContentAlignmentPosition(alignContent(), normalValueBehavior);
 319 }
 320 
 321 ContentDistribution RenderStyle::resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 322 {
 323     return resolvedContentAlignmentDistribution(alignContent(), normalValueBehavior);
 324 }
 325 
 326 void RenderStyle::inheritFrom(const RenderStyle&amp; inheritParent)
 327 {
 328     m_rareInheritedData = inheritParent.m_rareInheritedData;
 329     m_inheritedData = inheritParent.m_inheritedData;
 330     m_inheritedFlags = inheritParent.m_inheritedFlags;
 331 
 332     if (m_svgStyle != inheritParent.m_svgStyle)
 333         m_svgStyle.access().inheritFrom(inheritParent.m_svgStyle.get());
 334 }
 335 
 336 void RenderStyle::copyNonInheritedFrom(const RenderStyle&amp; other)
 337 {
 338     m_boxData = other.m_boxData;
 339     m_visualData = other.m_visualData;
 340     m_backgroundData = other.m_backgroundData;
 341     m_surroundData = other.m_surroundData;
 342     m_rareNonInheritedData = other.m_rareNonInheritedData;
 343     m_nonInheritedFlags.copyNonInheritedFrom(other.m_nonInheritedFlags);
 344 
 345     if (m_svgStyle != other.m_svgStyle)
 346         m_svgStyle.access().copyNonInheritedFrom(other.m_svgStyle.get());
 347 
 348     ASSERT(zoom() == initialZoom());
 349 }
 350 
 351 void RenderStyle::copyContentFrom(const RenderStyle&amp; other)
 352 {
 353     if (!other.m_rareNonInheritedData-&gt;content)
 354         return;
 355     m_rareNonInheritedData.access().content = other.m_rareNonInheritedData-&gt;content-&gt;clone();
 356 }
 357 
 358 bool RenderStyle::operator==(const RenderStyle&amp; other) const
 359 {
 360     // compare everything except the pseudoStyle pointer
 361     return m_inheritedFlags == other.m_inheritedFlags
 362         &amp;&amp; m_nonInheritedFlags == other.m_nonInheritedFlags
 363         &amp;&amp; m_boxData == other.m_boxData
 364         &amp;&amp; m_visualData == other.m_visualData
 365         &amp;&amp; m_backgroundData == other.m_backgroundData
 366         &amp;&amp; m_surroundData == other.m_surroundData
 367         &amp;&amp; m_rareNonInheritedData == other.m_rareNonInheritedData
 368         &amp;&amp; m_rareInheritedData == other.m_rareInheritedData
 369         &amp;&amp; m_inheritedData == other.m_inheritedData
 370         &amp;&amp; m_svgStyle == other.m_svgStyle;
 371 }
 372 
 373 bool RenderStyle::hasUniquePseudoStyle() const
 374 {
 375     if (!m_cachedPseudoStyles || styleType() != PseudoId::None)
 376         return false;
 377 
 378     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 379         if (pseudoStyle-&gt;unique())
 380             return true;
 381     }
 382 
 383     return false;
 384 }
 385 
 386 RenderStyle* RenderStyle::getCachedPseudoStyle(PseudoId pid) const
 387 {
 388     if (!m_cachedPseudoStyles || !m_cachedPseudoStyles-&gt;size())
 389         return nullptr;
 390 
 391     if (styleType() != PseudoId::None)
 392         return nullptr;
 393 
 394     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 395         if (pseudoStyle-&gt;styleType() == pid)
 396             return pseudoStyle.get();
 397     }
 398 
 399     return nullptr;
 400 }
 401 
 402 RenderStyle* RenderStyle::addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt; pseudo)
 403 {
 404     if (!pseudo)
 405         return nullptr;
 406 
 407     ASSERT(pseudo-&gt;styleType() &gt; PseudoId::None);
 408 
 409     RenderStyle* result = pseudo.get();
 410 
 411     if (!m_cachedPseudoStyles)
 412         m_cachedPseudoStyles = makeUnique&lt;PseudoStyleCache&gt;();
 413 
 414     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 415 
 416     return result;
 417 }
 418 
 419 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 420 {
 421     if (!m_cachedPseudoStyles)
 422         return;
 423     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 424         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 425         if (pseudoStyle-&gt;styleType() == pid) {
 426             m_cachedPseudoStyles-&gt;remove(i);
 427             return;
 428         }
 429     }
 430 }
 431 
 432 bool RenderStyle::inheritedNotEqual(const RenderStyle* other) const
 433 {
 434     return m_inheritedFlags != other-&gt;m_inheritedFlags
 435         || m_inheritedData != other-&gt;m_inheritedData
 436         || m_svgStyle-&gt;inheritedNotEqual(other-&gt;m_svgStyle)
 437         || m_rareInheritedData != other-&gt;m_rareInheritedData;
 438 }
 439 
 440 #if ENABLE(TEXT_AUTOSIZING)
 441 
 442 static inline unsigned computeFontHash(const FontCascade&amp; font)
 443 {
 444     IntegerHasher hasher;
 445     hasher.add(ASCIICaseInsensitiveHash::hash(font.fontDescription().firstFamily()));
 446     hasher.add(font.fontDescription().specifiedSize());
 447     return hasher.hash();
 448 }
 449 
 450 unsigned RenderStyle::hashForTextAutosizing() const
 451 {
 452     // FIXME: Not a very smart hash. Could be improved upon. See &lt;https://bugs.webkit.org/show_bug.cgi?id=121131&gt;.
 453     unsigned hash = m_rareNonInheritedData-&gt;appearance;
 454     hash ^= m_rareNonInheritedData-&gt;marginBeforeCollapse;
 455     hash ^= m_rareNonInheritedData-&gt;marginAfterCollapse;
 456     hash ^= m_rareNonInheritedData-&gt;lineClamp.value();
 457     hash ^= m_rareInheritedData-&gt;overflowWrap;
 458     hash ^= m_rareInheritedData-&gt;nbspMode;
 459     hash ^= m_rareInheritedData-&gt;lineBreak;
 460     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;specifiedLineHeight.value());
 461     hash ^= computeFontHash(m_inheritedData-&gt;fontCascade);
 462     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;horizontalBorderSpacing);
 463     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;verticalBorderSpacing);
 464     hash ^= m_inheritedFlags.boxDirection;
 465     hash ^= m_inheritedFlags.rtlOrdering;
 466     hash ^= m_nonInheritedFlags.position;
 467     hash ^= m_nonInheritedFlags.floating;
 468     hash ^= m_rareNonInheritedData-&gt;textOverflow;
 469     hash ^= m_rareInheritedData-&gt;textSecurity;
 470     return hash;
 471 }
 472 
 473 bool RenderStyle::equalForTextAutosizing(const RenderStyle&amp; other) const
 474 {
 475     return m_rareNonInheritedData-&gt;appearance == other.m_rareNonInheritedData-&gt;appearance
 476         &amp;&amp; m_rareNonInheritedData-&gt;marginBeforeCollapse == other.m_rareNonInheritedData-&gt;marginBeforeCollapse
 477         &amp;&amp; m_rareNonInheritedData-&gt;marginAfterCollapse == other.m_rareNonInheritedData-&gt;marginAfterCollapse
 478         &amp;&amp; m_rareNonInheritedData-&gt;lineClamp == other.m_rareNonInheritedData-&gt;lineClamp
 479         &amp;&amp; m_rareInheritedData-&gt;textSizeAdjust == other.m_rareInheritedData-&gt;textSizeAdjust
 480         &amp;&amp; m_rareInheritedData-&gt;overflowWrap == other.m_rareInheritedData-&gt;overflowWrap
 481         &amp;&amp; m_rareInheritedData-&gt;nbspMode == other.m_rareInheritedData-&gt;nbspMode
 482         &amp;&amp; m_rareInheritedData-&gt;lineBreak == other.m_rareInheritedData-&gt;lineBreak
 483         &amp;&amp; m_rareInheritedData-&gt;textSecurity == other.m_rareInheritedData-&gt;textSecurity
 484         &amp;&amp; m_inheritedData-&gt;specifiedLineHeight == other.m_inheritedData-&gt;specifiedLineHeight
 485         &amp;&amp; m_inheritedData-&gt;fontCascade.equalForTextAutoSizing(other.m_inheritedData-&gt;fontCascade)
 486         &amp;&amp; m_inheritedData-&gt;horizontalBorderSpacing == other.m_inheritedData-&gt;horizontalBorderSpacing
 487         &amp;&amp; m_inheritedData-&gt;verticalBorderSpacing == other.m_inheritedData-&gt;verticalBorderSpacing
 488         &amp;&amp; m_inheritedFlags.boxDirection == other.m_inheritedFlags.boxDirection
 489         &amp;&amp; m_inheritedFlags.rtlOrdering == other.m_inheritedFlags.rtlOrdering
 490         &amp;&amp; m_nonInheritedFlags.position == other.m_nonInheritedFlags.position
 491         &amp;&amp; m_nonInheritedFlags.floating == other.m_nonInheritedFlags.floating
 492         &amp;&amp; m_rareNonInheritedData-&gt;textOverflow == other.m_rareNonInheritedData-&gt;textOverflow;
 493 }
 494 
 495 bool RenderStyle::isIdempotentTextAutosizingCandidate() const
 496 {
 497     // Refer to &lt;rdar://problem/51826266&gt; for more information regarding how this function was generated.
 498     auto fields = OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 499     if (fields.contains(AutosizeStatus::Fields::AvoidSubtree))
 500         return false;
 501 
 502     const float smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 5;
 503     const float largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 25;
 504 
 505     if (fields.contains(AutosizeStatus::Fields::FixedHeight)) {
 506         if (fields.contains(AutosizeStatus::Fields::FixedWidth)) {
 507             if (whiteSpace() == WhiteSpace::NoWrap) {
 508                 if (width().isFixed())
 509                     return false;
 510 
 511                 if (height().isFixed() &amp;&amp; specifiedLineHeight().isFixed()) {
 512                     float specifiedSize = specifiedFontSize();
 513                     if (height().value() == specifiedSize &amp;&amp; specifiedLineHeight().value() == specifiedSize)
 514                         return false;
 515                 }
 516 
 517                 return true;
 518             }
 519 
 520             if (fields.contains(AutosizeStatus::Fields::Floating)) {
 521                 if (specifiedLineHeight().isFixed() &amp;&amp; height().isFixed()) {
 522                     float specifiedSize = specifiedFontSize();
 523                     if (specifiedLineHeight().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText
 524                         &amp;&amp; height().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText) {
 525                         return true;
 526                     }
 527                 }
 528                 return false;
 529             }
 530 
 531             if (fields.contains(AutosizeStatus::Fields::OverflowXHidden))
 532                 return false;
 533 
 534             return true;
 535         }
 536 
 537         if (fields.contains(AutosizeStatus::Fields::OverflowXHidden)) {
 538             if (fields.contains(AutosizeStatus::Fields::Floating))
 539                 return false;
 540 
 541             return true;
 542         }
 543 
 544         return true;
 545     }
 546 
 547     if (width().isFixed()) {
 548         if (breakWords())
 549             return true;
 550 
 551         return false;
 552     }
 553 
 554     if (textSizeAdjust().isPercentage() &amp;&amp; textSizeAdjust().percentage() == 100) {
 555         if (fields.contains(AutosizeStatus::Fields::Floating))
 556             return true;
 557 
 558         if (fields.contains(AutosizeStatus::Fields::FixedWidth))
 559             return true;
 560 
 561         if (specifiedLineHeight().isFixed() &amp;&amp; specifiedLineHeight().value() - specifiedFontSize() &gt; largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText)
 562             return true;
 563 
 564         return false;
 565     }
 566 
 567     if (hasBackgroundImage() &amp;&amp; backgroundRepeatX() == FillRepeat::NoRepeat &amp;&amp; backgroundRepeatY() == FillRepeat::NoRepeat)
 568         return false;
 569 
 570     return true;
 571 }
 572 
 573 AutosizeStatus RenderStyle::autosizeStatus() const
 574 {
 575     return OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 576 }
 577 
 578 void RenderStyle::setAutosizeStatus(AutosizeStatus autosizeStatus)
 579 {
 580     m_inheritedFlags.autosizeStatus = autosizeStatus.fields().toRaw();
 581 }
 582 
 583 #endif // ENABLE(TEXT_AUTOSIZING)
 584 
 585 bool RenderStyle::inheritedDataShared(const RenderStyle* other) const
 586 {
 587     // This is a fast check that only looks if the data structures are shared.
 588     return m_inheritedFlags == other-&gt;m_inheritedFlags
 589         &amp;&amp; m_inheritedData.ptr() == other-&gt;m_inheritedData.ptr()
 590         &amp;&amp; m_svgStyle.ptr() == other-&gt;m_svgStyle.ptr()
 591         &amp;&amp; m_rareInheritedData.ptr() == other-&gt;m_rareInheritedData.ptr();
 592 }
 593 
 594 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 595 {
 596     // If any unit types are different, then we can&#39;t guarantee
 597     // that this was just a movement.
 598     if (a.left().type() != b.left().type()
 599         || a.right().type() != b.right().type()
 600         || a.top().type() != b.top().type()
 601         || a.bottom().type() != b.bottom().type())
 602         return false;
 603 
 604     // Only one unit can be non-auto in the horizontal direction and
 605     // in the vertical direction.  Otherwise the adjustment of values
 606     // is changing the size of the box.
 607     if (!a.left().isIntrinsicOrAuto() &amp;&amp; !a.right().isIntrinsicOrAuto())
 608         return false;
 609     if (!a.top().isIntrinsicOrAuto() &amp;&amp; !a.bottom().isIntrinsicOrAuto())
 610         return false;
 611     // If our width is auto and left or right is specified then this
 612     // is not just a movement - we need to resize to our container.
 613     if ((!a.left().isIntrinsicOrAuto() || !a.right().isIntrinsicOrAuto()) &amp;&amp; width.isIntrinsicOrAuto())
 614         return false;
 615 
 616     // One of the units is fixed or percent in both directions and stayed
 617     // that way in the new style.  Therefore all we are doing is moving.
 618     return true;
 619 }
 620 
 621 inline bool RenderStyle::changeAffectsVisualOverflow(const RenderStyle&amp; other) const
 622 {
 623     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 624         &amp;&amp; !arePointingToEqualData(m_rareNonInheritedData-&gt;boxShadow, other.m_rareNonInheritedData-&gt;boxShadow))
 625         return true;
 626 
 627     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 628         &amp;&amp; !arePointingToEqualData(m_rareInheritedData-&gt;textShadow, other.m_rareInheritedData-&gt;textShadow))
 629         return true;
 630 
 631     if (m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
 632         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
 633         || m_rareInheritedData-&gt;textDecorationThickness != other.m_rareInheritedData-&gt;textDecorationThickness
 634         || m_rareInheritedData-&gt;textUnderlineOffset != other.m_rareInheritedData-&gt;textUnderlineOffset
 635         || m_rareInheritedData-&gt;textUnderlinePosition != other.m_rareInheritedData-&gt;textUnderlinePosition) {
 636         // Underlines are always drawn outside of their textbox bounds when text-underline-position: under;
 637         // is specified. We can take an early out here.
 638         if (textUnderlinePosition() == TextUnderlinePosition::Under || other.textUnderlinePosition() == TextUnderlinePosition::Under)
 639             return true;
 640         return visualOverflowForDecorations(*this, nullptr) != visualOverflowForDecorations(other, nullptr);
 641     }
 642 
 643     if (hasOutlineInVisualOverflow() != other.hasOutlineInVisualOverflow())
 644         return true;
 645     return false;
 646 }
 647 
 648 static bool rareNonInheritedDataChangeRequiresLayout(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 649 {
 650     ASSERT(&amp;first != &amp;second);
 651 
 652     if (first.appearance != second.appearance
 653         || first.marginBeforeCollapse != second.marginBeforeCollapse
 654         || first.marginAfterCollapse != second.marginAfterCollapse
 655         || first.lineClamp != second.lineClamp
 656         || first.initialLetter != second.initialLetter
 657         || first.textOverflow != second.textOverflow)
 658         return true;
 659 
 660     if (first.shapeMargin != second.shapeMargin)
 661         return true;
 662 
 663     if (first.deprecatedFlexibleBox != second.deprecatedFlexibleBox)
 664         return true;
 665 
 666     if (first.flexibleBox != second.flexibleBox)
 667         return true;
 668 
 669     if (first.order != second.order
 670         || first.alignContent != second.alignContent
 671         || first.alignItems != second.alignItems
 672         || first.alignSelf != second.alignSelf
 673         || first.justifyContent != second.justifyContent
 674         || first.justifyItems != second.justifyItems
 675         || first.justifySelf != second.justifySelf)
 676         return true;
 677 
 678     if (!arePointingToEqualData(first.boxReflect, second.boxReflect))
 679         return true;
 680 
 681     if (first.multiCol != second.multiCol)
 682         return true;
 683 
 684     if (first.transform.ptr() != second.transform.ptr()) {
 685         if (first.transform-&gt;hasTransform() != second.transform-&gt;hasTransform())
 686             return true;
 687         if (*first.transform != *second.transform) {
 688             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Transform);
 689             // Don&#39;t return; keep looking for another change
 690         }
 691     }
 692 
 693     if (first.grid != second.grid
 694         || first.gridItem != second.gridItem)
 695         return true;
 696 
 697     if (!arePointingToEqualData(first.willChange, second.willChange)) {
 698         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::WillChange);
 699         // Don&#39;t return; keep looking for another change
 700     }
 701 
 702     if (first.textCombine != second.textCombine)
 703         return true;
 704 
 705     if (first.breakBefore != second.breakBefore
 706         || first.breakAfter != second.breakAfter
 707         || first.breakInside != second.breakInside)
 708         return true;
 709 
 710     if (first.hasOpacity() != second.hasOpacity()) {
 711         // FIXME: We would like to use SimplifiedLayout here, but we can&#39;t quite do that yet.
 712         // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 713         // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 714         // In addition we need to solve the floating object issue when layers come and go. Right now
 715         // a full layout is necessary to keep floating object lists sane.
 716         return true;
 717     }
 718 
 719 #if ENABLE(CSS_COMPOSITING)
 720     if (first.isolation != second.isolation) {
 721         // Ideally this would trigger a cheaper layout that just updates layer z-order trees (webit.org/b/190088).
 722         return true;
 723     }
 724 #endif
 725 
 726     if (first.hasFilters() != second.hasFilters())
 727         return true;
 728 
 729 #if ENABLE(FILTERS_LEVEL_2)
 730     if (first.hasBackdropFilters() != second.hasBackdropFilters())
 731         return true;
 732 #endif
 733 
 734     return false;
 735 }
 736 
 737 static bool rareInheritedDataChangeRequiresLayout(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
 738 {
 739     ASSERT(&amp;first != &amp;second);
 740 
 741     if (first.indent != second.indent
 742 #if ENABLE(CSS3_TEXT)
 743         || first.textAlignLast != second.textAlignLast
 744         || first.textJustify != second.textJustify
 745         || first.textIndentLine != second.textIndentLine
 746 #endif
 747         || first.effectiveZoom != second.effectiveZoom
 748         || first.textZoom != second.textZoom
 749 #if ENABLE(TEXT_AUTOSIZING)
 750         || first.textSizeAdjust != second.textSizeAdjust
 751 #endif
 752         || first.wordBreak != second.wordBreak
 753         || first.overflowWrap != second.overflowWrap
 754         || first.nbspMode != second.nbspMode
 755         || first.lineBreak != second.lineBreak
 756         || first.textSecurity != second.textSecurity
 757         || first.hyphens != second.hyphens
 758         || first.hyphenationLimitBefore != second.hyphenationLimitBefore
 759         || first.hyphenationLimitAfter != second.hyphenationLimitAfter
 760         || first.hyphenationString != second.hyphenationString
 761         || first.rubyPosition != second.rubyPosition
 762         || first.textEmphasisMark != second.textEmphasisMark
 763         || first.textEmphasisPosition != second.textEmphasisPosition
 764         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 765         || first.textOrientation != second.textOrientation
 766         || first.tabSize != second.tabSize
 767         || first.lineBoxContain != second.lineBoxContain
 768         || first.lineGrid != second.lineGrid
 769 #if ENABLE(CSS_IMAGE_ORIENTATION)
 770         || first.imageOrientation != second.imageOrientation
 771 #endif
 772 #if ENABLE(CSS_IMAGE_RESOLUTION)
 773         || first.imageResolutionSource != second.imageResolutionSource
 774         || first.imageResolutionSnap != second.imageResolutionSnap
 775         || first.imageResolution != second.imageResolution
 776 #endif
 777         || first.lineSnap != second.lineSnap
 778         || first.lineAlign != second.lineAlign
 779         || first.hangingPunctuation != second.hangingPunctuation
 780 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 781         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 782 #endif
 783         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 784         return true;
 785 
 786     if (first.textStrokeWidth != second.textStrokeWidth)
 787         return true;
 788 
 789     // These properties affect the cached stroke bounding box rects.
 790     if (first.capStyle != second.capStyle
 791         || first.joinStyle != second.joinStyle
 792         || first.strokeWidth != second.strokeWidth
 793         || first.miterLimit != second.miterLimit)
 794         return true;
 795 
 796     if (!arePointingToEqualData(first.quotes, second.quotes))
 797         return true;
 798 
 799     return false;
 800 }
 801 
 802 bool RenderStyle::changeRequiresLayout(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 803 {
 804     if (m_boxData.ptr() != other.m_boxData.ptr()) {
 805         if (m_boxData-&gt;width() != other.m_boxData-&gt;width()
 806             || m_boxData-&gt;minWidth() != other.m_boxData-&gt;minWidth()
 807             || m_boxData-&gt;maxWidth() != other.m_boxData-&gt;maxWidth()
 808             || m_boxData-&gt;height() != other.m_boxData-&gt;height()
 809             || m_boxData-&gt;minHeight() != other.m_boxData-&gt;minHeight()
 810             || m_boxData-&gt;maxHeight() != other.m_boxData-&gt;maxHeight())
 811             return true;
 812 
 813         if (m_boxData-&gt;verticalAlign() != other.m_boxData-&gt;verticalAlign())
 814             return true;
 815 
 816         if (m_boxData-&gt;boxSizing() != other.m_boxData-&gt;boxSizing())
 817             return true;
 818     }
 819 
 820     if (m_surroundData-&gt;margin != other.m_surroundData-&gt;margin)
 821         return true;
 822 
 823     if (m_surroundData-&gt;padding != other.m_surroundData-&gt;padding)
 824         return true;
 825 
 826     // FIXME: We should add an optimized form of layout that just recomputes visual overflow.
 827     if (changeAffectsVisualOverflow(other))
 828         return true;
 829 
 830     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 831         &amp;&amp; rareNonInheritedDataChangeRequiresLayout(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
 832         return true;
 833 
 834     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 835         &amp;&amp; rareInheritedDataChangeRequiresLayout(*m_rareInheritedData, *other.m_rareInheritedData))
 836         return true;
 837 
 838     if (m_inheritedData.ptr() != other.m_inheritedData.ptr()) {
 839         if (m_inheritedData-&gt;lineHeight != other.m_inheritedData-&gt;lineHeight
 840 #if ENABLE(TEXT_AUTOSIZING)
 841             || m_inheritedData-&gt;specifiedLineHeight != other.m_inheritedData-&gt;specifiedLineHeight
 842 #endif
 843             || m_inheritedData-&gt;fontCascade != other.m_inheritedData-&gt;fontCascade
 844             || m_inheritedData-&gt;horizontalBorderSpacing != other.m_inheritedData-&gt;horizontalBorderSpacing
 845             || m_inheritedData-&gt;verticalBorderSpacing != other.m_inheritedData-&gt;verticalBorderSpacing)
 846             return true;
 847     }
 848 
 849     if (m_inheritedFlags.boxDirection != other.m_inheritedFlags.boxDirection
 850         || m_inheritedFlags.rtlOrdering != other.m_inheritedFlags.rtlOrdering
 851         || m_nonInheritedFlags.position != other.m_nonInheritedFlags.position
 852         || m_nonInheritedFlags.floating != other.m_nonInheritedFlags.floating
 853         || m_nonInheritedFlags.originalDisplay != other.m_nonInheritedFlags.originalDisplay
 854         || m_nonInheritedFlags.verticalAlign != other.m_nonInheritedFlags.verticalAlign)
 855         return true;
 856 
 857     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) &gt;= DisplayType::Table) {
 858         if (m_inheritedFlags.borderCollapse != other.m_inheritedFlags.borderCollapse
 859             || m_inheritedFlags.emptyCells != other.m_inheritedFlags.emptyCells
 860             || m_inheritedFlags.captionSide != other.m_inheritedFlags.captionSide
 861             || m_nonInheritedFlags.tableLayout != other.m_nonInheritedFlags.tableLayout)
 862             return true;
 863 
 864         // In the collapsing border model, &#39;hidden&#39; suppresses other borders, while &#39;none&#39;
 865         // does not, so these style differences can be width differences.
 866         if (m_inheritedFlags.borderCollapse
 867             &amp;&amp; ((borderTopStyle() == BorderStyle::Hidden &amp;&amp; other.borderTopStyle() == BorderStyle::None)
 868                 || (borderTopStyle() == BorderStyle::None &amp;&amp; other.borderTopStyle() == BorderStyle::Hidden)
 869                 || (borderBottomStyle() == BorderStyle::Hidden &amp;&amp; other.borderBottomStyle() == BorderStyle::None)
 870                 || (borderBottomStyle() == BorderStyle::None &amp;&amp; other.borderBottomStyle() == BorderStyle::Hidden)
 871                 || (borderLeftStyle() == BorderStyle::Hidden &amp;&amp; other.borderLeftStyle() == BorderStyle::None)
 872                 || (borderLeftStyle() == BorderStyle::None &amp;&amp; other.borderLeftStyle() == BorderStyle::Hidden)
 873                 || (borderRightStyle() == BorderStyle::Hidden &amp;&amp; other.borderRightStyle() == BorderStyle::None)
 874                 || (borderRightStyle() == BorderStyle::None &amp;&amp; other.borderRightStyle() == BorderStyle::Hidden)))
 875             return true;
 876     }
 877 
 878     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) == DisplayType::ListItem) {
 879         if (m_inheritedFlags.listStyleType != other.m_inheritedFlags.listStyleType
 880             || m_inheritedFlags.listStylePosition != other.m_inheritedFlags.listStylePosition)
 881             return true;
 882     }
 883 
 884     if (m_inheritedFlags.textAlign != other.m_inheritedFlags.textAlign
 885         || m_inheritedFlags.textTransform != other.m_inheritedFlags.textTransform
 886         || m_inheritedFlags.direction != other.m_inheritedFlags.direction
 887         || m_inheritedFlags.whiteSpace != other.m_inheritedFlags.whiteSpace
 888         || m_nonInheritedFlags.clear != other.m_nonInheritedFlags.clear
 889         || m_nonInheritedFlags.unicodeBidi != other.m_nonInheritedFlags.unicodeBidi)
 890         return true;
 891 
 892     // Check block flow direction.
 893     if (m_inheritedFlags.writingMode != other.m_inheritedFlags.writingMode)
 894         return true;
 895 
 896     // Overflow returns a layout hint.
 897     if (m_nonInheritedFlags.overflowX != other.m_nonInheritedFlags.overflowX
 898         || m_nonInheritedFlags.overflowY != other.m_nonInheritedFlags.overflowY)
 899         return true;
 900 
 901     // If our border widths change, then we need to layout.  Other changes to borders
 902     // only necessitate a repaint.
 903     if (borderLeftWidth() != other.borderLeftWidth()
 904         || borderTopWidth() != other.borderTopWidth()
 905         || borderBottomWidth() != other.borderBottomWidth()
 906         || borderRightWidth() != other.borderRightWidth())
 907         return true;
 908 
 909     // If the counter directives change, trigger a relayout to re-calculate counter values and rebuild the counter node tree.
 910     if (!arePointingToEqualData(m_rareNonInheritedData-&gt;counterDirectives, other.m_rareNonInheritedData-&gt;counterDirectives))
 911         return true;
 912 
 913     if ((visibility() == Visibility::Collapse) != (other.visibility() == Visibility::Collapse))
 914         return true;
 915 
 916     if (position() != PositionType::Static) {
 917         if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 918             // FIXME: We would like to use SimplifiedLayout for relative positioning, but we can&#39;t quite do that yet.
 919             // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 920             // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 921             if (position() != PositionType::Absolute)
 922                 return true;
 923 
 924             // Optimize for the case where a positioned layer is moving but not changing size.
 925             if (!positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 926                 return true;
 927         }
 928     }
 929 
 930     bool hasFirstLineStyle = hasPseudoStyle(PseudoId::FirstLine);
 931     if (hasFirstLineStyle != other.hasPseudoStyle(PseudoId::FirstLine))
 932         return true;
 933     if (hasFirstLineStyle) {
 934         auto* firstLineStyle = getCachedPseudoStyle(PseudoId::FirstLine);
 935         if (!firstLineStyle)
 936             return true;
 937         auto* otherFirstLineStyle = other.getCachedPseudoStyle(PseudoId::FirstLine);
 938         if (!otherFirstLineStyle)
 939             return true;
 940         // FIXME: Not all first line style changes actually need layout.
 941         if (*firstLineStyle != *otherFirstLineStyle)
 942             return true;
 943     }
 944 
 945     return false;
 946 }
 947 
 948 bool RenderStyle::changeRequiresPositionedLayoutOnly(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
 949 {
 950     if (position() == PositionType::Static)
 951         return false;
 952 
 953     if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 954         // Optimize for the case where a positioned layer is moving but not changing size.
 955         if (position() == PositionType::Absolute &amp;&amp; positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 956             return true;
 957     }
 958 
 959     return false;
 960 }
 961 
 962 static bool rareNonInheritedDataChangeRequiresLayerRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 963 {
 964 #if ENABLE(CSS_COMPOSITING)
 965     if (first.effectiveBlendMode != second.effectiveBlendMode)
 966         return true;
 967 #endif
 968 
 969     if (first.opacity != second.opacity) {
 970         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Opacity);
 971         // Don&#39;t return true; keep looking for another change.
 972     }
 973 
 974     if (first.filter != second.filter) {
 975         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 976         // Don&#39;t return true; keep looking for another change.
 977     }
 978 
 979 #if ENABLE(FILTERS_LEVEL_2)
 980     if (first.backdropFilter != second.backdropFilter) {
 981         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 982         // Don&#39;t return true; keep looking for another change.
 983     }
 984 #endif
 985 
 986     if (first.mask != second.mask || first.maskBoxImage != second.maskBoxImage)
 987         return true;
 988 
 989     return false;
 990 }
 991 
 992 bool RenderStyle::changeRequiresLayerRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 993 {
 994     // StyleResolver has ensured that zIndex is non-auto only if it&#39;s applicable.
 995     if (m_boxData-&gt;zIndex() != other.m_boxData-&gt;zIndex() || m_boxData-&gt;hasAutoZIndex() != other.m_boxData-&gt;hasAutoZIndex())
 996         return true;
 997 
 998     if (position() != PositionType::Static) {
 999         if (m_visualData-&gt;clip != other.m_visualData-&gt;clip || m_visualData-&gt;hasClip != other.m_visualData-&gt;hasClip) {
1000             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipRect);
1001             return true;
1002         }
1003     }
1004 
1005     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1006         &amp;&amp; rareNonInheritedDataChangeRequiresLayerRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1007         return true;
1008 
1009     return false;
1010 }
1011 
1012 static bool requiresPainting(const RenderStyle&amp; style)
1013 {
1014     if (style.visibility() == Visibility::Hidden)
1015         return false;
1016     if (!style.opacity())
1017         return false;
1018     return true;
1019 }
1020 
1021 static bool rareNonInheritedDataChangeRequiresRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
1022 {
1023     if (first.userDrag != second.userDrag
1024         || first.borderFit != second.borderFit
1025         || first.objectFit != second.objectFit
1026         || first.objectPosition != second.objectPosition)
1027         return true;
1028 
1029     if (first.isNotFinal != second.isNotFinal)
1030         return true;
1031 
1032     if (first.shapeOutside != second.shapeOutside)
1033         return true;
1034 
1035     // FIXME: this should probably be moved to changeRequiresLayerRepaint().
1036     if (first.clipPath != second.clipPath) {
1037         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipPath);
1038         // Don&#39;t return true; keep looking for another change.
1039     }
1040 
1041     return false;
1042 }
1043 
1044 static bool rareInheritedDataChangeRequiresRepaint(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
1045 {
1046     return first.userModify != second.userModify
1047         || first.userSelect != second.userSelect
1048         || first.appleColorFilter != second.appleColorFilter
1049         || first.imageRendering != second.imageRendering
1050 #if ENABLE(DARK_MODE_CSS)
1051         || first.colorScheme != second.colorScheme
1052 #endif
1053     ;
1054 }
1055 
1056 #if ENABLE(CSS_PAINTING_API)
1057 void RenderStyle::addCustomPaintWatchProperty(const String&amp; name)
1058 {
1059     auto&amp; data = m_rareNonInheritedData.access();
1060     if (!data.customPaintWatchedProperties)
1061         data.customPaintWatchedProperties = makeUnique&lt;HashSet&lt;String&gt;&gt;();
1062     data.customPaintWatchedProperties-&gt;add(name);
1063 }
1064 
1065 inline static bool changedCustomPaintWatchedProperty(const RenderStyle&amp; a, const StyleRareNonInheritedData&amp; aData, const RenderStyle&amp; b, const StyleRareNonInheritedData&amp; bData)
1066 {
1067     auto* propertiesA = aData.customPaintWatchedProperties.get();
1068     auto* propertiesB = bData.customPaintWatchedProperties.get();
1069 
1070     if (UNLIKELY(propertiesA || propertiesB)) {
1071         // FIXME: We should not need to use ComputedStyleExtractor here.
1072         ComputedStyleExtractor extractor((Element*) nullptr);
1073 
1074         for (auto* watchPropertiesMap : { propertiesA, propertiesB }) {
1075             if (!watchPropertiesMap)
1076                 continue;
1077 
1078             for (auto&amp; name : *watchPropertiesMap) {
1079                 RefPtr&lt;CSSValue&gt; valueA;
1080                 RefPtr&lt;CSSValue&gt; valueB;
1081                 if (isCustomPropertyName(name)) {
1082                     if (a.getCustomProperty(name))
1083                         valueA = CSSCustomPropertyValue::create(*a.getCustomProperty(name));
1084                     if (b.getCustomProperty(name))
1085                         valueB = CSSCustomPropertyValue::create(*b.getCustomProperty(name));
1086                 } else {
1087                     CSSPropertyID propertyID = cssPropertyID(name);
1088                     if (!propertyID)
1089                         continue;
1090                     valueA = extractor.valueForPropertyInStyle(a, propertyID);
1091                     valueB = extractor.valueForPropertyInStyle(b, propertyID);
1092                 }
1093 
1094                 if ((valueA &amp;&amp; !valueB) || (!valueA &amp;&amp; valueB))
1095                     return true;
1096 
1097                 if (!valueA)
1098                     continue;
1099 
1100                 if (!(*valueA == *valueB))
1101                     return true;
1102             }
1103         }
1104     }
1105 
1106     return false;
1107 }
1108 #endif
1109 
1110 bool RenderStyle::changeRequiresRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1111 {
1112     if (!requiresPainting(*this) &amp;&amp; !requiresPainting(other))
1113         return false;
1114 
1115     if (m_inheritedFlags.visibility != other.m_inheritedFlags.visibility
1116         || m_inheritedFlags.printColorAdjust != other.m_inheritedFlags.printColorAdjust
1117         || m_inheritedFlags.insideLink != other.m_inheritedFlags.insideLink
1118         || m_inheritedFlags.insideDefaultButton != other.m_inheritedFlags.insideDefaultButton
1119         || m_surroundData-&gt;border != other.m_surroundData-&gt;border
1120         || !m_backgroundData-&gt;isEquivalentForPainting(*other.m_backgroundData))
1121         return true;
1122 
1123     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1124         &amp;&amp; rareNonInheritedDataChangeRequiresRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1125         return true;
1126 
1127     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
1128         &amp;&amp; rareInheritedDataChangeRequiresRepaint(*m_rareInheritedData, *other.m_rareInheritedData))
1129         return true;
1130 
1131 #if ENABLE(CSS_PAINTING_API)
1132     if (changedCustomPaintWatchedProperty(*this, *m_rareNonInheritedData, other, *other.m_rareNonInheritedData))
1133         return true;
1134 #endif
1135 
1136     return false;
1137 }
1138 
1139 bool RenderStyle::changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1140 {
1141     if (m_inheritedData-&gt;color != other.m_inheritedData-&gt;color
1142         || m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
1143         || m_visualData-&gt;textDecoration != other.m_visualData-&gt;textDecoration
1144         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
1145         || m_rareNonInheritedData-&gt;textDecorationColor != other.m_rareNonInheritedData-&gt;textDecorationColor
1146         || m_rareInheritedData-&gt;textDecorationSkip != other.m_rareInheritedData-&gt;textDecorationSkip
1147         || m_rareInheritedData-&gt;textFillColor != other.m_rareInheritedData-&gt;textFillColor
1148         || m_rareInheritedData-&gt;textStrokeColor != other.m_rareInheritedData-&gt;textStrokeColor
1149         || m_rareInheritedData-&gt;textEmphasisColor != other.m_rareInheritedData-&gt;textEmphasisColor
1150         || m_rareInheritedData-&gt;textEmphasisFill != other.m_rareInheritedData-&gt;textEmphasisFill
1151         || m_rareInheritedData-&gt;strokeColor != other.m_rareInheritedData-&gt;strokeColor
1152         || m_rareInheritedData-&gt;caretColor != other.m_rareInheritedData-&gt;caretColor)
1153         return true;
1154 
1155     return false;
1156 }
1157 
1158 bool RenderStyle::changeRequiresRecompositeLayer(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1159 {
1160     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()) {
1161         if (m_rareNonInheritedData-&gt;transformStyle3D != other.m_rareNonInheritedData-&gt;transformStyle3D
1162             || m_rareNonInheritedData-&gt;backfaceVisibility != other.m_rareNonInheritedData-&gt;backfaceVisibility
1163             || m_rareNonInheritedData-&gt;perspective != other.m_rareNonInheritedData-&gt;perspective
1164             || m_rareNonInheritedData-&gt;perspectiveOriginX != other.m_rareNonInheritedData-&gt;perspectiveOriginX
1165             || m_rareNonInheritedData-&gt;perspectiveOriginY != other.m_rareNonInheritedData-&gt;perspectiveOriginY)
1166             return true;
1167     }
1168 
1169     return false;
1170 }
1171 
1172 StyleDifference RenderStyle::diff(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1173 {
1174     changedContextSensitiveProperties = OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;();
1175 
1176     StyleDifference svgChange = StyleDifference::Equal;
1177     if (m_svgStyle != other.m_svgStyle) {
1178         svgChange = m_svgStyle-&gt;diff(other.m_svgStyle.get());
1179         if (svgChange == StyleDifference::Layout)
1180             return svgChange;
1181     }
1182 
1183     if (changeRequiresLayout(other, changedContextSensitiveProperties))
1184         return StyleDifference::Layout;
1185 
1186     // SVGRenderStyle::diff() might have returned StyleDifference::Repaint, eg. if fill changes.
1187     // If eg. the font-size changed at the same time, we&#39;re not allowed to return StyleDifference::Repaint,
1188     // but have to return StyleDifference::Layout, that&#39;s why  this if branch comes after all branches
1189     // that are relevant for SVG and might return StyleDifference::Layout.
1190     if (svgChange != StyleDifference::Equal)
1191         return svgChange;
1192 
1193     if (changeRequiresPositionedLayoutOnly(other, changedContextSensitiveProperties))
1194         return StyleDifference::LayoutPositionedMovementOnly;
1195 
1196     if (changeRequiresLayerRepaint(other, changedContextSensitiveProperties))
1197         return StyleDifference::RepaintLayer;
1198 
1199     if (changeRequiresRepaint(other, changedContextSensitiveProperties))
1200         return StyleDifference::Repaint;
1201 
1202     if (changeRequiresRecompositeLayer(other, changedContextSensitiveProperties))
1203         return StyleDifference::RecompositeLayer;
1204 
1205     if (changeRequiresRepaintIfTextOrBorderOrOutline(other, changedContextSensitiveProperties))
1206         return StyleDifference::RepaintIfTextOrBorderOrOutline;
1207 
1208     // Cursors are not checked, since they will be set appropriately in response to mouse events,
1209     // so they don&#39;t need to cause any repaint or layout.
1210 
1211     // Animations don&#39;t need to be checked either.  We always set the new style on the RenderObject, so we will get a chance to fire off
1212     // the resulting transition properly.
1213     return StyleDifference::Equal;
1214 }
1215 
1216 bool RenderStyle::diffRequiresLayerRepaint(const RenderStyle&amp; style, bool isComposited) const
1217 {
1218     OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; changedContextSensitiveProperties;
1219 
1220     if (changeRequiresRepaint(style, changedContextSensitiveProperties))
1221         return true;
1222 
1223     if (isComposited &amp;&amp; changeRequiresLayerRepaint(style, changedContextSensitiveProperties))
1224         return changedContextSensitiveProperties.contains(StyleDifferenceContextSensitiveProperty::ClipRect);
1225 
1226     return false;
1227 }
1228 
1229 void RenderStyle::setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left)
1230 {
1231     auto&amp; data = m_visualData.access();
1232     data.clip.top() = WTFMove(top);
1233     data.clip.right() = WTFMove(right);
1234     data.clip.bottom() = WTFMove(bottom);
1235     data.clip.left() = WTFMove(left);
1236 }
1237 
1238 void RenderStyle::addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp; image, const IntPoint&amp; hotSpot)
1239 {
1240     auto&amp; cursorData = m_rareInheritedData.access().cursorData;
1241     if (!cursorData)
1242         cursorData = CursorList::create();
1243     cursorData-&gt;append(CursorData(WTFMove(image), hotSpot));
1244 }
1245 
1246 void RenderStyle::setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp; list)
1247 {
1248     m_rareInheritedData.access().cursorData = WTFMove(list);
1249 }
1250 
1251 void RenderStyle::setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp; q)
1252 {
1253     if (m_rareInheritedData-&gt;quotes == q || (m_rareInheritedData-&gt;quotes &amp;&amp; q &amp;&amp; *m_rareInheritedData-&gt;quotes == *q))
1254         return;
1255 
1256     m_rareInheritedData.access().quotes = WTFMove(q);
1257 }
1258 
1259 void RenderStyle::setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp; willChangeData)
1260 {
1261     if (arePointingToEqualData(m_rareNonInheritedData-&gt;willChange.get(), willChangeData.get()))
1262         return;
1263 
1264     m_rareNonInheritedData.access().willChange = WTFMove(willChangeData);
1265 }
1266 
1267 void RenderStyle::clearCursorList()
1268 {
1269     if (m_rareInheritedData-&gt;cursorData)
1270         m_rareInheritedData.access().cursorData = nullptr;
1271 }
1272 
1273 void RenderStyle::clearContent()
1274 {
1275     if (m_rareNonInheritedData-&gt;content)
1276         m_rareNonInheritedData.access().content = nullptr;
1277 }
1278 
1279 static inline ContentData&amp; lastContent(ContentData&amp; firstContent)
1280 {
1281     auto* lastContent = &amp;firstContent;
1282     for (auto* content = &amp;firstContent; content; content = content-&gt;next())
1283         lastContent = content;
1284     return *lastContent;
1285 }
1286 
1287 void RenderStyle::setContent(std::unique_ptr&lt;ContentData&gt; contentData, bool add)
1288 {
1289     auto&amp; data = m_rareNonInheritedData.access();
1290     if (add &amp;&amp; data.content)
1291         lastContent(*data.content).setNext(WTFMove(contentData));
1292     else {
1293         data.content = WTFMove(contentData);
1294         auto&amp; altText = data.altText;
1295         if (!altText.isNull())
1296             data.content-&gt;setAltText(altText);
1297     }
1298 }
1299 
1300 void RenderStyle::setContent(RefPtr&lt;StyleImage&gt;&amp;&amp; image, bool add)
1301 {
1302     if (!image)
1303         return;
1304     setContent(makeUnique&lt;ImageContentData&gt;(image.releaseNonNull()), add);
1305 }
1306 
1307 void RenderStyle::setContent(const String&amp; string, bool add)
1308 {
1309     auto&amp; data = m_rareNonInheritedData.access();
1310     if (add &amp;&amp; data.content) {
1311         auto&amp; last = lastContent(*data.content);
1312         if (!is&lt;TextContentData&gt;(last))
1313             last.setNext(makeUnique&lt;TextContentData&gt;(string));
1314         else {
1315             auto&amp; textContent = downcast&lt;TextContentData&gt;(last);
1316             textContent.setText(textContent.text() + string);
1317         }
1318     } else {
1319         data.content = makeUnique&lt;TextContentData&gt;(string);
1320         auto&amp; altText = data.altText;
1321         if (!altText.isNull())
1322             data.content-&gt;setAltText(altText);
1323     }
1324 }
1325 
1326 void RenderStyle::setContent(std::unique_ptr&lt;CounterContent&gt; counter, bool add)
1327 {
1328     if (!counter)
1329         return;
1330     setContent(makeUnique&lt;CounterContentData&gt;(WTFMove(counter)), add);
1331 }
1332 
1333 void RenderStyle::setContent(QuoteType quote, bool add)
1334 {
1335     setContent(makeUnique&lt;QuoteContentData&gt;(quote), add);
1336 }
1337 
1338 void RenderStyle::setContentAltText(const String&amp; string)
1339 {
1340     auto&amp; data = m_rareNonInheritedData.access();
1341     data.altText = string;
1342     if (data.content)
1343         data.content-&gt;setAltText(string);
1344 }
1345 
1346 const String&amp; RenderStyle::contentAltText() const
1347 {
1348     return m_rareNonInheritedData-&gt;altText;
1349 }
1350 
1351 void RenderStyle::setHasAttrContent()
1352 {
1353     setUnique();
1354     SET_VAR(m_rareNonInheritedData, hasAttrContent, true);
1355 }
1356 
1357 static inline bool requireTransformOrigin(const Vector&lt;RefPtr&lt;TransformOperation&gt;&gt;&amp; transformOperations, RenderStyle::ApplyTransformOrigin applyOrigin)
1358 {
1359     // The transform-origin property brackets the transform with translate operations.
1360     // When the only transform is a translation, the transform-origin is irrelevant.
1361 
1362     if (applyOrigin != RenderStyle::IncludeTransformOrigin)
1363         return false;
1364 
1365     for (auto&amp; operation : transformOperations) {
1366         // FIXME: Use affectedByTransformOrigin().
1367         auto type = operation-&gt;type();
1368         if (type != TransformOperation::TRANSLATE
1369             &amp;&amp; type != TransformOperation::TRANSLATE_3D
1370             &amp;&amp; type != TransformOperation::TRANSLATE_X
1371             &amp;&amp; type != TransformOperation::TRANSLATE_Y
1372             &amp;&amp; type != TransformOperation::TRANSLATE_Z)
1373             return true;
1374     }
1375 
1376     return false;
1377 }
1378 
1379 void RenderStyle::applyTransform(TransformationMatrix&amp; transform, const FloatRect&amp; boundingBox, ApplyTransformOrigin applyOrigin) const
1380 {
1381     auto&amp; operations = m_rareNonInheritedData-&gt;transform-&gt;operations.operations();
1382     bool applyTransformOrigin = requireTransformOrigin(operations, applyOrigin);
1383 
1384     FloatPoint3D originTranslate;
1385     if (applyTransformOrigin) {
1386         originTranslate.setX(boundingBox.x() + floatValueForLength(transformOriginX(), boundingBox.width()));
1387         originTranslate.setY(boundingBox.y() + floatValueForLength(transformOriginY(), boundingBox.height()));
1388         originTranslate.setZ(transformOriginZ());
1389         transform.translate3d(originTranslate.x(), originTranslate.y(), originTranslate.z());
1390     }
1391 
1392     for (auto&amp; operation : operations)
1393         operation-&gt;apply(transform, boundingBox.size());
1394 
1395     if (applyTransformOrigin)
1396         transform.translate3d(-originTranslate.x(), -originTranslate.y(), -originTranslate.z());
1397 }
1398 
1399 void RenderStyle::setPageScaleTransform(float scale)
1400 {
1401     if (scale == 1)
1402         return;
1403     TransformOperations transform;
1404     transform.operations().append(ScaleTransformOperation::create(scale, scale, ScaleTransformOperation::SCALE));
1405     setTransform(transform);
1406     setTransformOriginX(Length(0, Fixed));
1407     setTransformOriginY(Length(0, Fixed));
1408 }
1409 
1410 void RenderStyle::setTextShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1411 {
1412     ASSERT(!shadowData || (!shadowData-&gt;spread() &amp;&amp; shadowData-&gt;style() == Normal));
1413 
1414     auto&amp; rareData = m_rareInheritedData.access();
1415     if (!add) {
1416         rareData.textShadow = WTFMove(shadowData);
1417         return;
1418     }
1419 
1420     shadowData-&gt;setNext(WTFMove(rareData.textShadow));
1421     rareData.textShadow = WTFMove(shadowData);
1422 }
1423 
1424 void RenderStyle::setBoxShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1425 {
1426     auto&amp; rareData = m_rareNonInheritedData.access();
1427     if (!add) {
1428         rareData.boxShadow = WTFMove(shadowData);
1429         return;
1430     }
1431 
1432     shadowData-&gt;setNext(WTFMove(rareData.boxShadow));
1433     rareData.boxShadow = WTFMove(shadowData);
1434 }
1435 
1436 static RoundedRect::Radii calcRadiiFor(const BorderData&amp; border, const LayoutSize&amp; size)
1437 {
1438     return {
1439         sizeForLengthSize(border.topLeft(), size),
1440         sizeForLengthSize(border.topRight(), size),
1441         sizeForLengthSize(border.bottomLeft(), size),
1442         sizeForLengthSize(border.bottomRight(), size)
1443     };
1444 }
1445 
1446 StyleImage* RenderStyle::listStyleImage() const
1447 {
1448     return m_rareInheritedData-&gt;listStyleImage.get();
1449 }
1450 
1451 void RenderStyle::setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v)
1452 {
1453     if (m_rareInheritedData-&gt;listStyleImage != v)
1454         m_rareInheritedData.access().listStyleImage = WTFMove(v);
1455 }
1456 
1457 const Color&amp; RenderStyle::color() const
1458 {
1459     return m_inheritedData-&gt;color;
1460 }
1461 
1462 const Color&amp; RenderStyle::visitedLinkColor() const
1463 {
1464     return m_inheritedData-&gt;visitedLinkColor;
1465 }
1466 
1467 void RenderStyle::setColor(const Color&amp; v)
1468 {
1469     SET_VAR(m_inheritedData, color, v);
1470 }
1471 
1472 void RenderStyle::setVisitedLinkColor(const Color&amp; v)
1473 {
1474     SET_VAR(m_inheritedData, visitedLinkColor, v);
1475 }
1476 
1477 float RenderStyle::horizontalBorderSpacing() const
1478 {
1479     return m_inheritedData-&gt;horizontalBorderSpacing;
1480 }
1481 
1482 float RenderStyle::verticalBorderSpacing() const
1483 {
1484     return m_inheritedData-&gt;verticalBorderSpacing;
1485 }
1486 
1487 void RenderStyle::setHorizontalBorderSpacing(float v)
1488 {
1489     SET_VAR(m_inheritedData, horizontalBorderSpacing, v);
1490 }
1491 
1492 void RenderStyle::setVerticalBorderSpacing(float v)
1493 {
1494     SET_VAR(m_inheritedData, verticalBorderSpacing, v);
1495 }
1496 
1497 RoundedRect RenderStyle::getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1498 {
1499     RoundedRect roundedRect(borderRect);
1500     if (hasBorderRadius()) {
1501         RoundedRect::Radii radii = calcRadiiFor(m_surroundData-&gt;border, borderRect.size());
1502         radii.scale(calcBorderRadiiConstraintScaleFor(borderRect, radii));
1503         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1504     }
1505     return roundedRect;
1506 }
1507 
1508 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1509 {
1510     bool horizontal = isHorizontalWritingMode();
1511     LayoutUnit leftWidth { (!horizontal || includeLogicalLeftEdge) ? borderLeftWidth() : 0 };
1512     LayoutUnit rightWidth { (!horizontal || includeLogicalRightEdge) ? borderRightWidth() : 0 };
1513     LayoutUnit topWidth { (horizontal || includeLogicalLeftEdge) ? borderTopWidth() : 0 };
1514     LayoutUnit bottomWidth { (horizontal || includeLogicalRightEdge) ? borderBottomWidth() : 0 };
1515     return getRoundedInnerBorderFor(borderRect, topWidth, bottomWidth, leftWidth, rightWidth, includeLogicalLeftEdge, includeLogicalRightEdge);
1516 }
1517 
1518 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
1519     LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1520 {
1521     RoundedRect roundedRect { { borderRect.x() + leftWidth, borderRect.y() + topWidth,
1522         borderRect.width() - leftWidth - rightWidth, borderRect.height() - topWidth - bottomWidth } };
1523     if (hasBorderRadius()) {
1524         auto radii = getRoundedBorderFor(borderRect).radii();
1525         radii.shrink(topWidth, bottomWidth, leftWidth, rightWidth);
1526         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1527     }
1528     return roundedRect;
1529 }
1530 
1531 static bool allLayersAreFixed(const FillLayer&amp; layers)
1532 {
1533     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1534         if (!(layer-&gt;image() &amp;&amp; layer-&gt;attachment() == FillAttachment::FixedBackground))
1535             return false;
1536     }
1537     return true;
1538 }
1539 
1540 bool RenderStyle::hasEntirelyFixedBackground() const
1541 {
1542     return allLayersAreFixed(backgroundLayers());
1543 }
1544 
1545 const CounterDirectiveMap* RenderStyle::counterDirectives() const
1546 {
1547     return m_rareNonInheritedData-&gt;counterDirectives.get();
1548 }
1549 
1550 CounterDirectiveMap&amp; RenderStyle::accessCounterDirectives()
1551 {
1552     auto&amp; map = m_rareNonInheritedData.access().counterDirectives;
1553     if (!map)
1554         map = makeUnique&lt;CounterDirectiveMap&gt;();
1555     return *map;
1556 }
1557 
1558 const AtomString&amp; RenderStyle::hyphenString() const
1559 {
1560     ASSERT(hyphens() != Hyphens::None);
1561 
1562     auto&amp; hyphenationString = m_rareInheritedData-&gt;hyphenationString;
1563     if (!hyphenationString.isNull())
1564         return hyphenationString;
1565 
1566     // FIXME: This should depend on locale.
1567     static NeverDestroyed&lt;AtomString&gt; hyphenMinusString(&amp;hyphenMinus, 1);
1568     static NeverDestroyed&lt;AtomString&gt; hyphenString(&amp;hyphen, 1);
1569     return fontCascade().primaryFont().glyphForCharacter(hyphen) ? hyphenString : hyphenMinusString;
1570 }
1571 
1572 const AtomString&amp; RenderStyle::textEmphasisMarkString() const
1573 {
1574     switch (textEmphasisMark()) {
1575     case TextEmphasisMark::None:
1576         return nullAtom();
1577     case TextEmphasisMark::Custom:
1578         return textEmphasisCustomMark();
1579     case TextEmphasisMark::Dot: {
1580         static NeverDestroyed&lt;AtomString&gt; filledDotString(&amp;bullet, 1);
1581         static NeverDestroyed&lt;AtomString&gt; openDotString(&amp;whiteBullet, 1);
1582         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDotString : openDotString;
1583     }
1584     case TextEmphasisMark::Circle: {
1585         static NeverDestroyed&lt;AtomString&gt; filledCircleString(&amp;blackCircle, 1);
1586         static NeverDestroyed&lt;AtomString&gt; openCircleString(&amp;whiteCircle, 1);
1587         return textEmphasisFill() == TextEmphasisFill::Filled ? filledCircleString : openCircleString;
1588     }
1589     case TextEmphasisMark::DoubleCircle: {
1590         static NeverDestroyed&lt;AtomString&gt; filledDoubleCircleString(&amp;fisheye, 1);
1591         static NeverDestroyed&lt;AtomString&gt; openDoubleCircleString(&amp;bullseye, 1);
1592         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDoubleCircleString : openDoubleCircleString;
1593     }
1594     case TextEmphasisMark::Triangle: {
1595         static NeverDestroyed&lt;AtomString&gt; filledTriangleString(&amp;blackUpPointingTriangle, 1);
1596         static NeverDestroyed&lt;AtomString&gt; openTriangleString(&amp;whiteUpPointingTriangle, 1);
1597         return textEmphasisFill() == TextEmphasisFill::Filled ? filledTriangleString : openTriangleString;
1598     }
1599     case TextEmphasisMark::Sesame: {
1600         static NeverDestroyed&lt;AtomString&gt; filledSesameString(&amp;sesameDot, 1);
1601         static NeverDestroyed&lt;AtomString&gt; openSesameString(&amp;whiteSesameDot, 1);
1602         return textEmphasisFill() == TextEmphasisFill::Filled ? filledSesameString : openSesameString;
1603     }
1604     case TextEmphasisMark::Auto:
1605         ASSERT_NOT_REACHED();
1606         return nullAtom();
1607     }
1608 
1609     ASSERT_NOT_REACHED();
1610     return nullAtom();
1611 }
1612 
1613 void RenderStyle::adjustAnimations()
1614 {
1615     auto* animationList = m_rareNonInheritedData-&gt;animations.get();
1616     if (!animationList)
1617         return;
1618 
1619     // Get rid of empty animations and anything beyond them
1620     for (size_t i = 0, size = animationList-&gt;size(); i &lt; size; ++i) {
1621         if (animationList-&gt;animation(i).isEmpty()) {
1622             animationList-&gt;resize(i);
1623             break;
1624         }
1625     }
1626 
1627     if (animationList-&gt;isEmpty()) {
1628         clearAnimations();
1629         return;
1630     }
1631 
1632     // Repeat patterns into layers that don&#39;t have some properties set.
1633     animationList-&gt;fillUnsetProperties();
1634 }
1635 
1636 void RenderStyle::adjustTransitions()
1637 {
1638     auto* transitionList = m_rareNonInheritedData-&gt;transitions.get();
1639     if (!transitionList)
1640         return;
1641 
1642     // Get rid of empty transitions and anything beyond them
1643     for (size_t i = 0, size = transitionList-&gt;size(); i &lt; size; ++i) {
1644         if (transitionList-&gt;animation(i).isEmpty()) {
1645             transitionList-&gt;resize(i);
1646             break;
1647         }
1648     }
1649 
1650     if (transitionList-&gt;isEmpty()) {
1651         clearTransitions();
1652         return;
1653     }
1654 
1655     // Repeat patterns into layers that don&#39;t have some properties set.
1656     transitionList-&gt;fillUnsetProperties();
1657 
1658     // Make sure there are no duplicate properties.
1659     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1660     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1661         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1662             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1663                 // toss i
1664                 transitionList-&gt;remove(i);
1665                 j = i;
1666             }
1667         }
1668     }
1669 }
1670 
1671 AnimationList&amp; RenderStyle::ensureAnimations()
1672 {
1673     if (!m_rareNonInheritedData.access().animations)
1674         m_rareNonInheritedData.access().animations = makeUnique&lt;AnimationList&gt;();
1675     return *m_rareNonInheritedData-&gt;animations;
1676 }
1677 
1678 AnimationList&amp; RenderStyle::ensureTransitions()
1679 {
1680     if (!m_rareNonInheritedData.access().transitions)
1681         m_rareNonInheritedData.access().transitions = makeUnique&lt;AnimationList&gt;();
1682     return *m_rareNonInheritedData-&gt;transitions;
1683 }
1684 
1685 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1686 {
1687     auto* transitions = this-&gt;transitions();
1688     if (!transitions)
1689         return nullptr;
1690     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1691         auto&amp; animation = transitions-&gt;animation(i);
1692         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1693             return &amp;animation;
1694     }
1695     return nullptr;
1696 }
1697 
1698 const FontCascade&amp; RenderStyle::fontCascade() const
1699 {
1700     return m_inheritedData-&gt;fontCascade;
1701 }
1702 
1703 const FontMetrics&amp; RenderStyle::fontMetrics() const
1704 {
1705     return m_inheritedData-&gt;fontCascade.fontMetrics();
1706 }
1707 
1708 const FontCascadeDescription&amp; RenderStyle::fontDescription() const
1709 {
1710     return m_inheritedData-&gt;fontCascade.fontDescription();
1711 }
1712 
1713 float RenderStyle::specifiedFontSize() const
1714 {
1715     return fontDescription().specifiedSize();
1716 }
1717 
1718 float RenderStyle::computedFontSize() const
1719 {
1720     return fontDescription().computedSize();
1721 }
1722 
1723 unsigned RenderStyle::computedFontPixelSize() const
1724 {
1725     return fontDescription().computedPixelSize();
1726 }
1727 
1728 const Length&amp; RenderStyle::wordSpacing() const
1729 {
1730     return m_rareInheritedData-&gt;wordSpacing;
1731 }
1732 
1733 float RenderStyle::letterSpacing() const
1734 {
1735     return m_inheritedData-&gt;fontCascade.letterSpacing();
1736 }
1737 
1738 bool RenderStyle::setFontDescription(FontCascadeDescription&amp;&amp; description)
1739 {
1740     if (m_inheritedData-&gt;fontCascade.fontDescription() == description)
1741         return false;
1742     auto&amp; cascade = m_inheritedData.access().fontCascade;
1743     cascade = { WTFMove(description), cascade.letterSpacing(), cascade.wordSpacing() };
1744     return true;
1745 }
1746 
1747 const Length&amp; RenderStyle::specifiedLineHeight() const
1748 {
1749 #if ENABLE(TEXT_AUTOSIZING)
1750     return m_inheritedData-&gt;specifiedLineHeight;
1751 #else
1752     return m_inheritedData-&gt;lineHeight;
1753 #endif
1754 }
1755 
1756 #if ENABLE(TEXT_AUTOSIZING)
1757 
1758 void RenderStyle::setSpecifiedLineHeight(Length&amp;&amp; height)
1759 {
1760     SET_VAR(m_inheritedData, specifiedLineHeight, WTFMove(height));
1761 }
1762 
1763 #endif
1764 
1765 const Length&amp; RenderStyle::lineHeight() const
1766 {
1767     return m_inheritedData-&gt;lineHeight;
1768 }
1769 
1770 void RenderStyle::setLineHeight(Length&amp;&amp; height)
1771 {
1772     SET_VAR(m_inheritedData, lineHeight, WTFMove(height));
1773 }
1774 
1775 int RenderStyle::computedLineHeight() const
1776 {
1777     const Length&amp; lh = lineHeight();
1778 
1779     // Negative value means the line height is not set. Use the font&#39;s built-in spacing.
1780     if (lh.isNegative())
1781         return fontMetrics().lineSpacing();
1782 
1783     if (lh.isPercentOrCalculated())
1784         return minimumValueForLength(lh, computedFontPixelSize());
1785 
1786     return clampTo&lt;int&gt;(lh.value());
1787 }
1788 
1789 void RenderStyle::setWordSpacing(Length&amp;&amp; value)
1790 {
1791     float fontWordSpacing;
1792     switch (value.type()) {
1793     case Auto:
1794         fontWordSpacing = 0;
1795         break;
1796     case Percent:
1797         fontWordSpacing = value.percent() * fontCascade().spaceWidth() / 100;
1798         break;
1799     case Fixed:
1800         fontWordSpacing = value.value();
1801         break;
1802     case Calculated:
1803         fontWordSpacing = value.nonNanCalculatedValue(maxValueForCssLength);
1804         break;
1805     default:
1806         ASSERT_NOT_REACHED();
1807         fontWordSpacing = 0;
1808         break;
1809     }
1810     m_inheritedData.access().fontCascade.setWordSpacing(fontWordSpacing);
1811     m_rareInheritedData.access().wordSpacing = WTFMove(value);
1812 }
1813 
1814 void RenderStyle::setLetterSpacing(float v) { m_inheritedData.access().fontCascade.setLetterSpacing(v); }
1815 
1816 void RenderStyle::setFontSize(float size)
1817 {
1818     // size must be specifiedSize if Text Autosizing is enabled, but computedSize if text
1819     // zoom is enabled (if neither is enabled it&#39;s irrelevant as they&#39;re probably the same).
1820 
1821     ASSERT(std::isfinite(size));
1822     if (!std::isfinite(size) || size &lt; 0)
1823         size = 0;
1824     else
1825         size = std::min(maximumAllowedFontSize, size);
1826 
1827     FontSelector* currentFontSelector = fontCascade().fontSelector();
1828     auto description = fontDescription();
1829     description.setSpecifiedSize(size);
1830     description.setComputedSize(size);
1831 
1832     setFontDescription(WTFMove(description));
1833     fontCascade().update(currentFontSelector);
1834 }
1835 
1836 #if ENABLE(VARIATION_FONTS)
1837 void RenderStyle::setFontVariationSettings(FontVariationSettings settings)
1838 {
1839     FontSelector* currentFontSelector = fontCascade().fontSelector();
1840     auto description = fontDescription();
1841     description.setVariationSettings(WTFMove(settings));
1842 
1843     setFontDescription(WTFMove(description));
1844     fontCascade().update(currentFontSelector);
1845 }
1846 #endif
1847 
1848 void RenderStyle::setFontWeight(FontSelectionValue value)
1849 {
1850     FontSelector* currentFontSelector = fontCascade().fontSelector();
1851     auto description = fontDescription();
1852     description.setWeight(value);
1853 
1854     setFontDescription(WTFMove(description));
1855     fontCascade().update(currentFontSelector);
1856 }
1857 
1858 void RenderStyle::setFontStretch(FontSelectionValue value)
1859 {
1860     FontSelector* currentFontSelector = fontCascade().fontSelector();
1861     auto description = fontDescription();
1862     description.setStretch(value);
1863 
1864     setFontDescription(WTFMove(description));
1865     fontCascade().update(currentFontSelector);
1866 }
1867 
1868 void RenderStyle::setFontItalic(Optional&lt;FontSelectionValue&gt; value)
1869 {
1870     FontSelector* currentFontSelector = fontCascade().fontSelector();
1871     auto description = fontDescription();
1872     description.setItalic(value);
1873 
1874     setFontDescription(WTFMove(description));
1875     fontCascade().update(currentFontSelector);
1876 }
1877 
1878 void RenderStyle::getShadowExtent(const ShadowData* shadow, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const
1879 {
1880     top = 0;
1881     right = 0;
1882     bottom = 0;
1883     left = 0;
1884 
1885     for ( ; shadow; shadow = shadow-&gt;next()) {
1886         if (shadow-&gt;style() == Inset)
1887             continue;
1888 
1889         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1890         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1891         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1892         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1893         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1894     }
1895 }
1896 
1897 LayoutBoxExtent RenderStyle::getShadowInsetExtent(const ShadowData* shadow) const
1898 {
1899     LayoutUnit top;
1900     LayoutUnit right;
1901     LayoutUnit bottom;
1902     LayoutUnit left;
1903 
1904     for ( ; shadow; shadow = shadow-&gt;next()) {
1905         if (shadow-&gt;style() == Normal)
1906             continue;
1907 
1908         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1909         top = std::max&lt;LayoutUnit&gt;(top, shadow-&gt;y() + extentAndSpread);
1910         right = std::min&lt;LayoutUnit&gt;(right, shadow-&gt;x() - extentAndSpread);
1911         bottom = std::min&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() - extentAndSpread);
1912         left = std::max&lt;LayoutUnit&gt;(left, shadow-&gt;x() + extentAndSpread);
1913     }
1914 
1915     return LayoutBoxExtent(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
1916 }
1917 
1918 void RenderStyle::getShadowHorizontalExtent(const ShadowData* shadow, LayoutUnit &amp;left, LayoutUnit &amp;right) const
1919 {
1920     left = 0;
1921     right = 0;
1922 
1923     for ( ; shadow; shadow = shadow-&gt;next()) {
1924         if (shadow-&gt;style() == Inset)
1925             continue;
1926 
1927         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1928         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1929         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1930     }
1931 }
1932 
1933 void RenderStyle::getShadowVerticalExtent(const ShadowData* shadow, LayoutUnit &amp;top, LayoutUnit &amp;bottom) const
1934 {
1935     top = 0;
1936     bottom = 0;
1937 
1938     for ( ; shadow; shadow = shadow-&gt;next()) {
1939         if (shadow-&gt;style() == Inset)
1940             continue;
1941 
1942         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1943         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1944         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1945     }
1946 }
1947 
1948 Color RenderStyle::colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const
1949 {
1950     Color result;
1951     BorderStyle borderStyle = BorderStyle::None;
1952     switch (colorProperty) {
1953     case CSSPropertyBackgroundColor:
1954         return visitedLink ? visitedLinkBackgroundColor() : backgroundColor(); // Background color doesn&#39;t fall back.
1955     case CSSPropertyBorderLeftColor:
1956         result = visitedLink ? visitedLinkBorderLeftColor() : borderLeftColor();
1957         borderStyle = borderLeftStyle();
1958         break;
1959     case CSSPropertyBorderRightColor:
1960         result = visitedLink ? visitedLinkBorderRightColor() : borderRightColor();
1961         borderStyle = borderRightStyle();
1962         break;
1963     case CSSPropertyBorderTopColor:
1964         result = visitedLink ? visitedLinkBorderTopColor() : borderTopColor();
1965         borderStyle = borderTopStyle();
1966         break;
1967     case CSSPropertyBorderBottomColor:
1968         result = visitedLink ? visitedLinkBorderBottomColor() : borderBottomColor();
1969         borderStyle = borderBottomStyle();
1970         break;
1971     case CSSPropertyCaretColor:
1972         result = visitedLink ? visitedLinkCaretColor() : caretColor();
1973         break;
1974     case CSSPropertyColor:
1975         result = visitedLink ? visitedLinkColor() : color();
1976         break;
1977     case CSSPropertyOutlineColor:
1978         result = visitedLink ? visitedLinkOutlineColor() : outlineColor();
1979         break;
1980     case CSSPropertyColumnRuleColor:
1981         result = visitedLink ? visitedLinkColumnRuleColor() : columnRuleColor();
1982         break;
1983     case CSSPropertyTextDecorationColor:
1984         // Text decoration color fallback is handled in RenderObject::decorationColor.
1985         return visitedLink ? visitedLinkTextDecorationColor() : textDecorationColor();
1986     case CSSPropertyWebkitTextEmphasisColor:
1987         result = visitedLink ? visitedLinkTextEmphasisColor() : textEmphasisColor();
1988         break;
1989     case CSSPropertyWebkitTextFillColor:
1990         result = visitedLink ? visitedLinkTextFillColor() : textFillColor();
1991         break;
1992     case CSSPropertyWebkitTextStrokeColor:
1993         result = visitedLink ? visitedLinkTextStrokeColor() : textStrokeColor();
1994         break;
1995     case CSSPropertyStrokeColor:
1996         result = visitedLink ? visitedLinkStrokeColor() : strokeColor();
1997         break;
1998     default:
1999         ASSERT_NOT_REACHED();
2000         break;
2001     }
2002 
2003     if (!result.isValid()) {
2004         if (!visitedLink &amp;&amp; (borderStyle == BorderStyle::Inset || borderStyle == BorderStyle::Outset || borderStyle == BorderStyle::Ridge || borderStyle == BorderStyle::Groove))
2005             result = Color(238, 238, 238);
2006         else
2007             result = visitedLink ? visitedLinkColor() : color();
2008     }
2009     return result;
2010 }
2011 
2012 Color RenderStyle::visitedDependentColor(CSSPropertyID colorProperty) const
2013 {
2014     Color unvisitedColor = colorIncludingFallback(colorProperty, false);
2015     if (insideLink() != InsideLink::InsideVisited)
2016         return unvisitedColor;
2017 
2018     Color visitedColor = colorIncludingFallback(colorProperty, true);
2019 
2020     // Text decoration color validity is preserved (checked in RenderObject::decorationColor).
2021     if (colorProperty == CSSPropertyTextDecorationColor)
2022         return visitedColor;
2023 
2024     // FIXME: Technically someone could explicitly specify the color transparent, but for now we&#39;ll just
2025     // assume that if the background color is transparent that it wasn&#39;t set. Note that it&#39;s weird that
2026     // we&#39;re returning unvisited info for a visited link, but given our restriction that the alpha values
2027     // have to match, it makes more sense to return the unvisited background color if specified than it
2028     // does to return black. This behavior matches what Firefox 4 does as well.
2029     if (colorProperty == CSSPropertyBackgroundColor &amp;&amp; visitedColor == Color::transparent)
2030         return unvisitedColor;
2031 
2032     // Take the alpha from the unvisited color, but get the RGB values from the visited color.
2033     return visitedColor.colorWithAlpha(unvisitedColor.alphaAsFloat());
2034 }
2035 
2036 Color RenderStyle::visitedDependentColorWithColorFilter(CSSPropertyID colorProperty) const
2037 {
2038     if (!hasAppleColorFilter())
2039         return visitedDependentColor(colorProperty);
2040 
2041     return colorByApplyingColorFilter(visitedDependentColor(colorProperty));
2042 }
2043 
2044 Color RenderStyle::colorByApplyingColorFilter(const Color&amp; color) const
2045 {
2046     Color transformedColor = color;
2047     appleColorFilter().transformColor(transformedColor);
2048     return transformedColor;
2049 }
2050 
2051 const BorderValue&amp; RenderStyle::borderBefore() const
2052 {
2053     switch (writingMode()) {
2054     case TopToBottomWritingMode:
2055         return borderTop();
2056     case BottomToTopWritingMode:
2057         return borderBottom();
2058     case LeftToRightWritingMode:
2059         return borderLeft();
2060     case RightToLeftWritingMode:
2061         return borderRight();
2062     }
2063     ASSERT_NOT_REACHED();
2064     return borderTop();
2065 }
2066 
2067 const BorderValue&amp; RenderStyle::borderAfter() const
2068 {
2069     switch (writingMode()) {
2070     case TopToBottomWritingMode:
2071         return borderBottom();
2072     case BottomToTopWritingMode:
2073         return borderTop();
2074     case LeftToRightWritingMode:
2075         return borderRight();
2076     case RightToLeftWritingMode:
2077         return borderLeft();
2078     }
2079     ASSERT_NOT_REACHED();
2080     return borderBottom();
2081 }
2082 
2083 const BorderValue&amp; RenderStyle::borderStart() const
2084 {
2085     if (isHorizontalWritingMode())
2086         return isLeftToRightDirection() ? borderLeft() : borderRight();
2087     return isLeftToRightDirection() ? borderTop() : borderBottom();
2088 }
2089 
2090 const BorderValue&amp; RenderStyle::borderEnd() const
2091 {
2092     if (isHorizontalWritingMode())
2093         return isLeftToRightDirection() ? borderRight() : borderLeft();
2094     return isLeftToRightDirection() ? borderBottom() : borderTop();
2095 }
2096 
2097 float RenderStyle::borderBeforeWidth() const
2098 {
2099     switch (writingMode()) {
2100     case TopToBottomWritingMode:
2101         return borderTopWidth();
2102     case BottomToTopWritingMode:
2103         return borderBottomWidth();
2104     case LeftToRightWritingMode:
2105         return borderLeftWidth();
2106     case RightToLeftWritingMode:
2107         return borderRightWidth();
2108     }
2109     ASSERT_NOT_REACHED();
2110     return borderTopWidth();
2111 }
2112 
2113 float RenderStyle::borderAfterWidth() const
2114 {
2115     switch (writingMode()) {
2116     case TopToBottomWritingMode:
2117         return borderBottomWidth();
2118     case BottomToTopWritingMode:
2119         return borderTopWidth();
2120     case LeftToRightWritingMode:
2121         return borderRightWidth();
2122     case RightToLeftWritingMode:
2123         return borderLeftWidth();
2124     }
2125     ASSERT_NOT_REACHED();
2126     return borderBottomWidth();
2127 }
2128 
2129 float RenderStyle::borderStartWidth() const
2130 {
2131     if (isHorizontalWritingMode())
2132         return isLeftToRightDirection() ? borderLeftWidth() : borderRightWidth();
2133     return isLeftToRightDirection() ? borderTopWidth() : borderBottomWidth();
2134 }
2135 
2136 float RenderStyle::borderEndWidth() const
2137 {
2138     if (isHorizontalWritingMode())
2139         return isLeftToRightDirection() ? borderRightWidth() : borderLeftWidth();
2140     return isLeftToRightDirection() ? borderBottomWidth() : borderTopWidth();
2141 }
2142 
2143 void RenderStyle::setMarginStart(Length&amp;&amp; margin)
2144 {
2145     if (isHorizontalWritingMode()) {
2146         if (isLeftToRightDirection())
2147             setMarginLeft(WTFMove(margin));
2148         else
2149             setMarginRight(WTFMove(margin));
2150     } else {
2151         if (isLeftToRightDirection())
2152             setMarginTop(WTFMove(margin));
2153         else
2154             setMarginBottom(WTFMove(margin));
2155     }
2156 }
2157 
2158 void RenderStyle::setMarginEnd(Length&amp;&amp; margin)
2159 {
2160     if (isHorizontalWritingMode()) {
2161         if (isLeftToRightDirection())
2162             setMarginRight(WTFMove(margin));
2163         else
2164             setMarginLeft(WTFMove(margin));
2165     } else {
2166         if (isLeftToRightDirection())
2167             setMarginBottom(WTFMove(margin));
2168         else
2169             setMarginTop(WTFMove(margin));
2170     }
2171 }
2172 
2173 TextEmphasisMark RenderStyle::textEmphasisMark() const
2174 {
2175     auto mark = static_cast&lt;TextEmphasisMark&gt;(m_rareInheritedData-&gt;textEmphasisMark);
2176     if (mark != TextEmphasisMark::Auto)
2177         return mark;
2178     if (isHorizontalWritingMode())
2179         return TextEmphasisMark::Dot;
2180     return TextEmphasisMark::Sesame;
2181 }
2182 
2183 #if ENABLE(TOUCH_EVENTS)
2184 
2185 Color RenderStyle::initialTapHighlightColor()
2186 {
2187     return RenderTheme::tapHighlightColor();
2188 }
2189 
2190 #endif
2191 
2192 LayoutBoxExtent RenderStyle::imageOutsets(const NinePieceImage&amp; image) const
2193 {
2194     return {
2195         NinePieceImage::computeOutset(image.outset().top(), LayoutUnit(borderTopWidth())),
2196         NinePieceImage::computeOutset(image.outset().right(), LayoutUnit(borderRightWidth())),
2197         NinePieceImage::computeOutset(image.outset().bottom(), LayoutUnit(borderBottomWidth())),
2198         NinePieceImage::computeOutset(image.outset().left(), LayoutUnit(borderLeftWidth()))
2199     };
2200 }
2201 
2202 std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; RenderStyle::fontAndGlyphOrientation()
2203 {
2204     // FIXME: TextOrientationSideways should map to sideways-left in vertical-lr, which is not supported yet.
2205 
2206     if (isHorizontalWritingMode())
2207         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2208 
2209     switch (textOrientation()) {
2210     case TextOrientation::Mixed:
2211         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Mixed };
2212     case TextOrientation::Upright:
2213         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Upright };
2214     case TextOrientation::Sideways:
2215         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2216     default:
2217         ASSERT_NOT_REACHED();
2218         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2219     }
2220 }
2221 
2222 void RenderStyle::setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; image)
2223 {
2224     if (m_surroundData-&gt;border.m_image.image() == image.get())
2225         return;
2226     m_surroundData.access().border.m_image.setImage(WTFMove(image));
2227 }
2228 
2229 void RenderStyle::setBorderImageSlices(LengthBox&amp;&amp; slices)
2230 {
2231     if (m_surroundData-&gt;border.m_image.imageSlices() == slices)
2232         return;
2233     m_surroundData.access().border.m_image.setImageSlices(WTFMove(slices));
2234 }
2235 
2236 void RenderStyle::setBorderImageWidth(LengthBox&amp;&amp; slices)
2237 {
2238     if (m_surroundData-&gt;border.m_image.borderSlices() == slices)
2239         return;
2240     m_surroundData.access().border.m_image.setBorderSlices(WTFMove(slices));
2241 }
2242 
2243 void RenderStyle::setBorderImageOutset(LengthBox&amp;&amp; outset)
2244 {
2245     if (m_surroundData-&gt;border.m_image.outset() == outset)
2246         return;
2247     m_surroundData.access().border.m_image.setOutset(WTFMove(outset));
2248 }
2249 
2250 void RenderStyle::setColumnStylesFromPaginationMode(const Pagination::Mode&amp; paginationMode)
2251 {
2252     if (paginationMode == Pagination::Unpaginated)
2253         return;
2254 
2255     setColumnFill(ColumnFill::Auto);
2256 
2257     switch (paginationMode) {
2258     case Pagination::LeftToRightPaginated:
2259         setColumnAxis(ColumnAxis::Horizontal);
2260         if (isHorizontalWritingMode())
2261             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2262         else
2263             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2264         break;
2265     case Pagination::RightToLeftPaginated:
2266         setColumnAxis(ColumnAxis::Horizontal);
2267         if (isHorizontalWritingMode())
2268             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2269         else
2270             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2271         break;
2272     case Pagination::TopToBottomPaginated:
2273         setColumnAxis(ColumnAxis::Vertical);
2274         if (isHorizontalWritingMode())
2275             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2276         else
2277             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2278         break;
2279     case Pagination::BottomToTopPaginated:
2280         setColumnAxis(ColumnAxis::Vertical);
2281         if (isHorizontalWritingMode())
2282             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2283         else
2284             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2285         break;
2286     case Pagination::Unpaginated:
2287         ASSERT_NOT_REACHED();
2288         break;
2289     }
2290 }
2291 
2292 #if ENABLE(CSS_SCROLL_SNAP)
2293 
2294 ScrollSnapType RenderStyle::initialScrollSnapType()
2295 {
2296     return { };
2297 }
2298 
2299 ScrollSnapAlign RenderStyle::initialScrollSnapAlign()
2300 {
2301     return { };
2302 }
2303 
2304 const StyleScrollSnapArea&amp; RenderStyle::scrollSnapArea() const
2305 {
2306     return *m_rareNonInheritedData-&gt;scrollSnapArea;
2307 }
2308 
2309 const StyleScrollSnapPort&amp; RenderStyle::scrollSnapPort() const
2310 {
2311     return *m_rareNonInheritedData-&gt;scrollSnapPort;
2312 }
2313 
2314 const ScrollSnapType&amp; RenderStyle::scrollSnapType() const
2315 {
2316     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;type;
2317 }
2318 
2319 const LengthBox&amp; RenderStyle::scrollPadding() const
2320 {
2321     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;scrollPadding;
2322 }
2323 
2324 const Length&amp; RenderStyle::scrollPaddingTop() const
2325 {
2326     return scrollPadding().top();
2327 }
2328 
2329 const Length&amp; RenderStyle::scrollPaddingBottom() const
2330 {
2331     return scrollPadding().bottom();
2332 }
2333 
2334 const Length&amp; RenderStyle::scrollPaddingLeft() const
2335 {
2336     return scrollPadding().left();
2337 }
2338 
2339 const Length&amp; RenderStyle::scrollPaddingRight() const
2340 {
2341     return scrollPadding().right();
2342 }
2343 
2344 const ScrollSnapAlign&amp; RenderStyle::scrollSnapAlign() const
2345 {
2346     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;alignment;
2347 }
2348 
2349 const LengthBox&amp; RenderStyle::scrollSnapMargin() const
2350 {
2351     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;scrollSnapMargin;
2352 }
2353 
2354 const Length&amp; RenderStyle::scrollSnapMarginTop() const
2355 {
2356     return scrollSnapMargin().top();
2357 }
2358 
2359 const Length&amp; RenderStyle::scrollSnapMarginBottom() const
2360 {
2361     return scrollSnapMargin().bottom();
2362 }
2363 
2364 const Length&amp; RenderStyle::scrollSnapMarginLeft() const
2365 {
2366     return scrollSnapMargin().left();
2367 }
2368 
2369 const Length&amp; RenderStyle::scrollSnapMarginRight() const
2370 {
2371     return scrollSnapMargin().right();
2372 }
2373 
2374 void RenderStyle::setScrollSnapType(const ScrollSnapType&amp; type)
2375 {
2376     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, type, type);
2377 }
2378 
2379 void RenderStyle::setScrollPaddingTop(Length&amp;&amp; length)
2380 {
2381     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.top(), WTFMove(length));
2382 }
2383 
2384 void RenderStyle::setScrollPaddingBottom(Length&amp;&amp; length)
2385 {
2386     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.bottom(), WTFMove(length));
2387 }
2388 
2389 void RenderStyle::setScrollPaddingLeft(Length&amp;&amp; length)
2390 {
2391     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.left(), WTFMove(length));
2392 }
2393 
2394 void RenderStyle::setScrollPaddingRight(Length&amp;&amp; length)
2395 {
2396     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.right(), WTFMove(length));
2397 }
2398 
2399 void RenderStyle::setScrollSnapAlign(const ScrollSnapAlign&amp; alignment)
2400 {
2401     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, alignment, alignment);
2402 }
2403 
2404 void RenderStyle::setScrollSnapMarginTop(Length&amp;&amp; length)
2405 {
2406     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.top(), WTFMove(length));
2407 }
2408 
2409 void RenderStyle::setScrollSnapMarginBottom(Length&amp;&amp; length)
2410 {
2411     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.bottom(), WTFMove(length));
2412 }
2413 
2414 void RenderStyle::setScrollSnapMarginLeft(Length&amp;&amp; length)
2415 {
2416     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.left(), WTFMove(length));
2417 }
2418 
2419 void RenderStyle::setScrollSnapMarginRight(Length&amp;&amp; length)
2420 {
2421     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.right(), WTFMove(length));
2422 }
2423 
2424 #endif
2425 
2426 bool RenderStyle::hasReferenceFilterOnly() const
2427 {
2428     if (!hasFilter())
2429         return false;
2430     auto&amp; filterOperations = m_rareNonInheritedData-&gt;filter-&gt;operations;
2431     return filterOperations.size() == 1 &amp;&amp; filterOperations.at(0)-&gt;type() == FilterOperation::REFERENCE;
2432 }
2433 
2434 float RenderStyle::outlineWidth() const
2435 {
2436     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2437         return 0;
2438     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2439         return std::max(m_backgroundData-&gt;outline.width(), RenderTheme::platformFocusRingWidth());
2440     return m_backgroundData-&gt;outline.width();
2441 }
2442 
2443 float RenderStyle::outlineOffset() const
2444 {
2445     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2446         return 0;
2447     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2448         return (m_backgroundData-&gt;outline.offset() + RenderTheme::platformFocusRingOffset(outlineWidth()));
2449     return m_backgroundData-&gt;outline.offset();
2450 }
2451 
2452 bool RenderStyle::shouldPlaceBlockDirectionScrollbarOnLeft() const
2453 {
2454     return !isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode();
2455 }
2456 
2457 Vector&lt;PaintType, 3&gt; RenderStyle::paintTypesForPaintOrder(PaintOrder order)
2458 {
2459     Vector&lt;PaintType, 3&gt; paintOrder;
2460     switch (order) {
2461     case PaintOrder::Normal:
2462         FALLTHROUGH;
2463     case PaintOrder::Fill:
2464         paintOrder.append(PaintType::Fill);
2465         paintOrder.append(PaintType::Stroke);
2466         paintOrder.append(PaintType::Markers);
2467         break;
2468     case PaintOrder::FillMarkers:
2469         paintOrder.append(PaintType::Fill);
2470         paintOrder.append(PaintType::Markers);
2471         paintOrder.append(PaintType::Stroke);
2472         break;
2473     case PaintOrder::Stroke:
2474         paintOrder.append(PaintType::Stroke);
2475         paintOrder.append(PaintType::Fill);
2476         paintOrder.append(PaintType::Markers);
2477         break;
2478     case PaintOrder::StrokeMarkers:
2479         paintOrder.append(PaintType::Stroke);
2480         paintOrder.append(PaintType::Markers);
2481         paintOrder.append(PaintType::Fill);
2482         break;
2483     case PaintOrder::Markers:
2484         paintOrder.append(PaintType::Markers);
2485         paintOrder.append(PaintType::Fill);
2486         paintOrder.append(PaintType::Stroke);
2487         break;
2488     case PaintOrder::MarkersStroke:
2489         paintOrder.append(PaintType::Markers);
2490         paintOrder.append(PaintType::Stroke);
2491         paintOrder.append(PaintType::Fill);
2492         break;
2493     };
2494     return paintOrder;
2495 }
2496 
2497 float RenderStyle::computedStrokeWidth(const IntSize&amp; viewportSize) const
2498 {
2499     // Use the stroke-width and stroke-color value combination only if stroke-color has been explicitly specified.
2500     // Since there will be no visible stroke when stroke-color is not specified (transparent by default), we fall
2501     // back to the legacy Webkit text stroke combination in that case.
2502     if (!hasExplicitlySetStrokeColor())
2503         return textStrokeWidth();
2504 
2505     const Length&amp; length = strokeWidth();
2506 
2507     if (length.isPercent()) {
2508         // According to the spec, https://drafts.fxtf.org/paint/#stroke-width, the percentage is relative to the scaled viewport size.
2509         // The scaled viewport size is the geometric mean of the viewport width and height.
2510         ExceptionOr&lt;float&gt; result = length.value() * (viewportSize.width() + viewportSize.height()) / 200.0f;
2511         if (result.hasException())
2512             return 0;
2513         return result.releaseReturnValue();
2514     }
2515 
2516     if (length.isAuto() || !length.isSpecified())
2517         return 0;
2518 
2519     return floatValueForLength(length, viewportSize.width());
2520 }
2521 
2522 bool RenderStyle::hasPositiveStrokeWidth() const
2523 {
2524     if (!hasExplicitlySetStrokeWidth())
2525         return textStrokeWidth() &gt; 0;
2526 
2527     return strokeWidth().isPositive();
2528 }
2529 
2530 Color RenderStyle::computedStrokeColor() const
2531 {
2532     CSSPropertyID propertyID = CSSPropertyStrokeColor;
2533     if (!hasExplicitlySetStrokeColor())
2534         propertyID = CSSPropertyWebkitTextStrokeColor;
2535     return visitedDependentColor(propertyID);
2536 }
2537 
2538 } // namespace WebCore
    </pre>
  </body>
</html>