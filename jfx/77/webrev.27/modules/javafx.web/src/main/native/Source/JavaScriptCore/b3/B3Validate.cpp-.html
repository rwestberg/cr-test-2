<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3Validate.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3Validate.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirCode.h&quot;
 32 #include &quot;B3ArgumentRegValue.h&quot;
 33 #include &quot;B3AtomicValue.h&quot;
 34 #include &quot;B3BasicBlockInlines.h&quot;
 35 #include &quot;B3Dominators.h&quot;
 36 #include &quot;B3MemoryValue.h&quot;
 37 #include &quot;B3Procedure.h&quot;
 38 #include &quot;B3SlotBaseValue.h&quot;
 39 #include &quot;B3StackSlot.h&quot;
 40 #include &quot;B3SwitchValue.h&quot;
 41 #include &quot;B3UpsilonValue.h&quot;
 42 #include &quot;B3ValueInlines.h&quot;
 43 #include &quot;B3Variable.h&quot;
 44 #include &quot;B3VariableValue.h&quot;
 45 #include &quot;B3WasmBoundsCheckValue.h&quot;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/StringPrintStream.h&gt;
 48 #include &lt;wtf/text/CString.h&gt;
 49 
 50 namespace JSC { namespace B3 {
 51 
 52 namespace {
 53 
 54 class Validater {
 55 public:
 56     Validater(Procedure&amp; procedure, const char* dumpBefore)
 57         : m_procedure(procedure)
 58         , m_dumpBefore(dumpBefore)
 59     {
 60     }
 61 
 62 #define VALIDATE(condition, message) do {                               \
 63         if (condition)                                                  \
 64             break;                                                      \
 65         fail(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition, toCString message); \
 66     } while (false)
 67 
 68     void run()
 69     {
 70         HashSet&lt;BasicBlock*&gt; blocks;
 71         HashSet&lt;Value*&gt; valueInProc;
 72         HashMap&lt;Value*, unsigned&gt; valueInBlock;
 73         HashMap&lt;Value*, BasicBlock*&gt; valueOwner;
 74         HashMap&lt;Value*, unsigned&gt; valueIndex;
 75 
 76         for (BasicBlock* block : m_procedure) {
 77             blocks.add(block);
 78             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 79                 Value* value = block-&gt;at(i);
 80                 valueInBlock.add(value, 0).iterator-&gt;value++;
 81                 valueOwner.add(value, block);
 82                 valueIndex.add(value, i);
 83             }
 84         }
 85 
 86         for (Value* value : m_procedure.values())
 87             valueInProc.add(value);
 88 
 89         for (Value* value : valueInProc)
 90             VALIDATE(valueInBlock.contains(value), (&quot;At &quot;, *value));
 91         for (auto&amp; entry : valueInBlock) {
 92             VALIDATE(valueInProc.contains(entry.key), (&quot;At &quot;, *entry.key));
 93             VALIDATE(entry.value == 1, (&quot;At &quot;, *entry.key));
 94         }
 95 
 96         // Compute dominators ourselves to avoid perturbing Procedure.
 97         Dominators dominators(m_procedure);
 98 
 99         for (Value* value : valueInProc) {
100             for (Value* child : value-&gt;children()) {
101                 VALIDATE(child, (&quot;At &quot;, *value));
102                 VALIDATE(valueInProc.contains(child), (&quot;At &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
103                 if (valueOwner.get(child) == valueOwner.get(value))
104                     VALIDATE(valueIndex.get(value) &gt; valueIndex.get(child), (&quot;At &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
105                 else
106                     VALIDATE(dominators.dominates(valueOwner.get(child), valueOwner.get(value)), (&quot;at &quot;, *value, &quot;-&gt;&quot;, pointerDump(child)));
107             }
108         }
109 
110         HashMap&lt;BasicBlock*, HashSet&lt;BasicBlock*&gt;&gt; allPredecessors;
111         for (BasicBlock* block : blocks) {
112             VALIDATE(block-&gt;size() &gt;= 1, (&quot;At &quot;, *block));
113             for (unsigned i = 0; i &lt; block-&gt;size() - 1; ++i)
114                 VALIDATE(!block-&gt;at(i)-&gt;effects().terminal, (&quot;At &quot;, *block-&gt;at(i)));
115             VALIDATE(block-&gt;last()-&gt;effects().terminal, (&quot;At &quot;, *block-&gt;last()));
116 
117             for (BasicBlock* successor : block-&gt;successorBlocks()) {
118                 allPredecessors.add(successor, HashSet&lt;BasicBlock*&gt;()).iterator-&gt;value.add(block);
119                 VALIDATE(
120                     blocks.contains(successor), (&quot;At &quot;, *block, &quot;-&gt;&quot;, pointerDump(successor)));
121             }
122         }
123 
124         // Note that this totally allows dead code.
125         for (auto&amp; entry : allPredecessors) {
126             BasicBlock* successor = entry.key;
127             HashSet&lt;BasicBlock*&gt;&amp; predecessors = entry.value;
128             VALIDATE(predecessors == successor-&gt;predecessors(), (&quot;At &quot;, *successor));
129         }
130 
131         for (Value* value : m_procedure.values()) {
132             for (Value* child : value-&gt;children())
133                 VALIDATE(child-&gt;type() != Void, (&quot;At &quot;, *value, &quot;-&gt;&quot;, *child));
134             switch (value-&gt;opcode()) {
135             case Nop:
136             case Fence:
137                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
138                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
139                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
140                 break;
141             case Identity:
142             case Opaque:
143                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
144                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
145                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
146                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
147                 break;
148             case Const32:
149                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
150                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
151                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
152                 break;
153             case Const64:
154                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
155                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
156                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
157                 break;
158             case ConstDouble:
159                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
160                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
161                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
162                 break;
163             case ConstFloat:
164                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
165                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
166                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
167                 break;
168             case Set:
169                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
170                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
171                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;VariableValue&gt;()-&gt;variable()-&gt;type(), (&quot;At &quot;, *value));
172                 break;
173             case Get:
174                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
175                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
176                 VALIDATE(value-&gt;type() == value-&gt;as&lt;VariableValue&gt;()-&gt;variable()-&gt;type(), (&quot;At &quot;, *value));
177                 break;
178             case SlotBase:
179             case FramePointer:
180                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
181                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
182                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
183                 break;
184             case ArgumentReg:
185                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
186                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
187                 VALIDATE(
188                     (value-&gt;as&lt;ArgumentRegValue&gt;()-&gt;argumentReg().isGPR() ? pointerType() : Double)
189                     == value-&gt;type(), (&quot;At &quot;, *value));
190                 break;
191             case Add:
192             case Sub:
193             case Mul:
194             case Div:
195             case UDiv:
196             case Mod:
197             case UMod:
198             case BitAnd:
199             case BitOr:
200             case BitXor:
201                 VALIDATE(!value-&gt;kind().traps(), (&quot;At &quot;, *value));
202                 switch (value-&gt;opcode()) {
203                 case Div:
204                 case Mod:
205                     if (value-&gt;isChill()) {
206                         VALIDATE(value-&gt;opcode() == Div || value-&gt;opcode() == Mod, (&quot;At &quot;, *value));
207                         VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
208                     }
209                     break;
210                 default:
211                     VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
212                     break;
213                 }
214                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
215                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
216                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
217                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
218                 break;
219             case Neg:
220                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
221                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
222                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
223                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
224                 break;
225             case Shl:
226             case SShr:
227             case ZShr:
228             case RotR:
229                 case RotL:
230                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
231                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
232                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
233                 VALIDATE(value-&gt;child(1)-&gt;type() == Int32, (&quot;At &quot;, *value));
234                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
235                 break;
236             case BitwiseCast:
237                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
238                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
239                 VALIDATE(value-&gt;type() != value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
240                 VALIDATE(
241                     (value-&gt;type() == Int64 &amp;&amp; value-&gt;child(0)-&gt;type() == Double)
242                     || (value-&gt;type() == Double &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
243                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Int32)
244                     || (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Float),
245                     (&quot;At &quot;, *value));
246                 break;
247             case SExt8:
248             case SExt16:
249                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
250                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
251                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
252                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
253                 break;
254             case SExt32:
255             case ZExt32:
256                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
257                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
258                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
259                 VALIDATE(value-&gt;type() == Int64, (&quot;At &quot;, *value));
260                 break;
261             case Clz:
262                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
263                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
264                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
265                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
266                 break;
267             case Trunc:
268                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
269                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
270                 VALIDATE(
271                     (value-&gt;type() == Int32 &amp;&amp; value-&gt;child(0)-&gt;type() == Int64)
272                     || (value-&gt;type() == Float &amp;&amp; value-&gt;child(0)-&gt;type() == Double),
273                     (&quot;At &quot;, *value));
274                 break;
275             case Abs:
276             case Ceil:
277             case Floor:
278             case Sqrt:
279                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
280                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
281                 VALIDATE(isFloat(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
282                 VALIDATE(isFloat(value-&gt;type()), (&quot;At &quot;, *value));
283                 break;
284             case IToD:
285                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
286                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
287                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
288                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
289                 break;
290             case IToF:
291                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
292                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
293                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
294                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
295                 break;
296             case FloatToDouble:
297                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
298                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
299                 VALIDATE(value-&gt;child(0)-&gt;type() == Float, (&quot;At &quot;, *value));
300                 VALIDATE(value-&gt;type() == Double, (&quot;At &quot;, *value));
301                 break;
302             case DoubleToFloat:
303                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
304                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
305                 VALIDATE(value-&gt;child(0)-&gt;type() == Double, (&quot;At &quot;, *value));
306                 VALIDATE(value-&gt;type() == Float, (&quot;At &quot;, *value));
307                 break;
308             case Equal:
309             case NotEqual:
310             case LessThan:
311             case GreaterThan:
312             case LessEqual:
313             case GreaterEqual:
314                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
315                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
316                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
317                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
318                 break;
319             case Above:
320             case Below:
321             case AboveEqual:
322             case BelowEqual:
323                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
324                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
325                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
326                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
327                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
328                 break;
329             case EqualOrUnordered:
330                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
331                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
332                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
333                 VALIDATE(isFloat(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
334                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
335                 break;
336             case Select:
337                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
338                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
339                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
340                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
341                 VALIDATE(value-&gt;type() == value-&gt;child(2)-&gt;type(), (&quot;At &quot;, *value));
342                 break;
343             case Load8Z:
344             case Load8S:
345             case Load16Z:
346             case Load16S:
347                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
348                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
349                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
350                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
351                 validateFence(value);
352                 validateStackAccess(value);
353                 break;
354             case Load:
355                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
356                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
357                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
358                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
359                 validateFence(value);
360                 validateStackAccess(value);
361                 break;
362             case Store8:
363             case Store16:
364                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
365                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
366                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
367                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
368                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
369                 validateFence(value);
370                 validateStackAccess(value);
371                 break;
372             case Store:
373                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
374                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
375                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
376                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
377                 validateFence(value);
378                 validateStackAccess(value);
379                 break;
380             case AtomicWeakCAS:
381                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
382                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
383                 VALIDATE(value-&gt;type() == Int32, (&quot;At &quot;, *value));
384                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
385                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
386                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
387                 validateAtomic(value);
388                 validateStackAccess(value);
389                 break;
390             case AtomicStrongCAS:
391                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
392                 VALIDATE(value-&gt;numChildren() == 3, (&quot;At &quot;, *value));
393                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
394                 VALIDATE(value-&gt;type() == value-&gt;child(1)-&gt;type(), (&quot;At &quot;, *value));
395                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
396                 VALIDATE(value-&gt;child(2)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
397                 validateAtomic(value);
398                 validateStackAccess(value);
399                 break;
400             case AtomicXchgAdd:
401             case AtomicXchgAnd:
402             case AtomicXchgOr:
403             case AtomicXchgSub:
404             case AtomicXchgXor:
405             case AtomicXchg:
406                 VALIDATE(!value-&gt;kind().isChill(), (&quot;At &quot;, *value));
407                 VALIDATE(value-&gt;numChildren() == 2, (&quot;At &quot;, *value));
408                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
409                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
410                 VALIDATE(value-&gt;child(1)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
411                 validateAtomic(value);
412                 validateStackAccess(value);
413                 break;
414             case Depend:
415                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
416                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
417                 VALIDATE(value-&gt;type() == value-&gt;child(0)-&gt;type(), (&quot;At &quot;, *value));
418                 VALIDATE(isInt(value-&gt;type()), (&quot;At &quot;, *value));
419                 break;
420             case WasmAddress:
421                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
422                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
423                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
424                 VALIDATE(value-&gt;type() == pointerType(), (&quot;At &quot;, *value));
425                 break;
426             case CCall:
427                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
428                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
429                 VALIDATE(value-&gt;child(0)-&gt;type() == pointerType(), (&quot;At &quot;, *value));
430                 break;
431             case Patchpoint:
432                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
433                 if (value-&gt;type() == Void)
434                     VALIDATE(value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraint == ValueRep::WarmAny, (&quot;At &quot;, *value));
435                 else
436                     validateStackmapConstraint(value, ConstrainedValue(value, value-&gt;as&lt;PatchpointValue&gt;()-&gt;resultConstraint), ConstraintRole::Def);
437                 validateStackmap(value);
438                 break;
439             case CheckAdd:
440             case CheckSub:
441             case CheckMul:
442                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
443                 VALIDATE(value-&gt;numChildren() &gt;= 2, (&quot;At &quot;, *value));
444                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
445                 VALIDATE(isInt(value-&gt;child(1)-&gt;type()), (&quot;At &quot;, *value));
446                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
447                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(1).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
448                 validateStackmap(value);
449                 break;
450             case Check:
451                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
452                 VALIDATE(value-&gt;numChildren() &gt;= 1, (&quot;At &quot;, *value));
453                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
454                 VALIDATE(value-&gt;as&lt;StackmapValue&gt;()-&gt;constrainedChild(0).rep() == ValueRep::WarmAny, (&quot;At &quot;, *value));
455                 validateStackmap(value);
456                 break;
457             case WasmBoundsCheck:
458                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
459                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
460                 VALIDATE(value-&gt;child(0)-&gt;type() == Int32, (&quot;At &quot;, *value));
461                 switch (value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;boundsType()) {
462                 case WasmBoundsCheckValue::Type::Pinned:
463                     VALIDATE(m_procedure.code().isPinned(value-&gt;as&lt;WasmBoundsCheckValue&gt;()-&gt;bounds().pinnedSize), (&quot;At &quot;, *value));
464                     break;
465                 case WasmBoundsCheckValue::Type::Maximum:
466                     break;
467                 }
468                 VALIDATE(m_procedure.code().wasmBoundsCheckGenerator(), (&quot;At &quot;, *value));
469                 break;
470             case Upsilon:
471                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
472                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
473                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi(), (&quot;At &quot;, *value));
474                 VALIDATE(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;opcode() == Phi, (&quot;At &quot;, *value));
475                 VALIDATE(value-&gt;child(0)-&gt;type() == value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()-&gt;type(), (&quot;At &quot;, *value));
476                 VALIDATE(valueInProc.contains(value-&gt;as&lt;UpsilonValue&gt;()-&gt;phi()), (&quot;At &quot;, *value));
477                 break;
478             case Phi:
479                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
480                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
481                 VALIDATE(value-&gt;type() != Void, (&quot;At &quot;, *value));
482                 break;
483             case Jump:
484                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
485                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
486                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
487                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 1, (&quot;At &quot;, *value));
488                 break;
489             case Oops:
490                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
491                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
492                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
493                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
494                 break;
495             case Return:
496                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
497                 VALIDATE(value-&gt;numChildren() &lt;= 1, (&quot;At &quot;, *value));
498                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
499                 VALIDATE(!valueOwner.get(value)-&gt;numSuccessors(), (&quot;At &quot;, *value));
500                 break;
501             case Branch:
502                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
503                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
504                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
505                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
506                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == 2, (&quot;At &quot;, *value));
507                 break;
508             case Switch: {
509                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
510                 VALIDATE(value-&gt;numChildren() == 1, (&quot;At &quot;, *value));
511                 VALIDATE(isInt(value-&gt;child(0)-&gt;type()), (&quot;At &quot;, *value));
512                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
513                 VALIDATE(value-&gt;as&lt;SwitchValue&gt;()-&gt;hasFallThrough(valueOwner.get(value)), (&quot;At &quot;, *value));
514                 // This validates the same thing as hasFallThrough, but more explicitly. We want to
515                 // make sure that if anyone tries to change the definition of hasFallThrough, they
516                 // will feel some pain here, since this is fundamental.
517                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == value-&gt;as&lt;SwitchValue&gt;()-&gt;numCaseValues() + 1, (&quot;At &quot;, *value));
518 
519                 // Check that there are no duplicate cases.
520                 Vector&lt;int64_t&gt; caseValues = value-&gt;as&lt;SwitchValue&gt;()-&gt;caseValues();
521                 std::sort(caseValues.begin(), caseValues.end());
522                 for (unsigned i = 1; i &lt; caseValues.size(); ++i)
523                     VALIDATE(caseValues[i - 1] != caseValues[i], (&quot;At &quot;, *value, &quot;, caseValue = &quot;, caseValues[i]));
524                 break;
525             }
526             case EntrySwitch:
527                 VALIDATE(!value-&gt;kind().hasExtraBits(), (&quot;At &quot;, *value));
528                 VALIDATE(!value-&gt;numChildren(), (&quot;At &quot;, *value));
529                 VALIDATE(value-&gt;type() == Void, (&quot;At &quot;, *value));
530                 VALIDATE(valueOwner.get(value)-&gt;numSuccessors() == m_procedure.numEntrypoints(), (&quot;At &quot;, *value));
531                 break;
532             }
533 
534             VALIDATE(!(value-&gt;effects().writes &amp;&amp; value-&gt;key()), (&quot;At &quot;, *value));
535         }
536 
537         for (Variable* variable : m_procedure.variables())
538             VALIDATE(variable-&gt;type() != Void, (&quot;At &quot;, *variable));
539 
540         for (BasicBlock* block : m_procedure) {
541             // We expect the predecessor list to be de-duplicated.
542             HashSet&lt;BasicBlock*&gt; predecessors;
543             for (BasicBlock* predecessor : block-&gt;predecessors())
544                 predecessors.add(predecessor);
545             VALIDATE(block-&gt;numPredecessors() == predecessors.size(), (&quot;At &quot;, *block));
546         }
547     }
548 
549 private:
550     void validateStackmap(Value* value)
551     {
552         StackmapValue* stackmap = value-&gt;as&lt;StackmapValue&gt;();
553         VALIDATE(stackmap, (&quot;At &quot;, *value));
554         VALIDATE(stackmap-&gt;numChildren() &gt;= stackmap-&gt;reps().size(), (&quot;At &quot;, *stackmap));
555         for (ConstrainedValue child : stackmap-&gt;constrainedChildren())
556             validateStackmapConstraint(stackmap, child);
557     }
558 
559     enum class ConstraintRole {
560         Use,
561         Def
562     };
563     void validateStackmapConstraint(Value* context, const ConstrainedValue&amp; value, ConstraintRole role = ConstraintRole::Use)
564     {
565         switch (value.rep().kind()) {
566         case ValueRep::WarmAny:
567         case ValueRep::SomeRegister:
568         case ValueRep::StackArgument:
569             break;
570         case ValueRep::LateColdAny:
571         case ValueRep::ColdAny:
572             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
573             break;
574         case ValueRep::SomeRegisterWithClobber:
575             VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
576             VALIDATE(context-&gt;as&lt;PatchpointValue&gt;(), (&quot;At &quot;, *context));
577             break;
578         case ValueRep::SomeEarlyRegister:
579             VALIDATE(role == ConstraintRole::Def, (&quot;At &quot;, *context, &quot;: &quot;, value));
580             break;
581         case ValueRep::Register:
582         case ValueRep::LateRegister:
583             if (value.rep().kind() == ValueRep::LateRegister)
584                 VALIDATE(role == ConstraintRole::Use, (&quot;At &quot;, *context, &quot;: &quot;, value));
585             if (value.rep().reg().isGPR())
586                 VALIDATE(isInt(value.value()-&gt;type()), (&quot;At &quot;, *context, &quot;: &quot;, value));
587             else
588                 VALIDATE(isFloat(value.value()-&gt;type()), (&quot;At &quot;, *context, &quot;: &quot;, value));
589             break;
590         default:
591             VALIDATE(false, (&quot;At &quot;, *context, &quot;: &quot;, value));
592             break;
593         }
594     }
595 
596     void validateFence(Value* value)
597     {
598         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
599         if (memory-&gt;hasFence())
600             VALIDATE(memory-&gt;accessBank() == GP, (&quot;Fence at &quot;, *memory));
601     }
602 
603     void validateAtomic(Value* value)
604     {
605         AtomicValue* atomic = value-&gt;as&lt;AtomicValue&gt;();
606 
607         VALIDATE(bestType(GP, atomic-&gt;accessWidth()) == atomic-&gt;accessType(), (&quot;At &quot;, *value));
608     }
609 
610     void validateStackAccess(Value* value)
611     {
612         MemoryValue* memory = value-&gt;as&lt;MemoryValue&gt;();
613         SlotBaseValue* slotBase = value-&gt;lastChild()-&gt;as&lt;SlotBaseValue&gt;();
614         if (!slotBase)
615             return;
616 
617         VALIDATE(memory-&gt;offset() &gt;= 0, (&quot;At &quot;, *value));
618     }
619 
620     NO_RETURN_DUE_TO_CRASH void fail(
621         const char* filename, int lineNumber, const char* function, const char* condition,
622         CString message)
623     {
624         CString failureMessage;
625         {
626             StringPrintStream out;
627             out.print(&quot;B3 VALIDATION FAILURE\n&quot;);
628             out.print(&quot;    &quot;, condition, &quot; (&quot;, filename, &quot;:&quot;, lineNumber, &quot;)\n&quot;);
629             out.print(&quot;    &quot;, message, &quot;\n&quot;);
630             out.print(&quot;    After &quot;, m_procedure.lastPhaseName(), &quot;\n&quot;);
631             failureMessage = out.toCString();
632         }
633 
634         dataLog(failureMessage);
635         if (m_dumpBefore) {
636             dataLog(&quot;Before &quot;, m_procedure.lastPhaseName(), &quot;:\n&quot;);
637             dataLog(m_dumpBefore);
638         }
639         dataLog(&quot;At time of failure:\n&quot;);
640         dataLog(m_procedure);
641 
642         dataLog(failureMessage);
643         WTFReportAssertionFailure(filename, lineNumber, function, condition);
644         CRASH();
645     }
646 
647     Procedure&amp; m_procedure;
648     const char* m_dumpBefore;
649 };
650 
651 } // anonymous namespace
652 
653 void validate(Procedure&amp; procedure, const char* dumpBefore)
654 {
655     Validater validater(procedure, dumpBefore);
656     validater.run();
657 }
658 
659 } } // namespace JSC::B3
660 
661 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>