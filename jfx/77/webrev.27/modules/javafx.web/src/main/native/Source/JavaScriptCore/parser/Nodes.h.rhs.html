<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.
   5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6  *  Copyright (C) 2007 Maks Orlovich
   7  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  *
   9  *  This library is free software; you can redistribute it and/or
  10  *  modify it under the terms of the GNU Library General Public
  11  *  License as published by the Free Software Foundation; either
  12  *  version 2 of the License, or (at your option) any later version.
  13  *
  14  *  This library is distributed in the hope that it will be useful,
  15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  *  Library General Public License for more details.
  18  *
  19  *  You should have received a copy of the GNU Library General Public License
  20  *  along with this library; see the file COPYING.LIB.  If not, write to
  21  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  *  Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  29 #include &quot;JITCode.h&quot;
  30 #include &quot;ParserArena.h&quot;
  31 #include &quot;ParserModes.h&quot;
  32 #include &quot;ParserTokens.h&quot;
  33 #include &quot;ResultType.h&quot;
  34 #include &quot;SourceCode.h&quot;
  35 #include &quot;SymbolTable.h&quot;
  36 #include &quot;VariableEnvironment.h&quot;
  37 #include &lt;wtf/MathExtras.h&gt;
  38 #include &lt;wtf/SmallPtrSet.h&gt;
  39 
  40 namespace JSC {
  41 
  42     enum OpcodeID : unsigned;
  43 
  44     class ArgumentListNode;
  45     class BytecodeGenerator;
  46     class FunctionMetadataNode;
  47     class FunctionParameters;
  48     class Label;
  49     class ModuleAnalyzer;
  50     class ModuleScopeData;
  51     class PropertyListNode;
  52     class ReadModifyResolveNode;
  53     class RegisterID;
  54     class ScopeNode;
  55 
  56     typedef SmallPtrSet&lt;UniquedStringImpl*&gt; UniquedStringImplPtrSet;
  57 
  58     enum Operator : uint8_t {
  59         OpEqual,
  60         OpPlusEq,
  61         OpMinusEq,
  62         OpMultEq,
  63         OpDivEq,
  64         OpPlusPlus,
  65         OpMinusMinus,
  66         OpAndEq,
  67         OpXOrEq,
  68         OpOrEq,
  69         OpModEq,
  70         OpPowEq,
  71         OpLShift,
  72         OpRShift,
  73         OpURShift
  74     };
  75 
  76     enum LogicalOperator : uint8_t {
  77         OpLogicalAnd,
  78         OpLogicalOr
  79     };
  80 
  81     enum FallThroughMode : uint8_t {
  82         FallThroughMeansTrue = 0,
  83         FallThroughMeansFalse = 1
  84     };
  85     inline FallThroughMode invert(FallThroughMode fallThroughMode) { return static_cast&lt;FallThroughMode&gt;(!fallThroughMode); }
  86 
  87     namespace DeclarationStacks {
  88         typedef Vector&lt;FunctionMetadataNode*&gt; FunctionStack;
  89     }
  90 
  91     struct SwitchInfo {
  92         enum SwitchType : uint8_t { SwitchNone, SwitchImmediate, SwitchCharacter, SwitchString };
  93         uint32_t bytecodeOffset;
  94         SwitchType switchType;
  95     };
  96 
  97     enum class AssignmentContext : uint8_t {
  98         DeclarationStatement,
  99         ConstDeclarationStatement,
 100         AssignmentExpression
 101     };
 102 
 103     class ParserArenaFreeable {
 104     public:
 105         // ParserArenaFreeable objects are freed when the arena is deleted.
 106         // Destructors are not called. Clients must not call delete on such objects.
 107         void* operator new(size_t, ParserArena&amp;);
 108     };
 109 
 110     class ParserArenaDeletable {
 111     public:
 112         virtual ~ParserArenaDeletable() { }
 113 
 114         // ParserArenaDeletable objects are deleted when the arena is deleted.
 115         // Clients must not call delete directly on such objects.
 116         template&lt;typename T&gt; void* operator new(size_t, ParserArena&amp;);
 117     };
 118 
 119 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 120         void* operator new(size_t size, ParserArena&amp; parserArena) \
 121         { \
 122             return ParserArenaDeletable::operator new&lt;__classToNew&gt;(size, parserArena); \
 123         }
 124 
 125 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(__classToNew) \
 126     public: \
 127         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 128     private: \
 129         typedef int __thisIsHereToForceASemicolonAfterThisMacro
 130 
 131     class ParserArenaRoot {
 132         WTF_MAKE_FAST_ALLOCATED;
 133     protected:
 134         ParserArenaRoot(ParserArena&amp;);
 135 
 136     public:
 137         ParserArena&amp; parserArena() { return m_arena; }
 138         virtual ~ParserArenaRoot() { }
 139 
 140     protected:
 141         ParserArena m_arena;
 142     };
 143 
 144     class Node : public ParserArenaFreeable {
 145     protected:
 146         Node(const JSTokenLocation&amp;);
 147 
 148     public:
 149         virtual ~Node() { }
 150 
 151         int firstLine() const { return m_position.line; }
 152         int startOffset() const { return m_position.offset; }
 153         int endOffset() const { return m_endOffset; }
 154         int lineStartOffset() const { return m_position.lineStartOffset; }
 155         const JSTextPosition&amp; position() const { return m_position; }
 156         void setEndOffset(int offset) { m_endOffset = offset; }
 157         void setStartOffset(int offset) { m_position.offset = offset; }
 158 
 159         bool needsDebugHook() const { return m_needsDebugHook; }
 160         void setNeedsDebugHook() { m_needsDebugHook = true; }
 161 
 162     protected:
 163         JSTextPosition m_position;
 164         int m_endOffset { -1 };
 165         bool m_needsDebugHook { false };
 166     };
 167 
 168     class ExpressionNode : public Node {
 169     protected:
 170         ExpressionNode(const JSTokenLocation&amp;, ResultType = ResultType::unknownType());
 171 
 172     public:
 173         virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 174 
 175         virtual bool isNumber() const { return false; }
 176         virtual bool isString() const { return false; }
 177         virtual bool isBigInt() const { return false; }
 178         virtual bool isObjectLiteral() const { return false; }
 179         virtual bool isArrayLiteral() const { return false; }
 180         virtual bool isNull() const { return false; }
 181         virtual bool isPure(BytecodeGenerator&amp;) const { return false; }
 182         virtual bool isConstant() const { return false; }
 183         virtual bool isLocation() const { return false; }
 184         virtual bool isAssignmentLocation() const { return isLocation(); }
 185         virtual bool isResolveNode() const { return false; }
 186         virtual bool isAssignResolveNode() const { return false; }
 187         virtual bool isBracketAccessorNode() const { return false; }
 188         virtual bool isDotAccessorNode() const { return false; }
 189         virtual bool isDestructuringNode() const { return false; }
 190         virtual bool isBaseFuncExprNode() const { return false; }
 191         virtual bool isFuncExprNode() const { return false; }
 192         virtual bool isArrowFuncExprNode() const { return false; }
 193         virtual bool isClassExprNode() const { return false; }
 194         virtual bool isCommaNode() const { return false; }
 195         virtual bool isSimpleArray() const { return false; }
 196         virtual bool isAdd() const { return false; }
 197         virtual bool isSubtract() const { return false; }
 198         virtual bool isBoolean() const { return false; }
 199         virtual bool isSpreadExpression() const { return false; }
 200         virtual bool isSuperNode() const { return false; }
 201         virtual bool isImportNode() const { return false; }
 202         virtual bool isMetaProperty() const { return false; }
 203         virtual bool isNewTarget() const { return false; }
 204         virtual bool isImportMeta() const { return false; }
 205         virtual bool isBytecodeIntrinsicNode() const { return false; }
 206         virtual bool isBinaryOpNode() const { return false; }
<a name="1" id="anc1"></a><span class="line-added"> 207         virtual bool isFunctionCall() const { return false; }</span>
<span class="line-added"> 208         virtual bool isDeleteNode() const { return false; }</span>
<span class="line-added"> 209         virtual bool isOptionalChain() const { return false; }</span>
 210 
 211         virtual void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp;, Label&amp;, FallThroughMode);
 212 
 213         virtual ExpressionNode* stripUnaryPlus() { return this; }
 214 
 215         ResultType resultDescriptor() const { return m_resultType; }
 216 
<a name="2" id="anc2"></a><span class="line-added"> 217         bool isOptionalChainBase() const { return m_isOptionalChainBase; }</span>
<span class="line-added"> 218         void setIsOptionalChainBase() { m_isOptionalChainBase = true; }</span>
<span class="line-added"> 219 </span>
 220     private:
 221         ResultType m_resultType;
<a name="3" id="anc3"></a><span class="line-added"> 222         bool m_isOptionalChainBase { false };</span>
 223     };
 224 
 225     class StatementNode : public Node {
 226     protected:
 227         StatementNode(const JSTokenLocation&amp;);
 228 
 229     public:
 230         virtual void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;
 231 
 232         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset);
 233         unsigned lastLine() const { return m_lastLine; }
 234 
 235         StatementNode* next() const { return m_next; }
 236         void setNext(StatementNode* next) { m_next = next; }
 237 
 238         virtual bool hasCompletionValue() const { return true; }
 239         virtual bool hasEarlyBreakOrContinue() const { return false; }
 240 
 241         virtual bool isEmptyStatement() const { return false; }
 242         virtual bool isDebuggerStatement() const { return false; }
 243         virtual bool isFunctionNode() const { return false; }
 244         virtual bool isReturnNode() const { return false; }
 245         virtual bool isExprStatement() const { return false; }
 246         virtual bool isBreak() const { return false; }
 247         virtual bool isContinue() const { return false; }
 248         virtual bool isLabel() const { return false; }
 249         virtual bool isBlock() const { return false; }
 250         virtual bool isFuncDeclNode() const { return false; }
 251         virtual bool isModuleDeclarationNode() const { return false; }
 252         virtual bool isForOfNode() const { return false; }
 253 
 254     protected:
 255         int m_lastLine { -1 };
 256         StatementNode* m_next { nullptr };
 257     };
 258 
 259     class VariableEnvironmentNode : public ParserArenaDeletable {
 260         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(VariableEnvironmentNode);
 261     public:
 262         typedef DeclarationStacks::FunctionStack FunctionStack;
 263 
 264         VariableEnvironmentNode()
 265         {
 266         }
 267 
 268         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables);
 269         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables, FunctionStack&amp;&amp;);
 270 
 271         VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 272         FunctionStack&amp; functionStack() { return m_functionStack; }
 273 
 274     protected:
 275         VariableEnvironment m_lexicalVariables;
 276         FunctionStack m_functionStack;
 277     };
 278 
 279     class ConstantNode : public ExpressionNode {
 280     public:
 281         ConstantNode(const JSTokenLocation&amp;, ResultType);
 282         bool isPure(BytecodeGenerator&amp;) const override { return true; }
 283         bool isConstant() const  override { return true; }
 284         virtual JSValue jsValue(BytecodeGenerator&amp;) const = 0;
 285     private:
 286         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 287         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
 288     };
 289 
 290     class NullNode final : public ConstantNode {
 291     public:
 292         NullNode(const JSTokenLocation&amp;);
 293 
 294     private:
 295         bool isNull() const override { return true; }
 296         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsNull(); }
 297     };
 298 
 299     class BooleanNode final : public ConstantNode {
 300     public:
 301         BooleanNode(const JSTokenLocation&amp;, bool value);
 302         bool value() { return m_value; }
 303 
 304     private:
 305         bool isBoolean() const override { return true; }
 306         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsBoolean(m_value); }
 307 
 308         bool m_value;
 309     };
 310 
 311     class NumberNode : public ConstantNode {
 312     public:
 313         NumberNode(const JSTokenLocation&amp;, double value);
 314         double value() const { return m_value; }
 315         virtual bool isIntegerNode() const = 0;
 316         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) final;
 317 
 318     private:
 319         bool isNumber() const final { return true; }
 320         JSValue jsValue(BytecodeGenerator&amp;) const override { return jsNumber(m_value); }
 321 
 322         double m_value;
 323     };
 324 
 325     class DoubleNode : public NumberNode {
 326     public:
 327         DoubleNode(const JSTokenLocation&amp;, double value);
 328 
 329     private:
 330         bool isIntegerNode() const override { return false; }
 331     };
 332 
 333     // An integer node represent a number represented as an integer (e.g. 42 instead of 42., 42.0, 42e0)
 334     class IntegerNode final : public DoubleNode {
 335     public:
 336         IntegerNode(const JSTokenLocation&amp;, double value);
 337         bool isIntegerNode() const final { return true; }
 338     };
 339 
 340     class StringNode final : public ConstantNode {
 341     public:
 342         StringNode(const JSTokenLocation&amp;, const Identifier&amp;);
 343         const Identifier&amp; value() { return m_value; }
 344 
 345     private:
 346         bool isString() const override { return true; }
 347         JSValue jsValue(BytecodeGenerator&amp;) const override;
 348 
 349         const Identifier&amp; m_value;
 350     };
 351 
 352     class BigIntNode final : public ConstantNode {
 353     public:
 354         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix);
 355         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix, bool sign);
 356         const Identifier&amp; value() { return m_value; }
 357 
 358         const Identifier&amp; identifier() const { return m_value; }
 359         uint8_t radix() const { return m_radix; }
 360         bool sign() const { return m_sign; }
 361 
 362     private:
 363         bool isBigInt() const final { return true; }
 364         JSValue jsValue(BytecodeGenerator&amp;) const final;
 365 
 366         const Identifier&amp; m_value;
 367         const uint8_t m_radix;
 368         const bool m_sign;
 369     };
 370 
 371     class ThrowableExpressionData {
 372     public:
 373         ThrowableExpressionData()
 374             : m_divot(-1, -1, -1)
 375             , m_divotStart(-1, -1, -1)
 376             , m_divotEnd(-1, -1, -1)
 377         {
 378         }
 379 
 380         ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 381             : m_divot(divot)
 382             , m_divotStart(start)
 383             , m_divotEnd(end)
 384         {
 385             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
 386             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);
 387             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);
 388         }
 389 
 390         void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 391         {
 392             ASSERT(divot.offset &gt;= divot.lineStartOffset);
 393             ASSERT(divotStart.offset &gt;= divotStart.lineStartOffset);
 394             ASSERT(divotEnd.offset &gt;= divotEnd.lineStartOffset);
 395             m_divot = divot;
 396             m_divotStart = divotStart;
 397             m_divotEnd = divotEnd;
 398         }
 399 
 400         const JSTextPosition&amp; divot() const { return m_divot; }
 401         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
 402         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
 403 
 404     protected:
 405         RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
 406 
 407     private:
 408         JSTextPosition m_divot;
 409         JSTextPosition m_divotStart;
 410         JSTextPosition m_divotEnd;
 411     };
 412 
 413     class ThrowableSubExpressionData : public ThrowableExpressionData {
 414     public:
 415         ThrowableSubExpressionData()
 416             : m_subexpressionDivotOffset(0)
 417             , m_subexpressionEndOffset(0)
 418             , m_subexpressionLineOffset(0)
 419             , m_subexpressionLineStartOffset(0)
 420         {
 421         }
 422 
 423         ThrowableSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 424             : ThrowableExpressionData(divot, divotStart, divotEnd)
 425             , m_subexpressionDivotOffset(0)
 426             , m_subexpressionEndOffset(0)
 427             , m_subexpressionLineOffset(0)
 428             , m_subexpressionLineStartOffset(0)
 429         {
 430         }
 431 
 432         void setSubexpressionInfo(const JSTextPosition&amp; subexpressionDivot, int subexpressionOffset)
 433         {
 434             ASSERT(subexpressionDivot.offset &lt;= divot().offset);
 435             // Overflow means we can&#39;t do this safely, so just point at the primary divot,
 436             // divotLine, or divotLineStart.
 437             if ((divot() - subexpressionDivot.offset) &amp; ~0xFFFF)
 438                 return;
 439             if ((divot().line - subexpressionDivot.line) &amp; ~0xFFFF)
 440                 return;
 441             if ((divot().lineStartOffset - subexpressionDivot.lineStartOffset) &amp; ~0xFFFF)
 442                 return;
 443             if ((divotEnd() - subexpressionOffset) &amp; ~0xFFFF)
 444                 return;
 445             m_subexpressionDivotOffset = divot() - subexpressionDivot.offset;
 446             m_subexpressionEndOffset = divotEnd() - subexpressionOffset;
 447             m_subexpressionLineOffset = divot().line - subexpressionDivot.line;
 448             m_subexpressionLineStartOffset = divot().lineStartOffset - subexpressionDivot.lineStartOffset;
 449         }
 450 
 451         JSTextPosition subexpressionDivot()
 452         {
 453             int newLine = divot().line - m_subexpressionLineOffset;
 454             int newOffset = divot().offset - m_subexpressionDivotOffset;
 455             int newLineStartOffset = divot().lineStartOffset - m_subexpressionLineStartOffset;
 456             return JSTextPosition(newLine, newOffset, newLineStartOffset);
 457         }
 458         JSTextPosition subexpressionStart() { return divotStart(); }
 459         JSTextPosition subexpressionEnd() { return divotEnd() - static_cast&lt;int&gt;(m_subexpressionEndOffset); }
 460 
 461     protected:
 462         uint16_t m_subexpressionDivotOffset;
 463         uint16_t m_subexpressionEndOffset;
 464         uint16_t m_subexpressionLineOffset;
 465         uint16_t m_subexpressionLineStartOffset;
 466     };
 467 
 468     class ThrowablePrefixedSubExpressionData : public ThrowableExpressionData {
 469     public:
 470         ThrowablePrefixedSubExpressionData()
 471             : m_subexpressionDivotOffset(0)
 472             , m_subexpressionStartOffset(0)
 473             , m_subexpressionLineOffset(0)
 474             , m_subexpressionLineStartOffset(0)
 475         {
 476         }
 477 
 478         ThrowablePrefixedSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 479             : ThrowableExpressionData(divot, start, end)
 480             , m_subexpressionDivotOffset(0)
 481             , m_subexpressionStartOffset(0)
 482             , m_subexpressionLineOffset(0)
 483             , m_subexpressionLineStartOffset(0)
 484         {
 485         }
 486 
 487         void setSubexpressionInfo(const JSTextPosition&amp; subexpressionDivot, int subexpressionOffset)
 488         {
 489             ASSERT(subexpressionDivot.offset &gt;= divot().offset);
 490             // Overflow means we can&#39;t do this safely, so just point at the primary divot,
 491             // divotLine, or divotLineStart.
 492             if ((subexpressionDivot.offset - divot()) &amp; ~0xFFFF)
 493                 return;
 494             if ((subexpressionDivot.line - divot().line) &amp; ~0xFFFF)
 495                 return;
 496             if ((subexpressionDivot.lineStartOffset - divot().lineStartOffset) &amp; ~0xFFFF)
 497                 return;
 498             if ((subexpressionOffset - divotStart()) &amp; ~0xFFFF)
 499                 return;
 500             m_subexpressionDivotOffset = subexpressionDivot.offset - divot();
 501             m_subexpressionStartOffset = subexpressionOffset - divotStart();
 502             m_subexpressionLineOffset = subexpressionDivot.line - divot().line;
 503             m_subexpressionLineStartOffset = subexpressionDivot.lineStartOffset - divot().lineStartOffset;
 504         }
 505 
 506         JSTextPosition subexpressionDivot()
 507         {
 508             int newLine = divot().line + m_subexpressionLineOffset;
 509             int newOffset = divot().offset + m_subexpressionDivotOffset;
 510             int newLineStartOffset = divot().lineStartOffset + m_subexpressionLineStartOffset;
 511             return JSTextPosition(newLine, newOffset, newLineStartOffset);
 512         }
 513         JSTextPosition subexpressionStart() { return divotStart() + static_cast&lt;int&gt;(m_subexpressionStartOffset); }
 514         JSTextPosition subexpressionEnd() { return divotEnd(); }
 515 
 516     protected:
 517         uint16_t m_subexpressionDivotOffset;
 518         uint16_t m_subexpressionStartOffset;
 519         uint16_t m_subexpressionLineOffset;
 520         uint16_t m_subexpressionLineStartOffset;
 521     };
 522 
 523     class TemplateExpressionListNode final : public ParserArenaFreeable {
 524     public:
 525         TemplateExpressionListNode(ExpressionNode*);
 526         TemplateExpressionListNode(TemplateExpressionListNode*, ExpressionNode*);
 527 
 528         ExpressionNode* value() { return m_node; }
 529         TemplateExpressionListNode* next() { return m_next; }
 530 
 531     private:
 532         TemplateExpressionListNode* m_next { nullptr };
 533         ExpressionNode* m_node { nullptr };
 534     };
 535 
 536     class TemplateStringNode final : public ExpressionNode {
 537     public:
 538         TemplateStringNode(const JSTokenLocation&amp;, const Identifier* cooked, const Identifier* raw);
 539 
 540         const Identifier* cooked() { return m_cooked; }
 541         const Identifier* raw() { return m_raw; }
 542 
 543     private:
 544         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 545 
 546         const Identifier* m_cooked;
 547         const Identifier* m_raw;
 548     };
 549 
 550     class TemplateStringListNode final : public ParserArenaFreeable {
 551     public:
 552         TemplateStringListNode(TemplateStringNode*);
 553         TemplateStringListNode(TemplateStringListNode*, TemplateStringNode*);
 554 
 555         TemplateStringNode* value() { return m_node; }
 556         TemplateStringListNode* next() { return m_next; }
 557 
 558     private:
 559         TemplateStringListNode* m_next { nullptr };
 560         TemplateStringNode* m_node { nullptr };
 561     };
 562 
 563     class TemplateLiteralNode final : public ExpressionNode {
 564     public:
 565         TemplateLiteralNode(const JSTokenLocation&amp;, TemplateStringListNode*);
 566         TemplateLiteralNode(const JSTokenLocation&amp;, TemplateStringListNode*, TemplateExpressionListNode*);
 567 
 568         TemplateStringListNode* templateStrings() const { return m_templateStrings; }
 569         TemplateExpressionListNode* templateExpressions() const { return m_templateExpressions; }
 570 
 571     private:
 572         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 573 
 574         TemplateStringListNode* m_templateStrings;
 575         TemplateExpressionListNode* m_templateExpressions;
 576     };
 577 
 578     class TaggedTemplateNode final : public ExpressionNode, public ThrowableExpressionData {
 579     public:
 580         TaggedTemplateNode(const JSTokenLocation&amp;, ExpressionNode*, TemplateLiteralNode*);
 581 
 582         TemplateLiteralNode* templateLiteral() const { return m_templateLiteral; }
 583 
 584     private:
 585         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 586 
 587         ExpressionNode* m_tag;
 588         TemplateLiteralNode* m_templateLiteral;
 589     };
 590 
 591     class RegExpNode final : public ExpressionNode, public ThrowableExpressionData {
 592     public:
 593         RegExpNode(const JSTokenLocation&amp;, const Identifier&amp; pattern, const Identifier&amp; flags);
 594 
 595     private:
 596         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 597 
 598         const Identifier&amp; m_pattern;
 599         const Identifier&amp; m_flags;
 600     };
 601 
 602     class ThisNode final : public ExpressionNode {
 603     public:
 604         ThisNode(const JSTokenLocation&amp;);
 605 
 606     private:
 607         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 608     };
 609 
 610     class SuperNode final : public ExpressionNode {
 611     public:
 612         SuperNode(const JSTokenLocation&amp;);
 613 
 614     private:
 615         bool isSuperNode() const override { return true; }
 616         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 617     };
 618 
 619     class ImportNode final : public ExpressionNode, public ThrowableExpressionData {
 620     public:
 621         ImportNode(const JSTokenLocation&amp;, ExpressionNode*);
 622 
 623     private:
 624         bool isImportNode() const override { return true; }
 625         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 626 
 627         ExpressionNode* m_expr;
 628     };
 629 
 630     class MetaPropertyNode : public ExpressionNode {
 631     public:
 632         MetaPropertyNode(const JSTokenLocation&amp;);
 633 
 634     private:
 635         bool isMetaProperty() const final { return true; }
 636     };
 637 
 638     class NewTargetNode final : public MetaPropertyNode {
 639     public:
 640         NewTargetNode(const JSTokenLocation&amp;);
 641 
 642     private:
 643         bool isNewTarget() const final { return true; }
 644         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 645     };
 646 
 647     class ImportMetaNode final : public MetaPropertyNode {
 648     public:
 649         ImportMetaNode(const JSTokenLocation&amp;, ExpressionNode*);
 650 
 651     private:
 652         bool isImportMeta() const final { return true; }
 653         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 654 
 655         ExpressionNode* m_expr;
 656     };
 657 
 658     class ResolveNode final : public ExpressionNode {
 659     public:
 660         ResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; start);
 661 
 662         const Identifier&amp; identifier() const { return m_ident; }
 663 
 664     private:
 665         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 666 
 667         bool isPure(BytecodeGenerator&amp;) const override;
 668         bool isLocation() const override { return true; }
 669         bool isResolveNode() const override { return true; }
 670 
 671         const Identifier&amp; m_ident;
 672         JSTextPosition m_start;
 673     };
 674 
 675     class ElementNode final : public ParserArenaFreeable {
 676     public:
 677         ElementNode(int elision, ExpressionNode*);
 678         ElementNode(ElementNode*, int elision, ExpressionNode*);
 679 
 680         int elision() const { return m_elision; }
 681         ExpressionNode* value() { return m_node; }
 682         ElementNode* next() { return m_next; }
 683 
 684     private:
 685         ElementNode* m_next { nullptr };
 686         ExpressionNode* m_node;
 687         int m_elision;
 688     };
 689 
 690     class ArrayNode final : public ExpressionNode {
 691     public:
 692         ArrayNode(const JSTokenLocation&amp;, int elision);
 693         ArrayNode(const JSTokenLocation&amp;, ElementNode*);
 694         ArrayNode(const JSTokenLocation&amp;, int elision, ElementNode*);
 695 
 696         bool isArrayLiteral() const override { return true; }
 697 
 698         ArgumentListNode* toArgumentList(ParserArena&amp;, int, int) const;
 699 
 700         ElementNode* elements() const { return m_element; }
 701     private:
 702         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 703 
 704         bool isSimpleArray() const override;
 705 
 706         ElementNode* m_element;
 707         int m_elision;
 708         bool m_optional;
 709     };
 710 
 711     enum class ClassElementTag : uint8_t { No, Instance, Static, LastTag };
 712     class PropertyNode final : public ParserArenaFreeable {
 713     public:
 714         enum Type : uint8_t { Constant = 1, Getter = 2, Setter = 4, Computed = 8, Shorthand = 16, Spread = 32 };
 715         enum PutType : uint8_t { Unknown, KnownDirect };
 716 
 717         PropertyNode(const Identifier&amp;, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 718         PropertyNode(ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 719         PropertyNode(ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 720 
 721         ExpressionNode* expressionName() const { return m_expression; }
 722         const Identifier* name() const { return m_name; }
 723 
 724         Type type() const { return static_cast&lt;Type&gt;(m_type); }
 725         bool needsSuperBinding() const { return m_needsSuperBinding; }
 726         bool isClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) != ClassElementTag::No; }
 727         bool isStaticClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Static; }
 728         bool isInstanceClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Instance; }
 729         bool isOverriddenByDuplicate() const { return m_isOverriddenByDuplicate; }
 730         void setIsOverriddenByDuplicate() { m_isOverriddenByDuplicate = true; }
 731         PutType putType() const { return static_cast&lt;PutType&gt;(m_putType); }
 732 
 733     private:
 734         friend class PropertyListNode;
 735         const Identifier* m_name;
 736         ExpressionNode* m_expression;
 737         ExpressionNode* m_assign;
 738         unsigned m_type : 6;
 739         unsigned m_needsSuperBinding : 1;
 740         unsigned m_putType : 1;
 741         static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
 742         unsigned m_classElementTag : 2;
 743         unsigned m_isOverriddenByDuplicate: 1;
 744     };
 745 
 746     class PropertyListNode final : public ExpressionNode {
 747     public:
 748         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
 749         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
 750 
 751         bool hasStaticallyNamedProperty(const Identifier&amp; propName);
 752 
 753         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*);
 754 
 755     private:
 756         RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
 757         {
 758             return emitBytecode(generator, dst, nullptr);
 759         }
 760         void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);
 761 
 762         PropertyNode* m_node;
 763         PropertyListNode* m_next { nullptr };
 764     };
 765 
 766     class ObjectLiteralNode final : public ExpressionNode {
 767     public:
 768         ObjectLiteralNode(const JSTokenLocation&amp;);
 769         ObjectLiteralNode(const JSTokenLocation&amp;, PropertyListNode*);
 770         bool isObjectLiteral() const override { return true; }
 771 
 772     private:
 773         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 774 
 775         PropertyListNode* m_list;
 776     };
 777 
 778     class BracketAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 779     public:
 780         BracketAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);
 781 
 782         ExpressionNode* base() const { return m_base; }
 783         ExpressionNode* subscript() const { return m_subscript; }
 784 
 785         bool subscriptHasAssignments() const { return m_subscriptHasAssignments; }
 786 
 787     private:
 788         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 789 
 790         bool isLocation() const override { return true; }
 791         bool isBracketAccessorNode() const override { return true; }
 792 
 793         ExpressionNode* m_base;
 794         ExpressionNode* m_subscript;
 795         bool m_subscriptHasAssignments;
 796     };
 797 
 798     class DotAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 799     public:
 800         DotAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;);
 801 
 802         ExpressionNode* base() const { return m_base; }
 803         const Identifier&amp; identifier() const { return m_ident; }
 804 
 805     private:
 806         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 807 
 808         bool isLocation() const override { return true; }
 809         bool isDotAccessorNode() const override { return true; }
 810 
 811         ExpressionNode* m_base;
 812         const Identifier&amp; m_ident;
 813     };
 814 
 815     class SpreadExpressionNode final : public ExpressionNode, public ThrowableExpressionData {
 816     public:
 817         SpreadExpressionNode(const JSTokenLocation&amp;, ExpressionNode*);
 818 
 819         ExpressionNode* expression() const { return m_expression; }
 820 
 821     private:
 822         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 823 
 824         bool isSpreadExpression() const override { return true; }
 825         ExpressionNode* m_expression;
 826     };
 827 
 828     class ObjectSpreadExpressionNode final : public ExpressionNode, public ThrowableExpressionData {
 829     public:
 830         ObjectSpreadExpressionNode(const JSTokenLocation&amp;, ExpressionNode*);
 831 
 832         ExpressionNode* expression() const { return m_expression; }
 833 
 834     private:
 835         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 836 
 837         ExpressionNode* m_expression;
 838     };
 839 
 840     class ArgumentListNode final : public ExpressionNode {
 841     public:
 842         ArgumentListNode(const JSTokenLocation&amp;, ExpressionNode*);
 843         ArgumentListNode(const JSTokenLocation&amp;, ArgumentListNode*, ExpressionNode*);
 844 
 845         ArgumentListNode* m_next { nullptr };
 846         ExpressionNode* m_expr;
 847 
 848     private:
 849         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 850     };
 851 
 852     class ArgumentsNode final : public ParserArenaFreeable {
 853     public:
 854         ArgumentsNode();
 855         ArgumentsNode(ArgumentListNode*);
 856 
 857         ArgumentListNode* m_listNode;
 858     };
 859 
 860     class NewExprNode final : public ExpressionNode, public ThrowableExpressionData {
 861     public:
 862         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*);
 863         NewExprNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*);
 864 
 865     private:
 866         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 867 
 868         ExpressionNode* m_expr;
 869         ArgumentsNode* m_args;
 870     };
 871 
 872     class EvalFunctionCallNode final : public ExpressionNode, public ThrowableExpressionData {
 873     public:
 874         EvalFunctionCallNode(const JSTokenLocation&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 875 
 876     private:
 877         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 878 
<a name="4" id="anc4"></a><span class="line-added"> 879         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 880 </span>
 881         ArgumentsNode* m_args;
 882     };
 883 
 884     class FunctionCallValueNode final : public ExpressionNode, public ThrowableExpressionData {
 885     public:
 886         FunctionCallValueNode(const JSTokenLocation&amp;, ExpressionNode*, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 887 
 888     private:
 889         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 890 
<a name="5" id="anc5"></a><span class="line-added"> 891         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 892 </span>
 893         ExpressionNode* m_expr;
 894         ArgumentsNode* m_args;
 895     };
 896 
 897     class FunctionCallResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 898     public:
 899         FunctionCallResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 900 
 901     private:
 902         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 903 
<a name="6" id="anc6"></a><span class="line-added"> 904         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 905 </span>
 906         const Identifier&amp; m_ident;
 907         ArgumentsNode* m_args;
 908     };
 909 
 910     class FunctionCallBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
 911     public:
 912         FunctionCallBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 913 
 914     private:
 915         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 916 
<a name="7" id="anc7"></a><span class="line-added"> 917         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 918 </span>
 919         ExpressionNode* m_base;
 920         ExpressionNode* m_subscript;
 921         ArgumentsNode* m_args;
 922         bool m_subscriptHasAssignments;
 923     };
 924 
 925     class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
 926     public:
 927         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 928 
 929     private:
 930         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 931 
 932     protected:
<a name="8" id="anc8"></a><span class="line-added"> 933         bool isFunctionCall() const override { return true; }</span>
<span class="line-added"> 934 </span>
 935         ExpressionNode* m_base;
 936         const Identifier&amp; m_ident;
 937         ArgumentsNode* m_args;
 938     };
 939 
 940     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 941     public:
 942         enum class Type : uint8_t {
 943             Constant,
 944             Function
 945         };
 946 
 947         typedef RegisterID* (BytecodeIntrinsicNode::* EmitterType)(BytecodeGenerator&amp;, RegisterID*);
 948 
 949         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, EmitterType, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 950 
 951         bool isBytecodeIntrinsicNode() const override { return true; }
 952 
 953         Type type() const { return m_type; }
 954         EmitterType emitter() const { return m_emitter; }
 955         const Identifier&amp; identifier() const { return m_ident; }
 956 
 957 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 958         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 959         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 960 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 961 
 962     private:
 963         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 964 
<a name="9" id="anc9"></a><span class="line-added"> 965         bool isFunctionCall() const override { return m_type == Type::Function; }</span>
<span class="line-added"> 966 </span>
 967         EmitterType m_emitter;
 968         const Identifier&amp; m_ident;
 969         ArgumentsNode* m_args;
 970         Type m_type;
 971     };
 972 
 973     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 974     public:
 975         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 976 
 977     private:
 978         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 979         size_t m_distanceToInnermostCallOrApply;
 980     };
 981 
 982     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 983     public:
 984         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 985 
 986     private:
 987         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 988         size_t m_distanceToInnermostCallOrApply;
 989     };
 990 
 991     class DeleteResolveNode final : public ExpressionNode, public ThrowableExpressionData {
 992     public:
 993         DeleteResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 994 
 995     private:
 996         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 997 
<a name="10" id="anc10"></a><span class="line-added"> 998         bool isDeleteNode() const final { return true; }</span>
<span class="line-added"> 999 </span>
1000         const Identifier&amp; m_ident;
1001     };
1002 
1003     class DeleteBracketNode final : public ExpressionNode, public ThrowableExpressionData {
1004     public:
1005         DeleteBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1006 
1007     private:
1008         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1009 
<a name="11" id="anc11"></a><span class="line-added">1010         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1011 </span>
1012         ExpressionNode* m_base;
1013         ExpressionNode* m_subscript;
1014     };
1015 
1016     class DeleteDotNode final : public ExpressionNode, public ThrowableExpressionData {
1017     public:
1018         DeleteDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1019 
1020     private:
1021         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1022 
<a name="12" id="anc12"></a><span class="line-added">1023         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1024 </span>
1025         ExpressionNode* m_base;
1026         const Identifier&amp; m_ident;
1027     };
1028 
1029     class DeleteValueNode final : public ExpressionNode {
1030     public:
1031         DeleteValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1032 
1033     private:
1034         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1035 
<a name="13" id="anc13"></a><span class="line-added">1036         bool isDeleteNode() const final { return true; }</span>
<span class="line-added">1037 </span>
1038         ExpressionNode* m_expr;
1039     };
1040 
1041     class VoidNode final : public ExpressionNode {
1042     public:
1043         VoidNode(const JSTokenLocation&amp;, ExpressionNode*);
1044 
1045     private:
1046         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1047 
1048         ExpressionNode* m_expr;
1049     };
1050 
1051     class TypeOfResolveNode final : public ExpressionNode {
1052     public:
1053         TypeOfResolveNode(const JSTokenLocation&amp;, const Identifier&amp;);
1054 
1055         const Identifier&amp; identifier() const { return m_ident; }
1056 
1057     private:
1058         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1059 
1060         const Identifier&amp; m_ident;
1061     };
1062 
1063     class TypeOfValueNode final : public ExpressionNode {
1064     public:
1065         TypeOfValueNode(const JSTokenLocation&amp;, ExpressionNode*);
1066 
1067     private:
1068         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1069 
1070         ExpressionNode* m_expr;
1071     };
1072 
1073     class PrefixNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
1074     public:
1075         PrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1076 
1077     protected:
1078         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1079         virtual RegisterID* emitResolve(BytecodeGenerator&amp;, RegisterID* = 0);
1080         virtual RegisterID* emitBracket(BytecodeGenerator&amp;, RegisterID* = 0);
1081         virtual RegisterID* emitDot(BytecodeGenerator&amp;, RegisterID* = 0);
1082 
1083         ExpressionNode* m_expr;
1084         Operator m_operator;
1085     };
1086 
1087     class PostfixNode final : public PrefixNode {
1088     public:
1089         PostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1090 
1091     private:
1092         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1093         RegisterID* emitResolve(BytecodeGenerator&amp;, RegisterID* = 0) override;
1094         RegisterID* emitBracket(BytecodeGenerator&amp;, RegisterID* = 0) override;
1095         RegisterID* emitDot(BytecodeGenerator&amp;, RegisterID* = 0) override;
1096     };
1097 
1098     class UnaryOpNode : public ExpressionNode {
1099     public:
1100         UnaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode*, OpcodeID);
1101 
1102     protected:
1103         ExpressionNode* expr() { return m_expr; }
1104         const ExpressionNode* expr() const { return m_expr; }
1105         OpcodeID opcodeID() const { return m_opcodeID; }
1106 
1107     private:
1108         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1109 
1110         ExpressionNode* m_expr;
1111         OpcodeID m_opcodeID;
1112     };
1113 
1114     class UnaryPlusNode final : public UnaryOpNode {
1115     public:
1116         UnaryPlusNode(const JSTokenLocation&amp;, ExpressionNode*);
1117 
1118     private:
1119         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1120 
1121         ExpressionNode* stripUnaryPlus() override { return expr(); }
1122     };
1123 
1124     class NegateNode final : public UnaryOpNode {
1125     public:
1126         NegateNode(const JSTokenLocation&amp;, ExpressionNode*);
1127     };
1128 
1129     class BitwiseNotNode final : public UnaryOpNode {
1130     public:
1131         BitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
1132     };
1133 
1134     class LogicalNotNode final : public UnaryOpNode {
1135     public:
1136         LogicalNotNode(const JSTokenLocation&amp;, ExpressionNode*);
1137     private:
1138         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1139     };
1140 
1141     class BinaryOpNode : public ExpressionNode {
1142     public:
1143         BinaryOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1144         BinaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1145 
1146         RegisterID* emitStrcat(BytecodeGenerator&amp; generator, RegisterID* destination, RegisterID* lhs = 0, ReadModifyResolveNode* emitExpressionInfoForMe = 0);
1147         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1148 
1149         ExpressionNode* lhs() { return m_expr1; };
1150         ExpressionNode* rhs() { return m_expr2; };
1151 
1152         bool isBinaryOpNode() const override { return true; }
1153 
1154     private:
1155         enum class UInt32Result : uint8_t { UInt32, Constant, };
1156 
1157         void tryFoldToBranch(BytecodeGenerator&amp;, TriState&amp; branchCondition, ExpressionNode*&amp; branchExpression);
1158         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1159 
1160     protected:
1161         OpcodeID opcodeID() const { return m_opcodeID; }
1162 
1163     protected:
1164         bool m_rightHasAssignments;
1165         bool m_shouldToUnsignedResult { true };
1166     private:
1167         OpcodeID m_opcodeID;
1168     protected:
1169         ExpressionNode* m_expr1;
1170         ExpressionNode* m_expr2;
1171     };
1172 
1173     class PowNode final : public BinaryOpNode {
1174     public:
1175         PowNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1176     };
1177 
1178     class MultNode final : public BinaryOpNode {
1179     public:
1180         MultNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1181     };
1182 
1183     class DivNode final : public BinaryOpNode {
1184     public:
1185         DivNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1186     };
1187 
1188     class ModNode final : public BinaryOpNode {
1189     public:
1190         ModNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1191     };
1192 
1193     class AddNode final : public BinaryOpNode {
1194     public:
1195         AddNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1196 
1197         bool isAdd() const override { return true; }
1198     };
1199 
1200     class SubNode final : public BinaryOpNode {
1201     public:
1202         SubNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1203 
1204         bool isSubtract() const override { return true; }
1205     };
1206 
1207     class LeftShiftNode final : public BinaryOpNode {
1208     public:
1209         LeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1210     };
1211 
1212     class RightShiftNode final : public BinaryOpNode {
1213     public:
1214         RightShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1215     };
1216 
1217     class UnsignedRightShiftNode final : public BinaryOpNode {
1218     public:
1219         UnsignedRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1220     };
1221 
1222     class LessNode final : public BinaryOpNode {
1223     public:
1224         LessNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1225     };
1226 
1227     class GreaterNode final : public BinaryOpNode {
1228     public:
1229         GreaterNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1230     };
1231 
1232     class LessEqNode final : public BinaryOpNode {
1233     public:
1234         LessEqNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1235     };
1236 
1237     class GreaterEqNode final : public BinaryOpNode {
1238     public:
1239         GreaterEqNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1240     };
1241 
1242     class ThrowableBinaryOpNode : public BinaryOpNode, public ThrowableExpressionData {
1243     public:
1244         ThrowableBinaryOpNode(const JSTokenLocation&amp;, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1245         ThrowableBinaryOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
1246 
1247     private:
1248         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1249     };
1250 
1251     class InstanceOfNode final : public ThrowableBinaryOpNode {
1252     public:
1253         InstanceOfNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1254 
1255     private:
1256         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1257     };
1258 
1259     class InNode final : public ThrowableBinaryOpNode {
1260     public:
1261         InNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1262 
1263     private:
1264         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1265     };
1266 
1267     class EqualNode final : public BinaryOpNode {
1268     public:
1269         EqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1270 
1271     private:
1272         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1273     };
1274 
1275     class NotEqualNode final : public BinaryOpNode {
1276     public:
1277         NotEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1278     };
1279 
1280     class StrictEqualNode final : public BinaryOpNode {
1281     public:
1282         StrictEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1283 
1284     private:
1285         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1286     };
1287 
1288     class NotStrictEqualNode final : public BinaryOpNode {
1289     public:
1290         NotStrictEqualNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1291     };
1292 
1293     class BitAndNode final : public BinaryOpNode {
1294     public:
1295         BitAndNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1296     };
1297 
1298     class BitOrNode final : public BinaryOpNode {
1299     public:
1300         BitOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1301     };
1302 
1303     class BitXOrNode final : public BinaryOpNode {
1304     public:
1305         BitXOrNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
1306     };
1307 
1308     // m_expr1 &amp;&amp; m_expr2, m_expr1 || m_expr2
1309     class LogicalOpNode final : public ExpressionNode {
1310     public:
1311         LogicalOpNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);
1312 
1313     private:
1314         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1315         void emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode) override;
1316 
1317         LogicalOperator m_operator;
1318         ExpressionNode* m_expr1;
1319         ExpressionNode* m_expr2;
1320     };
1321 
<a name="14" id="anc14"></a><span class="line-added">1322     class CoalesceNode final : public ExpressionNode {</span>
<span class="line-added">1323     public:</span>
<span class="line-added">1324         CoalesceNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, bool);</span>
<span class="line-added">1325 </span>
<span class="line-added">1326     private:</span>
<span class="line-added">1327         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;</span>
<span class="line-added">1328 </span>
<span class="line-added">1329         ExpressionNode* m_expr1;</span>
<span class="line-added">1330         ExpressionNode* m_expr2;</span>
<span class="line-added">1331         bool m_hasAbsorbedOptionalChain;</span>
<span class="line-added">1332     };</span>
<span class="line-added">1333 </span>
<span class="line-added">1334     class OptionalChainNode final : public ExpressionNode {</span>
<span class="line-added">1335     public:</span>
<span class="line-added">1336         OptionalChainNode(const JSTokenLocation&amp;, ExpressionNode*, bool);</span>
<span class="line-added">1337 </span>
<span class="line-added">1338         void setExpr(ExpressionNode* expr) { m_expr = expr; }</span>
<span class="line-added">1339         ExpressionNode* expr() const { return m_expr; }</span>
<span class="line-added">1340 </span>
<span class="line-added">1341     private:</span>
<span class="line-added">1342         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = nullptr) final;</span>
<span class="line-added">1343 </span>
<span class="line-added">1344         bool isOptionalChain() const final { return true; }</span>
<span class="line-added">1345 </span>
<span class="line-added">1346         ExpressionNode* m_expr;</span>
<span class="line-added">1347         bool m_isOutermost;</span>
<span class="line-added">1348     };</span>
<span class="line-added">1349 </span>
1350     // The ternary operator, &quot;m_logical ? m_expr1 : m_expr2&quot;
1351     class ConditionalNode final : public ExpressionNode {
1352     public:
1353         ConditionalNode(const JSTokenLocation&amp;, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);
1354 
1355     private:
1356         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1357 
1358         ExpressionNode* m_logical;
1359         ExpressionNode* m_expr1;
1360         ExpressionNode* m_expr2;
1361     };
1362 
1363     class ReadModifyResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1364     public:
1365         ReadModifyResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, Operator, ExpressionNode*  right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1366 
1367     private:
1368         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1369 
1370         const Identifier&amp; m_ident;
1371         ExpressionNode* m_right;
1372         Operator m_operator;
1373         bool m_rightHasAssignments;
1374     };
1375 
1376     class AssignResolveNode final : public ExpressionNode, public ThrowableExpressionData {
1377     public:
1378         AssignResolveNode(const JSTokenLocation&amp;, const Identifier&amp;, ExpressionNode* right, AssignmentContext);
1379         bool isAssignResolveNode() const override { return true; }
1380         const Identifier&amp; identifier() const { return m_ident; }
1381 
1382     private:
1383         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1384 
1385         const Identifier&amp; m_ident;
1386         ExpressionNode* m_right;
1387         AssignmentContext m_assignmentContext;
1388     };
1389 
1390     class ReadModifyBracketNode final : public ExpressionNode, public ThrowableSubExpressionData {
1391     public:
1392         ReadModifyBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, Operator, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1393 
1394     private:
1395         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1396 
1397         ExpressionNode* m_base;
1398         ExpressionNode* m_subscript;
1399         ExpressionNode* m_right;
1400         unsigned m_operator : 30;
1401         bool m_subscriptHasAssignments : 1;
1402         bool m_rightHasAssignments : 1;
1403     };
1404 
1405     class AssignBracketNode final : public ExpressionNode, public ThrowableExpressionData {
1406     public:
1407         AssignBracketNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1408 
1409     private:
1410         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1411 
1412         ExpressionNode* m_base;
1413         ExpressionNode* m_subscript;
1414         ExpressionNode* m_right;
1415         bool m_subscriptHasAssignments : 1;
1416         bool m_rightHasAssignments : 1;
1417     };
1418 
1419     class AssignDotNode final : public ExpressionNode, public ThrowableExpressionData {
1420     public:
1421         AssignDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ExpressionNode* right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1422 
1423     private:
1424         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1425 
1426         ExpressionNode* m_base;
1427         const Identifier&amp; m_ident;
1428         ExpressionNode* m_right;
1429         bool m_rightHasAssignments;
1430     };
1431 
1432     class ReadModifyDotNode final : public ExpressionNode, public ThrowableSubExpressionData {
1433     public:
1434         ReadModifyDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, Operator, ExpressionNode* right, bool rightHasAssignments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1435 
1436     private:
1437         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1438 
1439         ExpressionNode* m_base;
1440         const Identifier&amp; m_ident;
1441         ExpressionNode* m_right;
1442         unsigned m_operator : 31;
1443         bool m_rightHasAssignments : 1;
1444     };
1445 
1446     class AssignErrorNode final : public ExpressionNode, public ThrowableExpressionData {
1447     public:
1448         AssignErrorNode(const JSTokenLocation&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
1449 
1450     private:
1451         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1452     };
1453 
1454     class CommaNode final : public ExpressionNode {
1455     public:
1456         CommaNode(const JSTokenLocation&amp;, ExpressionNode*);
1457 
1458         void setNext(CommaNode* next) { m_next = next; }
1459         CommaNode* next() { return m_next; }
1460 
1461     private:
1462         bool isCommaNode() const override { return true; }
1463         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1464 
1465         ExpressionNode* m_expr;
1466         CommaNode* m_next { nullptr };
1467     };
1468 
1469     class SourceElements final : public ParserArenaFreeable {
1470     public:
1471         SourceElements();
1472 
1473         void append(StatementNode*);
1474 
1475         StatementNode* singleStatement() const;
1476         StatementNode* lastStatement() const;
1477 
1478         bool hasCompletionValue() const;
1479         bool hasEarlyBreakOrContinue() const;
1480 
1481         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1482         void analyzeModule(ModuleAnalyzer&amp;);
1483 
1484     private:
1485         StatementNode* m_head { nullptr };
1486         StatementNode* m_tail { nullptr };
1487     };
1488 
1489     class BlockNode final : public StatementNode, public VariableEnvironmentNode {
1490         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(BlockNode);
1491     public:
1492         BlockNode(const JSTokenLocation&amp;, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
1493 
1494         StatementNode* singleStatement() const;
1495         StatementNode* lastStatement() const;
1496 
1497     private:
1498         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1499 
1500         bool hasCompletionValue() const override;
1501         bool hasEarlyBreakOrContinue() const override;
1502 
1503         bool isBlock() const override { return true; }
1504 
1505         SourceElements* m_statements;
1506     };
1507 
1508     class EmptyStatementNode final : public StatementNode {
1509     public:
1510         EmptyStatementNode(const JSTokenLocation&amp;);
1511 
1512     private:
1513         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1514 
1515         bool hasCompletionValue() const override { return false; }
1516         bool isEmptyStatement() const override { return true; }
1517     };
1518 
1519     class DebuggerStatementNode final : public StatementNode {
1520     public:
1521         DebuggerStatementNode(const JSTokenLocation&amp;);
1522 
1523         bool hasCompletionValue() const override { return false; }
1524         bool isDebuggerStatement() const override { return true; }
1525 
1526     private:
1527         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1528     };
1529 
1530     class ExprStatementNode final : public StatementNode {
1531     public:
1532         ExprStatementNode(const JSTokenLocation&amp;, ExpressionNode*);
1533 
1534         ExpressionNode* expr() const { return m_expr; }
1535 
1536     private:
1537         bool isExprStatement() const override { return true; }
1538 
1539         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1540 
1541         ExpressionNode* m_expr;
1542     };
1543 
1544     class DeclarationStatement final : public StatementNode {
1545     public:
1546         DeclarationStatement(const JSTokenLocation&amp;, ExpressionNode*);
1547     private:
1548         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1549 
1550         bool hasCompletionValue() const override { return false; }
1551 
1552         ExpressionNode* m_expr;
1553     };
1554 
1555     class EmptyVarExpression final : public ExpressionNode {
1556     public:
1557         EmptyVarExpression(const JSTokenLocation&amp;, const Identifier&amp;);
1558 
1559     private:
1560         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1561 
1562         const Identifier&amp; m_ident;
1563     };
1564 
1565     class EmptyLetExpression final : public ExpressionNode {
1566     public:
1567         EmptyLetExpression(const JSTokenLocation&amp;, const Identifier&amp;);
1568 
1569     private:
1570         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1571 
1572         const Identifier&amp; m_ident;
1573     };
1574 
1575     class IfElseNode final : public StatementNode {
1576     public:
1577         IfElseNode(const JSTokenLocation&amp;, ExpressionNode* condition, StatementNode* ifBlock, StatementNode* elseBlock);
1578 
1579     private:
1580         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1581         bool tryFoldBreakAndContinue(BytecodeGenerator&amp;, StatementNode* ifBlock,
1582             Label*&amp; trueTarget, FallThroughMode&amp;);
1583 
1584         ExpressionNode* m_condition;
1585         StatementNode* m_ifBlock;
1586         StatementNode* m_elseBlock;
1587     };
1588 
1589     class DoWhileNode final : public StatementNode {
1590     public:
1591         DoWhileNode(const JSTokenLocation&amp;, StatementNode*, ExpressionNode*);
1592 
1593     private:
1594         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1595 
1596         StatementNode* m_statement;
1597         ExpressionNode* m_expr;
1598     };
1599 
1600     class WhileNode final : public StatementNode {
1601     public:
1602         WhileNode(const JSTokenLocation&amp;, ExpressionNode*, StatementNode*);
1603 
1604     private:
1605         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1606 
1607         ExpressionNode* m_expr;
1608         StatementNode* m_statement;
1609     };
1610 
1611     class ForNode final : public StatementNode, public VariableEnvironmentNode {
1612         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForNode);
1613     public:
1614         ForNode(const JSTokenLocation&amp;, ExpressionNode* expr1, ExpressionNode* expr2, ExpressionNode* expr3, StatementNode*, VariableEnvironment&amp;);
1615 
1616     private:
1617         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1618 
1619         ExpressionNode* m_expr1;
1620         ExpressionNode* m_expr2;
1621         ExpressionNode* m_expr3;
1622         StatementNode* m_statement;
1623     };
1624 
1625     class DestructuringPatternNode;
1626 
1627     class EnumerationNode : public StatementNode, public ThrowableExpressionData, public VariableEnvironmentNode {
1628         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(EnumerationNode);
1629     public:
1630         EnumerationNode(const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1631 
1632         ExpressionNode* lexpr() const { return m_lexpr; }
1633         ExpressionNode* expr() const { return m_expr; }
1634 
1635     protected:
1636         ExpressionNode* m_lexpr;
1637         ExpressionNode* m_expr;
1638         StatementNode* m_statement;
1639     };
1640 
1641     class ForInNode final : public EnumerationNode {
1642         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForInNode);
1643     public:
1644         ForInNode(const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1645 
1646     private:
1647         RegisterID* tryGetBoundLocal(BytecodeGenerator&amp;);
1648         void emitLoopHeader(BytecodeGenerator&amp;, RegisterID* propertyName);
1649 
1650         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1651     };
1652 
1653     class ForOfNode final : public EnumerationNode {
1654         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ForOfNode);
1655     public:
1656         ForOfNode(bool, const JSTokenLocation&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, VariableEnvironment&amp;);
1657         bool isForOfNode() const override { return true; }
1658         bool isForAwait() const { return m_isForAwait; }
1659 
1660     private:
1661         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1662 
1663         const bool m_isForAwait;
1664     };
1665 
1666     class ContinueNode final : public StatementNode, public ThrowableExpressionData {
1667     public:
1668         ContinueNode(const JSTokenLocation&amp;, const Identifier&amp;);
1669         Label* trivialTarget(BytecodeGenerator&amp;);
1670 
1671     private:
1672         bool hasCompletionValue() const override { return false; }
1673         bool isContinue() const override { return true; }
1674         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1675 
1676         const Identifier&amp; m_ident;
1677     };
1678 
1679     class BreakNode final : public StatementNode, public ThrowableExpressionData {
1680     public:
1681         BreakNode(const JSTokenLocation&amp;, const Identifier&amp;);
1682         Label* trivialTarget(BytecodeGenerator&amp;);
1683 
1684     private:
1685         bool hasCompletionValue() const override { return false; }
1686         bool isBreak() const override { return true; }
1687         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1688 
1689         const Identifier&amp; m_ident;
1690     };
1691 
1692     class ReturnNode final : public StatementNode, public ThrowableExpressionData {
1693     public:
1694         ReturnNode(const JSTokenLocation&amp;, ExpressionNode* value);
1695 
1696         ExpressionNode* value() { return m_value; }
1697 
1698     private:
1699         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1700 
1701         bool isReturnNode() const override { return true; }
1702 
1703         ExpressionNode* m_value;
1704     };
1705 
1706     class WithNode final : public StatementNode {
1707     public:
1708         WithNode(const JSTokenLocation&amp;, ExpressionNode*, StatementNode*, const JSTextPosition&amp; divot, uint32_t expressionLength);
1709 
1710     private:
1711         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1712 
1713         ExpressionNode* m_expr;
1714         StatementNode* m_statement;
1715         JSTextPosition m_divot;
1716         uint32_t m_expressionLength;
1717     };
1718 
1719     class LabelNode final : public StatementNode, public ThrowableExpressionData {
1720     public:
1721         LabelNode(const JSTokenLocation&amp;, const Identifier&amp; name, StatementNode*);
1722 
1723         bool isLabel() const override { return true; }
1724 
1725     private:
1726         bool hasCompletionValue() const override { return m_statement-&gt;hasCompletionValue(); }
1727         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1728 
1729         const Identifier&amp; m_name;
1730         StatementNode* m_statement;
1731     };
1732 
1733     class ThrowNode final : public StatementNode, public ThrowableExpressionData {
1734     public:
1735         ThrowNode(const JSTokenLocation&amp;, ExpressionNode*);
1736 
1737     private:
1738         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1739 
1740         ExpressionNode* m_expr;
1741     };
1742 
1743     class TryNode final : public StatementNode, public VariableEnvironmentNode {
1744         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(TryNode);
1745     public:
1746         TryNode(const JSTokenLocation&amp;, StatementNode* tryBlock, DestructuringPatternNode* catchPattern, StatementNode* catchBlock, VariableEnvironment&amp; catchEnvironment, StatementNode* finallyBlock);
1747 
1748     private:
1749         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1750 
1751         StatementNode* m_tryBlock;
1752         DestructuringPatternNode* m_catchPattern;
1753         StatementNode* m_catchBlock;
1754         StatementNode* m_finallyBlock;
1755     };
1756 
1757     class ScopeNode : public StatementNode, public ParserArenaRoot, public VariableEnvironmentNode {
1758     public:
1759         // ScopeNode is never directly instantiate. The life-cycle of its derived classes are
1760         // managed using std::unique_ptr. Hence, though ScopeNode extends VariableEnvironmentNode,
1761         // which in turn extends ParserArenaDeletable, we don&#39;t want to use ParserArenaDeletable&#39;s
1762         // new for allocation.
1763         using ParserArenaRoot::operator new;
1764 
1765         ScopeNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, bool inStrictContext);
1766         ScopeNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, const SourceCode&amp;, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants);
1767 
1768         const SourceCode&amp; source() const { return m_source; }
1769         const String&amp; sourceURL() const { return m_source.provider()-&gt;url(); }
1770         intptr_t sourceID() const { return m_source.providerID(); }
1771 
1772         int startLine() const { return m_startLineNumber; }
1773         int startStartOffset() const { return m_startStartOffset; }
1774         int startLineStartOffset() const { return m_startLineStartOffset; }
1775 
1776         void setFeatures(CodeFeatures features) { m_features = features; }
1777         CodeFeatures features() { return m_features; }
1778         InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures() { return m_innerArrowFunctionCodeFeatures; }
1779         bool doAnyInnerArrowFunctionsUseAnyFeature() { return m_innerArrowFunctionCodeFeatures != NoInnerArrowFunctionFeatures; }
1780         bool doAnyInnerArrowFunctionsUseArguments() { return m_innerArrowFunctionCodeFeatures &amp; ArgumentsInnerArrowFunctionFeature; }
1781         bool doAnyInnerArrowFunctionsUseSuperCall() { return m_innerArrowFunctionCodeFeatures &amp; SuperCallInnerArrowFunctionFeature; }
1782         bool doAnyInnerArrowFunctionsUseSuperProperty() { return m_innerArrowFunctionCodeFeatures &amp; SuperPropertyInnerArrowFunctionFeature; }
1783         bool doAnyInnerArrowFunctionsUseEval() { return m_innerArrowFunctionCodeFeatures &amp; EvalInnerArrowFunctionFeature; }
1784         bool doAnyInnerArrowFunctionsUseThis() { return m_innerArrowFunctionCodeFeatures &amp; ThisInnerArrowFunctionFeature; }
1785         bool doAnyInnerArrowFunctionsUseNewTarget() { return m_innerArrowFunctionCodeFeatures &amp; NewTargetInnerArrowFunctionFeature; }
1786 
1787         bool usesEval() const { return m_features &amp; EvalFeature; }
1788         bool usesArguments() const { return (m_features &amp; ArgumentsFeature) &amp;&amp; !(m_features &amp; ShadowsArgumentsFeature); }
1789         bool usesArrowFunction() const { return m_features &amp; ArrowFunctionFeature; }
1790         bool isStrictMode() const { return m_features &amp; StrictModeFeature; }
1791         void setUsesArguments() { m_features |= ArgumentsFeature; }
1792         bool usesThis() const { return m_features &amp; ThisFeature; }
1793         bool usesSuperCall() const { return m_features &amp; SuperCallFeature; }
1794         bool usesSuperProperty() const { return m_features &amp; SuperPropertyFeature; }
1795         bool usesNewTarget() const { return m_features &amp; NewTargetFeature; }
1796         bool needsActivation() const { return (hasCapturedVariables()) || (m_features &amp; (EvalFeature | WithFeature)); }
1797         bool hasCapturedVariables() const { return m_varDeclarations.hasCapturedVariables(); }
1798         bool captures(UniquedStringImpl* uid) { return m_varDeclarations.captures(uid); }
1799         bool captures(const Identifier&amp; ident) { return captures(ident.impl()); }
1800         bool hasSloppyModeHoistedFunction(UniquedStringImpl* uid) const { return m_sloppyModeHoistedFunctions.contains(uid); }
1801 
<a name="15" id="anc15"></a><span class="line-added">1802         bool needsNewTargetRegisterForThisScope() const</span>
<span class="line-added">1803         {</span>
<span class="line-added">1804             return usesSuperCall() || usesNewTarget();</span>
<span class="line-added">1805         }</span>
<span class="line-added">1806 </span>
1807         VariableEnvironment&amp; varDeclarations() { return m_varDeclarations; }
1808 
1809         int neededConstants()
1810         {
1811             // We may need 2 more constants than the count given by the parser,
1812             // because of the various uses of jsUndefined() and jsNull().
1813             return m_numConstants + 2;
1814         }
1815 
1816         StatementNode* singleStatement() const;
1817 
1818         bool hasCompletionValue() const override;
1819         bool hasEarlyBreakOrContinue() const override;
1820 
1821         void emitStatementsBytecode(BytecodeGenerator&amp;, RegisterID* destination);
1822 
1823         void analyzeModule(ModuleAnalyzer&amp;);
1824 
1825     protected:
1826         int m_startLineNumber;
1827         unsigned m_startStartOffset;
1828         unsigned m_startLineStartOffset;
1829 
1830     private:
1831         CodeFeatures m_features;
1832         InnerArrowFunctionCodeFeatures m_innerArrowFunctionCodeFeatures;
1833         SourceCode m_source;
1834         VariableEnvironment m_varDeclarations;
1835         UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;
1836         int m_numConstants;
1837         SourceElements* m_statements;
1838     };
1839 
1840     class ProgramNode final : public ScopeNode {
1841     public:
1842         ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1843 
1844         unsigned startColumn() const { return m_startColumn; }
1845         unsigned endColumn() const { return m_endColumn; }
1846 
1847         static const bool scopeIsFunction = false;
1848 
1849     private:
1850         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1851         unsigned m_startColumn;
1852         unsigned m_endColumn;
1853     };
1854 
1855     class EvalNode final : public ScopeNode {
1856     public:
1857         EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1858 
1859         ALWAYS_INLINE unsigned startColumn() const { return 0; }
1860         unsigned endColumn() const { return m_endColumn; }
1861 
1862         static const bool scopeIsFunction = false;
1863 
1864     private:
1865         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1866 
1867         unsigned m_endColumn;
1868     };
1869 
1870     class ModuleProgramNode final : public ScopeNode {
1871     public:
1872         ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1873 
1874         unsigned startColumn() const { return m_startColumn; }
1875         unsigned endColumn() const { return m_endColumn; }
1876 
1877         static const bool scopeIsFunction = false;
1878 
1879         ModuleScopeData&amp; moduleScopeData()
1880         {
1881             return m_moduleScopeData;
1882         }
1883 
1884     private:
1885         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1886         unsigned m_startColumn;
1887         unsigned m_endColumn;
1888         Ref&lt;ModuleScopeData&gt; m_moduleScopeData;
1889     };
1890 
1891     class ModuleNameNode final : public Node {
1892     public:
1893         ModuleNameNode(const JSTokenLocation&amp;, const Identifier&amp; moduleName);
1894 
1895         const Identifier&amp; moduleName() { return m_moduleName; }
1896 
1897     private:
1898         const Identifier&amp; m_moduleName;
1899     };
1900 
1901     class ImportSpecifierNode final : public Node {
1902     public:
1903         ImportSpecifierNode(const JSTokenLocation&amp;, const Identifier&amp; importedName, const Identifier&amp; localName);
1904 
1905         const Identifier&amp; importedName() { return m_importedName; }
1906         const Identifier&amp; localName() { return m_localName; }
1907 
1908     private:
1909         const Identifier&amp; m_importedName;
1910         const Identifier&amp; m_localName;
1911     };
1912 
1913     class ImportSpecifierListNode final : public ParserArenaDeletable {
1914         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ImportSpecifierListNode);
1915     public:
1916         typedef Vector&lt;ImportSpecifierNode*, 3&gt; Specifiers;
1917 
1918         const Specifiers&amp; specifiers() const { return m_specifiers; }
1919         void append(ImportSpecifierNode* specifier)
1920         {
1921             m_specifiers.append(specifier);
1922         }
1923 
1924     private:
1925         Specifiers m_specifiers;
1926     };
1927 
1928     class ModuleDeclarationNode : public StatementNode {
1929     public:
1930         virtual void analyzeModule(ModuleAnalyzer&amp;) = 0;
1931         bool hasCompletionValue() const override { return false; }
1932         bool isModuleDeclarationNode() const override { return true; }
1933 
1934     protected:
1935         ModuleDeclarationNode(const JSTokenLocation&amp;);
1936     };
1937 
1938     class ImportDeclarationNode final : public ModuleDeclarationNode {
1939     public:
1940         ImportDeclarationNode(const JSTokenLocation&amp;, ImportSpecifierListNode*, ModuleNameNode*);
1941 
1942         ImportSpecifierListNode* specifierList() const { return m_specifierList; }
1943         ModuleNameNode* moduleName() const { return m_moduleName; }
1944 
1945     private:
1946         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1947         void analyzeModule(ModuleAnalyzer&amp;) override;
1948 
1949         ImportSpecifierListNode* m_specifierList;
1950         ModuleNameNode* m_moduleName;
1951     };
1952 
1953     class ExportAllDeclarationNode final : public ModuleDeclarationNode {
1954     public:
1955         ExportAllDeclarationNode(const JSTokenLocation&amp;, ModuleNameNode*);
1956 
1957         ModuleNameNode* moduleName() const { return m_moduleName; }
1958 
1959     private:
1960         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1961         void analyzeModule(ModuleAnalyzer&amp;) override;
1962 
1963         ModuleNameNode* m_moduleName;
1964     };
1965 
1966     class ExportDefaultDeclarationNode final : public ModuleDeclarationNode {
1967     public:
1968         ExportDefaultDeclarationNode(const JSTokenLocation&amp;, StatementNode*, const Identifier&amp; localName);
1969 
1970         const StatementNode&amp; declaration() const { return *m_declaration; }
1971         const Identifier&amp; localName() const { return m_localName; }
1972 
1973     private:
1974         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1975         void analyzeModule(ModuleAnalyzer&amp;) override;
1976         StatementNode* m_declaration;
1977         const Identifier&amp; m_localName;
1978     };
1979 
1980     class ExportLocalDeclarationNode final : public ModuleDeclarationNode {
1981     public:
1982         ExportLocalDeclarationNode(const JSTokenLocation&amp;, StatementNode*);
1983 
1984         const StatementNode&amp; declaration() const { return *m_declaration; }
1985 
1986     private:
1987         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1988         void analyzeModule(ModuleAnalyzer&amp;) override;
1989         StatementNode* m_declaration;
1990     };
1991 
1992     class ExportSpecifierNode final : public Node {
1993     public:
1994         ExportSpecifierNode(const JSTokenLocation&amp;, const Identifier&amp; localName, const Identifier&amp; exportedName);
1995 
1996         const Identifier&amp; exportedName() { return m_exportedName; }
1997         const Identifier&amp; localName() { return m_localName; }
1998 
1999     private:
2000         const Identifier&amp; m_localName;
2001         const Identifier&amp; m_exportedName;
2002     };
2003 
2004     class ExportSpecifierListNode final : public ParserArenaDeletable {
2005         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ExportSpecifierListNode);
2006     public:
2007         typedef Vector&lt;ExportSpecifierNode*, 3&gt; Specifiers;
2008 
2009         const Specifiers&amp; specifiers() const { return m_specifiers; }
2010         void append(ExportSpecifierNode* specifier)
2011         {
2012             m_specifiers.append(specifier);
2013         }
2014 
2015     private:
2016         Specifiers m_specifiers;
2017     };
2018 
2019     class ExportNamedDeclarationNode final : public ModuleDeclarationNode {
2020     public:
2021         ExportNamedDeclarationNode(const JSTokenLocation&amp;, ExportSpecifierListNode*, ModuleNameNode*);
2022 
2023         ExportSpecifierListNode* specifierList() const { return m_specifierList; }
2024         ModuleNameNode* moduleName() const { return m_moduleName; }
2025 
2026     private:
2027         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2028         void analyzeModule(ModuleAnalyzer&amp;) override;
2029         ExportSpecifierListNode* m_specifierList;
2030         ModuleNameNode* m_moduleName { nullptr };
2031     };
2032 
2033     class FunctionMetadataNode final : public ParserArenaDeletable, public Node {
2034         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(FunctionMetadataNode);
2035     public:
2036         FunctionMetadataNode(
2037             ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2038             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2039             int functionNameStart, int parametersStart, bool isInStrictContext,
2040             ConstructorKind, SuperBinding, unsigned parameterCount,
2041             SourceParseMode, bool isArrowFunctionBodyExpression);
2042         FunctionMetadataNode(
2043             const JSTokenLocation&amp; start, const JSTokenLocation&amp; end,
2044             unsigned startColumn, unsigned endColumn, int functionKeywordStart,
2045             int functionNameStart, int parametersStart, bool isInStrictContext,
2046             ConstructorKind, SuperBinding, unsigned parameterCount,
2047             SourceParseMode, bool isArrowFunctionBodyExpression);
2048 
2049         void dump(PrintStream&amp;) const;
2050 
2051         void finishParsing(const SourceCode&amp;, const Identifier&amp;, FunctionMode);
2052 
2053         void overrideName(const Identifier&amp; ident) { m_ident = ident; }
2054         const Identifier&amp; ident() { return m_ident; }
2055         void setEcmaName(const Identifier&amp; ecmaName) { m_ecmaName = ecmaName; }
2056         const Identifier&amp; ecmaName() { return m_ident.isEmpty() ? m_ecmaName : m_ident; }
<a name="16" id="anc16"></a>

2057 
2058         FunctionMode functionMode() { return m_functionMode; }
2059 
2060         int functionNameStart() const { return m_functionNameStart; }
2061         int functionKeywordStart() const { return m_functionKeywordStart; }
2062         int parametersStart() const { return m_parametersStart; }
2063         unsigned startColumn() const { return m_startColumn; }
2064         unsigned endColumn() const { return m_endColumn; }
2065         unsigned parameterCount() const { return m_parameterCount; }
2066         SourceParseMode parseMode() const { return m_parseMode; }
2067 
2068         void setEndPosition(JSTextPosition);
2069 
2070         const SourceCode&amp; source() const { return m_source; }
2071         const SourceCode&amp; classSource() const { return m_classSource; }
2072         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2073 
2074         int startStartOffset() const { return m_startStartOffset; }
2075         bool isInStrictContext() const { return m_isInStrictContext; }
2076         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
2077         ConstructorKind constructorKind() { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
2078         bool isArrowFunctionBodyExpression() const { return m_isArrowFunctionBodyExpression; }
2079 
2080         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2081         {
2082             m_lastLine = lastLine;
2083             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2084             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2085         }
2086         unsigned lastLine() const { return m_lastLine; }
2087 
2088         bool operator==(const FunctionMetadataNode&amp;) const;
2089         bool operator!=(const FunctionMetadataNode&amp; other) const
2090         {
2091             return !(*this == other);
2092         }
2093 
2094     public:
2095         unsigned m_isInStrictContext : 1;
2096         unsigned m_superBinding : 1;
2097         unsigned m_constructorKind : 2;
2098         unsigned m_isArrowFunctionBodyExpression : 1;
2099         SourceParseMode m_parseMode;
<a name="17" id="anc17"></a><span class="line-added">2100         FunctionMode m_functionMode;</span>
2101         Identifier m_ident;
2102         Identifier m_ecmaName;
<a name="18" id="anc18"></a>

2103         unsigned m_startColumn;
2104         unsigned m_endColumn;
2105         int m_functionKeywordStart;
2106         int m_functionNameStart;
2107         int m_parametersStart;
2108         SourceCode m_source;
2109         SourceCode m_classSource;
2110         int m_startStartOffset;
2111         unsigned m_parameterCount;
2112         int m_lastLine;
2113     };
2114 
2115     class FunctionNode final : public ScopeNode {
2116     public:
2117         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2118 
2119         FunctionParameters* parameters() const { return m_parameters; }
2120 
2121         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2122 
2123         bool isFunctionNode() const override { return true; }
2124 
2125         void finishParsing(const Identifier&amp;, FunctionMode);
2126 
2127         const Identifier&amp; ident() { return m_ident; }
2128 
2129         FunctionMode functionMode() const { return m_functionMode; }
2130 
2131         unsigned startColumn() const { return m_startColumn; }
2132         unsigned endColumn() const { return m_endColumn; }
2133 
2134         static const bool scopeIsFunction = true;
2135 
2136     private:
2137         Identifier m_ident;
2138         FunctionMode m_functionMode;
2139         FunctionParameters* m_parameters;
2140         unsigned m_startColumn;
2141         unsigned m_endColumn;
2142     };
2143 
2144     class BaseFuncExprNode : public ExpressionNode {
2145     public:
2146         FunctionMetadataNode* metadata() { return m_metadata; }
2147 
2148         bool isBaseFuncExprNode() const override { return true; }
2149 
2150     protected:
2151         BaseFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2152 
2153         FunctionMetadataNode* m_metadata;
2154     };
2155 
2156 
2157     class FuncExprNode : public BaseFuncExprNode {
2158     public:
2159         FuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2160 
2161     protected:
2162         FuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2163 
2164     private:
2165         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2166 
2167         bool isFuncExprNode() const override { return true; }
2168     };
2169 
2170     class ArrowFuncExprNode final : public BaseFuncExprNode {
2171     public:
2172         ArrowFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2173 
2174     private:
2175         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2176 
2177         bool isArrowFuncExprNode() const override { return true; }
2178     };
2179 
2180     class MethodDefinitionNode final : public FuncExprNode {
2181     public:
2182         MethodDefinitionNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2183 
2184     private:
2185         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2186     };
2187 
2188     class YieldExprNode final : public ExpressionNode, public ThrowableExpressionData {
2189     public:
2190         YieldExprNode(const JSTokenLocation&amp;, ExpressionNode* argument, bool delegate);
2191 
2192         ExpressionNode* argument() const { return m_argument; }
2193         bool delegate() const { return m_delegate; }
2194 
2195     private:
2196         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2197 
2198         ExpressionNode* m_argument;
2199         bool m_delegate;
2200     };
2201 
2202     class AwaitExprNode final : public ExpressionNode, public ThrowableExpressionData {
2203     public:
2204         AwaitExprNode(const JSTokenLocation&amp;, ExpressionNode* argument);
2205 
2206         ExpressionNode* argument() const { return m_argument; }
2207 
2208     private:
2209         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2210 
2211         ExpressionNode* m_argument;
2212     };
2213 
2214     class ClassExprNode final : public ExpressionNode, public VariableEnvironmentNode {
2215         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ClassExprNode);
2216     public:
2217         ClassExprNode(const JSTokenLocation&amp;, const Identifier&amp;, const SourceCode&amp; classSource,
2218             VariableEnvironment&amp; classEnvironment, ExpressionNode* constructorExpresssion,
2219             ExpressionNode* parentClass, PropertyListNode* classElements);
2220 
2221         const Identifier&amp; name() { return m_name; }
2222         const Identifier&amp; ecmaName() { return m_ecmaName ? *m_ecmaName : m_name; }
2223         void setEcmaName(const Identifier&amp; name) { m_ecmaName = m_name.isNull() ? &amp;name : &amp;m_name; }
2224 
2225         bool hasStaticProperty(const Identifier&amp; propName) { return m_classElements ? m_classElements-&gt;hasStaticallyNamedProperty(propName) : false; }
2226 
2227     private:
2228         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2229 
2230         bool isClassExprNode() const override { return true; }
2231 
2232         SourceCode m_classSource;
2233         const Identifier&amp; m_name;
2234         const Identifier* m_ecmaName;
2235         ExpressionNode* m_constructorExpression;
2236         ExpressionNode* m_classHeritage;
2237         PropertyListNode* m_classElements;
2238     };
2239 
2240     class DestructuringPatternNode : public ParserArenaFreeable {
2241     public:
2242         virtual ~DestructuringPatternNode() { }
2243         virtual void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const = 0;
2244         virtual void bindValue(BytecodeGenerator&amp;, RegisterID* source) const = 0;
2245         virtual void toString(StringBuilder&amp;) const = 0;
2246 
2247         virtual bool isBindingNode() const { return false; }
2248         virtual bool isAssignmentElementNode() const { return false; }
2249         virtual bool isRestParameter() const { return false; }
2250         virtual RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID*, ExpressionNode*) { return 0; }
2251 
2252     protected:
2253         DestructuringPatternNode();
2254     };
2255 
2256     class ArrayPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2257         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ArrayPatternNode);
2258     public:
2259         ArrayPatternNode();
2260         enum class BindingType : uint8_t {
2261             Elision,
2262             Element,
2263             RestElement
2264         };
2265 
2266         void appendIndex(BindingType bindingType, const JSTokenLocation&amp;, DestructuringPatternNode* node, ExpressionNode* defaultValue)
2267         {
2268             m_targetPatterns.append({ bindingType, node, defaultValue });
2269         }
2270 
2271     private:
2272         struct Entry {
2273             BindingType bindingType;
2274             DestructuringPatternNode* pattern;
2275             ExpressionNode* defaultValue;
2276         };
2277         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2278         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2279         RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID* dst, ExpressionNode*) override;
2280         void toString(StringBuilder&amp;) const override;
2281 
2282         Vector&lt;Entry&gt; m_targetPatterns;
2283     };
2284 
2285     class ObjectPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2286         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ObjectPatternNode);
2287     public:
2288         ObjectPatternNode();
2289         enum class BindingType : uint8_t {
2290             Element,
2291             RestElement
2292         };
2293         void appendEntry(const JSTokenLocation&amp;, const Identifier&amp; identifier, bool wasString, DestructuringPatternNode* pattern, ExpressionNode* defaultValue, BindingType bindingType)
2294         {
2295             m_targetPatterns.append(Entry{ identifier, nullptr, wasString, pattern, defaultValue, bindingType });
2296         }
2297 
2298         void appendEntry(VM&amp; vm, const JSTokenLocation&amp;, ExpressionNode* propertyExpression, DestructuringPatternNode* pattern, ExpressionNode* defaultValue, BindingType bindingType)
2299         {
2300             m_targetPatterns.append(Entry{ vm.propertyNames-&gt;nullIdentifier, propertyExpression, false, pattern, defaultValue, bindingType });
2301         }
2302 
2303         void setContainsRestElement(bool containsRestElement)
2304         {
2305             m_containsRestElement = containsRestElement;
2306         }
2307 
2308         void setContainsComputedProperty(bool containsComputedProperty)
2309         {
2310             m_containsComputedProperty = containsComputedProperty;
2311         }
2312 
2313     private:
2314         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2315         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2316         void toString(StringBuilder&amp;) const override;
2317         struct Entry {
2318             const Identifier&amp; propertyName;
2319             ExpressionNode* propertyExpression;
2320             bool wasString;
2321             DestructuringPatternNode* pattern;
2322             ExpressionNode* defaultValue;
2323             BindingType bindingType;
2324         };
2325         bool m_containsRestElement { false };
2326         bool m_containsComputedProperty { false };
2327         Vector&lt;Entry&gt; m_targetPatterns;
2328     };
2329 
2330     class BindingNode final: public DestructuringPatternNode {
2331     public:
2332         BindingNode(const Identifier&amp; boundProperty, const JSTextPosition&amp; start, const JSTextPosition&amp; end, AssignmentContext);
2333         const Identifier&amp; boundProperty() const { return m_boundProperty; }
2334 
2335         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
2336         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
2337 
2338     private:
2339         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2340         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2341         void toString(StringBuilder&amp;) const override;
2342 
2343         bool isBindingNode() const override { return true; }
2344 
2345         JSTextPosition m_divotStart;
2346         JSTextPosition m_divotEnd;
2347         const Identifier&amp; m_boundProperty;
2348         AssignmentContext m_bindingContext;
2349     };
2350 
2351     class RestParameterNode final : public DestructuringPatternNode {
2352     public:
2353         RestParameterNode(DestructuringPatternNode*, unsigned numParametersToSkip);
2354 
2355         bool isRestParameter() const override { return true; }
2356 
2357         void emit(BytecodeGenerator&amp;);
2358 
2359     private:
2360         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2361         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2362         void toString(StringBuilder&amp;) const override;
2363 
2364         DestructuringPatternNode* m_pattern;
2365         unsigned m_numParametersToSkip;
2366     };
2367 
2368     class AssignmentElementNode final : public DestructuringPatternNode {
2369     public:
2370         AssignmentElementNode(ExpressionNode* assignmentTarget, const JSTextPosition&amp; start, const JSTextPosition&amp; end);
2371         const ExpressionNode* assignmentTarget() { return m_assignmentTarget; }
2372 
2373         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
2374         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
2375 
2376     private:
2377         void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const override;
2378         void bindValue(BytecodeGenerator&amp;, RegisterID*) const override;
2379         void toString(StringBuilder&amp;) const override;
2380 
2381         bool isAssignmentElementNode() const override { return true; }
2382 
2383         JSTextPosition m_divotStart;
2384         JSTextPosition m_divotEnd;
2385         ExpressionNode* m_assignmentTarget;
2386     };
2387 
2388     class DestructuringAssignmentNode final : public ExpressionNode {
2389     public:
2390         DestructuringAssignmentNode(const JSTokenLocation&amp;, DestructuringPatternNode*, ExpressionNode*);
2391         DestructuringPatternNode* bindings() { return m_bindings; }
2392 
2393     private:
2394         bool isAssignmentLocation() const override { return true; }
2395         bool isDestructuringNode() const override { return true; }
2396         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2397 
2398         DestructuringPatternNode* m_bindings;
2399         ExpressionNode* m_initializer;
2400     };
2401 
2402     class FunctionParameters final : public ParserArenaDeletable {
2403         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(FunctionParameters);
2404     public:
2405         FunctionParameters();
2406         ALWAYS_INLINE unsigned size() const { return m_patterns.size(); }
2407         ALWAYS_INLINE std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt; at(unsigned index) { return m_patterns[index]; }
2408         ALWAYS_INLINE void append(DestructuringPatternNode* pattern, ExpressionNode* defaultValue)
2409         {
2410             ASSERT(pattern);
2411 
2412             // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
2413             // This implements IsSimpleParameterList in the Ecma 2015 spec.
2414             // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
2415             // IsSimpleParameterList is false if the argument list contains any default parameter values,
2416             // a rest parameter, or any destructuring patterns.
2417             // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
2418 
2419             bool hasDefaultParameterValue = defaultValue;
2420             bool isSimpleParameter = !hasDefaultParameterValue &amp;&amp; pattern-&gt;isBindingNode();
2421             m_isSimpleParameterList &amp;= isSimpleParameter;
2422 
2423             m_patterns.append(std::make_pair(pattern, defaultValue));
2424         }
2425         ALWAYS_INLINE bool isSimpleParameterList() const { return m_isSimpleParameterList; }
2426 
2427     private:
2428 
2429         Vector&lt;std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt;, 3&gt; m_patterns;
2430         bool m_isSimpleParameterList { true };
2431     };
2432 
2433     class FuncDeclNode final : public StatementNode {
2434     public:
2435         FuncDeclNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;);
2436 
2437         bool hasCompletionValue() const override { return false; }
2438         bool isFuncDeclNode() const override { return true; }
2439         FunctionMetadataNode* metadata() { return m_metadata; }
2440 
2441     private:
2442         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2443 
2444         FunctionMetadataNode* m_metadata;
2445     };
2446 
2447     class ClassDeclNode final : public StatementNode {
2448     public:
2449         ClassDeclNode(const JSTokenLocation&amp;, ExpressionNode* classExpression);
2450 
2451     private:
2452         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2453 
2454         bool hasCompletionValue() const override { return false; }
2455 
2456         ExpressionNode* m_classDeclaration;
2457     };
2458 
2459     class CaseClauseNode final : public ParserArenaFreeable {
2460     public:
2461         CaseClauseNode(ExpressionNode*, SourceElements* = 0);
2462 
2463         ExpressionNode* expr() const { return m_expr; }
2464 
2465         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);
2466         void setStartOffset(int offset) { m_startOffset = offset; }
2467 
2468     private:
2469         ExpressionNode* m_expr;
2470         SourceElements* m_statements;
2471         int m_startOffset;
2472     };
2473 
2474     class ClauseListNode final : public ParserArenaFreeable {
2475     public:
2476         ClauseListNode(CaseClauseNode*);
2477         ClauseListNode(ClauseListNode*, CaseClauseNode*);
2478 
2479         CaseClauseNode* getClause() const { return m_clause; }
2480         ClauseListNode* getNext() const { return m_next; }
2481 
2482     private:
2483         CaseClauseNode* m_clause;
2484         ClauseListNode* m_next { nullptr };
2485     };
2486 
2487     class CaseBlockNode final : public ParserArenaFreeable {
2488     public:
2489         CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);
2490 
2491         void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
2492 
2493     private:
2494         SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
2495         static const size_t s_tableSwitchMinimum = 3;
2496         ClauseListNode* m_list1;
2497         CaseClauseNode* m_defaultClause;
2498         ClauseListNode* m_list2;
2499     };
2500 
2501     class SwitchNode final : public StatementNode, public VariableEnvironmentNode {
2502         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(SwitchNode);
2503     public:
2504         SwitchNode(const JSTokenLocation&amp;, ExpressionNode*, CaseBlockNode*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
2505 
2506     private:
2507         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2508 
2509         ExpressionNode* m_expr;
2510         CaseBlockNode* m_block;
2511     };
2512 
2513     struct ElementList {
2514         ElementNode* head;
2515         ElementNode* tail;
2516     };
2517 
2518     struct PropertyList {
2519         PropertyListNode* head;
2520         PropertyListNode* tail;
2521     };
2522 
2523     struct ArgumentList {
2524         ArgumentListNode* head;
2525         ArgumentListNode* tail;
2526     };
2527 
2528     struct ClauseList {
2529         ClauseListNode* head;
2530         ClauseListNode* tail;
2531     };
2532 
2533 } // namespace JSC
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>