<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebKitLegacy/java/WebCoreSupport/FrameLoaderClientJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 #include &quot;FrameLoaderClientJava.h&quot;
  28 #include &quot;FrameNetworkingContextJava.h&quot;
  29 #include &quot;WebPage.h&quot;
  30 
  31 #include &lt;JavaScriptCore/APICast.h&gt;
  32 #include &lt;JavaScriptCore/JavaScript.h&gt;
  33 #include &lt;WebCore/AuthenticationChallenge.h&gt;
  34 #include &lt;WebCore/Chrome.h&gt;
  35 #include &lt;WebCore/DNS.h&gt;
  36 #include &lt;WebCore/DocumentLoader.h&gt;
  37 #include &lt;WebCore/FormState.h&gt;
  38 #include &lt;WebCore/Frame.h&gt;
  39 #include &lt;WebCore/FrameLoadRequest.h&gt;
  40 #include &lt;WebCore/FrameTree.h&gt;
  41 #include &lt;WebCore/FrameView.h&gt;
  42 #include &lt;WebCore/HTMLFormElement.h&gt;
  43 #include &lt;WebCore/HistoryItem.h&gt;
  44 #include &lt;WebCore/MIMETypeRegistry.h&gt;
  45 #include &lt;WebCore/NotImplemented.h&gt;
  46 #include &lt;WebCore/Page.h&gt;
  47 #include &lt;WebCore/PluginWidgetJava.h&gt;
  48 #include &lt;WebCore/PolicyChecker.h&gt;
  49 #include &lt;WebCore/ProgressTracker.h&gt;
  50 #include &lt;WebCore/ScriptController.h&gt;
  51 #include &lt;WebCore/Settings.h&gt;
  52 #include &lt;WebCore/WindowFeatures.h&gt;
  53 
  54 #include &quot;com_sun_webkit_LoadListenerClient.h&quot;
  55 
  56 namespace WebCore {
  57 
  58 namespace FrameLoaderClientJavaInternal {
  59 
  60 static JGClass webPageClass;
  61 static JGClass networkContextClass;
  62 
  63 static jmethodID setRequestURLMID;
  64 static jmethodID removeRequestURLMID;
  65 
  66 static jmethodID fireLoadEventMID;
  67 static jmethodID fireResourceLoadEventMID;
  68 static jmethodID canHandleURLMID;
  69 
  70 static jmethodID permitNavigateActionMID;
  71 static jmethodID permitRedirectActionMID;
  72 static jmethodID permitAcceptResourceActionMID;
  73 static jmethodID permitSubmitDataActionMID;
  74 static jmethodID permitEnableScriptsActionMID;
  75 static jmethodID permitNewWindowActionMID;
  76 
  77 static jmethodID didClearWindowObjectMID;
  78 
  79 static jmethodID frameCreatedMID;
  80 static jmethodID frameDestroyedMID;
  81 
  82 static void initRefs(JNIEnv* env)
  83 {
  84     if (!webPageClass) {
  85         webPageClass = JLClass(env-&gt;FindClass(
  86             &quot;com/sun/webkit/WebPage&quot;));
  87         ASSERT(webPageClass);
  88 
  89         setRequestURLMID = env-&gt;GetMethodID(webPageClass, &quot;fwkSetRequestURL&quot;, &quot;(JILjava/lang/String;)V&quot;);
  90         ASSERT(setRequestURLMID);
  91         removeRequestURLMID = env-&gt;GetMethodID(webPageClass, &quot;fwkRemoveRequestURL&quot;, &quot;(JI)V&quot;);
  92         ASSERT(removeRequestURLMID);
  93 
  94         fireLoadEventMID = env-&gt;GetMethodID(webPageClass, &quot;fwkFireLoadEvent&quot;,
  95                                             &quot;(JILjava/lang/String;Ljava/lang/String;DI)V&quot;);
  96         ASSERT(fireLoadEventMID);
  97         fireResourceLoadEventMID = env-&gt;GetMethodID(webPageClass, &quot;fwkFireResourceLoadEvent&quot;,
  98                                                     &quot;(JIILjava/lang/String;DI)V&quot;);
  99         ASSERT(fireResourceLoadEventMID);
 100 
 101         permitNavigateActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitNavigateAction&quot;,
 102                                                    &quot;(JLjava/lang/String;)Z&quot;);
 103         ASSERT(permitNavigateActionMID);
 104 
 105         permitRedirectActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitRedirectAction&quot;,
 106                                                    &quot;(JLjava/lang/String;)Z&quot;);
 107         ASSERT(permitRedirectActionMID);
 108 
 109         permitAcceptResourceActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitAcceptResourceAction&quot;,
 110                                                          &quot;(JLjava/lang/String;)Z&quot;);
 111         ASSERT(permitAcceptResourceActionMID);
 112 
 113         permitSubmitDataActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitSubmitDataAction&quot;,
 114                                                      &quot;(JLjava/lang/String;Ljava/lang/String;Z)Z&quot;);
 115         ASSERT(permitSubmitDataActionMID);
 116 
 117         permitEnableScriptsActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitEnableScriptsAction&quot;,
 118                                                         &quot;(JLjava/lang/String;)Z&quot;);
 119         ASSERT(permitEnableScriptsActionMID);
 120 
 121         permitNewWindowActionMID = env-&gt;GetMethodID(webPageClass, &quot;fwkPermitNewWindowAction&quot;,
 122                                                     &quot;(JLjava/lang/String;)Z&quot;);
 123         ASSERT(permitNewWindowActionMID);
 124 
 125         didClearWindowObjectMID = env-&gt;GetMethodID(webPageClass, &quot;fwkDidClearWindowObject&quot;, &quot;(JJ)V&quot;);
 126         ASSERT(didClearWindowObjectMID);
 127 
 128         frameCreatedMID = env-&gt;GetMethodID(webPageClass, &quot;fwkFrameCreated&quot;, &quot;(J)V&quot;);
 129         ASSERT(frameCreatedMID);
 130 
 131         frameDestroyedMID = env-&gt;GetMethodID(webPageClass, &quot;fwkFrameDestroyed&quot;, &quot;(J)V&quot;);
 132         ASSERT(frameDestroyedMID);
 133     }
 134     if (!networkContextClass) {
 135         networkContextClass = JLClass(env-&gt;FindClass(&quot;com/sun/webkit/network/NetworkContext&quot;));
 136         ASSERT(networkContextClass);
 137 
 138         canHandleURLMID = env-&gt;GetStaticMethodID(networkContextClass, &quot;canHandleURL&quot;, &quot;(Ljava/lang/String;)Z&quot;);
 139         ASSERT(canHandleURLMID);
 140     }
 141 }
 142 // This was copied from file &quot;WebKit/Source/WebKit/mac/Misc/WebKitErrors.h&quot;.
 143 enum {
 144     WebKitErrorCannotShowMIMEType =                             100,
 145     WebKitErrorCannotShowURL =                                  101,
 146     WebKitErrorFrameLoadInterruptedByPolicyChange =             102,
 147     WebKitErrorCannotUseRestrictedPort =                        103,
 148     WebKitErrorCannotFindPlugIn =                               200,
 149     WebKitErrorCannotLoadPlugIn =                               201,
 150     WebKitErrorJavaUnavailable =                                202,
 151     WebKitErrorPluginWillHandleLoad =                           203
 152 };
 153 
 154 enum ContentDispositionType {
 155     ContentDispositionNone,
 156     ContentDispositionInline,
 157     ContentDispositionAttachment,
 158     ContentDispositionOther
 159 };
 160 
 161 // Below function was removed after https://bugs.webkit.org/show_bug.cgi?id=163095
 162 // from HTTPParser.h.
 163 ContentDispositionType contentDispositionType(const String&amp; contentDisposition)
 164 {
 165     if (contentDisposition.isEmpty())
 166         return ContentDispositionNone;
 167 
 168     Vector&lt;String&gt; parameters = contentDisposition.split(&#39;;&#39;);
 169 
 170     String dispositionType = parameters[0];
 171     dispositionType.stripWhiteSpace();
 172 
 173     if (equalLettersIgnoringASCIICase(dispositionType, &quot;inline&quot;))
 174         return ContentDispositionInline;
 175 
 176     // Some broken sites just send bogus headers like
 177     //
 178     //   Content-Disposition: ; filename=&quot;file&quot;
 179     //   Content-Disposition: filename=&quot;file&quot;
 180     //   Content-Disposition: name=&quot;file&quot;
 181     //
 182     // without a disposition token... screen those out.
 183     if (!isValidHTTPToken(dispositionType))
 184         return ContentDispositionNone;
 185 
 186     // We have a content-disposition of &quot;attachment&quot; or unknown.
 187     // RFC 2183, section 2.8 says that an unknown disposition
 188     // value should be treated as &quot;attachment&quot;
 189     return ContentDispositionAttachment;
 190 }
 191 } // namespace
 192 
 193 FrameLoaderClientJava::FrameLoaderClientJava(const JLObject &amp;webPage)
 194     : m_page(nullptr)
 195     , m_frame(nullptr)
 196     , m_isPageRedirected(false)
 197     , m_hasRepresentation(false)
 198     , m_webPage(webPage)
 199 {
 200 }
 201 
 202 void FrameLoaderClientJava::dispatchDidNavigateWithinPage()
 203 {
 204     postLoadEvent(frame(),
 205                   com_sun_webkit_LoadListenerClient_PAGE_REPLACED,
 206                   frame()-&gt;document()-&gt;url(),
 207                   frame()-&gt;loader().documentLoader()-&gt;responseMIMEType(),
 208                   1.0 /* progress */);
 209 }
 210 
 211 void FrameLoaderClientJava::frameLoaderDestroyed()
 212 {
 213     using namespace FrameLoaderClientJavaInternal;
 214     WC_GETJAVAENV_CHKRET(env);
 215     initRefs(env);
 216 
 217     ASSERT(m_webPage);
 218     ASSERT(m_frame);
 219     env-&gt;CallVoidMethod(m_webPage, frameDestroyedMID, ptr_to_jlong(m_frame));
 220     WTF::CheckAndClearException(env);
 221 
 222     m_page = 0;
 223     m_frame = 0;
 224 
 225     delete this;
 226 }
 227 
 228 Page* FrameLoaderClientJava::page()
 229 {
 230     if (!m_page) {
 231         m_page = WebPage::pageFromJObject(m_webPage);
 232         ASSERT(m_page);
 233     }
 234     return m_page;
 235 }
 236 
 237 Frame* FrameLoaderClientJava::frame()
 238 {
 239     return m_frame;
 240 }
 241 
 242 void FrameLoaderClientJava::setFrame(Frame* frame)
 243 {
 244     ASSERT(frame);
 245     m_frame = frame;
 246 }
 247 
 248 void FrameLoaderClientJava::setRequestURL(Frame* f, int identifier, String url)
 249 {
 250     using namespace FrameLoaderClientJavaInternal;
 251     JNIEnv* env = WTF::GetJavaEnv();
 252     initRefs(env);
 253 
 254     JLString urlJavaString(url.toJavaString(env));
 255     env-&gt;CallVoidMethod(m_webPage, setRequestURLMID, ptr_to_jlong(f), identifier, (jstring)urlJavaString);
 256     WTF::CheckAndClearException(env);
 257 }
 258 
 259 void FrameLoaderClientJava::removeRequestURL(Frame* f, int identifier)
 260 {
 261     using namespace FrameLoaderClientJavaInternal;
 262     JNIEnv* env = WTF::GetJavaEnv();
 263     initRefs(env);
 264 
 265     env-&gt;CallVoidMethod(m_webPage, removeRequestURLMID, ptr_to_jlong(f), identifier);
 266     WTF::CheckAndClearException(env);
 267 }
 268 
 269 void FrameLoaderClientJava::postLoadEvent(Frame* f, int state,
 270                                           String url, String contentType,
 271                                           double progress, int errorCode)
 272 {
 273     using namespace FrameLoaderClientJavaInternal;
 274     JNIEnv* env = WTF::GetJavaEnv();
 275     initRefs(env);
 276 
 277     JLString urlJavaString(url.toJavaString(env));
 278     JLString contentTypeJavaString(contentType.toJavaString(env));
 279 
 280     // First, notify SharedBufferManager, so users can get the full source
 281     // in CONTENT_RECEIVED handler
 282     if (state == com_sun_webkit_LoadListenerClient_PAGE_STARTED ||
 283         state == com_sun_webkit_LoadListenerClient_PROGRESS_CHANGED ||
 284         state == com_sun_webkit_LoadListenerClient_CONTENT_RECEIVED)
 285     {
 286         DocumentLoader* dl = f-&gt;loader().activeDocumentLoader();
 287         if (dl &amp;&amp; dl-&gt;mainResourceData()) {
 288             dl-&gt;mainResourceData()-&gt;size(); // TODO-java: recheck
 289         }
 290     }
 291 
 292     // Second, send a load event
 293     env-&gt;CallVoidMethod(m_webPage, fireLoadEventMID,
 294                         ptr_to_jlong(f), state, (jstring)urlJavaString,
 295                         (jstring)contentTypeJavaString, progress, errorCode);
 296     WTF::CheckAndClearException(env);
 297 }
 298 
 299 void FrameLoaderClientJava::postResourceLoadEvent(Frame* f, int state,
 300                                                   int id, String contentType,
 301                                                   double progress, int errorCode)
 302 {
 303     using namespace FrameLoaderClientJavaInternal;
 304     JNIEnv* env = WTF::GetJavaEnv();
 305     initRefs(env);
 306 
 307     JLString contentTypeJavaString(contentType.toJavaString(env));
 308     // notification for resource event listeners
 309     env-&gt;CallVoidMethod(m_webPage, fireResourceLoadEventMID,
 310                         ptr_to_jlong(f), state, id,
 311                         (jstring)contentTypeJavaString, progress, errorCode);
 312     WTF::CheckAndClearException(env);
 313 }
 314 
 315 String FrameLoaderClientJava::userAgent(const URL&amp;)
 316 {
 317     return page()-&gt;settings().userAgent();
 318 }
 319 
 320 void FrameLoaderClientJava::savePlatformDataToCachedFrame(CachedFrame*)
 321 {
 322     notImplemented();
 323 }
 324 
 325 void FrameLoaderClientJava::transitionToCommittedFromCachedFrame(CachedFrame*)
 326 {
 327     notImplemented();
 328 }
 329 
 330 void FrameLoaderClientJava::transitionToCommittedForNewPage()
 331 {
 332     FloatRect pageRect = frame()-&gt;page()-&gt;chrome().pageRect();
 333     Color bkColor(Color::white);
 334     Optional&lt;Color&gt; backgroundColor;
 335     FrameView* fv = frame()-&gt;view();
 336     if (fv) {
 337         backgroundColor = fv-&gt;baseBackgroundColor();
 338     }
 339     frame()-&gt;createView(IntRect(pageRect).size(), backgroundColor, /* fixedLayoutSize */ { }, /* fixedVisibleContentRect */ { });
 340 }
 341 
 342 WTF::Ref&lt;WebCore::DocumentLoader&gt; FrameLoaderClientJava::createDocumentLoader(const WebCore::ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 343 {
 344     return DocumentLoader::create(request, substituteData);
 345 }
 346 
 347 void FrameLoaderClientJava::dispatchWillSubmitForm(FormState&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; function)
 348 {
 349     // FIXME: This is surely too simple
 350     if (!frame() || !function) {
 351         return;
 352     }
 353     function();
 354 }
 355 
 356 void FrameLoaderClientJava::committedLoad(DocumentLoader* loader, const char* data, int length)
 357 {
 358     //uta: for m_pluginWidget we need to do something different
 359     loader-&gt;commitData(data, length);
 360 }
 361 
 362 void FrameLoaderClientJava::dispatchDecidePolicyForResponse(const ResourceResponse&amp; response, const ResourceRequest&amp;, PolicyCheckIdentifier identifier, FramePolicyFunction&amp;&amp; policyFunction)
 363 {
 364     using namespace FrameLoaderClientJavaInternal;
 365     PolicyAction action;
 366 
 367     int statusCode = response.httpStatusCode();
 368     if (statusCode == 204 || statusCode == 205) {
 369         // The server does not want us to replace the page contents.
 370         action = PolicyAction::Ignore;
 371     } else if (contentDispositionType(response.httpHeaderField(HTTPHeaderName::ContentDisposition)) == ContentDispositionAttachment) {
 372         // The server wants us to download instead of replacing the page contents.
 373         // Downloading is handled by the embedder, but we still get the initial
 374         // response so that we can ignore it and clean up properly.
 375         action = PolicyAction::Ignore;
 376     } else if (!canShowMIMEType(response.mimeType())) {
 377         // Make sure that we can actually handle this type internally.
 378         action = PolicyAction::Ignore;
 379     } else {
 380         // OK, we will render this page.
 381         action = PolicyAction::Use;
 382     }
 383 
 384     // NOTE: PolicyChangeError will be generated when action is not PolicyUse.
 385     policyFunction(action, identifier);
 386 }
 387 
 388 void FrameLoaderClientJava::dispatchDidReceiveResponse(DocumentLoader*, unsigned long identifier, const ResourceResponse&amp; response)
 389 {
 390     m_response = response;
 391 
 392     if (identifier == m_mainResourceRequestID) {
 393         double progress = page()-&gt;progress().estimatedProgress();
 394         postLoadEvent(frame(),
 395                       com_sun_webkit_LoadListenerClient_CONTENTTYPE_RECEIVED,
 396                       response.url().string(),
 397                       response.mimeType(),
 398                       progress);
 399     }
 400 }
 401 
 402 void FrameLoaderClientJava::dispatchDecidePolicyForNewWindowAction(const NavigationAction&amp;,
 403                                                                    const ResourceRequest&amp; req,
 404                                                                    FormState*,
 405                                                                    const String&amp;,
 406                                                                    PolicyCheckIdentifier identifier,
 407                                                                    FramePolicyFunction&amp;&amp; policyFunction)
 408 {
 409     using namespace FrameLoaderClientJavaInternal;
 410     JNIEnv* env = WTF::GetJavaEnv();
 411     initRefs(env);
 412 
 413     ASSERT(frame() &amp;&amp; policyFunction);
 414     if (!frame() || !policyFunction) {
 415         return;
 416     }
 417 
 418     JLString urlString(req.url().string().toJavaString(env));
 419     bool permit = jbool_to_bool(env-&gt;CallBooleanMethod(m_webPage, permitNewWindowActionMID,
 420                                                        ptr_to_jlong(frame()), (jstring)urlString));
 421     WTF::CheckAndClearException(env);
 422 
 423     // FIXME: I think Qt version marshals this to another thread so when we
 424     // have multi-threaded download, we might need to do the same
 425     policyFunction(permit ? PolicyAction::Use : PolicyAction::Ignore, identifier);
 426 }
 427 
 428 void FrameLoaderClientJava::dispatchDecidePolicyForNavigationAction(const NavigationAction&amp; action,
 429                                                                     const ResourceRequest&amp; req,
 430                                                                     const ResourceResponse&amp; /*didReceiveRedirectResponse*/,
 431                                                                     FormState*,
 432                                                                     PolicyDecisionMode,
 433                                                                     PolicyCheckIdentifier identifier,
 434                                                                     FramePolicyFunction&amp;&amp; policyFunction)
 435 {
 436     using namespace FrameLoaderClientJavaInternal;
 437     JNIEnv* env = WTF::GetJavaEnv();
 438     initRefs(env);
 439 
 440     ASSERT(frame() &amp;&amp; policyFunction);
 441     if (!frame() || !policyFunction) {
 442         return;
 443     }
 444 
 445     bool permit = true;
 446 
 447     JLString urlJavaString(req.url().string().toJavaString(env));
 448 
 449     // 1. Submitting/resubmitting data.
 450     if (action.type() == NavigationType::FormSubmitted ||
 451         action.type() == NavigationType::FormResubmitted)
 452     {
 453         JLString httpMethodString(req.httpMethod().toJavaString(env));
 454         permit = env-&gt;CallBooleanMethod(m_webPage, permitSubmitDataActionMID,
 455                                         ptr_to_jlong(frame()), (jstring)urlJavaString,
 456                                         (jstring)httpMethodString,
 457                                         bool_to_jbool(action.type() == NavigationType::FormSubmitted));
 458         WTF::CheckAndClearException(env);
 459     // 2. Redirecting page.
 460     } else if (m_isPageRedirected) {
 461         permit = env-&gt;CallBooleanMethod(m_webPage, permitRedirectActionMID,
 462                                         ptr_to_jlong(frame()), (jstring)urlJavaString);
 463         WTF::CheckAndClearException(env);
 464         m_isPageRedirected = false;
 465     // 3. Loading document.
 466     } else {
 467         permit = env-&gt;CallBooleanMethod(m_webPage, permitNavigateActionMID,
 468                                         ptr_to_jlong(frame()), (jstring)urlJavaString);
 469         WTF::CheckAndClearException(env);
 470     }
 471 
 472     policyFunction(permit ? PolicyAction::Use : PolicyAction::Ignore, identifier);
 473 }
 474 
 475 RefPtr&lt;Widget&gt; FrameLoaderClientJava::createPlugin(const IntSize&amp; intSize, HTMLPlugInElement&amp; element, const URL&amp; url,
 476                                             const Vector&lt;String&gt;&amp; paramNames, const Vector&lt;String&gt;&amp; paramValues,
 477                                             const String&amp; mimeType, bool)
 478 {
 479     return adoptRef(new PluginWidgetJava(
 480         m_webPage,
 481         &amp;element,
 482         intSize,
 483         url.string(),
 484         mimeType,
 485         paramNames,
 486         paramValues));
 487 }
 488 
 489 RefPtr&lt;Frame&gt; FrameLoaderClientJava::createFrame(const URL&amp; url, const String&amp; name, HTMLFrameOwnerElement&amp; ownerElement,
 490                                         const String&amp; referrer)
 491 {
 492     using namespace FrameLoaderClientJavaInternal;
 493     JNIEnv* env = WTF::GetJavaEnv();
 494     initRefs(env);
 495 
 496     FrameLoaderClientJava* frameLoaderClient = new FrameLoaderClientJava(m_webPage);
 497     RefPtr&lt;Frame&gt; childFrame(Frame::create(page(), &amp;ownerElement, frameLoaderClient));
 498     frameLoaderClient-&gt;setFrame(childFrame.get());
 499 
 500     childFrame-&gt;tree().setName(name);
 501     m_frame-&gt;tree().appendChild(*childFrame);
 502 
 503     childFrame-&gt;init();
 504 
 505     // gtk: The creation of the frame may have run arbitrary JS that removed it from the page already.
 506     if (!childFrame-&gt;page()) {
 507         return 0;
 508     }
 509 
 510     m_frame-&gt;loader().loadURLIntoChildFrame(url, referrer, childFrame.get());
 511 
 512     // gtk: The frame&#39;s onload handler may have removed it from the document.
 513     if (!childFrame-&gt;tree().parent()) {
 514         return 0;
 515     }
 516 
 517     env-&gt;CallVoidMethod(m_webPage, frameCreatedMID, ptr_to_jlong(childFrame.get()));
 518     WTF::CheckAndClearException(env);
 519 
 520     return childFrame;
 521 }
 522 
 523 void FrameLoaderClientJava::redirectDataToPlugin(Widget&amp;)
 524 {
 525     /*
 526     ASSERT(!m_pluginWidget);
 527     m_pluginWidget = static_cast&lt;PluginWidgetJava*&gt;(pluginWidget);
 528     */
 529     notImplemented();
 530 }
 531 
 532 RefPtr&lt;Widget&gt; FrameLoaderClientJava::createJavaAppletWidget(const IntSize&amp;, HTMLAppletElement&amp;, const URL&amp;,
 533                                                       const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;)
 534 {
 535     notImplemented();
 536     return nullptr;
 537 }
 538 
 539 ObjectContentType FrameLoaderClientJava::objectContentType(const URL&amp; url, const String&amp; mimeType)
 540 {
 541     //copied from FrameLoaderClientEfl.cpp
 542 
 543     // FIXME: once plugin support is enabled, this method needs to correctly handle the &#39;shouldPreferPlugInsForImages&#39; flag. See
 544     // WebCore::FrameLoader::defaultObjectContentType() for an example.
 545 
 546     if (url.isEmpty() &amp;&amp; mimeType.isEmpty())
 547         return ObjectContentType::None;
 548 
 549     // We don&#39;t use MIMETypeRegistry::getMIMETypeForPath() because it returns &quot;application/octet-stream&quot; upon failure
 550     String type = mimeType;
 551     if (type.isEmpty())
 552         type = MIMETypeRegistry::getMIMETypeForExtension(url.path().substring(url.path().reverseFind(&#39;.&#39;) + 1));
 553 
 554     if (type.isEmpty())
 555         return ObjectContentType::Frame;
 556 
 557     if (MIMETypeRegistry::isSupportedImageMIMEType(type))
 558         return ObjectContentType::Image;
 559 
 560 #if 0 // PluginDatabase is disabled until we have Plugin system done.
 561     if (PluginDatabase::installedPlugins()-&gt;isMIMETypeRegistered(mimeType))
 562         return ObjectContentNetscapePlugin;
 563 #endif
 564 
 565     if (MIMETypeRegistry::isSupportedNonImageMIMEType(type))
 566         return ObjectContentType::Frame;
 567 
 568     if (url.protocol() == &quot;about&quot;)
 569         return ObjectContentType::Frame;
 570 
 571     return ObjectContentType::None;
 572 }
 573 
 574 String FrameLoaderClientJava::overrideMediaType() const
 575 {
 576     notImplemented();
 577     return String();
 578 }
 579 
 580 void FrameLoaderClientJava::setMainFrameDocumentReady(bool)
 581 {
 582     // this is only interesting once we provide an external API for the DOM
 583 }
 584 
 585 bool FrameLoaderClientJava::hasWebView() const
 586 {
 587     notImplemented();
 588     return true;
 589 }
 590 
 591 void FrameLoaderClientJava::assignIdentifierToInitialRequest(unsigned long, DocumentLoader*, const ResourceRequest&amp;)
 592 {
 593     notImplemented();
 594 }
 595 
 596 void FrameLoaderClientJava::willReplaceMultipartContent()
 597 {
 598     notImplemented(); // TODO-java: recheck
 599 }
 600 
 601 void FrameLoaderClientJava::didReplaceMultipartContent()
 602 {
 603     notImplemented(); // TODO-java: recheck
 604 }
 605 
 606 void FrameLoaderClientJava::updateCachedDocumentLoader(DocumentLoader&amp;)
 607 {
 608     notImplemented(); // TODO-java: recheck
 609 }
 610 
 611 void FrameLoaderClientJava::dispatchDidStartProvisionalLoad()
 612 {
 613     m_mainResourceRequestID = 0;
 614 }
 615 
 616 void FrameLoaderClientJava::dispatchWillSendRequest(DocumentLoader* l, unsigned long identifier, ResourceRequest&amp; req, const ResourceResponse&amp; res)
 617 {
 618     using namespace FrameLoaderClientJavaInternal;
 619     JNIEnv* env = WTF::GetJavaEnv();
 620     initRefs(env);
 621 
 622     Frame* f = l-&gt;frame();
 623     if (!f) {
 624         f = frame();
 625     }
 626 
 627     double progress = 0.0;
 628     progress = page()-&gt;progress().estimatedProgress();
 629 
 630     if (m_mainResourceRequestID == 0) {
 631         m_mainResourceRequestID = identifier;
 632         postLoadEvent(f,
 633                       com_sun_webkit_LoadListenerClient_PAGE_STARTED,
 634                       req.url().string(),
 635                       res.mimeType(),
 636                       progress);
 637     } else if (m_mainResourceRequestID == identifier) { // serever-side redirection
 638         m_isPageRedirected = true;
 639         postLoadEvent(f,
 640                       com_sun_webkit_LoadListenerClient_PAGE_REDIRECTED,
 641                       req.url().string(),
 642                       res.mimeType(),
 643                       progress);
 644     } else {
 645         // Check resource policy.
 646         JLString urlJavaString(req.url().string().toJavaString(env));
 647         bool permit = jbool_to_bool(env-&gt;CallBooleanMethod(m_webPage, permitAcceptResourceActionMID,
 648                                                            ptr_to_jlong(f), (jstring)urlJavaString));
 649         WTF::CheckAndClearException(env);
 650         if (!permit) {
 651 /*
 652             req.setURL(NULL); // will cancel loading
 653 */
 654             req.setURL(URL());
 655         } else {
 656             setRequestURL(f, identifier, req.url().string());
 657             postResourceLoadEvent(f,
 658                                   com_sun_webkit_LoadListenerClient_RESOURCE_STARTED,
 659                                   identifier,
 660                                   res.mimeType(),
 661                                   0.0 /* progress */);
 662         }
 663     }
 664 }
 665 
 666 void FrameLoaderClientJava::dispatchDidFailLoading(DocumentLoader* dl, unsigned long identifier, const ResourceError&amp; error)
 667 {
 668     Frame* f = dl-&gt;frame();
 669     if (!f) {
 670         f = frame();
 671     }
 672     postResourceLoadEvent(f,
 673                           com_sun_webkit_LoadListenerClient_RESOURCE_FAILED,
 674                           identifier,
 675                           dl-&gt;responseMIMEType(),
 676                           0.0 /* progress */,
 677                           error.errorCode());
 678     removeRequestURL(f, identifier);
 679 }
 680 
 681 void FrameLoaderClientJava::dispatchDidFailProvisionalLoad(const ResourceError&amp; error)
 682 {
 683     ASSERT(frame());
 684     if (!frame()) {
 685         return;
 686     }
 687     DocumentLoader* dl = frame()-&gt;loader().activeDocumentLoader();
 688     if (!dl) {
 689         return;
 690     }
 691 
 692     double progress = page()-&gt;progress().estimatedProgress();
 693     int state = error.isCancellation()
 694         ? com_sun_webkit_LoadListenerClient_LOAD_STOPPED
 695         : com_sun_webkit_LoadListenerClient_LOAD_FAILED;
 696     postLoadEvent(frame(), state,
 697                   dl-&gt;url().string(),
 698                   dl-&gt;responseMIMEType(),
 699                   progress,
 700                   error.errorCode());
 701 }
 702 
 703 void FrameLoaderClientJava::dispatchDidFailLoad(const ResourceError&amp; error)
 704 {
 705     dispatchDidFailProvisionalLoad(error);
 706 }
 707 
 708 // client-side redirection
 709 void FrameLoaderClientJava::dispatchWillPerformClientRedirect(const URL&amp;, double, WallTime, LockBackForwardList)
 710 {
 711 }
 712 
 713 void FrameLoaderClientJava::dispatchDidReceiveTitle(const StringWithDirection&amp;)
 714 {
 715     double progress = page()-&gt;progress().estimatedProgress();
 716     postLoadEvent(frame(),
 717                   com_sun_webkit_LoadListenerClient_TITLE_RECEIVED,
 718                   frame()-&gt;document()-&gt;url(),
 719                   frame()-&gt;loader().documentLoader()-&gt;responseMIMEType(),
 720                   progress);
 721 }
 722 
 723 void FrameLoaderClientJava::dispatchDidReceiveIcon()
 724 {
 725     // not called without IconDatabase support, so sending the notification
 726     // from dispatchDidLoadMainResource()
 727     /*
 728     Frame* f = page()-&gt;mainFrame();
 729     if (!f-&gt;loader() || !f-&gt;document()) {
 730         return;
 731     }
 732 
 733     double progress = page()-&gt;progress()-&gt;estimatedProgress();
 734     postLoadEvent(com_sun_webkit_LoadListenerClient_ICON_RECEIVED,
 735                   0, // request id
 736                   f-&gt;document()-&gt;url(),
 737                   f-&gt;loader()-&gt;documentLoader()-&gt;responseMIMEType(),
 738                   progress);
 739     */
 740 }
 741 
 742 void FrameLoaderClientJava::dispatchDidReceiveContentLength(DocumentLoader*, unsigned long, int)
 743 {
 744     notImplemented();
 745 }
 746 
 747 void FrameLoaderClientJava::dispatchDidFinishDocumentLoad()
 748 {
 749     if (!frame()-&gt;isMainFrame()) {
 750         // send the notification for the main frame only
 751         return;
 752     }
 753 
 754     double progress = page()-&gt;progress().estimatedProgress();
 755     postLoadEvent(frame(),
 756                   com_sun_webkit_LoadListenerClient_DOCUMENT_AVAILABLE,
 757                   frame()-&gt;document()-&gt;url(),
 758                   frame()-&gt;loader().documentLoader()-&gt;responseMIMEType(),
 759                   progress);
 760 }
 761 
 762 void FrameLoaderClientJava::dispatchDidLoadMainResource(DocumentLoader* l)
 763 {
 764     double progress = page()-&gt;progress().estimatedProgress();
 765     // send ICON_RECEIVED here instead of dispatchDidReceiveIcon(),
 766     // see comments in the method for details
 767     postLoadEvent(frame(),
 768                   com_sun_webkit_LoadListenerClient_ICON_RECEIVED,
 769                   frame()-&gt;document()-&gt;url(),
 770                   l-&gt;responseMIMEType(),
 771                   progress);
 772     postLoadEvent(frame(),
 773                   com_sun_webkit_LoadListenerClient_CONTENT_RECEIVED,
 774                   l-&gt;responseURL().string(),
 775                   l-&gt;responseMIMEType(),
 776                   progress);
 777 }
 778 
 779 void FrameLoaderClientJava::dispatchDidFinishLoading(DocumentLoader* l, unsigned long identifier)
 780 {
 781     postResourceLoadEvent(frame(),
 782                           com_sun_webkit_LoadListenerClient_RESOURCE_FINISHED,
 783                           identifier,
 784                           l-&gt;responseMIMEType(),
 785                           1.0 /* progress */);
 786     removeRequestURL(frame(), identifier);
 787 }
 788 
 789 void FrameLoaderClientJava::dispatchDidFinishLoad()
 790 {
 791     double progress = page()-&gt;progress().estimatedProgress();
 792     postLoadEvent(frame(),
 793                   com_sun_webkit_LoadListenerClient_PAGE_FINISHED,
 794                   frame()-&gt;document()-&gt;url(),
 795                   frame()-&gt;loader().documentLoader()-&gt;responseMIMEType(),
 796                   progress);
 797 }
 798 
 799 void FrameLoaderClientJava::finishedLoading(DocumentLoader* dl)
 800 {
 801     // This is necessary to create an empty document. See bug 634004.
 802     // However, we only want to do this if makeRepresentation has been called, to
 803     // match the behavior on the Mac.
 804     if (m_hasRepresentation)
 805         dl-&gt;writer().setEncoding(&quot;&quot;, false);
 806 }
 807 
 808 void FrameLoaderClientJava::frameLoadCompleted()
 809 {
 810     notImplemented();
 811 }
 812 
 813 void FrameLoaderClientJava::saveViewStateToItem(HistoryItem&amp;)
 814 {
 815     notImplemented();
 816 }
 817 
 818 void FrameLoaderClientJava::restoreViewState()
 819 {
 820     notImplemented();
 821 }
 822 
 823 Frame* FrameLoaderClientJava::dispatchCreatePage(const NavigationAction&amp; action)
 824 {
 825     struct WindowFeatures features {};
 826     Page* newPage = frame()-&gt;page()-&gt;chrome().createWindow(
 827                         *frame(),
 828                         FrameLoadRequest(*frame()-&gt;document(),
 829                                             frame()-&gt;document()-&gt;securityOrigin(),
 830                                             action.resourceRequest(),
 831                                             {},
 832                                             LockHistory::No,
 833                                             LockBackForwardList::No,
 834                                             ShouldSendReferrer::MaybeSendReferrer,
 835                                             AllowNavigationToInvalidURL::Yes,
 836                                             NewFrameOpenerPolicy::Allow, // TODO-java: check params
 837                                             action.shouldOpenExternalURLsPolicy(),
 838                                             action.initiatedByMainFrame()),
 839                         features,
 840                         action);
 841 
 842     // createWindow can return null (e.g., popup blocker denies the window).
 843     if (!newPage)
 844         return 0;
 845 
 846     return &amp;newPage-&gt;mainFrame();
 847 }
 848 
 849 bool FrameLoaderClientJava::shouldGoToHistoryItem(HistoryItem&amp;) const
 850 {
 851     // FIXME: This is a very simple implementation. More sophisticated
 852     // implementation would delegate the decision to a PolicyDelegate.
 853     // See mac implementation for example.
 854     return true;
 855 }
 856 
 857 void FrameLoaderClientJava::didDisplayInsecureContent()
 858 {
 859     notImplemented();
 860 }
 861 
 862 void FrameLoaderClientJava::didRunInsecureContent(SecurityOrigin&amp;, const URL&amp;)
 863 {
 864     notImplemented();
 865 }
 866 
 867 void FrameLoaderClientJava::didDetectXSS(const URL&amp;, bool)
 868 {
 869     notImplemented();
 870 }
 871 
 872 void FrameLoaderClientJava::makeRepresentation(DocumentLoader*)
 873 {
 874     m_hasRepresentation = true;
 875 }
 876 
 877 void FrameLoaderClientJava::forceLayoutForNonHTML() { notImplemented(); }
 878 void FrameLoaderClientJava::setCopiesOnScroll() { notImplemented(); }
 879 void FrameLoaderClientJava::detachedFromParent2() { notImplemented(); }
 880 void FrameLoaderClientJava::detachedFromParent3() { notImplemented(); }
 881 
 882 void FrameLoaderClientJava::dispatchDidPushStateWithinPage()
 883 {
 884     dispatchDidNavigateWithinPage();
 885 }
 886 
 887 void FrameLoaderClientJava::dispatchDidReplaceStateWithinPage()
 888 {
 889     dispatchDidNavigateWithinPage();
 890 }
 891 
 892 void FrameLoaderClientJava::dispatchDidDispatchOnloadEvents() {notImplemented(); }
 893 void FrameLoaderClientJava::dispatchDidPopStateWithinPage() { notImplemented(); }
 894 void FrameLoaderClientJava::dispatchDidReceiveServerRedirectForProvisionalLoad() { notImplemented(); }
 895 void FrameLoaderClientJava::dispatchDidCancelClientRedirect() { notImplemented(); }
 896 void FrameLoaderClientJava::dispatchDidChangeLocationWithinPage() { notImplemented(); }
 897 void FrameLoaderClientJava::dispatchWillClose() { notImplemented(); }
 898 void FrameLoaderClientJava::dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt;)
 899 {
 900     // TODO: Look at GTK version
 901     notImplemented();
 902 }
 903 
 904 void FrameLoaderClientJava::dispatchShow() { notImplemented(); }
 905 void FrameLoaderClientJava::cancelPolicyCheck() { notImplemented(); }
 906 void FrameLoaderClientJava::revertToProvisionalState(DocumentLoader*) { notImplemented(); }
 907 void FrameLoaderClientJava::willChangeTitle(DocumentLoader*) { notImplemented(); }
 908 void FrameLoaderClientJava::didChangeTitle(DocumentLoader *l) { setTitle(l-&gt;title(), l-&gt;url()); }
 909 
 910 bool FrameLoaderClientJava::canHandleRequest(const ResourceRequest&amp; req) const
 911 {
 912     using namespace FrameLoaderClientJavaInternal;
 913     JNIEnv* env = WTF::GetJavaEnv();
 914     initRefs(env);
 915 
 916     JLString urlJavaString(req.url().string().toJavaString(env));
 917     jboolean ret = env-&gt;CallStaticBooleanMethod(networkContextClass, canHandleURLMID, (jstring)urlJavaString);
 918     WTF::CheckAndClearException(env);
 919 
 920     return jbool_to_bool(ret);
 921 }
 922 
 923 bool FrameLoaderClientJava::canShowMIMEType(const String&amp; mimeType) const
 924 {
 925     //copy from QT implementation
 926     String type = mimeType.convertToLowercaseWithoutLocale();
 927     if (MIMETypeRegistry::isSupportedImageMIMEType(type))
 928         return true;
 929 
 930     if (MIMETypeRegistry::isSupportedNonImageMIMEType(type))
 931         return true;
 932 
 933     if (MIMETypeRegistry::isSupportedMediaMIMEType(type))
 934         return true;
 935 
 936 #if 0 // PluginDatabase is disabled until we have Plugin system done.
 937     if (m_frame &amp;&amp; m_frame-&gt;settings().arePluginsEnabled()
 938         &amp;&amp; PluginDatabase::installedPlugins()-&gt;isMIMETypeRegistered(type))
 939         return true;
 940 #endif
 941 
 942     return false;
 943 }
 944 
 945 bool FrameLoaderClientJava::canShowMIMETypeAsHTML(const String&amp;) const
 946 {
 947     notImplemented();
 948     return false;
 949 }
 950 
 951 
 952 bool FrameLoaderClientJava::representationExistsForURLScheme(const String&amp;) const
 953 {
 954     notImplemented();
 955     return false;
 956 }
 957 
 958 String FrameLoaderClientJava::generatedMIMETypeForURLScheme(const String&amp;) const
 959 {
 960     notImplemented();
 961     return String();
 962 }
 963 
 964 void FrameLoaderClientJava::provisionalLoadStarted()
 965 {
 966     notImplemented();
 967 }
 968 
 969 void FrameLoaderClientJava::didFinishLoad()
 970 {
 971     notImplemented();
 972 }
 973 
 974 void FrameLoaderClientJava::prepareForDataSourceReplacement()
 975 {
 976     notImplemented();
 977 }
 978 
 979 void FrameLoaderClientJava::setTitle(const StringWithDirection&amp;, const URL&amp;)
 980 {
 981     notImplemented();
 982 }
 983 
 984 bool FrameLoaderClientJava::dispatchDidLoadResourceFromMemoryCache(
 985     DocumentLoader*,
 986     const ResourceRequest&amp;,
 987     const ResourceResponse&amp;,
 988     int)
 989 {
 990     notImplemented();
 991     return false;
 992 }
 993 
 994 ResourceError FrameLoaderClientJava::cancelledError(const ResourceRequest&amp; request)
 995 {
 996     return ResourceError(&quot;Error&quot;, -999, request.url(), &quot;Request cancelled&quot;);
 997 }
 998 
 999 ResourceError FrameLoaderClientJava::blockedError(const ResourceRequest&amp; request)
1000 {
1001     using namespace FrameLoaderClientJavaInternal;
1002     return ResourceError(&quot;Error&quot;, WebKitErrorCannotUseRestrictedPort, request.url(),
1003                          &quot;Request blocked&quot;);
1004 }
1005 
1006 ResourceError FrameLoaderClientJava::blockedByContentBlockerError(const ResourceRequest&amp; request)
1007 {
1008     using namespace FrameLoaderClientJavaInternal;
1009     RELEASE_ASSERT_NOT_REACHED(); // Content Blockers are not enabled for WK1.
1010     return ResourceError(&quot;Error&quot;, WebKitErrorCannotShowURL, request.url(),
1011                          &quot;Cannot show URL&quot;);
1012 }
1013 
1014 ResourceError FrameLoaderClientJava::cannotShowURLError(const ResourceRequest&amp; request)
1015 {
1016     using namespace FrameLoaderClientJavaInternal;
1017     return ResourceError(&quot;Error&quot;, WebKitErrorCannotShowURL, request.url(),
1018                          &quot;Cannot show URL&quot;);
1019 }
1020 
1021 ResourceError FrameLoaderClientJava::interruptedForPolicyChangeError(const ResourceRequest&amp; request)
1022 {
1023     using namespace FrameLoaderClientJavaInternal;
1024     return ResourceError(&quot;Error&quot;, WebKitErrorFrameLoadInterruptedByPolicyChange,
1025                          request.url(), &quot;Frame load interrupted by policy change&quot;);
1026 }
1027 
1028 ResourceError FrameLoaderClientJava::cannotShowMIMETypeError(const ResourceResponse&amp; response)
1029 {
1030     using namespace FrameLoaderClientJavaInternal;
1031     return ResourceError(&quot;Error&quot;, WebKitErrorCannotShowMIMEType, response.url(),
1032                          &quot;Cannot show mimetype&quot;);
1033 }
1034 
1035 ResourceError FrameLoaderClientJava::fileDoesNotExistError(const ResourceResponse&amp; response)
1036 {
1037     return ResourceError(&quot;Error&quot;, -998 /* ### */, response.url(),
1038                          &quot;File does not exist&quot;);
1039 }
1040 
1041 ResourceError FrameLoaderClientJava::pluginWillHandleLoadError(const ResourceResponse&amp; response)
1042 {
1043     using namespace FrameLoaderClientJavaInternal;
1044     return ResourceError(&quot;Error&quot;, WebKitErrorPluginWillHandleLoad, response.url(), &quot;Loading is handled by the media engine&quot;);
1045 }
1046 
1047 bool FrameLoaderClientJava::shouldFallBack(const ResourceError&amp; error)
1048 {
1049     using namespace FrameLoaderClientJavaInternal;
1050     //Font fallback supported by Java Fonts internaly
1051     return !(error.isCancellation() || (error.errorCode() == WebKitErrorFrameLoadInterruptedByPolicyChange));
1052 }
1053 
1054 bool FrameLoaderClientJava::canCachePage() const
1055 {
1056     return true;
1057 }
1058 
1059 void FrameLoaderClientJava::didSaveToPageCache()
1060 {
1061 }
1062 
1063 void FrameLoaderClientJava::didRestoreFromPageCache()
1064 {
1065 }
1066 
1067 void FrameLoaderClientJava::dispatchUnableToImplementPolicy(const ResourceError&amp;)
1068 {
1069     notImplemented();
1070 }
1071 
1072 void FrameLoaderClientJava::dispatchDidBecomeFrameset(bool)
1073 {
1074    notImplemented();
1075 }
1076 
1077 
1078 void FrameLoaderClientJava::setMainDocumentError(
1079     DocumentLoader*,
1080     const ResourceError&amp;)
1081 {
1082 //    if (m_pluginWidget) {
1083 //        m_pluginWidget = 0;
1084 //    }
1085     notImplemented();
1086 }
1087 
1088 void FrameLoaderClientJava::startDownload(const ResourceRequest&amp;, const String&amp;)
1089 {
1090     notImplemented();
1091 }
1092 
1093 void FrameLoaderClientJava::updateGlobalHistory()
1094 {
1095     notImplemented();
1096 }
1097 
1098 void FrameLoaderClientJava::updateGlobalHistoryRedirectLinks()
1099 {
1100     notImplemented();
1101 }
1102 
1103 void FrameLoaderClientJava::dispatchDidClearWindowObjectInWorld(
1104     DOMWrapperWorld&amp; world)
1105 {
1106     using namespace FrameLoaderClientJavaInternal;
1107     JNIEnv* env = WTF::GetJavaEnv();
1108     initRefs(env);
1109 
1110     if (&amp;world != &amp;mainThreadNormalWorld()) {
1111         return;
1112     }
1113 
1114     JSGlobalContextRef context = toGlobalRef(frame()-&gt;script().globalObject(
1115             mainThreadNormalWorld())-&gt;globalExec());
1116     JSObjectRef windowObject = JSContextGetGlobalObject(context);
1117 
1118     env-&gt;CallVoidMethod(m_webPage, didClearWindowObjectMID,
1119             ptr_to_jlong(context), ptr_to_jlong(windowObject));
1120     WTF::CheckAndClearException(env);
1121 }
1122 
1123 void FrameLoaderClientJava::registerForIconNotification()
1124 {
1125     //notImplemented();
1126 }
1127 
1128 void FrameLoaderClientJava::convertMainResourceLoadToDownload(DocumentLoader*, PAL::SessionID, const ResourceRequest&amp;, const ResourceResponse&amp;)
1129 {
1130     //notImplemented();
1131 }
1132 
1133 Ref&lt;FrameNetworkingContext&gt; FrameLoaderClientJava::createNetworkingContext()
1134 {
1135     return FrameNetworkingContextJava::create(frame());
1136 }
1137 
1138 
1139 bool FrameLoaderClientJava::shouldUseCredentialStorage(
1140     DocumentLoader*,
1141     unsigned long)
1142 {
1143     notImplemented();
1144     return false;
1145 }
1146 
1147 void FrameLoaderClientJava::dispatchDidReceiveAuthenticationChallenge(DocumentLoader*, unsigned long, const AuthenticationChallenge&amp; challenge)
1148 {
1149     notImplemented();
1150     // If the ResourceLoadDelegate doesn&#39;t exist or fails to handle the call, we tell the ResourceHandle
1151     // to continue without credential - this is the best approximation of Mac behavior
1152     challenge.authenticationClient()-&gt;receivedRequestToContinueWithoutCredential(challenge);
1153 }
1154 
1155 void FrameLoaderClientJava::prefetchDNS(const String&amp; hostname)
1156 {
1157     WebCore::prefetchDNS(hostname);
1158 }
1159 
1160 Optional&lt;uint64_t&gt; FrameLoaderClientJava::pageID() const
1161 {
1162     return WTF::nullopt;
1163 }
1164 
1165 Optional&lt;uint64_t&gt; FrameLoaderClientJava::frameID() const
1166 {
1167     return WTF::nullopt;
1168 }
1169 
1170 PAL::SessionID FrameLoaderClientJava::sessionID() const
1171 {
1172     RELEASE_ASSERT_NOT_REACHED();
1173     return PAL::SessionID::defaultSessionID();
1174 }
1175 
1176 
1177 }
    </pre>
  </body>
</html>