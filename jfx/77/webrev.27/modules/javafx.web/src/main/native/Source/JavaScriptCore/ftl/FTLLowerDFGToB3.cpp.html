<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*
    2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;FTLLowerDFGToB3.h&quot;
   28 
   29 #if ENABLE(FTL_JIT)
   30 
   31 #include &quot;AirCode.h&quot;
   32 #include &quot;AirGenerationContext.h&quot;
   33 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
   35 #include &quot;AtomicsObject.h&quot;
   36 #include &quot;B3CheckValue.h&quot;
   37 #include &quot;B3FenceValue.h&quot;
   38 #include &quot;B3PatchpointValue.h&quot;
   39 #include &quot;B3SlotBaseValue.h&quot;
   40 #include &quot;B3StackmapGenerationParams.h&quot;
   41 #include &quot;B3ValueInlines.h&quot;
   42 #include &quot;CallFrameShuffler.h&quot;
   43 #include &quot;CodeBlockWithJITType.h&quot;
   44 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   45 #include &quot;DFGCapabilities.h&quot;
   46 #include &quot;DFGDoesGC.h&quot;
   47 #include &quot;DFGDominators.h&quot;
   48 #include &quot;DFGInPlaceAbstractState.h&quot;
   49 #include &quot;DFGLivenessAnalysisPhase.h&quot;
   50 #include &quot;DFGMayExit.h&quot;
   51 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
   52 #include &quot;DFGOSRExitFuzz.h&quot;
   53 #include &quot;DirectArguments.h&quot;
   54 #include &quot;FTLAbstractHeapRepository.h&quot;
   55 #include &quot;FTLAvailableRecovery.h&quot;
   56 #include &quot;FTLExceptionTarget.h&quot;
   57 #include &quot;FTLForOSREntryJITCode.h&quot;
   58 #include &quot;FTLFormattedValue.h&quot;
   59 #include &quot;FTLLazySlowPathCall.h&quot;
   60 #include &quot;FTLLoweredNodeValue.h&quot;
   61 #include &quot;FTLOperations.h&quot;
   62 #include &quot;FTLOutput.h&quot;
   63 #include &quot;FTLPatchpointExceptionHandle.h&quot;
   64 #include &quot;FTLSnippetParams.h&quot;
   65 #include &quot;FTLThunks.h&quot;
   66 #include &quot;FTLWeightedTarget.h&quot;
   67 #include &quot;JITAddGenerator.h&quot;
   68 #include &quot;JITBitAndGenerator.h&quot;
   69 #include &quot;JITBitOrGenerator.h&quot;
   70 #include &quot;JITBitXorGenerator.h&quot;
   71 #include &quot;JITDivGenerator.h&quot;
   72 #include &quot;JITInlineCacheGenerator.h&quot;
   73 #include &quot;JITLeftShiftGenerator.h&quot;
   74 #include &quot;JITMathIC.h&quot;
   75 #include &quot;JITMulGenerator.h&quot;
   76 #include &quot;JITRightShiftGenerator.h&quot;
   77 #include &quot;JITSubGenerator.h&quot;
   78 #include &quot;JSAsyncFunction.h&quot;
   79 #include &quot;JSAsyncGeneratorFunction.h&quot;
   80 #include &quot;JSCInlines.h&quot;
   81 #include &quot;JSGeneratorFunction.h&quot;
   82 #include &quot;JSImmutableButterfly.h&quot;
   83 #include &quot;JSLexicalEnvironment.h&quot;
   84 #include &quot;JSMap.h&quot;
   85 #include &quot;OperandsInlines.h&quot;
   86 #include &quot;ProbeContext.h&quot;
   87 #include &quot;RegExpObject.h&quot;
   88 #include &quot;ScopedArguments.h&quot;
   89 #include &quot;ScopedArgumentsTable.h&quot;
   90 #include &quot;ScratchRegisterAllocator.h&quot;
   91 #include &quot;SetupVarargsFrame.h&quot;
   92 #include &quot;ShadowChicken.h&quot;
   93 #include &quot;StructureStubInfo.h&quot;
   94 #include &quot;SuperSampler.h&quot;
   95 #include &quot;ThunkGenerators.h&quot;
   96 #include &quot;VirtualRegister.h&quot;
   97 #include &quot;Watchdog.h&quot;
   98 #include &lt;atomic&gt;
   99 #include &lt;wtf/Box.h&gt;
  100 #include &lt;wtf/Gigacage.h&gt;
  101 #include &lt;wtf/RecursableLambda.h&gt;
  102 #include &lt;wtf/StdUnorderedSet.h&gt;
  103 
  104 #undef RELEASE_ASSERT
  105 #define RELEASE_ASSERT(assertion) do { \
  106     if (!(assertion)) { \
  107         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
  108         CRASH(); \
  109     } \
  110 } while (0)
  111 
  112 namespace JSC { namespace FTL {
  113 
  114 using namespace B3;
  115 using namespace DFG;
  116 
  117 namespace {
  118 
  119 std::atomic&lt;int&gt; compileCounter;
  120 
  121 #if !ASSERT_DISABLED
  122 NO_RETURN_DUE_TO_CRASH static void ftlUnreachable(
  123     CodeBlock* codeBlock, BlockIndex blockIndex, unsigned nodeIndex)
  124 {
  125     dataLog(&quot;Crashing in thought-to-be-unreachable FTL-generated code for &quot;, pointerDump(codeBlock), &quot; at basic block #&quot;, blockIndex);
  126     if (nodeIndex != UINT_MAX)
  127         dataLog(&quot;, node @&quot;, nodeIndex);
  128     dataLog(&quot;.\n&quot;);
  129     CRASH();
  130 }
  131 #endif
  132 
  133 // Using this instead of typeCheck() helps to reduce the load on B3, by creating
  134 // significantly less dead code.
  135 #define FTL_TYPE_CHECK_WITH_EXIT_KIND(exitKind, lowValue, highValue, typesPassedThrough, failCondition) do { \
  136         FormattedValue _ftc_lowValue = (lowValue);                      \
  137         Edge _ftc_highValue = (highValue);                              \
  138         SpeculatedType _ftc_typesPassedThrough = (typesPassedThrough);  \
  139         if (!m_interpreter.needsTypeCheck(_ftc_highValue, _ftc_typesPassedThrough)) \
  140             break;                                                      \
  141         typeCheck(_ftc_lowValue, _ftc_highValue, _ftc_typesPassedThrough, (failCondition), exitKind); \
  142     } while (false)
  143 
  144 #define FTL_TYPE_CHECK(lowValue, highValue, typesPassedThrough, failCondition) \
  145     FTL_TYPE_CHECK_WITH_EXIT_KIND(BadType, lowValue, highValue, typesPassedThrough, failCondition)
  146 
  147 class LowerDFGToB3 {
  148     WTF_MAKE_NONCOPYABLE(LowerDFGToB3);
  149 public:
  150     LowerDFGToB3(State&amp; state)
  151         : m_graph(state.graph)
  152         , m_ftlState(state)
  153         , m_out(state)
  154         , m_proc(*state.proc)
  155         , m_availabilityCalculator(m_graph)
  156         , m_state(state.graph)
  157         , m_interpreter(state.graph, m_state)
  158         , m_indexMaskingMode(Options::enableSpectreMitigations() ?  IndexMaskingEnabled : IndexMaskingDisabled)
  159     {
  160         if (Options::validateAbstractInterpreterState()) {
  161             performLivenessAnalysis(m_graph);
  162 
  163             // We only use node liveness here, not combined liveness, as we only track
  164             // AI state for live nodes.
  165             for (DFG::BasicBlock* block : m_graph.blocksInNaturalOrder()) {
  166                 NodeSet live;
  167 
  168                 for (NodeFlowProjection node : block-&gt;ssa-&gt;liveAtTail) {
  169                     if (node.kind() == NodeFlowProjection::Primary)
  170                         live.addVoid(node.node());
  171                 }
  172 
  173                 for (unsigned i = block-&gt;size(); i--; ) {
  174                     Node* node = block-&gt;at(i);
  175                     live.remove(node);
  176                     m_graph.doToChildren(node, [&amp;] (Edge child) {
  177                         live.addVoid(child.node());
  178                     });
  179                     m_liveInToNode.add(node, live);
  180                 }
  181             }
  182         }
  183     }
  184 
  185     void lower()
  186     {
  187         State* state = &amp;m_ftlState;
  188 
  189         CString name;
  190         if (verboseCompilationEnabled()) {
  191             name = toCString(
  192                 &quot;jsBody_&quot;, ++compileCounter, &quot;_&quot;, codeBlock()-&gt;inferredName(),
  193                 &quot;_&quot;, codeBlock()-&gt;hash());
  194         } else
  195             name = &quot;jsBody&quot;;
  196 
  197         {
  198             m_proc.setNumEntrypoints(m_graph.m_numberOfEntrypoints);
  199             CodeBlock* codeBlock = m_graph.m_codeBlock;
  200 
  201             Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
  202                 [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
  203                     AllowMacroScratchRegisterUsage allowScratch(jit);
  204                     jit.addPtr(CCallHelpers::TrustedImm32(-code.frameSize()), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
  205                     if (Options::zeroStackFrame())
  206                         jit.clearStackFrame(GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister, GPRInfo::regT0, code.frameSize());
  207 
  208                     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
  209                     jit.emitPutToCallFrameHeader(codeBlock, CallFrameSlot::codeBlock);
  210                 });
  211 
  212             for (unsigned catchEntrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys()) {
  213                 RELEASE_ASSERT(catchEntrypointIndex != 0);
  214                 m_proc.code().setPrologueForEntrypoint(catchEntrypointIndex, catchPrologueGenerator.copyRef());
  215             }
  216 
  217             if (m_graph.m_maxLocalsForCatchOSREntry) {
  218                 uint32_t numberOfLiveLocals = std::max(*m_graph.m_maxLocalsForCatchOSREntry, 1u); // Make sure we always allocate a non-null catchOSREntryBuffer.
  219                 m_ftlState.jitCode-&gt;common.catchOSREntryBuffer = m_graph.m_vm.scratchBufferForSize(sizeof(JSValue) * numberOfLiveLocals);
  220             }
  221         }
  222 
  223         m_graph.ensureSSADominators();
  224 
  225         if (verboseCompilationEnabled())
  226             dataLog(&quot;Function ready, beginning lowering.\n&quot;);
  227 
  228         m_out.initialize(m_heaps);
  229 
  230         // We use prologue frequency for all of the initialization code.
  231         m_out.setFrequency(1);
  232 
  233         bool hasMultipleEntrypoints = m_graph.m_numberOfEntrypoints &gt; 1;
  234 
  235         LBasicBlock prologue = m_out.newBlock();
  236         LBasicBlock callEntrypointArgumentSpeculations = hasMultipleEntrypoints ? m_out.newBlock() : nullptr;
  237         m_handleExceptions = m_out.newBlock();
  238 
  239         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
  240             m_highBlock = m_graph.block(blockIndex);
  241             if (!m_highBlock)
  242                 continue;
  243             m_out.setFrequency(m_highBlock-&gt;executionCount);
  244             m_blocks.add(m_highBlock, m_out.newBlock());
  245         }
  246 
  247         // Back to prologue frequency for any bocks that get sneakily created in the initialization code.
  248         m_out.setFrequency(1);
  249 
  250         m_out.appendTo(prologue, hasMultipleEntrypoints ? callEntrypointArgumentSpeculations : m_handleExceptions);
  251         m_out.initializeConstants(m_proc, prologue);
  252         createPhiVariables();
  253 
  254         size_t sizeOfCaptured = sizeof(JSValue) * m_graph.m_nextMachineLocal;
  255         B3::SlotBaseValue* capturedBase = m_out.lockedStackSlot(sizeOfCaptured);
  256         m_captured = m_out.add(capturedBase, m_out.constIntPtr(sizeOfCaptured));
  257         state-&gt;capturedValue = capturedBase-&gt;slot();
  258 
  259         auto preOrder = m_graph.blocksInPreOrder();
  260 
  261         m_callFrame = m_out.framePointer();
  262         m_tagTypeNumber = m_out.constInt64(TagTypeNumber);
  263         m_tagMask = m_out.constInt64(TagMask);
  264 
  265         // Make sure that B3 knows that we really care about the mask registers. This forces the
  266         // constants to be materialized in registers.
  267         m_proc.addFastConstant(m_tagTypeNumber-&gt;key());
  268         m_proc.addFastConstant(m_tagMask-&gt;key());
  269 
  270         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
  271         // that would cause it to always get collected.
  272         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), addressFor(CallFrameSlot::codeBlock));
  273 
  274         VM* vm = &amp;this-&gt;vm();
  275 
  276         // Stack Overflow Check.
  277         unsigned exitFrameSize = m_graph.requiredRegisterCountForExit() * sizeof(Register);
  278         MacroAssembler::AbsoluteAddress addressOfStackLimit(vm-&gt;addressOfSoftStackLimit());
  279         PatchpointValue* stackOverflowHandler = m_out.patchpoint(Void);
  280         CallSiteIndex callSiteIndex = callSiteIndexForCodeOrigin(m_ftlState, CodeOrigin(0));
  281         stackOverflowHandler-&gt;appendSomeRegister(m_callFrame);
  282         stackOverflowHandler-&gt;clobber(RegisterSet::macroScratchRegisters());
  283         stackOverflowHandler-&gt;numGPScratchRegisters = 1;
  284         stackOverflowHandler-&gt;setGenerator(
  285             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
  286                 AllowMacroScratchRegisterUsage allowScratch(jit);
  287                 GPRReg fp = params[0].gpr();
  288                 GPRReg scratch = params.gpScratch(0);
  289 
  290                 unsigned ftlFrameSize = params.proc().frameSize();
  291                 unsigned maxFrameSize = std::max(exitFrameSize, ftlFrameSize);
  292 
  293                 jit.addPtr(MacroAssembler::TrustedImm32(-maxFrameSize), fp, scratch);
  294                 MacroAssembler::JumpList stackOverflow;
  295                 if (UNLIKELY(maxFrameSize &gt; Options::reservedZoneSize()))
  296                     stackOverflow.append(jit.branchPtr(MacroAssembler::Above, scratch, fp));
  297                 stackOverflow.append(jit.branchPtr(MacroAssembler::Above, addressOfStackLimit, scratch));
  298 
  299                 params.addLatePath([=] (CCallHelpers&amp; jit) {
  300                     AllowMacroScratchRegisterUsage allowScratch(jit);
  301 
  302                     stackOverflow.link(&amp;jit);
  303 
  304                     // FIXME: We would not have to do this if the stack check was part of the Air
  305                     // prologue. Then, we would know that there is no way for the callee-saves to
  306                     // get clobbered.
  307                     // https://bugs.webkit.org/show_bug.cgi?id=172456
  308                     jit.emitRestore(params.proc().calleeSaveRegisterAtOffsetList());
  309 
  310                     jit.store32(
  311                         MacroAssembler::TrustedImm32(callSiteIndex.bits()),
  312                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
  313                     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
  314 
  315                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
  316                     jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()), GPRInfo::argumentGPR1);
  317                     CCallHelpers::Call throwCall = jit.call(OperationPtrTag);
  318 
  319                     jit.move(CCallHelpers::TrustedImmPtr(vm), GPRInfo::argumentGPR0);
  320                     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);
  321                     CCallHelpers::Call lookupExceptionHandlerCall = jit.call(OperationPtrTag);
  322                     jit.jumpToExceptionHandler(*vm);
  323 
  324                     jit.addLinkTask(
  325                         [=] (LinkBuffer&amp; linkBuffer) {
  326                             linkBuffer.link(throwCall, FunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowError));
  327                             linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandlerFromCallerFrame));
  328                     });
  329                 });
  330             });
  331 
  332         LBasicBlock firstDFGBasicBlock = lowBlock(m_graph.block(0));
  333 
  334         {
  335             if (hasMultipleEntrypoints) {
  336                 Vector&lt;LBasicBlock&gt; successors(m_graph.m_numberOfEntrypoints);
  337                 successors[0] = callEntrypointArgumentSpeculations;
  338                 for (unsigned i = 1; i &lt; m_graph.m_numberOfEntrypoints; ++i) {
  339                     // Currently, the only other entrypoint is an op_catch entrypoint.
  340                     // We do OSR entry at op_catch, and we prove argument formats before
  341                     // jumping to FTL code, so we don&#39;t need to check argument types here
  342                     // for these entrypoints.
  343                     successors[i] = firstDFGBasicBlock;
  344                 }
  345 
  346                 m_out.entrySwitch(successors);
  347                 m_out.appendTo(callEntrypointArgumentSpeculations, m_handleExceptions);
  348             }
  349 
  350             m_node = nullptr;
  351             m_origin = NodeOrigin(CodeOrigin(0), CodeOrigin(0), true);
  352 
  353             // Check Arguments.
  354             availabilityMap().clear();
  355             availabilityMap().m_locals = Operands&lt;Availability&gt;(codeBlock()-&gt;numParameters(), 0);
  356             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  357                 availabilityMap().m_locals.argument(i) =
  358                     Availability(FlushedAt(FlushedJSValue, virtualRegisterForArgument(i)));
  359             }
  360 
  361             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  362                 MethodOfGettingAValueProfile profile(&amp;m_graph.m_profiledBlock-&gt;valueProfileForArgument(i));
  363                 VirtualRegister operand = virtualRegisterForArgument(i);
  364                 LValue jsValue = m_out.load64(addressFor(operand));
  365 
  366                 switch (m_graph.m_argumentFormats[0][i]) {
  367                 case FlushedInt32:
  368                     speculate(BadType, jsValueValue(jsValue), profile, isNotInt32(jsValue));
  369                     break;
  370                 case FlushedBoolean:
  371                     speculate(BadType, jsValueValue(jsValue), profile, isNotBoolean(jsValue));
  372                     break;
  373                 case FlushedCell:
  374                     speculate(BadType, jsValueValue(jsValue), profile, isNotCell(jsValue));
  375                     break;
  376                 case FlushedJSValue:
  377                     break;
  378                 default:
  379                     DFG_CRASH(m_graph, nullptr, &quot;Bad flush format for argument&quot;);
  380                     break;
  381                 }
  382             }
  383             m_out.jump(firstDFGBasicBlock);
  384         }
  385 
  386 
  387         m_out.appendTo(m_handleExceptions, firstDFGBasicBlock);
  388         Box&lt;CCallHelpers::Label&gt; exceptionHandler = state-&gt;exceptionHandler;
  389         m_out.patchpoint(Void)-&gt;setGenerator(
  390             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
  391                 CCallHelpers::Jump jump = jit.jump();
  392                 jit.addLinkTask(
  393                     [=] (LinkBuffer&amp; linkBuffer) {
  394                         linkBuffer.link(jump, linkBuffer.locationOf&lt;ExceptionHandlerPtrTag&gt;(*exceptionHandler));
  395                     });
  396             });
  397         m_out.unreachable();
  398 
  399         for (DFG::BasicBlock* block : preOrder)
  400             compileBlock(block);
  401 
  402         // Make sure everything is decorated. This does a bunch of deferred decorating. This has
  403         // to happen last because our abstract heaps are generated lazily. They have to be
  404         // generated lazily because we have an infinite number of numbered, indexed, and
  405         // absolute heaps. We only become aware of the ones we actually mention while lowering.
  406         m_heaps.computeRangesAndDecorateInstructions();
  407 
  408         // We create all Phi&#39;s up front, but we may then decide not to compile the basic block
  409         // that would have contained one of them. So this creates orphans, which triggers B3
  410         // validation failures. Calling this fixes the issue.
  411         //
  412         // Note that you should avoid the temptation to make this call conditional upon
  413         // validation being enabled. B3 makes no guarantees of any kind of correctness when
  414         // dealing with IR that would have failed validation. For example, it would be valid to
  415         // write a B3 phase that so aggressively assumes the lack of orphans that it would crash
  416         // if any orphans were around. We might even have such phases already.
  417         m_proc.deleteOrphans();
  418 
  419         // We put the blocks into the B3 procedure in a super weird order. Now we reorder them.
  420         m_out.applyBlockOrder();
  421     }
  422 
  423 private:
  424 
  425     void createPhiVariables()
  426     {
  427         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  428             DFG::BasicBlock* block = m_graph.block(blockIndex);
  429             if (!block)
  430                 continue;
  431             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
  432                 Node* node = block-&gt;at(nodeIndex);
  433                 if (node-&gt;op() != DFG::Phi)
  434                     continue;
  435                 LType type;
  436                 switch (node-&gt;flags() &amp; NodeResultMask) {
  437                 case NodeResultDouble:
  438                     type = Double;
  439                     break;
  440                 case NodeResultInt32:
  441                     type = Int32;
  442                     break;
  443                 case NodeResultInt52:
  444                     type = Int64;
  445                     break;
  446                 case NodeResultBoolean:
  447                     type = Int32;
  448                     break;
  449                 case NodeResultJS:
  450                     type = Int64;
  451                     break;
  452                 default:
  453                     DFG_CRASH(m_graph, node, &quot;Bad Phi node result type&quot;);
  454                     break;
  455                 }
  456                 m_phis.add(node, m_proc.add&lt;Value&gt;(B3::Phi, type, Origin(node)));
  457             }
  458         }
  459     }
  460 
  461     void compileBlock(DFG::BasicBlock* block)
  462     {
  463         if (!block)
  464             return;
  465 
  466         if (verboseCompilationEnabled())
  467             dataLog(&quot;Compiling block &quot;, *block, &quot;\n&quot;);
  468 
  469         m_highBlock = block;
  470 
  471         // Make sure that any blocks created while lowering code in the high block have the frequency of
  472         // the high block. This is appropriate because B3 doesn&#39;t need precise frequencies. It just needs
  473         // something roughly approximate for things like register allocation.
  474         m_out.setFrequency(m_highBlock-&gt;executionCount);
  475 
  476         LBasicBlock lowBlock = m_blocks.get(m_highBlock);
  477 
  478         m_nextHighBlock = 0;
  479         for (BlockIndex nextBlockIndex = m_highBlock-&gt;index + 1; nextBlockIndex &lt; m_graph.numBlocks(); ++nextBlockIndex) {
  480             m_nextHighBlock = m_graph.block(nextBlockIndex);
  481             if (m_nextHighBlock)
  482                 break;
  483         }
  484         m_nextLowBlock = m_nextHighBlock ? m_blocks.get(m_nextHighBlock) : 0;
  485 
  486         // All of this effort to find the next block gives us the ability to keep the
  487         // generated IR in roughly program order. This ought not affect the performance
  488         // of the generated code (since we expect B3 to reorder things) but it will
  489         // make IR dumps easier to read.
  490         m_out.appendTo(lowBlock, m_nextLowBlock);
  491 
  492         if (Options::ftlCrashes())
  493             m_out.trap();
  494 
  495         if (!m_highBlock-&gt;cfaHasVisited) {
  496             if (verboseCompilationEnabled())
  497                 dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
  498             crash(m_highBlock, nullptr);
  499             return;
  500         }
  501 
  502         m_aiCheckedNodes.clear();
  503 
  504         m_availabilityCalculator.beginBlock(m_highBlock);
  505 
  506         m_state.reset();
  507         m_state.beginBasicBlock(m_highBlock);
  508 
  509         for (m_nodeIndex = 0; m_nodeIndex &lt; m_highBlock-&gt;size(); ++m_nodeIndex) {
  510             if (!compileNode(m_nodeIndex))
  511                 break;
  512         }
  513     }
  514 
  515     void safelyInvalidateAfterTermination()
  516     {
  517         if (verboseCompilationEnabled())
  518             dataLog(&quot;Bailing.\n&quot;);
  519         crash();
  520 
  521         // Invalidate dominated blocks. Under normal circumstances we would expect
  522         // them to be invalidated already. But you can have the CFA become more
  523         // precise over time because the structures of objects change on the main
  524         // thread. Failing to do this would result in weird crashes due to a value
  525         // being used but not defined. Race conditions FTW!
  526         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  527             DFG::BasicBlock* target = m_graph.block(blockIndex);
  528             if (!target)
  529                 continue;
  530             if (m_graph.m_ssaDominators-&gt;dominates(m_highBlock, target)) {
  531                 if (verboseCompilationEnabled())
  532                     dataLog(&quot;Block &quot;, *target, &quot; will bail also.\n&quot;);
  533                 target-&gt;cfaHasVisited = false;
  534             }
  535         }
  536     }
  537 
  538     void validateAIState(Node* node)
  539     {
  540         if (!m_graphDump) {
  541             StringPrintStream out;
  542             m_graph.dump(out);
  543             m_graphDump = out.toString();
  544         }
  545 
  546         switch (node-&gt;op()) {
  547         case MovHint:
  548         case ZombieHint:
  549         case JSConstant:
  550         case LazyJSConstant:
  551         case DoubleConstant:
  552         case Int52Constant:
  553         case GetStack:
  554         case PutStack:
  555         case KillStack:
  556         case ExitOK:
  557             return;
  558         default:
  559             break;
  560         }
  561 
  562         // Before we execute node.
  563         NodeSet&amp; live = m_liveInToNode.find(node)-&gt;value;
  564         unsigned highParentIndex = node-&gt;index();
  565         {
  566             uint64_t hash = WTF::intHash(highParentIndex);
  567             if (hash &gt;= static_cast&lt;uint64_t&gt;((static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max()) + 1) * Options::validateAbstractInterpreterStateProbability()))
  568                 return;
  569         }
  570 
  571         for (Node* node : live) {
  572             if (node-&gt;isPhantomAllocation())
  573                 continue;
  574 
  575             if (node-&gt;op() == CheckInBounds)
  576                 continue;
  577 
  578             AbstractValue value = m_interpreter.forNode(node);
  579             {
  580                 auto iter = m_aiCheckedNodes.find(node);
  581                 if (iter != m_aiCheckedNodes.end()) {
  582                     AbstractValue checkedValue = iter-&gt;value;
  583                     if (checkedValue == value) {
  584                         if (!(value.m_type &amp; SpecCell))
  585                             continue;
  586                     }
  587                 }
  588                 m_aiCheckedNodes.set(node, value);
  589             }
  590 
  591             FlushFormat flushFormat;
  592             LValue input;
  593             if (node-&gt;hasJSResult()) {
  594                 input = lowJSValue(Edge(node, UntypedUse));
  595                 flushFormat = FlushedJSValue;
  596             } else if (node-&gt;hasDoubleResult()) {
  597                 input = lowDouble(Edge(node, DoubleRepUse));
  598                 flushFormat = FlushedDouble;
  599             } else if (node-&gt;hasInt52Result()) {
  600                 input = strictInt52ToJSValue(lowStrictInt52(Edge(node, Int52RepUse)));
  601                 flushFormat = FlushedInt52;
  602             } else
  603                 continue;
  604 
  605             unsigned highChildIndex = node-&gt;index();
  606 
  607             String graphDump = m_graphDump;
  608 
  609             PatchpointValue* patchpoint = m_out.patchpoint(Void);
  610             patchpoint-&gt;effects = Effects::none();
  611             patchpoint-&gt;effects.writesLocalState = true;
  612             patchpoint-&gt;appendSomeRegister(input);
  613             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
  614                 GPRReg reg = InvalidGPRReg;
  615                 FPRReg fpReg = InvalidFPRReg;
  616                 if (flushFormat == FlushedDouble)
  617                     fpReg = params[0].fpr();
  618                 else
  619                     reg = params[0].gpr();
  620                 jit.probe([=] (Probe::Context&amp; context) {
  621                     JSValue input;
  622                     double doubleInput;
  623 
  624                     auto dumpAndCrash = [&amp;] {
  625                         dataLogLn(&quot;Validation failed at node: @&quot;, highParentIndex);
  626                         dataLogLn(&quot;Failed validating live value: @&quot;, highChildIndex);
  627                         dataLogLn();
  628                         dataLogLn(&quot;Expected AI value = &quot;, value);
  629                         if (flushFormat != FlushedDouble)
  630                             dataLogLn(&quot;Unexpected value = &quot;, input);
  631                         else
  632                             dataLogLn(&quot;Unexpected double value = &quot;, doubleInput);
  633                         dataLogLn();
  634                         dataLogLn(graphDump);
  635                         CRASH();
  636                     };
  637 
  638                     if (flushFormat == FlushedDouble) {
  639                         doubleInput = context.fpr(fpReg);
  640                         SpeculatedType type;
  641                         if (!std::isnan(doubleInput))
  642                             type = speculationFromValue(jsDoubleNumber(doubleInput));
  643                         else if (isImpureNaN(doubleInput))
  644                             type = SpecDoubleImpureNaN;
  645                         else
  646                             type = SpecDoublePureNaN;
  647 
  648                         if (!value.couldBeType(type))
  649                             dumpAndCrash();
  650                     } else {
  651                         input = JSValue::decode(context.gpr(reg));
  652                         if (flushFormat == FlushedInt52) {
  653                             RELEASE_ASSERT(input.isAnyInt());
  654                             input = jsDoubleNumber(input.asAnyInt());
  655                         }
  656                         if (!value.validateOSREntryValue(input, flushFormat))
  657                             dumpAndCrash();
  658                     }
  659 
  660                 });
  661             });
  662         }
  663     }
  664 
  665     bool compileNode(unsigned nodeIndex)
  666     {
  667         if (!m_state.isValid()) {
  668             safelyInvalidateAfterTermination();
  669             return false;
  670         }
  671 
  672         m_node = m_highBlock-&gt;at(nodeIndex);
  673         m_origin = m_node-&gt;origin;
  674         m_out.setOrigin(m_node);
  675 
  676         if (verboseCompilationEnabled())
  677             dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  678 
  679         m_interpreter.startExecuting();
  680         m_interpreter.executeKnownEdgeTypes(m_node);
  681 
  682         if (Options::validateAbstractInterpreterState())
  683             validateAIState(m_node);
  684 
  685         if (validateDFGDoesGC) {
  686             bool expectDoesGC = doesGC(m_graph, m_node);
  687             m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
  688         }
  689 
  690         switch (m_node-&gt;op()) {
  691         case DFG::Upsilon:
  692             compileUpsilon();
  693             break;
  694         case DFG::Phi:
  695             compilePhi();
  696             break;
  697         case JSConstant:
  698             break;
  699         case DoubleConstant:
  700             compileDoubleConstant();
  701             break;
  702         case Int52Constant:
  703             compileInt52Constant();
  704             break;
  705         case LazyJSConstant:
  706             compileLazyJSConstant();
  707             break;
  708         case DoubleRep:
  709             compileDoubleRep();
  710             break;
  711         case DoubleAsInt32:
  712             compileDoubleAsInt32();
  713             break;
  714         case DFG::ValueRep:
  715             compileValueRep();
  716             break;
  717         case Int52Rep:
  718             compileInt52Rep();
  719             break;
  720         case ValueToInt32:
  721             compileValueToInt32();
  722             break;
  723         case BooleanToNumber:
  724             compileBooleanToNumber();
  725             break;
  726         case ExtractOSREntryLocal:
  727             compileExtractOSREntryLocal();
  728             break;
  729         case ExtractCatchLocal:
  730             compileExtractCatchLocal();
  731             break;
  732         case ClearCatchLocals:
  733             compileClearCatchLocals();
  734             break;
  735         case GetStack:
  736             compileGetStack();
  737             break;
  738         case PutStack:
  739             compilePutStack();
  740             break;
  741         case DFG::Check:
  742         case CheckVarargs:
  743             compileNoOp();
  744             break;
  745         case ToObject:
  746         case CallObjectConstructor:
  747             compileToObjectOrCallObjectConstructor();
  748             break;
  749         case ToThis:
  750             compileToThis();
  751             break;
  752         case ValueNegate:
  753             compileValueNegate();
  754             break;
  755         case ValueAdd:
  756             compileValueAdd();
  757             break;
  758         case ValueSub:
  759             compileValueSub();
  760             break;
  761         case ValueMul:
  762             compileValueMul();
  763             break;
  764         case StrCat:
  765             compileStrCat();
  766             break;
  767         case ArithAdd:
  768         case ArithSub:
  769             compileArithAddOrSub();
  770             break;
  771         case ArithClz32:
  772             compileArithClz32();
  773             break;
  774         case ArithMul:
  775             compileArithMul();
  776             break;
  777         case ValueDiv:
  778             compileValueDiv();
  779             break;
  780         case ArithDiv:
  781             compileArithDiv();
  782             break;
  783         case ValueMod:
  784             compileValueMod();
  785             break;
  786         case ArithMod:
  787             compileArithMod();
  788             break;
  789         case ArithMin:
  790         case ArithMax:
  791             compileArithMinOrMax();
  792             break;
  793         case ArithAbs:
  794             compileArithAbs();
  795             break;
  796         case ValuePow:
  797             compileValuePow();
  798             break;
  799         case ArithPow:
  800             compileArithPow();
  801             break;
  802         case ArithRandom:
  803             compileArithRandom();
  804             break;
  805         case ArithRound:
  806             compileArithRound();
  807             break;
  808         case ArithFloor:
  809             compileArithFloor();
  810             break;
  811         case ArithCeil:
  812             compileArithCeil();
  813             break;
  814         case ArithTrunc:
  815             compileArithTrunc();
  816             break;
  817         case ArithSqrt:
  818             compileArithSqrt();
  819             break;
  820         case ArithFRound:
  821             compileArithFRound();
  822             break;
  823         case ArithNegate:
  824             compileArithNegate();
  825             break;
  826         case ArithUnary:
  827             compileArithUnary();
  828             break;
  829         case ValueBitNot:
  830             compileValueBitNot();
  831             break;
  832         case ArithBitNot:
  833             compileArithBitNot();
  834             break;
  835         case ValueBitAnd:
  836             compileValueBitAnd();
  837             break;
  838         case ArithBitAnd:
  839             compileArithBitAnd();
  840             break;
  841         case ValueBitOr:
  842             compileValueBitOr();
  843             break;
  844         case ArithBitOr:
  845             compileArithBitOr();
  846             break;
  847         case ArithBitXor:
  848             compileArithBitXor();
  849             break;
  850         case ValueBitXor:
  851             compileValueBitXor();
  852             break;
  853         case BitRShift:
  854             compileBitRShift();
  855             break;
  856         case ArithBitLShift:
  857             compileArithBitLShift();
  858             break;
  859         case ValueBitLShift:
  860             compileValueBitLShift();
  861             break;
  862         case BitURShift:
  863             compileBitURShift();
  864             break;
  865         case UInt32ToNumber:
  866             compileUInt32ToNumber();
  867             break;
  868         case CheckStructure:
  869             compileCheckStructure();
  870             break;
  871         case CheckStructureOrEmpty:
  872             compileCheckStructureOrEmpty();
  873             break;
  874         case CheckCell:
  875             compileCheckCell();
  876             break;
  877         case CheckNotEmpty:
  878             compileCheckNotEmpty();
  879             break;
  880         case AssertNotEmpty:
  881             compileAssertNotEmpty();
  882             break;
  883         case CheckBadCell:
  884             compileCheckBadCell();
  885             break;
  886         case CheckStringIdent:
  887             compileCheckStringIdent();
  888             break;
  889         case GetExecutable:
  890             compileGetExecutable();
  891             break;
  892         case Arrayify:
  893         case ArrayifyToStructure:
  894             compileArrayify();
  895             break;
  896         case PutStructure:
  897             compilePutStructure();
  898             break;
  899         case TryGetById:
  900             compileGetById(AccessType::TryGet);
  901             break;
  902         case GetById:
  903         case GetByIdFlush:
  904             compileGetById(AccessType::Get);
  905             break;
  906         case GetByIdWithThis:
  907             compileGetByIdWithThis();
  908             break;
  909         case GetByIdDirect:
  910         case GetByIdDirectFlush:
  911             compileGetById(AccessType::GetDirect);
  912             break;
  913         case InById:
  914             compileInById();
  915             break;
  916         case InByVal:
  917             compileInByVal();
  918             break;
  919         case HasOwnProperty:
  920             compileHasOwnProperty();
  921             break;
  922         case PutById:
  923         case PutByIdDirect:
  924         case PutByIdFlush:
  925             compilePutById();
  926             break;
  927         case PutByIdWithThis:
  928             compilePutByIdWithThis();
  929             break;
  930         case PutGetterById:
  931         case PutSetterById:
  932             compilePutAccessorById();
  933             break;
  934         case PutGetterSetterById:
  935             compilePutGetterSetterById();
  936             break;
  937         case PutGetterByVal:
  938         case PutSetterByVal:
  939             compilePutAccessorByVal();
  940             break;
  941         case DeleteById:
  942             compileDeleteById();
  943             break;
  944         case DeleteByVal:
  945             compileDeleteByVal();
  946             break;
  947         case GetButterfly:
  948             compileGetButterfly();
  949             break;
  950         case ConstantStoragePointer:
  951             compileConstantStoragePointer();
  952             break;
  953         case GetIndexedPropertyStorage:
  954             compileGetIndexedPropertyStorage();
  955             break;
  956         case CheckArray:
  957             compileCheckArray();
  958             break;
  959         case GetArrayLength:
  960             compileGetArrayLength();
  961             break;
  962         case GetVectorLength:
  963             compileGetVectorLength();
  964             break;
  965         case CheckInBounds:
  966             compileCheckInBounds();
  967             break;
  968         case GetByVal:
  969             compileGetByVal();
  970             break;
  971         case GetMyArgumentByVal:
  972         case GetMyArgumentByValOutOfBounds:
  973             compileGetMyArgumentByVal();
  974             break;
  975         case GetByValWithThis:
  976             compileGetByValWithThis();
  977             break;
  978         case PutByVal:
  979         case PutByValAlias:
  980         case PutByValDirect:
  981             compilePutByVal();
  982             break;
  983         case PutByValWithThis:
  984             compilePutByValWithThis();
  985             break;
  986         case AtomicsAdd:
  987         case AtomicsAnd:
  988         case AtomicsCompareExchange:
  989         case AtomicsExchange:
  990         case AtomicsLoad:
  991         case AtomicsOr:
  992         case AtomicsStore:
  993         case AtomicsSub:
  994         case AtomicsXor:
  995             compileAtomicsReadModifyWrite();
  996             break;
  997         case AtomicsIsLockFree:
  998             compileAtomicsIsLockFree();
  999             break;
 1000         case DefineDataProperty:
 1001             compileDefineDataProperty();
 1002             break;
 1003         case DefineAccessorProperty:
 1004             compileDefineAccessorProperty();
 1005             break;
 1006         case ArrayPush:
 1007             compileArrayPush();
 1008             break;
 1009         case ArrayPop:
 1010             compileArrayPop();
 1011             break;
 1012         case ArraySlice:
 1013             compileArraySlice();
 1014             break;
 1015         case ArrayIndexOf:
 1016             compileArrayIndexOf();
 1017             break;
 1018         case CreateActivation:
 1019             compileCreateActivation();
 1020             break;
 1021         case PushWithScope:
 1022             compilePushWithScope();
 1023             break;
 1024         case NewFunction:
 1025         case NewGeneratorFunction:
 1026         case NewAsyncGeneratorFunction:
 1027         case NewAsyncFunction:
 1028             compileNewFunction();
 1029             break;
 1030         case CreateDirectArguments:
 1031             compileCreateDirectArguments();
 1032             break;
 1033         case CreateScopedArguments:
 1034             compileCreateScopedArguments();
 1035             break;
 1036         case CreateClonedArguments:
 1037             compileCreateClonedArguments();
 1038             break;
 1039         case ObjectCreate:
 1040             compileObjectCreate();
 1041             break;
 1042         case ObjectKeys:
 1043             compileObjectKeys();
 1044             break;
 1045         case NewObject:
 1046             compileNewObject();
 1047             break;
 1048         case NewStringObject:
 1049             compileNewStringObject();
 1050             break;
 1051         case NewSymbol:
 1052             compileNewSymbol();
 1053             break;
 1054         case NewArray:
 1055             compileNewArray();
 1056             break;
 1057         case NewArrayWithSpread:
 1058             compileNewArrayWithSpread();
 1059             break;
 1060         case CreateThis:
 1061             compileCreateThis();
 1062             break;
 1063         case Spread:
 1064             compileSpread();
 1065             break;
 1066         case NewArrayBuffer:
 1067             compileNewArrayBuffer();
 1068             break;
 1069         case NewArrayWithSize:
 1070             compileNewArrayWithSize();
 1071             break;
 1072         case NewTypedArray:
 1073             compileNewTypedArray();
 1074             break;
 1075         case GetTypedArrayByteOffset:
 1076             compileGetTypedArrayByteOffset();
 1077             break;
 1078         case GetPrototypeOf:
 1079             compileGetPrototypeOf();
 1080             break;
 1081         case AllocatePropertyStorage:
 1082             compileAllocatePropertyStorage();
 1083             break;
 1084         case ReallocatePropertyStorage:
 1085             compileReallocatePropertyStorage();
 1086             break;
 1087         case NukeStructureAndSetButterfly:
 1088             compileNukeStructureAndSetButterfly();
 1089             break;
 1090         case ToNumber:
 1091             compileToNumber();
 1092             break;
 1093         case ToString:
 1094         case CallStringConstructor:
 1095         case StringValueOf:
 1096             compileToStringOrCallStringConstructorOrStringValueOf();
 1097             break;
 1098         case ToPrimitive:
 1099             compileToPrimitive();
 1100             break;
 1101         case MakeRope:
 1102             compileMakeRope();
 1103             break;
 1104         case StringCharAt:
 1105             compileStringCharAt();
 1106             break;
 1107         case StringCharCodeAt:
 1108             compileStringCharCodeAt();
 1109             break;
 1110         case StringFromCharCode:
 1111             compileStringFromCharCode();
 1112             break;
 1113         case GetByOffset:
 1114         case GetGetterSetterByOffset:
 1115             compileGetByOffset();
 1116             break;
 1117         case GetGetter:
 1118             compileGetGetter();
 1119             break;
 1120         case GetSetter:
 1121             compileGetSetter();
 1122             break;
 1123         case MultiGetByOffset:
 1124             compileMultiGetByOffset();
 1125             break;
 1126         case PutByOffset:
 1127             compilePutByOffset();
 1128             break;
 1129         case MultiPutByOffset:
 1130             compileMultiPutByOffset();
 1131             break;
 1132         case MatchStructure:
 1133             compileMatchStructure();
 1134             break;
 1135         case GetGlobalVar:
 1136         case GetGlobalLexicalVariable:
 1137             compileGetGlobalVariable();
 1138             break;
 1139         case PutGlobalVariable:
 1140             compilePutGlobalVariable();
 1141             break;
 1142         case NotifyWrite:
 1143             compileNotifyWrite();
 1144             break;
 1145         case GetCallee:
 1146             compileGetCallee();
 1147             break;
 1148         case SetCallee:
 1149             compileSetCallee();
 1150             break;
 1151         case GetArgumentCountIncludingThis:
 1152             compileGetArgumentCountIncludingThis();
 1153             break;
 1154         case SetArgumentCountIncludingThis:
 1155             compileSetArgumentCountIncludingThis();
 1156             break;
 1157         case GetScope:
 1158             compileGetScope();
 1159             break;
 1160         case SkipScope:
 1161             compileSkipScope();
 1162             break;
 1163         case GetGlobalObject:
 1164             compileGetGlobalObject();
 1165             break;
 1166         case GetGlobalThis:
 1167             compileGetGlobalThis();
 1168             break;
 1169         case GetClosureVar:
 1170             compileGetClosureVar();
 1171             break;
 1172         case PutClosureVar:
 1173             compilePutClosureVar();
 1174             break;
 1175         case GetFromArguments:
 1176             compileGetFromArguments();
 1177             break;
 1178         case PutToArguments:
 1179             compilePutToArguments();
 1180             break;
 1181         case GetArgument:
 1182             compileGetArgument();
 1183             break;
 1184         case CompareEq:
 1185             compileCompareEq();
 1186             break;
 1187         case CompareStrictEq:
 1188             compileCompareStrictEq();
 1189             break;
 1190         case CompareLess:
 1191             compileCompareLess();
 1192             break;
 1193         case CompareLessEq:
 1194             compileCompareLessEq();
 1195             break;
 1196         case CompareGreater:
 1197             compileCompareGreater();
 1198             break;
 1199         case CompareGreaterEq:
 1200             compileCompareGreaterEq();
 1201             break;
 1202         case CompareBelow:
 1203             compileCompareBelow();
 1204             break;
 1205         case CompareBelowEq:
 1206             compileCompareBelowEq();
 1207             break;
 1208         case CompareEqPtr:
 1209             compileCompareEqPtr();
 1210             break;
 1211         case SameValue:
 1212             compileSameValue();
 1213             break;
 1214         case LogicalNot:
 1215             compileLogicalNot();
 1216             break;
 1217         case Call:
 1218         case TailCallInlinedCaller:
 1219         case Construct:
 1220             compileCallOrConstruct();
 1221             break;
 1222         case DirectCall:
 1223         case DirectTailCallInlinedCaller:
 1224         case DirectConstruct:
 1225         case DirectTailCall:
 1226             compileDirectCallOrConstruct();
 1227             break;
 1228         case TailCall:
 1229             compileTailCall();
 1230             break;
 1231         case CallVarargs:
 1232         case CallForwardVarargs:
 1233         case TailCallVarargs:
 1234         case TailCallVarargsInlinedCaller:
 1235         case TailCallForwardVarargs:
 1236         case TailCallForwardVarargsInlinedCaller:
 1237         case ConstructVarargs:
 1238         case ConstructForwardVarargs:
 1239             compileCallOrConstructVarargs();
 1240             break;
 1241         case CallEval:
 1242             compileCallEval();
 1243             break;
 1244         case LoadVarargs:
 1245             compileLoadVarargs();
 1246             break;
 1247         case ForwardVarargs:
 1248             compileForwardVarargs();
 1249             break;
 1250         case DFG::Jump:
 1251             compileJump();
 1252             break;
 1253         case DFG::Branch:
 1254             compileBranch();
 1255             break;
 1256         case DFG::Switch:
 1257             compileSwitch();
 1258             break;
 1259         case DFG::EntrySwitch:
 1260             compileEntrySwitch();
 1261             break;
 1262         case DFG::Return:
 1263             compileReturn();
 1264             break;
 1265         case ForceOSRExit:
 1266             compileForceOSRExit();
 1267             break;
 1268         case CPUIntrinsic:
 1269 #if CPU(X86_64)
 1270             compileCPUIntrinsic();
 1271 #else
 1272             RELEASE_ASSERT_NOT_REACHED();
 1273 #endif
 1274             break;
 1275         case Throw:
 1276             compileThrow();
 1277             break;
 1278         case ThrowStaticError:
 1279             compileThrowStaticError();
 1280             break;
 1281         case InvalidationPoint:
 1282             compileInvalidationPoint();
 1283             break;
 1284         case IsEmpty:
 1285             compileIsEmpty();
 1286             break;
 1287         case IsUndefined:
 1288             compileIsUndefined();
 1289             break;
 1290         case IsUndefinedOrNull:
 1291             compileIsUndefinedOrNull();
 1292             break;
 1293         case IsBoolean:
 1294             compileIsBoolean();
 1295             break;
 1296         case IsNumber:
 1297             compileIsNumber();
 1298             break;
 1299         case NumberIsInteger:
 1300             compileNumberIsInteger();
 1301             break;
 1302         case IsCellWithType:
 1303             compileIsCellWithType();
 1304             break;
 1305         case MapHash:
 1306             compileMapHash();
 1307             break;
 1308         case NormalizeMapKey:
 1309             compileNormalizeMapKey();
 1310             break;
 1311         case GetMapBucket:
 1312             compileGetMapBucket();
 1313             break;
 1314         case GetMapBucketHead:
 1315             compileGetMapBucketHead();
 1316             break;
 1317         case GetMapBucketNext:
 1318             compileGetMapBucketNext();
 1319             break;
 1320         case LoadKeyFromMapBucket:
 1321             compileLoadKeyFromMapBucket();
 1322             break;
 1323         case LoadValueFromMapBucket:
 1324             compileLoadValueFromMapBucket();
 1325             break;
 1326         case ExtractValueFromWeakMapGet:
 1327             compileExtractValueFromWeakMapGet();
 1328             break;
 1329         case SetAdd:
 1330             compileSetAdd();
 1331             break;
 1332         case MapSet:
 1333             compileMapSet();
 1334             break;
 1335         case WeakMapGet:
 1336             compileWeakMapGet();
 1337             break;
 1338         case WeakSetAdd:
 1339             compileWeakSetAdd();
 1340             break;
 1341         case WeakMapSet:
 1342             compileWeakMapSet();
 1343             break;
 1344         case IsObject:
 1345             compileIsObject();
 1346             break;
 1347         case IsObjectOrNull:
 1348             compileIsObjectOrNull();
 1349             break;
 1350         case IsFunction:
 1351             compileIsFunction();
 1352             break;
 1353         case IsTypedArrayView:
 1354             compileIsTypedArrayView();
 1355             break;
 1356         case ParseInt:
 1357             compileParseInt();
 1358             break;
 1359         case TypeOf:
 1360             compileTypeOf();
 1361             break;
 1362         case CheckTypeInfoFlags:
 1363             compileCheckTypeInfoFlags();
 1364             break;
 1365         case OverridesHasInstance:
 1366             compileOverridesHasInstance();
 1367             break;
 1368         case InstanceOf:
 1369             compileInstanceOf();
 1370             break;
 1371         case InstanceOfCustom:
 1372             compileInstanceOfCustom();
 1373             break;
 1374         case CountExecution:
 1375             compileCountExecution();
 1376             break;
 1377         case SuperSamplerBegin:
 1378             compileSuperSamplerBegin();
 1379             break;
 1380         case SuperSamplerEnd:
 1381             compileSuperSamplerEnd();
 1382             break;
 1383         case StoreBarrier:
 1384         case FencedStoreBarrier:
 1385             compileStoreBarrier();
 1386             break;
 1387         case HasIndexedProperty:
 1388             compileHasIndexedProperty();
 1389             break;
 1390         case HasGenericProperty:
 1391             compileHasGenericProperty();
 1392             break;
 1393         case HasStructureProperty:
 1394             compileHasStructureProperty();
 1395             break;
 1396         case GetDirectPname:
 1397             compileGetDirectPname();
 1398             break;
 1399         case GetEnumerableLength:
 1400             compileGetEnumerableLength();
 1401             break;
 1402         case GetPropertyEnumerator:
 1403             compileGetPropertyEnumerator();
 1404             break;
 1405         case GetEnumeratorStructurePname:
 1406             compileGetEnumeratorStructurePname();
 1407             break;
 1408         case GetEnumeratorGenericPname:
 1409             compileGetEnumeratorGenericPname();
 1410             break;
 1411         case ToIndexString:
 1412             compileToIndexString();
 1413             break;
 1414         case CheckStructureImmediate:
 1415             compileCheckStructureImmediate();
 1416             break;
 1417         case MaterializeNewObject:
 1418             compileMaterializeNewObject();
 1419             break;
 1420         case MaterializeCreateActivation:
 1421             compileMaterializeCreateActivation();
 1422             break;
 1423         case CheckTraps:
 1424             compileCheckTraps();
 1425             break;
 1426         case CreateRest:
 1427             compileCreateRest();
 1428             break;
 1429         case GetRestLength:
 1430             compileGetRestLength();
 1431             break;
 1432         case RegExpExec:
 1433             compileRegExpExec();
 1434             break;
 1435         case RegExpExecNonGlobalOrSticky:
 1436             compileRegExpExecNonGlobalOrSticky();
 1437             break;
 1438         case RegExpTest:
 1439             compileRegExpTest();
 1440             break;
 1441         case RegExpMatchFast:
 1442             compileRegExpMatchFast();
 1443             break;
 1444         case RegExpMatchFastGlobal:
 1445             compileRegExpMatchFastGlobal();
 1446             break;
 1447         case NewRegexp:
 1448             compileNewRegexp();
 1449             break;
 1450         case SetFunctionName:
 1451             compileSetFunctionName();
 1452             break;
 1453         case StringReplace:
 1454         case StringReplaceRegExp:
 1455             compileStringReplace();
 1456             break;
 1457         case GetRegExpObjectLastIndex:
 1458             compileGetRegExpObjectLastIndex();
 1459             break;
 1460         case SetRegExpObjectLastIndex:
 1461             compileSetRegExpObjectLastIndex();
 1462             break;
 1463         case LogShadowChickenPrologue:
 1464             compileLogShadowChickenPrologue();
 1465             break;
 1466         case LogShadowChickenTail:
 1467             compileLogShadowChickenTail();
 1468             break;
 1469         case RecordRegExpCachedResult:
 1470             compileRecordRegExpCachedResult();
 1471             break;
 1472         case ResolveScopeForHoistingFuncDeclInEval:
 1473             compileResolveScopeForHoistingFuncDeclInEval();
 1474             break;
 1475         case ResolveScope:
 1476             compileResolveScope();
 1477             break;
 1478         case GetDynamicVar:
 1479             compileGetDynamicVar();
 1480             break;
 1481         case PutDynamicVar:
 1482             compilePutDynamicVar();
 1483             break;
 1484         case Unreachable:
 1485             compileUnreachable();
 1486             break;
 1487         case StringSlice:
 1488             compileStringSlice();
 1489             break;
 1490         case ToLowerCase:
 1491             compileToLowerCase();
 1492             break;
 1493         case NumberToStringWithRadix:
 1494             compileNumberToStringWithRadix();
 1495             break;
 1496         case NumberToStringWithValidRadixConstant:
 1497             compileNumberToStringWithValidRadixConstant();
 1498             break;
 1499         case CheckSubClass:
 1500             compileCheckSubClass();
 1501             break;
 1502         case CallDOM:
 1503             compileCallDOM();
 1504             break;
 1505         case CallDOMGetter:
 1506             compileCallDOMGetter();
 1507             break;
 1508         case FilterCallLinkStatus:
 1509         case FilterGetByIdStatus:
 1510         case FilterPutByIdStatus:
 1511         case FilterInByIdStatus:
 1512             compileFilterICStatus();
 1513             break;
 1514         case DataViewGetInt:
 1515         case DataViewGetFloat:
 1516             compileDataViewGet();
 1517             break;
 1518         case DataViewSet:
 1519             compileDataViewSet();
 1520             break;
 1521 
 1522         case PhantomLocal:
 1523         case LoopHint:
 1524         case MovHint:
 1525         case ZombieHint:
 1526         case ExitOK:
 1527         case PhantomNewObject:
 1528         case PhantomNewFunction:
 1529         case PhantomNewGeneratorFunction:
 1530         case PhantomNewAsyncGeneratorFunction:
 1531         case PhantomNewAsyncFunction:
 1532         case PhantomCreateActivation:
 1533         case PhantomDirectArguments:
 1534         case PhantomCreateRest:
 1535         case PhantomSpread:
 1536         case PhantomNewArrayWithSpread:
 1537         case PhantomNewArrayBuffer:
 1538         case PhantomClonedArguments:
 1539         case PhantomNewRegexp:
 1540         case PutHint:
 1541         case BottomValue:
 1542         case KillStack:
 1543         case InitializeEntrypointArguments:
 1544             break;
 1545         default:
 1546             DFG_CRASH(m_graph, m_node, &quot;Unrecognized node in FTL backend&quot;);
 1547             break;
 1548         }
 1549 
 1550         if (m_node-&gt;isTerminal())
 1551             return false;
 1552 
 1553         if (!m_state.isValid()) {
 1554             safelyInvalidateAfterTermination();
 1555             return false;
 1556         }
 1557 
 1558         m_availabilityCalculator.executeNode(m_node);
 1559         m_interpreter.executeEffects(nodeIndex);
 1560 
 1561         return true;
 1562     }
 1563 
 1564     void compileUpsilon()
 1565     {
 1566         LValue upsilonValue = nullptr;
 1567         switch (m_node-&gt;child1().useKind()) {
 1568         case DoubleRepUse:
 1569             upsilonValue = lowDouble(m_node-&gt;child1());
 1570             break;
 1571         case Int32Use:
 1572         case KnownInt32Use:
 1573             upsilonValue = lowInt32(m_node-&gt;child1());
 1574             break;
 1575         case Int52RepUse:
 1576             upsilonValue = lowInt52(m_node-&gt;child1());
 1577             break;
 1578         case BooleanUse:
 1579         case KnownBooleanUse:
 1580             upsilonValue = lowBoolean(m_node-&gt;child1());
 1581             break;
 1582         case CellUse:
 1583         case KnownCellUse:
 1584             upsilonValue = lowCell(m_node-&gt;child1());
 1585             break;
 1586         case UntypedUse:
 1587             upsilonValue = lowJSValue(m_node-&gt;child1());
 1588             break;
 1589         default:
 1590             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1591             break;
 1592         }
 1593         ValueFromBlock upsilon = m_out.anchor(upsilonValue);
 1594         LValue phiNode = m_phis.get(m_node-&gt;phi());
 1595         m_out.addIncomingToPhi(phiNode, upsilon);
 1596     }
 1597 
 1598     void compilePhi()
 1599     {
 1600         LValue phi = m_phis.get(m_node);
 1601         m_out.m_block-&gt;append(phi);
 1602 
 1603         switch (m_node-&gt;flags() &amp; NodeResultMask) {
 1604         case NodeResultDouble:
 1605             setDouble(phi);
 1606             break;
 1607         case NodeResultInt32:
 1608             setInt32(phi);
 1609             break;
 1610         case NodeResultInt52:
 1611             setInt52(phi);
 1612             break;
 1613         case NodeResultBoolean:
 1614             setBoolean(phi);
 1615             break;
 1616         case NodeResultJS:
 1617             setJSValue(phi);
 1618             break;
 1619         default:
 1620             DFG_CRASH(m_graph, m_node, &quot;Bad result type&quot;);
 1621             break;
 1622         }
 1623     }
 1624 
 1625     void compileDoubleConstant()
 1626     {
 1627         setDouble(m_out.constDouble(m_node-&gt;asNumber()));
 1628     }
 1629 
 1630     void compileInt52Constant()
 1631     {
 1632         int64_t value = m_node-&gt;asAnyInt();
 1633 
 1634         setInt52(m_out.constInt64(value &lt;&lt; JSValue::int52ShiftAmount));
 1635         setStrictInt52(m_out.constInt64(value));
 1636     }
 1637 
 1638     void compileLazyJSConstant()
 1639     {
 1640         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 1641         LazyJSValue value = m_node-&gt;lazyJSValue();
 1642         patchpoint-&gt;setGenerator(
 1643             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 1644                 value.emit(jit, JSValueRegs(params[0].gpr()));
 1645             });
 1646         patchpoint-&gt;effects = Effects::none();
 1647         setJSValue(patchpoint);
 1648     }
 1649 
 1650     void compileDoubleRep()
 1651     {
 1652         switch (m_node-&gt;child1().useKind()) {
 1653         case RealNumberUse: {
 1654             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1655 
 1656             LValue doubleValue = unboxDouble(value);
 1657 
 1658             LBasicBlock intCase = m_out.newBlock();
 1659             LBasicBlock continuation = m_out.newBlock();
 1660 
 1661             ValueFromBlock fastResult = m_out.anchor(doubleValue);
 1662             m_out.branch(
 1663                 m_out.doubleEqual(doubleValue, doubleValue),
 1664                 usually(continuation), rarely(intCase));
 1665 
 1666             LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
 1667 
 1668             FTL_TYPE_CHECK(
 1669                 jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
 1670                 isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecDoubleReal));
 1671             ValueFromBlock slowResult = m_out.anchor(m_out.intToDouble(unboxInt32(value)));
 1672             m_out.jump(continuation);
 1673 
 1674             m_out.appendTo(continuation, lastNext);
 1675 
 1676             setDouble(m_out.phi(Double, fastResult, slowResult));
 1677             return;
 1678         }
 1679 
 1680         case NotCellUse:
 1681         case NumberUse: {
 1682             bool shouldConvertNonNumber = m_node-&gt;child1().useKind() == NotCellUse;
 1683 
 1684             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1685 
 1686             LBasicBlock intCase = m_out.newBlock();
 1687             LBasicBlock doubleTesting = m_out.newBlock();
 1688             LBasicBlock doubleCase = m_out.newBlock();
 1689             LBasicBlock nonDoubleCase = m_out.newBlock();
 1690             LBasicBlock continuation = m_out.newBlock();
 1691 
 1692             m_out.branch(
 1693                 isNotInt32(value, provenType(m_node-&gt;child1())),
 1694                 unsure(doubleTesting), unsure(intCase));
 1695 
 1696             LBasicBlock lastNext = m_out.appendTo(intCase, doubleTesting);
 1697 
 1698             ValueFromBlock intToDouble = m_out.anchor(
 1699                 m_out.intToDouble(unboxInt32(value)));
 1700             m_out.jump(continuation);
 1701 
 1702             m_out.appendTo(doubleTesting, doubleCase);
 1703             LValue valueIsNumber = isNumber(value, provenType(m_node-&gt;child1()));
 1704             m_out.branch(valueIsNumber, usually(doubleCase), rarely(nonDoubleCase));
 1705 
 1706             m_out.appendTo(doubleCase, nonDoubleCase);
 1707             ValueFromBlock unboxedDouble = m_out.anchor(unboxDouble(value));
 1708             m_out.jump(continuation);
 1709 
 1710             if (shouldConvertNonNumber) {
 1711                 LBasicBlock undefinedCase = m_out.newBlock();
 1712                 LBasicBlock testNullCase = m_out.newBlock();
 1713                 LBasicBlock nullCase = m_out.newBlock();
 1714                 LBasicBlock testBooleanTrueCase = m_out.newBlock();
 1715                 LBasicBlock convertBooleanTrueCase = m_out.newBlock();
 1716                 LBasicBlock convertBooleanFalseCase = m_out.newBlock();
 1717 
 1718                 m_out.appendTo(nonDoubleCase, undefinedCase);
 1719                 LValue valueIsUndefined = m_out.equal(value, m_out.constInt64(ValueUndefined));
 1720                 m_out.branch(valueIsUndefined, unsure(undefinedCase), unsure(testNullCase));
 1721 
 1722                 m_out.appendTo(undefinedCase, testNullCase);
 1723                 ValueFromBlock convertedUndefined = m_out.anchor(m_out.constDouble(PNaN));
 1724                 m_out.jump(continuation);
 1725 
 1726                 m_out.appendTo(testNullCase, nullCase);
 1727                 LValue valueIsNull = m_out.equal(value, m_out.constInt64(ValueNull));
 1728                 m_out.branch(valueIsNull, unsure(nullCase), unsure(testBooleanTrueCase));
 1729 
 1730                 m_out.appendTo(nullCase, testBooleanTrueCase);
 1731                 ValueFromBlock convertedNull = m_out.anchor(m_out.constDouble(0));
 1732                 m_out.jump(continuation);
 1733 
 1734                 m_out.appendTo(testBooleanTrueCase, convertBooleanTrueCase);
 1735                 LValue valueIsBooleanTrue = m_out.equal(value, m_out.constInt64(ValueTrue));
 1736                 m_out.branch(valueIsBooleanTrue, unsure(convertBooleanTrueCase), unsure(convertBooleanFalseCase));
 1737 
 1738                 m_out.appendTo(convertBooleanTrueCase, convertBooleanFalseCase);
 1739                 ValueFromBlock convertedTrue = m_out.anchor(m_out.constDouble(1));
 1740                 m_out.jump(continuation);
 1741 
 1742                 m_out.appendTo(convertBooleanFalseCase, continuation);
 1743 
 1744                 LValue valueIsNotBooleanFalse = m_out.notEqual(value, m_out.constInt64(ValueFalse));
 1745                 FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), ~SpecCellCheck, valueIsNotBooleanFalse);
 1746                 ValueFromBlock convertedFalse = m_out.anchor(m_out.constDouble(0));
 1747                 m_out.jump(continuation);
 1748 
 1749                 m_out.appendTo(continuation, lastNext);
 1750                 setDouble(m_out.phi(Double, intToDouble, unboxedDouble, convertedUndefined, convertedNull, convertedTrue, convertedFalse));
 1751                 return;
 1752             }
 1753             m_out.appendTo(nonDoubleCase, continuation);
 1754             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecBytecodeNumber, m_out.booleanTrue);
 1755             m_out.unreachable();
 1756 
 1757             m_out.appendTo(continuation, lastNext);
 1758 
 1759             setDouble(m_out.phi(Double, intToDouble, unboxedDouble));
 1760             return;
 1761         }
 1762 
 1763         case Int52RepUse: {
 1764             setDouble(strictInt52ToDouble(lowStrictInt52(m_node-&gt;child1())));
 1765             return;
 1766         }
 1767 
 1768         default:
 1769             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1770         }
 1771     }
 1772 
 1773     void compileDoubleAsInt32()
 1774     {
 1775         LValue integerValue = convertDoubleToInt32(lowDouble(m_node-&gt;child1()), shouldCheckNegativeZero(m_node-&gt;arithMode()));
 1776         setInt32(integerValue);
 1777     }
 1778 
 1779     void compileValueRep()
 1780     {
 1781         switch (m_node-&gt;child1().useKind()) {
 1782         case DoubleRepUse: {
 1783             LValue value = lowDouble(m_node-&gt;child1());
 1784 
 1785             if (m_interpreter.needsTypeCheck(m_node-&gt;child1(), ~SpecDoubleImpureNaN)) {
 1786                 value = m_out.select(
 1787                     m_out.doubleEqual(value, value), value, m_out.constDouble(PNaN));
 1788             }
 1789 
 1790             setJSValue(boxDouble(value));
 1791             return;
 1792         }
 1793 
 1794         case Int52RepUse: {
 1795             setJSValue(strictInt52ToJSValue(lowStrictInt52(m_node-&gt;child1())));
 1796             return;
 1797         }
 1798 
 1799         default:
 1800             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1801         }
 1802     }
 1803 
 1804     void compileInt52Rep()
 1805     {
 1806         switch (m_node-&gt;child1().useKind()) {
 1807         case Int32Use:
 1808             setStrictInt52(m_out.signExt32To64(lowInt32(m_node-&gt;child1())));
 1809             return;
 1810 
 1811         case AnyIntUse:
 1812             setStrictInt52(
 1813                 jsValueToStrictInt52(
 1814                     m_node-&gt;child1(), lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1815             return;
 1816 
 1817         case DoubleRepAnyIntUse:
 1818             setStrictInt52(
 1819                 doubleToStrictInt52(
 1820                     m_node-&gt;child1(), lowDouble(m_node-&gt;child1())));
 1821             return;
 1822 
 1823         default:
 1824             RELEASE_ASSERT_NOT_REACHED();
 1825         }
 1826     }
 1827 
 1828     void compileValueToInt32()
 1829     {
 1830         switch (m_node-&gt;child1().useKind()) {
 1831         case Int52RepUse:
 1832             setInt32(m_out.castToInt32(lowStrictInt52(m_node-&gt;child1())));
 1833             break;
 1834 
 1835         case DoubleRepUse:
 1836             setInt32(doubleToInt32(lowDouble(m_node-&gt;child1())));
 1837             break;
 1838 
 1839         case NumberUse:
 1840         case NotCellUse: {
 1841             LoweredNodeValue value = m_int32Values.get(m_node-&gt;child1().node());
 1842             if (isValid(value)) {
 1843                 setInt32(value.value());
 1844                 break;
 1845             }
 1846 
 1847             value = m_jsValueValues.get(m_node-&gt;child1().node());
 1848             if (isValid(value)) {
 1849                 setInt32(numberOrNotCellToInt32(m_node-&gt;child1(), value.value()));
 1850                 break;
 1851             }
 1852 
 1853             // We&#39;ll basically just get here for constants. But it&#39;s good to have this
 1854             // catch-all since we often add new representations into the mix.
 1855             setInt32(
 1856                 numberOrNotCellToInt32(
 1857                     m_node-&gt;child1(),
 1858                     lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1859             break;
 1860         }
 1861 
 1862         default:
 1863             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1864             break;
 1865         }
 1866     }
 1867 
 1868     void compileBooleanToNumber()
 1869     {
 1870         switch (m_node-&gt;child1().useKind()) {
 1871         case BooleanUse: {
 1872             setInt32(m_out.zeroExt(lowBoolean(m_node-&gt;child1()), Int32));
 1873             return;
 1874         }
 1875 
 1876         case UntypedUse: {
 1877             LValue value = lowJSValue(m_node-&gt;child1());
 1878 
 1879             if (!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
 1880                 setInt32(m_out.bitAnd(m_out.castToInt32(value), m_out.int32One));
 1881                 return;
 1882             }
 1883 
 1884             LBasicBlock booleanCase = m_out.newBlock();
 1885             LBasicBlock continuation = m_out.newBlock();
 1886 
 1887             ValueFromBlock notBooleanResult = m_out.anchor(value);
 1888             m_out.branch(
 1889                 isBoolean(value, provenType(m_node-&gt;child1())),
 1890                 unsure(booleanCase), unsure(continuation));
 1891 
 1892             LBasicBlock lastNext = m_out.appendTo(booleanCase, continuation);
 1893             ValueFromBlock booleanResult = m_out.anchor(m_out.bitOr(
 1894                 m_out.zeroExt(unboxBoolean(value), Int64), m_tagTypeNumber));
 1895             m_out.jump(continuation);
 1896 
 1897             m_out.appendTo(continuation, lastNext);
 1898             setJSValue(m_out.phi(Int64, booleanResult, notBooleanResult));
 1899             return;
 1900         }
 1901 
 1902         default:
 1903             RELEASE_ASSERT_NOT_REACHED();
 1904             return;
 1905         }
 1906     }
 1907 
 1908     void compileExtractOSREntryLocal()
 1909     {
 1910         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(
 1911             m_ftlState.jitCode-&gt;ftlForOSREntry()-&gt;entryBuffer()-&gt;dataBuffer());
 1912         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;unlinkedLocal().toLocal())));
 1913     }
 1914 
 1915     void compileExtractCatchLocal()
 1916     {
 1917         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(m_ftlState.jitCode-&gt;common.catchOSREntryBuffer-&gt;dataBuffer());
 1918         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;catchOSREntryIndex())));
 1919     }
 1920 
 1921     void compileClearCatchLocals()
 1922     {
 1923         ScratchBuffer* scratchBuffer = m_ftlState.jitCode-&gt;common.catchOSREntryBuffer;
 1924         ASSERT(scratchBuffer);
 1925         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 1926     }
 1927 
 1928     void compileGetStack()
 1929     {
 1930         StackAccessData* data = m_node-&gt;stackAccessData();
 1931         AbstractValue&amp; value = m_state.operand(data-&gt;local);
 1932 
 1933         DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
 1934 
 1935         switch (data-&gt;format) {
 1936         case FlushedDouble:
 1937             setDouble(m_out.loadDouble(addressFor(data-&gt;machineLocal)));
 1938             break;
 1939         case FlushedInt52:
 1940             setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
 1941             break;
 1942         default:
 1943             if (isInt32Speculation(value.m_type))
 1944                 setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));
 1945             else
 1946                 setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));
 1947             break;
 1948         }
 1949     }
 1950 
 1951     void compilePutStack()
 1952     {
 1953         StackAccessData* data = m_node-&gt;stackAccessData();
 1954         switch (data-&gt;format) {
 1955         case FlushedJSValue: {
 1956             LValue value = lowJSValue(m_node-&gt;child1());
 1957             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1958             break;
 1959         }
 1960 
 1961         case FlushedDouble: {
 1962             LValue value = lowDouble(m_node-&gt;child1());
 1963             m_out.storeDouble(value, addressFor(data-&gt;machineLocal));
 1964             break;
 1965         }
 1966 
 1967         case FlushedInt32: {
 1968             LValue value = lowInt32(m_node-&gt;child1());
 1969             m_out.store32(value, payloadFor(data-&gt;machineLocal));
 1970             break;
 1971         }
 1972 
 1973         case FlushedInt52: {
 1974             LValue value = lowInt52(m_node-&gt;child1());
 1975             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1976             break;
 1977         }
 1978 
 1979         case FlushedCell: {
 1980             LValue value = lowCell(m_node-&gt;child1());
 1981             m_out.store64(value, addressFor(data-&gt;machineLocal));
 1982             break;
 1983         }
 1984 
 1985         case FlushedBoolean: {
 1986             speculateBoolean(m_node-&gt;child1());
 1987             m_out.store64(
 1988                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 1989                 addressFor(data-&gt;machineLocal));
 1990             break;
 1991         }
 1992 
 1993         default:
 1994             DFG_CRASH(m_graph, m_node, &quot;Bad flush format&quot;);
 1995             break;
 1996         }
 1997     }
 1998 
 1999     void compileNoOp()
 2000     {
 2001         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, speculate);
 2002     }
 2003 
 2004     void compileToObjectOrCallObjectConstructor()
 2005     {
 2006         LValue value = lowJSValue(m_node-&gt;child1());
 2007 
 2008         LBasicBlock isCellCase = m_out.newBlock();
 2009         LBasicBlock slowCase = m_out.newBlock();
 2010         LBasicBlock continuation = m_out.newBlock();
 2011 
 2012         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 2013 
 2014         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 2015         ValueFromBlock fastResult = m_out.anchor(value);
 2016         m_out.branch(isObject(value), usually(continuation), rarely(slowCase));
 2017 
 2018         m_out.appendTo(slowCase, continuation);
 2019 
 2020         ValueFromBlock slowResult;
 2021         if (m_node-&gt;op() == ToObject) {
 2022             auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 2023             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToObject), m_callFrame, weakPointer(globalObject), value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 2024         } else
 2025             slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationCallObjectConstructor), m_callFrame, frozenPointer(m_node-&gt;cellOperand()), value));
 2026         m_out.jump(continuation);
 2027 
 2028         m_out.appendTo(continuation, lastNext);
 2029         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 2030     }
 2031 
 2032     void compileToThis()
 2033     {
 2034         LValue value = lowJSValue(m_node-&gt;child1());
 2035 
 2036         LBasicBlock isCellCase = m_out.newBlock();
 2037         LBasicBlock slowCase = m_out.newBlock();
 2038         LBasicBlock continuation = m_out.newBlock();
 2039 
 2040         m_out.branch(
 2041             isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 2042 
 2043         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 2044         ValueFromBlock fastResult = m_out.anchor(value);
 2045         m_out.branch(
 2046             m_out.testIsZero32(
 2047                 m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
 2048                 m_out.constInt32(OverridesToThis)),
 2049             usually(continuation), rarely(slowCase));
 2050 
 2051         m_out.appendTo(slowCase, continuation);
 2052         J_JITOperation_EJ function;
 2053         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 2054             function = operationToThisStrict;
 2055         else
 2056             function = operationToThis;
 2057         ValueFromBlock slowResult = m_out.anchor(
 2058             vmCall(Int64, m_out.operation(function), m_callFrame, value));
 2059         m_out.jump(continuation);
 2060 
 2061         m_out.appendTo(continuation, lastNext);
 2062         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 2063     }
 2064 
 2065     void compileValueAdd()
 2066     {
 2067         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2068             LValue left = lowBigInt(m_node-&gt;child1());
 2069             LValue right = lowBigInt(m_node-&gt;child2());
 2070 
 2071             LValue result = vmCall(pointerType(), m_out.operation(operationAddBigInt), m_callFrame, left, right);
 2072             setJSValue(result);
 2073             return;
 2074         }
 2075 
 2076         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
 2077         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();
 2078         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);
 2079         auto repatchingFunction = operationValueAddOptimize;
 2080         auto nonRepatchingFunction = operationValueAdd;
 2081         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2082     }
 2083 
 2084     void compileValueSub()
 2085     {
 2086         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2087             LValue left = lowBigInt(m_node-&gt;child1());
 2088             LValue right = lowBigInt(m_node-&gt;child2());
 2089 
 2090             LValue result = vmCall(pointerType(), m_out.operation(operationSubBigInt), m_callFrame, left, right);
 2091             setJSValue(result);
 2092             return;
 2093         }
 2094 
 2095         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
 2096         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();
 2097         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);
 2098         auto repatchingFunction = operationValueSubOptimize;
 2099         auto nonRepatchingFunction = operationValueSub;
 2100         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2101     }
 2102 
 2103     void compileValueMul()
 2104     {
 2105         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2106             LValue left = lowBigInt(m_node-&gt;child1());
 2107             LValue right = lowBigInt(m_node-&gt;child2());
 2108 
 2109             LValue result = vmCall(Int64, m_out.operation(operationMulBigInt), m_callFrame, left, right);
 2110             setJSValue(result);
 2111             return;
 2112         }
 2113 
 2114         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
 2115         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();
 2116         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);
 2117         auto repatchingFunction = operationValueMulOptimize;
 2118         auto nonRepatchingFunction = operationValueMul;
 2119         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2120     }
 2121 
 2122     template &lt;typename Generator, typename Func1, typename Func2,
 2123         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
 2124     void compileUnaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)
 2125     {
 2126         Node* node = m_node;
 2127 
 2128         LValue operand = lowJSValue(node-&gt;child1());
 2129 
 2130         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2131         patchpoint-&gt;appendSomeRegister(operand);
 2132         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2133         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2134         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 2135         patchpoint-&gt;numGPScratchRegisters = 1;
 2136         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2137         State* state = &amp;m_ftlState;
 2138         patchpoint-&gt;setGenerator(
 2139             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2140                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2141 
 2142                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2143                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2144 
 2145 #if ENABLE(MATH_IC_STATS)
 2146                 auto inlineStart = jit.label();
 2147 #endif
 2148 
 2149                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 2150                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);
 2151                 mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
 2152 
 2153                 bool shouldEmitProfiling = false;
 2154                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2155 
 2156                 if (generatedInline) {
 2157                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2158                     auto done = jit.label();
 2159                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2160                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2161                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2162                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2163 #if ENABLE(MATH_IC_STATS)
 2164                         auto slowPathStart = jit.label();
 2165 #endif
 2166 
 2167                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2168                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2169                                 repatchingFunction, params[0].gpr(), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2170                             mathICGenerationState-&gt;slowPathCall = call.call();
 2171                         } else {
 2172                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 2173                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2174                             mathICGenerationState-&gt;slowPathCall = call.call();
 2175                         }
 2176                         jit.jump().linkTo(done, &amp;jit);
 2177 
 2178                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2179                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2180                         });
 2181 
 2182 #if ENABLE(MATH_IC_STATS)
 2183                         auto slowPathEnd = jit.label();
 2184                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2185                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2186                             mathIC-&gt;m_generatedCodeSize += size;
 2187                         });
 2188 #endif
 2189                     });
 2190                 } else {
 2191                     callOperation(
 2192                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2193                         nonRepatchingFunction, params[0].gpr(), params[1].gpr());
 2194                 }
 2195 
 2196 #if ENABLE(MATH_IC_STATS)
 2197                 auto inlineEnd = jit.label();
 2198                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2199                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2200                     mathIC-&gt;m_generatedCodeSize += size;
 2201                 });
 2202 #endif
 2203             });
 2204 
 2205         setJSValue(patchpoint);
 2206     }
 2207 
 2208     template &lt;typename Generator, typename Func1, typename Func2,
 2209         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
 2210     void compileBinaryMathIC(ArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)
 2211     {
 2212         Node* node = m_node;
 2213 
 2214         LValue left = lowJSValue(node-&gt;child1());
 2215         LValue right = lowJSValue(node-&gt;child2());
 2216 
 2217         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
 2218         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
 2219 
 2220         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2221         patchpoint-&gt;appendSomeRegister(left);
 2222         patchpoint-&gt;appendSomeRegister(right);
 2223         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
 2224         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
 2225         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 2226             preparePatchpointForExceptions(patchpoint);
 2227         patchpoint-&gt;numGPScratchRegisters = 1;
 2228         patchpoint-&gt;numFPScratchRegisters = 2;
 2229         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2230         State* state = &amp;m_ftlState;
 2231         patchpoint-&gt;setGenerator(
 2232             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2233                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2234 
 2235 
 2236                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2237                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2238 
 2239 #if ENABLE(MATH_IC_STATS)
 2240                 auto inlineStart = jit.label();
 2241 #endif
 2242 
 2243                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 2244                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);
 2245                 mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
 2246                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
 2247                     params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
 2248 
 2249                 bool shouldEmitProfiling = false;
 2250                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2251 
 2252                 if (generatedInline) {
 2253                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2254                     auto done = jit.label();
 2255                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2256                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2257                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2258                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2259 #if ENABLE(MATH_IC_STATS)
 2260                         auto slowPathStart = jit.label();
 2261 #endif
 2262 
 2263                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2264                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2265                                 repatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr(), CCallHelpers::TrustedImmPtr(mathIC));
 2266                             mathICGenerationState-&gt;slowPathCall = call.call();
 2267                         } else {
 2268                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 2269                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());
 2270                             mathICGenerationState-&gt;slowPathCall = call.call();
 2271                         }
 2272                         jit.jump().linkTo(done, &amp;jit);
 2273 
 2274                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2275                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2276                         });
 2277 
 2278 #if ENABLE(MATH_IC_STATS)
 2279                         auto slowPathEnd = jit.label();
 2280                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2281                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2282                             mathIC-&gt;m_generatedCodeSize += size;
 2283                         });
 2284 #endif
 2285                     });
 2286                 } else {
 2287                     callOperation(
 2288                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
 2289                         nonRepatchingFunction, params[0].gpr(), params[1].gpr(), params[2].gpr());
 2290                 }
 2291 
 2292 #if ENABLE(MATH_IC_STATS)
 2293                 auto inlineEnd = jit.label();
 2294                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2295                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2296                     mathIC-&gt;m_generatedCodeSize += size;
 2297                 });
 2298 #endif
 2299             });
 2300 
 2301         setJSValue(patchpoint);
 2302     }
 2303 
 2304     void compileStrCat()
 2305     {
 2306         LValue result;
 2307         if (m_node-&gt;child3()) {
 2308             result = vmCall(
 2309                 Int64, m_out.operation(operationStrCat3), m_callFrame,
 2310                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2311                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation),
 2312                 lowJSValue(m_node-&gt;child3(), ManualOperandSpeculation));
 2313         } else {
 2314             result = vmCall(
 2315                 Int64, m_out.operation(operationStrCat2), m_callFrame,
 2316                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2317                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation));
 2318         }
 2319         setJSValue(result);
 2320     }
 2321 
 2322     void compileArithAddOrSub()
 2323     {
 2324         bool isSub =  m_node-&gt;op() == ArithSub;
 2325         switch (m_node-&gt;binaryUseKind()) {
 2326         case Int32Use: {
 2327             LValue left = lowInt32(m_node-&gt;child1());
 2328             LValue right = lowInt32(m_node-&gt;child2());
 2329 
 2330             if (!shouldCheckOverflow(m_node-&gt;arithMode())) {
 2331                 setInt32(isSub ? m_out.sub(left, right) : m_out.add(left, right));
 2332                 break;
 2333             }
 2334 
 2335             CheckValue* result =
 2336                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2337             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2338             setInt32(result);
 2339             break;
 2340         }
 2341 
 2342         case Int52RepUse: {
 2343             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)
 2344                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {
 2345                 Int52Kind kind;
 2346                 LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2347                 LValue right = lowInt52(m_node-&gt;child2(), kind);
 2348                 setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
 2349                 break;
 2350             }
 2351 
 2352             LValue left = lowInt52(m_node-&gt;child1());
 2353             LValue right = lowInt52(m_node-&gt;child2());
 2354             CheckValue* result =
 2355                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2356             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2357             setInt52(result);
 2358             break;
 2359         }
 2360 
 2361         case DoubleRepUse: {
 2362             LValue C1 = lowDouble(m_node-&gt;child1());
 2363             LValue C2 = lowDouble(m_node-&gt;child2());
 2364 
 2365             setDouble(isSub ? m_out.doubleSub(C1, C2) : m_out.doubleAdd(C1, C2));
 2366             break;
 2367         }
 2368 
 2369         case UntypedUse: {
 2370             if (!isSub) {
 2371                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2372                 break;
 2373             }
 2374 
 2375             CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
 2376             unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();
 2377             ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);
 2378             auto repatchingFunction = operationValueSubOptimize;
 2379             auto nonRepatchingFunction = operationValueSub;
 2380             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2381             break;
 2382         }
 2383 
 2384         default:
 2385             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2386             break;
 2387         }
 2388     }
 2389 
 2390     void compileArithClz32()
 2391     {
 2392         if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
 2393             LValue operand = lowInt32(m_node-&gt;child1());
 2394             setInt32(m_out.ctlz32(operand));
 2395             return;
 2396         }
 2397         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2398         LValue argument = lowJSValue(m_node-&gt;child1());
 2399         LValue result = vmCall(Int32, m_out.operation(operationArithClz32), m_callFrame, argument);
 2400         setInt32(result);
 2401     }
 2402 
 2403     void compileArithMul()
 2404     {
 2405         switch (m_node-&gt;binaryUseKind()) {
 2406         case Int32Use: {
 2407             LValue left = lowInt32(m_node-&gt;child1());
 2408             LValue right = lowInt32(m_node-&gt;child2());
 2409 
 2410             LValue result;
 2411 
 2412             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 2413                 result = m_out.mul(left, right);
 2414             else {
 2415                 CheckValue* speculation = m_out.speculateMul(left, right);
 2416                 blessSpeculation(speculation, Overflow, noValue(), nullptr, m_origin);
 2417                 result = speculation;
 2418             }
 2419 
 2420             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2421                 LBasicBlock slowCase = m_out.newBlock();
 2422                 LBasicBlock continuation = m_out.newBlock();
 2423 
 2424                 m_out.branch(
 2425                     m_out.notZero32(result), usually(continuation), rarely(slowCase));
 2426 
 2427                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2428                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int32Zero));
 2429                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int32Zero));
 2430                 m_out.jump(continuation);
 2431                 m_out.appendTo(continuation, lastNext);
 2432             }
 2433 
 2434             setInt32(result);
 2435             break;
 2436         }
 2437 
 2438         case Int52RepUse: {
 2439             Int52Kind kind;
 2440             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2441             LValue right = lowInt52(m_node-&gt;child2(), opposite(kind));
 2442 
 2443             CheckValue* result = m_out.speculateMul(left, right);
 2444             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2445 
 2446             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2447                 LBasicBlock slowCase = m_out.newBlock();
 2448                 LBasicBlock continuation = m_out.newBlock();
 2449 
 2450                 m_out.branch(
 2451                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 2452 
 2453                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2454                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int64Zero));
 2455                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int64Zero));
 2456                 m_out.jump(continuation);
 2457                 m_out.appendTo(continuation, lastNext);
 2458             }
 2459 
 2460             setInt52(result);
 2461             break;
 2462         }
 2463 
 2464         case DoubleRepUse: {
 2465             setDouble(
 2466                 m_out.doubleMul(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2467             break;
 2468         }
 2469 
 2470         default:
 2471             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2472             break;
 2473         }
 2474     }
 2475 
 2476     void compileValueDiv()
 2477     {
 2478         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2479             LValue left = lowBigInt(m_node-&gt;child1());
 2480             LValue right = lowBigInt(m_node-&gt;child2());
 2481 
 2482             LValue result = vmCall(pointerType(), m_out.operation(operationDivBigInt), m_callFrame, left, right);
 2483             setJSValue(result);
 2484             return;
 2485         }
 2486 
 2487         emitBinarySnippet&lt;JITDivGenerator, NeedScratchFPR&gt;(operationValueDiv);
 2488     }
 2489 
 2490     void compileArithDiv()
 2491     {
 2492         switch (m_node-&gt;binaryUseKind()) {
 2493         case Int32Use: {
 2494             LValue numerator = lowInt32(m_node-&gt;child1());
 2495             LValue denominator = lowInt32(m_node-&gt;child2());
 2496 
 2497             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2498                 LBasicBlock zeroNumerator = m_out.newBlock();
 2499                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2500 
 2501                 m_out.branch(
 2502                     m_out.isZero32(numerator),
 2503                     rarely(zeroNumerator), usually(numeratorContinuation));
 2504 
 2505                 LBasicBlock innerLastNext = m_out.appendTo(zeroNumerator, numeratorContinuation);
 2506 
 2507                 speculate(
 2508                     NegativeZero, noValue(), 0, m_out.lessThan(denominator, m_out.int32Zero));
 2509 
 2510                 m_out.jump(numeratorContinuation);
 2511 
 2512                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2513             }
 2514 
 2515             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2516                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2517                 LBasicBlock continuation = m_out.newBlock();
 2518 
 2519                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2520                 m_out.branch(
 2521                     m_out.above(adjustedDenominator, m_out.int32One),
 2522                     usually(continuation), rarely(unsafeDenominator));
 2523 
 2524                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2525                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2526                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2527                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2528                 m_out.jump(continuation);
 2529 
 2530                 m_out.appendTo(continuation, lastNext);
 2531                 LValue result = m_out.div(numerator, denominator);
 2532                 speculate(
 2533                     Overflow, noValue(), 0,
 2534                     m_out.notEqual(m_out.mul(result, denominator), numerator));
 2535                 setInt32(result);
 2536             } else
 2537                 setInt32(m_out.chillDiv(numerator, denominator));
 2538 
 2539             break;
 2540         }
 2541 
 2542         case DoubleRepUse: {
 2543             setDouble(m_out.doubleDiv(
 2544                 lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2545             break;
 2546         }
 2547 
 2548         default:
 2549             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2550             break;
 2551         }
 2552     }
 2553 
 2554     void compileValueMod()
 2555     {
 2556         if (m_node-&gt;binaryUseKind() == BigIntUse) {
 2557             LValue left = lowBigInt(m_node-&gt;child1());
 2558             LValue right = lowBigInt(m_node-&gt;child2());
 2559 
 2560             LValue result = vmCall(pointerType(), m_out.operation(operationModBigInt), m_callFrame, left, right);
 2561             setJSValue(result);
 2562             return;
 2563         }
 2564 
 2565         DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());
 2566         LValue left = lowJSValue(m_node-&gt;child1());
 2567         LValue right = lowJSValue(m_node-&gt;child2());
 2568         LValue result = vmCall(Int64, m_out.operation(operationValueMod), m_callFrame, left, right);
 2569         setJSValue(result);
 2570     }
 2571 
 2572     void compileArithMod()
 2573     {
 2574         switch (m_node-&gt;binaryUseKind()) {
 2575         case Int32Use: {
 2576             LValue numerator = lowInt32(m_node-&gt;child1());
 2577             LValue denominator = lowInt32(m_node-&gt;child2());
 2578 
 2579             LValue remainder;
 2580             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2581                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2582                 LBasicBlock continuation = m_out.newBlock();
 2583 
 2584                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2585                 m_out.branch(
 2586                     m_out.above(adjustedDenominator, m_out.int32One),
 2587                     usually(continuation), rarely(unsafeDenominator));
 2588 
 2589                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2590                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2591                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2592                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2593                 m_out.jump(continuation);
 2594 
 2595                 m_out.appendTo(continuation, lastNext);
 2596                 LValue result = m_out.mod(numerator, denominator);
 2597                 remainder = result;
 2598             } else
 2599                 remainder = m_out.chillMod(numerator, denominator);
 2600 
 2601             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2602                 LBasicBlock negativeNumerator = m_out.newBlock();
 2603                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2604 
 2605                 m_out.branch(
 2606                     m_out.lessThan(numerator, m_out.int32Zero),
 2607                     unsure(negativeNumerator), unsure(numeratorContinuation));
 2608 
 2609                 LBasicBlock innerLastNext = m_out.appendTo(negativeNumerator, numeratorContinuation);
 2610 
 2611                 speculate(NegativeZero, noValue(), 0, m_out.isZero32(remainder));
 2612 
 2613                 m_out.jump(numeratorContinuation);
 2614 
 2615                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2616             }
 2617 
 2618             setInt32(remainder);
 2619             break;
 2620         }
 2621 
 2622         case DoubleRepUse: {
 2623             setDouble(
 2624                 m_out.doubleMod(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2625             break;
 2626         }
 2627 
 2628         default:
 2629             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2630             break;
 2631         }
 2632     }
 2633 
 2634     void compileArithMinOrMax()
 2635     {
 2636         switch (m_node-&gt;binaryUseKind()) {
 2637         case Int32Use: {
 2638             LValue left = lowInt32(m_node-&gt;child1());
 2639             LValue right = lowInt32(m_node-&gt;child2());
 2640 
 2641             setInt32(
 2642                 m_out.select(
 2643                     m_node-&gt;op() == ArithMin
 2644                         ? m_out.lessThan(left, right)
 2645                         : m_out.lessThan(right, left),
 2646                     left, right));
 2647             break;
 2648         }
 2649 
 2650         case DoubleRepUse: {
 2651             LValue left = lowDouble(m_node-&gt;child1());
 2652             LValue right = lowDouble(m_node-&gt;child2());
 2653 
 2654             LBasicBlock notLessThan = m_out.newBlock();
 2655             LBasicBlock continuation = m_out.newBlock();
 2656 
 2657             Vector&lt;ValueFromBlock, 2&gt; results;
 2658 
 2659             results.append(m_out.anchor(left));
 2660             m_out.branch(
 2661                 m_node-&gt;op() == ArithMin
 2662                     ? m_out.doubleLessThan(left, right)
 2663                     : m_out.doubleGreaterThan(left, right),
 2664                 unsure(continuation), unsure(notLessThan));
 2665 
 2666             LBasicBlock lastNext = m_out.appendTo(notLessThan, continuation);
 2667             results.append(m_out.anchor(m_out.select(
 2668                 m_node-&gt;op() == ArithMin
 2669                     ? m_out.doubleGreaterThanOrEqual(left, right)
 2670                     : m_out.doubleLessThanOrEqual(left, right),
 2671                 right, m_out.constDouble(PNaN))));
 2672             m_out.jump(continuation);
 2673 
 2674             m_out.appendTo(continuation, lastNext);
 2675             setDouble(m_out.phi(Double, results));
 2676             break;
 2677         }
 2678 
 2679         default:
 2680             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2681             break;
 2682         }
 2683     }
 2684 
 2685     void compileArithAbs()
 2686     {
 2687         switch (m_node-&gt;child1().useKind()) {
 2688         case Int32Use: {
 2689             LValue value = lowInt32(m_node-&gt;child1());
 2690 
 2691             LValue mask = m_out.aShr(value, m_out.constInt32(31));
 2692             LValue result = m_out.bitXor(mask, m_out.add(mask, value));
 2693 
 2694             if (shouldCheckOverflow(m_node-&gt;arithMode()))
 2695                 speculate(Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
 2696 
 2697             setInt32(result);
 2698             break;
 2699         }
 2700 
 2701         case DoubleRepUse: {
 2702             setDouble(m_out.doubleAbs(lowDouble(m_node-&gt;child1())));
 2703             break;
 2704         }
 2705 
 2706         default: {
 2707             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2708             LValue argument = lowJSValue(m_node-&gt;child1());
 2709             LValue result = vmCall(Double, m_out.operation(operationArithAbs), m_callFrame, argument);
 2710             setDouble(result);
 2711             break;
 2712         }
 2713         }
 2714     }
 2715 
 2716     void compileArithUnary()
 2717     {
 2718         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2719             setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
 2720             return;
 2721         }
 2722         LValue argument = lowJSValue(m_node-&gt;child1());
 2723         LValue result = vmCall(Double, m_out.operation(DFG::arithUnaryOperation(m_node-&gt;arithUnaryType())), m_callFrame, argument);
 2724         setDouble(result);
 2725     }
 2726 
 2727     void compileValuePow()
 2728     {
 2729         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2730             LValue base = lowBigInt(m_node-&gt;child1());
 2731             LValue exponent = lowBigInt(m_node-&gt;child2());
 2732 
 2733             LValue result = vmCall(pointerType(), m_out.operation(operationPowBigInt), m_callFrame, base, exponent);
 2734             setJSValue(result);
 2735             return;
 2736         }
 2737 
 2738         LValue base = lowJSValue(m_node-&gt;child1());
 2739         LValue exponent = lowJSValue(m_node-&gt;child2());
 2740         LValue result = vmCall(Int64, m_out.operation(operationValuePow), m_callFrame, base, exponent);
 2741         setJSValue(result);
 2742     }
 2743 
 2744     void compileArithPow()
 2745     {
 2746         if (m_node-&gt;child2().useKind() == Int32Use)
 2747             setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2748         else {
 2749             LValue base = lowDouble(m_node-&gt;child1());
 2750             LValue exponent = lowDouble(m_node-&gt;child2());
 2751 
 2752             LBasicBlock integerExponentIsSmallBlock = m_out.newBlock();
 2753             LBasicBlock integerExponentPowBlock = m_out.newBlock();
 2754             LBasicBlock doubleExponentPowBlockEntry = m_out.newBlock();
 2755             LBasicBlock nanExceptionBaseIsOne = m_out.newBlock();
 2756             LBasicBlock nanExceptionExponentIsInfinity = m_out.newBlock();
 2757             LBasicBlock testExponentIsOneHalf = m_out.newBlock();
 2758             LBasicBlock handleBaseZeroExponentIsOneHalf = m_out.newBlock();
 2759             LBasicBlock handleInfinityForExponentIsOneHalf = m_out.newBlock();
 2760             LBasicBlock exponentIsOneHalfNormal = m_out.newBlock();
 2761             LBasicBlock exponentIsOneHalfInfinity = m_out.newBlock();
 2762             LBasicBlock testExponentIsNegativeOneHalf = m_out.newBlock();
 2763             LBasicBlock testBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2764             LBasicBlock handleBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2765             LBasicBlock handleInfinityForExponentIsNegativeOneHalf = m_out.newBlock();
 2766             LBasicBlock exponentIsNegativeOneHalfNormal = m_out.newBlock();
 2767             LBasicBlock exponentIsNegativeOneHalfInfinity = m_out.newBlock();
 2768             LBasicBlock powBlock = m_out.newBlock();
 2769             LBasicBlock nanExceptionResultIsNaN = m_out.newBlock();
 2770             LBasicBlock continuation = m_out.newBlock();
 2771 
 2772             LValue integerExponent = m_out.doubleToInt(exponent);
 2773             LValue integerExponentConvertedToDouble = m_out.intToDouble(integerExponent);
 2774             LValue exponentIsInteger = m_out.doubleEqual(exponent, integerExponentConvertedToDouble);
 2775             m_out.branch(exponentIsInteger, unsure(integerExponentIsSmallBlock), unsure(doubleExponentPowBlockEntry));
 2776 
 2777             LBasicBlock lastNext = m_out.appendTo(integerExponentIsSmallBlock, integerExponentPowBlock);
 2778             LValue integerExponentBelowMax = m_out.belowOrEqual(integerExponent, m_out.constInt32(maxExponentForIntegerMathPow));
 2779             m_out.branch(integerExponentBelowMax, usually(integerExponentPowBlock), rarely(doubleExponentPowBlockEntry));
 2780 
 2781             m_out.appendTo(integerExponentPowBlock, doubleExponentPowBlockEntry);
 2782             ValueFromBlock powDoubleIntResult = m_out.anchor(m_out.doublePowi(base, integerExponent));
 2783             m_out.jump(continuation);
 2784 
 2785             // If y is NaN, the result is NaN.
 2786             m_out.appendTo(doubleExponentPowBlockEntry, nanExceptionBaseIsOne);
 2787             LValue exponentIsNaN;
 2788             if (provenType(m_node-&gt;child2()) &amp; SpecDoubleNaN)
 2789                 exponentIsNaN = m_out.doubleNotEqualOrUnordered(exponent, exponent);
 2790             else
 2791                 exponentIsNaN = m_out.booleanFalse;
 2792             m_out.branch(exponentIsNaN, rarely(nanExceptionResultIsNaN), usually(nanExceptionBaseIsOne));
 2793 
 2794             // If abs(x) is 1 and y is +infinity, the result is NaN.
 2795             // If abs(x) is 1 and y is -infinity, the result is NaN.
 2796 
 2797             //     Test if base == 1.
 2798             m_out.appendTo(nanExceptionBaseIsOne, nanExceptionExponentIsInfinity);
 2799             LValue absoluteBase = m_out.doubleAbs(base);
 2800             LValue absoluteBaseIsOne = m_out.doubleEqual(absoluteBase, m_out.constDouble(1));
 2801             m_out.branch(absoluteBaseIsOne, rarely(nanExceptionExponentIsInfinity), usually(testExponentIsOneHalf));
 2802 
 2803             //     Test if abs(y) == Infinity.
 2804             m_out.appendTo(nanExceptionExponentIsInfinity, testExponentIsOneHalf);
 2805             LValue absoluteExponent = m_out.doubleAbs(exponent);
 2806             LValue absoluteExponentIsInfinity = m_out.doubleEqual(absoluteExponent, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2807             m_out.branch(absoluteExponentIsInfinity, rarely(nanExceptionResultIsNaN), usually(testExponentIsOneHalf));
 2808 
 2809             // If y == 0.5 or y == -0.5, handle it through SQRT.
 2810             // We have be carefuly with -0 and -Infinity.
 2811 
 2812             //     Test if y == 0.5
 2813             m_out.appendTo(testExponentIsOneHalf, handleBaseZeroExponentIsOneHalf);
 2814             LValue exponentIsOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(0.5));
 2815             m_out.branch(exponentIsOneHalf, rarely(handleBaseZeroExponentIsOneHalf), usually(testExponentIsNegativeOneHalf));
 2816 
 2817             //     Handle x == -0.
 2818             m_out.appendTo(handleBaseZeroExponentIsOneHalf, handleInfinityForExponentIsOneHalf);
 2819             LValue baseIsZeroExponentIsOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2820             ValueFromBlock zeroResultExponentIsOneHalf = m_out.anchor(m_out.doubleZero);
 2821             m_out.branch(baseIsZeroExponentIsOneHalf, rarely(continuation), usually(handleInfinityForExponentIsOneHalf));
 2822 
 2823             //     Test if abs(x) == Infinity.
 2824             m_out.appendTo(handleInfinityForExponentIsOneHalf, exponentIsOneHalfNormal);
 2825             LValue absoluteBaseIsInfinityOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2826             m_out.branch(absoluteBaseIsInfinityOneHalf, rarely(exponentIsOneHalfInfinity), usually(exponentIsOneHalfNormal));
 2827 
 2828             //     The exponent is 0.5, the base is finite or NaN, we can use SQRT.
 2829             m_out.appendTo(exponentIsOneHalfNormal, exponentIsOneHalfInfinity);
 2830             ValueFromBlock sqrtResult = m_out.anchor(m_out.doubleSqrt(base));
 2831             m_out.jump(continuation);
 2832 
 2833             //     The exponent is 0.5, the base is infinite, the result is always infinite.
 2834             m_out.appendTo(exponentIsOneHalfInfinity, testExponentIsNegativeOneHalf);
 2835             ValueFromBlock sqrtInfinityResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2836             m_out.jump(continuation);
 2837 
 2838             //     Test if y == -0.5
 2839             m_out.appendTo(testExponentIsNegativeOneHalf, testBaseZeroExponentIsNegativeOneHalf);
 2840             LValue exponentIsNegativeOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(-0.5));
 2841             m_out.branch(exponentIsNegativeOneHalf, rarely(testBaseZeroExponentIsNegativeOneHalf), usually(powBlock));
 2842 
 2843             //     Handle x == -0.
 2844             m_out.appendTo(testBaseZeroExponentIsNegativeOneHalf, handleBaseZeroExponentIsNegativeOneHalf);
 2845             LValue baseIsZeroExponentIsNegativeOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2846             m_out.branch(baseIsZeroExponentIsNegativeOneHalf, rarely(handleBaseZeroExponentIsNegativeOneHalf), usually(handleInfinityForExponentIsNegativeOneHalf));
 2847 
 2848             m_out.appendTo(handleBaseZeroExponentIsNegativeOneHalf, handleInfinityForExponentIsNegativeOneHalf);
 2849             ValueFromBlock oneOverSqrtZeroResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2850             m_out.jump(continuation);
 2851 
 2852             //     Test if abs(x) == Infinity.
 2853             m_out.appendTo(handleInfinityForExponentIsNegativeOneHalf, exponentIsNegativeOneHalfNormal);
 2854             LValue absoluteBaseIsInfinityNegativeOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2855             m_out.branch(absoluteBaseIsInfinityNegativeOneHalf, rarely(exponentIsNegativeOneHalfInfinity), usually(exponentIsNegativeOneHalfNormal));
 2856 
 2857             //     The exponent is -0.5, the base is finite or NaN, we can use 1/SQRT.
 2858             m_out.appendTo(exponentIsNegativeOneHalfNormal, exponentIsNegativeOneHalfInfinity);
 2859             LValue sqrtBase = m_out.doubleSqrt(base);
 2860             ValueFromBlock oneOverSqrtResult = m_out.anchor(m_out.div(m_out.constDouble(1.), sqrtBase));
 2861             m_out.jump(continuation);
 2862 
 2863             //     The exponent is -0.5, the base is infinite, the result is always zero.
 2864             m_out.appendTo(exponentIsNegativeOneHalfInfinity, powBlock);
 2865             ValueFromBlock oneOverSqrtInfinityResult = m_out.anchor(m_out.doubleZero);
 2866             m_out.jump(continuation);
 2867 
 2868             m_out.appendTo(powBlock, nanExceptionResultIsNaN);
 2869             ValueFromBlock powResult = m_out.anchor(m_out.doublePow(base, exponent));
 2870             m_out.jump(continuation);
 2871 
 2872             m_out.appendTo(nanExceptionResultIsNaN, continuation);
 2873             ValueFromBlock pureNan = m_out.anchor(m_out.constDouble(PNaN));
 2874             m_out.jump(continuation);
 2875 
 2876             m_out.appendTo(continuation, lastNext);
 2877             setDouble(m_out.phi(Double, powDoubleIntResult, zeroResultExponentIsOneHalf, sqrtResult, sqrtInfinityResult, oneOverSqrtZeroResult, oneOverSqrtResult, oneOverSqrtInfinityResult, powResult, pureNan));
 2878         }
 2879     }
 2880 
 2881     void compileArithRandom()
 2882     {
 2883         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 2884 
 2885         // Inlined WeakRandom::advance().
 2886         // uint64_t x = m_low;
 2887         void* lowAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::lowOffset();
 2888         LValue low = m_out.load64(m_out.absolute(lowAddress));
 2889         // uint64_t y = m_high;
 2890         void* highAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::highOffset();
 2891         LValue high = m_out.load64(m_out.absolute(highAddress));
 2892         // m_low = y;
 2893         m_out.store64(high, m_out.absolute(lowAddress));
 2894 
 2895         // x ^= x &lt;&lt; 23;
 2896         LValue phase1 = m_out.bitXor(m_out.shl(low, m_out.constInt64(23)), low);
 2897 
 2898         // x ^= x &gt;&gt; 17;
 2899         LValue phase2 = m_out.bitXor(m_out.lShr(phase1, m_out.constInt64(17)), phase1);
 2900 
 2901         // x ^= y ^ (y &gt;&gt; 26);
 2902         LValue phase3 = m_out.bitXor(m_out.bitXor(high, m_out.lShr(high, m_out.constInt64(26))), phase2);
 2903 
 2904         // m_high = x;
 2905         m_out.store64(phase3, m_out.absolute(highAddress));
 2906 
 2907         // return x + y;
 2908         LValue random64 = m_out.add(phase3, high);
 2909 
 2910         // Extract random 53bit. [0, 53] bit is safe integer number ranges in double representation.
 2911         LValue random53 = m_out.bitAnd(random64, m_out.constInt64((1ULL &lt;&lt; 53) - 1));
 2912 
 2913         LValue double53Integer = m_out.intToDouble(random53);
 2914 
 2915         // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
 2916         // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
 2917         static const double scale = 1.0 / (1ULL &lt;&lt; 53);
 2918 
 2919         // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
 2920         // It just reduces the exp part of the given 53bit double integer.
 2921         // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
 2922         // Now we get 53bit precision random double value in [0, 1).
 2923         LValue result = m_out.doubleMul(double53Integer, m_out.constDouble(scale));
 2924 
 2925         setDouble(result);
 2926     }
 2927 
 2928     void compileArithRound()
 2929     {
 2930         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2931             LValue result = nullptr;
 2932             if (producesInteger(m_node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())) {
 2933                 LValue value = lowDouble(m_node-&gt;child1());
 2934                 result = m_out.doubleFloor(m_out.doubleAdd(value, m_out.constDouble(0.5)));
 2935             } else {
 2936                 LBasicBlock realPartIsMoreThanHalf = m_out.newBlock();
 2937                 LBasicBlock continuation = m_out.newBlock();
 2938 
 2939                 LValue value = lowDouble(m_node-&gt;child1());
 2940                 LValue integerValue = m_out.doubleCeil(value);
 2941                 ValueFromBlock integerValueResult = m_out.anchor(integerValue);
 2942 
 2943                 LValue realPart = m_out.doubleSub(integerValue, value);
 2944 
 2945                 m_out.branch(m_out.doubleGreaterThanOrUnordered(realPart, m_out.constDouble(0.5)), unsure(realPartIsMoreThanHalf), unsure(continuation));
 2946 
 2947                 LBasicBlock lastNext = m_out.appendTo(realPartIsMoreThanHalf, continuation);
 2948                 LValue integerValueRoundedDown = m_out.doubleSub(integerValue, m_out.constDouble(1));
 2949                 ValueFromBlock integerValueRoundedDownResult = m_out.anchor(integerValueRoundedDown);
 2950                 m_out.jump(continuation);
 2951                 m_out.appendTo(continuation, lastNext);
 2952 
 2953                 result = m_out.phi(Double, integerValueResult, integerValueRoundedDownResult);
 2954             }
 2955 
 2956             if (producesInteger(m_node-&gt;arithRoundingMode())) {
 2957                 LValue integerValue = convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode()));
 2958                 setInt32(integerValue);
 2959             } else
 2960                 setDouble(result);
 2961             return;
 2962         }
 2963 
 2964         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2965         LValue argument = lowJSValue(m_node-&gt;child1());
 2966         setJSValue(vmCall(Int64, m_out.operation(operationArithRound), m_callFrame, argument));
 2967     }
 2968 
 2969     void compileArithFloor()
 2970     {
 2971         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2972             LValue value = lowDouble(m_node-&gt;child1());
 2973             LValue integerValue = m_out.doubleFloor(value);
 2974             if (producesInteger(m_node-&gt;arithRoundingMode()))
 2975                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 2976             else
 2977                 setDouble(integerValue);
 2978             return;
 2979         }
 2980         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2981         LValue argument = lowJSValue(m_node-&gt;child1());
 2982         setJSValue(vmCall(Int64, m_out.operation(operationArithFloor), m_callFrame, argument));
 2983     }
 2984 
 2985     void compileArithCeil()
 2986     {
 2987         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2988             LValue value = lowDouble(m_node-&gt;child1());
 2989             LValue integerValue = m_out.doubleCeil(value);
 2990             if (producesInteger(m_node-&gt;arithRoundingMode()))
 2991                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 2992             else
 2993                 setDouble(integerValue);
 2994             return;
 2995         }
 2996         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2997         LValue argument = lowJSValue(m_node-&gt;child1());
 2998         setJSValue(vmCall(Int64, m_out.operation(operationArithCeil), m_callFrame, argument));
 2999     }
 3000 
 3001     void compileArithTrunc()
 3002     {
 3003         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3004             LValue value = lowDouble(m_node-&gt;child1());
 3005             LValue result = m_out.doubleTrunc(value);
 3006             if (producesInteger(m_node-&gt;arithRoundingMode()))
 3007                 setInt32(convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 3008             else
 3009                 setDouble(result);
 3010             return;
 3011         }
 3012         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 3013         LValue argument = lowJSValue(m_node-&gt;child1());
 3014         setJSValue(vmCall(Int64, m_out.operation(operationArithTrunc), m_callFrame, argument));
 3015     }
 3016 
 3017     void compileArithSqrt()
 3018     {
 3019         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3020             setDouble(m_out.doubleSqrt(lowDouble(m_node-&gt;child1())));
 3021             return;
 3022         }
 3023         LValue argument = lowJSValue(m_node-&gt;child1());
 3024         LValue result = vmCall(Double, m_out.operation(operationArithSqrt), m_callFrame, argument);
 3025         setDouble(result);
 3026     }
 3027 
 3028     void compileArithFRound()
 3029     {
 3030         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3031             setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
 3032             return;
 3033         }
 3034         LValue argument = lowJSValue(m_node-&gt;child1());
 3035         LValue result = vmCall(Double, m_out.operation(operationArithFRound), m_callFrame, argument);
 3036         setDouble(result);
 3037     }
 3038 
 3039     void compileValueNegate()
 3040     {
 3041         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
 3042         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
 3043         unsigned bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();
 3044         ArithProfile* arithProfile = baselineCodeBlock-&gt;arithProfileForBytecodeOffset(bytecodeIndex);
 3045         auto repatchingFunction = operationArithNegateOptimize;
 3046         auto nonRepatchingFunction = operationArithNegate;
 3047         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 3048     }
 3049 
 3050     void compileArithNegate()
 3051     {
 3052         switch (m_node-&gt;child1().useKind()) {
 3053         case Int32Use: {
 3054             LValue value = lowInt32(m_node-&gt;child1());
 3055 
 3056             LValue result;
 3057             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 3058                 result = m_out.neg(value);
 3059             else if (!shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 3060                 CheckValue* check = m_out.speculateSub(m_out.int32Zero, value);
 3061                 blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 3062                 result = check;
 3063             } else {
 3064                 speculate(Overflow, noValue(), 0, m_out.testIsZero32(value, m_out.constInt32(0x7fffffff)));
 3065                 result = m_out.neg(value);
 3066             }
 3067 
 3068             setInt32(result);
 3069             break;
 3070         }
 3071 
 3072         case Int52RepUse: {
 3073             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {
 3074                 Int52Kind kind;
 3075                 LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
 3076                 LValue result = m_out.neg(value);
 3077                 if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3078                     speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3079                 setInt52(result, kind);
 3080                 break;
 3081             }
 3082 
 3083             LValue value = lowInt52(m_node-&gt;child1());
 3084             CheckValue* result = m_out.speculateSub(m_out.int64Zero, value);
 3085             blessSpeculation(result, Int52Overflow, noValue(), nullptr, m_origin);
 3086             if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3087                 speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3088             setInt52(result);
 3089             break;
 3090         }
 3091 
 3092         case DoubleRepUse: {
 3093             setDouble(m_out.doubleNeg(lowDouble(m_node-&gt;child1())));
 3094             break;
 3095         }
 3096 
 3097         default:
 3098             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3099             break;
 3100         }
 3101     }
 3102 
 3103     void compileValueBitNot()
 3104     {
 3105         if (m_node-&gt;child1().useKind() == BigIntUse) {
 3106             LValue operand = lowBigInt(m_node-&gt;child1());
 3107             LValue result = vmCall(pointerType(), m_out.operation(operationBitNotBigInt), m_callFrame, operand);
 3108             setJSValue(result);
 3109             return;
 3110         }
 3111 
 3112         LValue operand = lowJSValue(m_node-&gt;child1());
 3113         LValue result = vmCall(Int64, m_out.operation(operationValueBitNot), m_callFrame, operand);
 3114         setJSValue(result);
 3115     }
 3116 
 3117     void compileArithBitNot()
 3118     {
 3119         setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
 3120     }
 3121 
 3122     void compileValueBitAnd()
 3123     {
 3124         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3125             LValue left = lowBigInt(m_node-&gt;child1());
 3126             LValue right = lowBigInt(m_node-&gt;child2());
 3127 
 3128             LValue result = vmCall(pointerType(), m_out.operation(operationBitAndBigInt), m_callFrame, left, right);
 3129             setJSValue(result);
 3130             return;
 3131         }
 3132 
 3133         emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
 3134     }
 3135 
 3136     void compileArithBitAnd()
 3137     {
 3138         setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3139     }
 3140 
 3141     void compileValueBitOr()
 3142     {
 3143         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3144             LValue left = lowBigInt(m_node-&gt;child1());
 3145             LValue right = lowBigInt(m_node-&gt;child2());
 3146 
 3147             LValue result = vmCall(pointerType(), m_out.operation(operationBitOrBigInt), m_callFrame, left, right);
 3148             setJSValue(result);
 3149             return;
 3150         }
 3151 
 3152         emitBinaryBitOpSnippet&lt;JITBitOrGenerator&gt;(operationValueBitOr);
 3153     }
 3154 
 3155     void compileArithBitOr()
 3156     {
 3157         setInt32(m_out.bitOr(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3158     }
 3159 
 3160     void compileValueBitXor()
 3161     {
 3162         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3163             LValue left = lowBigInt(m_node-&gt;child1());
 3164             LValue right = lowBigInt(m_node-&gt;child2());
 3165 
 3166             LValue result = vmCall(pointerType(), m_out.operation(operationBitXorBigInt), m_callFrame, left, right);
 3167             setJSValue(result);
 3168             return;
 3169         }
 3170 
 3171         emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
 3172     }
 3173 
 3174     void compileArithBitXor()
 3175     {
 3176         setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3177     }
 3178 
 3179     void compileBitRShift()
 3180     {
 3181         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 3182             emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);
 3183             return;
 3184         }
 3185         setInt32(m_out.aShr(
 3186             lowInt32(m_node-&gt;child1()),
 3187             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3188     }
 3189 
 3190     void compileArithBitLShift()
 3191     {
 3192         setInt32(m_out.shl(
 3193             lowInt32(m_node-&gt;child1()),
 3194             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3195     }
 3196 
 3197     void compileValueBitLShift()
 3198     {
 3199         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3200             LValue left = lowBigInt(m_node-&gt;child1());
 3201             LValue right = lowBigInt(m_node-&gt;child2());
 3202 
 3203             LValue result = vmCall(pointerType(), m_out.operation(operationBitLShiftBigInt), m_callFrame, left, right);
 3204             setJSValue(result);
 3205             return;
 3206         }
 3207 
 3208         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
 3209         emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);
 3210     }
 3211 
 3212     void compileBitURShift()
 3213     {
 3214         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 3215             emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
 3216             return;
 3217         }
 3218         setInt32(m_out.lShr(
 3219             lowInt32(m_node-&gt;child1()),
 3220             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3221     }
 3222 
 3223     void compileUInt32ToNumber()
 3224     {
 3225         LValue value = lowInt32(m_node-&gt;child1());
 3226 
 3227         if (doesOverflow(m_node-&gt;arithMode())) {
 3228             setStrictInt52(m_out.zeroExtPtr(value));
 3229             return;
 3230         }
 3231 
 3232         speculate(Overflow, noValue(), 0, m_out.lessThan(value, m_out.int32Zero));
 3233         setInt32(value);
 3234     }
 3235 
 3236     void compileCheckStructure()
 3237     {
 3238         ExitKind exitKind;
 3239         if (m_node-&gt;child1()-&gt;hasConstant())
 3240             exitKind = BadConstantCache;
 3241         else
 3242             exitKind = BadCache;
 3243 
 3244         switch (m_node-&gt;child1().useKind()) {
 3245         case CellUse:
 3246         case KnownCellUse: {
 3247             LValue cell = lowCell(m_node-&gt;child1());
 3248 
 3249             checkStructure(
 3250                 m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3251                 exitKind, m_node-&gt;structureSet(),
 3252                 [&amp;] (RegisteredStructure structure) {
 3253                     return weakStructureID(structure);
 3254                 });
 3255             return;
 3256         }
 3257 
 3258         case CellOrOtherUse: {
 3259             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 3260 
 3261             LBasicBlock cellCase = m_out.newBlock();
 3262             LBasicBlock notCellCase = m_out.newBlock();
 3263             LBasicBlock continuation = m_out.newBlock();
 3264 
 3265             m_out.branch(
 3266                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3267 
 3268             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3269             checkStructure(
 3270                 m_out.load32(value, m_heaps.JSCell_structureID), jsValueValue(value),
 3271                 exitKind, m_node-&gt;structureSet(),
 3272                 [&amp;] (RegisteredStructure structure) {
 3273                     return weakStructureID(structure);
 3274                 });
 3275             m_out.jump(continuation);
 3276 
 3277             m_out.appendTo(notCellCase, continuation);
 3278             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecCell | SpecOther, isNotOther(value));
 3279             m_out.jump(continuation);
 3280 
 3281             m_out.appendTo(continuation, lastNext);
 3282             return;
 3283         }
 3284 
 3285         default:
 3286             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3287             return;
 3288         }
 3289     }
 3290 
 3291     void compileCheckStructureOrEmpty()
 3292     {
 3293         ExitKind exitKind;
 3294         if (m_node-&gt;child1()-&gt;hasConstant())
 3295             exitKind = BadConstantCache;
 3296         else
 3297             exitKind = BadCache;
 3298 
 3299         LValue cell = lowCell(m_node-&gt;child1());
 3300         bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;
 3301         LBasicBlock notEmpty;
 3302         LBasicBlock continuation;
 3303         LBasicBlock lastNext;
 3304         if (maySeeEmptyValue) {
 3305             notEmpty = m_out.newBlock();
 3306             continuation = m_out.newBlock();
 3307             m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));
 3308             lastNext = m_out.appendTo(notEmpty, continuation);
 3309         }
 3310 
 3311         checkStructure(
 3312             m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3313             exitKind, m_node-&gt;structureSet(),
 3314             [&amp;] (RegisteredStructure structure) {
 3315                 return weakStructureID(structure);
 3316             });
 3317 
 3318         if (maySeeEmptyValue) {
 3319             m_out.jump(continuation);
 3320             m_out.appendTo(continuation, lastNext);
 3321         }
 3322     }
 3323 
 3324     void compileCheckCell()
 3325     {
 3326         LValue cell = lowCell(m_node-&gt;child1());
 3327 
 3328         speculate(
 3329             BadCell, jsValueValue(cell), m_node-&gt;child1().node(),
 3330             m_out.notEqual(cell, weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 3331     }
 3332 
 3333     void compileCheckBadCell()
 3334     {
 3335         terminate(BadCell);
 3336     }
 3337 
 3338     void compileCheckNotEmpty()
 3339     {
 3340         speculate(TDZFailure, noValue(), nullptr, m_out.isZero64(lowJSValue(m_node-&gt;child1())));
 3341     }
 3342 
 3343     void compileAssertNotEmpty()
 3344     {
 3345         if (!validationEnabled())
 3346             return;
 3347 
 3348         LValue val = lowJSValue(m_node-&gt;child1());
 3349         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3350         patchpoint-&gt;appendSomeRegister(val);
 3351         patchpoint-&gt;setGenerator(
 3352             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3353                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3354                 GPRReg input =  params[0].gpr();
 3355                 CCallHelpers::Jump done = jit.branchIfNotEmpty(input);
 3356                 jit.breakpoint();
 3357                 done.link(&amp;jit);
 3358             });
 3359     }
 3360 
 3361     void compileCheckStringIdent()
 3362     {
 3363         UniquedStringImpl* uid = m_node-&gt;uidOperand();
 3364         LValue stringImpl = lowStringIdent(m_node-&gt;child1());
 3365         speculate(BadIdent, noValue(), nullptr, m_out.notEqual(stringImpl, m_out.constIntPtr(uid)));
 3366     }
 3367 
 3368     void compileGetExecutable()
 3369     {
 3370         LValue cell = lowCell(m_node-&gt;child1());
 3371         speculateFunction(m_node-&gt;child1(), cell);
 3372         setJSValue(m_out.loadPtr(cell, m_heaps.JSFunction_executable));
 3373     }
 3374 
 3375     void compileArrayify()
 3376     {
 3377         LValue cell = lowCell(m_node-&gt;child1());
 3378         LValue property = !!m_node-&gt;child2() ? lowInt32(m_node-&gt;child2()) : 0;
 3379 
 3380         LBasicBlock unexpectedStructure = m_out.newBlock();
 3381         LBasicBlock continuation = m_out.newBlock();
 3382 
 3383         auto isUnexpectedArray = [&amp;] (LValue cell) {
 3384             if (m_node-&gt;op() == Arrayify)
 3385                 return m_out.logicalNot(isArrayTypeForArrayify(cell, m_node-&gt;arrayMode()));
 3386 
 3387             ASSERT(m_node-&gt;op() == ArrayifyToStructure);
 3388             return m_out.notEqual(m_out.load32(cell, m_heaps.JSCell_structureID), weakStructureID(m_node-&gt;structure()));
 3389         };
 3390 
 3391         m_out.branch(isUnexpectedArray(cell), rarely(unexpectedStructure), usually(continuation));
 3392 
 3393         LBasicBlock lastNext = m_out.appendTo(unexpectedStructure, continuation);
 3394 
 3395         if (property) {
 3396             switch (m_node-&gt;arrayMode().type()) {
 3397             case Array::Int32:
 3398             case Array::Double:
 3399             case Array::Contiguous:
 3400                 speculate(
 3401                     Uncountable, noValue(), 0,
 3402                     m_out.aboveOrEqual(property, m_out.constInt32(MIN_SPARSE_ARRAY_INDEX)));
 3403                 break;
 3404             default:
 3405                 break;
 3406             }
 3407         }
 3408 
 3409         switch (m_node-&gt;arrayMode().type()) {
 3410         case Array::Int32:
 3411             vmCall(Void, m_out.operation(operationEnsureInt32), m_callFrame, cell);
 3412             break;
 3413         case Array::Double:
 3414             vmCall(Void, m_out.operation(operationEnsureDouble), m_callFrame, cell);
 3415             break;
 3416         case Array::Contiguous:
 3417             vmCall(Void, m_out.operation(operationEnsureContiguous), m_callFrame, cell);
 3418             break;
 3419         case Array::ArrayStorage:
 3420         case Array::SlowPutArrayStorage:
 3421             vmCall(Void, m_out.operation(operationEnsureArrayStorage), m_callFrame, cell);
 3422             break;
 3423         default:
 3424             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 3425             break;
 3426         }
 3427 
 3428         speculate(BadIndexingType, jsValueValue(cell), 0, isUnexpectedArray(cell));
 3429         m_out.jump(continuation);
 3430 
 3431         m_out.appendTo(continuation, lastNext);
 3432     }
 3433 
 3434     void compilePutStructure()
 3435     {
 3436         m_ftlState.jitCode-&gt;common.notifyCompilingStructureTransition(m_graph.m_plan, codeBlock(), m_node);
 3437 
 3438         RegisteredStructure oldStructure = m_node-&gt;transition()-&gt;previous;
 3439         RegisteredStructure newStructure = m_node-&gt;transition()-&gt;next;
 3440         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
 3441         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
 3442         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
 3443 
 3444         LValue cell = lowCell(m_node-&gt;child1());
 3445         m_out.store32(
 3446             weakStructureID(newStructure),
 3447             cell, m_heaps.JSCell_structureID);
 3448     }
 3449 
 3450     void compileGetById(AccessType type)
 3451     {
 3452         ASSERT(type == AccessType::Get || type == AccessType::TryGet || type == AccessType::GetDirect);
 3453         switch (m_node-&gt;child1().useKind()) {
 3454         case CellUse: {
 3455             setJSValue(getById(lowCell(m_node-&gt;child1()), type));
 3456             return;
 3457         }
 3458 
 3459         case UntypedUse: {
 3460             // This is pretty weird, since we duplicate the slow path both here and in the
 3461             // code generated by the IC. We should investigate making this less bad.
 3462             // https://bugs.webkit.org/show_bug.cgi?id=127830
 3463             LValue value = lowJSValue(m_node-&gt;child1());
 3464 
 3465             LBasicBlock cellCase = m_out.newBlock();
 3466             LBasicBlock notCellCase = m_out.newBlock();
 3467             LBasicBlock continuation = m_out.newBlock();
 3468 
 3469             m_out.branch(
 3470                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3471 
 3472             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3473             ValueFromBlock cellResult = m_out.anchor(getById(value, type));
 3474             m_out.jump(continuation);
 3475 
 3476             J_JITOperation_EJI getByIdFunction = appropriateGenericGetByIdFunction(type);
 3477 
 3478             m_out.appendTo(notCellCase, continuation);
 3479             ValueFromBlock notCellResult = m_out.anchor(vmCall(
 3480                 Int64, m_out.operation(getByIdFunction),
 3481                 m_callFrame, value,
 3482                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3483             m_out.jump(continuation);
 3484 
 3485             m_out.appendTo(continuation, lastNext);
 3486             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3487             return;
 3488         }
 3489 
 3490         default:
 3491             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3492             return;
 3493         }
 3494     }
 3495 
 3496     void compileGetByIdWithThis()
 3497     {
 3498         if (m_node-&gt;child1().useKind() == CellUse &amp;&amp; m_node-&gt;child2().useKind() == CellUse)
 3499             setJSValue(getByIdWithThis(lowCell(m_node-&gt;child1()), lowCell(m_node-&gt;child2())));
 3500         else {
 3501             LValue base = lowJSValue(m_node-&gt;child1());
 3502             LValue thisValue = lowJSValue(m_node-&gt;child2());
 3503 
 3504             LBasicBlock baseCellCase = m_out.newBlock();
 3505             LBasicBlock notCellCase = m_out.newBlock();
 3506             LBasicBlock thisValueCellCase = m_out.newBlock();
 3507             LBasicBlock continuation = m_out.newBlock();
 3508 
 3509             m_out.branch(
 3510                 isCell(base, provenType(m_node-&gt;child1())), unsure(baseCellCase), unsure(notCellCase));
 3511 
 3512             LBasicBlock lastNext = m_out.appendTo(baseCellCase, thisValueCellCase);
 3513 
 3514             m_out.branch(
 3515                 isCell(thisValue, provenType(m_node-&gt;child2())), unsure(thisValueCellCase), unsure(notCellCase));
 3516 
 3517             m_out.appendTo(thisValueCellCase, notCellCase);
 3518             ValueFromBlock cellResult = m_out.anchor(getByIdWithThis(base, thisValue));
 3519             m_out.jump(continuation);
 3520 
 3521             m_out.appendTo(notCellCase, continuation);
 3522             ValueFromBlock notCellResult = m_out.anchor(vmCall(
 3523                 Int64, m_out.operation(operationGetByIdWithThisGeneric),
 3524                 m_callFrame, base, thisValue,
 3525                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3526             m_out.jump(continuation);
 3527 
 3528             m_out.appendTo(continuation, lastNext);
 3529             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3530         }
 3531 
 3532     }
 3533 
 3534     void compileGetByValWithThis()
 3535     {
 3536         LValue base = lowJSValue(m_node-&gt;child1());
 3537         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3538         LValue subscript = lowJSValue(m_node-&gt;child3());
 3539 
 3540         LValue result = vmCall(Int64, m_out.operation(operationGetByValWithThis), m_callFrame, base, thisValue, subscript);
 3541         setJSValue(result);
 3542     }
 3543 
 3544     void compilePutByIdWithThis()
 3545     {
 3546         LValue base = lowJSValue(m_node-&gt;child1());
 3547         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3548         LValue value = lowJSValue(m_node-&gt;child3());
 3549 
 3550         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis),
 3551             m_callFrame, base, thisValue, value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()]));
 3552     }
 3553 
 3554     void compilePutByValWithThis()
 3555     {
 3556         LValue base = lowJSValue(m_graph.varArgChild(m_node, 0));
 3557         LValue thisValue = lowJSValue(m_graph.varArgChild(m_node, 1));
 3558         LValue property = lowJSValue(m_graph.varArgChild(m_node, 2));
 3559         LValue value = lowJSValue(m_graph.varArgChild(m_node, 3));
 3560 
 3561         vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis),
 3562             m_callFrame, base, thisValue, property, value);
 3563     }
 3564 
 3565     void compileAtomicsReadModifyWrite()
 3566     {
 3567         TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 3568         unsigned numExtraArgs = numExtraAtomicsArgs(m_node-&gt;op());
 3569         Edge baseEdge = m_graph.child(m_node, 0);
 3570         Edge indexEdge = m_graph.child(m_node, 1);
 3571         Edge argEdges[maxNumExtraAtomicsArgs];
 3572         for (unsigned i = numExtraArgs; i--;)
 3573             argEdges[i] = m_graph.child(m_node, 2 + i);
 3574         Edge storageEdge = m_graph.child(m_node, 2 + numExtraArgs);
 3575 
 3576         auto operation = [&amp;] () -&gt; LValue {
 3577             switch (m_node-&gt;op()) {
 3578             case AtomicsAdd:
 3579                 return m_out.operation(operationAtomicsAdd);
 3580             case AtomicsAnd:
 3581                 return m_out.operation(operationAtomicsAnd);
 3582             case AtomicsCompareExchange:
 3583                 return m_out.operation(operationAtomicsCompareExchange);
 3584             case AtomicsExchange:
 3585                 return m_out.operation(operationAtomicsExchange);
 3586             case AtomicsLoad:
 3587                 return m_out.operation(operationAtomicsLoad);
 3588             case AtomicsOr:
 3589                 return m_out.operation(operationAtomicsOr);
 3590             case AtomicsStore:
 3591                 return m_out.operation(operationAtomicsStore);
 3592             case AtomicsSub:
 3593                 return m_out.operation(operationAtomicsSub);
 3594             case AtomicsXor:
 3595                 return m_out.operation(operationAtomicsXor);
 3596             default:
 3597                 RELEASE_ASSERT_NOT_REACHED();
 3598                 break;
 3599             }
 3600         };
 3601 
 3602         if (!storageEdge) {
 3603             Vector&lt;LValue&gt; args;
 3604             args.append(m_callFrame);
 3605             args.append(lowJSValue(baseEdge));
 3606             args.append(lowJSValue(indexEdge));
 3607             for (unsigned i = 0; i &lt; numExtraArgs; ++i)
 3608                 args.append(lowJSValue(argEdges[i]));
 3609             LValue result = vmCall(Int64, operation(), args);
 3610             setJSValue(result);
 3611             return;
 3612         }
 3613 
 3614         LValue index = lowInt32(indexEdge);
 3615         LValue args[2];
 3616         for (unsigned i = numExtraArgs; i--;)
 3617             args[i] = getIntTypedArrayStoreOperand(argEdges[i]);
 3618         LValue storage = lowStorage(storageEdge);
 3619 
 3620         TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 3621         Width width = widthForBytes(elementSize(type));
 3622 
 3623         LValue atomicValue;
 3624         LValue result;
 3625 
 3626         auto sanitizeResult = [&amp;] (LValue value) -&gt; LValue {
 3627             if (isSigned(type)) {
 3628                 switch (elementSize(type)) {
 3629                 case 1:
 3630                     value = m_out.bitAnd(value, m_out.constInt32(0xff));
 3631                     break;
 3632                 case 2:
 3633                     value = m_out.bitAnd(value, m_out.constInt32(0xffff));
 3634                     break;
 3635                 case 4:
 3636                     break;
 3637                 default:
 3638                     RELEASE_ASSERT_NOT_REACHED();
 3639                     break;
 3640                 }
 3641             }
 3642             return value;
 3643         };
 3644 
 3645         switch (m_node-&gt;op()) {
 3646         case AtomicsAdd:
 3647             atomicValue = m_out.atomicXchgAdd(args[0], pointer, width);
 3648             result = sanitizeResult(atomicValue);
 3649             break;
 3650         case AtomicsAnd:
 3651             atomicValue = m_out.atomicXchgAnd(args[0], pointer, width);
 3652             result = sanitizeResult(atomicValue);
 3653             break;
 3654         case AtomicsCompareExchange:
 3655             atomicValue = m_out.atomicStrongCAS(args[0], args[1], pointer, width);
 3656             result = sanitizeResult(atomicValue);
 3657             break;
 3658         case AtomicsExchange:
 3659             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3660             result = sanitizeResult(atomicValue);
 3661             break;
 3662         case AtomicsLoad:
 3663             atomicValue = m_out.atomicXchgAdd(m_out.int32Zero, pointer, width);
 3664             result = sanitizeResult(atomicValue);
 3665             break;
 3666         case AtomicsOr:
 3667             atomicValue = m_out.atomicXchgOr(args[0], pointer, width);
 3668             result = sanitizeResult(atomicValue);
 3669             break;
 3670         case AtomicsStore:
 3671             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3672             result = args[0];
 3673             break;
 3674         case AtomicsSub:
 3675             atomicValue = m_out.atomicXchgSub(args[0], pointer, width);
 3676             result = sanitizeResult(atomicValue);
 3677             break;
 3678         case AtomicsXor:
 3679             atomicValue = m_out.atomicXchgXor(args[0], pointer, width);
 3680             result = sanitizeResult(atomicValue);
 3681             break;
 3682         default:
 3683             RELEASE_ASSERT_NOT_REACHED();
 3684             break;
 3685         }
 3686         // Signify that the state against which the atomic operations are serialized is confined to just
 3687         // the typed array storage, since that&#39;s as precise of an abstraction as we can have of shared
 3688         // array buffer storage.
 3689         m_heaps.decorateFencedAccess(&amp;m_heaps.typedArrayProperties, atomicValue);
 3690 
 3691         setIntTypedArrayLoadResult(result, type);
 3692     }
 3693 
 3694     void compileAtomicsIsLockFree()
 3695     {
 3696         if (m_node-&gt;child1().useKind() != Int32Use) {
 3697             setJSValue(vmCall(Int64, m_out.operation(operationAtomicsIsLockFree), m_callFrame, lowJSValue(m_node-&gt;child1())));
 3698             return;
 3699         }
 3700 
 3701         LValue bytes = lowInt32(m_node-&gt;child1());
 3702 
 3703         LBasicBlock trueCase = m_out.newBlock();
 3704         LBasicBlock falseCase = m_out.newBlock();
 3705         LBasicBlock continuation = m_out.newBlock();
 3706 
 3707         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueCase);
 3708 
 3709         Vector&lt;SwitchCase&gt; cases;
 3710         cases.append(SwitchCase(m_out.constInt32(1), trueCase, Weight()));
 3711         cases.append(SwitchCase(m_out.constInt32(2), trueCase, Weight()));
 3712         cases.append(SwitchCase(m_out.constInt32(4), trueCase, Weight()));
 3713         m_out.switchInstruction(bytes, cases, falseCase, Weight());
 3714 
 3715         m_out.appendTo(trueCase, falseCase);
 3716         ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
 3717         m_out.jump(continuation);
 3718         m_out.appendTo(falseCase, continuation);
 3719         ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
 3720         m_out.jump(continuation);
 3721 
 3722         m_out.appendTo(continuation, lastNext);
 3723         setBoolean(m_out.phi(Int32, trueValue, falseValue));
 3724     }
 3725 
 3726     void compileDefineDataProperty()
 3727     {
 3728         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3729         LValue value  = lowJSValue(m_graph.varArgChild(m_node, 2));
 3730         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 3));
 3731         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3732         switch (propertyEdge.useKind()) {
 3733         case StringUse: {
 3734             LValue property = lowString(propertyEdge);
 3735             vmCall(Void, m_out.operation(operationDefineDataPropertyString), m_callFrame, base, property, value, attributes);
 3736             break;
 3737         }
 3738         case StringIdentUse: {
 3739             LValue property = lowStringIdent(propertyEdge);
 3740             vmCall(Void, m_out.operation(operationDefineDataPropertyStringIdent), m_callFrame, base, property, value, attributes);
 3741             break;
 3742         }
 3743         case SymbolUse: {
 3744             LValue property = lowSymbol(propertyEdge);
 3745             vmCall(Void, m_out.operation(operationDefineDataPropertySymbol), m_callFrame, base, property, value, attributes);
 3746             break;
 3747         }
 3748         case UntypedUse: {
 3749             LValue property = lowJSValue(propertyEdge);
 3750             vmCall(Void, m_out.operation(operationDefineDataProperty), m_callFrame, base, property, value, attributes);
 3751             break;
 3752         }
 3753         default:
 3754             RELEASE_ASSERT_NOT_REACHED();
 3755         }
 3756     }
 3757 
 3758     void compileDefineAccessorProperty()
 3759     {
 3760         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3761         LValue getter = lowCell(m_graph.varArgChild(m_node, 2));
 3762         LValue setter = lowCell(m_graph.varArgChild(m_node, 3));
 3763         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 4));
 3764         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3765         switch (propertyEdge.useKind()) {
 3766         case StringUse: {
 3767             LValue property = lowString(propertyEdge);
 3768             vmCall(Void, m_out.operation(operationDefineAccessorPropertyString), m_callFrame, base, property, getter, setter, attributes);
 3769             break;
 3770         }
 3771         case StringIdentUse: {
 3772             LValue property = lowStringIdent(propertyEdge);
 3773             vmCall(Void, m_out.operation(operationDefineAccessorPropertyStringIdent), m_callFrame, base, property, getter, setter, attributes);
 3774             break;
 3775         }
 3776         case SymbolUse: {
 3777             LValue property = lowSymbol(propertyEdge);
 3778             vmCall(Void, m_out.operation(operationDefineAccessorPropertySymbol), m_callFrame, base, property, getter, setter, attributes);
 3779             break;
 3780         }
 3781         case UntypedUse: {
 3782             LValue property = lowJSValue(propertyEdge);
 3783             vmCall(Void, m_out.operation(operationDefineAccessorProperty), m_callFrame, base, property, getter, setter, attributes);
 3784             break;
 3785         }
 3786         default:
 3787             RELEASE_ASSERT_NOT_REACHED();
 3788         }
 3789     }
 3790 
 3791     void compilePutById()
 3792     {
 3793         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == CellUse, m_node-&gt;child1().useKind());
 3794 
 3795         Node* node = m_node;
 3796         LValue base = lowCell(node-&gt;child1());
 3797         LValue value = lowJSValue(node-&gt;child2());
 3798         auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
 3799 
 3800         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3801         patchpoint-&gt;appendSomeRegister(base);
 3802         patchpoint-&gt;appendSomeRegister(value);
 3803         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 3804         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 3805         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 3806 
 3807         // FIXME: If this is a PutByIdFlush, we might want to late-clobber volatile registers.
 3808         // https://bugs.webkit.org/show_bug.cgi?id=152848
 3809 
 3810         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 3811             preparePatchpointForExceptions(patchpoint);
 3812 
 3813         State* state = &amp;m_ftlState;
 3814         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;ecmaMode();
 3815 
 3816         patchpoint-&gt;setGenerator(
 3817             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3818                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3819 
 3820                 CallSiteIndex callSiteIndex =
 3821                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
 3822 
 3823                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 3824                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 3825 
 3826                 // JS setter call ICs generated by the PutById IC will need this.
 3827                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 3828 
 3829                 auto generator = Box&lt;JITPutByIdGenerator&gt;::create(
 3830                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
 3831                     params.unavailableRegisters(), JSValueRegs(params[0].gpr()),
 3832                     JSValueRegs(params[1].gpr()), GPRInfo::patchpointScratchRegister, ecmaMode,
 3833                     node-&gt;op() == PutByIdDirect ? Direct : NotDirect);
 3834 
 3835                 generator-&gt;generateFastPath(jit);
 3836                 CCallHelpers::Label done = jit.label();
 3837 
 3838                 params.addLatePath(
 3839                     [=] (CCallHelpers&amp; jit) {
 3840                         AllowMacroScratchRegisterUsage allowScratch(jit);
 3841 
 3842                         generator-&gt;slowPathJump().link(&amp;jit);
 3843                         CCallHelpers::Label slowPathBegin = jit.label();
 3844                         CCallHelpers::Call slowPathCall = callOperation(
 3845                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 3846                             exceptions.get(), generator-&gt;slowPathFunction(), InvalidGPRReg,
 3847                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
 3848                             params[0].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
 3849                         jit.jump().linkTo(done, &amp;jit);
 3850 
 3851                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
 3852 
 3853                         jit.addLinkTask(
 3854                             [=] (LinkBuffer&amp; linkBuffer) {
 3855                                 generator-&gt;finalize(linkBuffer, linkBuffer);
 3856                             });
 3857                     });
 3858             });
 3859     }
 3860 
 3861     void compileGetButterfly()
 3862     {
 3863         LValue butterfly = m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSObject_butterfly);
 3864         setStorage(butterfly);
 3865     }
 3866 
 3867     void compileConstantStoragePointer()
 3868     {
 3869         setStorage(m_out.constIntPtr(m_node-&gt;storagePointer()));
 3870     }
 3871 
 3872     void compileGetIndexedPropertyStorage()
 3873     {
 3874         LValue cell = lowCell(m_node-&gt;child1());
 3875 
 3876         if (m_node-&gt;arrayMode().type() == Array::String) {
 3877             LBasicBlock slowPath = m_out.newBlock();
 3878             LBasicBlock continuation = m_out.newBlock();
 3879 
 3880             LValue fastResultValue = m_out.loadPtr(cell, m_heaps.JSString_value);
 3881             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 3882 
 3883             m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
 3884 
 3885             LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
 3886 
 3887             ValueFromBlock slowResult = m_out.anchor(
 3888                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, cell));
 3889 
 3890             m_out.jump(continuation);
 3891 
 3892             m_out.appendTo(continuation, lastNext);
 3893 
 3894             setStorage(m_out.loadPtr(m_out.phi(pointerType(), fastResult, slowResult), m_heaps.StringImpl_data));
 3895             return;
 3896         }
 3897 
 3898         DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
 3899         LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
 3900         setStorage(caged(Gigacage::Primitive, vector, cell));
 3901     }
 3902 
 3903     void compileCheckArray()
 3904     {
 3905         Edge edge = m_node-&gt;child1();
 3906         LValue cell = lowCell(edge);
 3907 
 3908         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge)))
 3909             return;
 3910 
 3911         speculate(
 3912             BadIndexingType, jsValueValue(cell), 0,
 3913             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
 3914     }
 3915 
 3916     void compileGetTypedArrayByteOffset()
 3917     {
 3918         LValue basePtr = lowCell(m_node-&gt;child1());
 3919 
 3920         LBasicBlock simpleCase = m_out.newBlock();
 3921         LBasicBlock wastefulCase = m_out.newBlock();
 3922         LBasicBlock notNull = m_out.newBlock();
 3923         LBasicBlock continuation = m_out.newBlock();
 3924 
 3925         LValue mode = m_out.load32(basePtr, m_heaps.JSArrayBufferView_mode);
 3926         m_out.branch(
 3927             m_out.notEqual(mode, m_out.constInt32(WastefulTypedArray)),
 3928             unsure(simpleCase), unsure(wastefulCase));
 3929 
 3930         LBasicBlock lastNext = m_out.appendTo(simpleCase, wastefulCase);
 3931 
 3932         ValueFromBlock simpleOut = m_out.anchor(m_out.constIntPtr(0));
 3933 
 3934         m_out.jump(continuation);
 3935 
 3936         m_out.appendTo(wastefulCase, notNull);
 3937 
 3938         LValue vector = m_out.loadPtr(basePtr, m_heaps.JSArrayBufferView_vector);
 3939         ValueFromBlock nullVectorOut = m_out.anchor(vector);
 3940         m_out.branch(vector, unsure(notNull), unsure(continuation));
 3941 
 3942         m_out.appendTo(notNull, continuation);
 3943 
 3944         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly), basePtr);
 3945         LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
 3946 
 3947         LValue vectorPtr = caged(Gigacage::Primitive, vector, basePtr);
 3948 
 3949         // FIXME: This needs caging.
 3950         // https://bugs.webkit.org/show_bug.cgi?id=175515
 3951         LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
 3952         dataPtr = removeArrayPtrTag(dataPtr);
 3953 
 3954         ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
 3955 
 3956         m_out.jump(continuation);
 3957         m_out.appendTo(continuation, lastNext);
 3958 
 3959         setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
 3960     }
 3961 
 3962     void compileGetPrototypeOf()
 3963     {
 3964         switch (m_node-&gt;child1().useKind()) {
 3965         case ArrayUse:
 3966         case FunctionUse:
 3967         case FinalObjectUse: {
 3968             LValue object = lowCell(m_node-&gt;child1());
 3969             switch (m_node-&gt;child1().useKind()) {
 3970             case ArrayUse:
 3971                 speculateArray(m_node-&gt;child1(), object);
 3972                 break;
 3973             case FunctionUse:
 3974                 speculateFunction(m_node-&gt;child1(), object);
 3975                 break;
 3976             case FinalObjectUse:
 3977                 speculateFinalObject(m_node-&gt;child1(), object);
 3978                 break;
 3979             default:
 3980                 RELEASE_ASSERT_NOT_REACHED();
 3981                 break;
 3982             }
 3983 
 3984             LValue structure = loadStructure(object);
 3985 
 3986             AbstractValue&amp; value = m_state.forNode(m_node-&gt;child1());
 3987             if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
 3988                 bool hasPolyProto = false;
 3989                 bool hasMonoProto = false;
 3990                 value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
 3991                     if (structure-&gt;hasPolyProto())
 3992                         hasPolyProto = true;
 3993                     else
 3994                         hasMonoProto = true;
 3995                 });
 3996 
 3997                 if (hasMonoProto &amp;&amp; !hasPolyProto) {
 3998                     setJSValue(m_out.load64(structure, m_heaps.Structure_prototype));
 3999                     return;
 4000                 }
 4001 
 4002                 if (hasPolyProto &amp;&amp; !hasMonoProto) {
 4003                     setJSValue(m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 4004                     return;
 4005                 }
 4006             }
 4007 
 4008             LBasicBlock continuation = m_out.newBlock();
 4009             LBasicBlock loadPolyProto = m_out.newBlock();
 4010 
 4011             LValue prototypeBits = m_out.load64(structure, m_heaps.Structure_prototype);
 4012             ValueFromBlock directPrototype = m_out.anchor(prototypeBits);
 4013             m_out.branch(m_out.isZero64(prototypeBits), unsure(loadPolyProto), unsure(continuation));
 4014 
 4015             LBasicBlock lastNext = m_out.appendTo(loadPolyProto, continuation);
 4016             ValueFromBlock polyProto = m_out.anchor(
 4017                 m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 4018             m_out.jump(continuation);
 4019 
 4020             m_out.appendTo(continuation, lastNext);
 4021             setJSValue(m_out.phi(Int64, directPrototype, polyProto));
 4022             return;
 4023         }
 4024         case ObjectUse: {
 4025             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOfObject), m_callFrame, lowObject(m_node-&gt;child1())));
 4026             return;
 4027         }
 4028         default: {
 4029             setJSValue(vmCall(Int64, m_out.operation(operationGetPrototypeOf), m_callFrame, lowJSValue(m_node-&gt;child1())));
 4030             return;
 4031         }
 4032         }
 4033     }
 4034 
 4035     void compileGetArrayLength()
 4036     {
 4037         switch (m_node-&gt;arrayMode().type()) {
 4038         case Array::Undecided:
 4039         case Array::Int32:
 4040         case Array::Double:
 4041         case Array::Contiguous: {
 4042             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.Butterfly_publicLength));
 4043             return;
 4044         }
 4045 
 4046         case Array::ArrayStorage:
 4047         case Array::SlowPutArrayStorage: {
 4048             LValue length = m_out.load32(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_publicLength);
 4049             speculate(Uncountable, noValue(), nullptr, m_out.lessThan(length, m_out.int32Zero));
 4050             setInt32(length);
 4051             return;
 4052         }
 4053 
 4054         case Array::String: {
 4055             LValue string = lowCell(m_node-&gt;child1());
 4056 
 4057             LBasicBlock ropePath = m_out.newBlock();
 4058             LBasicBlock nonRopePath = m_out.newBlock();
 4059             LBasicBlock continuation = m_out.newBlock();
 4060 
 4061             m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropePath), usually(nonRopePath));
 4062 
 4063             LBasicBlock lastNext = m_out.appendTo(ropePath, nonRopePath);
 4064             ValueFromBlock ropeLength = m_out.anchor(m_out.load32NonNegative(string, m_heaps.JSRopeString_length));
 4065             m_out.jump(continuation);
 4066 
 4067             m_out.appendTo(nonRopePath, continuation);
 4068             ValueFromBlock nonRopeLength = m_out.anchor(m_out.load32NonNegative(m_out.loadPtr(string, m_heaps.JSString_value), m_heaps.StringImpl_length));
 4069             m_out.jump(continuation);
 4070 
 4071             m_out.appendTo(continuation, lastNext);
 4072             setInt32(m_out.phi(Int32, ropeLength, nonRopeLength));
 4073             return;
 4074         }
 4075 
 4076         case Array::DirectArguments: {
 4077             LValue arguments = lowCell(m_node-&gt;child1());
 4078             speculate(
 4079                 ExoticObjectMode, noValue(), nullptr,
 4080                 m_out.notNull(m_out.loadPtr(arguments, m_heaps.DirectArguments_mappedArguments)));
 4081             setInt32(m_out.load32NonNegative(arguments, m_heaps.DirectArguments_length));
 4082             return;
 4083         }
 4084 
 4085         case Array::ScopedArguments: {
 4086             LValue arguments = lowCell(m_node-&gt;child1());
 4087             LValue storage = m_out.loadPtr(arguments, m_heaps.ScopedArguments_storage);
 4088             speculate(
 4089                 ExoticObjectMode, noValue(), nullptr,
 4090                 m_out.notZero32(m_out.load8ZeroExt32(storage, m_heaps.ScopedArguments_Storage_overrodeThings)));
 4091             setInt32(m_out.load32NonNegative(storage, m_heaps.ScopedArguments_Storage_totalLength));
 4092             return;
 4093         }
 4094 
 4095         default:
 4096             if (m_node-&gt;arrayMode().isSomeTypedArrayView()) {
 4097                 setInt32(
 4098                     m_out.load32NonNegative(lowCell(m_node-&gt;child1()), m_heaps.JSArrayBufferView_length));
 4099                 return;
 4100             }
 4101 
 4102             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4103             return;
 4104         }
 4105     }
 4106 
 4107     void compileGetVectorLength()
 4108     {
 4109         switch (m_node-&gt;arrayMode().type()) {
 4110         case Array::ArrayStorage:
 4111         case Array::SlowPutArrayStorage:
 4112             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_vectorLength));
 4113             return;
 4114         default:
 4115             return;
 4116         }
 4117     }
 4118 
 4119     void compileCheckInBounds()
 4120     {
 4121         speculate(
 4122             OutOfBounds, noValue(), 0,
 4123             m_out.aboveOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 4124 
 4125         // Even though we claim to have JSValue result, no user of us should
 4126         // depend on our value. Users of this node just need to maintain that
 4127         // we dominate them.
 4128     }
 4129 
 4130     void compileGetByVal()
 4131     {
 4132         switch (m_node-&gt;arrayMode().type()) {
 4133         case Array::Int32:
 4134         case Array::Contiguous: {
 4135             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4136             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4137 
 4138             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
 4139                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
 4140 
 4141             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4142 
 4143             if (m_node-&gt;arrayMode().isInBounds()) {
 4144                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4145                 LValue isHole = m_out.isZero64(result);
 4146                 if (m_node-&gt;arrayMode().isSaneChain()) {
 4147                     DFG_ASSERT(
 4148                         m_graph, m_node, m_node-&gt;arrayMode().type() == Array::Contiguous, m_node-&gt;arrayMode().type());
 4149                     result = m_out.select(
 4150                         isHole, m_out.constInt64(JSValue::encode(jsUndefined())), result);
 4151                 } else
 4152                     speculate(LoadFromHole, noValue(), 0, isHole);
 4153                 setJSValue(result);
 4154                 return;
 4155             }
 4156 
 4157             LBasicBlock fastCase = m_out.newBlock();
 4158             LBasicBlock slowCase = m_out.newBlock();
 4159             LBasicBlock continuation = m_out.newBlock();
 4160 
 4161             m_out.branch(
 4162                 m_out.aboveOrEqual(
 4163                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 4164                 rarely(slowCase), usually(fastCase));
 4165 
 4166             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 4167 
 4168             LValue fastResultValue = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4169             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 4170             m_out.branch(
 4171                 m_out.isZero64(fastResultValue), rarely(slowCase), usually(continuation));
 4172 
 4173             m_out.appendTo(slowCase, continuation);
 4174             ValueFromBlock slowResult = m_out.anchor(
 4175                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4176             m_out.jump(continuation);
 4177 
 4178             m_out.appendTo(continuation, lastNext);
 4179             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4180             return;
 4181         }
 4182 
 4183         case Array::Double: {
 4184             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4185             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4186             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4187 
 4188             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
 4189 
 4190             if (m_node-&gt;arrayMode().isInBounds()) {
 4191                 LValue result = m_out.loadDouble(
 4192                     baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4193 
 4194                 if (!m_node-&gt;arrayMode().isSaneChain()) {
 4195                     speculate(
 4196                         LoadFromHole, noValue(), 0,
 4197                         m_out.doubleNotEqualOrUnordered(result, result));
 4198                 }
 4199                 setDouble(result);
 4200                 break;
 4201             }
 4202 
 4203             LBasicBlock inBounds = m_out.newBlock();
 4204             LBasicBlock boxPath = m_out.newBlock();
 4205             LBasicBlock slowCase = m_out.newBlock();
 4206             LBasicBlock continuation = m_out.newBlock();
 4207 
 4208             m_out.branch(
 4209                 m_out.aboveOrEqual(
 4210                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 4211                 rarely(slowCase), usually(inBounds));
 4212 
 4213             LBasicBlock lastNext = m_out.appendTo(inBounds, boxPath);
 4214             LValue doubleValue = m_out.loadDouble(
 4215                 baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4216             m_out.branch(
 4217                 m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue),
 4218                 rarely(slowCase), usually(boxPath));
 4219 
 4220             m_out.appendTo(boxPath, slowCase);
 4221             ValueFromBlock fastResult = m_out.anchor(boxDouble(doubleValue));
 4222             m_out.jump(continuation);
 4223 
 4224             m_out.appendTo(slowCase, continuation);
 4225             ValueFromBlock slowResult = m_out.anchor(
 4226                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4227             m_out.jump(continuation);
 4228 
 4229             m_out.appendTo(continuation, lastNext);
 4230             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4231             return;
 4232         }
 4233 
 4234         case Array::Undecided: {
 4235             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4236 
 4237             speculate(OutOfBounds, noValue(), m_node, m_out.lessThan(index, m_out.int32Zero));
 4238             setJSValue(m_out.constInt64(ValueUndefined));
 4239             return;
 4240         }
 4241 
 4242         case Array::DirectArguments: {
 4243             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4244             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4245 
 4246             speculate(
 4247                 ExoticObjectMode, noValue(), nullptr,
 4248                 m_out.notNull(m_out.loadPtr(base, m_heaps.DirectArguments_mappedArguments)));
 4249 
 4250             LValue length = m_out.load32NonNegative(base, m_heaps.DirectArguments_length);
 4251             auto isOutOfBounds = m_out.aboveOrEqual(index, length);
 4252             if (m_node-&gt;arrayMode().isInBounds()) {
 4253                 speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4254                 TypedPointer address = m_out.baseIndex(
 4255                     m_heaps.DirectArguments_storage, base, m_out.zeroExtPtr(index));
 4256                 setJSValue(m_out.load64(address));
 4257                 return;
 4258             }
 4259 
 4260             LBasicBlock inBounds = m_out.newBlock();
 4261             LBasicBlock slowCase = m_out.newBlock();
 4262             LBasicBlock continuation = m_out.newBlock();
 4263 
 4264             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBounds));
 4265 
 4266             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4267             TypedPointer address = m_out.baseIndex(
 4268                 m_heaps.DirectArguments_storage,
 4269                 base,
 4270                 m_out.zeroExt(index, pointerType()));
 4271             ValueFromBlock fastResult = m_out.anchor(m_out.load64(address));
 4272             m_out.jump(continuation);
 4273 
 4274             m_out.appendTo(slowCase, continuation);
 4275             ValueFromBlock slowResult = m_out.anchor(
 4276                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4277             m_out.jump(continuation);
 4278 
 4279             m_out.appendTo(continuation, lastNext);
 4280             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4281             return;
 4282         }
 4283 
 4284         case Array::ScopedArguments: {
 4285             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4286             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4287 
 4288             LValue storage = m_out.loadPtr(base, m_heaps.ScopedArguments_storage);
 4289             LValue totalLength = m_out.load32NonNegative(
 4290                 storage, m_heaps.ScopedArguments_Storage_totalLength);
 4291             speculate(
 4292                 ExoticObjectMode, noValue(), nullptr,
 4293                 m_out.aboveOrEqual(index, totalLength));
 4294 
 4295             LValue table = m_out.loadPtr(base, m_heaps.ScopedArguments_table);
 4296             LValue namedLength = m_out.load32(table, m_heaps.ScopedArgumentsTable_length);
 4297 
 4298             LBasicBlock namedCase = m_out.newBlock();
 4299             LBasicBlock overflowCase = m_out.newBlock();
 4300             LBasicBlock continuation = m_out.newBlock();
 4301 
 4302             m_out.branch(
 4303                 m_out.aboveOrEqual(index, namedLength), unsure(overflowCase), unsure(namedCase));
 4304 
 4305             LBasicBlock lastNext = m_out.appendTo(namedCase, overflowCase);
 4306 
 4307             LValue scope = m_out.loadPtr(base, m_heaps.ScopedArguments_scope);
 4308             LValue arguments = m_out.loadPtr(table, m_heaps.ScopedArgumentsTable_arguments);
 4309 
 4310             TypedPointer address = m_out.baseIndex(
 4311                 m_heaps.scopedArgumentsTableArguments, arguments, m_out.zeroExtPtr(index));
 4312             LValue scopeOffset = m_out.load32(address);
 4313 
 4314             speculate(
 4315                 ExoticObjectMode, noValue(), nullptr,
 4316                 m_out.equal(scopeOffset, m_out.constInt32(ScopeOffset::invalidOffset)));
 4317 
 4318             address = m_out.baseIndex(
 4319                 m_heaps.JSLexicalEnvironment_variables, scope, m_out.zeroExtPtr(scopeOffset));
 4320             ValueFromBlock namedResult = m_out.anchor(m_out.load64(address));
 4321             m_out.jump(continuation);
 4322 
 4323             m_out.appendTo(overflowCase, continuation);
 4324 
 4325             address = m_out.baseIndex(
 4326                 m_heaps.ScopedArguments_Storage_storage, storage,
 4327                 m_out.zeroExtPtr(m_out.sub(index, namedLength)));
 4328             LValue overflowValue = m_out.load64(address);
 4329             speculate(ExoticObjectMode, noValue(), nullptr, m_out.isZero64(overflowValue));
 4330             ValueFromBlock overflowResult = m_out.anchor(overflowValue);
 4331             m_out.jump(continuation);
 4332 
 4333             m_out.appendTo(continuation, lastNext);
 4334 
 4335             LValue result = m_out.phi(Int64, namedResult, overflowResult);
 4336             result = preciseIndexMask32(result, index, totalLength);
 4337 
 4338             setJSValue(result);
 4339             return;
 4340         }
 4341 
 4342         case Array::Generic: {
 4343             if (m_graph.varArgChild(m_node, 0).useKind() == ObjectUse) {
 4344                 if (m_graph.varArgChild(m_node, 1).useKind() == StringUse) {
 4345                     setJSValue(vmCall(
 4346                         Int64, m_out.operation(operationGetByValObjectString), m_callFrame,
 4347                         lowObject(m_graph.varArgChild(m_node, 0)), lowString(m_graph.varArgChild(m_node, 1))));
 4348                     return;
 4349                 }
 4350 
 4351                 if (m_graph.varArgChild(m_node, 1).useKind() == SymbolUse) {
 4352                     setJSValue(vmCall(
 4353                         Int64, m_out.operation(operationGetByValObjectSymbol), m_callFrame,
 4354                         lowObject(m_graph.varArgChild(m_node, 0)), lowSymbol(m_graph.varArgChild(m_node, 1))));
 4355                     return;
 4356                 }
 4357             }
 4358             setJSValue(vmCall(
 4359                 Int64, m_out.operation(operationGetByVal), m_callFrame,
 4360                 lowJSValue(m_graph.varArgChild(m_node, 0)), lowJSValue(m_graph.varArgChild(m_node, 1))));
 4361             return;
 4362         }
 4363 
 4364         case Array::ArrayStorage:
 4365         case Array::SlowPutArrayStorage: {
 4366             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4367             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4368             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4369 
 4370             IndexedAbstractHeap&amp; heap = m_heaps.ArrayStorage_vector;
 4371 
 4372             if (m_node-&gt;arrayMode().isInBounds()) {
 4373                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4374                 speculate(LoadFromHole, noValue(), 0, m_out.isZero64(result));
 4375                 setJSValue(result);
 4376                 break;
 4377             }
 4378 
 4379             LBasicBlock inBounds = m_out.newBlock();
 4380             LBasicBlock slowCase = m_out.newBlock();
 4381             LBasicBlock continuation = m_out.newBlock();
 4382 
 4383             m_out.branch(
 4384                 m_out.aboveOrEqual(index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
 4385                 rarely(slowCase), usually(inBounds));
 4386 
 4387             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4388             LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4389             ValueFromBlock fastResult = m_out.anchor(result);
 4390             m_out.branch(
 4391                 m_out.isZero64(result),
 4392                 rarely(slowCase), usually(continuation));
 4393 
 4394             m_out.appendTo(slowCase, continuation);
 4395             ValueFromBlock slowResult = m_out.anchor(
 4396                 vmCall(Int64, m_out.operation(operationGetByValObjectInt), m_callFrame, base, index));
 4397             m_out.jump(continuation);
 4398 
 4399             m_out.appendTo(continuation, lastNext);
 4400             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4401             return;
 4402         }
 4403 
 4404         case Array::String: {
 4405             compileStringCharAt();
 4406             return;
 4407         }
 4408 
 4409         case Array::Int8Array:
 4410         case Array::Int16Array:
 4411         case Array::Int32Array:
 4412         case Array::Uint8Array:
 4413         case Array::Uint8ClampedArray:
 4414         case Array::Uint16Array:
 4415         case Array::Uint32Array:
 4416         case Array::Float32Array:
 4417         case Array::Float64Array: {
 4418             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4419             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4420 
 4421             TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 4422             ASSERT(isTypedView(type));
 4423             {
 4424                 TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 4425 
 4426                 if (isInt(type)) {
 4427                     LValue result = loadFromIntTypedArray(pointer, type);
 4428                     bool canSpeculate = true;
 4429                     setIntTypedArrayLoadResult(result, type, canSpeculate);
 4430                     return;
 4431                 }
 4432 
 4433                 ASSERT(isFloat(type));
 4434 
 4435                 LValue result;
 4436                 switch (type) {
 4437                 case TypeFloat32:
 4438                     result = m_out.floatToDouble(m_out.loadFloat(pointer));
 4439                     break;
 4440                 case TypeFloat64:
 4441                     result = m_out.loadDouble(pointer);
 4442                     break;
 4443                 default:
 4444                     DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4445                 }
 4446 
 4447                 setDouble(result);
 4448                 return;
 4449             }
 4450         }
 4451 
 4452         case Array::AnyTypedArray:
 4453         case Array::ForceExit:
 4454         case Array::SelectUsingArguments:
 4455         case Array::SelectUsingPredictions:
 4456         case Array::Unprofiled:
 4457             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4458             return;
 4459         }
 4460     }
 4461 
 4462     void compileGetMyArgumentByVal()
 4463     {
 4464         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 4465 
 4466         LValue originalIndex = lowInt32(m_node-&gt;child2());
 4467 
 4468         LValue numberOfArgsIncludingThis;
 4469         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
 4470             numberOfArgsIncludingThis = m_out.constInt32(inlineCallFrame-&gt;argumentCountIncludingThis);
 4471         else {
 4472             VirtualRegister argumentCountRegister = AssemblyHelpers::argumentCount(inlineCallFrame);
 4473             numberOfArgsIncludingThis = m_out.load32(payloadFor(argumentCountRegister));
 4474         }
 4475 
 4476         LValue numberOfArgs = m_out.sub(numberOfArgsIncludingThis, m_out.int32One);
 4477         LValue indexToCheck = originalIndex;
 4478         LValue numberOfArgumentsToSkip = m_out.int32Zero;
 4479         if (m_node-&gt;numberOfArgumentsToSkip()) {
 4480             numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 4481             CheckValue* check = m_out.speculateAdd(indexToCheck, numberOfArgumentsToSkip);
 4482             blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 4483             indexToCheck = check;
 4484         }
 4485 
 4486         LValue isOutOfBounds = m_out.bitOr(m_out.aboveOrEqual(indexToCheck, numberOfArgs), m_out.below(indexToCheck, numberOfArgumentsToSkip));
 4487         LBasicBlock continuation = nullptr;
 4488         LBasicBlock lastNext = nullptr;
 4489         ValueFromBlock slowResult;
 4490         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4491             LBasicBlock normalCase = m_out.newBlock();
 4492             continuation = m_out.newBlock();
 4493 
 4494             slowResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined())));
 4495             m_out.branch(isOutOfBounds, unsure(continuation), unsure(normalCase));
 4496 
 4497             lastNext = m_out.appendTo(normalCase, continuation);
 4498         } else
 4499             speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4500 
 4501         LValue index = m_out.add(indexToCheck, m_out.int32One);
 4502 
 4503         TypedPointer base;
 4504         if (inlineCallFrame) {
 4505             if (inlineCallFrame-&gt;argumentCountIncludingThis &gt; 1)
 4506                 base = addressFor(inlineCallFrame-&gt;argumentsWithFixup[0].virtualRegister());
 4507         } else
 4508             base = addressFor(virtualRegisterForArgument(0));
 4509 
 4510         LValue result;
 4511         if (base) {
 4512             LValue pointer = m_out.baseIndex(
 4513                 base.value(), m_out.zeroExt(index, pointerType()), ScaleEight);
 4514             result = m_out.load64(TypedPointer(m_heaps.variables.atAnyIndex(), pointer));
 4515             result = preciseIndexMask32(result, indexToCheck, numberOfArgs);
 4516         } else
 4517             result = m_out.constInt64(JSValue::encode(jsUndefined()));
 4518 
 4519         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4520             ValueFromBlock normalResult = m_out.anchor(result);
 4521             m_out.jump(continuation);
 4522 
 4523             m_out.appendTo(continuation, lastNext);
 4524             result = m_out.phi(Int64, slowResult, normalResult);
 4525         }
 4526 
 4527         setJSValue(result);
 4528     }
 4529 
 4530     void compilePutByVal()
 4531     {
 4532         Edge child1 = m_graph.varArgChild(m_node, 0);
 4533         Edge child2 = m_graph.varArgChild(m_node, 1);
 4534         Edge child3 = m_graph.varArgChild(m_node, 2);
 4535         Edge child4 = m_graph.varArgChild(m_node, 3);
 4536         Edge child5 = m_graph.varArgChild(m_node, 4);
 4537 
 4538         ArrayMode arrayMode = m_node-&gt;arrayMode().modeForPut();
 4539         switch (arrayMode.type()) {
 4540         case Array::Generic: {
 4541             if (child1.useKind() == CellUse) {
 4542                 V_JITOperation_ECCJ operation = nullptr;
 4543                 if (child2.useKind() == StringUse) {
 4544                     if (m_node-&gt;op() == PutByValDirect) {
 4545                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4546                             operation = operationPutByValDirectCellStringStrict;
 4547                         else
 4548                             operation = operationPutByValDirectCellStringNonStrict;
 4549                     } else {
 4550                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4551                             operation = operationPutByValCellStringStrict;
 4552                         else
 4553                             operation = operationPutByValCellStringNonStrict;
 4554                     }
 4555                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowString(child2), lowJSValue(child3));
 4556                     return;
 4557                 }
 4558 
 4559                 if (child2.useKind() == SymbolUse) {
 4560                     if (m_node-&gt;op() == PutByValDirect) {
 4561                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4562                             operation = operationPutByValDirectCellSymbolStrict;
 4563                         else
 4564                             operation = operationPutByValDirectCellSymbolNonStrict;
 4565                     } else {
 4566                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4567                             operation = operationPutByValCellSymbolStrict;
 4568                         else
 4569                             operation = operationPutByValCellSymbolNonStrict;
 4570                     }
 4571                     vmCall(Void, m_out.operation(operation), m_callFrame, lowCell(child1), lowSymbol(child2), lowJSValue(child3));
 4572                     return;
 4573                 }
 4574             }
 4575 
 4576             V_JITOperation_EJJJ operation;
 4577             if (m_node-&gt;op() == PutByValDirect) {
 4578                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4579                     operation = operationPutByValDirectStrict;
 4580                 else
 4581                     operation = operationPutByValDirectNonStrict;
 4582             } else {
 4583                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4584                     operation = operationPutByValStrict;
 4585                 else
 4586                     operation = operationPutByValNonStrict;
 4587             }
 4588 
 4589             vmCall(
 4590                 Void, m_out.operation(operation), m_callFrame,
 4591                 lowJSValue(child1), lowJSValue(child2), lowJSValue(child3));
 4592             return;
 4593         }
 4594 
 4595         default:
 4596             break;
 4597         }
 4598 
 4599         LValue base = lowCell(child1);
 4600         LValue index = lowInt32(child2);
 4601         LValue storage = lowStorage(child4);
 4602 
 4603         switch (arrayMode.type()) {
 4604         case Array::Int32:
 4605         case Array::Double:
 4606         case Array::Contiguous: {
 4607             LBasicBlock continuation = m_out.newBlock();
 4608             LBasicBlock outerLastNext = m_out.appendTo(m_out.m_block, continuation);
 4609 
 4610             switch (arrayMode.type()) {
 4611             case Array::Int32:
 4612             case Array::Contiguous: {
 4613                 LValue value = lowJSValue(child3, ManualOperandSpeculation);
 4614 
 4615                 if (arrayMode.type() == Array::Int32)
 4616                     FTL_TYPE_CHECK(jsValueValue(value), child3, SpecInt32Only, isNotInt32(value));
 4617 
 4618                 TypedPointer elementPointer = m_out.baseIndex(
 4619                     arrayMode.type() == Array::Int32 ?
 4620                     m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties,
 4621                     storage, m_out.zeroExtPtr(index), provenValue(child2));
 4622 
 4623                 if (m_node-&gt;op() == PutByValAlias) {
 4624                     m_out.store64(value, elementPointer);
 4625                     break;
 4626                 }
 4627 
 4628                 contiguousPutByValOutOfBounds(
 4629                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4630                         ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4631                         : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
 4632                     base, storage, index, value, continuation);
 4633 
 4634                 m_out.store64(value, elementPointer);
 4635                 break;
 4636             }
 4637 
 4638             case Array::Double: {
 4639                 LValue value = lowDouble(child3);
 4640 
 4641                 FTL_TYPE_CHECK(
 4642                     doubleValue(value), child3, SpecDoubleReal,
 4643                     m_out.doubleNotEqualOrUnordered(value, value));
 4644 
 4645                 TypedPointer elementPointer = m_out.baseIndex(
 4646                     m_heaps.indexedDoubleProperties, storage, m_out.zeroExtPtr(index),
 4647                     provenValue(child2));
 4648 
 4649                 if (m_node-&gt;op() == PutByValAlias) {
 4650                     m_out.storeDouble(value, elementPointer);
 4651                     break;
 4652                 }
 4653 
 4654                 contiguousPutByValOutOfBounds(
 4655                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4656                         ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 4657                         : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 4658                     base, storage, index, value, continuation);
 4659 
 4660                 m_out.storeDouble(value, elementPointer);
 4661                 break;
 4662             }
 4663 
 4664             default:
 4665                 DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4666             }
 4667 
 4668             m_out.jump(continuation);
 4669             m_out.appendTo(continuation, outerLastNext);
 4670             return;
 4671         }
 4672 
 4673         case Array::ArrayStorage:
 4674         case Array::SlowPutArrayStorage: {
 4675             LValue value = lowJSValue(child3);
 4676 
 4677             TypedPointer elementPointer = m_out.baseIndex(
 4678                 m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(index),
 4679                 provenValue(child2));
 4680 
 4681             if (m_node-&gt;op() == PutByValAlias) {
 4682                 m_out.store64(value, elementPointer);
 4683                 return;
 4684             }
 4685 
 4686             if (arrayMode.isInBounds()) {
 4687                 speculate(StoreToHole, noValue(), 0, m_out.isZero64(m_out.load64(elementPointer)));
 4688                 m_out.store64(value, elementPointer);
 4689                 return;
 4690             }
 4691 
 4692             LValue isOutOfBounds = m_out.aboveOrEqual(
 4693                 index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
 4694 
 4695             auto slowPathFunction = m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4696                 ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4697                 : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
 4698             if (!arrayMode.isOutOfBounds()) {
 4699                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
 4700                 isOutOfBounds = m_out.booleanFalse;
 4701             }
 4702 
 4703             LBasicBlock inBoundCase = m_out.newBlock();
 4704             LBasicBlock slowCase = m_out.newBlock();
 4705             LBasicBlock holeCase = m_out.newBlock();
 4706             LBasicBlock doStoreCase = m_out.newBlock();
 4707             LBasicBlock lengthUpdateCase = m_out.newBlock();
 4708             LBasicBlock continuation = m_out.newBlock();
 4709 
 4710             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
 4711 
 4712             LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
 4713             vmCall(
 4714                 Void, m_out.operation(slowPathFunction),
 4715                 m_callFrame, base, index, value);
 4716             m_out.jump(continuation);
 4717 
 4718 
 4719             if (arrayMode.isSlowPut()) {
 4720                 m_out.appendTo(inBoundCase, doStoreCase);
 4721                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(slowCase), usually(doStoreCase));
 4722             } else {
 4723                 m_out.appendTo(inBoundCase, holeCase);
 4724                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(holeCase), usually(doStoreCase));
 4725 
 4726                 m_out.appendTo(holeCase, lengthUpdateCase);
 4727                 m_out.store32(
 4728                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 4729                     storage, m_heaps.ArrayStorage_numValuesInVector);
 4730                 m_out.branch(
 4731                     m_out.below(
 4732                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_publicLength)),
 4733                     unsure(doStoreCase), unsure(lengthUpdateCase));
 4734 
 4735                 m_out.appendTo(lengthUpdateCase, doStoreCase);
 4736                 m_out.store32(
 4737                     m_out.add(index, m_out.int32One),
 4738                     storage, m_heaps.ArrayStorage_publicLength);
 4739                 m_out.jump(doStoreCase);
 4740             }
 4741 
 4742             m_out.appendTo(doStoreCase, continuation);
 4743             m_out.store64(value, elementPointer);
 4744             m_out.jump(continuation);
 4745 
 4746             m_out.appendTo(continuation, lastNext);
 4747             return;
 4748         }
 4749 
 4750         case Array::Int8Array:
 4751         case Array::Int16Array:
 4752         case Array::Int32Array:
 4753         case Array::Uint8Array:
 4754         case Array::Uint8ClampedArray:
 4755         case Array::Uint16Array:
 4756         case Array::Uint32Array:
 4757         case Array::Float32Array:
 4758         case Array::Float64Array: {
 4759             TypedArrayType type = arrayMode.typedArrayType();
 4760 
 4761             ASSERT(isTypedView(type));
 4762             {
 4763                 TypedPointer pointer = TypedPointer(
 4764                     m_heaps.typedArrayProperties,
 4765                     m_out.add(
 4766                         storage,
 4767                         m_out.shl(
 4768                             m_out.zeroExt(index, pointerType()),
 4769                             m_out.constIntPtr(logElementSize(type)))));
 4770 
 4771                 LValue valueToStore;
 4772 
 4773                 if (isInt(type)) {
 4774                     LValue intValue = getIntTypedArrayStoreOperand(child3, isClamped(type));
 4775 
 4776                     valueToStore = intValue;
 4777                 } else /* !isInt(type) */ {
 4778                     LValue value = lowDouble(child3);
 4779                     switch (type) {
 4780                     case TypeFloat32:
 4781                         valueToStore = m_out.doubleToFloat(value);
 4782                         break;
 4783                     case TypeFloat64:
 4784                         valueToStore = value;
 4785                         break;
 4786                     default:
 4787                         DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4788                     }
 4789                 }
 4790 
 4791                 if (arrayMode.isInBounds() || m_node-&gt;op() == PutByValAlias)
 4792                     m_out.store(valueToStore, pointer, storeType(type));
 4793                 else {
 4794                     LBasicBlock isInBounds = m_out.newBlock();
 4795                     LBasicBlock isOutOfBounds = m_out.newBlock();
 4796                     LBasicBlock continuation = m_out.newBlock();
 4797 
 4798                     m_out.branch(
 4799                         m_out.aboveOrEqual(index, lowInt32(child5)),
 4800                         unsure(isOutOfBounds), unsure(isInBounds));
 4801 
 4802                     LBasicBlock lastNext = m_out.appendTo(isInBounds, isOutOfBounds);
 4803                     m_out.store(valueToStore, pointer, storeType(type));
 4804                     m_out.jump(continuation);
 4805 
 4806                     m_out.appendTo(isOutOfBounds, continuation);
 4807                     speculateTypedArrayIsNotNeutered(base);
 4808                     m_out.jump(continuation);
 4809 
 4810                     m_out.appendTo(continuation, lastNext);
 4811                 }
 4812 
 4813                 return;
 4814             }
 4815         }
 4816 
 4817         case Array::AnyTypedArray:
 4818         case Array::String:
 4819         case Array::DirectArguments:
 4820         case Array::ForceExit:
 4821         case Array::Generic:
 4822         case Array::ScopedArguments:
 4823         case Array::SelectUsingArguments:
 4824         case Array::SelectUsingPredictions:
 4825         case Array::Undecided:
 4826         case Array::Unprofiled:
 4827             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4828             break;
 4829         }
 4830     }
 4831 
 4832     void compilePutAccessorById()
 4833     {
 4834         LValue base = lowCell(m_node-&gt;child1());
 4835         LValue accessor = lowCell(m_node-&gt;child2());
 4836         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4837         vmCall(
 4838             Void,
 4839             m_out.operation(m_node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById),
 4840             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);
 4841     }
 4842 
 4843     void compilePutGetterSetterById()
 4844     {
 4845         LValue base = lowCell(m_node-&gt;child1());
 4846         LValue getter = lowJSValue(m_node-&gt;child2());
 4847         LValue setter = lowJSValue(m_node-&gt;child3());
 4848         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4849         vmCall(
 4850             Void, m_out.operation(operationPutGetterSetter),
 4851             m_callFrame, base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), getter, setter);
 4852 
 4853     }
 4854 
 4855     void compilePutAccessorByVal()
 4856     {
 4857         LValue base = lowCell(m_node-&gt;child1());
 4858         LValue subscript = lowJSValue(m_node-&gt;child2());
 4859         LValue accessor = lowCell(m_node-&gt;child3());
 4860         vmCall(
 4861             Void,
 4862             m_out.operation(m_node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal),
 4863             m_callFrame, base, subscript, m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);
 4864     }
 4865 
 4866     void compileDeleteById()
 4867     {
 4868         LValue base = lowJSValue(m_node-&gt;child1());
 4869         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 4870         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteById), m_callFrame, base, m_out.constIntPtr(uid))));
 4871     }
 4872 
 4873     void compileDeleteByVal()
 4874     {
 4875         LValue base = lowJSValue(m_node-&gt;child1());
 4876         LValue subscript = lowJSValue(m_node-&gt;child2());
 4877         setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationDeleteByVal), m_callFrame, base, subscript)));
 4878     }
 4879 
 4880     void compileArrayPush()
 4881     {
 4882         LValue base = lowCell(m_graph.varArgChild(m_node, 1));
 4883         LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
 4884         unsigned elementOffset = 2;
 4885         unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
 4886 
 4887         switch (m_node-&gt;arrayMode().type()) {
 4888         case Array::Int32:
 4889         case Array::Contiguous:
 4890         case Array::Double: {
 4891             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 4892 
 4893             if (elementCount == 1) {
 4894                 LValue value;
 4895                 Output::StoreType storeType;
 4896 
 4897                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
 4898                 speculate(element);
 4899                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4900                     value = lowJSValue(element, ManualOperandSpeculation);
 4901                     storeType = Output::Store64;
 4902                 } else {
 4903                     value = lowDouble(element);
 4904                     storeType = Output::StoreDouble;
 4905                 }
 4906 
 4907                 LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4908 
 4909                 LBasicBlock fastPath = m_out.newBlock();
 4910                 LBasicBlock slowPath = m_out.newBlock();
 4911                 LBasicBlock continuation = m_out.newBlock();
 4912 
 4913                 m_out.branch(
 4914                     m_out.aboveOrEqual(
 4915                         prevLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength)),
 4916                     unsure(slowPath), unsure(fastPath));
 4917 
 4918                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4919                 m_out.store(
 4920                     value, m_out.baseIndex(heap, storage, m_out.zeroExtPtr(prevLength)), storeType);
 4921                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 4922                 m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4923 
 4924                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4925                 m_out.jump(continuation);
 4926 
 4927                 m_out.appendTo(slowPath, continuation);
 4928                 LValue operation;
 4929                 if (m_node-&gt;arrayMode().type() != Array::Double)
 4930                     operation = m_out.operation(operationArrayPush);
 4931                 else
 4932                     operation = m_out.operation(operationArrayPushDouble);
 4933                 ValueFromBlock slowResult = m_out.anchor(
 4934                     vmCall(Int64, operation, m_callFrame, value, base));
 4935                 m_out.jump(continuation);
 4936 
 4937                 m_out.appendTo(continuation, lastNext);
 4938                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4939                 return;
 4940             }
 4941 
 4942             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4943                 Edge element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4944                 speculate(element);
 4945             }
 4946 
 4947             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 4948             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 4949 
 4950             LBasicBlock fastPath = m_out.newBlock();
 4951             LBasicBlock slowPath = m_out.newBlock();
 4952             LBasicBlock setup = m_out.newBlock();
 4953             LBasicBlock slowCallPath = m_out.newBlock();
 4954             LBasicBlock continuation = m_out.newBlock();
 4955 
 4956             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength));
 4957 
 4958             m_out.branch(beyondVectorLength, unsure(slowPath), unsure(fastPath));
 4959 
 4960             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 4961             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 4962             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight));
 4963             m_out.jump(setup);
 4964 
 4965             m_out.appendTo(slowPath, setup);
 4966             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 4967             static_assert(sizeof(EncodedJSValue) == sizeof(double), &quot;&quot;);
 4968             ASSERT(scratchSize);
 4969             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 4970             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 4971             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 4972             m_out.jump(setup);
 4973 
 4974             m_out.appendTo(setup, slowCallPath);
 4975             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 4976             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 4977                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 4978 
 4979                 LValue value;
 4980                 Output::StoreType storeType;
 4981                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 4982                     value = lowJSValue(element, ManualOperandSpeculation);
 4983                     storeType = Output::Store64;
 4984                 } else {
 4985                     value = lowDouble(element);
 4986                     storeType = Output::StoreDouble;
 4987                 }
 4988 
 4989                 m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
 4990             }
 4991             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 4992 
 4993             m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
 4994 
 4995             m_out.appendTo(slowCallPath, continuation);
 4996             LValue operation;
 4997             if (m_node-&gt;arrayMode().type() != Array::Double)
 4998                 operation = m_out.operation(operationArrayPushMultiple);
 4999             else
 5000                 operation = m_out.operation(operationArrayPushDoubleMultiple);
 5001             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 5002             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5003             m_out.jump(continuation);
 5004 
 5005             m_out.appendTo(continuation, lastNext);
 5006             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5007             return;
 5008         }
 5009 
 5010         case Array::ArrayStorage: {
 5011             // This ensures that the result of ArrayPush is Int32 in AI.
 5012             int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 5013 
 5014             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 5015             // Refuse to handle bizarre lengths.
 5016             speculate(Uncountable, noValue(), nullptr, m_out.above(prevLength, m_out.constInt32(largestPositiveInt32Length)));
 5017 
 5018             if (elementCount == 1) {
 5019                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
 5020 
 5021                 LValue value = lowJSValue(element);
 5022 
 5023                 LBasicBlock fastPath = m_out.newBlock();
 5024                 LBasicBlock slowPath = m_out.newBlock();
 5025                 LBasicBlock continuation = m_out.newBlock();
 5026 
 5027                 m_out.branch(
 5028                     m_out.aboveOrEqual(
 5029                         prevLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)),
 5030                     rarely(slowPath), usually(fastPath));
 5031 
 5032                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5033                 m_out.store64(
 5034                     value, m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(prevLength)));
 5035                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 5036                 m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5037                 m_out.store32(
 5038                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5039                     storage, m_heaps.ArrayStorage_numValuesInVector);
 5040 
 5041                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5042                 m_out.jump(continuation);
 5043 
 5044                 m_out.appendTo(slowPath, continuation);
 5045                 ValueFromBlock slowResult = m_out.anchor(
 5046                     vmCall(Int64, m_out.operation(operationArrayPush), m_callFrame, value, base));
 5047                 m_out.jump(continuation);
 5048 
 5049                 m_out.appendTo(continuation, lastNext);
 5050                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5051                 return;
 5052             }
 5053 
 5054             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 5055 
 5056             LBasicBlock fastPath = m_out.newBlock();
 5057             LBasicBlock slowPath = m_out.newBlock();
 5058             LBasicBlock setup = m_out.newBlock();
 5059             LBasicBlock slowCallPath = m_out.newBlock();
 5060             LBasicBlock continuation = m_out.newBlock();
 5061 
 5062             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength));
 5063 
 5064             m_out.branch(beyondVectorLength, rarely(slowPath), usually(fastPath));
 5065 
 5066             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5067             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5068             m_out.store32(
 5069                 m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.constInt32(elementCount)),
 5070                 storage, m_heaps.ArrayStorage_numValuesInVector);
 5071             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight, ArrayStorage::vectorOffset()));
 5072             m_out.jump(setup);
 5073 
 5074             m_out.appendTo(slowPath, setup);
 5075             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 5076             ASSERT(scratchSize);
 5077             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 5078             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5079             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 5080             m_out.jump(setup);
 5081 
 5082             m_out.appendTo(setup, slowCallPath);
 5083             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 5084             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 5085                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 5086 
 5087                 LValue value = lowJSValue(element);
 5088                 m_out.store64(value, m_out.baseIndex(m_heaps.ArrayStorage_vector.atAnyIndex(), buffer, m_out.constIntPtr(elementIndex), ScaleEight));
 5089             }
 5090             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5091 
 5092             m_out.branch(beyondVectorLength, rarely(slowCallPath), usually(continuation));
 5093 
 5094             m_out.appendTo(slowCallPath, continuation);
 5095             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationArrayPushMultiple), m_callFrame, base, buffer, m_out.constInt32(elementCount)));
 5096             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5097             m_out.jump(continuation);
 5098 
 5099             m_out.appendTo(continuation, lastNext);
 5100             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5101             return;
 5102         }
 5103 
 5104         default:
 5105             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5106             return;
 5107         }
 5108     }
 5109 
 5110     std::pair&lt;LValue, LValue&gt; populateSliceRange(LValue start, LValue end, LValue length)
 5111     {
 5112         // end can be nullptr.
 5113         ASSERT(start);
 5114         ASSERT(length);
 5115 
 5116         auto pickIndex = [&amp;] (LValue index) {
 5117             return m_out.select(m_out.greaterThanOrEqual(index, m_out.int32Zero),
 5118                 m_out.select(m_out.above(index, length), length, index),
 5119                 m_out.select(m_out.lessThan(m_out.add(length, index), m_out.int32Zero), m_out.int32Zero, m_out.add(length, index)));
 5120         };
 5121 
 5122         LValue endBoundary = length;
 5123         if (end)
 5124             endBoundary = pickIndex(end);
 5125         LValue startIndex = pickIndex(start);
 5126         return std::make_pair(startIndex, endBoundary);
 5127     }
 5128 
 5129     void compileArraySlice()
 5130     {
 5131         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5132 
 5133         LValue sourceArray = lowCell(m_graph.varArgChild(m_node, 0));
 5134         LValue sourceStorage = lowStorage(m_graph.varArgChild(m_node, m_node-&gt;numChildren() - 1));
 5135         LValue inputLength = m_out.load32(sourceStorage, m_heaps.Butterfly_publicLength);
 5136 
 5137         LValue startIndex = nullptr;
 5138         LValue resultLength = nullptr;
 5139         if (m_node-&gt;numChildren() == 2) {
 5140             startIndex = m_out.constInt32(0);
 5141             resultLength = inputLength;
 5142         } else {
 5143             LValue start = lowInt32(m_graph.varArgChild(m_node, 1));
 5144             LValue end = nullptr;
 5145             if (m_node-&gt;numChildren() != 3)
 5146                 end = lowInt32(m_graph.varArgChild(m_node, 2));
 5147 
 5148             auto range = populateSliceRange(start, end, inputLength);
 5149             startIndex = range.first;
 5150             LValue endBoundary = range.second;
 5151 
 5152             resultLength = m_out.select(m_out.belowOrEqual(startIndex, endBoundary),
 5153                 m_out.sub(endBoundary, startIndex),
 5154                 m_out.constInt32(0));
 5155         }
 5156 
 5157         ArrayValues arrayResult;
 5158         {
 5159             LValue indexingType = m_out.load8ZeroExt32(sourceArray, m_heaps.JSCell_indexingTypeAndMisc);
 5160             // We can ignore the writability of the cell since we won&#39;t write to the source.
 5161             indexingType = m_out.bitAnd(indexingType, m_out.constInt32(AllWritableArrayTypesAndHistory));
 5162             // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 5163             // to ensure the incoming array is one to be one of the original array structures
 5164             // with one of the following indexing shapes: Int32, Contiguous, Double.
 5165             LValue structure = m_out.select(
 5166                 m_out.equal(indexingType, m_out.constInt32(ArrayWithInt32)),
 5167                 weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))),
 5168                 m_out.select(m_out.equal(indexingType, m_out.constInt32(ArrayWithContiguous)),
 5169                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))),
 5170                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble)))));
 5171             arrayResult = allocateJSArray(resultLength, resultLength, structure, indexingType, false, false);
 5172         }
 5173 
 5174         // Keep the sourceArray alive at least until after anything that can GC.
 5175         keepAlive(sourceArray);
 5176 
 5177         LBasicBlock loop = m_out.newBlock();
 5178         LBasicBlock continuation = m_out.newBlock();
 5179 
 5180         resultLength = m_out.zeroExtPtr(resultLength);
 5181         ValueFromBlock startLoadIndex = m_out.anchor(m_out.zeroExtPtr(startIndex));
 5182         ValueFromBlock startStoreIndex = m_out.anchor(m_out.constIntPtr(0));
 5183 
 5184         m_out.branch(
 5185             m_out.below(m_out.constIntPtr(0), resultLength), unsure(loop), unsure(continuation));
 5186 
 5187         LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 5188         LValue storeIndex = m_out.phi(pointerType(), startStoreIndex);
 5189         LValue loadIndex = m_out.phi(pointerType(), startLoadIndex);
 5190         LValue value = m_out.load64(m_out.baseIndex(m_heaps.root, sourceStorage, loadIndex, ScaleEight));
 5191         m_out.store64(value, m_out.baseIndex(m_heaps.root, arrayResult.butterfly, storeIndex, ScaleEight));
 5192         LValue nextStoreIndex = m_out.add(storeIndex, m_out.constIntPtr(1));
 5193         m_out.addIncomingToPhi(storeIndex, m_out.anchor(nextStoreIndex));
 5194         m_out.addIncomingToPhi(loadIndex, m_out.anchor(m_out.add(loadIndex, m_out.constIntPtr(1))));
 5195         m_out.branch(
 5196             m_out.below(nextStoreIndex, resultLength), unsure(loop), unsure(continuation));
 5197 
 5198         m_out.appendTo(continuation, lastNext);
 5199 
 5200         mutatorFence();
 5201         setJSValue(arrayResult.array);
 5202     }
 5203 
 5204     void compileArrayIndexOf()
 5205     {
 5206         LValue storage = lowStorage(m_node-&gt;numChildren() == 3 ? m_graph.varArgChild(m_node, 2) : m_graph.varArgChild(m_node, 3));
 5207         LValue length = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5208 
 5209         LValue startIndex;
 5210         if (m_node-&gt;numChildren() == 4) {
 5211             startIndex = lowInt32(m_graph.varArgChild(m_node, 2));
 5212             startIndex = m_out.select(m_out.greaterThanOrEqual(startIndex, m_out.int32Zero),
 5213                 m_out.select(m_out.above(startIndex, length), length, startIndex),
 5214                 m_out.select(m_out.lessThan(m_out.add(length, startIndex), m_out.int32Zero), m_out.int32Zero, m_out.add(length, startIndex)));
 5215         } else
 5216             startIndex = m_out.int32Zero;
 5217 
 5218         Edge&amp; searchElementEdge = m_graph.varArgChild(m_node, 1);
 5219         switch (searchElementEdge.useKind()) {
 5220         case Int32Use:
 5221         case ObjectUse:
 5222         case SymbolUse:
 5223         case OtherUse:
 5224         case DoubleRepUse: {
 5225             LBasicBlock loopHeader = m_out.newBlock();
 5226             LBasicBlock loopBody = m_out.newBlock();
 5227             LBasicBlock loopNext = m_out.newBlock();
 5228             LBasicBlock notFound = m_out.newBlock();
 5229             LBasicBlock continuation = m_out.newBlock();
 5230 
 5231             LValue searchElement;
 5232             switch (searchElementEdge.useKind()) {
 5233             case Int32Use:
 5234                 ASSERT(m_node-&gt;arrayMode().type() == Array::Int32);
 5235                 speculate(searchElementEdge);
 5236                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5237                 break;
 5238             case ObjectUse:
 5239                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5240                 searchElement = lowObject(searchElementEdge);
 5241                 break;
 5242             case SymbolUse:
 5243                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5244                 searchElement = lowSymbol(searchElementEdge);
 5245                 break;
 5246             case OtherUse:
 5247                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5248                 speculate(searchElementEdge);
 5249                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5250                 break;
 5251             case DoubleRepUse:
 5252                 ASSERT(m_node-&gt;arrayMode().type() == Array::Double);
 5253                 searchElement = lowDouble(searchElementEdge);
 5254                 break;
 5255             default:
 5256                 RELEASE_ASSERT_NOT_REACHED();
 5257                 break;
 5258             }
 5259 
 5260             startIndex = m_out.zeroExtPtr(startIndex);
 5261             length = m_out.zeroExtPtr(length);
 5262 
 5263             ValueFromBlock initialStartIndex = m_out.anchor(startIndex);
 5264             m_out.jump(loopHeader);
 5265 
 5266             LBasicBlock lastNext = m_out.appendTo(loopHeader, loopBody);
 5267             LValue index = m_out.phi(pointerType(), initialStartIndex);
 5268             m_out.branch(m_out.notEqual(index, length), unsure(loopBody), unsure(notFound));
 5269 
 5270             m_out.appendTo(loopBody, loopNext);
 5271             ValueFromBlock foundResult = m_out.anchor(index);
 5272             switch (searchElementEdge.useKind()) {
 5273             case Int32Use: {
 5274                 // Empty value is ignored because of TagTypeNumber.
 5275                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedInt32Properties, storage, index));
 5276                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5277                 break;
 5278             }
 5279             case ObjectUse:
 5280             case SymbolUse:
 5281             case OtherUse: {
 5282                 // Empty value never matches against non-empty JS values.
 5283                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, index));
 5284                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5285                 break;
 5286             }
 5287             case DoubleRepUse: {
 5288                 // Empty value is ignored because of NaN.
 5289                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, storage, index));
 5290                 m_out.branch(m_out.doubleEqual(value, searchElement), unsure(continuation), unsure(loopNext));
 5291                 break;
 5292             }
 5293             default:
 5294                 RELEASE_ASSERT_NOT_REACHED();
 5295                 break;
 5296             }
 5297 
 5298             m_out.appendTo(loopNext, notFound);
 5299             LValue nextIndex = m_out.add(index, m_out.intPtrOne);
 5300             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 5301             m_out.jump(loopHeader);
 5302 
 5303             m_out.appendTo(notFound, continuation);
 5304             ValueFromBlock notFoundResult = m_out.anchor(m_out.constIntPtr(-1));
 5305             m_out.jump(continuation);
 5306 
 5307             m_out.appendTo(continuation, lastNext);
 5308             setInt32(m_out.castToInt32(m_out.phi(pointerType(), notFoundResult, foundResult)));
 5309             break;
 5310         }
 5311 
 5312         case StringUse:
 5313             ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5314             setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfString), m_callFrame, storage, lowString(searchElementEdge), startIndex));
 5315             break;
 5316 
 5317         case UntypedUse:
 5318             switch (m_node-&gt;arrayMode().type()) {
 5319             case Array::Double:
 5320                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueDouble), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));
 5321                 break;
 5322             case Array::Int32:
 5323             case Array::Contiguous:
 5324                 setInt32(vmCall(Int32, m_out.operation(operationArrayIndexOfValueInt32OrContiguous), m_callFrame, storage, lowJSValue(searchElementEdge), startIndex));
 5325                 break;
 5326             default:
 5327                 RELEASE_ASSERT_NOT_REACHED();
 5328                 break;
 5329             }
 5330             break;
 5331 
 5332         default:
 5333             RELEASE_ASSERT_NOT_REACHED();
 5334             break;
 5335         }
 5336     }
 5337 
 5338 
 5339     void compileArrayPop()
 5340     {
 5341         LValue base = lowCell(m_node-&gt;child1());
 5342         LValue storage = lowStorage(m_node-&gt;child2());
 5343 
 5344         switch (m_node-&gt;arrayMode().type()) {
 5345         case Array::Int32:
 5346         case Array::Double:
 5347         case Array::Contiguous: {
 5348             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 5349 
 5350             LBasicBlock fastCase = m_out.newBlock();
 5351             LBasicBlock slowCase = m_out.newBlock();
 5352             LBasicBlock continuation = m_out.newBlock();
 5353 
 5354             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5355 
 5356             Vector&lt;ValueFromBlock, 3&gt; results;
 5357             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5358             m_out.branch(
 5359                 m_out.isZero32(prevLength), rarely(continuation), usually(fastCase));
 5360 
 5361             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 5362             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5363             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 5364             TypedPointer pointer = m_out.baseIndex(heap, storage, m_out.zeroExtPtr(newLength));
 5365             if (m_node-&gt;arrayMode().type() != Array::Double) {
 5366                 LValue result = m_out.load64(pointer);
 5367                 m_out.store64(m_out.int64Zero, pointer);
 5368                 results.append(m_out.anchor(result));
 5369                 m_out.branch(
 5370                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 5371             } else {
 5372                 LValue result = m_out.loadDouble(pointer);
 5373                 m_out.store64(m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)), pointer);
 5374                 results.append(m_out.anchor(boxDouble(result)));
 5375                 m_out.branch(
 5376                     m_out.doubleEqual(result, result),
 5377                     usually(continuation), rarely(slowCase));
 5378             }
 5379 
 5380             m_out.appendTo(slowCase, continuation);
 5381             results.append(m_out.anchor(vmCall(
 5382                 Int64, m_out.operation(operationArrayPopAndRecoverLength), m_callFrame, base)));
 5383             m_out.jump(continuation);
 5384 
 5385             m_out.appendTo(continuation, lastNext);
 5386             setJSValue(m_out.phi(Int64, results));
 5387             return;
 5388         }
 5389 
 5390         case Array::ArrayStorage: {
 5391             LBasicBlock vectorLengthCheckCase = m_out.newBlock();
 5392             LBasicBlock popCheckCase = m_out.newBlock();
 5393             LBasicBlock fastCase = m_out.newBlock();
 5394             LBasicBlock slowCase = m_out.newBlock();
 5395             LBasicBlock continuation = m_out.newBlock();
 5396 
 5397             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 5398 
 5399             Vector&lt;ValueFromBlock, 3&gt; results;
 5400             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5401             m_out.branch(
 5402                 m_out.isZero32(prevLength), rarely(continuation), usually(vectorLengthCheckCase));
 5403 
 5404             LBasicBlock lastNext = m_out.appendTo(vectorLengthCheckCase, popCheckCase);
 5405             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5406             m_out.branch(
 5407                 m_out.aboveOrEqual(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)), rarely(slowCase), usually(popCheckCase));
 5408 
 5409             m_out.appendTo(popCheckCase, fastCase);
 5410             TypedPointer pointer = m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(newLength));
 5411             LValue result = m_out.load64(pointer);
 5412             m_out.branch(m_out.notZero64(result), usually(fastCase), rarely(slowCase));
 5413 
 5414             m_out.appendTo(fastCase, slowCase);
 5415             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5416             m_out.store64(m_out.int64Zero, pointer);
 5417             m_out.store32(
 5418                 m_out.sub(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5419                 storage, m_heaps.ArrayStorage_numValuesInVector);
 5420             results.append(m_out.anchor(result));
 5421             m_out.jump(continuation);
 5422 
 5423             m_out.appendTo(slowCase, continuation);
 5424             results.append(m_out.anchor(vmCall(
 5425                 Int64, m_out.operation(operationArrayPop), m_callFrame, base)));
 5426             m_out.jump(continuation);
 5427 
 5428             m_out.appendTo(continuation, lastNext);
 5429             setJSValue(m_out.phi(Int64, results));
 5430             return;
 5431         }
 5432 
 5433         default:
 5434             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5435             return;
 5436         }
 5437     }
 5438 
 5439     void compilePushWithScope()
 5440     {
 5441         LValue parentScope = lowCell(m_node-&gt;child1());
 5442         auto objectEdge = m_node-&gt;child2();
 5443         if (objectEdge.useKind() == ObjectUse) {
 5444             LValue object = lowNonNullObject(objectEdge);
 5445             LValue result = vmCall(Int64, m_out.operation(operationPushWithScopeObject), m_callFrame, parentScope, object);
 5446             setJSValue(result);
 5447         } else {
 5448             ASSERT(objectEdge.useKind() == UntypedUse);
 5449             LValue object = lowJSValue(m_node-&gt;child2());
 5450             LValue result = vmCall(Int64, m_out.operation(operationPushWithScope), m_callFrame, parentScope, object);
 5451             setJSValue(result);
 5452         }
 5453     }
 5454 
 5455     void compileCreateActivation()
 5456     {
 5457         LValue scope = lowCell(m_node-&gt;child1());
 5458         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
 5459         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
 5460         JSValue initializationValue = m_node-&gt;initializationValueForActivation();
 5461         ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
 5462         if (table-&gt;singleton().isStillValid()) {
 5463             LValue callResult = vmCall(
 5464                 Int64,
 5465                 m_out.operation(operationCreateActivationDirect), m_callFrame, weakStructure(structure),
 5466                 scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
 5467             setJSValue(callResult);
 5468             return;
 5469         }
 5470 
 5471         LBasicBlock slowPath = m_out.newBlock();
 5472         LBasicBlock continuation = m_out.newBlock();
 5473 
 5474         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5475 
 5476         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
 5477             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
 5478 
 5479         // We don&#39;t need memory barriers since we just fast-created the activation, so the
 5480         // activation must be young.
 5481         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
 5482         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
 5483 
 5484         for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 5485             m_out.store64(
 5486                 m_out.constInt64(JSValue::encode(initializationValue)),
 5487                 fastObject, m_heaps.JSLexicalEnvironment_variables[i]);
 5488         }
 5489 
 5490         mutatorFence();
 5491 
 5492         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5493         m_out.jump(continuation);
 5494 
 5495         m_out.appendTo(slowPath, continuation);
 5496         VM&amp; vm = this-&gt;vm();
 5497         LValue callResult = lazySlowPath(
 5498             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5499                 return createLazyCallGenerator(vm,
 5500                     operationCreateActivationDirect, locations[0].directGPR(),
 5501                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5502                     CCallHelpers::TrustedImmPtr(table),
 5503                     CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
 5504             },
 5505             scope);
 5506         ValueFromBlock slowResult = m_out.anchor(callResult);
 5507         m_out.jump(continuation);
 5508 
 5509         m_out.appendTo(continuation, lastNext);
 5510         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5511     }
 5512 
 5513     void compileNewFunction()
 5514     {
 5515         ASSERT(m_node-&gt;op() == NewFunction || m_node-&gt;op() == NewGeneratorFunction || m_node-&gt;op() == NewAsyncGeneratorFunction || m_node-&gt;op() == NewAsyncFunction);
 5516         bool isGeneratorFunction = m_node-&gt;op() == NewGeneratorFunction;
 5517         bool isAsyncFunction = m_node-&gt;op() == NewAsyncFunction;
 5518         bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
 5519 
 5520         LValue scope = lowCell(m_node-&gt;child1());
 5521 
 5522         FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 5523         if (executable-&gt;singleton().isStillValid()) {
 5524             LValue callResult =
 5525                 isGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5526                 isAsyncFunction ? vmCall(Int64, m_out.operation(operationNewAsyncFunction), m_callFrame, scope, weakPointer(executable)) :
 5527                 isAsyncGeneratorFunction ? vmCall(Int64, m_out.operation(operationNewAsyncGeneratorFunction), m_callFrame, scope, weakPointer(executable)) :
 5528                 vmCall(Int64, m_out.operation(operationNewFunction), m_callFrame, scope, weakPointer(executable));
 5529             setJSValue(callResult);
 5530             return;
 5531         }
 5532 
 5533         RegisteredStructure structure = m_graph.registerStructure(
 5534             [&amp;] () {
 5535                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5536                 switch (m_node-&gt;op()) {
 5537                 case NewGeneratorFunction:
 5538                     return globalObject-&gt;generatorFunctionStructure();
 5539                 case NewAsyncFunction:
 5540                     return globalObject-&gt;asyncFunctionStructure();
 5541                 case NewAsyncGeneratorFunction:
 5542                     return globalObject-&gt;asyncGeneratorFunctionStructure();
 5543                 case NewFunction:
 5544                     return JSFunction::selectStructureForNewFuncExp(globalObject, m_node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 5545                 default:
 5546                     RELEASE_ASSERT_NOT_REACHED();
 5547                 }
 5548             }());
 5549 
 5550         LBasicBlock slowPath = m_out.newBlock();
 5551         LBasicBlock continuation = m_out.newBlock();
 5552 
 5553         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5554 
 5555         LValue fastObject =
 5556             isGeneratorFunction ? allocateObject&lt;JSGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5557             isAsyncFunction ? allocateObject&lt;JSAsyncFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5558             isAsyncGeneratorFunction ? allocateObject&lt;JSAsyncGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5559             allocateObject&lt;JSFunction&gt;(structure, m_out.intPtrZero, slowPath);
 5560 
 5561 
 5562         // We don&#39;t need memory barriers since we just fast-created the function, so it
 5563         // must be young.
 5564         m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
 5565         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executable);
 5566         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.JSFunction_rareData);
 5567 
 5568         VM&amp; vm = this-&gt;vm();
 5569         if (executable-&gt;isAnonymousBuiltinFunction()) {
 5570             mutatorFence();
 5571             Allocator allocator = allocatorForNonVirtualConcurrently&lt;FunctionRareData&gt;(vm, sizeof(FunctionRareData), AllocatorForMode::AllocatorIfExists);
 5572             LValue rareData = allocateCell(m_out.constIntPtr(allocator.localAllocator()), vm.functionRareDataStructure.get(), slowPath);
 5573             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocator);
 5574             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_structure);
 5575             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_prototype);
 5576             m_out.storePtr(m_out.intPtrOne, rareData, m_heaps.FunctionRareData_objectAllocationProfileWatchpoint);
 5577             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);
 5578             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_boundFunctionStructure);
 5579             m_out.storePtr(m_out.intPtrZero, rareData, m_heaps.FunctionRareData_allocationProfileClearingWatchpoint);
 5580             m_out.store32As8(m_out.int32One, rareData, m_heaps.FunctionRareData_hasReifiedName);
 5581             m_out.store32As8(m_out.int32Zero, rareData, m_heaps.FunctionRareData_hasReifiedLength);
 5582             mutatorFence();
 5583             m_out.storePtr(rareData, fastObject, m_heaps.JSFunction_rareData);
 5584         } else
 5585             mutatorFence();
 5586 
 5587         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5588         m_out.jump(continuation);
 5589 
 5590         m_out.appendTo(slowPath, continuation);
 5591 
 5592         Vector&lt;LValue&gt; slowPathArguments;
 5593         slowPathArguments.append(scope);
 5594         LValue callResult = lazySlowPath(
 5595             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5596                 auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
 5597                 if (isGeneratorFunction)
 5598                     operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5599                 else if (isAsyncFunction)
 5600                     operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
 5601                 else if (isAsyncGeneratorFunction)
 5602                     operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5603 
 5604                 return createLazyCallGenerator(vm, operation,
 5605                     locations[0].directGPR(), locations[1].directGPR(),
 5606                     CCallHelpers::TrustedImmPtr(executable));
 5607             },
 5608             slowPathArguments);
 5609         ValueFromBlock slowResult = m_out.anchor(callResult);
 5610         m_out.jump(continuation);
 5611 
 5612         m_out.appendTo(continuation, lastNext);
 5613         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5614     }
 5615 
 5616     void compileCreateDirectArguments()
 5617     {
 5618         // FIXME: A more effective way of dealing with the argument count and callee is to have
 5619         // them be explicit arguments to this node.
 5620         // https://bugs.webkit.org/show_bug.cgi?id=142207
 5621 
 5622         RegisteredStructure structure =
 5623             m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 5624 
 5625         unsigned minCapacity = m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic)-&gt;numParameters() - 1;
 5626 
 5627         LBasicBlock slowPath = m_out.newBlock();
 5628         LBasicBlock continuation = m_out.newBlock();
 5629 
 5630         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5631 
 5632         ArgumentsLength length = getArgumentsLength();
 5633 
 5634         LValue fastObject;
 5635         if (length.isKnown) {
 5636             fastObject = allocateObject&lt;DirectArguments&gt;(
 5637                 DirectArguments::allocationSize(std::max(length.known, minCapacity)), structure,
 5638                 m_out.intPtrZero, slowPath);
 5639         } else {
 5640             LValue size = m_out.add(
 5641                 m_out.shl(length.value, m_out.constInt32(3)),
 5642                 m_out.constInt32(DirectArguments::storageOffset()));
 5643 
 5644             size = m_out.select(
 5645                 m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5646                 size, m_out.constInt32(DirectArguments::allocationSize(minCapacity)));
 5647 
 5648             fastObject = allocateVariableSizedObject&lt;DirectArguments&gt;(
 5649                 m_out.zeroExtPtr(size), structure, m_out.intPtrZero, slowPath);
 5650         }
 5651 
 5652         m_out.store32(length.value, fastObject, m_heaps.DirectArguments_length);
 5653         m_out.store32(m_out.constInt32(minCapacity), fastObject, m_heaps.DirectArguments_minCapacity);
 5654         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_mappedArguments);
 5655         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_modifiedArgumentsDescriptor);
 5656 
 5657         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5658         m_out.jump(continuation);
 5659 
 5660         m_out.appendTo(slowPath, continuation);
 5661         VM&amp; vm = this-&gt;vm();
 5662         LValue callResult = lazySlowPath(
 5663             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5664                 return createLazyCallGenerator(vm,
 5665                     operationCreateDirectArguments, locations[0].directGPR(),
 5666                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5667                     CCallHelpers::TrustedImm32(minCapacity));
 5668             }, length.value);
 5669         ValueFromBlock slowResult = m_out.anchor(callResult);
 5670         m_out.jump(continuation);
 5671 
 5672         m_out.appendTo(continuation, lastNext);
 5673         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
 5674 
 5675         m_out.storePtr(getCurrentCallee(), result, m_heaps.DirectArguments_callee);
 5676 
 5677         if (length.isKnown) {
 5678             VirtualRegister start = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic);
 5679             for (unsigned i = 0; i &lt; std::max(length.known, minCapacity); ++i) {
 5680                 m_out.store64(
 5681                     m_out.load64(addressFor(start + i)),
 5682                     result, m_heaps.DirectArguments_storage[i]);
 5683             }
 5684         } else {
 5685             LValue stackBase = getArgumentsStart();
 5686 
 5687             LBasicBlock loop = m_out.newBlock();
 5688             LBasicBlock end = m_out.newBlock();
 5689 
 5690             ValueFromBlock originalLength;
 5691             if (minCapacity) {
 5692                 LValue capacity = m_out.select(
 5693                     m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5694                     length.value,
 5695                     m_out.constInt32(minCapacity));
 5696                 LValue originalLengthValue = m_out.zeroExtPtr(capacity);
 5697                 originalLength = m_out.anchor(originalLengthValue);
 5698                 m_out.jump(loop);
 5699             } else {
 5700                 LValue originalLengthValue = m_out.zeroExtPtr(length.value);
 5701                 originalLength = m_out.anchor(originalLengthValue);
 5702                 m_out.branch(m_out.isNull(originalLengthValue), unsure(end), unsure(loop));
 5703             }
 5704 
 5705             lastNext = m_out.appendTo(loop, end);
 5706             LValue previousIndex = m_out.phi(pointerType(), originalLength);
 5707             LValue index = m_out.sub(previousIndex, m_out.intPtrOne);
 5708             m_out.store64(
 5709                 m_out.load64(m_out.baseIndex(m_heaps.variables, stackBase, index)),
 5710                 m_out.baseIndex(m_heaps.DirectArguments_storage, result, index));
 5711             ValueFromBlock nextIndex = m_out.anchor(index);
 5712             m_out.addIncomingToPhi(previousIndex, nextIndex);
 5713             m_out.branch(m_out.isNull(index), unsure(end), unsure(loop));
 5714 
 5715             m_out.appendTo(end, lastNext);
 5716         }
 5717 
 5718         mutatorFence();
 5719 
 5720         setJSValue(result);
 5721     }
 5722 
 5723     void compileCreateScopedArguments()
 5724     {
 5725         LValue scope = lowCell(m_node-&gt;child1());
 5726 
 5727         LValue result = vmCall(
 5728             Int64, m_out.operation(operationCreateScopedArguments), m_callFrame,
 5729             weakPointer(
 5730                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
 5731             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee(), scope);
 5732 
 5733         setJSValue(result);
 5734     }
 5735 
 5736     void compileCreateClonedArguments()
 5737     {
 5738         LValue result = vmCall(
 5739             Int64, m_out.operation(operationCreateClonedArguments), m_callFrame,
 5740             weakPointer(
 5741                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
 5742             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee());
 5743 
 5744         setJSValue(result);
 5745     }
 5746 
 5747     void compileCreateRest()
 5748     {
 5749         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 5750             LBasicBlock continuation = m_out.newBlock();
 5751             LValue arrayLength = lowInt32(m_node-&gt;child1());
 5752             LBasicBlock loopStart = m_out.newBlock();
 5753             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5754             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalRestParameterStructure());
 5755             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(arrayLength, structure);
 5756             LValue array = arrayValues.array;
 5757             LValue butterfly = arrayValues.butterfly;
 5758             ValueFromBlock startLength = m_out.anchor(arrayLength);
 5759             LValue argumentRegion = m_out.add(getArgumentsStart(), m_out.constInt64(sizeof(Register) * m_node-&gt;numberOfArgumentsToSkip()));
 5760             m_out.branch(m_out.equal(arrayLength, m_out.constInt32(0)),
 5761                 unsure(continuation), unsure(loopStart));
 5762 
 5763             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 5764             LValue phiOffset = m_out.phi(Int32, startLength);
 5765             LValue currentOffset = m_out.sub(phiOffset, m_out.int32One);
 5766             m_out.addIncomingToPhi(phiOffset, m_out.anchor(currentOffset));
 5767             LValue loadedValue = m_out.load64(m_out.baseIndex(m_heaps.variables, argumentRegion, m_out.zeroExtPtr(currentOffset)));
 5768             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 5769             m_out.store64(loadedValue, m_out.baseIndex(heap, butterfly, m_out.zeroExtPtr(currentOffset)));
 5770             m_out.branch(m_out.equal(currentOffset, m_out.constInt32(0)), unsure(continuation), unsure(loopStart));
 5771 
 5772             m_out.appendTo(continuation, lastNext);
 5773             mutatorFence();
 5774             setJSValue(array);
 5775             return;
 5776         }
 5777 
 5778         LValue arrayLength = lowInt32(m_node-&gt;child1());
 5779         LValue argumentStart = getArgumentsStart();
 5780         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 5781         setJSValue(vmCall(
 5782             Int64, m_out.operation(operationCreateRest), m_callFrame, argumentStart, numberOfArgumentsToSkip, arrayLength));
 5783     }
 5784 
 5785     void compileGetRestLength()
 5786     {
 5787         LBasicBlock nonZeroLength = m_out.newBlock();
 5788         LBasicBlock continuation = m_out.newBlock();
 5789 
 5790         ValueFromBlock zeroLengthResult = m_out.anchor(m_out.constInt32(0));
 5791 
 5792         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 5793         LValue argumentsLength = getArgumentsLength().value;
 5794         m_out.branch(m_out.above(argumentsLength, numberOfArgumentsToSkip),
 5795             unsure(nonZeroLength), unsure(continuation));
 5796 
 5797         LBasicBlock lastNext = m_out.appendTo(nonZeroLength, continuation);
 5798         ValueFromBlock nonZeroLengthResult = m_out.anchor(m_out.sub(argumentsLength, numberOfArgumentsToSkip));
 5799         m_out.jump(continuation);
 5800 
 5801         m_out.appendTo(continuation, lastNext);
 5802         setInt32(m_out.phi(Int32, zeroLengthResult, nonZeroLengthResult));
 5803     }
 5804 
 5805     void compileObjectKeys()
 5806     {
 5807         switch (m_node-&gt;child1().useKind()) {
 5808         case ObjectUse: {
 5809             if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 5810                 LBasicBlock notNullCase = m_out.newBlock();
 5811                 LBasicBlock rareDataCase = m_out.newBlock();
 5812                 LBasicBlock useCacheCase = m_out.newBlock();
 5813                 LBasicBlock slowButArrayBufferCase = m_out.newBlock();
 5814                 LBasicBlock slowCase = m_out.newBlock();
 5815                 LBasicBlock continuation = m_out.newBlock();
 5816 
 5817                 LValue object = lowObject(m_node-&gt;child1());
 5818                 LValue structure = loadStructure(object);
 5819                 LValue previousOrRareData = m_out.loadPtr(structure, m_heaps.Structure_previousOrRareData);
 5820                 m_out.branch(m_out.notNull(previousOrRareData), unsure(notNullCase), unsure(slowCase));
 5821 
 5822                 LBasicBlock lastNext = m_out.appendTo(notNullCase, rareDataCase);
 5823                 m_out.branch(
 5824                     m_out.notEqual(m_out.load32(previousOrRareData, m_heaps.JSCell_structureID), m_out.constInt32(m_graph.m_vm.structureStructure-&gt;structureID())),
 5825                     unsure(rareDataCase), unsure(slowCase));
 5826 
 5827                 m_out.appendTo(rareDataCase, useCacheCase);
 5828                 ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
 5829                 LValue cachedOwnKeys = m_out.loadPtr(previousOrRareData, m_heaps.StructureRareData_cachedOwnKeys);
 5830                 m_out.branch(m_out.belowOrEqual(cachedOwnKeys, m_out.constIntPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))), unsure(slowCase), unsure(useCacheCase));
 5831 
 5832                 m_out.appendTo(useCacheCase, slowButArrayBufferCase);
 5833                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5834                 RegisteredStructure arrayStructure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
 5835                 LValue fastArray = allocateObject&lt;JSArray&gt;(arrayStructure, m_out.addPtr(cachedOwnKeys, JSImmutableButterfly::offsetOfData()), slowButArrayBufferCase);
 5836                 ValueFromBlock fastResult = m_out.anchor(fastArray);
 5837                 m_out.jump(continuation);
 5838 
 5839                 m_out.appendTo(slowButArrayBufferCase, slowCase);
 5840                 LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(arrayStructure), cachedOwnKeys);
 5841                 ValueFromBlock slowButArrayBufferResult = m_out.anchor(slowArray);
 5842                 m_out.jump(continuation);
 5843 
 5844                 m_out.appendTo(slowCase, continuation);
 5845                 VM&amp; vm = this-&gt;vm();
 5846                 LValue slowResultValue = lazySlowPath(
 5847                     [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5848                         return createLazyCallGenerator(vm,
 5849                             operationObjectKeysObject, locations[0].directGPR(), locations[1].directGPR());
 5850                     },
 5851                     object);
 5852                 ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 5853                 m_out.jump(continuation);
 5854 
 5855                 m_out.appendTo(continuation, lastNext);
 5856                 setJSValue(m_out.phi(pointerType(), fastResult, slowButArrayBufferResult, slowResult));
 5857                 break;
 5858             }
 5859             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeysObject), m_callFrame, lowObject(m_node-&gt;child1())));
 5860             break;
 5861         }
 5862         case UntypedUse:
 5863             setJSValue(vmCall(Int64, m_out.operation(operationObjectKeys), m_callFrame, lowJSValue(m_node-&gt;child1())));
 5864             break;
 5865         default:
 5866             RELEASE_ASSERT_NOT_REACHED();
 5867             break;
 5868         }
 5869     }
 5870 
 5871     void compileObjectCreate()
 5872     {
 5873         switch (m_node-&gt;child1().useKind()) {
 5874         case ObjectUse:
 5875             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreateObject), m_callFrame, lowObject(m_node-&gt;child1())));
 5876             break;
 5877         case UntypedUse:
 5878             setJSValue(vmCall(Int64, m_out.operation(operationObjectCreate), m_callFrame, lowJSValue(m_node-&gt;child1())));
 5879             break;
 5880         default:
 5881             RELEASE_ASSERT_NOT_REACHED();
 5882             break;
 5883         }
 5884     }
 5885 
 5886     void compileNewObject()
 5887     {
 5888         setJSValue(allocateObject(m_node-&gt;structure()));
 5889         mutatorFence();
 5890     }
 5891 
 5892     void compileNewStringObject()
 5893     {
 5894         RegisteredStructure structure = m_node-&gt;structure();
 5895         LValue string = lowString(m_node-&gt;child1());
 5896 
 5897         LBasicBlock slowCase = m_out.newBlock();
 5898         LBasicBlock continuation = m_out.newBlock();
 5899 
 5900         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
 5901 
 5902         LValue fastResultValue = allocateObject&lt;StringObject&gt;(structure, m_out.intPtrZero, slowCase);
 5903         m_out.storePtr(m_out.constIntPtr(StringObject::info()), fastResultValue, m_heaps.JSDestructibleObject_classInfo);
 5904         m_out.store64(string, fastResultValue, m_heaps.JSWrapperObject_internalValue);
 5905         mutatorFence();
 5906         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 5907         m_out.jump(continuation);
 5908 
 5909         m_out.appendTo(slowCase, continuation);
 5910         VM&amp; vm = this-&gt;vm();
 5911         LValue slowResultValue = lazySlowPath(
 5912             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5913                 return createLazyCallGenerator(vm,
 5914                     operationNewStringObject, locations[0].directGPR(), locations[1].directGPR(),
 5915                     CCallHelpers::TrustedImmPtr(structure.get()));
 5916             },
 5917             string);
 5918         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 5919         m_out.jump(continuation);
 5920 
 5921         m_out.appendTo(continuation, lastNext);
 5922         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5923     }
 5924 
 5925     void compileNewSymbol()
 5926     {
 5927         if (!m_node-&gt;child1()) {
 5928             setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbol), m_callFrame));
 5929             return;
 5930         }
 5931         ASSERT(m_node-&gt;child1().useKind() == KnownStringUse);
 5932         setJSValue(vmCall(pointerType(), m_out.operation(operationNewSymbolWithDescription), m_callFrame, lowString(m_node-&gt;child1())));
 5933     }
 5934 
 5935     void compileNewArray()
 5936     {
 5937         // First speculate appropriately on all of the children. Do this unconditionally up here
 5938         // because some of the slow paths may otherwise forget to do it. It&#39;s sort of arguable
 5939         // that doing the speculations up here might be unprofitable for RA - so we can consider
 5940         // sinking this to below the allocation fast path if we find that this has a lot of
 5941         // register pressure.
 5942         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex)
 5943             speculate(m_graph.varArgChild(m_node, operandIndex));
 5944 
 5945         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5946         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 5947             m_node-&gt;indexingType()));
 5948 
 5949         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 5950             unsigned numElements = m_node-&gt;numChildren();
 5951             unsigned vectorLengthHint = m_node-&gt;vectorLengthHint();
 5952             ASSERT(vectorLengthHint &gt;= numElements);
 5953 
 5954             ArrayValues arrayValues =
 5955                 allocateUninitializedContiguousJSArray(numElements, vectorLengthHint, structure);
 5956 
 5957             for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 5958                 Edge edge = m_graph.varArgChild(m_node, operandIndex);
 5959 
 5960                 switch (m_node-&gt;indexingType()) {
 5961                 case ALL_BLANK_INDEXING_TYPES:
 5962                 case ALL_UNDECIDED_INDEXING_TYPES:
 5963                     DFG_CRASH(m_graph, m_node, &quot;Bad indexing type&quot;);
 5964                     break;
 5965 
 5966                 case ALL_DOUBLE_INDEXING_TYPES:
 5967                     m_out.storeDouble(
 5968                         lowDouble(edge),
 5969                         arrayValues.butterfly, m_heaps.indexedDoubleProperties[operandIndex]);
 5970                     break;
 5971 
 5972                 case ALL_INT32_INDEXING_TYPES:
 5973                 case ALL_CONTIGUOUS_INDEXING_TYPES:
 5974                     m_out.store64(
 5975                         lowJSValue(edge, ManualOperandSpeculation),
 5976                         arrayValues.butterfly,
 5977                         m_heaps.forIndexingType(m_node-&gt;indexingType())-&gt;at(operandIndex));
 5978                     break;
 5979 
 5980                 default:
 5981                     DFG_CRASH(m_graph, m_node, &quot;Corrupt indexing type&quot;);
 5982                     break;
 5983                 }
 5984             }
 5985 
 5986             setJSValue(arrayValues.array);
 5987             mutatorFence();
 5988             return;
 5989         }
 5990 
 5991         if (!m_node-&gt;numChildren()) {
 5992             setJSValue(vmCall(
 5993                 Int64, m_out.operation(operationNewEmptyArray), m_callFrame,
 5994                 weakStructure(structure)));
 5995             return;
 5996         }
 5997 
 5998         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 5999         ASSERT(scratchSize);
 6000         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 6001         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 6002 
 6003         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 6004             Edge edge = m_graph.varArgChild(m_node, operandIndex);
 6005             LValue valueToStore;
 6006             switch (m_node-&gt;indexingType()) {
 6007             case ALL_DOUBLE_INDEXING_TYPES:
 6008                 valueToStore = boxDouble(lowDouble(edge));
 6009                 break;
 6010             default:
 6011                 valueToStore = lowJSValue(edge, ManualOperandSpeculation);
 6012                 break;
 6013             }
 6014             m_out.store64(valueToStore, m_out.absolute(buffer + operandIndex));
 6015         }
 6016 
 6017         m_out.storePtr(
 6018             m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6019 
 6020         LValue result = vmCall(
 6021             Int64, m_out.operation(operationNewArray), m_callFrame,
 6022             weakStructure(structure), m_out.constIntPtr(buffer),
 6023             m_out.constIntPtr(m_node-&gt;numChildren()));
 6024 
 6025         m_out.storePtr(m_out.intPtrZero, m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6026 
 6027         setJSValue(result);
 6028     }
 6029 
 6030     void compileNewArrayWithSpread()
 6031     {
 6032         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 6033             CheckedInt32 startLength = 0;
 6034             BitVector* bitVector = m_node-&gt;bitVector();
 6035             HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 6036 
 6037             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6038                 if (!bitVector-&gt;get(i))
 6039                     ++startLength;
 6040                 else {
 6041                     Edge&amp; child = m_graph.varArgChild(m_node, i);
 6042                     if (child-&gt;op() == PhantomSpread &amp;&amp; child-&gt;child1()-&gt;op() == PhantomNewArrayBuffer)
 6043                         startLength += child-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 6044                 }
 6045             }
 6046 
 6047             if (startLength.hasOverflowed()) {
 6048                 terminate(Overflow);
 6049                 return;
 6050             }
 6051 
 6052             LValue length = m_out.constInt32(startLength.unsafeGet());
 6053 
 6054             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6055                 if (bitVector-&gt;get(i)) {
 6056                     Edge use = m_graph.varArgChild(m_node, i);
 6057                     CheckValue* lengthCheck = nullptr;
 6058                     if (use-&gt;op() == PhantomSpread) {
 6059                         if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6060                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6061                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6062                             LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 6063                                 return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6064                             }).iterator-&gt;value;
 6065                             lengthCheck = m_out.speculateAdd(length, spreadLength);
 6066                         }
 6067                     } else {
 6068                         LValue fixedArray = lowCell(use);
 6069                         lengthCheck = m_out.speculateAdd(length, m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 6070                     }
 6071 
 6072                     if (lengthCheck) {
 6073                         blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
 6074                         length = lengthCheck;
 6075                     }
 6076                 }
 6077             }
 6078 
 6079             LValue exceedsMaxAllowedLength = m_out.aboveOrEqual(length, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
 6080             blessSpeculation(m_out.speculate(exceedsMaxAllowedLength), Overflow, noValue(), nullptr, m_origin);
 6081 
 6082             RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
 6083             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(length, structure);
 6084             LValue result = arrayValues.array;
 6085             LValue storage = arrayValues.butterfly;
 6086             LValue index = m_out.constIntPtr(0);
 6087 
 6088             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6089                 Edge use = m_graph.varArgChild(m_node, i);
 6090                 if (bitVector-&gt;get(i)) {
 6091                     if (use-&gt;op() == PhantomSpread) {
 6092                         if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 6093                             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6094                             auto* array = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6095                             for (unsigned i = 0; i &lt; array-&gt;length(); ++i) {
 6096                                 // Because resulted array from NewArrayWithSpread is always contiguous, we should not generate value
 6097                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6098                                 int64_t value = JSValue::encode(array-&gt;get(i));
 6099                                 m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
 6100                             }
 6101                             index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
 6102                         } else {
 6103                             RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
 6104                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6105                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6106 
 6107                             LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 6108                             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6109 
 6110                             LBasicBlock loopStart = m_out.newBlock();
 6111                             LBasicBlock continuation = m_out.newBlock();
 6112 
 6113                             ValueFromBlock loadIndexStart = m_out.anchor(m_out.constIntPtr(0));
 6114                             ValueFromBlock arrayIndexStart = m_out.anchor(index);
 6115                             ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 6116 
 6117                             m_out.branch(
 6118                                 m_out.isZero64(length),
 6119                                 unsure(continuation), unsure(loopStart));
 6120 
 6121                             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6122 
 6123                             LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 6124                             LValue loadIndex = m_out.phi(pointerType(), loadIndexStart);
 6125 
 6126                             LValue item = m_out.load64(m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 6127                             m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 6128 
 6129                             LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
 6130                             LValue nextLoadIndex = m_out.add(loadIndex, m_out.constIntPtr(1));
 6131                             ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 6132 
 6133                             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 6134                             m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 6135 
 6136                             m_out.branch(
 6137                                 m_out.below(nextLoadIndex, length),
 6138                                 unsure(loopStart), unsure(continuation));
 6139 
 6140                             m_out.appendTo(continuation, lastNext);
 6141                             index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 6142                         }
 6143                     } else {
 6144                         LBasicBlock loopStart = m_out.newBlock();
 6145                         LBasicBlock continuation = m_out.newBlock();
 6146 
 6147                         LValue fixedArray = lowCell(use);
 6148 
 6149                         ValueFromBlock fixedIndexStart = m_out.anchor(m_out.constIntPtr(0));
 6150                         ValueFromBlock arrayIndexStart = m_out.anchor(index);
 6151                         ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 6152 
 6153                         LValue fixedArraySize = m_out.zeroExtPtr(m_out.load32(fixedArray, m_heaps.JSFixedArray_size));
 6154 
 6155                         m_out.branch(
 6156                             m_out.isZero64(fixedArraySize),
 6157                             unsure(continuation), unsure(loopStart));
 6158 
 6159                         LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6160 
 6161                         LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 6162                         LValue fixedArrayIndex = m_out.phi(pointerType(), fixedIndexStart);
 6163 
 6164                         LValue item = m_out.load64(m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, fixedArrayIndex));
 6165                         m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 6166 
 6167                         LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
 6168                         LValue nextFixedArrayIndex = m_out.add(fixedArrayIndex, m_out.constIntPtr(1));
 6169                         ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 6170 
 6171                         m_out.addIncomingToPhi(fixedArrayIndex, m_out.anchor(nextFixedArrayIndex));
 6172                         m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 6173 
 6174                         m_out.branch(
 6175                             m_out.below(nextFixedArrayIndex, fixedArraySize),
 6176                             unsure(loopStart), unsure(continuation));
 6177 
 6178                         m_out.appendTo(continuation, lastNext);
 6179                         index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 6180                     }
 6181                 } else {
 6182                     IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6183                     LValue item = lowJSValue(use);
 6184                     m_out.store64(item, m_out.baseIndex(heap, storage, index));
 6185                     index = m_out.add(index, m_out.constIntPtr(1));
 6186                 }
 6187             }
 6188 
 6189             mutatorFence();
 6190             setJSValue(result);
 6191             return;
 6192         }
 6193 
 6194         ASSERT(m_node-&gt;numChildren());
 6195         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 6196         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 6197         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 6198         BitVector* bitVector = m_node-&gt;bitVector();
 6199         for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6200             Edge use = m_graph.m_varArgChildren[m_node-&gt;firstChild() + i];
 6201             LValue value;
 6202             if (bitVector-&gt;get(i))
 6203                 value = lowCell(use);
 6204             else
 6205                 value = lowJSValue(use);
 6206             m_out.store64(value, m_out.absolute(&amp;buffer[i]));
 6207         }
 6208 
 6209         m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6210         LValue result = vmCall(Int64, m_out.operation(operationNewArrayWithSpreadSlow), m_callFrame, m_out.constIntPtr(buffer), m_out.constInt32(m_node-&gt;numChildren()));
 6211         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6212 
 6213         setJSValue(result);
 6214     }
 6215 
 6216     void compileCreateThis()
 6217     {
 6218         LValue callee = lowCell(m_node-&gt;child1());
 6219 
 6220         LBasicBlock isFunctionBlock = m_out.newBlock();
 6221         LBasicBlock hasRareData = m_out.newBlock();
 6222         LBasicBlock slowPath = m_out.newBlock();
 6223         LBasicBlock continuation = m_out.newBlock();
 6224 
 6225         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowPath));
 6226 
 6227         LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);
 6228         LValue rareData = m_out.loadPtr(callee, m_heaps.JSFunction_rareData);
 6229         m_out.branch(m_out.isZero64(rareData), rarely(slowPath), usually(hasRareData));
 6230 
 6231         m_out.appendTo(hasRareData, slowPath);
 6232         LValue allocator = m_out.loadPtr(rareData, m_heaps.FunctionRareData_allocator);
 6233         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_structure);
 6234         LValue butterfly = m_out.constIntPtr(0);
 6235         ValueFromBlock fastResult = m_out.anchor(allocateObject(allocator, structure, butterfly, slowPath));
 6236         m_out.jump(continuation);
 6237 
 6238         m_out.appendTo(slowPath, continuation);
 6239         ValueFromBlock slowResult = m_out.anchor(vmCall(
 6240             Int64, m_out.operation(operationCreateThis), m_callFrame, callee, m_out.constInt32(m_node-&gt;inlineCapacity())));
 6241         m_out.jump(continuation);
 6242 
 6243         m_out.appendTo(continuation, lastNext);
 6244         LValue result = m_out.phi(Int64, fastResult, slowResult);
 6245 
 6246         mutatorFence();
 6247         setJSValue(result);
 6248     }
 6249 
 6250     void compileSpread()
 6251     {
 6252         if (m_node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 6253             LBasicBlock slowAllocation = m_out.newBlock();
 6254             LBasicBlock continuation = m_out.newBlock();
 6255 
 6256             auto* immutableButterfly = m_node-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6257 
 6258             LValue fastFixedArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(
 6259                 m_out.constIntPtr(JSFixedArray::allocationSize(immutableButterfly-&gt;length()).unsafeGet()),
 6260                 m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6261             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastFixedArrayValue, m_heaps.JSFixedArray_size);
 6262             ValueFromBlock fastFixedArray = m_out.anchor(fastFixedArrayValue);
 6263             m_out.jump(continuation);
 6264 
 6265             LBasicBlock lastNext = m_out.appendTo(slowAllocation, continuation);
 6266             ValueFromBlock slowFixedArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, m_out.constInt32(immutableButterfly-&gt;length())));
 6267             m_out.jump(continuation);
 6268 
 6269             m_out.appendTo(continuation, lastNext);
 6270             LValue fixedArray = m_out.phi(pointerType(), fastFixedArray, slowFixedArray);
 6271             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); i++) {
 6272                 // Because forwarded values are drained as JSValue, we should not generate value
 6273                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6274                 int64_t value = JSValue::encode(immutableButterfly-&gt;get(i));
 6275                 m_out.store64(
 6276                     m_out.constInt64(value),
 6277                     m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, m_out.constIntPtr(i), jsNumber(i)));
 6278             }
 6279             mutatorFence();
 6280             setJSValue(fixedArray);
 6281             return;
 6282         }
 6283 
 6284         if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6285             // This IR is rare to generate since it requires escaping the Spread
 6286             // but not the CreateRest. In bytecode, we have only few operations that
 6287             // accept Spread&#39;s result as input. This usually leads to the Spread node not
 6288             // escaping. However, this can happen if for example we generate a PutStack on
 6289             // the Spread but nothing escapes the CreateRest.
 6290             LBasicBlock loopHeader = m_out.newBlock();
 6291             LBasicBlock loopBody = m_out.newBlock();
 6292             LBasicBlock slowAllocation = m_out.newBlock();
 6293             LBasicBlock continuation = m_out.newBlock();
 6294             LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopHeader);
 6295 
 6296             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6297             unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6298             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6299             LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6300             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6301             LValue size = m_out.add(
 6302                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6303                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6304 
 6305             LValue fastArrayValue = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowAllocation);
 6306             m_out.store32(length, fastArrayValue, m_heaps.JSFixedArray_size);
 6307             ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
 6308             m_out.jump(loopHeader);
 6309 
 6310             m_out.appendTo(slowAllocation, loopHeader);
 6311             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), m_out.operation(operationCreateFixedArray), m_callFrame, length));
 6312             m_out.jump(loopHeader);
 6313 
 6314             m_out.appendTo(loopHeader, loopBody);
 6315             LValue fixedArray = m_out.phi(pointerType(), fastArray, slowArray);
 6316             ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
 6317             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopBody));
 6318 
 6319             m_out.appendTo(loopBody, continuation);
 6320             LValue index = m_out.phi(pointerType(), startIndex);
 6321             LValue value = m_out.load64(
 6322                 m_out.baseIndex(m_heaps.variables, sourceStart, index));
 6323             m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fixedArray, index));
 6324             LValue nextIndex = m_out.add(m_out.constIntPtr(1), index);
 6325             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6326             m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)), unsure(loopBody), unsure(continuation));
 6327 
 6328             m_out.appendTo(continuation, lastNext);
 6329             mutatorFence();
 6330             setJSValue(fixedArray);
 6331             return;
 6332         }
 6333 
 6334         LValue argument = lowCell(m_node-&gt;child1());
 6335 
 6336         LValue result;
 6337 
 6338         if (m_node-&gt;child1().useKind() == ArrayUse)
 6339             speculateArray(m_node-&gt;child1());
 6340 
 6341         if (m_graph.canDoFastSpread(m_node, m_state.forNode(m_node-&gt;child1()))) {
 6342             LBasicBlock preLoop = m_out.newBlock();
 6343             LBasicBlock loopSelection = m_out.newBlock();
 6344             LBasicBlock contiguousLoopStart = m_out.newBlock();
 6345             LBasicBlock doubleLoopStart = m_out.newBlock();
 6346             LBasicBlock slowPath = m_out.newBlock();
 6347             LBasicBlock continuation = m_out.newBlock();
 6348 
 6349             LValue indexingShape = m_out.load8ZeroExt32(argument, m_heaps.JSCell_indexingTypeAndMisc);
 6350             indexingShape = m_out.bitAnd(indexingShape, m_out.constInt32(IndexingShapeMask));
 6351             LValue isOKIndexingType = m_out.belowOrEqual(
 6352                 m_out.sub(indexingShape, m_out.constInt32(Int32Shape)),
 6353                 m_out.constInt32(ContiguousShape - Int32Shape));
 6354 
 6355             m_out.branch(isOKIndexingType, unsure(preLoop), unsure(slowPath));
 6356             LBasicBlock lastNext = m_out.appendTo(preLoop, loopSelection);
 6357 
 6358             LValue butterfly = m_out.loadPtr(argument, m_heaps.JSObject_butterfly);
 6359             LValue length = m_out.load32NonNegative(butterfly, m_heaps.Butterfly_publicLength);
 6360             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6361             LValue size = m_out.add(
 6362                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
 6363                 m_out.constIntPtr(JSFixedArray::offsetOfData()));
 6364 
 6365             LValue fastAllocation = allocateVariableSizedCell&lt;JSFixedArray&gt;(size, m_graph.m_vm.fixedArrayStructure.get(), slowPath);
 6366             ValueFromBlock fastResult = m_out.anchor(fastAllocation);
 6367             m_out.store32(length, fastAllocation, m_heaps.JSFixedArray_size);
 6368 
 6369             ValueFromBlock startIndexForContiguous = m_out.anchor(m_out.constIntPtr(0));
 6370             ValueFromBlock startIndexForDouble = m_out.anchor(m_out.constIntPtr(0));
 6371 
 6372             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopSelection));
 6373 
 6374             m_out.appendTo(loopSelection, contiguousLoopStart);
 6375             m_out.branch(m_out.equal(indexingShape, m_out.constInt32(DoubleShape)),
 6376                 unsure(doubleLoopStart), unsure(contiguousLoopStart));
 6377 
 6378             {
 6379                 m_out.appendTo(contiguousLoopStart, doubleLoopStart);
 6380                 LValue index = m_out.phi(pointerType(), startIndexForContiguous);
 6381 
 6382                 TypedPointer loadSite = m_out.baseIndex(m_heaps.root, butterfly, index, ScaleEight); // We read TOP here since we can be reading either int32 or contiguous properties.
 6383                 LValue value = m_out.load64(loadSite);
 6384                 value = m_out.select(m_out.isZero64(value), m_out.constInt64(JSValue::encode(jsUndefined())), value);
 6385                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));
 6386 
 6387                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6388                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6389 
 6390                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6391                     unsure(contiguousLoopStart), unsure(continuation));
 6392             }
 6393 
 6394             {
 6395                 m_out.appendTo(doubleLoopStart, slowPath);
 6396                 LValue index = m_out.phi(pointerType(), startIndexForDouble);
 6397 
 6398                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, butterfly, index));
 6399                 LValue isNaN = m_out.doubleNotEqualOrUnordered(value, value);
 6400                 LValue holeResult = m_out.constInt64(JSValue::encode(jsUndefined()));
 6401                 LValue normalResult = boxDouble(value);
 6402                 value = m_out.select(isNaN, holeResult, normalResult);
 6403                 m_out.store64(value, m_out.baseIndex(m_heaps.JSFixedArray_buffer, fastAllocation, index));
 6404 
 6405                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6406                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6407 
 6408                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6409                     unsure(doubleLoopStart), unsure(continuation));
 6410             }
 6411 
 6412             m_out.appendTo(slowPath, continuation);
 6413             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationSpreadFastArray), m_callFrame, argument));
 6414             m_out.jump(continuation);
 6415 
 6416             m_out.appendTo(continuation, lastNext);
 6417             result = m_out.phi(pointerType(), fastResult, slowResult);
 6418             mutatorFence();
 6419         } else
 6420             result = vmCall(pointerType(), m_out.operation(operationSpreadGeneric), m_callFrame, argument);
 6421 
 6422         setJSValue(result);
 6423     }
 6424 
 6425     void compileNewArrayBuffer()
 6426     {
 6427         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6428         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6429             m_node-&gt;indexingMode()));
 6430         auto* immutableButterfly = m_node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6431 
 6432         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingMode())) {
 6433             LBasicBlock slowPath = m_out.newBlock();
 6434             LBasicBlock continuation = m_out.newBlock();
 6435 
 6436             LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);
 6437             ValueFromBlock fastResult = m_out.anchor(fastArray);
 6438             m_out.jump(continuation);
 6439 
 6440             m_out.appendTo(slowPath, continuation);
 6441             LValue slowArray = vmCall(Int64, m_out.operation(operationNewArrayBuffer), m_callFrame, weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand()));
 6442             ValueFromBlock slowResult = m_out.anchor(slowArray);
 6443             m_out.jump(continuation);
 6444 
 6445             m_out.appendTo(continuation);
 6446 
 6447             mutatorFence();
 6448             setJSValue(m_out.phi(pointerType(), slowResult, fastResult));
 6449             return;
 6450         }
 6451 
 6452         setJSValue(vmCall(
 6453             Int64, m_out.operation(operationNewArrayBuffer), m_callFrame,
 6454             weakStructure(structure), m_out.weakPointer(m_node-&gt;cellOperand())));
 6455     }
 6456 
 6457     void compileNewArrayWithSize()
 6458     {
 6459         LValue publicLength = lowInt32(m_node-&gt;child1());
 6460 
 6461         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6462         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6463             m_node-&gt;indexingType()));
 6464 
 6465         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 6466             IndexingType indexingType = m_node-&gt;indexingType();
 6467             setJSValue(
 6468                 allocateJSArray(
 6469                     publicLength, publicLength, weakPointer(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType)), m_out.constInt32(indexingType)).array);
 6470             mutatorFence();
 6471             return;
 6472         }
 6473 
 6474         LValue structureValue = m_out.select(
 6475             m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)),
 6476             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))),
 6477             weakStructure(structure));
 6478         setJSValue(vmCall(Int64, m_out.operation(operationNewArrayWithSize), m_callFrame, structureValue, publicLength, m_out.intPtrZero));
 6479     }
 6480 
 6481     void compileNewTypedArray()
 6482     {
 6483         TypedArrayType typedArrayType = m_node-&gt;typedArrayType();
 6484         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6485 
 6486         switch (m_node-&gt;child1().useKind()) {
 6487         case Int32Use: {
 6488             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 6489 
 6490             LValue size = lowInt32(m_node-&gt;child1());
 6491 
 6492             LBasicBlock smallEnoughCase = m_out.newBlock();
 6493             LBasicBlock slowCase = m_out.newBlock();
 6494             LBasicBlock continuation = m_out.newBlock();
 6495 
 6496             ValueFromBlock noStorage = m_out.anchor(m_out.intPtrZero);
 6497 
 6498             m_out.branch(
 6499                 m_out.above(size, m_out.constInt32(JSArrayBufferView::fastSizeLimit)),
 6500                 rarely(slowCase), usually(smallEnoughCase));
 6501 
 6502             LBasicBlock lastNext = m_out.appendTo(smallEnoughCase, slowCase);
 6503 
 6504             LValue byteSize =
 6505                 m_out.shl(m_out.zeroExtPtr(size), m_out.constInt32(logElementSize(typedArrayType)));
 6506             if (elementSize(typedArrayType) &lt; 8) {
 6507                 byteSize = m_out.bitAnd(
 6508                     m_out.add(byteSize, m_out.constIntPtr(7)),
 6509                     m_out.constIntPtr(~static_cast&lt;intptr_t&gt;(7)));
 6510             }
 6511 
 6512             LValue allocator = allocatorForSize(vm().primitiveGigacageAuxiliarySpace, byteSize, slowCase);
 6513             LValue storage = allocateHeapCell(allocator, slowCase);
 6514 
 6515             splatWords(
 6516                 storage,
 6517                 m_out.int32Zero,
 6518                 m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
 6519                 m_out.int64Zero,
 6520                 m_heaps.typedArrayProperties);
 6521 
 6522 #if CPU(ARM64E)
 6523             {
 6524                 LValue sizePtr = m_out.zeroExtPtr(size);
 6525                 PatchpointValue* authenticate = m_out.patchpoint(pointerType());
 6526                 authenticate-&gt;appendSomeRegister(storage);
 6527                 authenticate-&gt;append(sizePtr, B3::ValueRep(B3::ValueRep::SomeLateRegister));
 6528                 authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 6529                     jit.move(params[1].gpr(), params[0].gpr());
 6530                     jit.tagArrayPtr(params[2].gpr(), params[0].gpr());
 6531                 });
 6532                 storage = authenticate;
 6533             }
 6534 #endif
 6535 
 6536             ValueFromBlock haveStorage = m_out.anchor(storage);
 6537 
 6538             LValue fastResultValue =
 6539                 allocateObject&lt;JSArrayBufferView&gt;(structure, m_out.intPtrZero, slowCase);
 6540 
 6541             m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
 6542             m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
 6543             m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
 6544 
 6545             mutatorFence();
 6546             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6547             m_out.jump(continuation);
 6548 
 6549             m_out.appendTo(slowCase, continuation);
 6550             LValue storageValue = m_out.phi(pointerType(), noStorage, haveStorage);
 6551 
 6552             VM&amp; vm = this-&gt;vm();
 6553             LValue slowResultValue = lazySlowPath(
 6554                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6555                     return createLazyCallGenerator(vm,
 6556                         operationNewTypedArrayWithSizeForType(typedArrayType), locations[0].directGPR(),
 6557                         CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 6558                         locations[2].directGPR());
 6559                 },
 6560                 size, storageValue);
 6561             ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6562             m_out.jump(continuation);
 6563 
 6564             m_out.appendTo(continuation, lastNext);
 6565             setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 6566             return;
 6567         }
 6568 
 6569         case UntypedUse: {
 6570             LValue argument = lowJSValue(m_node-&gt;child1());
 6571 
 6572             LValue result = vmCall(
 6573                 pointerType(), m_out.operation(operationNewTypedArrayWithOneArgumentForType(typedArrayType)),
 6574                 m_callFrame, weakPointer(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType)), argument);
 6575 
 6576             setJSValue(result);
 6577             return;
 6578         }
 6579 
 6580         default:
 6581             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 6582             return;
 6583         }
 6584     }
 6585 
 6586     void compileAllocatePropertyStorage()
 6587     {
 6588         LValue object = lowCell(m_node-&gt;child1());
 6589         setStorage(allocatePropertyStorage(object, m_node-&gt;transition()-&gt;previous.get()));
 6590     }
 6591 
 6592     void compileReallocatePropertyStorage()
 6593     {
 6594         Transition* transition = m_node-&gt;transition();
 6595         LValue object = lowCell(m_node-&gt;child1());
 6596         LValue oldStorage = lowStorage(m_node-&gt;child2());
 6597 
 6598         setStorage(
 6599             reallocatePropertyStorage(
 6600                 object, oldStorage, transition-&gt;previous.get(), transition-&gt;next.get()));
 6601     }
 6602 
 6603     void compileNukeStructureAndSetButterfly()
 6604     {
 6605         nukeStructureAndSetButterfly(lowStorage(m_node-&gt;child2()), lowCell(m_node-&gt;child1()));
 6606     }
 6607 
 6608     void compileToNumber()
 6609     {
 6610         LValue value = lowJSValue(m_node-&gt;child1());
 6611 
 6612         if (!(abstractValue(m_node-&gt;child1()).m_type &amp; SpecBytecodeNumber))
 6613             setJSValue(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));
 6614         else {
 6615             LBasicBlock notNumber = m_out.newBlock();
 6616             LBasicBlock continuation = m_out.newBlock();
 6617 
 6618             ValueFromBlock fastResult = m_out.anchor(value);
 6619             m_out.branch(isNumber(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notNumber));
 6620 
 6621             // notNumber case.
 6622             LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);
 6623             // We have several attempts to remove ToNumber. But ToNumber still exists.
 6624             // It means that converting non-numbers to numbers by this ToNumber is not rare.
 6625             // Instead of the lazy slow path generator, we call the operation here.
 6626             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_out.operation(operationToNumber), m_callFrame, value));
 6627             m_out.jump(continuation);
 6628 
 6629             // continuation case.
 6630             m_out.appendTo(continuation, lastNext);
 6631             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 6632         }
 6633     }
 6634 
 6635     void compileToStringOrCallStringConstructorOrStringValueOf()
 6636     {
 6637         ASSERT(m_node-&gt;op() != StringValueOf || m_node-&gt;child1().useKind() == UntypedUse);
 6638         switch (m_node-&gt;child1().useKind()) {
 6639         case StringObjectUse: {
 6640             LValue cell = lowCell(m_node-&gt;child1());
 6641             speculateStringObjectForCell(m_node-&gt;child1(), cell);
 6642             setJSValue(m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 6643             return;
 6644         }
 6645 
 6646         case StringOrStringObjectUse: {
 6647             LValue cell = lowCell(m_node-&gt;child1());
 6648             LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
 6649 
 6650             LBasicBlock notString = m_out.newBlock();
 6651             LBasicBlock continuation = m_out.newBlock();
 6652 
 6653             ValueFromBlock simpleResult = m_out.anchor(cell);
 6654             m_out.branch(
 6655                 m_out.equal(type, m_out.constInt32(StringType)),
 6656                 unsure(continuation), unsure(notString));
 6657 
 6658             LBasicBlock lastNext = m_out.appendTo(notString, continuation);
 6659             speculate(
 6660                 BadType, jsValueValue(cell), m_node-&gt;child1().node(),
 6661                 m_out.notEqual(type, m_out.constInt32(StringObjectType)));
 6662             ValueFromBlock unboxedResult = m_out.anchor(
 6663                 m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 6664             m_out.jump(continuation);
 6665 
 6666             m_out.appendTo(continuation, lastNext);
 6667             setJSValue(m_out.phi(Int64, simpleResult, unboxedResult));
 6668 
 6669             m_interpreter.filter(m_node-&gt;child1(), SpecString | SpecStringObject);
 6670             return;
 6671         }
 6672 
 6673         case CellUse:
 6674         case NotCellUse:
 6675         case UntypedUse: {
 6676             LValue value;
 6677             if (m_node-&gt;child1().useKind() == CellUse)
 6678                 value = lowCell(m_node-&gt;child1());
 6679             else if (m_node-&gt;child1().useKind() == NotCellUse)
 6680                 value = lowNotCell(m_node-&gt;child1());
 6681             else
 6682                 value = lowJSValue(m_node-&gt;child1());
 6683 
 6684             LBasicBlock isCell = m_out.newBlock();
 6685             LBasicBlock notString = m_out.newBlock();
 6686             LBasicBlock continuation = m_out.newBlock();
 6687 
 6688             LValue isCellPredicate;
 6689             if (m_node-&gt;child1().useKind() == CellUse)
 6690                 isCellPredicate = m_out.booleanTrue;
 6691             else if (m_node-&gt;child1().useKind() == NotCellUse)
 6692                 isCellPredicate = m_out.booleanFalse;
 6693             else
 6694                 isCellPredicate = this-&gt;isCell(value, provenType(m_node-&gt;child1()));
 6695             m_out.branch(isCellPredicate, unsure(isCell), unsure(notString));
 6696 
 6697             LBasicBlock lastNext = m_out.appendTo(isCell, notString);
 6698             ValueFromBlock simpleResult = m_out.anchor(value);
 6699             LValue isStringPredicate;
 6700             if (m_node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 6701                 isStringPredicate = isString(value, provenType(m_node-&gt;child1()));
 6702             } else
 6703                 isStringPredicate = m_out.booleanFalse;
 6704             m_out.branch(isStringPredicate, unsure(continuation), unsure(notString));
 6705 
 6706             m_out.appendTo(notString, continuation);
 6707             LValue operation;
 6708             if (m_node-&gt;child1().useKind() == CellUse) {
 6709                 ASSERT(m_node-&gt;op() != StringValueOf);
 6710                 operation = m_out.operation(m_node-&gt;op() == ToString ? operationToStringOnCell : operationCallStringConstructorOnCell);
 6711             } else {
 6712                 operation = m_out.operation(m_node-&gt;op() == ToString
 6713                     ? operationToString : m_node-&gt;op() == StringValueOf
 6714                     ? operationStringValueOf : operationCallStringConstructor);
 6715             }
 6716             ValueFromBlock convertedResult = m_out.anchor(vmCall(Int64, operation, m_callFrame, value));
 6717             m_out.jump(continuation);
 6718 
 6719             m_out.appendTo(continuation, lastNext);
 6720             setJSValue(m_out.phi(Int64, simpleResult, convertedResult));
 6721             return;
 6722         }
 6723 
 6724         case Int32Use:
 6725             setJSValue(vmCall(Int64, m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(10)));
 6726             return;
 6727 
 6728         case Int52RepUse:
 6729             setJSValue(vmCall(Int64, m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(10)));
 6730             return;
 6731 
 6732         case DoubleRepUse:
 6733             setJSValue(vmCall(Int64, m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(10)));
 6734             return;
 6735 
 6736         default:
 6737             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 6738             break;
 6739         }
 6740     }
 6741 
 6742     void compileToPrimitive()
 6743     {
 6744         LValue value = lowJSValue(m_node-&gt;child1());
 6745 
 6746         LBasicBlock isCellCase = m_out.newBlock();
 6747         LBasicBlock isObjectCase = m_out.newBlock();
 6748         LBasicBlock continuation = m_out.newBlock();
 6749 
 6750         Vector&lt;ValueFromBlock, 3&gt; results;
 6751 
 6752         results.append(m_out.anchor(value));
 6753         m_out.branch(
 6754             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 6755 
 6756         LBasicBlock lastNext = m_out.appendTo(isCellCase, isObjectCase);
 6757         results.append(m_out.anchor(value));
 6758         m_out.branch(
 6759             isObject(value, provenType(m_node-&gt;child1())),
 6760             unsure(isObjectCase), unsure(continuation));
 6761 
 6762         m_out.appendTo(isObjectCase, continuation);
 6763         results.append(m_out.anchor(vmCall(
 6764             Int64, m_out.operation(operationToPrimitive), m_callFrame, value)));
 6765         m_out.jump(continuation);
 6766 
 6767         m_out.appendTo(continuation, lastNext);
 6768         setJSValue(m_out.phi(Int64, results));
 6769     }
 6770 
 6771     void compileMakeRope()
 6772     {
 6773         struct FlagsAndLength {
 6774             LValue flags;
 6775             LValue length;
 6776         };
 6777 
 6778         Edge edges[3] = {
 6779             m_node-&gt;child1(),
 6780             m_node-&gt;child2(),
 6781             m_node-&gt;child3(),
 6782         };
 6783         LValue kids[3];
 6784         unsigned numKids;
 6785         kids[0] = lowCell(edges[0]);
 6786         kids[1] = lowCell(edges[1]);
 6787         if (edges[2]) {
 6788             kids[2] = lowCell(edges[2]);
 6789             numKids = 3;
 6790         } else {
 6791             kids[2] = 0;
 6792             numKids = 2;
 6793         }
 6794 
 6795         LBasicBlock emptyCase = m_out.newBlock();
 6796         LBasicBlock slowPath = m_out.newBlock();
 6797         LBasicBlock continuation = m_out.newBlock();
 6798 
 6799         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
 6800 
 6801         LValue result = allocateCell(
 6802             m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
 6803 
 6804         // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.
 6805         m_out.storePtr(m_out.constIntPtr(JSString::isRopeInPointer), result, m_heaps.JSRopeString_fiber0);
 6806 
 6807         auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
 6808             if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
 6809                 return FlagsAndLength {
 6810                     m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
 6811                     m_out.constInt32(string-&gt;length())
 6812                 };
 6813             }
 6814 
 6815             LBasicBlock continuation = m_out.newBlock();
 6816             LBasicBlock ropeCase = m_out.newBlock();
 6817             LBasicBlock notRopeCase = m_out.newBlock();
 6818 
 6819             m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
 6820 
 6821             LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
 6822             ValueFromBlock flagsForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_flags));
 6823             ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
 6824             m_out.jump(continuation);
 6825 
 6826             m_out.appendTo(notRopeCase, continuation);
 6827             LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
 6828             ValueFromBlock flagsForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_hashAndFlags));
 6829             ValueFromBlock lengthForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length));
 6830             m_out.jump(continuation);
 6831 
 6832             m_out.appendTo(continuation, lastNext);
 6833             return FlagsAndLength {
 6834                 m_out.phi(Int32, flagsForRope, flagsForNonRope),
 6835                 m_out.phi(Int32, lengthForRope, lengthForNonRope)
 6836             };
 6837         };
 6838 
 6839         FlagsAndLength flagsAndLength = getFlagsAndLength(edges[0], kids[0]);
 6840         for (unsigned i = 1; i &lt; numKids; ++i) {
 6841             auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
 6842                 FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
 6843                 LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
 6844                 CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
 6845                 blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);
 6846                 return FlagsAndLength {
 6847                     flags,
 6848                     lengthCheck
 6849                 };
 6850             };
 6851             flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
 6852         }
 6853 
 6854         m_out.storePtr(
 6855             m_out.bitOr(
 6856                 m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)),
 6857                 m_out.bitAnd(m_out.constIntPtr(JSRopeString::is8BitInPointer), m_out.zeroExtPtr(flagsAndLength.flags))),
 6858             result, m_heaps.JSRopeString_fiber0);
 6859         m_out.storePtr(
 6860             m_out.bitOr(m_out.zeroExtPtr(flagsAndLength.length), m_out.shl(kids[1], m_out.constInt32(32))),
 6861             result, m_heaps.JSRopeString_fiber1);
 6862         if (numKids == 2)
 6863             m_out.storePtr(m_out.lShr(kids[1], m_out.constInt32(32)), result, m_heaps.JSRopeString_fiber2);
 6864         else
 6865             m_out.storePtr(m_out.bitOr(m_out.lShr(kids[1], m_out.constInt32(32)), m_out.shl(kids[2], m_out.constInt32(16))), result, m_heaps.JSRopeString_fiber2);
 6866 
 6867         mutatorFence();
 6868         ValueFromBlock fastResult = m_out.anchor(result);
 6869         m_out.branch(m_out.isZero32(flagsAndLength.length), rarely(emptyCase), usually(continuation));
 6870 
 6871         LBasicBlock lastNext = m_out.appendTo(emptyCase, slowPath);
 6872         ValueFromBlock emptyResult = m_out.anchor(weakPointer(jsEmptyString(m_graph.m_vm)));
 6873         m_out.jump(continuation);
 6874 
 6875         m_out.appendTo(slowPath, continuation);
 6876         LValue slowResultValue;
 6877         VM&amp; vm = this-&gt;vm();
 6878         switch (numKids) {
 6879         case 2:
 6880             slowResultValue = lazySlowPath(
 6881                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6882                     return createLazyCallGenerator(vm,
 6883                         operationMakeRope2, locations[0].directGPR(), locations[1].directGPR(),
 6884                         locations[2].directGPR());
 6885                 }, kids[0], kids[1]);
 6886             break;
 6887         case 3:
 6888             slowResultValue = lazySlowPath(
 6889                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6890                     return createLazyCallGenerator(vm,
 6891                         operationMakeRope3, locations[0].directGPR(), locations[1].directGPR(),
 6892                         locations[2].directGPR(), locations[3].directGPR());
 6893                 }, kids[0], kids[1], kids[2]);
 6894             break;
 6895         default:
 6896             DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
 6897             break;
 6898         }
 6899         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6900         m_out.jump(continuation);
 6901 
 6902         m_out.appendTo(continuation, lastNext);
 6903         setJSValue(m_out.phi(Int64, fastResult, emptyResult, slowResult));
 6904     }
 6905 
 6906     void compileStringCharAt()
 6907     {
 6908         LValue base = lowString(m_graph.child(m_node, 0));
 6909         LValue index = lowInt32(m_graph.child(m_node, 1));
 6910         LValue storage = lowStorage(m_graph.child(m_node, 2));
 6911 
 6912         LBasicBlock fastPath = m_out.newBlock();
 6913         LBasicBlock slowPath = m_out.newBlock();
 6914         LBasicBlock continuation = m_out.newBlock();
 6915 
 6916         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 6917         m_out.branch(
 6918             m_out.aboveOrEqual(
 6919                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)),
 6920             rarely(slowPath), usually(fastPath));
 6921 
 6922         LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 6923 
 6924         LBasicBlock is8Bit = m_out.newBlock();
 6925         LBasicBlock is16Bit = m_out.newBlock();
 6926         LBasicBlock bitsContinuation = m_out.newBlock();
 6927         LBasicBlock bigCharacter = m_out.newBlock();
 6928 
 6929         m_out.branch(
 6930             m_out.testIsZero32(
 6931                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 6932                 m_out.constInt32(StringImpl::flagIs8Bit())),
 6933             unsure(is16Bit), unsure(is8Bit));
 6934 
 6935         m_out.appendTo(is8Bit, is16Bit);
 6936 
 6937         // FIXME: Need to cage strings!
 6938         // https://bugs.webkit.org/show_bug.cgi?id=174924
 6939         ValueFromBlock char8Bit = m_out.anchor(
 6940             m_out.load8ZeroExt32(m_out.baseIndex(
 6941                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 6942                 provenValue(m_graph.child(m_node, 1)))));
 6943         m_out.jump(bitsContinuation);
 6944 
 6945         m_out.appendTo(is16Bit, bigCharacter);
 6946 
 6947         LValue char16BitValue = m_out.load16ZeroExt32(
 6948             m_out.baseIndex(
 6949                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 6950                 provenValue(m_graph.child(m_node, 1))));
 6951         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
 6952         m_out.branch(
 6953             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
 6954             rarely(bigCharacter), usually(bitsContinuation));
 6955 
 6956         m_out.appendTo(bigCharacter, bitsContinuation);
 6957 
 6958         Vector&lt;ValueFromBlock, 4&gt; results;
 6959         results.append(m_out.anchor(vmCall(
 6960             Int64, m_out.operation(operationSingleCharacterString),
 6961             m_callFrame, char16BitValue)));
 6962         m_out.jump(continuation);
 6963 
 6964         m_out.appendTo(bitsContinuation, slowPath);
 6965 
 6966         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
 6967 
 6968         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 6969 
 6970         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
 6971             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
 6972         m_out.jump(continuation);
 6973 
 6974         m_out.appendTo(slowPath, continuation);
 6975 
 6976         if (m_node-&gt;arrayMode().isInBounds()) {
 6977             speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
 6978             results.append(m_out.anchor(m_out.intPtrZero));
 6979         } else {
 6980             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6981             Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm());
 6982             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
 6983             WTF::loadLoadFence();
 6984 
 6985             if (globalObject-&gt;stringPrototypeChainIsSane()) {
 6986                 // FIXME: This could be captured using a Speculation mode that means
 6987                 // &quot;out-of-bounds loads return a trivial value&quot;, something like
 6988                 // SaneChainOutOfBounds.
 6989                 // https://bugs.webkit.org/show_bug.cgi?id=144668
 6990 
 6991                 m_graph.registerAndWatchStructureTransition(stringPrototypeStructure);
 6992                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 6993 
 6994                 LBasicBlock negativeIndex = m_out.newBlock();
 6995 
 6996                 results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 6997                 m_out.branch(
 6998                     m_out.lessThan(index, m_out.int32Zero),
 6999                     rarely(negativeIndex), usually(continuation));
 7000 
 7001                 m_out.appendTo(negativeIndex, continuation);
 7002             }
 7003 
 7004             results.append(m_out.anchor(vmCall(
 7005                 Int64, m_out.operation(operationGetByValStringInt), m_callFrame, base, index)));
 7006         }
 7007 
 7008         m_out.jump(continuation);
 7009 
 7010         m_out.appendTo(continuation, lastNext);
 7011         setJSValue(m_out.phi(Int64, results));
 7012     }
 7013 
 7014     void compileStringCharCodeAt()
 7015     {
 7016         LBasicBlock is8Bit = m_out.newBlock();
 7017         LBasicBlock is16Bit = m_out.newBlock();
 7018         LBasicBlock continuation = m_out.newBlock();
 7019 
 7020         LValue base = lowString(m_node-&gt;child1());
 7021         LValue index = lowInt32(m_node-&gt;child2());
 7022         LValue storage = lowStorage(m_node-&gt;child3());
 7023 
 7024         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 7025 
 7026         speculate(
 7027             Uncountable, noValue(), 0,
 7028             m_out.aboveOrEqual(
 7029                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)));
 7030 
 7031         m_out.branch(
 7032             m_out.testIsZero32(
 7033                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 7034                 m_out.constInt32(StringImpl::flagIs8Bit())),
 7035             unsure(is16Bit), unsure(is8Bit));
 7036 
 7037         LBasicBlock lastNext = m_out.appendTo(is8Bit, is16Bit);
 7038 
 7039         // FIXME: need to cage strings!
 7040         // https://bugs.webkit.org/show_bug.cgi?id=174924
 7041         ValueFromBlock char8Bit = m_out.anchor(
 7042             m_out.load8ZeroExt32(m_out.baseIndex(
 7043                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 7044                 provenValue(m_node-&gt;child2()))));
 7045         m_out.jump(continuation);
 7046 
 7047         m_out.appendTo(is16Bit, continuation);
 7048 
 7049         ValueFromBlock char16Bit = m_out.anchor(
 7050             m_out.load16ZeroExt32(m_out.baseIndex(
 7051                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 7052                 provenValue(m_node-&gt;child2()))));
 7053         m_out.jump(continuation);
 7054 
 7055         m_out.appendTo(continuation, lastNext);
 7056 
 7057         setInt32(m_out.phi(Int32, char8Bit, char16Bit));
 7058     }
 7059 
 7060     void compileStringFromCharCode()
 7061     {
 7062         Edge childEdge = m_node-&gt;child1();
 7063 
 7064         if (childEdge.useKind() == UntypedUse) {
 7065             LValue result = vmCall(
 7066                 Int64, m_out.operation(operationStringFromCharCodeUntyped), m_callFrame,
 7067                 lowJSValue(childEdge));
 7068             setJSValue(result);
 7069             return;
 7070         }
 7071 
 7072         DFG_ASSERT(m_graph, m_node, childEdge.useKind() == Int32Use, childEdge.useKind());
 7073 
 7074         LValue value = lowInt32(childEdge);
 7075 
 7076         LBasicBlock smallIntCase = m_out.newBlock();
 7077         LBasicBlock slowCase = m_out.newBlock();
 7078         LBasicBlock continuation = m_out.newBlock();
 7079 
 7080         m_out.branch(
 7081             m_out.above(value, m_out.constInt32(maxSingleCharacterString)),
 7082             rarely(slowCase), usually(smallIntCase));
 7083 
 7084         LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
 7085 
 7086         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 7087         LValue fastResultValue = m_out.loadPtr(
 7088             m_out.baseIndex(m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(value)));
 7089         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 7090         m_out.jump(continuation);
 7091 
 7092         m_out.appendTo(slowCase, continuation);
 7093 
 7094         LValue slowResultValue = vmCall(
 7095             pointerType(), m_out.operation(operationStringFromCharCode), m_callFrame, value);
 7096         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 7097         m_out.jump(continuation);
 7098 
 7099         m_out.appendTo(continuation, lastNext);
 7100 
 7101         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 7102     }
 7103 
 7104     void compileGetByOffset()
 7105     {
 7106         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 7107 
 7108         setJSValue(loadProperty(
 7109             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset));
 7110     }
 7111 
 7112     void compileGetGetter()
 7113     {
 7114         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_getter));
 7115     }
 7116 
 7117     void compileGetSetter()
 7118     {
 7119         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_setter));
 7120     }
 7121 
 7122     void compileMultiGetByOffset()
 7123     {
 7124         LValue base = lowCell(m_node-&gt;child1());
 7125 
 7126         MultiGetByOffsetData&amp; data = m_node-&gt;multiGetByOffsetData();
 7127 
 7128         Vector&lt;LBasicBlock, 2&gt; blocks(data.cases.size());
 7129         for (unsigned i = data.cases.size(); i--;)
 7130             blocks[i] = m_out.newBlock();
 7131         LBasicBlock exit = m_out.newBlock();
 7132         LBasicBlock continuation = m_out.newBlock();
 7133 
 7134         Vector&lt;SwitchCase, 2&gt; cases;
 7135         RegisteredStructureSet baseSet;
 7136         for (unsigned i = data.cases.size(); i--;) {
 7137             MultiGetByOffsetCase getCase = data.cases[i];
 7138             for (unsigned j = getCase.set().size(); j--;) {
 7139                 RegisteredStructure structure = getCase.set()[j];
 7140                 baseSet.add(structure);
 7141                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 7142             }
 7143         }
 7144         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7145         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 7146 
 7147         LBasicBlock lastNext = m_out.m_nextBlock;
 7148 
 7149         Vector&lt;ValueFromBlock, 2&gt; results;
 7150         for (unsigned i = data.cases.size(); i--;) {
 7151             MultiGetByOffsetCase getCase = data.cases[i];
 7152             GetByOffsetMethod method = getCase.method();
 7153 
 7154             m_out.appendTo(blocks[i], i + 1 &lt; data.cases.size() ? blocks[i + 1] : exit);
 7155 
 7156             LValue result;
 7157 
 7158             switch (method.kind()) {
 7159             case GetByOffsetMethod::Invalid:
 7160                 RELEASE_ASSERT_NOT_REACHED();
 7161                 break;
 7162 
 7163             case GetByOffsetMethod::Constant:
 7164                 result = m_out.constInt64(JSValue::encode(method.constant()-&gt;value()));
 7165                 break;
 7166 
 7167             case GetByOffsetMethod::Load:
 7168             case GetByOffsetMethod::LoadFromPrototype: {
 7169                 LValue propertyBase;
 7170                 if (method.kind() == GetByOffsetMethod::Load)
 7171                     propertyBase = base;
 7172                 else
 7173                     propertyBase = weakPointer(method.prototype()-&gt;value().asCell());
 7174                 if (!isInlineOffset(method.offset()))
 7175                     propertyBase = m_out.loadPtr(propertyBase, m_heaps.JSObject_butterfly);
 7176                 result = loadProperty(
 7177                     propertyBase, data.identifierNumber, method.offset());
 7178                 break;
 7179             } }
 7180 
 7181             results.append(m_out.anchor(result));
 7182             m_out.jump(continuation);
 7183         }
 7184 
 7185         m_out.appendTo(exit, continuation);
 7186         if (!structuresChecked)
 7187             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7188         m_out.unreachable();
 7189 
 7190         m_out.appendTo(continuation, lastNext);
 7191         setJSValue(m_out.phi(Int64, results));
 7192     }
 7193 
 7194     void compilePutByOffset()
 7195     {
 7196         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 7197 
 7198         storeProperty(
 7199             lowJSValue(m_node-&gt;child3()),
 7200             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset);
 7201     }
 7202 
 7203     void compileMultiPutByOffset()
 7204     {
 7205         LValue base = lowCell(m_node-&gt;child1());
 7206         LValue value = lowJSValue(m_node-&gt;child2());
 7207 
 7208         MultiPutByOffsetData&amp; data = m_node-&gt;multiPutByOffsetData();
 7209 
 7210         Vector&lt;LBasicBlock, 2&gt; blocks(data.variants.size());
 7211         for (unsigned i = data.variants.size(); i--;)
 7212             blocks[i] = m_out.newBlock();
 7213         LBasicBlock exit = m_out.newBlock();
 7214         LBasicBlock continuation = m_out.newBlock();
 7215 
 7216         Vector&lt;SwitchCase, 2&gt; cases;
 7217         RegisteredStructureSet baseSet;
 7218         for (unsigned i = data.variants.size(); i--;) {
 7219             PutByIdVariant variant = data.variants[i];
 7220             for (unsigned j = variant.oldStructure().size(); j--;) {
 7221                 RegisteredStructure structure = m_graph.registerStructure(variant.oldStructure()[j]);
 7222                 baseSet.add(structure);
 7223                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 7224             }
 7225         }
 7226         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7227         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 7228 
 7229         LBasicBlock lastNext = m_out.m_nextBlock;
 7230 
 7231         for (unsigned i = data.variants.size(); i--;) {
 7232             m_out.appendTo(blocks[i], i + 1 &lt; data.variants.size() ? blocks[i + 1] : exit);
 7233 
 7234             PutByIdVariant variant = data.variants[i];
 7235 
 7236             LValue storage;
 7237             if (variant.kind() == PutByIdVariant::Replace) {
 7238                 if (isInlineOffset(variant.offset()))
 7239                     storage = base;
 7240                 else
 7241                     storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
 7242             } else {
 7243                 DFG_ASSERT(m_graph, m_node, variant.kind() == PutByIdVariant::Transition, variant.kind());
 7244                 m_graph.m_plan.transitions().addLazily(
 7245                     codeBlock(), m_node-&gt;origin.semantic.codeOriginOwner(),
 7246                     variant.oldStructureForTransition(), variant.newStructure());
 7247 
 7248                 storage = storageForTransition(
 7249                     base, variant.offset(),
 7250                     variant.oldStructureForTransition(), variant.newStructure());
 7251             }
 7252 
 7253             storeProperty(value, storage, data.identifierNumber, variant.offset());
 7254 
 7255             if (variant.kind() == PutByIdVariant::Transition) {
 7256                 ASSERT(variant.oldStructureForTransition()-&gt;indexingType() == variant.newStructure()-&gt;indexingType());
 7257                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().inlineTypeFlags() == variant.newStructure()-&gt;typeInfo().inlineTypeFlags());
 7258                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().type() == variant.newStructure()-&gt;typeInfo().type());
 7259                 m_out.store32(
 7260                     weakStructureID(m_graph.registerStructure(variant.newStructure())), base, m_heaps.JSCell_structureID);
 7261             }
 7262 
 7263             m_out.jump(continuation);
 7264         }
 7265 
 7266         m_out.appendTo(exit, continuation);
 7267         if (!structuresChecked)
 7268             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7269         m_out.unreachable();
 7270 
 7271         m_out.appendTo(continuation, lastNext);
 7272     }
 7273 
 7274     void compileMatchStructure()
 7275     {
 7276         LValue base = lowCell(m_node-&gt;child1());
 7277 
 7278         MatchStructureData&amp; data = m_node-&gt;matchStructureData();
 7279 
 7280         LBasicBlock trueBlock = m_out.newBlock();
 7281         LBasicBlock falseBlock = m_out.newBlock();
 7282         LBasicBlock exitBlock = m_out.newBlock();
 7283         LBasicBlock continuation = m_out.newBlock();
 7284 
 7285         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueBlock);
 7286 
 7287         Vector&lt;SwitchCase, 2&gt; cases;
 7288         RegisteredStructureSet baseSet;
 7289         for (MatchStructureVariant&amp; variant : data.variants) {
 7290             baseSet.add(variant.structure);
 7291             cases.append(SwitchCase(
 7292                 weakStructureID(variant.structure),
 7293                 variant.result ? trueBlock : falseBlock, Weight(1)));
 7294         }
 7295         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7296         emitSwitchForMultiByOffset(base, structuresChecked, cases, exitBlock);
 7297 
 7298         m_out.appendTo(trueBlock, falseBlock);
 7299         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
 7300         m_out.jump(continuation);
 7301 
 7302         m_out.appendTo(falseBlock, exitBlock);
 7303         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
 7304         m_out.jump(continuation);
 7305 
 7306         m_out.appendTo(exitBlock, continuation);
 7307         if (!structuresChecked)
 7308             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7309         m_out.unreachable();
 7310 
 7311         m_out.appendTo(continuation, lastNext);
 7312         setBoolean(m_out.phi(Int32, trueResult, falseResult));
 7313     }
 7314 
 7315     void compileGetGlobalVariable()
 7316     {
 7317         setJSValue(m_out.load64(m_out.absolute(m_node-&gt;variablePointer())));
 7318     }
 7319 
 7320     void compilePutGlobalVariable()
 7321     {
 7322         m_out.store64(
 7323             lowJSValue(m_node-&gt;child2()), m_out.absolute(m_node-&gt;variablePointer()));
 7324     }
 7325 
 7326     void compileNotifyWrite()
 7327     {
 7328         WatchpointSet* set = m_node-&gt;watchpointSet();
 7329 
 7330         LBasicBlock isNotInvalidated = m_out.newBlock();
 7331         LBasicBlock continuation = m_out.newBlock();
 7332 
 7333         LValue state = m_out.load8ZeroExt32(m_out.absolute(set-&gt;addressOfState()));
 7334         m_out.branch(
 7335             m_out.equal(state, m_out.constInt32(IsInvalidated)),
 7336             usually(continuation), rarely(isNotInvalidated));
 7337 
 7338         LBasicBlock lastNext = m_out.appendTo(isNotInvalidated, continuation);
 7339 
 7340         VM&amp; vm = this-&gt;vm();
 7341         lazySlowPath(
 7342             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 7343                 return createLazyCallGenerator(vm,
 7344                     operationNotifyWrite, InvalidGPRReg, CCallHelpers::TrustedImmPtr(set));
 7345             });
 7346         m_out.jump(continuation);
 7347 
 7348         m_out.appendTo(continuation, lastNext);
 7349     }
 7350 
 7351     void compileGetCallee()
 7352     {
 7353         setJSValue(m_out.loadPtr(addressFor(CallFrameSlot::callee)));
 7354     }
 7355 
 7356     void compileSetCallee()
 7357     {
 7358         auto callee = lowCell(m_node-&gt;child1());
 7359         m_out.storePtr(callee, payloadFor(CallFrameSlot::callee));
 7360     }
 7361 
 7362     void compileGetArgumentCountIncludingThis()
 7363     {
 7364         VirtualRegister argumentCountRegister;
 7365         if (InlineCallFrame* inlineCallFrame = m_node-&gt;argumentsInlineCallFrame())
 7366             argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
 7367         else
 7368             argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
 7369         setInt32(m_out.load32(payloadFor(argumentCountRegister)));
 7370     }
 7371 
 7372     void compileSetArgumentCountIncludingThis()
 7373     {
 7374         m_out.store32(m_out.constInt32(m_node-&gt;argumentCountIncludingThis()), payloadFor(CallFrameSlot::argumentCount));
 7375     }
 7376 
 7377     void compileGetScope()
 7378     {
 7379         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSFunction_scope));
 7380     }
 7381 
 7382     void compileSkipScope()
 7383     {
 7384         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSScope_next));
 7385     }
 7386 
 7387     void compileGetGlobalObject()
 7388     {
 7389         LValue structure = loadStructure(lowCell(m_node-&gt;child1()));
 7390         setJSValue(m_out.loadPtr(structure, m_heaps.Structure_globalObject));
 7391     }
 7392 
 7393     void compileGetGlobalThis()
 7394     {
 7395         auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 7396         setJSValue(m_out.loadPtr(m_out.absolute(globalObject-&gt;addressOfGlobalThis())));
 7397     }
 7398 
 7399     void compileGetClosureVar()
 7400     {
 7401         setJSValue(
 7402             m_out.load64(
 7403                 lowCell(m_node-&gt;child1()),
 7404                 m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]));
 7405     }
 7406 
 7407     void compilePutClosureVar()
 7408     {
 7409         m_out.store64(
 7410             lowJSValue(m_node-&gt;child2()),
 7411             lowCell(m_node-&gt;child1()),
 7412             m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]);
 7413     }
 7414 
 7415     void compileGetFromArguments()
 7416     {
 7417         setJSValue(
 7418             m_out.load64(
 7419                 lowCell(m_node-&gt;child1()),
 7420                 m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]));
 7421     }
 7422 
 7423     void compilePutToArguments()
 7424     {
 7425         m_out.store64(
 7426             lowJSValue(m_node-&gt;child2()),
 7427             lowCell(m_node-&gt;child1()),
 7428             m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]);
 7429     }
 7430 
 7431     void compileGetArgument()
 7432     {
 7433         LValue argumentCount = m_out.load32(payloadFor(AssemblyHelpers::argumentCount(m_node-&gt;origin.semantic)));
 7434 
 7435         LBasicBlock inBounds = m_out.newBlock();
 7436         LBasicBlock outOfBounds = m_out.newBlock();
 7437         LBasicBlock continuation = m_out.newBlock();
 7438 
 7439         m_out.branch(m_out.lessThanOrEqual(argumentCount, m_out.constInt32(m_node-&gt;argumentIndex())), unsure(outOfBounds), unsure(inBounds));
 7440 
 7441         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
 7442         VirtualRegister arg = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic) + m_node-&gt;argumentIndex() - 1;
 7443         ValueFromBlock inBoundsResult = m_out.anchor(m_out.load64(addressFor(arg)));
 7444         m_out.jump(continuation);
 7445 
 7446         m_out.appendTo(outOfBounds, continuation);
 7447         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueUndefined));
 7448         m_out.jump(continuation);
 7449 
 7450         m_out.appendTo(continuation, lastNext);
 7451         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
 7452     }
 7453 
 7454     void compileCompareEq()
 7455     {
 7456         if (m_node-&gt;isBinaryUseKind(Int32Use)
 7457             || m_node-&gt;isBinaryUseKind(Int52RepUse)
 7458             || m_node-&gt;isBinaryUseKind(DoubleRepUse)
 7459             || m_node-&gt;isBinaryUseKind(ObjectUse)
 7460             || m_node-&gt;isBinaryUseKind(BooleanUse)
 7461             || m_node-&gt;isBinaryUseKind(SymbolUse)
 7462             || m_node-&gt;isBinaryUseKind(StringIdentUse)
 7463             || m_node-&gt;isBinaryUseKind(StringUse)) {
 7464             compileCompareStrictEq();
 7465             return;
 7466         }
 7467 
 7468         if (m_node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 7469             compareEqObjectOrOtherToObject(m_node-&gt;child2(), m_node-&gt;child1());
 7470             return;
 7471         }
 7472 
 7473         if (m_node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 7474             compareEqObjectOrOtherToObject(m_node-&gt;child1(), m_node-&gt;child2());
 7475             return;
 7476         }
 7477 
 7478         if (m_node-&gt;child1().useKind() == KnownOtherUse) {
 7479             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecOther));
 7480             setBoolean(equalNullOrUndefined(m_node-&gt;child2(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 7481             return;
 7482         }
 7483 
 7484         if (m_node-&gt;child2().useKind() == KnownOtherUse) {
 7485             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child2(), SpecOther));
 7486             setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 7487             return;
 7488         }
 7489 
 7490         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 7491         nonSpeculativeCompare(
 7492             [&amp;] (LValue left, LValue right) {
 7493                 return m_out.equal(left, right);
 7494             },
 7495             operationCompareEq);
 7496     }
 7497 
 7498     void compileCompareStrictEq()
 7499     {
 7500         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
 7501             setBoolean(
 7502                 m_out.equal(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7503             return;
 7504         }
 7505 
 7506         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
 7507             Int52Kind kind;
 7508             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 7509             LValue right = lowInt52(m_node-&gt;child2(), kind);
 7510             setBoolean(m_out.equal(left, right));
 7511             return;
 7512         }
 7513 
 7514         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 7515             setBoolean(
 7516                 m_out.doubleEqual(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 7517             return;
 7518         }
 7519 
 7520         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
 7521             setBoolean(
 7522                 m_out.equal(lowStringIdent(m_node-&gt;child1()), lowStringIdent(m_node-&gt;child2())));
 7523             return;
 7524         }
 7525 
 7526         if (m_node-&gt;isBinaryUseKind(StringUse)) {
 7527             LValue left = lowCell(m_node-&gt;child1());
 7528             LValue right = lowCell(m_node-&gt;child2());
 7529 
 7530             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 7531             LBasicBlock continuation = m_out.newBlock();
 7532 
 7533             speculateString(m_node-&gt;child1(), left);
 7534 
 7535             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 7536             m_out.branch(
 7537                 m_out.equal(left, right), unsure(continuation), unsure(notTriviallyEqualCase));
 7538 
 7539             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 7540 
 7541             speculateString(m_node-&gt;child2(), right);
 7542 
 7543             ValueFromBlock slowResult = m_out.anchor(stringsEqual(left, right, m_node-&gt;child1(), m_node-&gt;child2()));
 7544             m_out.jump(continuation);
 7545 
 7546             m_out.appendTo(continuation, lastNext);
 7547             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 7548             return;
 7549         }
 7550 
 7551         if (m_node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 7552             setBoolean(
 7553                 m_out.equal(
 7554                     lowNonNullObject(m_node-&gt;child1()),
 7555                     lowJSValue(m_node-&gt;child2())));
 7556             return;
 7557         }
 7558 
 7559         if (m_node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 7560             setBoolean(
 7561                 m_out.equal(
 7562                     lowNonNullObject(m_node-&gt;child2()),
 7563                     lowJSValue(m_node-&gt;child1())));
 7564             return;
 7565         }
 7566 
 7567         if (m_node-&gt;isBinaryUseKind(ObjectUse)) {
 7568             setBoolean(
 7569                 m_out.equal(
 7570                     lowNonNullObject(m_node-&gt;child1()),
 7571                     lowNonNullObject(m_node-&gt;child2())));
 7572             return;
 7573         }
 7574 
 7575         if (m_node-&gt;isBinaryUseKind(BooleanUse)) {
 7576             setBoolean(
 7577                 m_out.equal(lowBoolean(m_node-&gt;child1()), lowBoolean(m_node-&gt;child2())));
 7578             return;
 7579         }
 7580 
 7581         if (m_node-&gt;isBinaryUseKind(SymbolUse)) {
 7582             LValue leftSymbol = lowSymbol(m_node-&gt;child1());
 7583             LValue rightSymbol = lowSymbol(m_node-&gt;child2());
 7584             setBoolean(m_out.equal(leftSymbol, rightSymbol));
 7585             return;
 7586         }
 7587 
 7588         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 7589             // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
 7590             // https://bugs.webkit.org/show_bug.cgi?id=182895
 7591             LValue left = lowBigInt(m_node-&gt;child1());
 7592             LValue right = lowBigInt(m_node-&gt;child2());
 7593 
 7594             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 7595             LBasicBlock continuation = m_out.newBlock();
 7596 
 7597             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 7598             m_out.branch(m_out.equal(left, right), rarely(continuation), usually(notTriviallyEqualCase));
 7599 
 7600             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 7601 
 7602             ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
 7603                 pointerType(), m_out.operation(operationCompareStrictEq), m_callFrame, left, right)));
 7604             m_out.jump(continuation);
 7605 
 7606             m_out.appendTo(continuation, lastNext);
 7607             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 7608             return;
 7609         }
 7610 
 7611         if (m_node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)
 7612             || m_node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 7613             Edge symbolEdge = m_node-&gt;child1();
 7614             Edge untypedEdge = m_node-&gt;child2();
 7615             if (symbolEdge.useKind() != SymbolUse)
 7616                 std::swap(symbolEdge, untypedEdge);
 7617 
 7618             LValue leftSymbol = lowSymbol(symbolEdge);
 7619             LValue untypedValue = lowJSValue(untypedEdge);
 7620 
 7621             setBoolean(m_out.equal(leftSymbol, untypedValue));
 7622             return;
 7623         }
 7624 
 7625         if (m_node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 7626             || m_node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 7627             speculate(m_node-&gt;child1());
 7628             speculate(m_node-&gt;child2());
 7629             LValue left = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 7630             LValue right = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
 7631             setBoolean(m_out.equal(left, right));
 7632             return;
 7633         }
 7634 
 7635         if (m_node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)
 7636             || m_node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 7637             Edge leftEdge = m_node-&gt;childFor(StringIdentUse);
 7638             Edge rightEdge = m_node-&gt;childFor(NotStringVarUse);
 7639 
 7640             LValue left = lowStringIdent(leftEdge);
 7641             LValue rightValue = lowJSValue(rightEdge, ManualOperandSpeculation);
 7642 
 7643             LBasicBlock isCellCase = m_out.newBlock();
 7644             LBasicBlock isStringCase = m_out.newBlock();
 7645             LBasicBlock continuation = m_out.newBlock();
 7646 
 7647             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 7648             m_out.branch(
 7649                 isCell(rightValue, provenType(rightEdge)),
 7650                 unsure(isCellCase), unsure(continuation));
 7651 
 7652             LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 7653             ValueFromBlock notStringResult = m_out.anchor(m_out.booleanFalse);
 7654             m_out.branch(
 7655                 isString(rightValue, provenType(rightEdge)),
 7656                 unsure(isStringCase), unsure(continuation));
 7657 
 7658             m_out.appendTo(isStringCase, continuation);
 7659             LValue right = m_out.loadPtr(rightValue, m_heaps.JSString_value);
 7660             speculateStringIdent(rightEdge, rightValue, right);
 7661             ValueFromBlock isStringResult = m_out.anchor(m_out.equal(left, right));
 7662             m_out.jump(continuation);
 7663 
 7664             m_out.appendTo(continuation, lastNext);
 7665             setBoolean(m_out.phi(Int32, notCellResult, notStringResult, isStringResult));
 7666             return;
 7667         }
 7668 
 7669         if (m_node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 7670             compileStringToUntypedStrictEquality(m_node-&gt;child1(), m_node-&gt;child2());
 7671             return;
 7672         }
 7673         if (m_node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 7674             compileStringToUntypedStrictEquality(m_node-&gt;child2(), m_node-&gt;child1());
 7675             return;
 7676         }
 7677 
 7678         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 7679         nonSpeculativeCompare(
 7680             [&amp;] (LValue left, LValue right) {
 7681                 return m_out.equal(left, right);
 7682             },
 7683             operationCompareStrictEq);
 7684     }
 7685 
 7686     void compileStringToUntypedStrictEquality(Edge stringEdge, Edge untypedEdge)
 7687     {
 7688         ASSERT(stringEdge.useKind() == StringUse);
 7689         ASSERT(untypedEdge.useKind() == UntypedUse);
 7690 
 7691         LValue leftString = lowCell(stringEdge);
 7692         LValue rightValue = lowJSValue(untypedEdge);
 7693         SpeculatedType rightValueType = provenType(untypedEdge);
 7694 
 7695         // Verify left is string.
 7696         speculateString(stringEdge, leftString);
 7697 
 7698         LBasicBlock testUntypedEdgeIsCell = m_out.newBlock();
 7699         LBasicBlock testUntypedEdgeIsString = m_out.newBlock();
 7700         LBasicBlock testStringEquality = m_out.newBlock();
 7701         LBasicBlock continuation = m_out.newBlock();
 7702 
 7703         // Given left is string. If the value are strictly equal, rightValue has to be the same string.
 7704         ValueFromBlock fastTrue = m_out.anchor(m_out.booleanTrue);
 7705         m_out.branch(m_out.equal(leftString, rightValue), unsure(continuation), unsure(testUntypedEdgeIsCell));
 7706 
 7707         LBasicBlock lastNext = m_out.appendTo(testUntypedEdgeIsCell, testUntypedEdgeIsString);
 7708         ValueFromBlock fastFalse = m_out.anchor(m_out.booleanFalse);
 7709         m_out.branch(isNotCell(rightValue, rightValueType), unsure(continuation), unsure(testUntypedEdgeIsString));
 7710 
 7711         // Check if the untyped edge is a string.
 7712         m_out.appendTo(testUntypedEdgeIsString, testStringEquality);
 7713         m_out.branch(isNotString(rightValue, rightValueType), unsure(continuation), unsure(testStringEquality));
 7714 
 7715         // Full String compare.
 7716         m_out.appendTo(testStringEquality, continuation);
 7717         ValueFromBlock slowResult = m_out.anchor(stringsEqual(leftString, rightValue, stringEdge, untypedEdge));
 7718         m_out.jump(continuation);
 7719 
 7720         // Continuation.
 7721         m_out.appendTo(continuation, lastNext);
 7722         setBoolean(m_out.phi(Int32, fastTrue, fastFalse, slowResult));
 7723     }
 7724 
 7725     void compileCompareEqPtr()
 7726     {
 7727         setBoolean(
 7728             m_out.equal(
 7729                 lowJSValue(m_node-&gt;child1()),
 7730                 weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 7731     }
 7732 
 7733     void compileCompareLess()
 7734     {
 7735         compare(
 7736             [&amp;] (LValue left, LValue right) {
 7737                 return m_out.lessThan(left, right);
 7738             },
 7739             [&amp;] (LValue left, LValue right) {
 7740                 return m_out.doubleLessThan(left, right);
 7741             },
 7742             operationCompareStringImplLess,
 7743             operationCompareStringLess,
 7744             operationCompareLess);
 7745     }
 7746 
 7747     void compileCompareLessEq()
 7748     {
 7749         compare(
 7750             [&amp;] (LValue left, LValue right) {
 7751                 return m_out.lessThanOrEqual(left, right);
 7752             },
 7753             [&amp;] (LValue left, LValue right) {
 7754                 return m_out.doubleLessThanOrEqual(left, right);
 7755             },
 7756             operationCompareStringImplLessEq,
 7757             operationCompareStringLessEq,
 7758             operationCompareLessEq);
 7759     }
 7760 
 7761     void compileCompareGreater()
 7762     {
 7763         compare(
 7764             [&amp;] (LValue left, LValue right) {
 7765                 return m_out.greaterThan(left, right);
 7766             },
 7767             [&amp;] (LValue left, LValue right) {
 7768                 return m_out.doubleGreaterThan(left, right);
 7769             },
 7770             operationCompareStringImplGreater,
 7771             operationCompareStringGreater,
 7772             operationCompareGreater);
 7773     }
 7774 
 7775     void compileCompareGreaterEq()
 7776     {
 7777         compare(
 7778             [&amp;] (LValue left, LValue right) {
 7779                 return m_out.greaterThanOrEqual(left, right);
 7780             },
 7781             [&amp;] (LValue left, LValue right) {
 7782                 return m_out.doubleGreaterThanOrEqual(left, right);
 7783             },
 7784             operationCompareStringImplGreaterEq,
 7785             operationCompareStringGreaterEq,
 7786             operationCompareGreaterEq);
 7787     }
 7788 
 7789     void compileCompareBelow()
 7790     {
 7791         setBoolean(m_out.below(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7792     }
 7793 
 7794     void compileCompareBelowEq()
 7795     {
 7796         setBoolean(m_out.belowOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 7797     }
 7798 
 7799     void compileSameValue()
 7800     {
 7801         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 7802             LValue arg1 = lowDouble(m_node-&gt;child1());
 7803             LValue arg2 = lowDouble(m_node-&gt;child2());
 7804 
 7805             LBasicBlock numberCase = m_out.newBlock();
 7806             LBasicBlock continuation = m_out.newBlock();
 7807 
 7808             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 7809             patchpoint-&gt;append(arg1, ValueRep::SomeRegister);
 7810             patchpoint-&gt;append(arg2, ValueRep::SomeRegister);
 7811             patchpoint-&gt;numGPScratchRegisters = 1;
 7812             patchpoint-&gt;setGenerator(
 7813                 [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7814                     GPRReg scratchGPR = params.gpScratch(0);
 7815                     jit.moveDoubleTo64(params[1].fpr(), scratchGPR);
 7816                     jit.moveDoubleTo64(params[2].fpr(), params[0].gpr());
 7817                     jit.compare64(CCallHelpers::Equal, scratchGPR, params[0].gpr(), params[0].gpr());
 7818                 });
 7819             patchpoint-&gt;effects = Effects::none();
 7820             ValueFromBlock compareResult = m_out.anchor(patchpoint);
 7821             m_out.branch(patchpoint, unsure(continuation), unsure(numberCase));
 7822 
 7823             LBasicBlock lastNext = m_out.appendTo(numberCase, continuation);
 7824             LValue isArg1NaN = m_out.doubleNotEqualOrUnordered(arg1, arg1);
 7825             LValue isArg2NaN = m_out.doubleNotEqualOrUnordered(arg2, arg2);
 7826             ValueFromBlock nanResult = m_out.anchor(m_out.bitAnd(isArg1NaN, isArg2NaN));
 7827             m_out.jump(continuation);
 7828 
 7829             m_out.appendTo(continuation, lastNext);
 7830             setBoolean(m_out.phi(Int32, compareResult, nanResult));
 7831             return;
 7832         }
 7833 
 7834         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
 7835         setBoolean(vmCall(Int32, m_out.operation(operationSameValue), m_callFrame, lowJSValue(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));
 7836     }
 7837 
 7838     void compileLogicalNot()
 7839     {
 7840         setBoolean(m_out.logicalNot(boolify(m_node-&gt;child1())));
 7841     }
 7842 
 7843     void compileCallOrConstruct()
 7844     {
 7845         Node* node = m_node;
 7846         unsigned numArgs = node-&gt;numChildren() - 1;
 7847 
 7848         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 7849 
 7850         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 7851         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 7852 
 7853         // JS-&gt;JS calling convention requires that the caller allows this much space on top of stack to
 7854         // get trashed by the callee, even if not all of that space is used to pass arguments. We tell
 7855         // B3 this explicitly for two reasons:
 7856         //
 7857         // - We will only pass frameSize worth of stuff.
 7858         // - The trashed stack guarantee is logically separate from the act of passing arguments, so we
 7859         //   shouldn&#39;t rely on Air to infer the trashed stack property based on the arguments it ends
 7860         //   up seeing.
 7861         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 7862 
 7863         // Collect the arguments, since this can generate code and we want to generate it before we emit
 7864         // the call.
 7865         Vector&lt;ConstrainedValue&gt; arguments;
 7866 
 7867         // Make sure that the callee goes into GPR0 because that&#39;s where the slow path thunks expect the
 7868         // callee to be.
 7869         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 7870 
 7871         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 7872             intptr_t offsetFromSP =
 7873                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7874             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7875         };
 7876 
 7877         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7878         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7879         for (unsigned i = 0; i &lt; numArgs; ++i)
 7880             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7881 
 7882         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 7883         patchpoint-&gt;appendVector(arguments);
 7884 
 7885         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 7886             preparePatchpointForExceptions(patchpoint);
 7887 
 7888         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 7889         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 7890         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 7891         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 7892         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 7893 
 7894         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 7895         State* state = &amp;m_ftlState;
 7896         VM* vm = &amp;this-&gt;vm();
 7897         patchpoint-&gt;setGenerator(
 7898             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7899                 AllowMacroScratchRegisterUsage allowScratch(jit);
 7900                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 7901 
 7902                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 7903 
 7904                 jit.store32(
 7905                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 7906                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 7907 
 7908                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 7909 
 7910                 CCallHelpers::DataLabelPtr targetToCheck;
 7911                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 7912                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 7913                     CCallHelpers::TrustedImmPtr(nullptr));
 7914 
 7915                 CCallHelpers::Call fastCall = jit.nearCall();
 7916                 CCallHelpers::Jump done = jit.jump();
 7917 
 7918                 slowPath.link(&amp;jit);
 7919 
 7920                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 7921                 CCallHelpers::Call slowCall = jit.nearCall();
 7922                 done.link(&amp;jit);
 7923 
 7924                 callLinkInfo-&gt;setUpCall(
 7925                     node-&gt;op() == Construct ? CallLinkInfo::Construct : CallLinkInfo::Call,
 7926                     node-&gt;origin.semantic, GPRInfo::regT0);
 7927 
 7928                 jit.addPtr(
 7929                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 7930                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 7931 
 7932                 jit.addLinkTask(
 7933                     [=] (LinkBuffer&amp; linkBuffer) {
 7934                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 7935                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 7936 
 7937                         callLinkInfo-&gt;setCallLocations(
 7938                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 7939                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 7940                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 7941                     });
 7942             });
 7943 
 7944         setJSValue(patchpoint);
 7945     }
 7946 
 7947     void compileDirectCallOrConstruct()
 7948     {
 7949         Node* node = m_node;
 7950         bool isTail = node-&gt;op() == DirectTailCall;
 7951         bool isConstruct = node-&gt;op() == DirectConstruct;
 7952 
 7953         ExecutableBase* executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 7954         FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 7955 
 7956         unsigned numPassedArgs = node-&gt;numChildren() - 1;
 7957         unsigned numAllocatedArgs = numPassedArgs;
 7958 
 7959         if (functionExecutable) {
 7960             numAllocatedArgs = std::max(
 7961                 numAllocatedArgs,
 7962                 std::min(
 7963                     static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1,
 7964                     Options::maximumDirectCallStackSize()));
 7965         }
 7966 
 7967         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 7968 
 7969         if (!isTail) {
 7970             unsigned frameSize = (CallFrame::headerSizeInRegisters + numAllocatedArgs) * sizeof(EncodedJSValue);
 7971             unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 7972 
 7973             m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 7974         }
 7975 
 7976         Vector&lt;ConstrainedValue&gt; arguments;
 7977 
 7978         arguments.append(ConstrainedValue(jsCallee, ValueRep::SomeRegister));
 7979         if (!isTail) {
 7980             auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 7981                 intptr_t offsetFromSP =
 7982                     (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 7983                 arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 7984             };
 7985 
 7986             addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 7987             addArgument(m_out.constInt32(numPassedArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 7988             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7989                 addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 7990             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 7991                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgument(i), 0);
 7992         } else {
 7993             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 7994                 arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
 7995         }
 7996 
 7997         PatchpointValue* patchpoint = m_out.patchpoint(isTail ? Void : Int64);
 7998         patchpoint-&gt;appendVector(arguments);
 7999 
 8000         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8001 
 8002         if (isTail) {
 8003             // The shuffler needs tags.
 8004             patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8005             patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8006         }
 8007 
 8008         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8009         if (!isTail) {
 8010             patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 8011             patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8012         }
 8013 
 8014         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8015         State* state = &amp;m_ftlState;
 8016         patchpoint-&gt;setGenerator(
 8017             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8018                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8019                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8020 
 8021                 GPRReg calleeGPR = params[!isTail].gpr();
 8022 
 8023                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8024 
 8025                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8026                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8027 
 8028                 if (isTail) {
 8029                     CallFrameShuffleData shuffleData;
 8030                     shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 8031 
 8032                     RegisterSet toSave = params.unavailableRegisters();
 8033                     shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatCell);
 8034                     toSave.set(calleeGPR);
 8035                     for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 8036                         ValueRecovery recovery = params[1 + i].recoveryForJSValue();
 8037                         shuffleData.args.append(recovery);
 8038                         recovery.forEachReg(
 8039                             [&amp;] (Reg reg) {
 8040                                 toSave.set(reg);
 8041                             });
 8042                     }
 8043                     for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 8044                         shuffleData.args.append(ValueRecovery::constant(jsUndefined()));
 8045                     shuffleData.numPassedArgs = numPassedArgs;
 8046                     shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 8047 
 8048                     CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8049 
 8050                     CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
 8051                     CCallHelpers::Label mainPath = jit.label();
 8052 
 8053                     jit.store32(
 8054                         CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8055                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8056 
 8057                     callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 8058                     CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 8059 
 8060                     CCallHelpers::Call call = jit.nearTailCall();
 8061 
 8062                     jit.abortWithReason(JITDidReturnFromTailCall);
 8063 
 8064                     CCallHelpers::Label slowPath = jit.label();
 8065                     patchableJump.m_jump.linkTo(slowPath, &amp;jit);
 8066                     callOperation(
 8067                         *state, toSave, jit,
 8068                         node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 8069                         InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo), calleeGPR).call();
 8070                     jit.jump().linkTo(mainPath, &amp;jit);
 8071 
 8072                     callLinkInfo-&gt;setUpCall(
 8073                         CallLinkInfo::DirectTailCall, node-&gt;origin.semantic, InvalidGPRReg);
 8074                     callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 8075                     if (numAllocatedArgs &gt; numPassedArgs)
 8076                         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 8077 
 8078                     jit.addLinkTask(
 8079                         [=] (LinkBuffer&amp; linkBuffer) {
 8080                             CodeLocationLabel&lt;JSInternalPtrTag&gt; patchableJumpLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump);
 8081                             CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 8082                             CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 8083 
 8084                             callLinkInfo-&gt;setCallLocations(
 8085                                 patchableJumpLocation,
 8086                                 slowPathLocation,
 8087                                 callLocation);
 8088                         });
 8089                     return;
 8090                 }
 8091 
 8092                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8093 
 8094                 CCallHelpers::Label mainPath = jit.label();
 8095 
 8096                 jit.store32(
 8097                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8098                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8099 
 8100                 CCallHelpers::Call call = jit.nearCall();
 8101                 jit.addPtr(
 8102                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 8103                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8104 
 8105                 callLinkInfo-&gt;setUpCall(
 8106                     isConstruct ? CallLinkInfo::DirectConstruct : CallLinkInfo::DirectCall,
 8107                     node-&gt;origin.semantic, InvalidGPRReg);
 8108                 callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 8109                 if (numAllocatedArgs &gt; numPassedArgs)
 8110                     callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);
 8111 
 8112                 params.addLatePath(
 8113                     [=] (CCallHelpers&amp; jit) {
 8114                         AllowMacroScratchRegisterUsage allowScratch(jit);
 8115 
 8116                         CCallHelpers::Label slowPath = jit.label();
 8117                         if (isX86())
 8118                             jit.pop(CCallHelpers::selectScratchGPR(calleeGPR));
 8119 
 8120                         callOperation(
 8121                             *state, params.unavailableRegisters(), jit,
 8122                             node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 8123                             InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo),
 8124                             calleeGPR).call();
 8125                         jit.jump().linkTo(mainPath, &amp;jit);
 8126 
 8127                         jit.addLinkTask(
 8128                             [=] (LinkBuffer&amp; linkBuffer) {
 8129                                 CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 8130                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 8131 
 8132                                 linkBuffer.link(call, slowPathLocation);
 8133 
 8134                                 callLinkInfo-&gt;setCallLocations(
 8135                                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(),
 8136                                     slowPathLocation,
 8137                                     callLocation);
 8138                             });
 8139                     });
 8140             });
 8141 
 8142         if (isTail)
 8143             patchpoint-&gt;effects.terminal = true;
 8144         else
 8145             setJSValue(patchpoint);
 8146     }
 8147 
 8148     void compileTailCall()
 8149     {
 8150         Node* node = m_node;
 8151         unsigned numArgs = node-&gt;numChildren() - 1;
 8152 
 8153         // It seems counterintuitive that this is needed given that tail calls don&#39;t create a new frame
 8154         // on the stack. However, the tail call slow path builds the frame at SP instead of FP before
 8155         // calling into the slow path C code. This slow path may decide to throw an exception because
 8156         // the callee we&#39;re trying to call is not callable. Throwing an exception will cause us to walk
 8157         // the stack, which may read, for the sake of the correctness of this code, arbitrary slots on the
 8158         // stack to recover state. This call arg area ensures the call frame shuffler does not overwrite
 8159         // any of the slots the stack walking code requires when on the slow path.
 8160         m_proc.requestCallArgAreaSizeInBytes(
 8161             WTF::roundUpToMultipleOf(stackAlignmentBytes(), (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue)));
 8162 
 8163         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8164 
 8165         // We want B3 to give us all of the arguments using whatever mechanism it thinks is
 8166         // convenient. The generator then shuffles those arguments into our own call frame,
 8167         // destroying our frame in the process.
 8168 
 8169         // Note that we don&#39;t have to do anything special for exceptions. A tail call is only a
 8170         // tail call if it is not inside a try block.
 8171 
 8172         Vector&lt;ConstrainedValue&gt; arguments;
 8173 
 8174         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 8175 
 8176         for (unsigned i = 0; i &lt; numArgs; ++i) {
 8177             // Note: we could let the shuffler do boxing for us, but it&#39;s not super clear that this
 8178             // would be better. Also, if we wanted to do that, then we&#39;d have to teach the shuffler
 8179             // that 32-bit values could land at 4-byte alignment but not 8-byte alignment.
 8180 
 8181             ConstrainedValue constrainedValue(
 8182                 lowJSValue(m_graph.varArgChild(node, 1 + i)),
 8183                 ValueRep::WarmAny);
 8184             arguments.append(constrainedValue);
 8185         }
 8186 
 8187         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 8188         patchpoint-&gt;appendVector(arguments);
 8189 
 8190         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8191         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8192 
 8193         // Prevent any of the arguments from using the scratch register.
 8194         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());
 8195 
 8196         patchpoint-&gt;effects.terminal = true;
 8197 
 8198         // We don&#39;t have to tell the patchpoint that we will clobber registers, since we won&#39;t return
 8199         // anyway.
 8200 
 8201         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8202         State* state = &amp;m_ftlState;
 8203         VM* vm = &amp;this-&gt;vm();
 8204         patchpoint-&gt;setGenerator(
 8205             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8206                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8207                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8208 
 8209                 // Yes, this is really necessary. You could throw an exception in a host call on the
 8210                 // slow path. That&#39;ll route us to lookupExceptionHandler(), which unwinds starting
 8211                 // with the call site index of our frame. Bad things happen if it&#39;s not set.
 8212                 jit.store32(
 8213                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8214                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8215 
 8216                 CallFrameShuffleData shuffleData;
 8217                 shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 8218                 shuffleData.callee = ValueRecovery::inGPR(GPRInfo::regT0, DataFormatJS);
 8219 
 8220                 for (unsigned i = 0; i &lt; numArgs; ++i)
 8221                     shuffleData.args.append(params[1 + i].recoveryForJSValue());
 8222 
 8223                 shuffleData.numPassedArgs = numArgs;
 8224 
 8225                 shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 8226 
 8227                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8228 
 8229                 CCallHelpers::DataLabelPtr targetToCheck;
 8230                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8231                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8232                     CCallHelpers::TrustedImmPtr(nullptr));
 8233 
 8234                 callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 8235                 CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 8236 
 8237                 CCallHelpers::Call fastCall = jit.nearTailCall();
 8238 
 8239                 slowPath.link(&amp;jit);
 8240 
 8241                 CallFrameShuffler slowPathShuffler(jit, shuffleData);
 8242                 slowPathShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 8243                 slowPathShuffler.prepareForSlowPath();
 8244 
 8245                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 8246                 CCallHelpers::Call slowCall = jit.nearCall();
 8247 
 8248                 jit.abortWithReason(JITDidReturnFromTailCall);
 8249 
 8250                 callLinkInfo-&gt;setUpCall(CallLinkInfo::TailCall, codeOrigin, GPRInfo::regT0);
 8251 
 8252                 jit.addLinkTask(
 8253                     [=] (LinkBuffer&amp; linkBuffer) {
 8254                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8255                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8256 
 8257                         callLinkInfo-&gt;setCallLocations(
 8258                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8259                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8260                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8261                     });
 8262             });
 8263     }
 8264 
 8265     void compileCallOrConstructVarargsSpread()
 8266     {
 8267         Node* node = m_node;
 8268         Node* arguments = node-&gt;child3().node();
 8269 
 8270         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 8271         LValue thisArg = lowJSValue(m_node-&gt;child2());
 8272 
 8273         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomSpread || arguments-&gt;op() == PhantomNewArrayBuffer);
 8274 
 8275         unsigned staticArgumentCount = 0;
 8276         Vector&lt;LValue, 2&gt; spreadLengths;
 8277         Vector&lt;LValue, 8&gt; patchpointArguments;
 8278         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 8279         auto pushAndCountArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8280             if (target-&gt;op() == PhantomSpread) {
 8281                 self(target-&gt;child1().node());
 8282                 return;
 8283             }
 8284 
 8285             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8286                 BitVector* bitVector = target-&gt;bitVector();
 8287                 for (unsigned i = target-&gt;numChildren(); i--; ) {
 8288                     if (bitVector-&gt;get(i))
 8289                         self(m_graph.varArgChild(target, i).node());
 8290                     else {
 8291                         ++staticArgumentCount;
 8292                         LValue argument = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 8293                         patchpointArguments.append(argument);
 8294                     }
 8295                 }
 8296                 return;
 8297             }
 8298 
 8299             if (target-&gt;op() == PhantomNewArrayBuffer) {
 8300                 staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 8301                 return;
 8302             }
 8303 
 8304             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 8305             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 8306             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8307             LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 8308                 return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
 8309             }).iterator-&gt;value;
 8310             patchpointArguments.append(length);
 8311             spreadLengths.append(length);
 8312         });
 8313 
 8314         pushAndCountArgumentsFromRightToLeft(arguments);
 8315         LValue argumentCountIncludingThis = m_out.constIntPtr(staticArgumentCount + 1);
 8316         for (LValue length : spreadLengths)
 8317             argumentCountIncludingThis = m_out.add(length, argumentCountIncludingThis);
 8318 
 8319         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8320 
 8321         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8322         patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
 8323         patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
 8324         patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
 8325         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8326         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8327 
 8328         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8329 
 8330         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8331         patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
 8332         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8333 
 8334         patchpoint-&gt;numGPScratchRegisters = 0;
 8335 
 8336         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8337         unsigned minimumJSCallAreaSize =
 8338             sizeof(CallerFrameAndPC) +
 8339             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8340 
 8341         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8342 
 8343         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8344         State* state = &amp;m_ftlState;
 8345         VM* vm = &amp;this-&gt;vm();
 8346         patchpoint-&gt;setGenerator(
 8347             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8348                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8349                 CallSiteIndex callSiteIndex =
 8350                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8351 
 8352                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8353                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8354 
 8355                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8356 
 8357                 jit.store32(
 8358                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8359                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8360 
 8361                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8362 
 8363                 RegisterSet usedRegisters = RegisterSet::allRegisters();
 8364                 usedRegisters.exclude(RegisterSet::volatileRegistersForJSCall());
 8365                 GPRReg calleeGPR = params[1].gpr();
 8366                 usedRegisters.set(calleeGPR);
 8367 
 8368                 ScratchRegisterAllocator allocator(usedRegisters);
 8369                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8370                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8371                 GPRReg scratchGPR3 = allocator.allocateScratchGPR();
 8372                 GPRReg scratchGPR4 = allocator.allocateScratchGPR();
 8373                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8374 
 8375                 auto getValueFromRep = [&amp;] (B3::ValueRep rep, GPRReg result) {
 8376                     ASSERT(!usedRegisters.get(result));
 8377 
 8378                     if (rep.isConstant()) {
 8379                         jit.move(CCallHelpers::Imm64(rep.value()), result);
 8380                         return;
 8381                     }
 8382 
 8383                     // Note: in this function, we only request 64 bit values.
 8384                     if (rep.isStack()) {
 8385                         jit.load64(
 8386                             CCallHelpers::Address(GPRInfo::callFrameRegister, rep.offsetFromFP()),
 8387                             result);
 8388                         return;
 8389                     }
 8390 
 8391                     RELEASE_ASSERT(rep.isGPR());
 8392                     ASSERT(usedRegisters.get(rep.gpr()));
 8393                     jit.move(rep.gpr(), result);
 8394                 };
 8395 
 8396                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8397                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8398                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8399                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8400                 };
 8401 
 8402                 CCallHelpers::JumpList slowCase;
 8403                 unsigned originalStackHeight = params.proc().frameSize();
 8404 
 8405                 {
 8406                     unsigned numUsedSlots = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), originalStackHeight / sizeof(EncodedJSValue));
 8407                     B3::ValueRep argumentCountIncludingThisRep = params[3];
 8408                     getValueFromRep(argumentCountIncludingThisRep, scratchGPR2);
 8409                     slowCase.append(jit.branch32(CCallHelpers::Above, scratchGPR2, CCallHelpers::TrustedImm32(JSC::maxArguments + 1)));
 8410 
 8411                     jit.move(scratchGPR2, scratchGPR1);
 8412                     jit.addPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(numUsedSlots + CallFrame::headerSizeInRegisters)), scratchGPR1);
 8413                     // scratchGPR1 now has the required frame size in Register units
 8414                     // Round scratchGPR1 to next multiple of stackAlignmentRegisters()
 8415                     jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentRegisters() - 1), scratchGPR1);
 8416                     jit.andPtr(CCallHelpers::TrustedImm32(~(stackAlignmentRegisters() - 1)), scratchGPR1);
 8417                     jit.negPtr(scratchGPR1);
 8418                     jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR1, CCallHelpers::TimesEight), scratchGPR1);
 8419 
 8420                     // Before touching stack values, we should update the stack pointer to protect them from signal stack.
 8421                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), scratchGPR1, CCallHelpers::stackPointerRegister);
 8422 
 8423                     jit.store32(scratchGPR2, CCallHelpers::Address(scratchGPR1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));
 8424 
 8425                     int storeOffset = CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register));
 8426 
 8427                     unsigned paramsOffset = 4;
 8428                     unsigned index = 0;
 8429                     auto emitArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8430                         if (target-&gt;op() == PhantomSpread) {
 8431                             self(target-&gt;child1().node());
 8432                             return;
 8433                         }
 8434 
 8435                         if (target-&gt;op() == PhantomNewArrayWithSpread) {
 8436                             BitVector* bitVector = target-&gt;bitVector();
 8437                             for (unsigned i = target-&gt;numChildren(); i--; ) {
 8438                                 if (bitVector-&gt;get(i))
 8439                                     self(state-&gt;graph.varArgChild(target, i).node());
 8440                                 else {
 8441                                     jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8442                                     getValueFromRep(params[paramsOffset + (index++)], scratchGPR3);
 8443                                     jit.store64(scratchGPR3,
 8444                                         CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8445                                 }
 8446                             }
 8447                             return;
 8448                         }
 8449 
 8450                         if (target-&gt;op() == PhantomNewArrayBuffer) {
 8451                             auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 8452                             Checked&lt;int32_t&gt; offsetCount { 1 };
 8453                             for (unsigned i = array-&gt;length(); i--; ++offsetCount) {
 8454                                 // Because varargs values are drained as JSValue, we should not generate value
 8455                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 8456                                 int64_t value = JSValue::encode(array-&gt;get(i));
 8457                                 jit.move(CCallHelpers::TrustedImm64(value), scratchGPR3);
 8458                                 Checked&lt;int32_t&gt; currentStoreOffset { storeOffset };
 8459                                 currentStoreOffset -= (offsetCount * static_cast&lt;int32_t&gt;(sizeof(Register)));
 8460                                 jit.store64(scratchGPR3,
 8461                                     CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, currentStoreOffset.unsafeGet()));
 8462                             }
 8463                             jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
 8464                             return;
 8465                         }
 8466 
 8467                         RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 8468                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 8469 
 8470                         unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 8471 
 8472                         B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
 8473                         getValueFromRep(numArgumentsToCopy, scratchGPR3);
 8474                         int loadOffset = (AssemblyHelpers::argumentsStart(inlineCallFrame).offset() + numberOfArgumentsToSkip) * static_cast&lt;int&gt;(sizeof(Register));
 8475 
 8476                         auto done = jit.branchTestPtr(MacroAssembler::Zero, scratchGPR3);
 8477                         auto loopStart = jit.label();
 8478                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR3);
 8479                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 8480                         jit.load64(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR3, CCallHelpers::TimesEight, loadOffset), scratchGPR4);
 8481                         jit.store64(scratchGPR4,
 8482                             CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 8483                         jit.branchTestPtr(CCallHelpers::NonZero, scratchGPR3).linkTo(loopStart, &amp;jit);
 8484                         done.link(&amp;jit);
 8485                     });
 8486                     emitArgumentsFromRightToLeft(arguments);
 8487                 }
 8488 
 8489                 {
 8490                     CCallHelpers::Jump dontThrow = jit.jump();
 8491                     slowCase.link(&amp;jit);
 8492                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8493                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8494                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8495 
 8496                     dontThrow.link(&amp;jit);
 8497                 }
 8498 
 8499                 ASSERT(calleeGPR == GPRInfo::regT0);
 8500                 jit.store64(calleeGPR, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 8501                 getValueFromRep(params[2], scratchGPR3);
 8502                 jit.store64(scratchGPR3, CCallHelpers::calleeArgumentSlot(0));
 8503 
 8504                 CallLinkInfo::CallType callType;
 8505                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 8506                     callType = CallLinkInfo::ConstructVarargs;
 8507                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 8508                     callType = CallLinkInfo::TailCallVarargs;
 8509                 else
 8510                     callType = CallLinkInfo::CallVarargs;
 8511 
 8512                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 8513 
 8514                 CCallHelpers::DataLabelPtr targetToCheck;
 8515                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8516                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8517                     CCallHelpers::TrustedImmPtr(nullptr));
 8518 
 8519                 CCallHelpers::Call fastCall;
 8520                 CCallHelpers::Jump done;
 8521 
 8522                 if (isTailCall) {
 8523                     jit.emitRestoreCalleeSaves();
 8524                     jit.prepareForTailCallSlow();
 8525                     fastCall = jit.nearTailCall();
 8526                 } else {
 8527                     fastCall = jit.nearCall();
 8528                     done = jit.jump();
 8529                 }
 8530 
 8531                 slowPath.link(&amp;jit);
 8532 
 8533                 if (isTailCall)
 8534                     jit.emitRestoreCalleeSaves();
 8535                 ASSERT(!usedRegisters.get(GPRInfo::regT2));
 8536                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 8537                 CCallHelpers::Call slowCall = jit.nearCall();
 8538 
 8539                 if (isTailCall)
 8540                     jit.abortWithReason(JITDidReturnFromTailCall);
 8541                 else
 8542                     done.link(&amp;jit);
 8543 
 8544                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 8545 
 8546                 jit.addPtr(
 8547                     CCallHelpers::TrustedImm32(-originalStackHeight),
 8548                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8549 
 8550                 jit.addLinkTask(
 8551                     [=] (LinkBuffer&amp; linkBuffer) {
 8552                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8553                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8554 
 8555                         callLinkInfo-&gt;setCallLocations(
 8556                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8557                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8558                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8559                     });
 8560             });
 8561 
 8562         switch (node-&gt;op()) {
 8563         case TailCallForwardVarargs:
 8564             m_out.unreachable();
 8565             break;
 8566 
 8567         default:
 8568             setJSValue(patchpoint);
 8569             break;
 8570         }
 8571     }
 8572 
 8573     void compileCallOrConstructVarargs()
 8574     {
 8575         Node* node = m_node;
 8576         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 8577         LValue thisArg = lowJSValue(m_node-&gt;child2());
 8578 
 8579         LValue jsArguments = nullptr;
 8580         bool forwarding = false;
 8581 
 8582         switch (node-&gt;op()) {
 8583         case CallVarargs:
 8584         case TailCallVarargs:
 8585         case TailCallVarargsInlinedCaller:
 8586         case ConstructVarargs:
 8587             jsArguments = lowJSValue(node-&gt;child3());
 8588             break;
 8589         case CallForwardVarargs:
 8590         case TailCallForwardVarargs:
 8591         case TailCallForwardVarargsInlinedCaller:
 8592         case ConstructForwardVarargs:
 8593             forwarding = true;
 8594             break;
 8595         default:
 8596             DFG_CRASH(m_graph, node, &quot;bad node type&quot;);
 8597             break;
 8598         }
 8599 
 8600         if (forwarding &amp;&amp; m_node-&gt;child3()) {
 8601             Node* arguments = m_node-&gt;child3().node();
 8602             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8603                 compileCallOrConstructVarargsSpread();
 8604                 return;
 8605             }
 8606         }
 8607 
 8608 
 8609         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8610 
 8611         // Append the forms of the arguments that we will use before any clobbering happens.
 8612         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 8613         if (jsArguments)
 8614             patchpoint-&gt;appendSomeRegister(jsArguments);
 8615         patchpoint-&gt;appendSomeRegister(thisArg);
 8616 
 8617         if (!forwarding) {
 8618             // Now append them again for after clobbering. Note that the compiler may ask us to use a
 8619             // different register for the late for the post-clobbering version of the value. This gives
 8620             // the compiler a chance to spill these values without having to burn any callee-saves.
 8621             patchpoint-&gt;append(jsCallee, ValueRep::LateColdAny);
 8622             patchpoint-&gt;append(jsArguments, ValueRep::LateColdAny);
 8623             patchpoint-&gt;append(thisArg, ValueRep::LateColdAny);
 8624         }
 8625 
 8626         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 8627             preparePatchpointForExceptions(patchpoint);
 8628 
 8629         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8630         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8631 
 8632         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8633         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 8634         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8635 
 8636         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 8637         unsigned minimumJSCallAreaSize =
 8638             sizeof(CallerFrameAndPC) +
 8639             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 8640 
 8641         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 8642 
 8643         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8644         State* state = &amp;m_ftlState;
 8645         VM* vm = &amp;this-&gt;vm();
 8646         patchpoint-&gt;setGenerator(
 8647             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8648                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8649                 CallSiteIndex callSiteIndex =
 8650                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8651 
 8652                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8653                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8654 
 8655                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8656 
 8657                 jit.store32(
 8658                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8659                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8660 
 8661                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8662                 CallVarargsData* data = node-&gt;callVarargsData();
 8663 
 8664                 unsigned argIndex = 1;
 8665                 GPRReg calleeGPR = params[argIndex++].gpr();
 8666                 ASSERT(calleeGPR == GPRInfo::regT0);
 8667                 GPRReg argumentsGPR = jsArguments ? params[argIndex++].gpr() : InvalidGPRReg;
 8668                 GPRReg thisGPR = params[argIndex++].gpr();
 8669 
 8670                 B3::ValueRep calleeLateRep;
 8671                 B3::ValueRep argumentsLateRep;
 8672                 B3::ValueRep thisLateRep;
 8673                 if (!forwarding) {
 8674                     // If we&#39;re not forwarding then we&#39;ll need callee, arguments, and this after we
 8675                     // have potentially clobbered calleeGPR, argumentsGPR, and thisGPR. Our technique
 8676                     // for this is to supply all of those operands as late uses in addition to
 8677                     // specifying them as early uses. It&#39;s possible that the late use uses a spill
 8678                     // while the early use uses a register, and it&#39;s possible for the late and early
 8679                     // uses to use different registers. We do know that the late uses interfere with
 8680                     // all volatile registers and so won&#39;t use those, but the early uses may use
 8681                     // volatile registers and in the case of calleeGPR, it&#39;s pinned to regT0 so it
 8682                     // definitely will.
 8683                     //
 8684                     // Note that we have to be super careful with these. It&#39;s possible that these
 8685                     // use a shuffling of the registers used for calleeGPR, argumentsGPR, and
 8686                     // thisGPR. If that happens and we do for example:
 8687                     //
 8688                     //     calleeLateRep.emitRestore(jit, calleeGPR);
 8689                     //     argumentsLateRep.emitRestore(jit, calleeGPR);
 8690                     //
 8691                     // Then we might end up with garbage if calleeLateRep.gpr() == argumentsGPR and
 8692                     // argumentsLateRep.gpr() == calleeGPR.
 8693                     //
 8694                     // We do a variety of things to prevent this from happening. For example, we use
 8695                     // argumentsLateRep before needing the other two and after we&#39;ve already stopped
 8696                     // using the *GPRs. Also, we pin calleeGPR to regT0, and rely on the fact that
 8697                     // the *LateReps cannot use volatile registers (so they cannot be regT0, so
 8698                     // calleeGPR != argumentsLateRep.gpr() and calleeGPR != thisLateRep.gpr()).
 8699                     //
 8700                     // An alternative would have been to just use early uses and early-clobber all
 8701                     // volatile registers. But that would force callee, arguments, and this into
 8702                     // callee-save registers even if we have to spill them. We don&#39;t want spilling to
 8703                     // use up three callee-saves.
 8704                     //
 8705                     // TL;DR: The way we use LateReps here is dangerous and barely works but achieves
 8706                     // some desirable performance properties, so don&#39;t mistake the cleverness for
 8707                     // elegance.
 8708                     calleeLateRep = params[argIndex++];
 8709                     argumentsLateRep = params[argIndex++];
 8710                     thisLateRep = params[argIndex++];
 8711                 }
 8712 
 8713                 // Get some scratch registers.
 8714                 RegisterSet usedRegisters;
 8715                 usedRegisters.merge(RegisterSet::stackRegisters());
 8716                 usedRegisters.merge(RegisterSet::reservedHardwareRegisters());
 8717                 usedRegisters.merge(RegisterSet::calleeSaveRegisters());
 8718                 usedRegisters.set(calleeGPR);
 8719                 if (argumentsGPR != InvalidGPRReg)
 8720                     usedRegisters.set(argumentsGPR);
 8721                 usedRegisters.set(thisGPR);
 8722                 if (calleeLateRep.isReg())
 8723                     usedRegisters.set(calleeLateRep.reg());
 8724                 if (argumentsLateRep.isReg())
 8725                     usedRegisters.set(argumentsLateRep.reg());
 8726                 if (thisLateRep.isReg())
 8727                     usedRegisters.set(thisLateRep.reg());
 8728                 ScratchRegisterAllocator allocator(usedRegisters);
 8729                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 8730                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 8731                 GPRReg scratchGPR3 = forwarding ? allocator.allocateScratchGPR() : InvalidGPRReg;
 8732                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 8733 
 8734                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 8735                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 8736                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8737                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8738                 };
 8739 
 8740                 unsigned originalStackHeight = params.proc().frameSize();
 8741 
 8742                 if (forwarding) {
 8743                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8744 
 8745                     CCallHelpers::JumpList slowCase;
 8746                     InlineCallFrame* inlineCallFrame;
 8747                     if (node-&gt;child3())
 8748                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 8749                     else
 8750                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 8751 
 8752                     // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 8753                     emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 8754 
 8755                     CCallHelpers::Jump done = jit.jump();
 8756                     slowCase.link(&amp;jit);
 8757                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;();
 8758                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 8759                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 8760 
 8761                     done.link(&amp;jit);
 8762                 } else {
 8763                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
 8764                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));
 8765                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
 8766 
 8767                     jit.move(GPRInfo::returnValueGPR, scratchGPR1);
 8768                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 8769                     argumentsLateRep.emitRestore(jit, argumentsGPR);
 8770                     emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
 8771                     jit.addPtr(CCallHelpers::TrustedImm32(-minimumJSCallAreaSize), scratchGPR2, CCallHelpers::stackPointerRegister);
 8772                     jit.setupArguments&lt;decltype(operationSetupVarargsFrame)&gt;(scratchGPR2, argumentsGPR, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset), scratchGPR1);
 8773                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSetupVarargsFrame));
 8774 
 8775                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister);
 8776 
 8777                     calleeLateRep.emitRestore(jit, GPRInfo::regT0);
 8778 
 8779                     // This may not emit code if thisGPR got a callee-save. Also, we&#39;re guaranteed
 8780                     // that thisGPR != GPRInfo::regT0 because regT0 interferes with it.
 8781                     thisLateRep.emitRestore(jit, thisGPR);
 8782                 }
 8783 
 8784                 jit.store64(GPRInfo::regT0, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 8785                 jit.store64(thisGPR, CCallHelpers::calleeArgumentSlot(0));
 8786 
 8787                 CallLinkInfo::CallType callType;
 8788                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 8789                     callType = CallLinkInfo::ConstructVarargs;
 8790                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 8791                     callType = CallLinkInfo::TailCallVarargs;
 8792                 else
 8793                     callType = CallLinkInfo::CallVarargs;
 8794 
 8795                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 8796 
 8797                 CCallHelpers::DataLabelPtr targetToCheck;
 8798                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8799                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8800                     CCallHelpers::TrustedImmPtr(nullptr));
 8801 
 8802                 CCallHelpers::Call fastCall;
 8803                 CCallHelpers::Jump done;
 8804 
 8805                 if (isTailCall) {
 8806                     jit.emitRestoreCalleeSaves();
 8807                     jit.prepareForTailCallSlow();
 8808                     fastCall = jit.nearTailCall();
 8809                 } else {
 8810                     fastCall = jit.nearCall();
 8811                     done = jit.jump();
 8812                 }
 8813 
 8814                 slowPath.link(&amp;jit);
 8815 
 8816                 if (isTailCall)
 8817                     jit.emitRestoreCalleeSaves();
 8818                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
 8819                 CCallHelpers::Call slowCall = jit.nearCall();
 8820 
 8821                 if (isTailCall)
 8822                     jit.abortWithReason(JITDidReturnFromTailCall);
 8823                 else
 8824                     done.link(&amp;jit);
 8825 
 8826                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 8827 
 8828                 jit.addPtr(
 8829                     CCallHelpers::TrustedImm32(-originalStackHeight),
 8830                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8831 
 8832                 jit.addLinkTask(
 8833                     [=] (LinkBuffer&amp; linkBuffer) {
 8834                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8835                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8836 
 8837                         callLinkInfo-&gt;setCallLocations(
 8838                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8839                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8840                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8841                     });
 8842             });
 8843 
 8844         switch (node-&gt;op()) {
 8845         case TailCallVarargs:
 8846         case TailCallForwardVarargs:
 8847             m_out.unreachable();
 8848             break;
 8849 
 8850         default:
 8851             setJSValue(patchpoint);
 8852             break;
 8853         }
 8854     }
 8855 
 8856     void compileCallEval()
 8857     {
 8858         Node* node = m_node;
 8859         unsigned numArgs = node-&gt;numChildren() - 1;
 8860 
 8861         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8862 
 8863         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 8864         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 8865 
 8866         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 8867 
 8868         Vector&lt;ConstrainedValue&gt; arguments;
 8869         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 8870 
 8871         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8872             intptr_t offsetFromSP =
 8873                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8874             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8875         };
 8876 
 8877         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
 8878         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCount), PayloadOffset);
 8879         for (unsigned i = 0; i &lt; numArgs; ++i)
 8880             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgument(i), 0);
 8881 
 8882         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8883         patchpoint-&gt;appendVector(arguments);
 8884 
 8885         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8886 
 8887         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
 8888         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
 8889         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8890         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 8891         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8892 
 8893         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8894         State* state = &amp;m_ftlState;
 8895         VM&amp; vm = this-&gt;vm();
 8896         patchpoint-&gt;setGenerator(
 8897             [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8898                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8899                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8900 
 8901                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8902 
 8903                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8904 
 8905                 jit.store32(
 8906                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
 8907                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCount)));
 8908 
 8909                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8910                 callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
 8911 
 8912                 jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), CCallHelpers::stackPointerRegister, GPRInfo::regT1);
 8913                 jit.storePtr(GPRInfo::callFrameRegister, CCallHelpers::Address(GPRInfo::regT1, CallFrame::callerFrameOffset()));
 8914 
 8915                 // Now we need to make room for:
 8916                 // - The caller frame and PC for a call to operationCallEval.
 8917                 // - Potentially two arguments on the stack.
 8918                 unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;
 8919                 requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 8920                 jit.subPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
 8921                 jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT1);
 8922                 jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCallEval)), GPRInfo::nonPreservedNonArgumentGPR0);
 8923                 jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 8924                 exceptions-&gt;append(jit.emitExceptionCheck(state-&gt;vm(), AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 8925 
 8926                 CCallHelpers::Jump done = jit.branchTest64(CCallHelpers::NonZero, GPRInfo::returnValueGPR);
 8927 
 8928                 jit.addPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
 8929                 jit.load64(CCallHelpers::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
 8930                 jit.emitDumbVirtualCall(vm, callLinkInfo);
 8931 
 8932                 done.link(&amp;jit);
 8933                 jit.addPtr(
 8934                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 8935                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8936             });
 8937 
 8938         setJSValue(patchpoint);
 8939     }
 8940 
 8941     void compileLoadVarargs()
 8942     {
 8943         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8944         LValue jsArguments = lowJSValue(m_node-&gt;child1());
 8945 
 8946         LValue length = vmCall(
 8947             Int32, m_out.operation(operationSizeOfVarargs), m_callFrame, jsArguments,
 8948             m_out.constInt32(data-&gt;offset));
 8949 
 8950         // FIXME: There is a chance that we will call an effectful length property twice. This is safe
 8951         // from the standpoint of the VM&#39;s integrity, but it&#39;s subtly wrong from a spec compliance
 8952         // standpoint. The best solution would be one where we can exit *into* the op_call_varargs right
 8953         // past the sizing.
 8954         // https://bugs.webkit.org/show_bug.cgi?id=141448
 8955 
 8956         LValue lengthIncludingThis = m_out.add(length, m_out.int32One);
 8957 
 8958         speculate(
 8959             VarargsOverflow, noValue(), nullptr,
 8960             m_out.above(length, lengthIncludingThis));
 8961 
 8962         speculate(
 8963             VarargsOverflow, noValue(), nullptr,
 8964             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 8965 
 8966         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 8967 
 8968         // FIXME: This computation is rather silly. If operationLaodVarargs just took a pointer instead
 8969         // of a VirtualRegister, we wouldn&#39;t have to do this.
 8970         // https://bugs.webkit.org/show_bug.cgi?id=141660
 8971         LValue machineStart = m_out.lShr(
 8972             m_out.sub(addressFor(data-&gt;machineStart.offset()).value(), m_callFrame),
 8973             m_out.constIntPtr(3));
 8974 
 8975         vmCall(
 8976             Void, m_out.operation(operationLoadVarargs), m_callFrame,
 8977             m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
 8978             length, m_out.constInt32(data-&gt;mandatoryMinimum));
 8979     }
 8980 
 8981     void compileForwardVarargs()
 8982     {
 8983         if (m_node-&gt;child1()) {
 8984             Node* arguments = m_node-&gt;child1().node();
 8985             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 8986                 compileForwardVarargsWithSpread();
 8987                 return;
 8988             }
 8989         }
 8990 
 8991         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 8992         InlineCallFrame* inlineCallFrame;
 8993         if (m_node-&gt;child1())
 8994             inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 8995         else
 8996             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
 8997 
 8998         LValue length = nullptr;
 8999         LValue lengthIncludingThis = nullptr;
 9000         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 9001         if (argumentsLength.isKnown) {
 9002             unsigned knownLength = argumentsLength.known;
 9003             if (knownLength &gt;= data-&gt;offset)
 9004                 knownLength = knownLength - data-&gt;offset;
 9005             else
 9006                 knownLength = 0;
 9007             length = m_out.constInt32(knownLength);
 9008             lengthIncludingThis = m_out.constInt32(knownLength + 1);
 9009         } else {
 9010             // We need to perform the same logical operation as the code above, but through dynamic operations.
 9011             if (!data-&gt;offset)
 9012                 length = argumentsLength.value;
 9013             else {
 9014                 LBasicBlock isLarger = m_out.newBlock();
 9015                 LBasicBlock continuation = m_out.newBlock();
 9016 
 9017                 ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));
 9018                 m_out.branch(
 9019                     m_out.above(argumentsLength.value, m_out.constInt32(data-&gt;offset)), unsure(isLarger), unsure(continuation));
 9020                 LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);
 9021                 ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(data-&gt;offset)));
 9022                 m_out.jump(continuation);
 9023 
 9024                 m_out.appendTo(continuation, lastNext);
 9025                 length = m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);
 9026             }
 9027             lengthIncludingThis = m_out.add(length, m_out.constInt32(1));
 9028         }
 9029 
 9030         speculate(
 9031             VarargsOverflow, noValue(), nullptr,
 9032             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 9033 
 9034         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9035 
 9036         unsigned numberOfArgumentsToSkip = data-&gt;offset;
 9037         LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 9038         LValue targetStart = addressFor(data-&gt;machineStart).value();
 9039 
 9040         LBasicBlock undefinedLoop = m_out.newBlock();
 9041         LBasicBlock mainLoopEntry = m_out.newBlock();
 9042         LBasicBlock mainLoop = m_out.newBlock();
 9043         LBasicBlock continuation = m_out.newBlock();
 9044 
 9045         LValue lengthAsPtr = m_out.zeroExtPtr(length);
 9046         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 9047         ValueFromBlock loopBound = m_out.anchor(loopBoundValue);
 9048         m_out.branch(
 9049             m_out.above(loopBoundValue, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 9050 
 9051         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, mainLoopEntry);
 9052         LValue previousIndex = m_out.phi(pointerType(), loopBound);
 9053         LValue currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 9054         m_out.store64(
 9055             m_out.constInt64(JSValue::encode(jsUndefined())),
 9056             m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 9057         ValueFromBlock nextIndex = m_out.anchor(currentIndex);
 9058         m_out.addIncomingToPhi(previousIndex, nextIndex);
 9059         m_out.branch(
 9060             m_out.above(currentIndex, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 9061 
 9062         m_out.appendTo(mainLoopEntry, mainLoop);
 9063         loopBound = m_out.anchor(lengthAsPtr);
 9064         m_out.branch(m_out.notNull(lengthAsPtr), unsure(mainLoop), unsure(continuation));
 9065 
 9066         m_out.appendTo(mainLoop, continuation);
 9067         previousIndex = m_out.phi(pointerType(), loopBound);
 9068         currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 9069         LValue value = m_out.load64(
 9070             m_out.baseIndex(m_heaps.variables, sourceStart, currentIndex));
 9071         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 9072         nextIndex = m_out.anchor(currentIndex);
 9073         m_out.addIncomingToPhi(previousIndex, nextIndex);
 9074         m_out.branch(m_out.isNull(currentIndex), unsure(continuation), unsure(mainLoop));
 9075 
 9076         m_out.appendTo(continuation, lastNext);
 9077     }
 9078 
 9079     LValue getSpreadLengthFromInlineCallFrame(InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip)
 9080     {
 9081         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 9082         if (argumentsLength.isKnown) {
 9083             unsigned knownLength = argumentsLength.known;
 9084             if (knownLength &gt;= numberOfArgumentsToSkip)
 9085                 knownLength = knownLength - numberOfArgumentsToSkip;
 9086             else
 9087                 knownLength = 0;
 9088             return m_out.constInt32(knownLength);
 9089         }
 9090 
 9091 
 9092         // We need to perform the same logical operation as the code above, but through dynamic operations.
 9093         if (!numberOfArgumentsToSkip)
 9094             return argumentsLength.value;
 9095 
 9096         LBasicBlock isLarger = m_out.newBlock();
 9097         LBasicBlock continuation = m_out.newBlock();
 9098 
 9099         ValueFromBlock smallerOrEqualLengthResult = m_out.anchor(m_out.constInt32(0));
 9100         m_out.branch(
 9101             m_out.above(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)), unsure(isLarger), unsure(continuation));
 9102         LBasicBlock lastNext = m_out.appendTo(isLarger, continuation);
 9103         ValueFromBlock largerLengthResult = m_out.anchor(m_out.sub(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip)));
 9104         m_out.jump(continuation);
 9105 
 9106         m_out.appendTo(continuation, lastNext);
 9107         return m_out.phi(Int32, smallerOrEqualLengthResult, largerLengthResult);
 9108     }
 9109 
 9110     void compileForwardVarargsWithSpread()
 9111     {
 9112         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 9113 
 9114         Node* arguments = m_node-&gt;child1().node();
 9115         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread);
 9116 
 9117         unsigned numberOfStaticArguments = 0;
 9118         Vector&lt;LValue, 2&gt; spreadLengths;
 9119 
 9120         auto collectArgumentCount = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 9121             if (target-&gt;op() == PhantomSpread) {
 9122                 self(target-&gt;child1().node());
 9123                 return;
 9124             }
 9125 
 9126             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9127                 BitVector* bitVector = target-&gt;bitVector();
 9128                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 9129                     if (bitVector-&gt;get(i))
 9130                         self(m_graph.varArgChild(target, i).node());
 9131                     else
 9132                         ++numberOfStaticArguments;
 9133                 }
 9134                 return;
 9135             }
 9136 
 9137             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9138                 numberOfStaticArguments += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 9139                 return;
 9140             }
 9141 
 9142             ASSERT(target-&gt;op() == PhantomCreateRest);
 9143             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 9144             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 9145             spreadLengths.append(cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 9146                 return this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 9147             }).iterator-&gt;value);
 9148         });
 9149 
 9150         collectArgumentCount(arguments);
 9151         LValue lengthIncludingThis = m_out.constInt32(1 + numberOfStaticArguments);
 9152         for (LValue length : spreadLengths)
 9153             lengthIncludingThis = m_out.add(lengthIncludingThis, length);
 9154 
 9155         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 9156         speculate(
 9157             VarargsOverflow, noValue(), nullptr,
 9158             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 9159 
 9160         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9161 
 9162         LValue targetStart = addressFor(data-&gt;machineStart).value();
 9163 
 9164         auto forwardSpread = recursableLambda([this, &amp;cachedSpreadLengths, &amp;targetStart](auto self, Node* target, LValue storeIndex) -&gt; LValue {
 9165             if (target-&gt;op() == PhantomSpread)
 9166                 return self(target-&gt;child1().node(), storeIndex);
 9167 
 9168             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9169                 BitVector* bitVector = target-&gt;bitVector();
 9170                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 9171                     if (bitVector-&gt;get(i))
 9172                         storeIndex = self(m_graph.varArgChild(target, i).node(), storeIndex);
 9173                     else {
 9174                         LValue value = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 9175                         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, storeIndex));
 9176                         storeIndex = m_out.add(m_out.constIntPtr(1), storeIndex);
 9177                     }
 9178                 }
 9179                 return storeIndex;
 9180             }
 9181 
 9182             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9183                 auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 9184                 for (unsigned i = 0; i &lt; array-&gt;length(); i++) {
 9185                     // Because forwarded values are drained as JSValue, we should not generate value
 9186                     // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 9187                     int64_t value = JSValue::encode(array-&gt;get(i));
 9188                     m_out.store64(m_out.constInt64(value), m_out.baseIndex(m_heaps.variables, targetStart, storeIndex, JSValue(), (Checked&lt;int32_t&gt;(sizeof(Register)) * i).unsafeGet()));
 9189                 }
 9190                 return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
 9191             }
 9192 
 9193             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 9194             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 9195 
 9196             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, target-&gt;numberOfArgumentsToSkip());
 9197             LValue spreadLength = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 9198 
 9199             LBasicBlock loop = m_out.newBlock();
 9200             LBasicBlock continuation = m_out.newBlock();
 9201             ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
 9202             ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 9203             ValueFromBlock startStoreIndexForEnd = m_out.anchor(storeIndex);
 9204 
 9205             m_out.branch(m_out.isZero64(spreadLength), unsure(continuation), unsure(loop));
 9206 
 9207             LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 9208             LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 9209             LValue loadIndex = m_out.phi(Int64, startLoadIndex);
 9210             LValue value = m_out.load64(
 9211                 m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 9212             m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 9213             LValue nextLoadIndex = m_out.add(m_out.constIntPtr(1), loadIndex);
 9214             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 9215             LValue nextStoreIndex = m_out.add(m_out.constIntPtr(1), loopStoreIndex);
 9216             m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextStoreIndex));
 9217             ValueFromBlock loopStoreIndexForEnd = m_out.anchor(nextStoreIndex);
 9218             m_out.branch(m_out.below(nextLoadIndex, spreadLength), unsure(loop), unsure(continuation));
 9219 
 9220             m_out.appendTo(continuation, lastNext);
 9221             return m_out.phi(Int64, startStoreIndexForEnd, loopStoreIndexForEnd);
 9222         });
 9223 
 9224         LValue storeIndex = forwardSpread(arguments, m_out.constIntPtr(0));
 9225 
 9226         LBasicBlock undefinedLoop = m_out.newBlock();
 9227         LBasicBlock continuation = m_out.newBlock();
 9228 
 9229         ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 9230         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 9231         m_out.branch(m_out.below(storeIndex, loopBoundValue),
 9232             unsure(undefinedLoop), unsure(continuation));
 9233 
 9234         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, continuation);
 9235         LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 9236         m_out.store64(
 9237             m_out.constInt64(JSValue::encode(jsUndefined())),
 9238             m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 9239         LValue nextIndex = m_out.add(loopStoreIndex, m_out.constIntPtr(1));
 9240         m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextIndex));
 9241         m_out.branch(
 9242             m_out.below(nextIndex, loopBoundValue), unsure(undefinedLoop), unsure(continuation));
 9243 
 9244         m_out.appendTo(continuation, lastNext);
 9245     }
 9246 
 9247     void compileJump()
 9248     {
 9249         m_out.jump(lowBlock(m_node-&gt;targetBlock()));
 9250     }
 9251 
 9252     void compileBranch()
 9253     {
 9254         m_out.branch(
 9255             boolify(m_node-&gt;child1()),
 9256             WeightedTarget(
 9257                 lowBlock(m_node-&gt;branchData()-&gt;taken.block),
 9258                 m_node-&gt;branchData()-&gt;taken.count),
 9259             WeightedTarget(
 9260                 lowBlock(m_node-&gt;branchData()-&gt;notTaken.block),
 9261                 m_node-&gt;branchData()-&gt;notTaken.count));
 9262     }
 9263 
 9264     void compileSwitch()
 9265     {
 9266         SwitchData* data = m_node-&gt;switchData();
 9267         switch (data-&gt;kind) {
 9268         case SwitchImm: {
 9269             Vector&lt;ValueFromBlock, 2&gt; intValues;
 9270             LBasicBlock switchOnInts = m_out.newBlock();
 9271 
 9272             LBasicBlock lastNext = m_out.appendTo(m_out.m_block, switchOnInts);
 9273 
 9274             switch (m_node-&gt;child1().useKind()) {
 9275             case Int32Use: {
 9276                 intValues.append(m_out.anchor(lowInt32(m_node-&gt;child1())));
 9277                 m_out.jump(switchOnInts);
 9278                 break;
 9279             }
 9280 
 9281             case UntypedUse: {
 9282                 LBasicBlock isInt = m_out.newBlock();
 9283                 LBasicBlock isNotInt = m_out.newBlock();
 9284                 LBasicBlock isDouble = m_out.newBlock();
 9285 
 9286                 LValue boxedValue = lowJSValue(m_node-&gt;child1());
 9287                 m_out.branch(isNotInt32(boxedValue), unsure(isNotInt), unsure(isInt));
 9288 
 9289                 LBasicBlock innerLastNext = m_out.appendTo(isInt, isNotInt);
 9290 
 9291                 intValues.append(m_out.anchor(unboxInt32(boxedValue)));
 9292                 m_out.jump(switchOnInts);
 9293 
 9294                 m_out.appendTo(isNotInt, isDouble);
 9295                 m_out.branch(
 9296                     isCellOrMisc(boxedValue, provenType(m_node-&gt;child1())),
 9297                     usually(lowBlock(data-&gt;fallThrough.block)), rarely(isDouble));
 9298 
 9299                 m_out.appendTo(isDouble, innerLastNext);
 9300                 LValue doubleValue = unboxDouble(boxedValue);
 9301                 LValue intInDouble = m_out.doubleToInt(doubleValue);
 9302                 intValues.append(m_out.anchor(intInDouble));
 9303                 m_out.branch(
 9304                     m_out.doubleEqual(m_out.intToDouble(intInDouble), doubleValue),
 9305                     unsure(switchOnInts), unsure(lowBlock(data-&gt;fallThrough.block)));
 9306                 break;
 9307             }
 9308 
 9309             default:
 9310                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9311                 break;
 9312             }
 9313 
 9314             m_out.appendTo(switchOnInts, lastNext);
 9315             buildSwitch(data, Int32, m_out.phi(Int32, intValues));
 9316             return;
 9317         }
 9318 
 9319         case SwitchChar: {
 9320             LValue stringValue;
 9321 
 9322             // FIXME: We should use something other than unsure() for the branch weight
 9323             // of the fallThrough block. The main challenge is just that we have multiple
 9324             // branches to fallThrough but a single count, so we would need to divvy it up
 9325             // among the different lowered branches.
 9326             // https://bugs.webkit.org/show_bug.cgi?id=129082
 9327 
 9328             switch (m_node-&gt;child1().useKind()) {
 9329             case StringUse: {
 9330                 stringValue = lowString(m_node-&gt;child1());
 9331                 break;
 9332             }
 9333 
 9334             case UntypedUse: {
 9335                 LValue unboxedValue = lowJSValue(m_node-&gt;child1());
 9336 
 9337                 LBasicBlock isCellCase = m_out.newBlock();
 9338                 LBasicBlock isStringCase = m_out.newBlock();
 9339 
 9340                 m_out.branch(
 9341                     isNotCell(unboxedValue, provenType(m_node-&gt;child1())),
 9342                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isCellCase));
 9343 
 9344                 LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 9345                 LValue cellValue = unboxedValue;
 9346                 m_out.branch(
 9347                     isNotString(cellValue, provenType(m_node-&gt;child1())),
 9348                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isStringCase));
 9349 
 9350                 m_out.appendTo(isStringCase, lastNext);
 9351                 stringValue = cellValue;
 9352                 break;
 9353             }
 9354 
 9355             default:
 9356                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9357                 break;
 9358             }
 9359 
 9360             LBasicBlock lengthIs1 = m_out.newBlock();
 9361             LBasicBlock needResolution = m_out.newBlock();
 9362             LBasicBlock resolved = m_out.newBlock();
 9363             LBasicBlock is8Bit = m_out.newBlock();
 9364             LBasicBlock is16Bit = m_out.newBlock();
 9365             LBasicBlock continuation = m_out.newBlock();
 9366 
 9367             ValueFromBlock fastValue = m_out.anchor(m_out.loadPtr(stringValue, m_heaps.JSString_value));
 9368             m_out.branch(
 9369                 isRopeString(stringValue, m_node-&gt;child1()),
 9370                 rarely(needResolution), usually(resolved));
 9371 
 9372             LBasicBlock lastNext = m_out.appendTo(needResolution, resolved);
 9373             ValueFromBlock slowValue = m_out.anchor(
 9374                 vmCall(pointerType(), m_out.operation(operationResolveRope), m_callFrame, stringValue));
 9375             m_out.jump(resolved);
 9376 
 9377             m_out.appendTo(resolved, lengthIs1);
 9378             LValue value = m_out.phi(pointerType(), fastValue, slowValue);
 9379             m_out.branch(
 9380                 m_out.notEqual(
 9381                     m_out.load32NonNegative(value, m_heaps.StringImpl_length),
 9382                     m_out.int32One),
 9383                 unsure(lowBlock(data-&gt;fallThrough.block)), unsure(lengthIs1));
 9384 
 9385             m_out.appendTo(lengthIs1, is8Bit);
 9386             LValue characterData = m_out.loadPtr(value, m_heaps.StringImpl_data);
 9387             m_out.branch(
 9388                 m_out.testNonZero32(
 9389                     m_out.load32(value, m_heaps.StringImpl_hashAndFlags),
 9390                     m_out.constInt32(StringImpl::flagIs8Bit())),
 9391                 unsure(is8Bit), unsure(is16Bit));
 9392 
 9393             Vector&lt;ValueFromBlock, 2&gt; characters;
 9394             m_out.appendTo(is8Bit, is16Bit);
 9395             characters.append(m_out.anchor(m_out.load8ZeroExt32(characterData, m_heaps.characters8[0])));
 9396             m_out.jump(continuation);
 9397 
 9398             m_out.appendTo(is16Bit, continuation);
 9399             characters.append(m_out.anchor(m_out.load16ZeroExt32(characterData, m_heaps.characters16[0])));
 9400             m_out.jump(continuation);
 9401 
 9402             m_out.appendTo(continuation, lastNext);
 9403             buildSwitch(data, Int32, m_out.phi(Int32, characters));
 9404             return;
 9405         }
 9406 
 9407         case SwitchString: {
 9408             switch (m_node-&gt;child1().useKind()) {
 9409             case StringIdentUse: {
 9410                 LValue stringImpl = lowStringIdent(m_node-&gt;child1());
 9411 
 9412                 Vector&lt;SwitchCase&gt; cases;
 9413                 for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
 9414                     LValue value = m_out.constIntPtr(data-&gt;cases[i].value.stringImpl());
 9415                     LBasicBlock block = lowBlock(data-&gt;cases[i].target.block);
 9416                     Weight weight = Weight(data-&gt;cases[i].target.count);
 9417                     cases.append(SwitchCase(value, block, weight));
 9418                 }
 9419 
 9420                 m_out.switchInstruction(
 9421                     stringImpl, cases, lowBlock(data-&gt;fallThrough.block),
 9422                     Weight(data-&gt;fallThrough.count));
 9423                 return;
 9424             }
 9425 
 9426             case StringUse: {
 9427                 switchString(data, lowString(m_node-&gt;child1()), m_node-&gt;child1());
 9428                 return;
 9429             }
 9430 
 9431             case UntypedUse: {
 9432                 LValue value = lowJSValue(m_node-&gt;child1());
 9433 
 9434                 LBasicBlock isCellBlock = m_out.newBlock();
 9435                 LBasicBlock isStringBlock = m_out.newBlock();
 9436 
 9437                 m_out.branch(
 9438                     isCell(value, provenType(m_node-&gt;child1())),
 9439                     unsure(isCellBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
 9440 
 9441                 LBasicBlock lastNext = m_out.appendTo(isCellBlock, isStringBlock);
 9442 
 9443                 m_out.branch(
 9444                     isString(value, provenType(m_node-&gt;child1())),
 9445                     unsure(isStringBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
 9446 
 9447                 m_out.appendTo(isStringBlock, lastNext);
 9448 
 9449                 switchString(data, value, m_node-&gt;child1());
 9450                 return;
 9451             }
 9452 
 9453             default:
 9454                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9455                 return;
 9456             }
 9457             return;
 9458         }
 9459 
 9460         case SwitchCell: {
 9461             LValue cell;
 9462             switch (m_node-&gt;child1().useKind()) {
 9463             case CellUse: {
 9464                 cell = lowCell(m_node-&gt;child1());
 9465                 break;
 9466             }
 9467 
 9468             case UntypedUse: {
 9469                 LValue value = lowJSValue(m_node-&gt;child1());
 9470                 LBasicBlock cellCase = m_out.newBlock();
 9471                 m_out.branch(
 9472                     isCell(value, provenType(m_node-&gt;child1())),
 9473                     unsure(cellCase), unsure(lowBlock(data-&gt;fallThrough.block)));
 9474                 m_out.appendTo(cellCase);
 9475                 cell = value;
 9476                 break;
 9477             }
 9478 
 9479             default:
 9480                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9481                 return;
 9482             }
 9483 
 9484             buildSwitch(m_node-&gt;switchData(), pointerType(), cell);
 9485             return;
 9486         } }
 9487 
 9488         DFG_CRASH(m_graph, m_node, &quot;Bad switch kind&quot;);
 9489     }
 9490 
 9491     void compileEntrySwitch()
 9492     {
 9493         Vector&lt;LBasicBlock&gt; successors;
 9494         for (DFG::BasicBlock* successor : m_node-&gt;entrySwitchData()-&gt;cases)
 9495             successors.append(lowBlock(successor));
 9496         m_out.entrySwitch(successors);
 9497     }
 9498 
 9499     void compileReturn()
 9500     {
 9501         m_out.ret(lowJSValue(m_node-&gt;child1()));
 9502     }
 9503 
 9504     void compileForceOSRExit()
 9505     {
 9506         terminate(InadequateCoverage);
 9507     }
 9508 
 9509     void compileCPUIntrinsic()
 9510     {
 9511 #if CPU(X86_64)
 9512         Intrinsic intrinsic = m_node-&gt;intrinsic();
 9513         switch (intrinsic) {
 9514         case CPUMfenceIntrinsic:
 9515         case CPUCpuidIntrinsic:
 9516         case CPUPauseIntrinsic: {
 9517             PatchpointValue* patchpoint = m_out.patchpoint(Void);
 9518             patchpoint-&gt;effects = Effects::forCall();
 9519             if (intrinsic == CPUCpuidIntrinsic)
 9520                 patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::ebx, X86Registers::ecx, X86Registers::edx });
 9521 
 9522             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9523                 switch (intrinsic) {
 9524                 case CPUMfenceIntrinsic:
 9525                     jit.mfence();
 9526                     break;
 9527                 case CPUCpuidIntrinsic:
 9528                     jit.cpuid();
 9529                     break;
 9530                 case CPUPauseIntrinsic:
 9531                     jit.pause();
 9532                     break;
 9533                 default:
 9534                     RELEASE_ASSERT_NOT_REACHED();
 9535                 }
 9536             });
 9537             setJSValue(m_out.constInt64(JSValue::encode(jsUndefined())));
 9538             break;
 9539         }
 9540         case CPURdtscIntrinsic: {
 9541             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9542             patchpoint-&gt;effects = Effects::forCall();
 9543             patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
 9544             // The low 32-bits of rdtsc go into rax.
 9545             patchpoint-&gt;resultConstraints = { ValueRep::reg(X86Registers::eax) };
 9546             patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 9547                 jit.rdtsc();
 9548             });
 9549             setJSValue(boxInt32(patchpoint));
 9550             break;
 9551         }
 9552         default:
 9553             RELEASE_ASSERT_NOT_REACHED();
 9554 
 9555         }
 9556 #endif
 9557     }
 9558 
 9559     void compileThrow()
 9560     {
 9561         LValue error = lowJSValue(m_node-&gt;child1());
 9562         vmCall(Void, m_out.operation(operationThrowDFG), m_callFrame, error);
 9563         // vmCall() does an exception check so we should never reach this.
 9564         m_out.unreachable();
 9565     }
 9566 
 9567     void compileThrowStaticError()
 9568     {
 9569         LValue errorMessage = lowString(m_node-&gt;child1());
 9570         LValue errorType = m_out.constInt32(m_node-&gt;errorType());
 9571         vmCall(Void, m_out.operation(operationThrowStaticError), m_callFrame, errorMessage, errorType);
 9572         // vmCall() does an exception check so we should never reach this.
 9573         m_out.unreachable();
 9574     }
 9575 
 9576     void compileInvalidationPoint()
 9577     {
 9578         if (verboseCompilationEnabled())
 9579             dataLog(&quot;    Invalidation point with availability: &quot;, availabilityMap(), &quot;\n&quot;);
 9580 
 9581         DFG_ASSERT(m_graph, m_node, m_origin.exitOK);
 9582 
 9583         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 9584         OSRExitDescriptor* descriptor = appendOSRExitDescriptor(noValue(), nullptr);
 9585         NodeOrigin origin = m_origin;
 9586         patchpoint-&gt;appendColdAnys(buildExitArguments(descriptor, origin.forExit, noValue()));
 9587 
 9588         State* state = &amp;m_ftlState;
 9589 
 9590         patchpoint-&gt;setGenerator(
 9591             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
 9592                 // The MacroAssembler knows more about this than B3 does. The watchpointLabel() method
 9593                 // will ensure that this is followed by a nop shadow but only when this is actually
 9594                 // necessary.
 9595                 CCallHelpers::Label label = jit.watchpointLabel();
 9596 
 9597                 RefPtr&lt;OSRExitHandle&gt; handle = descriptor-&gt;emitOSRExitLater(
 9598                     *state, UncountableInvalidation, origin, params);
 9599 
 9600                 RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode.get();
 9601 
 9602                 jit.addLinkTask(
 9603                     [=] (LinkBuffer&amp; linkBuffer) {
 9604                         JumpReplacement jumpReplacement(
 9605                             linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(label),
 9606                             linkBuffer.locationOf&lt;OSRExitPtrTag&gt;(handle-&gt;label));
 9607                         jitCode-&gt;common.jumpReplacements.append(jumpReplacement);
 9608                     });
 9609             });
 9610 
 9611         // Set some obvious things.
 9612         patchpoint-&gt;effects.terminal = false;
 9613         patchpoint-&gt;effects.writesLocalState = false;
 9614         patchpoint-&gt;effects.readsLocalState = false;
 9615 
 9616         // This is how we tell B3 about the possibility of jump replacement.
 9617         patchpoint-&gt;effects.exitsSideways = true;
 9618 
 9619         // It&#39;s not possible for some prior branch to determine the safety of this operation. It&#39;s always
 9620         // fine to execute this on some path that wouldn&#39;t have originally executed it before
 9621         // optimization.
 9622         patchpoint-&gt;effects.controlDependent = false;
 9623 
 9624         // If this falls through then it won&#39;t write anything.
 9625         patchpoint-&gt;effects.writes = HeapRange();
 9626 
 9627         // When this abruptly terminates, it could read any heap location.
 9628         patchpoint-&gt;effects.reads = HeapRange::top();
 9629     }
 9630 
 9631     void compileIsEmpty()
 9632     {
 9633         setBoolean(m_out.isZero64(lowJSValue(m_node-&gt;child1())));
 9634     }
 9635 
 9636     void compileIsUndefined()
 9637     {
 9638         setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualUndefined));
 9639     }
 9640 
 9641     void compileIsUndefinedOrNull()
 9642     {
 9643         setBoolean(isOther(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9644     }
 9645 
 9646     void compileIsBoolean()
 9647     {
 9648         setBoolean(isBoolean(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9649     }
 9650 
 9651     void compileIsNumber()
 9652     {
 9653         setBoolean(isNumber(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
 9654     }
 9655 
 9656     void compileNumberIsInteger()
 9657     {
 9658         LBasicBlock notInt32 = m_out.newBlock();
 9659         LBasicBlock doubleCase = m_out.newBlock();
 9660         LBasicBlock doubleNotNanOrInf = m_out.newBlock();
 9661         LBasicBlock continuation = m_out.newBlock();
 9662 
 9663         LValue input = lowJSValue(m_node-&gt;child1());
 9664 
 9665         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
 9666         m_out.branch(
 9667             isInt32(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notInt32));
 9668 
 9669         LBasicBlock lastNext = m_out.appendTo(notInt32, doubleCase);
 9670         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
 9671         m_out.branch(
 9672             isNotNumber(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(doubleCase));
 9673 
 9674         m_out.appendTo(doubleCase, doubleNotNanOrInf);
 9675         LValue doubleAsInt;
 9676         LValue asDouble = unboxDouble(input, &amp;doubleAsInt);
 9677         LValue expBits = m_out.bitAnd(m_out.lShr(doubleAsInt, m_out.constInt32(52)), m_out.constInt64(0x7ff));
 9678         m_out.branch(
 9679             m_out.equal(expBits, m_out.constInt64(0x7ff)),
 9680             unsure(continuation), unsure(doubleNotNanOrInf));
 9681 
 9682         m_out.appendTo(doubleNotNanOrInf, continuation);
 9683         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 9684         patchpoint-&gt;appendSomeRegister(asDouble);
 9685         patchpoint-&gt;numFPScratchRegisters = 1;
 9686         patchpoint-&gt;effects = Effects::none();
 9687         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9688             GPRReg result = params[0].gpr();
 9689             FPRReg input = params[1].fpr();
 9690             FPRReg temp = params.fpScratch(0);
 9691             jit.roundTowardZeroDouble(input, temp);
 9692             jit.compareDouble(MacroAssembler::DoubleEqual, input, temp, result);
 9693         });
 9694         ValueFromBlock patchpointResult = m_out.anchor(patchpoint);
 9695         m_out.jump(continuation);
 9696 
 9697         m_out.appendTo(continuation, lastNext);
 9698         setBoolean(m_out.phi(Int32, trueResult, falseResult, patchpointResult));
 9699     }
 9700 
 9701     void compileIsCellWithType()
 9702     {
 9703         if (m_node-&gt;child1().useKind() == UntypedUse) {
 9704             LValue value = lowJSValue(m_node-&gt;child1());
 9705 
 9706             LBasicBlock isCellCase = m_out.newBlock();
 9707             LBasicBlock continuation = m_out.newBlock();
 9708 
 9709             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 9710             m_out.branch(
 9711                 isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 9712 
 9713             LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
 9714             ValueFromBlock cellResult = m_out.anchor(isCellWithType(value, m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
 9715             m_out.jump(continuation);
 9716 
 9717             m_out.appendTo(continuation, lastNext);
 9718             setBoolean(m_out.phi(Int32, notCellResult, cellResult));
 9719         } else {
 9720             ASSERT(m_node-&gt;child1().useKind() == CellUse);
 9721             setBoolean(isCellWithType(lowCell(m_node-&gt;child1()), m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
 9722         }
 9723     }
 9724 
 9725     void compileIsObject()
 9726     {
 9727         LValue value = lowJSValue(m_node-&gt;child1());
 9728 
 9729         LBasicBlock isCellCase = m_out.newBlock();
 9730         LBasicBlock continuation = m_out.newBlock();
 9731 
 9732         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 9733         m_out.branch(
 9734             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 9735 
 9736         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
 9737         ValueFromBlock cellResult = m_out.anchor(isObject(value, provenType(m_node-&gt;child1())));
 9738         m_out.jump(continuation);
 9739 
 9740         m_out.appendTo(continuation, lastNext);
 9741         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
 9742     }
 9743 
 9744     LValue wangsInt64Hash(LValue input)
 9745     {
 9746         // key += ~(key &lt;&lt; 32);
 9747         LValue key = input;
 9748         LValue temp = key;
 9749         temp = m_out.shl(temp, m_out.constInt32(32));
 9750         temp = m_out.bitNot(temp);
 9751         key = m_out.add(key, temp);
 9752         // key ^= (key &gt;&gt; 22);
 9753         temp = key;
 9754         temp = m_out.lShr(temp, m_out.constInt32(22));
 9755         key = m_out.bitXor(key, temp);
 9756         // key += ~(key &lt;&lt; 13);
 9757         temp = key;
 9758         temp = m_out.shl(temp, m_out.constInt32(13));
 9759         temp = m_out.bitNot(temp);
 9760         key = m_out.add(key, temp);
 9761         // key ^= (key &gt;&gt; 8);
 9762         temp = key;
 9763         temp = m_out.lShr(temp, m_out.constInt32(8));
 9764         key = m_out.bitXor(key, temp);
 9765         // key += (key &lt;&lt; 3);
 9766         temp = key;
 9767         temp = m_out.shl(temp, m_out.constInt32(3));
 9768         key = m_out.add(key, temp);
 9769         // key ^= (key &gt;&gt; 15);
 9770         temp = key;
 9771         temp = m_out.lShr(temp, m_out.constInt32(15));
 9772         key = m_out.bitXor(key, temp);
 9773         // key += ~(key &lt;&lt; 27);
 9774         temp = key;
 9775         temp = m_out.shl(temp, m_out.constInt32(27));
 9776         temp = m_out.bitNot(temp);
 9777         key = m_out.add(key, temp);
 9778         // key ^= (key &gt;&gt; 31);
 9779         temp = key;
 9780         temp = m_out.lShr(temp, m_out.constInt32(31));
 9781         key = m_out.bitXor(key, temp);
 9782         key = m_out.castToInt32(key);
 9783 
 9784         return key;
 9785     }
 9786 
 9787     LValue mapHashString(LValue string, Edge&amp; edge)
 9788     {
 9789         LBasicBlock nonEmptyStringCase = m_out.newBlock();
 9790         LBasicBlock slowCase = m_out.newBlock();
 9791         LBasicBlock continuation = m_out.newBlock();
 9792 
 9793         m_out.branch(isRopeString(string, edge), rarely(slowCase), usually(nonEmptyStringCase));
 9794 
 9795         LBasicBlock lastNext = m_out.appendTo(nonEmptyStringCase, slowCase);
 9796         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
 9797         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
 9798         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
 9799         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
 9800             unsure(slowCase), unsure(continuation));
 9801 
 9802         m_out.appendTo(slowCase, continuation);
 9803         ValueFromBlock slowResult = m_out.anchor(
 9804             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, string));
 9805         m_out.jump(continuation);
 9806 
 9807         m_out.appendTo(continuation, lastNext);
 9808         return m_out.phi(Int32, slowResult, nonEmptyStringHashResult);
 9809     }
 9810 
 9811     void compileMapHash()
 9812     {
 9813         switch (m_node-&gt;child1().useKind()) {
 9814         case BooleanUse:
 9815         case Int32Use:
 9816         case SymbolUse:
 9817         case ObjectUse: {
 9818             LValue key = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 9819             speculate(m_node-&gt;child1());
 9820             setInt32(wangsInt64Hash(key));
 9821             return;
 9822         }
 9823 
 9824         case CellUse: {
 9825             LBasicBlock isString = m_out.newBlock();
 9826             LBasicBlock notString = m_out.newBlock();
 9827             LBasicBlock continuation = m_out.newBlock();
 9828 
 9829             LValue value = lowCell(m_node-&gt;child1());
 9830             LValue isStringValue = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
 9831             m_out.branch(
 9832                 isStringValue, unsure(isString), unsure(notString));
 9833 
 9834             LBasicBlock lastNext = m_out.appendTo(isString, notString);
 9835             ValueFromBlock stringResult = m_out.anchor(mapHashString(value, m_node-&gt;child1()));
 9836             m_out.jump(continuation);
 9837 
 9838             m_out.appendTo(notString, continuation);
 9839             ValueFromBlock notStringResult = m_out.anchor(wangsInt64Hash(value));
 9840             m_out.jump(continuation);
 9841 
 9842             m_out.appendTo(continuation, lastNext);
 9843             setInt32(m_out.phi(Int32, stringResult, notStringResult));
 9844             return;
 9845         }
 9846 
 9847         case StringUse: {
 9848             LValue string = lowString(m_node-&gt;child1());
 9849             setInt32(mapHashString(string, m_node-&gt;child1()));
 9850             return;
 9851         }
 9852 
 9853         default:
 9854             RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9855             break;
 9856         }
 9857 
 9858         LValue value = lowJSValue(m_node-&gt;child1());
 9859 
 9860         LBasicBlock isCellCase = m_out.newBlock();
 9861         LBasicBlock slowCase = m_out.newBlock();
 9862         LBasicBlock straightHash = m_out.newBlock();
 9863         LBasicBlock isStringCase = m_out.newBlock();
 9864         LBasicBlock nonEmptyStringCase = m_out.newBlock();
 9865         LBasicBlock continuation = m_out.newBlock();
 9866 
 9867         m_out.branch(
 9868             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(straightHash));
 9869 
 9870         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 9871         LValue isString = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
 9872         m_out.branch(
 9873             isString, unsure(isStringCase), unsure(straightHash));
 9874 
 9875         m_out.appendTo(isStringCase, nonEmptyStringCase);
 9876         m_out.branch(isRopeString(value, m_node-&gt;child1()), rarely(slowCase), usually(nonEmptyStringCase));
 9877 
 9878         m_out.appendTo(nonEmptyStringCase, straightHash);
 9879         LValue stringImpl = m_out.loadPtr(value, m_heaps.JSString_value);
 9880         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
 9881         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
 9882         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
 9883             unsure(slowCase), unsure(continuation));
 9884 
 9885         m_out.appendTo(straightHash, slowCase);
 9886         ValueFromBlock fastResult = m_out.anchor(wangsInt64Hash(value));
 9887         m_out.jump(continuation);
 9888 
 9889         m_out.appendTo(slowCase, continuation);
 9890         ValueFromBlock slowResult = m_out.anchor(
 9891             vmCall(Int32, m_out.operation(operationMapHash), m_callFrame, value));
 9892         m_out.jump(continuation);
 9893 
 9894         m_out.appendTo(continuation, lastNext);
 9895         setInt32(m_out.phi(Int32, fastResult, slowResult, nonEmptyStringHashResult));
 9896     }
 9897 
 9898     void compileNormalizeMapKey()
 9899     {
 9900         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
 9901 
 9902         LBasicBlock isNumberCase = m_out.newBlock();
 9903         LBasicBlock notInt32NumberCase = m_out.newBlock();
 9904         LBasicBlock notNaNCase = m_out.newBlock();
 9905         LBasicBlock convertibleCase = m_out.newBlock();
 9906         LBasicBlock continuation = m_out.newBlock();
 9907 
 9908         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isNumberCase);
 9909 
 9910         LValue key = lowJSValue(m_node-&gt;child1());
 9911         ValueFromBlock fastResult = m_out.anchor(key);
 9912         m_out.branch(isNotNumber(key), unsure(continuation), unsure(isNumberCase));
 9913 
 9914         m_out.appendTo(isNumberCase, notInt32NumberCase);
 9915         m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
 9916 
 9917         m_out.appendTo(notInt32NumberCase, notNaNCase);
 9918         LValue doubleValue = unboxDouble(key);
 9919         ValueFromBlock normalizedNaNResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsNaN())));
 9920         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
 9921 
 9922         m_out.appendTo(notNaNCase, convertibleCase);
 9923         LValue integerValue = m_out.doubleToInt(doubleValue);
 9924         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
 9925         ValueFromBlock doubleResult = m_out.anchor(key);
 9926         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
 9927 
 9928         m_out.appendTo(convertibleCase, continuation);
 9929         ValueFromBlock boxedIntResult = m_out.anchor(boxInt32(integerValue));
 9930         m_out.jump(continuation);
 9931 
 9932         m_out.appendTo(continuation, lastNext);
 9933         setJSValue(m_out.phi(Int64, fastResult, normalizedNaNResult, doubleResult, boxedIntResult));
 9934     }
 9935 
 9936     void compileGetMapBucket()
 9937     {
 9938         LBasicBlock loopStart = m_out.newBlock();
 9939         LBasicBlock loopAround = m_out.newBlock();
 9940         LBasicBlock slowPath = m_out.newBlock();
 9941         LBasicBlock notPresentInTable = m_out.newBlock();
 9942         LBasicBlock notEmptyValue = m_out.newBlock();
 9943         LBasicBlock notDeletedValue = m_out.newBlock();
 9944         LBasicBlock continuation = m_out.newBlock();
 9945 
 9946         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
 9947 
 9948         LValue map;
 9949         if (m_node-&gt;child1().useKind() == MapObjectUse)
 9950             map = lowMapObject(m_node-&gt;child1());
 9951         else if (m_node-&gt;child1().useKind() == SetObjectUse)
 9952             map = lowSetObject(m_node-&gt;child1());
 9953         else
 9954             RELEASE_ASSERT_NOT_REACHED();
 9955 
 9956         LValue key = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
 9957         if (m_node-&gt;child2().useKind() != UntypedUse)
 9958             speculate(m_node-&gt;child2());
 9959 
 9960         LValue hash = lowInt32(m_node-&gt;child3());
 9961 
 9962         LValue buffer = m_out.loadPtr(map, m_heaps.HashMapImpl_buffer);
 9963         LValue mask = m_out.sub(m_out.load32(map, m_heaps.HashMapImpl_capacity), m_out.int32One);
 9964 
 9965         ValueFromBlock indexStart = m_out.anchor(hash);
 9966         m_out.jump(loopStart);
 9967 
 9968         m_out.appendTo(loopStart, notEmptyValue);
 9969         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
 9970         LValue index = m_out.bitAnd(mask, unmaskedIndex);
 9971         // FIXME: I think these buffers are caged?
 9972         // https://bugs.webkit.org/show_bug.cgi?id=174925
 9973         LValue hashMapBucket = m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), buffer, m_out.zeroExt(index, Int64), ScaleEight));
 9974         ValueFromBlock bucketResult = m_out.anchor(hashMapBucket);
 9975         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue()))),
 9976             unsure(notPresentInTable), unsure(notEmptyValue));
 9977 
 9978         m_out.appendTo(notEmptyValue, notDeletedValue);
 9979         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))),
 9980             unsure(loopAround), unsure(notDeletedValue));
 9981 
 9982         m_out.appendTo(notDeletedValue, loopAround);
 9983         LValue bucketKey = m_out.load64(hashMapBucket, m_heaps.HashMapBucket_key);
 9984 
 9985         // Perform Object.is()
 9986         switch (m_node-&gt;child2().useKind()) {
 9987         case BooleanUse:
 9988         case Int32Use:
 9989         case SymbolUse:
 9990         case ObjectUse: {
 9991             m_out.branch(m_out.equal(key, bucketKey),
 9992                 unsure(continuation), unsure(loopAround));
 9993             break;
 9994         }
 9995         case StringUse: {
 9996             LBasicBlock notBitEqual = m_out.newBlock();
 9997             LBasicBlock bucketKeyIsCell = m_out.newBlock();
 9998 
 9999             m_out.branch(m_out.equal(key, bucketKey),
10000                 unsure(continuation), unsure(notBitEqual));
10001 
10002             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10003             m_out.branch(isCell(bucketKey),
10004                 unsure(bucketKeyIsCell), unsure(loopAround));
10005 
10006             m_out.appendTo(bucketKeyIsCell, loopAround);
10007             m_out.branch(isString(bucketKey),
10008                 unsure(slowPath), unsure(loopAround));
10009             break;
10010         }
10011         case CellUse: {
10012             LBasicBlock notBitEqual = m_out.newBlock();
10013             LBasicBlock bucketKeyIsCell = m_out.newBlock();
10014             LBasicBlock bucketKeyIsString = m_out.newBlock();
10015 
10016             m_out.branch(m_out.equal(key, bucketKey),
10017                 unsure(continuation), unsure(notBitEqual));
10018 
10019             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10020             m_out.branch(isCell(bucketKey),
10021                 unsure(bucketKeyIsCell), unsure(loopAround));
10022 
10023             m_out.appendTo(bucketKeyIsCell, bucketKeyIsString);
10024             m_out.branch(isString(bucketKey),
10025                 unsure(bucketKeyIsString), unsure(loopAround));
10026 
10027             m_out.appendTo(bucketKeyIsString, loopAround);
10028             m_out.branch(isString(key),
10029                 unsure(slowPath), unsure(loopAround));
10030             break;
10031         }
10032         case UntypedUse: {
10033             LBasicBlock notBitEqual = m_out.newBlock();
10034             LBasicBlock bucketKeyIsCell = m_out.newBlock();
10035             LBasicBlock bothAreCells = m_out.newBlock();
10036             LBasicBlock bucketKeyIsString = m_out.newBlock();
10037 
10038             m_out.branch(m_out.equal(key, bucketKey),
10039                 unsure(continuation), unsure(notBitEqual));
10040 
10041             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10042             m_out.branch(isCell(bucketKey),
10043                 unsure(bucketKeyIsCell), unsure(loopAround));
10044 
10045             m_out.appendTo(bucketKeyIsCell, bothAreCells);
10046             m_out.branch(isCell(key),
10047                 unsure(bothAreCells), unsure(loopAround));
10048 
10049             m_out.appendTo(bothAreCells, bucketKeyIsString);
10050             m_out.branch(isString(bucketKey),
10051                 unsure(bucketKeyIsString), unsure(loopAround));
10052 
10053             m_out.appendTo(bucketKeyIsString, loopAround);
10054             m_out.branch(isString(key),
10055                 unsure(slowPath), unsure(loopAround));
10056             break;
10057         }
10058         default:
10059             RELEASE_ASSERT_NOT_REACHED();
10060         }
10061 
10062         m_out.appendTo(loopAround, slowPath);
10063         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
10064         m_out.jump(loopStart);
10065 
10066         m_out.appendTo(slowPath, notPresentInTable);
10067         ValueFromBlock slowPathResult = m_out.anchor(vmCall(pointerType(),
10068             m_out.operation(m_node-&gt;child1().useKind() == MapObjectUse ? operationJSMapFindBucket : operationJSSetFindBucket), m_callFrame, map, key, hash));
10069         m_out.jump(continuation);
10070 
10071         m_out.appendTo(notPresentInTable, continuation);
10072         ValueFromBlock notPresentResult;
10073         if (m_node-&gt;child1().useKind() == MapObjectUse)
10074             notPresentResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
10075         else if (m_node-&gt;child1().useKind() == SetObjectUse)
10076             notPresentResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
10077         else
10078             RELEASE_ASSERT_NOT_REACHED();
10079         m_out.jump(continuation);
10080 
10081         m_out.appendTo(continuation, lastNext);
10082         setJSValue(m_out.phi(pointerType(), bucketResult, slowPathResult, notPresentResult));
10083     }
10084 
10085     void compileGetMapBucketHead()
10086     {
10087         LValue map;
10088         if (m_node-&gt;child1().useKind() == MapObjectUse)
10089             map = lowMapObject(m_node-&gt;child1());
10090         else if (m_node-&gt;child1().useKind() == SetObjectUse)
10091             map = lowSetObject(m_node-&gt;child1());
10092         else
10093             RELEASE_ASSERT_NOT_REACHED();
10094 
10095         ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
10096         setJSValue(m_out.loadPtr(map, m_heaps.HashMapImpl_head));
10097     }
10098 
10099     void compileGetMapBucketNext()
10100     {
10101         LBasicBlock loopStart = m_out.newBlock();
10102         LBasicBlock continuation = m_out.newBlock();
10103         LBasicBlock noBucket = m_out.newBlock();
10104         LBasicBlock hasBucket = m_out.newBlock();
10105         LBasicBlock nextBucket = m_out.newBlock();
10106 
10107         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
10108 
10109         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
10110         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
10111         LValue mapBucketPrev = lowCell(m_node-&gt;child1());
10112         ValueFromBlock mapBucketStart = m_out.anchor(m_out.loadPtr(mapBucketPrev, m_heaps.HashMapBucket_next));
10113         m_out.jump(loopStart);
10114 
10115         m_out.appendTo(loopStart, noBucket);
10116         LValue mapBucket = m_out.phi(pointerType(), mapBucketStart);
10117         m_out.branch(m_out.isNull(mapBucket), unsure(noBucket), unsure(hasBucket));
10118 
10119         m_out.appendTo(noBucket, hasBucket);
10120         ValueFromBlock noBucketResult;
10121         if (m_node-&gt;bucketOwnerType() == BucketOwnerType::Map)
10122             noBucketResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
10123         else {
10124             ASSERT(m_node-&gt;bucketOwnerType() == BucketOwnerType::Set);
10125             noBucketResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
10126         }
10127         m_out.jump(continuation);
10128 
10129         m_out.appendTo(hasBucket, nextBucket);
10130         ValueFromBlock bucketResult = m_out.anchor(mapBucket);
10131         m_out.branch(m_out.isZero64(m_out.load64(mapBucket, m_heaps.HashMapBucket_key)), unsure(nextBucket), unsure(continuation));
10132 
10133         m_out.appendTo(nextBucket, continuation);
10134         m_out.addIncomingToPhi(mapBucket, m_out.anchor(m_out.loadPtr(mapBucket, m_heaps.HashMapBucket_next)));
10135         m_out.jump(loopStart);
10136 
10137         m_out.appendTo(continuation, lastNext);
10138         setJSValue(m_out.phi(pointerType(), noBucketResult, bucketResult));
10139     }
10140 
10141     void compileLoadValueFromMapBucket()
10142     {
10143         LValue mapBucket = lowCell(m_node-&gt;child1());
10144         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_value));
10145     }
10146 
10147     void compileExtractValueFromWeakMapGet()
10148     {
10149         LValue value = lowJSValue(m_node-&gt;child1());
10150         setJSValue(m_out.select(m_out.isZero64(value),
10151             m_out.constInt64(JSValue::encode(jsUndefined())),
10152             value));
10153     }
10154 
10155     void compileLoadKeyFromMapBucket()
10156     {
10157         LValue mapBucket = lowCell(m_node-&gt;child1());
10158         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_key));
10159     }
10160 
10161     void compileSetAdd()
10162     {
10163         LValue set = lowSetObject(m_node-&gt;child1());
10164         LValue key = lowJSValue(m_node-&gt;child2());
10165         LValue hash = lowInt32(m_node-&gt;child3());
10166 
10167         setJSValue(vmCall(pointerType(), m_out.operation(operationSetAdd), m_callFrame, set, key, hash));
10168     }
10169 
10170     void compileMapSet()
10171     {
10172         LValue map = lowMapObject(m_graph.varArgChild(m_node, 0));
10173         LValue key = lowJSValue(m_graph.varArgChild(m_node, 1));
10174         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
10175         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
10176 
10177         setJSValue(vmCall(pointerType(), m_out.operation(operationMapSet), m_callFrame, map, key, value, hash));
10178     }
10179 
10180     void compileWeakMapGet()
10181     {
10182         LBasicBlock loopStart = m_out.newBlock();
10183         LBasicBlock loopAround = m_out.newBlock();
10184         LBasicBlock notEqualValue = m_out.newBlock();
10185         LBasicBlock continuation = m_out.newBlock();
10186 
10187         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
10188 
10189         LValue weakMap;
10190         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
10191             weakMap = lowWeakMapObject(m_node-&gt;child1());
10192         else if (m_node-&gt;child1().useKind() == WeakSetObjectUse)
10193             weakMap = lowWeakSetObject(m_node-&gt;child1());
10194         else
10195             RELEASE_ASSERT_NOT_REACHED();
10196         LValue key = lowObject(m_node-&gt;child2());
10197         LValue hash = lowInt32(m_node-&gt;child3());
10198 
10199         LValue buffer = m_out.loadPtr(weakMap, m_heaps.WeakMapImpl_buffer);
10200         LValue mask = m_out.sub(m_out.load32(weakMap, m_heaps.WeakMapImpl_capacity), m_out.int32One);
10201 
10202         ValueFromBlock indexStart = m_out.anchor(hash);
10203         m_out.jump(loopStart);
10204 
10205         m_out.appendTo(loopStart, notEqualValue);
10206         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
10207         LValue index = m_out.bitAnd(mask, unmaskedIndex);
10208 
10209         LValue bucket;
10210 
10211         if (m_node-&gt;child1().useKind() == WeakMapObjectUse) {
10212             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)), &quot;Should be a power of 2&quot;);
10213             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)))));
10214         } else {
10215             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)), &quot;Should be a power of 2&quot;);
10216             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)))));
10217         }
10218 
10219         LValue bucketKey = m_out.load64(bucket, m_heaps.WeakMapBucket_key);
10220         m_out.branch(m_out.equal(key, bucketKey), unsure(continuation), unsure(notEqualValue));
10221 
10222         m_out.appendTo(notEqualValue, loopAround);
10223         m_out.branch(m_out.isNull(bucketKey), unsure(continuation), unsure(loopAround));
10224 
10225         m_out.appendTo(loopAround, continuation);
10226         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
10227         m_out.jump(loopStart);
10228 
10229         m_out.appendTo(continuation, lastNext);
10230         LValue result;
10231         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
10232             result = m_out.load64(bucket, m_heaps.WeakMapBucket_value);
10233         else
10234             result = bucketKey;
10235         setJSValue(result);
10236     }
10237 
10238     void compileWeakSetAdd()
10239     {
10240         LValue set = lowWeakSetObject(m_node-&gt;child1());
10241         LValue key = lowObject(m_node-&gt;child2());
10242         LValue hash = lowInt32(m_node-&gt;child3());
10243 
10244         vmCall(Void, m_out.operation(operationWeakSetAdd), m_callFrame, set, key, hash);
10245     }
10246 
10247     void compileWeakMapSet()
10248     {
10249         LValue map = lowWeakMapObject(m_graph.varArgChild(m_node, 0));
10250         LValue key = lowObject(m_graph.varArgChild(m_node, 1));
10251         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
10252         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
10253 
10254         vmCall(Void, m_out.operation(operationWeakMapSet), m_callFrame, map, key, value, hash);
10255     }
10256 
10257     void compileIsObjectOrNull()
10258     {
10259         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10260 
10261         Edge child = m_node-&gt;child1();
10262         LValue value = lowJSValue(child);
10263 
10264         LBasicBlock cellCase = m_out.newBlock();
10265         LBasicBlock notFunctionCase = m_out.newBlock();
10266         LBasicBlock objectCase = m_out.newBlock();
10267         LBasicBlock slowPath = m_out.newBlock();
10268         LBasicBlock notCellCase = m_out.newBlock();
10269         LBasicBlock continuation = m_out.newBlock();
10270 
10271         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
10272 
10273         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10274         ValueFromBlock isFunctionResult = m_out.anchor(m_out.booleanFalse);
10275         m_out.branch(
10276             isFunction(value, provenType(child)),
10277             unsure(continuation), unsure(notFunctionCase));
10278 
10279         m_out.appendTo(notFunctionCase, objectCase);
10280         ValueFromBlock notObjectResult = m_out.anchor(m_out.booleanFalse);
10281         m_out.branch(
10282             isObject(value, provenType(child)),
10283             unsure(objectCase), unsure(continuation));
10284 
10285         m_out.appendTo(objectCase, slowPath);
10286         ValueFromBlock objectResult = m_out.anchor(m_out.booleanTrue);
10287         m_out.branch(
10288             isExoticForTypeof(value, provenType(child)),
10289             rarely(slowPath), usually(continuation));
10290 
10291         m_out.appendTo(slowPath, notCellCase);
10292         VM&amp; vm = this-&gt;vm();
10293         LValue slowResultValue = lazySlowPath(
10294             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10295                 return createLazyCallGenerator(vm,
10296                     operationObjectIsObject, locations[0].directGPR(),
10297                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
10298             }, value);
10299         ValueFromBlock slowResult = m_out.anchor(m_out.notZero64(slowResultValue));
10300         m_out.jump(continuation);
10301 
10302         m_out.appendTo(notCellCase, continuation);
10303         LValue notCellResultValue = m_out.equal(value, m_out.constInt64(JSValue::encode(jsNull())));
10304         ValueFromBlock notCellResult = m_out.anchor(notCellResultValue);
10305         m_out.jump(continuation);
10306 
10307         m_out.appendTo(continuation, lastNext);
10308         LValue result = m_out.phi(
10309             Int32,
10310             isFunctionResult, notObjectResult, objectResult, slowResult, notCellResult);
10311         setBoolean(result);
10312     }
10313 
10314     void compileIsFunction()
10315     {
10316         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10317 
10318         Edge child = m_node-&gt;child1();
10319         LValue value = lowJSValue(child);
10320 
10321         LBasicBlock cellCase = m_out.newBlock();
10322         LBasicBlock notFunctionCase = m_out.newBlock();
10323         LBasicBlock slowPath = m_out.newBlock();
10324         LBasicBlock continuation = m_out.newBlock();
10325 
10326         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10327         m_out.branch(
10328             isCell(value, provenType(child)), unsure(cellCase), unsure(continuation));
10329 
10330         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10331         ValueFromBlock functionResult = m_out.anchor(m_out.booleanTrue);
10332         m_out.branch(
10333             isFunction(value, provenType(child)),
10334             unsure(continuation), unsure(notFunctionCase));
10335 
10336         m_out.appendTo(notFunctionCase, slowPath);
10337         ValueFromBlock objectResult = m_out.anchor(m_out.booleanFalse);
10338         m_out.branch(
10339             isExoticForTypeof(value, provenType(child)),
10340             rarely(slowPath), usually(continuation));
10341 
10342         m_out.appendTo(slowPath, continuation);
10343         VM&amp; vm = this-&gt;vm();
10344         LValue slowResultValue = lazySlowPath(
10345             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10346                 return createLazyCallGenerator(vm,
10347                     operationObjectIsFunction, locations[0].directGPR(),
10348                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
10349             }, value);
10350         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(slowResultValue));
10351         m_out.jump(continuation);
10352 
10353         m_out.appendTo(continuation, lastNext);
10354         LValue result = m_out.phi(
10355             Int32, notCellResult, functionResult, objectResult, slowResult);
10356         setBoolean(result);
10357     }
10358 
10359     void compileIsTypedArrayView()
10360     {
10361         LValue value = lowJSValue(m_node-&gt;child1());
10362 
10363         LBasicBlock isCellCase = m_out.newBlock();
10364         LBasicBlock continuation = m_out.newBlock();
10365 
10366         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10367         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
10368 
10369         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
10370         ValueFromBlock cellResult = m_out.anchor(isTypedArrayView(value, provenType(m_node-&gt;child1())));
10371         m_out.jump(continuation);
10372 
10373         m_out.appendTo(continuation, lastNext);
10374         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
10375     }
10376 
10377     void compileTypeOf()
10378     {
10379         Edge child = m_node-&gt;child1();
10380         LValue value = lowJSValue(child);
10381 
10382         LBasicBlock continuation = m_out.newBlock();
10383         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
10384 
10385         Vector&lt;ValueFromBlock&gt; results;
10386 
10387         buildTypeOf(
10388             child, value,
10389             [&amp;] (TypeofType type) {
10390                 results.append(m_out.anchor(weakPointer(vm().smallStrings.typeString(type))));
10391                 m_out.jump(continuation);
10392             });
10393 
10394         m_out.appendTo(continuation, lastNext);
10395         setJSValue(m_out.phi(Int64, results));
10396     }
10397 
10398     void compileInByVal()
10399     {
10400         setJSValue(vmCall(Int64, m_out.operation(operationInByVal), m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));
10401     }
10402 
10403     void compileInById()
10404     {
10405         Node* node = m_node;
10406         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
10407         LValue base = lowCell(m_node-&gt;child1());
10408 
10409         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10410         patchpoint-&gt;appendSomeRegister(base);
10411         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10412         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10413 
10414         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10415 
10416         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10417             preparePatchpointForExceptions(patchpoint);
10418 
10419         State* state = &amp;m_ftlState;
10420         patchpoint-&gt;setGenerator(
10421             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10422                 AllowMacroScratchRegisterUsage allowScratch(jit);
10423 
10424                 CallSiteIndex callSiteIndex =
10425                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
10426 
10427                 // This is the direct exit target for operation calls.
10428                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
10429                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
10430 
10431                 auto generator = Box&lt;JITInByIdGenerator&gt;::create(
10432                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
10433                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
10434                     JSValueRegs(params[0].gpr()));
10435 
10436                 generator-&gt;generateFastPath(jit);
10437                 CCallHelpers::Label done = jit.label();
10438 
10439                 params.addLatePath(
10440                     [=] (CCallHelpers&amp; jit) {
10441                         AllowMacroScratchRegisterUsage allowScratch(jit);
10442 
10443                         generator-&gt;slowPathJump().link(&amp;jit);
10444                         CCallHelpers::Label slowPathBegin = jit.label();
10445                         CCallHelpers::Call slowPathCall = callOperation(
10446                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
10447                             exceptions.get(), operationInByIdOptimize, params[0].gpr(),
10448                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
10449                             CCallHelpers::TrustedImmPtr(uid)).call();
10450                         jit.jump().linkTo(done, &amp;jit);
10451 
10452                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
10453 
10454                         jit.addLinkTask(
10455                             [=] (LinkBuffer&amp; linkBuffer) {
10456                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10457                             });
10458                     });
10459             });
10460 
10461         setJSValue(patchpoint);
10462     }
10463 
10464     void compileHasOwnProperty()
10465     {
10466         LBasicBlock slowCase = m_out.newBlock();
10467         LBasicBlock continuation = m_out.newBlock();
10468         LBasicBlock lastNext = nullptr;
10469 
10470         LValue object = lowObject(m_node-&gt;child1());
10471         LValue uniquedStringImpl;
10472         LValue keyAsValue = nullptr;
10473         switch (m_node-&gt;child2().useKind()) {
10474         case StringUse: {
10475             LBasicBlock isNonEmptyString = m_out.newBlock();
10476             LBasicBlock isAtomString = m_out.newBlock();
10477 
10478             keyAsValue = lowString(m_node-&gt;child2());
10479             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10480 
10481             lastNext = m_out.appendTo(isNonEmptyString, isAtomString);
10482             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
10483             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));
10484             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomString));
10485 
10486             m_out.appendTo(isAtomString, slowCase);
10487             break;
10488         }
10489         case SymbolUse: {
10490             keyAsValue = lowSymbol(m_node-&gt;child2());
10491             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
10492             lastNext = m_out.insertNewBlocksBefore(slowCase);
10493             break;
10494         }
10495         case UntypedUse: {
10496             LBasicBlock isCellCase = m_out.newBlock();
10497             LBasicBlock isStringCase = m_out.newBlock();
10498             LBasicBlock notStringCase = m_out.newBlock();
10499             LBasicBlock isNonEmptyString = m_out.newBlock();
10500             LBasicBlock isSymbolCase = m_out.newBlock();
10501             LBasicBlock hasUniquedStringImpl = m_out.newBlock();
10502 
10503             keyAsValue = lowJSValue(m_node-&gt;child2());
10504             m_out.branch(isCell(keyAsValue), usually(isCellCase), rarely(slowCase));
10505 
10506             lastNext = m_out.appendTo(isCellCase, isStringCase);
10507             m_out.branch(isString(keyAsValue), unsure(isStringCase), unsure(notStringCase));
10508 
10509             m_out.appendTo(isStringCase, isNonEmptyString);
10510             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
10511 
10512             m_out.appendTo(isNonEmptyString, notStringCase);
10513             LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
10514             ValueFromBlock stringResult = m_out.anchor(implFromString);
10515             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));
10516             m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
10517 
10518             m_out.appendTo(notStringCase, isSymbolCase);
10519             m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
10520 
10521             m_out.appendTo(isSymbolCase, hasUniquedStringImpl);
10522             ValueFromBlock symbolResult = m_out.anchor(m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl));
10523             m_out.jump(hasUniquedStringImpl);
10524 
10525             m_out.appendTo(hasUniquedStringImpl, slowCase);
10526             uniquedStringImpl = m_out.phi(pointerType(), stringResult, symbolResult);
10527             break;
10528         }
10529         default:
10530             RELEASE_ASSERT_NOT_REACHED();
10531         }
10532 
10533         ASSERT(keyAsValue);
10534 
10535         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero
10536         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
10537         // ever load the result from the cache if the cache entry matches what we are querying for.
10538         // So we either get super lucky and use zero for the hash and somehow collide with the entity
10539         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
10540         // slow path anyways.
10541         LValue hash = m_out.lShr(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10542 
10543         LValue structureID = m_out.load32(object, m_heaps.JSCell_structureID);
10544         LValue index = m_out.add(hash, structureID);
10545         index = m_out.zeroExtPtr(m_out.bitAnd(index, m_out.constInt32(HasOwnPropertyCache::mask)));
10546         ASSERT(vm().hasOwnPropertyCache());
10547         LValue cache = m_out.constIntPtr(vm().hasOwnPropertyCache());
10548 
10549         IndexedAbstractHeap&amp; heap = m_heaps.HasOwnPropertyCache;
10550         LValue sameStructureID = m_out.equal(structureID, m_out.load32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfStructureID())));
10551         LValue sameImpl = m_out.equal(uniquedStringImpl, m_out.loadPtr(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfImpl())));
10552         ValueFromBlock fastResult = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfResult())));
10553         LValue cacheHit = m_out.bitAnd(sameStructureID, sameImpl);
10554 
10555         m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
10556 
10557         m_out.appendTo(slowCase, continuation);
10558         ValueFromBlock slowResult;
10559         slowResult = m_out.anchor(vmCall(Int32, m_out.operation(operationHasOwnProperty), m_callFrame, object, keyAsValue));
10560         m_out.jump(continuation);
10561 
10562         m_out.appendTo(continuation, lastNext);
10563         setBoolean(m_out.phi(Int32, fastResult, slowResult));
10564     }
10565 
10566     void compileParseInt()
10567     {
10568         RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child1().useKind() == StringUse);
10569         LValue result;
10570         if (m_node-&gt;child2()) {
10571             LValue radix = lowInt32(m_node-&gt;child2());
10572             if (m_node-&gt;child1().useKind() == UntypedUse)
10573                 result = vmCall(Int64, m_out.operation(operationParseIntGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()), radix);
10574             else
10575                 result = vmCall(Int64, m_out.operation(operationParseIntString), m_callFrame, lowString(m_node-&gt;child1()), radix);
10576         } else {
10577             if (m_node-&gt;child1().useKind() == UntypedUse)
10578                 result = vmCall(Int64, m_out.operation(operationParseIntNoRadixGeneric), m_callFrame, lowJSValue(m_node-&gt;child1()));
10579             else
10580                 result = vmCall(Int64, m_out.operation(operationParseIntStringNoRadix), m_callFrame, lowString(m_node-&gt;child1()));
10581         }
10582         setJSValue(result);
10583     }
10584 
10585     void compileOverridesHasInstance()
10586     {
10587         FrozenValue* defaultHasInstanceFunction = m_node-&gt;cellOperand();
10588         ASSERT(defaultHasInstanceFunction-&gt;cell()-&gt;inherits&lt;JSFunction&gt;(vm()));
10589 
10590         LValue constructor = lowCell(m_node-&gt;child1());
10591         LValue hasInstance = lowJSValue(m_node-&gt;child2());
10592 
10593         LBasicBlock defaultHasInstance = m_out.newBlock();
10594         LBasicBlock continuation = m_out.newBlock();
10595 
10596         // Unlike in the DFG, we don&#39;t worry about cleaning this code up for the case where we have proven the hasInstanceValue is a constant as B3 should fix it for us.
10597 
10598         ValueFromBlock notDefaultHasInstanceResult = m_out.anchor(m_out.booleanTrue);
10599         m_out.branch(m_out.notEqual(hasInstance, frozenPointer(defaultHasInstanceFunction)), unsure(continuation), unsure(defaultHasInstance));
10600 
10601         LBasicBlock lastNext = m_out.appendTo(defaultHasInstance, continuation);
10602         ValueFromBlock implementsDefaultHasInstanceResult = m_out.anchor(m_out.testIsZero32(
10603             m_out.load8ZeroExt32(constructor, m_heaps.JSCell_typeInfoFlags),
10604             m_out.constInt32(ImplementsDefaultHasInstance)));
10605         m_out.jump(continuation);
10606 
10607         m_out.appendTo(continuation, lastNext);
10608         setBoolean(m_out.phi(Int32, implementsDefaultHasInstanceResult, notDefaultHasInstanceResult));
10609     }
10610 
10611     void compileCheckTypeInfoFlags()
10612     {
10613         speculate(
10614             BadTypeInfoFlags, noValue(), 0,
10615             m_out.testIsZero32(
10616                 m_out.load8ZeroExt32(lowCell(m_node-&gt;child1()), m_heaps.JSCell_typeInfoFlags),
10617                 m_out.constInt32(m_node-&gt;typeInfoOperand())));
10618     }
10619 
10620     void compileInstanceOf()
10621     {
10622         Node* node = m_node;
10623         State* state = &amp;m_ftlState;
10624 
10625         LValue value;
10626         LValue prototype;
10627         bool valueIsCell;
10628         bool prototypeIsCell;
10629         if (m_node-&gt;child1().useKind() == CellUse
10630             &amp;&amp; m_node-&gt;child2().useKind() == CellUse) {
10631             value = lowCell(m_node-&gt;child1());
10632             prototype = lowCell(m_node-&gt;child2());
10633 
10634             valueIsCell = true;
10635             prototypeIsCell = true;
10636         } else {
10637             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
10638             DFG_ASSERT(m_graph, m_node, m_node-&gt;child2().useKind() == UntypedUse);
10639 
10640             value = lowJSValue(m_node-&gt;child1());
10641             prototype = lowJSValue(m_node-&gt;child2());
10642 
10643             valueIsCell = abstractValue(m_node-&gt;child1()).isType(SpecCell);
10644             prototypeIsCell = abstractValue(m_node-&gt;child2()).isType(SpecCell);
10645         }
10646 
10647         bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
10648 
10649         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
10650         patchpoint-&gt;appendSomeRegister(value);
10651         patchpoint-&gt;appendSomeRegister(prototype);
10652         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
10653         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
10654         patchpoint-&gt;numGPScratchRegisters = 2;
10655         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
10656         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
10657 
10658         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
10659             preparePatchpointForExceptions(patchpoint);
10660 
10661         patchpoint-&gt;setGenerator(
10662             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10663                 AllowMacroScratchRegisterUsage allowScratch(jit);
10664 
10665                 GPRReg resultGPR = params[0].gpr();
10666                 GPRReg valueGPR = params[1].gpr();
10667                 GPRReg prototypeGPR = params[2].gpr();
10668                 GPRReg scratchGPR = params.gpScratch(0);
10669                 GPRReg scratch2GPR = params.gpScratch(1);
10670 
10671                 CCallHelpers::Jump doneJump;
10672                 if (!valueIsCell) {
10673                     CCallHelpers::Jump isCell = jit.branchIfCell(valueGPR);
10674                     jit.boxBooleanPayload(false, resultGPR);
10675                     doneJump = jit.jump();
10676                     isCell.link(&amp;jit);
10677                 }
10678 
10679                 CCallHelpers::JumpList slowCases;
10680                 if (!prototypeIsCell)
10681                     slowCases.append(jit.branchIfNotCell(prototypeGPR));
10682 
10683                 CallSiteIndex callSiteIndex =
10684                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
10685 
10686                 // This is the direct exit target for operation calls.
10687                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
10688                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
10689 
10690                 auto generator = Box&lt;JITInstanceOfGenerator&gt;::create(
10691                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
10692                     params.unavailableRegisters(), resultGPR, valueGPR, prototypeGPR, scratchGPR,
10693                     scratch2GPR, prototypeIsObject);
10694                 generator-&gt;generateFastPath(jit);
10695                 CCallHelpers::Label done = jit.label();
10696 
10697                 params.addLatePath(
10698                     [=] (CCallHelpers&amp; jit) {
10699                         AllowMacroScratchRegisterUsage allowScratch(jit);
10700 
10701                         J_JITOperation_ESsiJJ optimizationFunction = operationInstanceOfOptimize;
10702 
10703                         slowCases.link(&amp;jit);
10704                         CCallHelpers::Label slowPathBegin = jit.label();
10705                         CCallHelpers::Call slowPathCall = callOperation(
10706                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
10707                             exceptions.get(), optimizationFunction, resultGPR,
10708                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), valueGPR,
10709                             prototypeGPR).call();
10710                         jit.jump().linkTo(done, &amp;jit);
10711 
10712                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
10713 
10714                         jit.addLinkTask(
10715                             [=] (LinkBuffer&amp; linkBuffer) {
10716                                 generator-&gt;finalize(linkBuffer, linkBuffer);
10717                             });
10718                     });
10719 
10720                 if (doneJump.isSet())
10721                     doneJump.link(&amp;jit);
10722             });
10723 
10724         // This returns a boxed boolean.
10725         setJSValue(patchpoint);
10726     }
10727 
10728     void compileInstanceOfCustom()
10729     {
10730         LValue value = lowJSValue(m_node-&gt;child1());
10731         LValue constructor = lowCell(m_node-&gt;child2());
10732         LValue hasInstance = lowJSValue(m_node-&gt;child3());
10733 
10734         setBoolean(m_out.logicalNot(m_out.equal(m_out.constInt32(0), vmCall(Int32, m_out.operation(operationInstanceOfCustom), m_callFrame, value, constructor, hasInstance))));
10735     }
10736 
10737     void compileCountExecution()
10738     {
10739         TypedPointer counter = m_out.absolute(m_node-&gt;executionCounter()-&gt;address());
10740         m_out.store64(m_out.add(m_out.load64(counter), m_out.constInt64(1)), counter);
10741     }
10742 
10743     void compileSuperSamplerBegin()
10744     {
10745         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
10746         m_out.store32(m_out.add(m_out.load32(counter), m_out.constInt32(1)), counter);
10747     }
10748 
10749     void compileSuperSamplerEnd()
10750     {
10751         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
10752         m_out.store32(m_out.sub(m_out.load32(counter), m_out.constInt32(1)), counter);
10753     }
10754 
10755     void compileStoreBarrier()
10756     {
10757         emitStoreBarrier(lowCell(m_node-&gt;child1()), m_node-&gt;op() == FencedStoreBarrier);
10758     }
10759 
10760     void compileHasIndexedProperty()
10761     {
10762         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
10763         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
10764 
10765         switch (m_node-&gt;arrayMode().type()) {
10766         case Array::Int32:
10767         case Array::Contiguous: {
10768             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10769             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10770 
10771             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
10772                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
10773 
10774             LBasicBlock slowCase = m_out.newBlock();
10775             LBasicBlock continuation = m_out.newBlock();
10776             LBasicBlock lastNext = nullptr;
10777 
10778             if (!m_node-&gt;arrayMode().isInBounds()) {
10779                 LBasicBlock checkHole = m_out.newBlock();
10780                 m_out.branch(
10781                     m_out.aboveOrEqual(
10782                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
10783                     rarely(slowCase), usually(checkHole));
10784                 lastNext = m_out.appendTo(checkHole, slowCase);
10785             } else
10786                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10787 
10788             LValue checkHoleResultValue =
10789                 m_out.notZero64(m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1))));
10790             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10791             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10792 
10793             m_out.appendTo(slowCase, continuation);
10794             ValueFromBlock slowResult = m_out.anchor(
10795                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10796             m_out.jump(continuation);
10797 
10798             m_out.appendTo(continuation, lastNext);
10799             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10800             return;
10801         }
10802         case Array::Double: {
10803             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10804             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10805 
10806             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
10807 
10808             LBasicBlock slowCase = m_out.newBlock();
10809             LBasicBlock continuation = m_out.newBlock();
10810             LBasicBlock lastNext = nullptr;
10811 
10812             if (!m_node-&gt;arrayMode().isInBounds()) {
10813                 LBasicBlock checkHole = m_out.newBlock();
10814                 m_out.branch(
10815                     m_out.aboveOrEqual(
10816                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
10817                     rarely(slowCase), usually(checkHole));
10818                 lastNext = m_out.appendTo(checkHole, slowCase);
10819             } else
10820                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10821 
10822             LValue doubleValue = m_out.loadDouble(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
10823             LValue checkHoleResultValue = m_out.doubleEqual(doubleValue, doubleValue);
10824             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10825             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10826 
10827             m_out.appendTo(slowCase, continuation);
10828             ValueFromBlock slowResult = m_out.anchor(
10829                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10830             m_out.jump(continuation);
10831 
10832             m_out.appendTo(continuation, lastNext);
10833             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10834             return;
10835         }
10836 
10837         case Array::ArrayStorage: {
10838             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
10839             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10840 
10841             LBasicBlock slowCase = m_out.newBlock();
10842             LBasicBlock continuation = m_out.newBlock();
10843             LBasicBlock lastNext = nullptr;
10844 
10845             if (!m_node-&gt;arrayMode().isInBounds()) {
10846                 LBasicBlock checkHole = m_out.newBlock();
10847                 m_out.branch(
10848                     m_out.aboveOrEqual(
10849                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
10850                     rarely(slowCase), usually(checkHole));
10851                 lastNext = m_out.appendTo(checkHole, slowCase);
10852             } else
10853                 lastNext = m_out.insertNewBlocksBefore(slowCase);
10854 
10855             LValue checkHoleResultValue =
10856                 m_out.notZero64(m_out.load64(baseIndex(m_heaps.ArrayStorage_vector, storage, index, m_graph.varArgChild(m_node, 1))));
10857             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
10858             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
10859 
10860             m_out.appendTo(slowCase, continuation);
10861             ValueFromBlock slowResult = m_out.anchor(
10862                 m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10863             m_out.jump(continuation);
10864 
10865             m_out.appendTo(continuation, lastNext);
10866             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
10867             break;
10868         }
10869 
10870         default: {
10871             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
10872             setBoolean(m_out.notZero64(vmCall(Int64, m_out.operation(operationHasIndexedPropertyByInt), m_callFrame, base, index, internalMethodType)));
10873             break;
10874         }
10875         }
10876     }
10877 
10878     void compileHasGenericProperty()
10879     {
10880         LValue base = lowJSValue(m_node-&gt;child1());
10881         LValue property = lowCell(m_node-&gt;child2());
10882         setJSValue(vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property));
10883     }
10884 
10885     void compileHasStructureProperty()
10886     {
10887         LValue base = lowJSValue(m_node-&gt;child1());
10888         LValue property = lowString(m_node-&gt;child2());
10889         LValue enumerator = lowCell(m_node-&gt;child3());
10890 
10891         LBasicBlock correctStructure = m_out.newBlock();
10892         LBasicBlock wrongStructure = m_out.newBlock();
10893         LBasicBlock continuation = m_out.newBlock();
10894 
10895         m_out.branch(m_out.notEqual(
10896             m_out.load32(base, m_heaps.JSCell_structureID),
10897             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
10898             rarely(wrongStructure), usually(correctStructure));
10899 
10900         LBasicBlock lastNext = m_out.appendTo(correctStructure, wrongStructure);
10901         ValueFromBlock correctStructureResult = m_out.anchor(m_out.booleanTrue);
10902         m_out.jump(continuation);
10903 
10904         m_out.appendTo(wrongStructure, continuation);
10905         ValueFromBlock wrongStructureResult = m_out.anchor(
10906             m_out.equal(
10907                 m_out.constInt64(JSValue::encode(jsBoolean(true))),
10908                 vmCall(Int64, m_out.operation(operationHasGenericProperty), m_callFrame, base, property)));
10909         m_out.jump(continuation);
10910 
10911         m_out.appendTo(continuation, lastNext);
10912         setBoolean(m_out.phi(Int32, correctStructureResult, wrongStructureResult));
10913     }
10914 
10915     void compileGetDirectPname()
10916     {
10917         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
10918         LValue property = lowCell(m_graph.varArgChild(m_node, 1));
10919         LValue index = lowInt32(m_graph.varArgChild(m_node, 2));
10920         LValue enumerator = lowCell(m_graph.varArgChild(m_node, 3));
10921 
10922         LBasicBlock checkOffset = m_out.newBlock();
10923         LBasicBlock inlineLoad = m_out.newBlock();
10924         LBasicBlock outOfLineLoad = m_out.newBlock();
10925         LBasicBlock slowCase = m_out.newBlock();
10926         LBasicBlock continuation = m_out.newBlock();
10927 
10928         m_out.branch(m_out.notEqual(
10929             m_out.load32(base, m_heaps.JSCell_structureID),
10930             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
10931             rarely(slowCase), usually(checkOffset));
10932 
10933         LBasicBlock lastNext = m_out.appendTo(checkOffset, inlineLoad);
10934         m_out.branch(m_out.aboveOrEqual(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity)),
10935             unsure(outOfLineLoad), unsure(inlineLoad));
10936 
10937         m_out.appendTo(inlineLoad, outOfLineLoad);
10938         ValueFromBlock inlineResult = m_out.anchor(
10939             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(),
10940                 base, m_out.zeroExt(index, Int64), ScaleEight, JSObject::offsetOfInlineStorage())));
10941         m_out.jump(continuation);
10942 
10943         m_out.appendTo(outOfLineLoad, slowCase);
10944         LValue storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
10945         LValue realIndex = m_out.signExt32To64(
10946             m_out.neg(m_out.sub(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity))));
10947         int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
10948         ValueFromBlock outOfLineResult = m_out.anchor(
10949             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), storage, realIndex, ScaleEight, offsetOfFirstProperty)));
10950         m_out.jump(continuation);
10951 
10952         m_out.appendTo(slowCase, continuation);
10953         ValueFromBlock slowCaseResult = m_out.anchor(
10954             vmCall(Int64, m_out.operation(operationGetByVal), m_callFrame, base, property));
10955         m_out.jump(continuation);
10956 
10957         m_out.appendTo(continuation, lastNext);
10958         setJSValue(m_out.phi(Int64, inlineResult, outOfLineResult, slowCaseResult));
10959     }
10960 
10961     void compileGetEnumerableLength()
10962     {
10963         LValue enumerator = lowCell(m_node-&gt;child1());
10964         setInt32(m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_indexLength));
10965     }
10966 
10967     void compileGetPropertyEnumerator()
10968     {
10969         if (m_node-&gt;child1().useKind() == CellUse)
10970             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumeratorCell), m_callFrame, lowCell(m_node-&gt;child1())));
10971         else
10972             setJSValue(vmCall(Int64, m_out.operation(operationGetPropertyEnumerator), m_callFrame, lowJSValue(m_node-&gt;child1())));
10973     }
10974 
10975     void compileGetEnumeratorStructurePname()
10976     {
10977         LValue enumerator = lowCell(m_node-&gt;child1());
10978         LValue index = lowInt32(m_node-&gt;child2());
10979 
10980         LBasicBlock inBounds = m_out.newBlock();
10981         LBasicBlock outOfBounds = m_out.newBlock();
10982         LBasicBlock continuation = m_out.newBlock();
10983 
10984         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endStructurePropertyIndex)),
10985             usually(inBounds), rarely(outOfBounds));
10986 
10987         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
10988         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
10989         ValueFromBlock inBoundsResult = m_out.anchor(
10990             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
10991         m_out.jump(continuation);
10992 
10993         m_out.appendTo(outOfBounds, continuation);
10994         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));
10995         m_out.jump(continuation);
10996 
10997         m_out.appendTo(continuation, lastNext);
10998         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
10999     }
11000 
11001     void compileGetEnumeratorGenericPname()
11002     {
11003         LValue enumerator = lowCell(m_node-&gt;child1());
11004         LValue index = lowInt32(m_node-&gt;child2());
11005 
11006         LBasicBlock inBounds = m_out.newBlock();
11007         LBasicBlock outOfBounds = m_out.newBlock();
11008         LBasicBlock continuation = m_out.newBlock();
11009 
11010         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endGenericPropertyIndex)),
11011             usually(inBounds), rarely(outOfBounds));
11012 
11013         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
11014         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
11015         ValueFromBlock inBoundsResult = m_out.anchor(
11016             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
11017         m_out.jump(continuation);
11018 
11019         m_out.appendTo(outOfBounds, continuation);
11020         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(ValueNull));
11021         m_out.jump(continuation);
11022 
11023         m_out.appendTo(continuation, lastNext);
11024         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
11025     }
11026 
11027     void compileToIndexString()
11028     {
11029         LValue index = lowInt32(m_node-&gt;child1());
11030         setJSValue(vmCall(Int64, m_out.operation(operationToIndexString), m_callFrame, index));
11031     }
11032 
11033     void compileCheckStructureImmediate()
11034     {
11035         LValue structure = lowCell(m_node-&gt;child1());
11036         checkStructure(
11037             structure, noValue(), BadCache, m_node-&gt;structureSet(),
11038             [this] (RegisteredStructure structure) {
11039                 return weakStructure(structure);
11040             });
11041     }
11042 
11043     void compileMaterializeNewObject()
11044     {
11045         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11046 
11047         // Lower the values first, to avoid creating values inside a control flow diamond.
11048 
11049         Vector&lt;LValue, 8&gt; values;
11050         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11051             Edge edge = m_graph.varArgChild(m_node, 1 + i);
11052             switch (data.m_properties[i].kind()) {
11053             case PublicLengthPLoc:
11054             case VectorLengthPLoc:
11055                 values.append(lowInt32(edge));
11056                 break;
11057             default:
11058                 values.append(lowJSValue(edge));
11059                 break;
11060             }
11061         }
11062 
11063         RegisteredStructureSet set = m_node-&gt;structureSet();
11064 
11065         Vector&lt;LBasicBlock, 1&gt; blocks(set.size());
11066         for (unsigned i = set.size(); i--;)
11067             blocks[i] = m_out.newBlock();
11068         LBasicBlock dummyDefault = m_out.newBlock();
11069         LBasicBlock outerContinuation = m_out.newBlock();
11070 
11071         Vector&lt;SwitchCase, 1&gt; cases(set.size());
11072         for (unsigned i = set.size(); i--;)
11073             cases[i] = SwitchCase(weakStructure(set.at(i)), blocks[i], Weight(1));
11074         m_out.switchInstruction(
11075             lowCell(m_graph.varArgChild(m_node, 0)), cases, dummyDefault, Weight(0));
11076 
11077         LBasicBlock outerLastNext = m_out.m_nextBlock;
11078 
11079         Vector&lt;ValueFromBlock, 1&gt; results;
11080 
11081         for (unsigned i = set.size(); i--;) {
11082             m_out.appendTo(blocks[i], i + 1 &lt; set.size() ? blocks[i + 1] : dummyDefault);
11083 
11084             RegisteredStructure structure = set.at(i);
11085 
11086             LValue object;
11087             LValue butterfly;
11088 
11089             if (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType())) {
11090                 size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
11091                 Allocator cellAllocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
11092 
11093                 bool hasIndexingHeader = hasIndexedProperties(structure-&gt;indexingType());
11094                 unsigned indexingHeaderSize = 0;
11095                 LValue indexingPayloadSizeInBytes = m_out.intPtrZero;
11096                 LValue vectorLength = m_out.int32Zero;
11097                 LValue publicLength = m_out.int32Zero;
11098                 if (hasIndexingHeader) {
11099                     indexingHeaderSize = sizeof(IndexingHeader);
11100                     for (unsigned i = data.m_properties.size(); i--;) {
11101                         PromotedLocationDescriptor descriptor = data.m_properties[i];
11102                         switch (descriptor.kind()) {
11103                         case PublicLengthPLoc:
11104                             publicLength = values[i];
11105                             break;
11106                         case VectorLengthPLoc:
11107                             vectorLength = values[i];
11108                             break;
11109                         default:
11110                             break;
11111                         }
11112                     }
11113                     indexingPayloadSizeInBytes =
11114                         m_out.mul(m_out.zeroExtPtr(vectorLength), m_out.intPtrEight);
11115                 }
11116 
11117                 LValue butterflySize = m_out.add(
11118                     m_out.constIntPtr(
11119                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + indexingHeaderSize),
11120                     indexingPayloadSizeInBytes);
11121 
11122                 LBasicBlock slowPath = m_out.newBlock();
11123                 LBasicBlock continuation = m_out.newBlock();
11124 
11125                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11126 
11127                 ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
11128 
11129                 LValue startOfStorage = allocateHeapCell(
11130                     allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, slowPath),
11131                     slowPath);
11132 
11133                 LValue fastButterflyValue = m_out.add(
11134                     startOfStorage,
11135                     m_out.constIntPtr(
11136                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + sizeof(IndexingHeader)));
11137 
11138                 ValueFromBlock haveButterfly = m_out.anchor(fastButterflyValue);
11139 
11140                 splatWords(
11141                     fastButterflyValue,
11142                     m_out.constInt32(-structure-&gt;outOfLineCapacity() - 1),
11143                     m_out.constInt32(-1),
11144                     m_out.int64Zero, m_heaps.properties.atAnyNumber());
11145 
11146                 m_out.store32(vectorLength, fastButterflyValue, m_heaps.Butterfly_vectorLength);
11147 
11148                 LValue fastObjectValue = allocateObject(
11149                     m_out.constIntPtr(cellAllocator.localAllocator()), structure, fastButterflyValue,
11150                     slowPath);
11151 
11152                 ValueFromBlock fastObject = m_out.anchor(fastObjectValue);
11153                 ValueFromBlock fastButterfly = m_out.anchor(fastButterflyValue);
11154                 m_out.jump(continuation);
11155 
11156                 m_out.appendTo(slowPath, continuation);
11157 
11158                 LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
11159 
11160                 VM&amp; vm = this-&gt;vm();
11161                 LValue slowObjectValue;
11162                 if (hasIndexingHeader) {
11163                     slowObjectValue = lazySlowPath(
11164                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11165                             return createLazyCallGenerator(vm,
11166                                 operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength,
11167                                 locations[0].directGPR(), CCallHelpers::TrustedImmPtr(structure.get()),
11168                                 locations[1].directGPR(), locations[2].directGPR());
11169                         },
11170                         vectorLength, butterflyValue);
11171                 } else {
11172                     slowObjectValue = lazySlowPath(
11173                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11174                             return createLazyCallGenerator(vm,
11175                                 operationNewObjectWithButterfly, locations[0].directGPR(),
11176                                 CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR());
11177                         },
11178                         butterflyValue);
11179                 }
11180                 ValueFromBlock slowObject = m_out.anchor(slowObjectValue);
11181                 ValueFromBlock slowButterfly = m_out.anchor(
11182                     m_out.loadPtr(slowObjectValue, m_heaps.JSObject_butterfly));
11183 
11184                 m_out.jump(continuation);
11185 
11186                 m_out.appendTo(continuation, lastNext);
11187 
11188                 object = m_out.phi(pointerType(), fastObject, slowObject);
11189                 butterfly = m_out.phi(pointerType(), fastButterfly, slowButterfly);
11190 
11191                 m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
11192 
11193                 initializeArrayElements(m_out.constInt32(structure-&gt;indexingType()), m_out.int32Zero, vectorLength, butterfly);
11194 
11195                 HashMap&lt;int32_t, LValue, DefaultHash&lt;int32_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int32_t&gt;&gt; indexMap;
11196                 Vector&lt;int32_t&gt; indices;
11197                 for (unsigned i = data.m_properties.size(); i--;) {
11198                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11199                     if (descriptor.kind() != IndexedPropertyPLoc)
11200                         continue;
11201                     int32_t index = static_cast&lt;int32_t&gt;(descriptor.info());
11202 
11203                     auto result = indexMap.add(index, values[i]);
11204                     DFG_ASSERT(m_graph, m_node, result); // Duplicates are illegal.
11205 
11206                     indices.append(index);
11207                 }
11208 
11209                 if (!indices.isEmpty()) {
11210                     std::sort(indices.begin(), indices.end());
11211 
11212                     Vector&lt;LBasicBlock&gt; blocksWithStores(indices.size());
11213                     Vector&lt;LBasicBlock&gt; blocksWithChecks(indices.size());
11214 
11215                     for (unsigned i = indices.size(); i--;) {
11216                         blocksWithStores[i] = m_out.newBlock();
11217                         blocksWithChecks[i] = m_out.newBlock(); // blocksWithChecks[0] is the continuation.
11218                     }
11219 
11220                     LBasicBlock indexLastNext = m_out.m_nextBlock;
11221 
11222                     for (unsigned i = indices.size(); i--;) {
11223                         int32_t index = indices[i];
11224                         LValue value = indexMap.get(index);
11225 
11226                         m_out.branch(
11227                             m_out.below(m_out.constInt32(index), publicLength),
11228                             unsure(blocksWithStores[i]), unsure(blocksWithChecks[i]));
11229 
11230                         m_out.appendTo(blocksWithStores[i], blocksWithChecks[i]);
11231 
11232                         // This has to type-check and convert its inputs, but it cannot do so in a
11233                         // way that updates AI. That&#39;s a bit annoying, but if you think about how
11234                         // sinking works, it&#39;s actually not a bad thing. We are virtually guaranteed
11235                         // that these type checks will not fail, since the type checks that guarded
11236                         // the original stores to the array are still somewhere above this point.
11237                         Output::StoreType storeType;
11238                         IndexedAbstractHeap* heap;
11239                         switch (structure-&gt;indexingType()) {
11240                         case ALL_INT32_INDEXING_TYPES:
11241                             // FIXME: This could use the proven type if we had the Edge for the
11242                             // value. https://bugs.webkit.org/show_bug.cgi?id=155311
11243                             speculate(BadType, noValue(), nullptr, isNotInt32(value));
11244                             storeType = Output::Store64;
11245                             heap = &amp;m_heaps.indexedInt32Properties;
11246                             break;
11247 
11248                         case ALL_DOUBLE_INDEXING_TYPES: {
11249                             // FIXME: If the source is ValueRep, we should avoid emitting any
11250                             // checks. We could also avoid emitting checks if we had the Edge of
11251                             // this value. https://bugs.webkit.org/show_bug.cgi?id=155311
11252 
11253                             LBasicBlock intCase = m_out.newBlock();
11254                             LBasicBlock doubleCase = m_out.newBlock();
11255                             LBasicBlock continuation = m_out.newBlock();
11256 
11257                             m_out.branch(isInt32(value), unsure(intCase), unsure(doubleCase));
11258 
11259                             LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
11260 
11261                             ValueFromBlock intResult =
11262                                 m_out.anchor(m_out.intToDouble(unboxInt32(value)));
11263                             m_out.jump(continuation);
11264 
11265                             m_out.appendTo(doubleCase, continuation);
11266 
11267                             speculate(BadType, noValue(), nullptr, isNumber(value));
11268                             ValueFromBlock doubleResult = m_out.anchor(unboxDouble(value));
11269                             m_out.jump(continuation);
11270 
11271                             m_out.appendTo(continuation, lastNext);
11272                             value = m_out.phi(Double, intResult, doubleResult);
11273                             storeType = Output::StoreDouble;
11274                             heap = &amp;m_heaps.indexedDoubleProperties;
11275                             break;
11276                         }
11277 
11278                         case ALL_CONTIGUOUS_INDEXING_TYPES:
11279                             storeType = Output::Store64;
11280                             heap = &amp;m_heaps.indexedContiguousProperties;
11281                             break;
11282 
11283                         default:
11284                             DFG_CRASH(m_graph, m_node, &quot;Invalid indexing type&quot;);
11285                             break;
11286                         }
11287 
11288                         m_out.store(value, m_out.address(butterfly, heap-&gt;at(index)), storeType);
11289 
11290                         m_out.jump(blocksWithChecks[i]);
11291                         m_out.appendTo(
11292                             blocksWithChecks[i], i ? blocksWithStores[i - 1] : indexLastNext);
11293                     }
11294                 }
11295             } else {
11296                 // In the easy case where we can do a one-shot allocation, we simply allocate the
11297                 // object to directly have the desired structure.
11298                 object = allocateObject(structure);
11299                 butterfly = nullptr; // Don&#39;t have one, don&#39;t need one.
11300             }
11301 
11302             BitVector setInlineOffsets;
11303             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11304                 for (unsigned i = data.m_properties.size(); i--;) {
11305                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11306                     if (descriptor.kind() != NamedPropertyPLoc)
11307                         continue;
11308                     if (m_graph.identifiers()[descriptor.info()] != entry.key)
11309                         continue;
11310 
11311                     LValue base;
11312                     if (isInlineOffset(entry.offset)) {
11313                         setInlineOffsets.set(entry.offset);
11314                         base = object;
11315                     } else
11316                         base = butterfly;
11317                     storeProperty(values[i], base, descriptor.info(), entry.offset);
11318                     break;
11319                 }
11320             }
11321             for (unsigned i = structure-&gt;inlineCapacity(); i--;) {
11322                 if (!setInlineOffsets.get(i))
11323                     m_out.store64(m_out.int64Zero, m_out.address(m_heaps.properties.atAnyNumber(), object, offsetRelativeToBase(i)));
11324             }
11325 
11326             results.append(m_out.anchor(object));
11327             m_out.jump(outerContinuation);
11328         }
11329 
11330         m_out.appendTo(dummyDefault, outerContinuation);
11331         m_out.unreachable();
11332 
11333         m_out.appendTo(outerContinuation, outerLastNext);
11334         setJSValue(m_out.phi(pointerType(), results));
11335         mutatorFence();
11336     }
11337 
11338     void compileMaterializeCreateActivation()
11339     {
11340         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11341 
11342         Vector&lt;LValue, 8&gt; values;
11343         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
11344             values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
11345 
11346         LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
11347         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
11348         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
11349 
11350         LBasicBlock slowPath = m_out.newBlock();
11351         LBasicBlock continuation = m_out.newBlock();
11352 
11353         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11354 
11355         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
11356             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
11357 
11358         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
11359         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
11360 
11361 
11362         ValueFromBlock fastResult = m_out.anchor(fastObject);
11363         m_out.jump(continuation);
11364 
11365         m_out.appendTo(slowPath, continuation);
11366         // We ensure allocation sinking explictly sets bottom values for all field members.
11367         // Therefore, it doesn&#39;t matter what JSValue we pass in as the initialization value
11368         // because all fields will be overwritten.
11369         // FIXME: It may be worth creating an operation that calls a constructor on JSLexicalEnvironment that
11370         // doesn&#39;t initialize every slot because we are guaranteed to do that here.
11371         VM&amp; vm = this-&gt;vm();
11372         LValue callResult = lazySlowPath(
11373             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11374                 return createLazyCallGenerator(vm,
11375                     operationCreateActivationDirect, locations[0].directGPR(),
11376                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
11377                     CCallHelpers::TrustedImmPtr(table),
11378                     CCallHelpers::TrustedImm64(JSValue::encode(jsUndefined())));
11379             }, scope);
11380         ValueFromBlock slowResult =  m_out.anchor(callResult);
11381         m_out.jump(continuation);
11382 
11383         m_out.appendTo(continuation, lastNext);
11384         LValue activation = m_out.phi(pointerType(), fastResult, slowResult);
11385         RELEASE_ASSERT(data.m_properties.size() == table-&gt;scopeSize());
11386         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11387             PromotedLocationDescriptor descriptor = data.m_properties[i];
11388             ASSERT(descriptor.kind() == ClosureVarPLoc);
11389             m_out.store64(
11390                 values[i], activation,
11391                 m_heaps.JSLexicalEnvironment_variables[descriptor.info()]);
11392         }
11393 
11394         if (validationEnabled()) {
11395             // Validate to make sure every slot in the scope has one value.
11396             ConcurrentJSLocker locker(table-&gt;m_lock);
11397             for (auto iter = table-&gt;begin(locker), end = table-&gt;end(locker); iter != end; ++iter) {
11398                 bool found = false;
11399                 for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11400                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11401                     ASSERT(descriptor.kind() == ClosureVarPLoc);
11402                     if (iter-&gt;value.scopeOffset().offset() == descriptor.info()) {
11403                         found = true;
11404                         break;
11405                     }
11406                 }
11407                 ASSERT_UNUSED(found, found);
11408             }
11409         }
11410 
11411         mutatorFence();
11412         setJSValue(activation);
11413     }
11414 
11415     void compileCheckTraps()
11416     {
11417         ASSERT(Options::usePollingTraps());
11418         LBasicBlock needTrapHandling = m_out.newBlock();
11419         LBasicBlock continuation = m_out.newBlock();
11420 
11421         LValue state = m_out.load8ZeroExt32(m_out.absolute(vm().needTrapHandlingAddress()));
11422         m_out.branch(m_out.isZero32(state),
11423             usually(continuation), rarely(needTrapHandling));
11424 
11425         LBasicBlock lastNext = m_out.appendTo(needTrapHandling, continuation);
11426 
11427         VM&amp; vm = this-&gt;vm();
11428         lazySlowPath(
11429             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11430                 return createLazyCallGenerator(vm, operationHandleTraps, InvalidGPRReg);
11431             });
11432         m_out.jump(continuation);
11433 
11434         m_out.appendTo(continuation, lastNext);
11435     }
11436 
11437     void compileRegExpExec()
11438     {
11439         LValue globalObject = lowCell(m_node-&gt;child1());
11440 
11441         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
11442             LValue base = lowRegExpObject(m_node-&gt;child2());
11443 
11444             if (m_node-&gt;child3().useKind() == StringUse) {
11445                 LValue argument = lowString(m_node-&gt;child3());
11446                 LValue result = vmCall(
11447                     Int64, m_out.operation(operationRegExpExecString), m_callFrame, globalObject,
11448                     base, argument);
11449                 setJSValue(result);
11450                 return;
11451             }
11452 
11453             LValue argument = lowJSValue(m_node-&gt;child3());
11454             LValue result = vmCall(
11455                 Int64, m_out.operation(operationRegExpExec), m_callFrame, globalObject, base,
11456                 argument);
11457             setJSValue(result);
11458             return;
11459         }
11460 
11461         LValue base = lowJSValue(m_node-&gt;child2());
11462         LValue argument = lowJSValue(m_node-&gt;child3());
11463         LValue result = vmCall(
11464             Int64, m_out.operation(operationRegExpExecGeneric), m_callFrame, globalObject, base,
11465             argument);
11466         setJSValue(result);
11467     }
11468 
11469     void compileRegExpExecNonGlobalOrSticky()
11470     {
11471         LValue globalObject = lowCell(m_node-&gt;child1());
11472         LValue argument = lowString(m_node-&gt;child2());
11473         LValue result = vmCall(
11474             Int64, m_out.operation(operationRegExpExecNonGlobalOrSticky), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);
11475         setJSValue(result);
11476     }
11477 
11478     void compileRegExpMatchFastGlobal()
11479     {
11480         LValue globalObject = lowCell(m_node-&gt;child1());
11481         LValue argument = lowString(m_node-&gt;child2());
11482         LValue result = vmCall(
11483             Int64, m_out.operation(operationRegExpMatchFastGlobalString), m_callFrame, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);
11484         setJSValue(result);
11485     }
11486 
11487     void compileRegExpTest()
11488     {
11489         LValue globalObject = lowCell(m_node-&gt;child1());
11490 
11491         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
11492             LValue base = lowRegExpObject(m_node-&gt;child2());
11493 
11494             if (m_node-&gt;child3().useKind() == StringUse) {
11495                 LValue argument = lowString(m_node-&gt;child3());
11496                 LValue result = vmCall(
11497                     Int32, m_out.operation(operationRegExpTestString), m_callFrame, globalObject,
11498                     base, argument);
11499                 setBoolean(result);
11500                 return;
11501             }
11502 
11503             LValue argument = lowJSValue(m_node-&gt;child3());
11504             LValue result = vmCall(
11505                 Int32, m_out.operation(operationRegExpTest), m_callFrame, globalObject, base,
11506                 argument);
11507             setBoolean(result);
11508             return;
11509         }
11510 
11511         LValue base = lowJSValue(m_node-&gt;child2());
11512         LValue argument = lowJSValue(m_node-&gt;child3());
11513         LValue result = vmCall(
11514             Int32, m_out.operation(operationRegExpTestGeneric), m_callFrame, globalObject, base,
11515             argument);
11516         setBoolean(result);
11517     }
11518 
11519     void compileRegExpMatchFast()
11520     {
11521         LValue globalObject = lowCell(m_node-&gt;child1());
11522         LValue base = lowRegExpObject(m_node-&gt;child2());
11523         LValue argument = lowString(m_node-&gt;child3());
11524         LValue result = vmCall(
11525             Int64, m_out.operation(operationRegExpMatchFastString), m_callFrame, globalObject,
11526             base, argument);
11527         setJSValue(result);
11528     }
11529 
11530     void compileNewRegexp()
11531     {
11532         FrozenValue* regexp = m_node-&gt;cellOperand();
11533         LValue lastIndex = lowJSValue(m_node-&gt;child1());
11534         ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
11535 
11536         LBasicBlock slowCase = m_out.newBlock();
11537         LBasicBlock continuation = m_out.newBlock();
11538 
11539         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
11540 
11541         auto structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;regExpStructure());
11542         LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
11543         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);
11544         m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
11545         mutatorFence();
11546         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
11547         m_out.jump(continuation);
11548 
11549         m_out.appendTo(slowCase, continuation);
11550         VM&amp; vm = this-&gt;vm();
11551         RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
11552         LValue slowResultValue = lazySlowPath(
11553             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11554                 return createLazyCallGenerator(vm,
11555                     operationNewRegexpWithLastIndex, locations[0].directGPR(),
11556                     CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
11557             }, lastIndex);
11558         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
11559         m_out.jump(continuation);
11560 
11561         m_out.appendTo(continuation, lastNext);
11562         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
11563     }
11564 
11565     void compileSetFunctionName()
11566     {
11567         vmCall(Void, m_out.operation(operationSetFunctionName), m_callFrame,
11568             lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()));
11569     }
11570 
11571     void compileStringReplace()
11572     {
11573         if (m_node-&gt;child1().useKind() == StringUse
11574             &amp;&amp; m_node-&gt;child2().useKind() == RegExpObjectUse
11575             &amp;&amp; m_node-&gt;child3().useKind() == StringUse) {
11576 
11577             if (JSString* replace = m_node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
11578                 if (!replace-&gt;length()) {
11579                     LValue string = lowString(m_node-&gt;child1());
11580                     LValue regExp = lowRegExpObject(m_node-&gt;child2());
11581 
11582                     LValue result = vmCall(
11583                         pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpEmptyStr),
11584                         m_callFrame, string, regExp);
11585 
11586                     setJSValue(result);
11587                     return;
11588                 }
11589             }
11590 
11591             LValue string = lowString(m_node-&gt;child1());
11592             LValue regExp = lowRegExpObject(m_node-&gt;child2());
11593             LValue replace = lowString(m_node-&gt;child3());
11594 
11595             LValue result = vmCall(
11596                 pointerType(), m_out.operation(operationStringProtoFuncReplaceRegExpString),
11597                 m_callFrame, string, regExp, replace);
11598 
11599             setJSValue(result);
11600             return;
11601         }
11602 
11603         LValue search;
11604         if (m_node-&gt;child2().useKind() == StringUse)
11605             search = lowString(m_node-&gt;child2());
11606         else
11607             search = lowJSValue(m_node-&gt;child2());
11608 
11609         LValue result = vmCall(
11610             pointerType(), m_out.operation(operationStringProtoFuncReplaceGeneric), m_callFrame,
11611             lowJSValue(m_node-&gt;child1()), search,
11612             lowJSValue(m_node-&gt;child3()));
11613 
11614         setJSValue(result);
11615     }
11616 
11617     void compileGetRegExpObjectLastIndex()
11618     {
11619         setJSValue(m_out.load64(lowRegExpObject(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex));
11620     }
11621 
11622     void compileSetRegExpObjectLastIndex()
11623     {
11624         if (!m_node-&gt;ignoreLastIndexIsWritable()) {
11625             LValue regExp = lowRegExpObject(m_node-&gt;child1());
11626             LValue value = lowJSValue(m_node-&gt;child2());
11627 
11628             speculate(
11629                 ExoticObjectMode, noValue(), nullptr,
11630                 m_out.testNonZeroPtr(
11631                     m_out.loadPtr(regExp, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag),
11632                     m_out.constIntPtr(RegExpObject::lastIndexIsNotWritableFlag)));
11633 
11634             m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
11635             return;
11636         }
11637 
11638         m_out.store64(lowJSValue(m_node-&gt;child2()), lowCell(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex);
11639     }
11640 
11641     void compileLogShadowChickenPrologue()
11642     {
11643         LValue packet = ensureShadowChickenPacket();
11644         LValue scope = lowCell(m_node-&gt;child1());
11645 
11646         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11647         m_out.storePtr(m_out.loadPtr(addressFor(0)), packet, m_heaps.ShadowChicken_Packet_callerFrame);
11648         m_out.storePtr(m_out.loadPtr(payloadFor(CallFrameSlot::callee)), packet, m_heaps.ShadowChicken_Packet_callee);
11649         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11650     }
11651 
11652     void compileLogShadowChickenTail()
11653     {
11654         LValue packet = ensureShadowChickenPacket();
11655         LValue thisValue = lowJSValue(m_node-&gt;child1());
11656         LValue scope = lowCell(m_node-&gt;child2());
11657         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(m_node-&gt;origin.semantic);
11658 
11659         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
11660         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(ShadowChicken::Packet::tailMarker())), packet, m_heaps.ShadowChicken_Packet_callee);
11661         m_out.store64(thisValue, packet, m_heaps.ShadowChicken_Packet_thisValue);
11662         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
11663         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
11664         // that would cause it to always get collected.
11665         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), packet, m_heaps.ShadowChicken_Packet_codeBlock);
11666         m_out.store32(m_out.constInt32(callSiteIndex.bits()), packet, m_heaps.ShadowChicken_Packet_callSiteIndex);
11667     }
11668 
11669     void compileRecordRegExpCachedResult()
11670     {
11671         Edge globalObjectEdge = m_graph.varArgChild(m_node, 0);
11672         Edge regExpEdge = m_graph.varArgChild(m_node, 1);
11673         Edge stringEdge = m_graph.varArgChild(m_node, 2);
11674         Edge startEdge = m_graph.varArgChild(m_node, 3);
11675         Edge endEdge = m_graph.varArgChild(m_node, 4);
11676 
11677         LValue globalObject = lowCell(globalObjectEdge);
11678         LValue regExp = lowCell(regExpEdge);
11679         LValue string = lowCell(stringEdge);
11680         LValue start = lowInt32(startEdge);
11681         LValue end = lowInt32(endEdge);
11682 
11683         m_out.storePtr(regExp, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastRegExp);
11684         m_out.storePtr(string, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastInput);
11685         m_out.store32(start, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_start);
11686         m_out.store32(end, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_end);
11687         m_out.store32As8(
11688             m_out.constInt32(0),
11689             m_out.address(globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_reified));
11690     }
11691 
11692     struct ArgumentsLength {
11693         ArgumentsLength()
11694             : isKnown(false)
11695             , known(UINT_MAX)
11696             , value(nullptr)
11697         {
11698         }
11699 
11700         bool isKnown;
11701         unsigned known;
11702         LValue value;
11703     };
11704     ArgumentsLength getArgumentsLength(InlineCallFrame* inlineCallFrame)
11705     {
11706         ArgumentsLength length;
11707 
11708         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
11709             length.known = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
11710             length.isKnown = true;
11711             length.value = m_out.constInt32(length.known);
11712         } else {
11713             length.known = UINT_MAX;
11714             length.isKnown = false;
11715 
11716             VirtualRegister argumentCountRegister;
11717             if (!inlineCallFrame)
11718                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCount);
11719             else
11720                 argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
11721             length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
11722         }
11723 
11724         return length;
11725     }
11726 
11727     ArgumentsLength getArgumentsLength()
11728     {
11729         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame());
11730     }
11731 
11732     LValue getCurrentCallee()
11733     {
11734         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {
11735             if (frame-&gt;isClosureCall)
11736                 return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
11737             return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
11738         }
11739         return m_out.loadPtr(addressFor(CallFrameSlot::callee));
11740     }
11741 
11742     LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
11743     {
11744         VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
11745         return addressFor(start).value();
11746     }
11747 
11748     LValue getArgumentsStart()
11749     {
11750         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame());
11751     }
11752 
11753     template&lt;typename Functor&gt;
11754     void checkStructure(
11755         LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
11756         const RegisteredStructureSet&amp; set, const Functor&amp; weakStructureDiscriminant)
11757     {
11758         if (set.isEmpty()) {
11759             terminate(exitKind);
11760             return;
11761         }
11762 
11763         if (set.size() == 1) {
11764             speculate(
11765                 exitKind, formattedValue, 0,
11766                 m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set[0])));
11767             return;
11768         }
11769 
11770         LBasicBlock continuation = m_out.newBlock();
11771 
11772         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
11773         for (unsigned i = 0; i &lt; set.size() - 1; ++i) {
11774             LBasicBlock nextStructure = m_out.newBlock();
11775             m_out.branch(
11776                 m_out.equal(structureDiscriminant, weakStructureDiscriminant(set[i])),
11777                 unsure(continuation), unsure(nextStructure));
11778             m_out.appendTo(nextStructure);
11779         }
11780 
11781         speculate(
11782             exitKind, formattedValue, 0,
11783             m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set.last())));
11784 
11785         m_out.jump(continuation);
11786         m_out.appendTo(continuation, lastNext);
11787     }
11788 
11789     LValue numberOrNotCellToInt32(Edge edge, LValue value)
11790     {
11791         LBasicBlock intCase = m_out.newBlock();
11792         LBasicBlock notIntCase = m_out.newBlock();
11793         LBasicBlock doubleCase = 0;
11794         LBasicBlock notNumberCase = 0;
11795         if (edge.useKind() == NotCellUse) {
11796             doubleCase = m_out.newBlock();
11797             notNumberCase = m_out.newBlock();
11798         }
11799         LBasicBlock continuation = m_out.newBlock();
11800 
11801         Vector&lt;ValueFromBlock&gt; results;
11802 
11803         m_out.branch(isNotInt32(value), unsure(notIntCase), unsure(intCase));
11804 
11805         LBasicBlock lastNext = m_out.appendTo(intCase, notIntCase);
11806         results.append(m_out.anchor(unboxInt32(value)));
11807         m_out.jump(continuation);
11808 
11809         if (edge.useKind() == NumberUse) {
11810             m_out.appendTo(notIntCase, continuation);
11811             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isCellOrMisc(value));
11812             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
11813             m_out.jump(continuation);
11814         } else {
11815             m_out.appendTo(notIntCase, doubleCase);
11816             m_out.branch(
11817                 isCellOrMisc(value, provenType(edge)), unsure(notNumberCase), unsure(doubleCase));
11818 
11819             m_out.appendTo(doubleCase, notNumberCase);
11820             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
11821             m_out.jump(continuation);
11822 
11823             m_out.appendTo(notNumberCase, continuation);
11824 
11825             FTL_TYPE_CHECK(jsValueValue(value), edge, ~SpecCellCheck, isCell(value));
11826 
11827             LValue specialResult = m_out.select(
11828                 m_out.equal(value, m_out.constInt64(JSValue::encode(jsBoolean(true)))),
11829                 m_out.int32One, m_out.int32Zero);
11830             results.append(m_out.anchor(specialResult));
11831             m_out.jump(continuation);
11832         }
11833 
11834         m_out.appendTo(continuation, lastNext);
11835         return m_out.phi(Int32, results);
11836     }
11837 
11838     LValue loadProperty(LValue storage, unsigned identifierNumber, PropertyOffset offset)
11839     {
11840         return m_out.load64(addressOfProperty(storage, identifierNumber, offset));
11841     }
11842 
11843     void storeProperty(
11844         LValue value, LValue storage, unsigned identifierNumber, PropertyOffset offset)
11845     {
11846         m_out.store64(value, addressOfProperty(storage, identifierNumber, offset));
11847     }
11848 
11849     TypedPointer addressOfProperty(
11850         LValue storage, unsigned identifierNumber, PropertyOffset offset)
11851     {
11852         return m_out.address(
11853             m_heaps.properties[identifierNumber], storage, offsetRelativeToBase(offset));
11854     }
11855 
11856     LValue storageForTransition(
11857         LValue object, PropertyOffset offset,
11858         Structure* previousStructure, Structure* nextStructure)
11859     {
11860         if (isInlineOffset(offset))
11861             return object;
11862 
11863         if (previousStructure-&gt;outOfLineCapacity() == nextStructure-&gt;outOfLineCapacity())
11864             return m_out.loadPtr(object, m_heaps.JSObject_butterfly);
11865 
11866         LValue result;
11867         if (!previousStructure-&gt;outOfLineCapacity())
11868             result = allocatePropertyStorage(object, previousStructure);
11869         else {
11870             result = reallocatePropertyStorage(
11871                 object, m_out.loadPtr(object, m_heaps.JSObject_butterfly),
11872                 previousStructure, nextStructure);
11873         }
11874 
11875         nukeStructureAndSetButterfly(result, object);
11876         return result;
11877     }
11878 
11879     void initializeArrayElements(LValue indexingType, LValue begin, LValue end, LValue butterfly)
11880     {
11881 
11882         if (begin == end)
11883             return;
11884 
11885         if (indexingType-&gt;hasInt32()) {
11886             IndexingType rawIndexingType = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());
11887             if (hasUndecided(rawIndexingType))
11888                 return;
11889             IndexedAbstractHeap* heap = m_heaps.forIndexingType(rawIndexingType);
11890             DFG_ASSERT(m_graph, m_node, heap);
11891 
11892             LValue hole;
11893             if (hasDouble(rawIndexingType))
11894                 hole = m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN));
11895             else
11896                 hole = m_out.constInt64(JSValue::encode(JSValue()));
11897 
11898             splatWords(butterfly, begin, end, hole, heap-&gt;atAnyIndex());
11899         } else {
11900             LValue hole = m_out.select(
11901                 m_out.equal(m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)), m_out.constInt32(DoubleShape)),
11902                 m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)),
11903                 m_out.constInt64(JSValue::encode(JSValue())));
11904             splatWords(butterfly, begin, end, hole, m_heaps.root);
11905         }
11906     }
11907 
11908     void splatWords(LValue base, LValue begin, LValue end, LValue value, const AbstractHeap&amp; heap)
11909     {
11910         const uint64_t unrollingLimit = 10;
11911         if (begin-&gt;hasInt() &amp;&amp; end-&gt;hasInt()) {
11912             uint64_t beginConst = static_cast&lt;uint64_t&gt;(begin-&gt;asInt());
11913             uint64_t endConst = static_cast&lt;uint64_t&gt;(end-&gt;asInt());
11914 
11915             if (endConst - beginConst &lt;= unrollingLimit) {
11916                 for (uint64_t i = beginConst; i &lt; endConst; ++i) {
11917                     LValue pointer = m_out.add(base, m_out.constIntPtr(i * sizeof(uint64_t)));
11918                     m_out.store64(value, TypedPointer(heap, pointer));
11919                 }
11920                 return;
11921             }
11922         }
11923 
11924         LBasicBlock initLoop = m_out.newBlock();
11925         LBasicBlock initDone = m_out.newBlock();
11926 
11927         LBasicBlock lastNext = m_out.insertNewBlocksBefore(initLoop);
11928 
11929         ValueFromBlock originalIndex = m_out.anchor(end);
11930         ValueFromBlock originalPointer = m_out.anchor(
11931             m_out.add(base, m_out.shl(m_out.signExt32ToPtr(begin), m_out.constInt32(3))));
11932         m_out.branch(m_out.notEqual(end, begin), unsure(initLoop), unsure(initDone));
11933 
11934         m_out.appendTo(initLoop, initDone);
11935         LValue index = m_out.phi(Int32, originalIndex);
11936         LValue pointer = m_out.phi(pointerType(), originalPointer);
11937 
11938         m_out.store64(value, TypedPointer(heap, pointer));
11939 
11940         LValue nextIndex = m_out.sub(index, m_out.int32One);
11941         m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
11942         m_out.addIncomingToPhi(pointer, m_out.anchor(m_out.add(pointer, m_out.intPtrEight)));
11943         m_out.branch(
11944             m_out.notEqual(nextIndex, begin), unsure(initLoop), unsure(initDone));
11945 
11946         m_out.appendTo(initDone, lastNext);
11947     }
11948 
11949     LValue allocatePropertyStorage(LValue object, Structure* previousStructure)
11950     {
11951         if (previousStructure-&gt;couldHaveIndexingHeader()) {
11952             return vmCall(
11953                 pointerType(),
11954                 m_out.operation(operationAllocateComplexPropertyStorageWithInitialCapacity),
11955                 m_callFrame, object);
11956         }
11957 
11958         LValue result = allocatePropertyStorageWithSizeImpl(initialOutOfLineCapacity);
11959 
11960         splatWords(
11961             result,
11962             m_out.constInt32(-initialOutOfLineCapacity - 1), m_out.constInt32(-1),
11963             m_out.int64Zero, m_heaps.properties.atAnyNumber());
11964 
11965         return result;
11966     }
11967 
11968     LValue reallocatePropertyStorage(
11969         LValue object, LValue oldStorage, Structure* previous, Structure* next)
11970     {
11971         size_t oldSize = previous-&gt;outOfLineCapacity();
11972         size_t newSize = oldSize * outOfLineGrowthFactor;
11973 
11974         ASSERT_UNUSED(next, newSize == next-&gt;outOfLineCapacity());
11975 
11976         if (previous-&gt;couldHaveIndexingHeader()) {
11977             LValue newAllocSize = m_out.constIntPtr(newSize);
11978             return vmCall(pointerType(), m_out.operation(operationAllocateComplexPropertyStorage), m_callFrame, object, newAllocSize);
11979         }
11980 
11981         LValue result = allocatePropertyStorageWithSizeImpl(newSize);
11982 
11983         ptrdiff_t headerSize = -sizeof(IndexingHeader) - sizeof(void*);
11984         ptrdiff_t endStorage = headerSize - static_cast&lt;ptrdiff_t&gt;(oldSize * sizeof(JSValue));
11985 
11986         for (ptrdiff_t offset = headerSize; offset &gt; endStorage; offset -= sizeof(void*)) {
11987             LValue loaded =
11988                 m_out.loadPtr(m_out.address(m_heaps.properties.atAnyNumber(), oldStorage, offset));
11989             m_out.storePtr(loaded, m_out.address(m_heaps.properties.atAnyNumber(), result, offset));
11990         }
11991 
11992         splatWords(
11993             result,
11994             m_out.constInt32(-newSize - 1), m_out.constInt32(-oldSize - 1),
11995             m_out.int64Zero, m_heaps.properties.atAnyNumber());
11996 
11997         return result;
11998     }
11999 
12000     LValue allocatePropertyStorageWithSizeImpl(size_t sizeInValues)
12001     {
12002         LBasicBlock slowPath = m_out.newBlock();
12003         LBasicBlock continuation = m_out.newBlock();
12004 
12005         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
12006 
12007         size_t sizeInBytes = sizeInValues * sizeof(JSValue);
12008         Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(sizeInBytes, AllocatorForMode::AllocatorIfExists);
12009         LValue startOfStorage = allocateHeapCell(
12010             m_out.constIntPtr(allocator.localAllocator()), slowPath);
12011         ValueFromBlock fastButterfly = m_out.anchor(
12012             m_out.add(m_out.constIntPtr(sizeInBytes + sizeof(IndexingHeader)), startOfStorage));
12013         m_out.jump(continuation);
12014 
12015         m_out.appendTo(slowPath, continuation);
12016 
12017         LValue slowButterflyValue;
12018         VM&amp; vm = this-&gt;vm();
12019         if (sizeInValues == initialOutOfLineCapacity) {
12020             slowButterflyValue = lazySlowPath(
12021                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12022                     return createLazyCallGenerator(vm,
12023                         operationAllocateSimplePropertyStorageWithInitialCapacity,
12024                         locations[0].directGPR());
12025                 });
12026         } else {
12027             slowButterflyValue = lazySlowPath(
12028                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12029                     return createLazyCallGenerator(vm,
12030                         operationAllocateSimplePropertyStorage, locations[0].directGPR(),
12031                         CCallHelpers::TrustedImmPtr(sizeInValues));
12032                 });
12033         }
12034         ValueFromBlock slowButterfly = m_out.anchor(slowButterflyValue);
12035 
12036         m_out.jump(continuation);
12037 
12038         m_out.appendTo(continuation, lastNext);
12039 
12040         return m_out.phi(pointerType(), fastButterfly, slowButterfly);
12041     }
12042 
12043     LValue getById(LValue base, AccessType type)
12044     {
12045         Node* node = m_node;
12046         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
12047 
12048         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12049         patchpoint-&gt;appendSomeRegister(base);
12050         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
12051         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
12052 
12053         // FIXME: If this is a GetByIdFlush/GetByIdDirectFlush, we might get some performance boost if we claim that it
12054         // clobbers volatile registers late. It&#39;s not necessary for correctness, though, since the
12055         // IC code is super smart about saving registers.
12056         // https://bugs.webkit.org/show_bug.cgi?id=152848
12057 
12058         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12059 
12060         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12061             preparePatchpointForExceptions(patchpoint);
12062 
12063         State* state = &amp;m_ftlState;
12064         patchpoint-&gt;setGenerator(
12065             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12066                 AllowMacroScratchRegisterUsage allowScratch(jit);
12067 
12068                 CallSiteIndex callSiteIndex =
12069                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
12070 
12071                 // This is the direct exit target for operation calls.
12072                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12073                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12074 
12075                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
12076                 // to do anything weird other than call this, since it will associate the exit with
12077                 // the callsite index.
12078                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
12079 
12080                 auto generator = Box&lt;JITGetByIdGenerator&gt;::create(
12081                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
12082                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
12083                     JSValueRegs(params[0].gpr()), type);
12084 
12085                 generator-&gt;generateFastPath(jit);
12086                 CCallHelpers::Label done = jit.label();
12087 
12088                 params.addLatePath(
12089                     [=] (CCallHelpers&amp; jit) {
12090                         AllowMacroScratchRegisterUsage allowScratch(jit);
12091 
12092                         J_JITOperation_ESsiJI optimizationFunction = appropriateOptimizingGetByIdFunction(type);
12093 
12094                         generator-&gt;slowPathJump().link(&amp;jit);
12095                         CCallHelpers::Label slowPathBegin = jit.label();
12096                         CCallHelpers::Call slowPathCall = callOperation(
12097                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
12098                             exceptions.get(), optimizationFunction, params[0].gpr(),
12099                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
12100                             CCallHelpers::TrustedImmPtr(uid)).call();
12101                         jit.jump().linkTo(done, &amp;jit);
12102 
12103                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
12104 
12105                         jit.addLinkTask(
12106                             [=] (LinkBuffer&amp; linkBuffer) {
12107                                 generator-&gt;finalize(linkBuffer, linkBuffer);
12108                             });
12109                     });
12110             });
12111 
12112         return patchpoint;
12113     }
12114 
12115     LValue getByIdWithThis(LValue base, LValue thisValue)
12116     {
12117         Node* node = m_node;
12118         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
12119 
12120         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12121         patchpoint-&gt;appendSomeRegister(base);
12122         patchpoint-&gt;appendSomeRegister(thisValue);
12123         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
12124         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
12125 
12126         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12127 
12128         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12129             preparePatchpointForExceptions(patchpoint);
12130 
12131         State* state = &amp;m_ftlState;
12132         patchpoint-&gt;setGenerator(
12133             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12134                 AllowMacroScratchRegisterUsage allowScratch(jit);
12135 
12136                 CallSiteIndex callSiteIndex =
12137                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
12138 
12139                 // This is the direct exit target for operation calls.
12140                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12141                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12142 
12143                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
12144                 // to do anything weird other than call this, since it will associate the exit with
12145                 // the callsite index.
12146                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
12147 
12148                 auto generator = Box&lt;JITGetByIdWithThisGenerator&gt;::create(
12149                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
12150                     params.unavailableRegisters(), uid, JSValueRegs(params[0].gpr()),
12151                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), AccessType::GetWithThis);
12152 
12153                 generator-&gt;generateFastPath(jit);
12154                 CCallHelpers::Label done = jit.label();
12155 
12156                 params.addLatePath(
12157                     [=] (CCallHelpers&amp; jit) {
12158                         AllowMacroScratchRegisterUsage allowScratch(jit);
12159 
12160                         J_JITOperation_ESsiJJI optimizationFunction = operationGetByIdWithThisOptimize;
12161 
12162                         generator-&gt;slowPathJump().link(&amp;jit);
12163                         CCallHelpers::Label slowPathBegin = jit.label();
12164                         CCallHelpers::Call slowPathCall = callOperation(
12165                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
12166                             exceptions.get(), optimizationFunction, params[0].gpr(),
12167                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
12168                             params[2].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
12169                         jit.jump().linkTo(done, &amp;jit);
12170 
12171                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
12172 
12173                         jit.addLinkTask(
12174                             [=] (LinkBuffer&amp; linkBuffer) {
12175                                 generator-&gt;finalize(linkBuffer, linkBuffer);
12176                             });
12177                     });
12178             });
12179 
12180         return patchpoint;
12181     }
12182 
12183     LValue isFastTypedArray(LValue object)
12184     {
12185         return m_out.equal(
12186             m_out.load32(object, m_heaps.JSArrayBufferView_mode),
12187             m_out.constInt32(FastTypedArray));
12188     }
12189 
12190     TypedPointer baseIndex(IndexedAbstractHeap&amp; heap, LValue storage, LValue index, Edge edge, ptrdiff_t offset = 0)
12191     {
12192         return m_out.baseIndex(
12193             heap, storage, m_out.zeroExtPtr(index), provenValue(edge), offset);
12194     }
12195 
12196     template&lt;typename IntFunctor, typename DoubleFunctor&gt;
12197     void compare(
12198         const IntFunctor&amp; intFunctor, const DoubleFunctor&amp; doubleFunctor,
12199         C_JITOperation_TT stringIdentFunction,
12200         C_JITOperation_B_EJssJss stringFunction,
12201         S_JITOperation_EJJ fallbackFunction)
12202     {
12203         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
12204             LValue left = lowInt32(m_node-&gt;child1());
12205             LValue right = lowInt32(m_node-&gt;child2());
12206             setBoolean(intFunctor(left, right));
12207             return;
12208         }
12209 
12210         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
12211             Int52Kind kind;
12212             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
12213             LValue right = lowInt52(m_node-&gt;child2(), kind);
12214             setBoolean(intFunctor(left, right));
12215             return;
12216         }
12217 
12218         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
12219             LValue left = lowDouble(m_node-&gt;child1());
12220             LValue right = lowDouble(m_node-&gt;child2());
12221             setBoolean(doubleFunctor(left, right));
12222             return;
12223         }
12224 
12225         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
12226             LValue left = lowStringIdent(m_node-&gt;child1());
12227             LValue right = lowStringIdent(m_node-&gt;child2());
12228             setBoolean(m_out.callWithoutSideEffects(Int32, stringIdentFunction, left, right));
12229             return;
12230         }
12231 
12232         if (m_node-&gt;isBinaryUseKind(StringUse)) {
12233             LValue left = lowCell(m_node-&gt;child1());
12234             LValue right = lowCell(m_node-&gt;child2());
12235             speculateString(m_node-&gt;child1(), left);
12236             speculateString(m_node-&gt;child2(), right);
12237 
12238             LValue result = vmCall(
12239                 Int32, m_out.operation(stringFunction),
12240                 m_callFrame, left, right);
12241             setBoolean(result);
12242             return;
12243         }
12244 
12245         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
12246         nonSpeculativeCompare(intFunctor, fallbackFunction);
12247     }
12248 
12249     void compileStringSlice()
12250     {
12251         LBasicBlock lengthCheckCase = m_out.newBlock();
12252         LBasicBlock emptyCase = m_out.newBlock();
12253         LBasicBlock notEmptyCase = m_out.newBlock();
12254         LBasicBlock oneCharCase = m_out.newBlock();
12255         LBasicBlock is8Bit = m_out.newBlock();
12256         LBasicBlock is16Bit = m_out.newBlock();
12257         LBasicBlock bitsContinuation = m_out.newBlock();
12258         LBasicBlock bigCharacter = m_out.newBlock();
12259         LBasicBlock slowCase = m_out.newBlock();
12260         LBasicBlock ropeSlowCase = m_out.newBlock();
12261         LBasicBlock continuation = m_out.newBlock();
12262 
12263         LValue string = lowString(m_node-&gt;child1());
12264         LValue start = lowInt32(m_node-&gt;child2());
12265         LValue end = nullptr;
12266         if (m_node-&gt;child3())
12267             end = lowInt32(m_node-&gt;child3());
12268         else
12269             end = m_out.constInt32(std::numeric_limits&lt;int32_t&gt;::max());
12270         m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropeSlowCase), usually(lengthCheckCase));
12271 
12272         LBasicBlock lastNext = m_out.appendTo(lengthCheckCase, emptyCase);
12273         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
12274         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);
12275         auto range = populateSliceRange(start, end, length);
12276         LValue from = range.first;
12277         LValue to = range.second;
12278         LValue span = m_out.sub(to, from);
12279         m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
12280 
12281         Vector&lt;ValueFromBlock, 5&gt; results;
12282 
12283         m_out.appendTo(emptyCase, notEmptyCase);
12284         results.append(m_out.anchor(weakPointer(jsEmptyString(vm()))));
12285         m_out.jump(continuation);
12286 
12287         m_out.appendTo(notEmptyCase, oneCharCase);
12288         m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
12289 
12290         m_out.appendTo(oneCharCase, is8Bit);
12291         LValue storage = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
12292         m_out.branch(
12293             m_out.testIsZero32(
12294                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
12295                 m_out.constInt32(StringImpl::flagIs8Bit())),
12296             unsure(is16Bit), unsure(is8Bit));
12297 
12298         m_out.appendTo(is8Bit, is16Bit);
12299         ValueFromBlock char8Bit = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, storage, m_out.zeroExtPtr(from))));
12300         m_out.jump(bitsContinuation);
12301 
12302         m_out.appendTo(is16Bit, bigCharacter);
12303         LValue char16BitValue = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(from)));
12304         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
12305         m_out.branch(
12306             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
12307             rarely(bigCharacter), usually(bitsContinuation));
12308 
12309         m_out.appendTo(bigCharacter, bitsContinuation);
12310         results.append(m_out.anchor(vmCall(
12311             Int64, m_out.operation(operationSingleCharacterString),
12312             m_callFrame, char16BitValue)));
12313         m_out.jump(continuation);
12314 
12315         m_out.appendTo(bitsContinuation, slowCase);
12316         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
12317         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
12318         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
12319             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
12320         m_out.jump(continuation);
12321 
12322         m_out.appendTo(slowCase, ropeSlowCase);
12323         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSubstr), m_callFrame, string, from, span)));
12324         m_out.jump(continuation);
12325 
12326         m_out.appendTo(ropeSlowCase, continuation);
12327         results.append(m_out.anchor(vmCall(pointerType(), m_out.operation(operationStringSlice), m_callFrame, string, start, end)));
12328         m_out.jump(continuation);
12329 
12330         m_out.appendTo(continuation, lastNext);
12331         setJSValue(m_out.phi(pointerType(), results));
12332     }
12333 
12334     void compileToLowerCase()
12335     {
12336         LBasicBlock notRope = m_out.newBlock();
12337         LBasicBlock is8Bit = m_out.newBlock();
12338         LBasicBlock loopTop = m_out.newBlock();
12339         LBasicBlock loopBody = m_out.newBlock();
12340         LBasicBlock slowPath = m_out.newBlock();
12341         LBasicBlock continuation = m_out.newBlock();
12342 
12343         LValue string = lowString(m_node-&gt;child1());
12344         ValueFromBlock startIndex = m_out.anchor(m_out.constInt32(0));
12345         ValueFromBlock startIndexForCall = m_out.anchor(m_out.constInt32(0));
12346         m_out.branch(isRopeString(string, m_node-&gt;child1()),
12347             unsure(slowPath), unsure(notRope));
12348 
12349         LBasicBlock lastNext = m_out.appendTo(notRope, is8Bit);
12350         LValue impl = m_out.loadPtr(string, m_heaps.JSString_value);
12351         m_out.branch(
12352             m_out.testIsZero32(
12353                 m_out.load32(impl, m_heaps.StringImpl_hashAndFlags),
12354                 m_out.constInt32(StringImpl::flagIs8Bit())),
12355             unsure(slowPath), unsure(is8Bit));
12356 
12357         m_out.appendTo(is8Bit, loopTop);
12358         LValue length = m_out.load32(impl, m_heaps.StringImpl_length);
12359         LValue buffer = m_out.loadPtr(impl, m_heaps.StringImpl_data);
12360         ValueFromBlock fastResult = m_out.anchor(string);
12361         m_out.jump(loopTop);
12362 
12363         m_out.appendTo(loopTop, loopBody);
12364         LValue index = m_out.phi(Int32, startIndex);
12365         ValueFromBlock indexFromBlock = m_out.anchor(index);
12366         m_out.branch(m_out.below(index, length),
12367             unsure(loopBody), unsure(continuation));
12368 
12369         m_out.appendTo(loopBody, slowPath);
12370 
12371         // FIXME: Strings needs to be caged.
12372         // https://bugs.webkit.org/show_bug.cgi?id=174924
12373         LValue byte = m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, buffer, m_out.zeroExtPtr(index)));
12374         LValue isInvalidAsciiRange = m_out.bitAnd(byte, m_out.constInt32(~0x7F));
12375         LValue isUpperCase = m_out.belowOrEqual(m_out.sub(byte, m_out.constInt32(&#39;A&#39;)), m_out.constInt32(&#39;Z&#39; - &#39;A&#39;));
12376         LValue isBadCharacter = m_out.bitOr(isInvalidAsciiRange, isUpperCase);
12377         m_out.addIncomingToPhi(index, m_out.anchor(m_out.add(index, m_out.int32One)));
12378         m_out.branch(isBadCharacter, unsure(slowPath), unsure(loopTop));
12379 
12380         m_out.appendTo(slowPath, continuation);
12381         LValue slowPathIndex = m_out.phi(Int32, startIndexForCall, indexFromBlock);
12382         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_out.operation(operationToLowerCase), m_callFrame, string, slowPathIndex));
12383         m_out.jump(continuation);
12384 
12385         m_out.appendTo(continuation, lastNext);
12386         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
12387     }
12388 
12389     void compileNumberToStringWithRadix()
12390     {
12391         bool validRadixIsGuaranteed = false;
12392         if (m_node-&gt;child2()-&gt;isInt32Constant()) {
12393             int32_t radix = m_node-&gt;child2()-&gt;asInt32();
12394             if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
12395                 validRadixIsGuaranteed = true;
12396         }
12397 
12398         switch (m_node-&gt;child1().useKind()) {
12399         case Int32Use:
12400             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString), m_callFrame, lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12401             break;
12402         case Int52RepUse:
12403             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString), m_callFrame, lowStrictInt52(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12404             break;
12405         case DoubleRepUse:
12406             setJSValue(vmCall(pointerType(), m_out.operation(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString), m_callFrame, lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
12407             break;
12408         default:
12409             RELEASE_ASSERT_NOT_REACHED();
12410         }
12411     }
12412 
12413     void compileNumberToStringWithValidRadixConstant()
12414     {
12415         switch (m_node-&gt;child1().useKind()) {
12416         case Int32Use:
12417             setJSValue(vmCall(pointerType(), m_out.operation(operationInt32ToStringWithValidRadix), m_callFrame, lowInt32(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12418             break;
12419         case Int52RepUse:
12420             setJSValue(vmCall(pointerType(), m_out.operation(operationInt52ToStringWithValidRadix), m_callFrame, lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12421             break;
12422         case DoubleRepUse:
12423             setJSValue(vmCall(pointerType(), m_out.operation(operationDoubleToStringWithValidRadix), m_callFrame, lowDouble(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));
12424             break;
12425         default:
12426             RELEASE_ASSERT_NOT_REACHED();
12427         }
12428     }
12429 
12430     void compileResolveScopeForHoistingFuncDeclInEval()
12431     {
12432         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12433         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScopeForHoistingFuncDeclInEval), m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12434     }
12435 
12436     void compileResolveScope()
12437     {
12438         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12439         setJSValue(vmCall(pointerType(), m_out.operation(operationResolveScope),
12440             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));
12441     }
12442 
12443     void compileGetDynamicVar()
12444     {
12445         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12446         setJSValue(vmCall(Int64, m_out.operation(operationGetDynamicVar),
12447             m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12448     }
12449 
12450     void compilePutDynamicVar()
12451     {
12452         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
12453         setJSValue(vmCall(Void, m_out.operation(m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict),
12454             m_callFrame, lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));
12455     }
12456 
12457     void compileUnreachable()
12458     {
12459         // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
12460         // simply not a requirement of the Unreachable opcode at all. If you emit an opcode that
12461         // *you* know will not return, then it&#39;s fine to end the basic block with Unreachable
12462         // after that opcode. You don&#39;t have to also prove to AI that your opcode does not return.
12463         // Hence, there is nothing to do here but emit code that will crash, so that we catch
12464         // cases where you said Unreachable but you lied.
12465         //
12466         // It&#39;s also also worth noting that some clients emit this opcode because they&#39;re not 100% sure
12467         // if the code is unreachable, but they would really prefer if we crashed rather than kept going
12468         // if it did turn out to be reachable. Hence, this needs to deterministically crash.
12469 
12470         crash();
12471     }
12472 
12473     void compileCheckSubClass()
12474     {
12475         LValue cell = lowCell(m_node-&gt;child1());
12476 
12477         const ClassInfo* classInfo = m_node-&gt;classInfo();
12478         if (!classInfo-&gt;checkSubClassSnippet) {
12479             LBasicBlock loop = m_out.newBlock();
12480             LBasicBlock parentClass = m_out.newBlock();
12481             LBasicBlock continuation = m_out.newBlock();
12482 
12483             LValue structure = loadStructure(cell);
12484             LValue classInfo = m_out.loadPtr(structure, m_heaps.Structure_classInfo);
12485             ValueFromBlock otherAtStart = m_out.anchor(classInfo);
12486             m_out.jump(loop);
12487 
12488             LBasicBlock lastNext = m_out.appendTo(loop, parentClass);
12489             LValue other = m_out.phi(pointerType(), otherAtStart);
12490             m_out.branch(m_out.equal(other, m_out.constIntPtr(classInfo)), unsure(continuation), unsure(parentClass));
12491 
12492             m_out.appendTo(parentClass, continuation);
12493             LValue parent = m_out.loadPtr(other, m_heaps.ClassInfo_parentClass);
12494             speculate(BadType, jsValueValue(cell), m_node-&gt;child1().node(), m_out.isNull(parent));
12495             m_out.addIncomingToPhi(other, m_out.anchor(parent));
12496             m_out.jump(loop);
12497 
12498             m_out.appendTo(continuation, lastNext);
12499             return;
12500         }
12501 
12502         RefPtr&lt;Snippet&gt; domJIT = classInfo-&gt;checkSubClassSnippet();
12503         PatchpointValue* patchpoint = m_out.patchpoint(Void);
12504         patchpoint-&gt;appendSomeRegister(cell);
12505         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12506         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12507 
12508         NodeOrigin origin = m_origin;
12509         unsigned osrExitArgumentOffset = patchpoint-&gt;numChildren();
12510         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(jsValueValue(cell), m_node-&gt;child1().node());
12511         patchpoint-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, jsValueValue(cell)));
12512 
12513         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12514         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
12515         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12516 
12517         State* state = &amp;m_ftlState;
12518         Node* node = m_node;
12519         JSValue child1Constant = m_state.forNode(m_node-&gt;child1()).value();
12520 
12521         patchpoint-&gt;setGenerator(
12522             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12523                 AllowMacroScratchRegisterUsage allowScratch(jit);
12524 
12525                 Vector&lt;GPRReg&gt; gpScratch;
12526                 Vector&lt;FPRReg&gt; fpScratch;
12527                 Vector&lt;SnippetParams::Value&gt; regs;
12528 
12529                 regs.append(SnippetParams::Value(params[0].gpr(), child1Constant));
12530 
12531                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12532                     gpScratch.append(params.gpScratch(i));
12533 
12534                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
12535                     fpScratch.append(params.fpScratch(i));
12536 
12537                 RefPtr&lt;OSRExitHandle&gt; handle = exitDescriptor-&gt;emitOSRExitLater(*state, BadType, origin, params, osrExitArgumentOffset);
12538 
12539                 SnippetParams domJITParams(*state, params, node, nullptr, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
12540                 CCallHelpers::JumpList failureCases = domJIT-&gt;generator()-&gt;run(jit, domJITParams);
12541 
12542                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
12543                     linkBuffer.link(failureCases, linkBuffer.locationOf&lt;NoPtrTag&gt;(handle-&gt;label));
12544                 });
12545             });
12546         patchpoint-&gt;effects = Effects::forCheck();
12547     }
12548 
12549     void compileCallDOM()
12550     {
12551         const DOMJIT::Signature* signature = m_node-&gt;signature();
12552 
12553         // FIXME: We should have a way to call functions with the vector of registers.
12554         // https://bugs.webkit.org/show_bug.cgi?id=163099
12555         Vector&lt;LValue, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
12556 
12557         unsigned index = 0;
12558         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, [&amp;](Node*, Edge edge) {
12559             if (!index)
12560                 operands.append(lowCell(edge));
12561             else {
12562                 switch (signature-&gt;arguments[index - 1]) {
12563                 case SpecString:
12564                     operands.append(lowString(edge));
12565                     break;
12566                 case SpecInt32Only:
12567                     operands.append(lowInt32(edge));
12568                     break;
12569                 case SpecBoolean:
12570                     operands.append(lowBoolean(edge));
12571                     break;
12572                 default:
12573                     RELEASE_ASSERT_NOT_REACHED();
12574                     break;
12575                 }
12576             }
12577             ++index;
12578         });
12579 
12580         unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
12581         LValue result;
12582         auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
12583         switch (argumentCountIncludingThis) {
12584         case 1:
12585             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EP&gt;(function.get())), m_callFrame, operands[0]);
12586             break;
12587         case 2:
12588             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPP&gt;(function.get())), m_callFrame, operands[0], operands[1]);
12589             break;
12590         case 3:
12591             result = vmCall(Int64, m_out.operation(reinterpret_cast&lt;J_JITOperation_EPPP&gt;(function.get())), m_callFrame, operands[0], operands[1], operands[2]);
12592             break;
12593         default:
12594             RELEASE_ASSERT_NOT_REACHED();
12595             break;
12596         }
12597 
12598         setJSValue(result);
12599     }
12600 
12601     void compileCallDOMGetter()
12602     {
12603         DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
12604         if (!domJIT) {
12605             // The following function is not an operation: we directly call a custom accessor getter.
12606             // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
12607             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
12608             setJSValue(
12609                 vmCall(Int64, m_out.operation(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),
12610                     m_callFrame, lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));
12611             return;
12612         }
12613 
12614         Edge&amp; baseEdge = m_node-&gt;child1();
12615         LValue base = lowCell(baseEdge);
12616         JSValue baseConstant = m_state.forNode(baseEdge).value();
12617 
12618         LValue globalObject;
12619         JSValue globalObjectConstant;
12620         if (domJIT-&gt;requireGlobalObject) {
12621             Edge&amp; globalObjectEdge = m_node-&gt;child2();
12622             globalObject = lowCell(globalObjectEdge);
12623             globalObjectConstant = m_state.forNode(globalObjectEdge).value();
12624         }
12625 
12626         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12627         patchpoint-&gt;appendSomeRegister(base);
12628         if (domJIT-&gt;requireGlobalObject)
12629             patchpoint-&gt;appendSomeRegister(globalObject);
12630         patchpoint-&gt;append(m_tagMask, ValueRep::reg(GPRInfo::tagMaskRegister));
12631         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::reg(GPRInfo::tagTypeNumberRegister));
12632         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
12633         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12634         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
12635         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
12636         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
12637 
12638         State* state = &amp;m_ftlState;
12639         Node* node = m_node;
12640         patchpoint-&gt;setGenerator(
12641             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12642                 AllowMacroScratchRegisterUsage allowScratch(jit);
12643 
12644                 Vector&lt;GPRReg&gt; gpScratch;
12645                 Vector&lt;FPRReg&gt; fpScratch;
12646                 Vector&lt;SnippetParams::Value&gt; regs;
12647 
12648                 regs.append(JSValueRegs(params[0].gpr()));
12649                 regs.append(SnippetParams::Value(params[1].gpr(), baseConstant));
12650                 if (domJIT-&gt;requireGlobalObject)
12651                     regs.append(SnippetParams::Value(params[2].gpr(), globalObjectConstant));
12652 
12653                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
12654                     gpScratch.append(params.gpScratch(i));
12655 
12656                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
12657                     fpScratch.append(params.fpScratch(i));
12658 
12659                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12660 
12661                 SnippetParams domJITParams(*state, params, node, exceptions, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
12662                 domJIT-&gt;generator()-&gt;run(jit, domJITParams);
12663             });
12664         patchpoint-&gt;effects = Effects::forCall();
12665         setJSValue(patchpoint);
12666     }
12667 
12668     void compileFilterICStatus()
12669     {
12670         m_interpreter.filterICStatus(m_node);
12671     }
12672 
12673     LValue byteSwap32(LValue value)
12674     {
12675         // FIXME: teach B3 byteswap
12676         // https://bugs.webkit.org/show_bug.cgi?id=188759
12677 
12678         RELEASE_ASSERT(value-&gt;type() == Int32);
12679         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12680         patchpoint-&gt;appendSomeRegister(value);
12681         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12682             jit.move(params[1].gpr(), params[0].gpr());
12683             jit.byteSwap32(params[0].gpr());
12684         });
12685         patchpoint-&gt;effects = Effects::none();
12686         return patchpoint;
12687     }
12688 
12689     LValue byteSwap64(LValue value)
12690     {
12691         // FIXME: teach B3 byteswap
12692         // https://bugs.webkit.org/show_bug.cgi?id=188759
12693 
12694         RELEASE_ASSERT(value-&gt;type() == Int64);
12695         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12696         patchpoint-&gt;appendSomeRegister(value);
12697         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12698             jit.move(params[1].gpr(), params[0].gpr());
12699             jit.byteSwap64(params[0].gpr());
12700         });
12701         patchpoint-&gt;effects = Effects::none();
12702         return patchpoint;
12703     }
12704 
12705     template &lt;typename F1, typename F2&gt;
12706     LValue emitCodeBasedOnEndiannessBranch(LValue isLittleEndian, const F1&amp; emitLittleEndianCode, const F2&amp; emitBigEndianCode)
12707     {
12708         LType type;
12709 
12710         LBasicBlock bigEndianCase = m_out.newBlock();
12711         LBasicBlock littleEndianCase = m_out.newBlock();
12712         LBasicBlock continuation = m_out.newBlock();
12713 
12714         m_out.branch(m_out.testIsZero32(isLittleEndian, m_out.constInt32(1)),
12715             unsure(bigEndianCase), unsure(littleEndianCase));
12716 
12717         LBasicBlock lastNext = m_out.appendTo(bigEndianCase, littleEndianCase);
12718         LValue bigEndianValue = emitBigEndianCode();
12719         type = bigEndianValue ? bigEndianValue-&gt;type() : Void;
12720         ValueFromBlock bigEndianResult = bigEndianValue ? m_out.anchor(bigEndianValue) : ValueFromBlock();
12721         m_out.jump(continuation);
12722 
12723         m_out.appendTo(littleEndianCase, continuation);
12724         LValue littleEndianValue = emitLittleEndianCode();
12725         ValueFromBlock littleEndianResult = littleEndianValue ? m_out.anchor(littleEndianValue) : ValueFromBlock();
12726         RELEASE_ASSERT((!littleEndianValue &amp;&amp; !bigEndianValue) || type == littleEndianValue-&gt;type());
12727         m_out.jump(continuation);
12728 
12729         m_out.appendTo(continuation, lastNext);
12730         RELEASE_ASSERT(!!bigEndianResult == !!littleEndianResult);
12731         if (bigEndianResult)
12732             return m_out.phi(type, bigEndianResult, littleEndianResult);
12733         return nullptr;
12734     }
12735 
12736     void compileDataViewGet()
12737     {
12738         LValue dataView = lowDataViewObject(m_node-&gt;child1());
12739         LValue index = lowInt32(m_node-&gt;child2());
12740         LValue isLittleEndian = nullptr;
12741         if (m_node-&gt;child3())
12742             isLittleEndian = lowBoolean(m_node-&gt;child3());
12743 
12744         DataViewData data = m_node-&gt;dataViewData();
12745 
12746         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12747         LValue indexToCheck = m_out.zeroExtPtr(index);
12748         if (data.byteSize &gt; 1)
12749             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12750         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12751 
12752         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);
12753 
12754         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12755 
12756         if (m_node-&gt;op() == DataViewGetInt) {
12757             switch (data.byteSize) {
12758             case 1:
12759                 if (data.isSigned)
12760                     setInt32(m_out.load8SignExt32(pointer));
12761                 else
12762                     setInt32(m_out.load8ZeroExt32(pointer));
12763                 break;
12764             case 2: {
12765                 auto emitLittleEndianLoad = [&amp;] {
12766                     if (data.isSigned)
12767                         return m_out.load16SignExt32(pointer);
12768                     return m_out.load16ZeroExt32(pointer);
12769                 };
12770 
12771                 auto emitBigEndianLoad = [&amp;] {
12772                     LValue val = m_out.load16ZeroExt32(pointer);
12773 
12774                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12775                     patchpoint-&gt;appendSomeRegister(val);
12776                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12777                         jit.move(params[1].gpr(), params[0].gpr());
12778                         jit.byteSwap16(params[0].gpr());
12779                         if (data.isSigned)
12780                             jit.signExtend16To32(params[0].gpr(), params[0].gpr());
12781                     });
12782                     patchpoint-&gt;effects = Effects::none();
12783 
12784                     return patchpoint;
12785                 };
12786 
12787                 if (data.isLittleEndian == FalseTriState)
12788                     setInt32(emitBigEndianLoad());
12789                 else if (data.isLittleEndian == TrueTriState)
12790                     setInt32(emitLittleEndianLoad());
12791                 else
12792                     setInt32(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianLoad, emitBigEndianLoad));
12793 
12794                 break;
12795             }
12796             case 4: {
12797                 LValue loadedValue = m_out.load32(pointer);
12798 
12799                 if (data.isLittleEndian == FalseTriState)
12800                     loadedValue = byteSwap32(loadedValue);
12801                 else if (data.isLittleEndian == MixedTriState) {
12802                     auto emitLittleEndianCode = [&amp;] {
12803                         return loadedValue;
12804                     };
12805                     auto emitBigEndianCode = [&amp;] {
12806                         return byteSwap32(loadedValue);
12807                     };
12808 
12809                     loadedValue = emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12810                 }
12811 
12812                 if (data.isSigned)
12813                     setInt32(loadedValue);
12814                 else
12815                     setStrictInt52(m_out.zeroExt(loadedValue, Int64));
12816 
12817                 break;
12818             }
12819             default:
12820                 RELEASE_ASSERT_NOT_REACHED();
12821             }
12822         } else {
12823             switch (data.byteSize) {
12824             case 4: {
12825                 auto emitLittleEndianCode = [&amp;] {
12826                     return m_out.floatToDouble(m_out.loadFloat(pointer));
12827                 };
12828 
12829                 auto emitBigEndianCode = [&amp;] {
12830                     LValue loadedValue = m_out.load32(pointer);
12831                     PatchpointValue* patchpoint = m_out.patchpoint(Double);
12832                     patchpoint-&gt;appendSomeRegister(loadedValue);
12833                     patchpoint-&gt;numGPScratchRegisters = 1;
12834                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12835                         jit.move(params[1].gpr(), params.gpScratch(0));
12836                         jit.byteSwap32(params.gpScratch(0));
12837                         jit.move32ToFloat(params.gpScratch(0), params[0].fpr());
12838                         jit.convertFloatToDouble(params[0].fpr(), params[0].fpr());
12839                     });
12840                     patchpoint-&gt;effects = Effects::none();
12841                     return patchpoint;
12842                 };
12843 
12844                 if (data.isLittleEndian == TrueTriState)
12845                     setDouble(emitLittleEndianCode());
12846                 else if (data.isLittleEndian == FalseTriState)
12847                     setDouble(emitBigEndianCode());
12848                 else
12849                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
12850 
12851                 break;
12852             }
12853             case 8: {
12854                 auto emitLittleEndianCode = [&amp;] {
12855                     return m_out.loadDouble(pointer);
12856                 };
12857 
12858                 auto emitBigEndianCode = [&amp;] {
12859                     LValue loadedValue = m_out.load64(pointer);
12860                     loadedValue = byteSwap64(loadedValue);
12861                     return m_out.bitCast(loadedValue, Double);
12862                 };
12863 
12864                 if (data.isLittleEndian == TrueTriState)
12865                     setDouble(emitLittleEndianCode());
12866                 else if (data.isLittleEndian == FalseTriState)
12867                     setDouble(emitBigEndianCode());
12868                 else
12869                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
12870 
12871                 break;
12872             }
12873             default:
12874                 RELEASE_ASSERT_NOT_REACHED();
12875             }
12876         }
12877     }
12878 
12879     void compileDataViewSet()
12880     {
12881         LValue dataView = lowDataViewObject(m_graph.varArgChild(m_node, 0));
12882         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
12883         LValue isLittleEndian = nullptr;
12884         if (m_graph.varArgChild(m_node, 3))
12885             isLittleEndian = lowBoolean(m_graph.varArgChild(m_node, 3));
12886 
12887         DataViewData data = m_node-&gt;dataViewData();
12888 
12889         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
12890         LValue indexToCheck = m_out.zeroExtPtr(index);
12891         if (data.byteSize &gt; 1)
12892             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
12893         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
12894 
12895         Edge&amp; valueEdge = m_graph.varArgChild(m_node, 2);
12896         LValue valueToStore;
12897         switch (valueEdge.useKind()) {
12898         case Int32Use:
12899             valueToStore = lowInt32(valueEdge);
12900             break;
12901         case DoubleRepUse:
12902             valueToStore = lowDouble(valueEdge);
12903             break;
12904         case Int52RepUse:
12905             valueToStore = lowStrictInt52(valueEdge);
12906             break;
12907         default:
12908             RELEASE_ASSERT_NOT_REACHED();
12909         }
12910 
12911         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);
12912         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
12913 
12914         if (data.isFloatingPoint) {
12915             if (data.byteSize == 4) {
12916                 valueToStore = m_out.doubleToFloat(valueToStore);
12917 
12918                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12919                     m_out.storeFloat(valueToStore, pointer);
12920                     return nullptr;
12921                 };
12922 
12923                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12924                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12925                     patchpoint-&gt;appendSomeRegister(valueToStore);
12926                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12927                         jit.moveFloatTo32(params[1].fpr(), params[0].gpr());
12928                         jit.byteSwap32(params[0].gpr());
12929                     });
12930                     patchpoint-&gt;effects = Effects::none();
12931                     m_out.store32(patchpoint, pointer);
12932                     return nullptr;
12933                 };
12934 
12935                 if (data.isLittleEndian == FalseTriState)
12936                     emitBigEndianCode();
12937                 else if (data.isLittleEndian == TrueTriState)
12938                     emitLittleEndianCode();
12939                 else
12940                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12941 
12942             } else {
12943                 RELEASE_ASSERT(data.byteSize == 8);
12944                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12945                     m_out.storeDouble(valueToStore, pointer);
12946                     return nullptr;
12947                 };
12948                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12949                     m_out.store64(byteSwap64(m_out.bitCast(valueToStore, Int64)), pointer);
12950                     return nullptr;
12951                 };
12952 
12953                 if (data.isLittleEndian == FalseTriState)
12954                     emitBigEndianCode();
12955                 else if (data.isLittleEndian == TrueTriState)
12956                     emitLittleEndianCode();
12957                 else
12958                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12959             }
12960         } else {
12961             switch (data.byteSize) {
12962             case 1:
12963                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
12964                 m_out.store32As8(valueToStore, pointer);
12965                 break;
12966             case 2: {
12967                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
12968 
12969                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
12970                     m_out.store32As16(valueToStore, pointer);
12971                     return nullptr;
12972                 };
12973                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
12974                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
12975                     patchpoint-&gt;appendSomeRegister(valueToStore);
12976                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12977                         jit.move(params[1].gpr(), params[0].gpr());
12978                         jit.byteSwap16(params[0].gpr());
12979                     });
12980                     patchpoint-&gt;effects = Effects::none();
12981 
12982                     m_out.store32As16(patchpoint, pointer);
12983                     return nullptr;
12984                 };
12985 
12986                 if (data.isLittleEndian == FalseTriState)
12987                     emitBigEndianCode();
12988                 else if (data.isLittleEndian == TrueTriState)
12989                     emitLittleEndianCode();
12990                 else
12991                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
12992                 break;
12993             }
12994             case 4: {
12995                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
12996 
12997                 if (valueEdge.useKind() == Int52RepUse)
12998                     valueToStore = m_out.castToInt32(valueToStore);
12999 
13000                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
13001                     m_out.store32(valueToStore, pointer);
13002                     return nullptr;
13003                 };
13004                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
13005                     m_out.store32(byteSwap32(valueToStore), pointer);
13006                     return nullptr;
13007                 };
13008 
13009                 if (data.isLittleEndian == FalseTriState)
13010                     emitBigEndianCode();
13011                 else if (data.isLittleEndian == TrueTriState)
13012                     emitLittleEndianCode();
13013                 else
13014                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13015 
13016                 break;
13017             }
13018             default:
13019                 RELEASE_ASSERT_NOT_REACHED();
13020             }
13021         }
13022     }
13023 
13024     void emitSwitchForMultiByOffset(LValue base, bool structuresChecked, Vector&lt;SwitchCase, 2&gt;&amp; cases, LBasicBlock exit)
13025     {
13026         if (cases.isEmpty()) {
13027             m_out.jump(exit);
13028             return;
13029         }
13030 
13031         if (structuresChecked) {
13032             std::sort(
13033                 cases.begin(), cases.end(),
13034                 [&amp;] (const SwitchCase&amp; a, const SwitchCase&amp; b) -&gt; bool {
13035                     return a.value()-&gt;asInt() &lt; b.value()-&gt;asInt();
13036                 });
13037             SwitchCase last = cases.takeLast();
13038             m_out.switchInstruction(
13039                 m_out.load32(base, m_heaps.JSCell_structureID), cases, last.target(), Weight(0));
13040             return;
13041         }
13042 
13043         m_out.switchInstruction(
13044             m_out.load32(base, m_heaps.JSCell_structureID), cases, exit, Weight(0));
13045     }
13046 
13047     void compareEqObjectOrOtherToObject(Edge leftChild, Edge rightChild)
13048     {
13049         LValue rightCell = lowCell(rightChild);
13050         LValue leftValue = lowJSValue(leftChild, ManualOperandSpeculation);
13051 
13052         speculateTruthyObject(rightChild, rightCell, SpecObject);
13053 
13054         LBasicBlock leftCellCase = m_out.newBlock();
13055         LBasicBlock leftNotCellCase = m_out.newBlock();
13056         LBasicBlock continuation = m_out.newBlock();
13057 
13058         m_out.branch(
13059             isCell(leftValue, provenType(leftChild)),
13060             unsure(leftCellCase), unsure(leftNotCellCase));
13061 
13062         LBasicBlock lastNext = m_out.appendTo(leftCellCase, leftNotCellCase);
13063         speculateTruthyObject(leftChild, leftValue, SpecObject | (~SpecCellCheck));
13064         ValueFromBlock cellResult = m_out.anchor(m_out.equal(rightCell, leftValue));
13065         m_out.jump(continuation);
13066 
13067         m_out.appendTo(leftNotCellCase, continuation);
13068         FTL_TYPE_CHECK(
13069             jsValueValue(leftValue), leftChild, SpecOther | SpecCellCheck, isNotOther(leftValue));
13070         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13071         m_out.jump(continuation);
13072 
13073         m_out.appendTo(continuation, lastNext);
13074         setBoolean(m_out.phi(Int32, cellResult, notCellResult));
13075     }
13076 
13077     void speculateTruthyObject(Edge edge, LValue cell, SpeculatedType filter)
13078     {
13079         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
13080             FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
13081             return;
13082         }
13083 
13084         FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
13085         speculate(
13086             BadType, jsValueValue(cell), edge.node(),
13087             m_out.testNonZero32(
13088                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
13089                 m_out.constInt32(MasqueradesAsUndefined)));
13090     }
13091 
13092     template&lt;typename IntFunctor&gt;
13093     void nonSpeculativeCompare(const IntFunctor&amp; intFunctor, S_JITOperation_EJJ helperFunction)
13094     {
13095         LValue left = lowJSValue(m_node-&gt;child1());
13096         LValue right = lowJSValue(m_node-&gt;child2());
13097 
13098         LBasicBlock leftIsInt = m_out.newBlock();
13099         LBasicBlock fastPath = m_out.newBlock();
13100         LBasicBlock slowPath = m_out.newBlock();
13101         LBasicBlock continuation = m_out.newBlock();
13102 
13103         m_out.branch(isNotInt32(left, provenType(m_node-&gt;child1())), rarely(slowPath), usually(leftIsInt));
13104 
13105         LBasicBlock lastNext = m_out.appendTo(leftIsInt, fastPath);
13106         m_out.branch(isNotInt32(right, provenType(m_node-&gt;child2())), rarely(slowPath), usually(fastPath));
13107 
13108         m_out.appendTo(fastPath, slowPath);
13109         ValueFromBlock fastResult = m_out.anchor(intFunctor(unboxInt32(left), unboxInt32(right)));
13110         m_out.jump(continuation);
13111 
13112         m_out.appendTo(slowPath, continuation);
13113         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
13114             pointerType(), m_out.operation(helperFunction), m_callFrame, left, right)));
13115         m_out.jump(continuation);
13116 
13117         m_out.appendTo(continuation, lastNext);
13118         setBoolean(m_out.phi(Int32, fastResult, slowResult));
13119     }
13120 
13121     LValue stringsEqual(LValue leftJSString, LValue rightJSString, Edge leftJSStringEdge = Edge(), Edge rightJSStringEdge = Edge())
13122     {
13123         LBasicBlock notTriviallyUnequalCase = m_out.newBlock();
13124         LBasicBlock notEmptyCase = m_out.newBlock();
13125         LBasicBlock leftReadyCase = m_out.newBlock();
13126         LBasicBlock rightReadyCase = m_out.newBlock();
13127         LBasicBlock left8BitCase = m_out.newBlock();
13128         LBasicBlock right8BitCase = m_out.newBlock();
13129         LBasicBlock loop = m_out.newBlock();
13130         LBasicBlock bytesEqual = m_out.newBlock();
13131         LBasicBlock trueCase = m_out.newBlock();
13132         LBasicBlock falseCase = m_out.newBlock();
13133         LBasicBlock slowCase = m_out.newBlock();
13134         LBasicBlock continuation = m_out.newBlock();
13135 
13136         m_out.branch(isRopeString(leftJSString, leftJSStringEdge), rarely(slowCase), usually(leftReadyCase));
13137 
13138         LBasicBlock lastNext = m_out.appendTo(leftReadyCase, rightReadyCase);
13139         m_out.branch(isRopeString(rightJSString, rightJSStringEdge), rarely(slowCase), usually(rightReadyCase));
13140 
13141         m_out.appendTo(rightReadyCase, notTriviallyUnequalCase);
13142         LValue left = m_out.loadPtr(leftJSString, m_heaps.JSString_value);
13143         LValue right = m_out.loadPtr(rightJSString, m_heaps.JSString_value);
13144         LValue length = m_out.load32(left, m_heaps.StringImpl_length);
13145         m_out.branch(
13146             m_out.notEqual(length, m_out.load32(right, m_heaps.StringImpl_length)),
13147             unsure(falseCase), unsure(notTriviallyUnequalCase));
13148 
13149         m_out.appendTo(notTriviallyUnequalCase, notEmptyCase);
13150         m_out.branch(m_out.isZero32(length), unsure(trueCase), unsure(notEmptyCase));
13151 
13152         m_out.appendTo(notEmptyCase, left8BitCase);
13153         m_out.branch(
13154             m_out.testIsZero32(
13155                 m_out.load32(left, m_heaps.StringImpl_hashAndFlags),
13156                 m_out.constInt32(StringImpl::flagIs8Bit())),
13157             unsure(slowCase), unsure(left8BitCase));
13158 
13159         m_out.appendTo(left8BitCase, right8BitCase);
13160         m_out.branch(
13161             m_out.testIsZero32(
13162                 m_out.load32(right, m_heaps.StringImpl_hashAndFlags),
13163                 m_out.constInt32(StringImpl::flagIs8Bit())),
13164             unsure(slowCase), unsure(right8BitCase));
13165 
13166         m_out.appendTo(right8BitCase, loop);
13167 
13168         LValue leftData = m_out.loadPtr(left, m_heaps.StringImpl_data);
13169         LValue rightData = m_out.loadPtr(right, m_heaps.StringImpl_data);
13170 
13171         ValueFromBlock indexAtStart = m_out.anchor(length);
13172 
13173         m_out.jump(loop);
13174 
13175         m_out.appendTo(loop, bytesEqual);
13176 
13177         LValue indexAtLoopTop = m_out.phi(Int32, indexAtStart);
13178         LValue indexInLoop = m_out.sub(indexAtLoopTop, m_out.int32One);
13179 
13180         LValue leftByte = m_out.load8ZeroExt32(
13181             m_out.baseIndex(m_heaps.characters8, leftData, m_out.zeroExtPtr(indexInLoop)));
13182         LValue rightByte = m_out.load8ZeroExt32(
13183             m_out.baseIndex(m_heaps.characters8, rightData, m_out.zeroExtPtr(indexInLoop)));
13184 
13185         m_out.branch(m_out.notEqual(leftByte, rightByte), unsure(falseCase), unsure(bytesEqual));
13186 
13187         m_out.appendTo(bytesEqual, trueCase);
13188 
13189         ValueFromBlock indexForNextIteration = m_out.anchor(indexInLoop);
13190         m_out.addIncomingToPhi(indexAtLoopTop, indexForNextIteration);
13191         m_out.branch(m_out.notZero32(indexInLoop), unsure(loop), unsure(trueCase));
13192 
13193         m_out.appendTo(trueCase, falseCase);
13194 
13195         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
13196         m_out.jump(continuation);
13197 
13198         m_out.appendTo(falseCase, slowCase);
13199 
13200         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
13201         m_out.jump(continuation);
13202 
13203         m_out.appendTo(slowCase, continuation);
13204 
13205         LValue slowResultValue = vmCall(
13206             Int64, m_out.operation(operationCompareStringEq), m_callFrame,
13207             leftJSString, rightJSString);
13208         ValueFromBlock slowResult = m_out.anchor(unboxBoolean(slowResultValue));
13209         m_out.jump(continuation);
13210 
13211         m_out.appendTo(continuation, lastNext);
13212         return m_out.phi(Int32, trueResult, falseResult, slowResult);
13213     }
13214 
13215     enum ScratchFPRUsage {
13216         DontNeedScratchFPR,
13217         NeedScratchFPR
13218     };
13219     template&lt;typename BinaryArithOpGenerator, ScratchFPRUsage scratchFPRUsage = DontNeedScratchFPR&gt;
13220     void emitBinarySnippet(J_JITOperation_EJJ slowPathFunction)
13221     {
13222         Node* node = m_node;
13223 
13224         LValue left = lowJSValue(node-&gt;child1());
13225         LValue right = lowJSValue(node-&gt;child2());
13226 
13227         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13228         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13229 
13230         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13231         patchpoint-&gt;appendSomeRegister(left);
13232         patchpoint-&gt;appendSomeRegister(right);
13233         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13234         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13235         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13236             preparePatchpointForExceptions(patchpoint);
13237         patchpoint-&gt;numGPScratchRegisters = 1;
13238         patchpoint-&gt;numFPScratchRegisters = 2;
13239         if (scratchFPRUsage == NeedScratchFPR)
13240             patchpoint-&gt;numFPScratchRegisters++;
13241         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13242         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
13243         State* state = &amp;m_ftlState;
13244         patchpoint-&gt;setGenerator(
13245             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13246                 AllowMacroScratchRegisterUsage allowScratch(jit);
13247 
13248                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13249                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13250 
13251                 auto generator = Box&lt;BinaryArithOpGenerator&gt;::create(
13252                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13253                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13254                     params.fpScratch(0), params.fpScratch(1), params.gpScratch(0),
13255                     scratchFPRUsage == NeedScratchFPR ? params.fpScratch(2) : InvalidFPRReg);
13256 
13257                 generator-&gt;generateFastPath(jit);
13258 
13259                 if (generator-&gt;didEmitFastPath()) {
13260                     generator-&gt;endJumpList().link(&amp;jit);
13261                     CCallHelpers::Label done = jit.label();
13262 
13263                     params.addLatePath(
13264                         [=] (CCallHelpers&amp; jit) {
13265                             AllowMacroScratchRegisterUsage allowScratch(jit);
13266 
13267                             generator-&gt;slowPathJumpList().link(&amp;jit);
13268                             callOperation(
13269                                 *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13270                                 exceptions.get(), slowPathFunction, params[0].gpr(),
13271                                 params[1].gpr(), params[2].gpr());
13272                             jit.jump().linkTo(done, &amp;jit);
13273                         });
13274                 } else {
13275                     callOperation(
13276                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13277                         exceptions.get(), slowPathFunction, params[0].gpr(), params[1].gpr(),
13278                         params[2].gpr());
13279                 }
13280             });
13281 
13282         setJSValue(patchpoint);
13283     }
13284 
13285     template&lt;typename BinaryBitOpGenerator&gt;
13286     void emitBinaryBitOpSnippet(J_JITOperation_EJJ slowPathFunction)
13287     {
13288         Node* node = m_node;
13289 
13290         LValue left = lowJSValue(node-&gt;child1());
13291         LValue right = lowJSValue(node-&gt;child2());
13292 
13293         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13294         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13295 
13296         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13297         patchpoint-&gt;appendSomeRegister(left);
13298         patchpoint-&gt;appendSomeRegister(right);
13299         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13300         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13301         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13302             preparePatchpointForExceptions(patchpoint);
13303         patchpoint-&gt;numGPScratchRegisters = 1;
13304         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13305         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
13306         State* state = &amp;m_ftlState;
13307         patchpoint-&gt;setGenerator(
13308             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13309                 AllowMacroScratchRegisterUsage allowScratch(jit);
13310 
13311                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13312                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13313 
13314                 auto generator = Box&lt;BinaryBitOpGenerator&gt;::create(
13315                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13316                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.gpScratch(0));
13317 
13318                 generator-&gt;generateFastPath(jit);
13319                 generator-&gt;endJumpList().link(&amp;jit);
13320                 CCallHelpers::Label done = jit.label();
13321 
13322                 params.addLatePath(
13323                     [=] (CCallHelpers&amp; jit) {
13324                         AllowMacroScratchRegisterUsage allowScratch(jit);
13325 
13326                         generator-&gt;slowPathJumpList().link(&amp;jit);
13327                         callOperation(
13328                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13329                             exceptions.get(), slowPathFunction, params[0].gpr(),
13330                             params[1].gpr(), params[2].gpr());
13331                         jit.jump().linkTo(done, &amp;jit);
13332                     });
13333             });
13334 
13335         setJSValue(patchpoint);
13336     }
13337 
13338     void emitRightShiftSnippet(JITRightShiftGenerator::ShiftType shiftType)
13339     {
13340         Node* node = m_node;
13341 
13342         // FIXME: Make this do exceptions.
13343         // https://bugs.webkit.org/show_bug.cgi?id=151686
13344 
13345         LValue left = lowJSValue(node-&gt;child1());
13346         LValue right = lowJSValue(node-&gt;child2());
13347 
13348         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
13349         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
13350 
13351         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13352         patchpoint-&gt;appendSomeRegister(left);
13353         patchpoint-&gt;appendSomeRegister(right);
13354         patchpoint-&gt;append(m_tagMask, ValueRep::lateReg(GPRInfo::tagMaskRegister));
13355         patchpoint-&gt;append(m_tagTypeNumber, ValueRep::lateReg(GPRInfo::tagTypeNumberRegister));
13356         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
13357             preparePatchpointForExceptions(patchpoint);
13358         patchpoint-&gt;numGPScratchRegisters = 1;
13359         patchpoint-&gt;numFPScratchRegisters = 1;
13360         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13361         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
13362         State* state = &amp;m_ftlState;
13363         patchpoint-&gt;setGenerator(
13364             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13365                 AllowMacroScratchRegisterUsage allowScratch(jit);
13366 
13367                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
13368                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13369 
13370                 auto generator = Box&lt;JITRightShiftGenerator&gt;::create(
13371                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
13372                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
13373                     params.fpScratch(0), params.gpScratch(0), InvalidFPRReg, shiftType);
13374 
13375                 generator-&gt;generateFastPath(jit);
13376                 generator-&gt;endJumpList().link(&amp;jit);
13377                 CCallHelpers::Label done = jit.label();
13378 
13379                 params.addLatePath(
13380                     [=] (CCallHelpers&amp; jit) {
13381                         AllowMacroScratchRegisterUsage allowScratch(jit);
13382 
13383                         generator-&gt;slowPathJumpList().link(&amp;jit);
13384 
13385                         J_JITOperation_EJJ slowPathFunction =
13386                             shiftType == JITRightShiftGenerator::SignedShift
13387                             ? operationValueBitRShift : operationValueBitURShift;
13388 
13389                         callOperation(
13390                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
13391                             exceptions.get(), slowPathFunction, params[0].gpr(),
13392                             params[1].gpr(), params[2].gpr());
13393                         jit.jump().linkTo(done, &amp;jit);
13394                     });
13395             });
13396 
13397         setJSValue(patchpoint);
13398     }
13399 
13400     LValue allocateHeapCell(LValue allocator, LBasicBlock slowPath)
13401     {
13402         JITAllocator actualAllocator;
13403         if (allocator-&gt;hasIntPtr())
13404             actualAllocator = JITAllocator::constant(Allocator(bitwise_cast&lt;LocalAllocator*&gt;(allocator-&gt;asIntPtr())));
13405         else
13406             actualAllocator = JITAllocator::variable();
13407 
13408         if (actualAllocator.isConstant()) {
13409             if (!actualAllocator.allocator()) {
13410                 LBasicBlock haveAllocator = m_out.newBlock();
13411                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
13412                 m_out.jump(slowPath);
13413                 m_out.appendTo(haveAllocator, lastNext);
13414                 return m_out.intPtrZero;
13415             }
13416         } else {
13417             // This means that either we know that the allocator is null or we don&#39;t know what the
13418             // allocator is. In either case, we need the null check.
13419             LBasicBlock haveAllocator = m_out.newBlock();
13420             LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
13421             m_out.branch(
13422                 m_out.notEqual(allocator, m_out.intPtrZero),
13423                 usually(haveAllocator), rarely(slowPath));
13424             m_out.appendTo(haveAllocator, lastNext);
13425         }
13426 
13427         LBasicBlock continuation = m_out.newBlock();
13428 
13429         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13430 
13431         PatchpointValue* patchpoint = m_out.patchpoint(pointerType());
13432         if (isARM64()) {
13433             // emitAllocateWithNonNullAllocator uses the scratch registers on ARM.
13434             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13435         }
13436         patchpoint-&gt;effects.terminal = true;
13437         if (actualAllocator.isConstant())
13438             patchpoint-&gt;numGPScratchRegisters++;
13439         else
13440             patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
13441         patchpoint-&gt;numGPScratchRegisters++;
13442         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
13443 
13444         m_out.appendSuccessor(usually(continuation));
13445         m_out.appendSuccessor(rarely(slowPath));
13446 
13447         patchpoint-&gt;setGenerator(
13448             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13449                 AllowMacroScratchRegisterUsageIf allowScratchIf(jit, isARM64());
13450                 CCallHelpers::JumpList jumpToSlowPath;
13451 
13452                 GPRReg allocatorGPR;
13453                 if (actualAllocator.isConstant())
13454                     allocatorGPR = params.gpScratch(1);
13455                 else
13456                     allocatorGPR = params[1].gpr();
13457 
13458                 // We use a patchpoint to emit the allocation path because whenever we mess with
13459                 // allocation paths, we already reason about them at the machine code level. We know
13460                 // exactly what instruction sequence we want. We&#39;re confident that no compiler
13461                 // optimization could make this code better. So, it&#39;s best to have the code in
13462                 // AssemblyHelpers::emitAllocate(). That way, the same optimized path is shared by
13463                 // all of the compiler tiers.
13464                 jit.emitAllocateWithNonNullAllocator(
13465                     params[0].gpr(), actualAllocator, allocatorGPR, params.gpScratch(0),
13466                     jumpToSlowPath);
13467 
13468                 CCallHelpers::Jump jumpToSuccess;
13469                 if (!params.fallsThroughToSuccessor(0))
13470                     jumpToSuccess = jit.jump();
13471 
13472                 Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
13473 
13474                 params.addLatePath(
13475                     [=] (CCallHelpers&amp; jit) {
13476                         jumpToSlowPath.linkTo(*labels[1], &amp;jit);
13477                         if (jumpToSuccess.isSet())
13478                             jumpToSuccess.linkTo(*labels[0], &amp;jit);
13479                     });
13480             });
13481 
13482         m_out.appendTo(continuation, lastNext);
13483         return patchpoint;
13484     }
13485 
13486     void storeStructure(LValue object, Structure* structure)
13487     {
13488         m_out.store32(m_out.constInt32(structure-&gt;id()), object, m_heaps.JSCell_structureID);
13489         m_out.store32(
13490             m_out.constInt32(structure-&gt;objectInitializationBlob()),
13491             object, m_heaps.JSCell_usefulBytes);
13492     }
13493 
13494     void storeStructure(LValue object, LValue structure)
13495     {
13496         if (structure-&gt;hasIntPtr()) {
13497             storeStructure(object, bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr()));
13498             return;
13499         }
13500 
13501         LValue id = m_out.load32(structure, m_heaps.Structure_structureID);
13502         m_out.store32(id, object, m_heaps.JSCell_structureID);
13503 
13504         LValue blob = m_out.load32(structure, m_heaps.Structure_indexingModeIncludingHistory);
13505         m_out.store32(blob, object, m_heaps.JSCell_usefulBytes);
13506     }
13507 
13508     template &lt;typename StructureType&gt;
13509     LValue allocateCell(LValue allocator, StructureType structure, LBasicBlock slowPath)
13510     {
13511         LValue result = allocateHeapCell(allocator, slowPath);
13512         storeStructure(result, structure);
13513         return result;
13514     }
13515 
13516     LValue allocateObject(LValue allocator, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
13517     {
13518         return allocateObject(allocator, weakStructure(structure), butterfly, slowPath);
13519     }
13520 
13521     LValue allocateObject(LValue allocator, LValue structure, LValue butterfly, LBasicBlock slowPath)
13522     {
13523         LValue result = allocateCell(allocator, structure, slowPath);
13524         if (structure-&gt;hasIntPtr()) {
13525             splatWords(
13526                 result,
13527                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13528                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8 + bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;inlineCapacity()),
13529                 m_out.int64Zero,
13530                 m_heaps.properties.atAnyNumber());
13531         } else {
13532             LValue end = m_out.add(
13533                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13534                 m_out.load8ZeroExt32(structure, m_heaps.Structure_inlineCapacity));
13535             splatWords(
13536                 result,
13537                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
13538                 end,
13539                 m_out.int64Zero,
13540                 m_heaps.properties.atAnyNumber());
13541         }
13542 
13543         m_out.storePtr(butterfly, result, m_heaps.JSObject_butterfly);
13544         return result;
13545     }
13546 
13547     template&lt;typename ClassType, typename StructureType&gt;
13548     LValue allocateObject(
13549         size_t size, StructureType structure, LValue butterfly, LBasicBlock slowPath)
13550     {
13551         Allocator allocator = allocatorForNonVirtualConcurrently&lt;ClassType&gt;(vm(), size, AllocatorForMode::AllocatorIfExists);
13552         return allocateObject(
13553             m_out.constIntPtr(allocator.localAllocator()), structure, butterfly, slowPath);
13554     }
13555 
13556     template&lt;typename ClassType, typename StructureType&gt;
13557     LValue allocateObject(StructureType structure, LValue butterfly, LBasicBlock slowPath)
13558     {
13559         return allocateObject&lt;ClassType&gt;(
13560             ClassType::allocationSize(0), structure, butterfly, slowPath);
13561     }
13562 
13563     LValue allocatorForSize(LValue subspace, LValue size, LBasicBlock slowPath)
13564     {
13565         static_assert(!(MarkedSpace::sizeStep &amp; (MarkedSpace::sizeStep - 1)), &quot;MarkedSpace::sizeStep must be a power of two.&quot;);
13566 
13567         // Try to do some constant-folding here.
13568         if (subspace-&gt;hasIntPtr() &amp;&amp; size-&gt;hasIntPtr()) {
13569             CompleteSubspace* actualSubspace = bitwise_cast&lt;CompleteSubspace*&gt;(subspace-&gt;asIntPtr());
13570             size_t actualSize = size-&gt;asIntPtr();
13571 
13572             Allocator actualAllocator = actualSubspace-&gt;allocatorForNonVirtual(actualSize, AllocatorForMode::AllocatorIfExists);
13573             if (!actualAllocator) {
13574                 LBasicBlock continuation = m_out.newBlock();
13575                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13576                 m_out.jump(slowPath);
13577                 m_out.appendTo(continuation, lastNext);
13578                 return m_out.intPtrZero;
13579             }
13580 
13581             return m_out.constIntPtr(actualAllocator.localAllocator());
13582         }
13583 
13584         unsigned stepShift = getLSBSet(MarkedSpace::sizeStep);
13585 
13586         LBasicBlock continuation = m_out.newBlock();
13587 
13588         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
13589 
13590         LValue sizeClassIndex = m_out.lShr(
13591             m_out.add(size, m_out.constIntPtr(MarkedSpace::sizeStep - 1)),
13592             m_out.constInt32(stepShift));
13593 
13594         m_out.branch(
13595             m_out.above(sizeClassIndex, m_out.constIntPtr(MarkedSpace::largeCutoff &gt;&gt; stepShift)),
13596             rarely(slowPath), usually(continuation));
13597 
13598         m_out.appendTo(continuation, lastNext);
13599 
13600         return m_out.loadPtr(
13601             m_out.baseIndex(
13602                 m_heaps.CompleteSubspace_allocatorForSizeStep,
13603                 subspace, sizeClassIndex));
13604     }
13605 
13606     LValue allocatorForSize(CompleteSubspace&amp; subspace, LValue size, LBasicBlock slowPath)
13607     {
13608         return allocatorForSize(m_out.constIntPtr(&amp;subspace), size, slowPath);
13609     }
13610 
13611     template&lt;typename ClassType&gt;
13612     LValue allocateVariableSizedObject(
13613         LValue size, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
13614     {
13615         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
13616         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
13617         LValue allocator = allocatorForSize(*subspace, size, slowPath);
13618         return allocateObject(allocator, structure, butterfly, slowPath);
13619     }
13620 
13621     template&lt;typename ClassType&gt;
13622     LValue allocateVariableSizedCell(
13623         LValue size, Structure* structure, LBasicBlock slowPath)
13624     {
13625         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
13626         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
13627         LValue allocator = allocatorForSize(*subspace, size, slowPath);
13628         return allocateCell(allocator, structure, slowPath);
13629     }
13630 
13631     LValue allocateObject(RegisteredStructure structure)
13632     {
13633         size_t allocationSize = JSFinalObject::allocationSize(structure.get()-&gt;inlineCapacity());
13634         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
13635 
13636         // FIXME: If the allocator is null, we could simply emit a normal C call to the allocator
13637         // instead of putting it on the slow path.
13638         // https://bugs.webkit.org/show_bug.cgi?id=161062
13639 
13640         LBasicBlock slowPath = m_out.newBlock();
13641         LBasicBlock continuation = m_out.newBlock();
13642 
13643         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
13644 
13645         ValueFromBlock fastResult = m_out.anchor(allocateObject(
13646             m_out.constIntPtr(allocator.localAllocator()), structure, m_out.intPtrZero, slowPath));
13647 
13648         m_out.jump(continuation);
13649 
13650         m_out.appendTo(slowPath, continuation);
13651 
13652         VM&amp; vm = this-&gt;vm();
13653         LValue slowResultValue = lazySlowPath(
13654             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13655                 return createLazyCallGenerator(vm,
13656                     operationNewObject, locations[0].directGPR(),
13657                     CCallHelpers::TrustedImmPtr(structure.get()));
13658             });
13659         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
13660         m_out.jump(continuation);
13661 
13662         m_out.appendTo(continuation, lastNext);
13663         return m_out.phi(pointerType(), fastResult, slowResult);
13664     }
13665 
13666     struct ArrayValues {
13667         ArrayValues()
13668             : array(0)
13669             , butterfly(0)
13670         {
13671         }
13672 
13673         ArrayValues(LValue array, LValue butterfly)
13674             : array(array)
13675             , butterfly(butterfly)
13676         {
13677         }
13678 
13679         LValue array;
13680         LValue butterfly;
13681     };
13682 
13683     ArrayValues allocateJSArray(LValue publicLength, LValue vectorLength, LValue structure, LValue indexingType, bool shouldInitializeElements = true, bool shouldLargeArraySizeCreateArrayStorage = true)
13684     {
13685         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
13686         if (indexingType-&gt;hasInt32()) {
13687             IndexingType type = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());
13688             ASSERT_UNUSED(type,
13689                 hasUndecided(type)
13690                 || hasInt32(type)
13691                 || hasDouble(type)
13692                 || hasContiguous(type));
13693         }
13694 
13695         LBasicBlock fastCase = m_out.newBlock();
13696         LBasicBlock largeCase = m_out.newBlock();
13697         LBasicBlock failCase = m_out.newBlock();
13698         LBasicBlock continuation = m_out.newBlock();
13699         LBasicBlock slowCase = m_out.newBlock();
13700 
13701         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastCase);
13702 
13703         Optional&lt;unsigned&gt; staticVectorLength;
13704         Optional&lt;unsigned&gt; staticVectorLengthFromPublicLength;
13705         if (structure-&gt;hasIntPtr()) {
13706             if (publicLength-&gt;hasInt32()) {
13707                 unsigned publicLengthConst = static_cast&lt;unsigned&gt;(publicLength-&gt;asInt32());
13708                 if (publicLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
13709                     publicLengthConst = Butterfly::optimalContiguousVectorLength(
13710                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), publicLengthConst);
13711                     staticVectorLengthFromPublicLength = publicLengthConst;
13712                 }
13713 
13714             }
13715             if (vectorLength-&gt;hasInt32()) {
13716                 unsigned vectorLengthConst = static_cast&lt;unsigned&gt;(vectorLength-&gt;asInt32());
13717                 if (vectorLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
13718                     vectorLengthConst = Butterfly::optimalContiguousVectorLength(
13719                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), vectorLengthConst);
13720                     vectorLength = m_out.constInt32(vectorLengthConst);
13721                     staticVectorLength = vectorLengthConst;
13722                 }
13723             }
13724         } else {
13725             // We don&#39;t compute the optimal vector length for new Array(blah) where blah is not
13726             // statically known, since the compute effort of doing it here is probably not worth it.
13727         }
13728 
13729         ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
13730 
13731         LValue predicate;
13732         if (shouldLargeArraySizeCreateArrayStorage)
13733             predicate = m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13734         else
13735             predicate = m_out.booleanFalse;
13736 
13737         m_out.branch(predicate, rarely(largeCase), usually(fastCase));
13738 
13739         m_out.appendTo(fastCase, largeCase);
13740 
13741         LValue payloadSize =
13742             m_out.shl(m_out.zeroExt(vectorLength, pointerType()), m_out.constIntPtr(3));
13743 
13744         LValue butterflySize = m_out.add(
13745             payloadSize, m_out.constIntPtr(sizeof(IndexingHeader)));
13746 
13747         LValue allocator = allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, failCase);
13748         LValue startOfStorage = allocateHeapCell(allocator, failCase);
13749 
13750         LValue butterfly = m_out.add(startOfStorage, m_out.constIntPtr(sizeof(IndexingHeader)));
13751 
13752         m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
13753         m_out.store32(vectorLength, butterfly, m_heaps.Butterfly_vectorLength);
13754 
13755         initializeArrayElements(
13756             indexingType,
13757             shouldInitializeElements ? m_out.int32Zero : publicLength, vectorLength,
13758             butterfly);
13759 
13760         ValueFromBlock haveButterfly = m_out.anchor(butterfly);
13761 
13762         LValue object = allocateObject&lt;JSArray&gt;(structure, butterfly, failCase);
13763 
13764         ValueFromBlock fastResult = m_out.anchor(object);
13765         ValueFromBlock fastButterfly = m_out.anchor(butterfly);
13766         m_out.jump(continuation);
13767 
13768         m_out.appendTo(largeCase, failCase);
13769         ValueFromBlock largeStructure = m_out.anchor(
13770             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))));
13771         m_out.jump(slowCase);
13772 
13773         m_out.appendTo(failCase, slowCase);
13774         ValueFromBlock failStructure = m_out.anchor(structure);
13775         m_out.jump(slowCase);
13776 
13777         m_out.appendTo(slowCase, continuation);
13778         LValue structureValue = m_out.phi(pointerType(), largeStructure, failStructure);
13779         LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
13780 
13781         VM&amp; vm = this-&gt;vm();
13782         LValue slowResultValue = nullptr;
13783         if (vectorLength == publicLength
13784             || (staticVectorLengthFromPublicLength &amp;&amp; staticVectorLength &amp;&amp; staticVectorLength.value() == staticVectorLengthFromPublicLength.value())) {
13785             slowResultValue = lazySlowPath(
13786                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13787                     return createLazyCallGenerator(vm,
13788                         operationNewArrayWithSize, locations[0].directGPR(),
13789                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR());
13790                 },
13791                 structureValue, publicLength, butterflyValue);
13792         } else {
13793             slowResultValue = lazySlowPath(
13794                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
13795                     return createLazyCallGenerator(vm,
13796                         operationNewArrayWithSizeAndHint, locations[0].directGPR(),
13797                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR(), locations[4].directGPR());
13798                 },
13799                 structureValue, publicLength, vectorLength, butterflyValue);
13800         }
13801 
13802         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
13803         ValueFromBlock slowButterfly = m_out.anchor(
13804             m_out.loadPtr(slowResultValue, m_heaps.JSObject_butterfly));
13805         m_out.jump(continuation);
13806 
13807         m_out.appendTo(continuation, lastNext);
13808         return ArrayValues(
13809             m_out.phi(pointerType(), fastResult, slowResult),
13810             m_out.phi(pointerType(), fastButterfly, slowButterfly));
13811     }
13812 
13813     ArrayValues allocateUninitializedContiguousJSArrayInternal(LValue publicLength, LValue vectorLength, RegisteredStructure structure)
13814     {
13815         bool shouldInitializeElements = false;
13816         bool shouldLargeArraySizeCreateArrayStorage = false;
13817         return allocateJSArray(
13818             publicLength, vectorLength, weakStructure(structure), m_out.constInt32(structure-&gt;indexingType()), shouldInitializeElements,
13819             shouldLargeArraySizeCreateArrayStorage);
13820     }
13821 
13822     ArrayValues allocateUninitializedContiguousJSArray(LValue publicLength, RegisteredStructure structure)
13823     {
13824         return allocateUninitializedContiguousJSArrayInternal(publicLength, publicLength, structure);
13825     }
13826 
13827     ArrayValues allocateUninitializedContiguousJSArray(unsigned publicLength, unsigned vectorLength, RegisteredStructure structure)
13828     {
13829         ASSERT(vectorLength &gt;= publicLength);
13830         return allocateUninitializedContiguousJSArrayInternal(m_out.constInt32(publicLength), m_out.constInt32(vectorLength), structure);
13831     }
13832 
13833     LValue ensureShadowChickenPacket()
13834     {
13835         ShadowChicken* shadowChicken = vm().shadowChicken();
13836         RELEASE_ASSERT(shadowChicken);
13837         LBasicBlock slowCase = m_out.newBlock();
13838         LBasicBlock continuation = m_out.newBlock();
13839 
13840         TypedPointer addressOfLogCursor = m_out.absolute(shadowChicken-&gt;addressOfLogCursor());
13841         LValue logCursor = m_out.loadPtr(addressOfLogCursor);
13842 
13843         ValueFromBlock fastResult = m_out.anchor(logCursor);
13844 
13845         m_out.branch(
13846             m_out.below(logCursor, m_out.constIntPtr(shadowChicken-&gt;logEnd())),
13847             usually(continuation), rarely(slowCase));
13848 
13849         LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
13850 
13851         vmCall(Void, m_out.operation(operationProcessShadowChickenLog), m_callFrame);
13852 
13853         ValueFromBlock slowResult = m_out.anchor(m_out.loadPtr(addressOfLogCursor));
13854         m_out.jump(continuation);
13855 
13856         m_out.appendTo(continuation, lastNext);
13857         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
13858 
13859         m_out.storePtr(
13860             m_out.add(result, m_out.constIntPtr(sizeof(ShadowChicken::Packet))),
13861             addressOfLogCursor);
13862 
13863         return result;
13864     }
13865 
13866     LValue boolify(Edge edge)
13867     {
13868         switch (edge.useKind()) {
13869         case BooleanUse:
13870         case KnownBooleanUse:
13871             return lowBoolean(edge);
13872         case Int32Use:
13873             return m_out.notZero32(lowInt32(edge));
13874         case DoubleRepUse:
13875             return m_out.doubleNotEqualAndOrdered(lowDouble(edge), m_out.doubleZero);
13876         case ObjectOrOtherUse:
13877             return m_out.logicalNot(
13878                 equalNullOrUndefined(
13879                     edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
13880                     ManualOperandSpeculation));
13881         case StringUse:
13882             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(m_graph.m_vm)));
13883         case StringOrOtherUse: {
13884             LValue value = lowJSValue(edge, ManualOperandSpeculation);
13885 
13886             LBasicBlock cellCase = m_out.newBlock();
13887             LBasicBlock notCellCase = m_out.newBlock();
13888             LBasicBlock continuation = m_out.newBlock();
13889 
13890             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13891 
13892             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
13893             FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
13894             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm))));
13895             m_out.jump(continuation);
13896 
13897             m_out.appendTo(notCellCase, continuation);
13898             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
13899             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13900             m_out.jump(continuation);
13901 
13902             m_out.appendTo(continuation, lastNext);
13903             return m_out.phi(Int32, stringResult, notCellResult);
13904         }
13905         case UntypedUse: {
13906             LValue value = lowJSValue(edge);
13907 
13908             // Implements the following control flow structure:
13909             // if (value is cell) {
13910             //     if (value is string or value is BigInt)
13911             //         result = !!value-&gt;length
13912             //     else {
13913             //         do evil things for masquerades-as-undefined
13914             //         result = true
13915             //     }
13916             // } else if (value is int32) {
13917             //     result = !!unboxInt32(value)
13918             // } else if (value is number) {
13919             //     result = !!unboxDouble(value)
13920             // } else {
13921             //     result = value == jsTrue
13922             // }
13923 
13924             LBasicBlock cellCase = m_out.newBlock();
13925             LBasicBlock notStringCase = m_out.newBlock();
13926             LBasicBlock stringCase = m_out.newBlock();
13927             LBasicBlock bigIntCase = m_out.newBlock();
13928             LBasicBlock notStringOrBigIntCase = m_out.newBlock();
13929             LBasicBlock notCellCase = m_out.newBlock();
13930             LBasicBlock int32Case = m_out.newBlock();
13931             LBasicBlock notInt32Case = m_out.newBlock();
13932             LBasicBlock doubleCase = m_out.newBlock();
13933             LBasicBlock notDoubleCase = m_out.newBlock();
13934             LBasicBlock continuation = m_out.newBlock();
13935 
13936             Vector&lt;ValueFromBlock&gt; results;
13937 
13938             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
13939 
13940             LBasicBlock lastNext = m_out.appendTo(cellCase, notStringCase);
13941             m_out.branch(
13942                 isString(value, provenType(edge) &amp; SpecCell),
13943                 unsure(stringCase), unsure(notStringCase));
13944 
13945             m_out.appendTo(notStringCase, stringCase);
13946             m_out.branch(
13947                 isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
13948                 unsure(bigIntCase), unsure(notStringOrBigIntCase));
13949 
13950             m_out.appendTo(stringCase, bigIntCase);
13951             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm)))));
13952             m_out.jump(continuation);
13953 
13954             m_out.appendTo(bigIntCase, notStringOrBigIntCase);
13955             LValue nonZeroBigInt = m_out.notZero32(
13956                 m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
13957             results.append(m_out.anchor(nonZeroBigInt));
13958             m_out.jump(continuation);
13959 
13960             m_out.appendTo(notStringOrBigIntCase, notCellCase);
13961             LValue isTruthyObject;
13962             if (masqueradesAsUndefinedWatchpointIsStillValid())
13963                 isTruthyObject = m_out.booleanTrue;
13964             else {
13965                 LBasicBlock masqueradesCase = m_out.newBlock();
13966 
13967                 results.append(m_out.anchor(m_out.booleanTrue));
13968 
13969                 m_out.branch(
13970                     m_out.testIsZero32(
13971                         m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
13972                         m_out.constInt32(MasqueradesAsUndefined)),
13973                     usually(continuation), rarely(masqueradesCase));
13974 
13975                 m_out.appendTo(masqueradesCase);
13976 
13977                 isTruthyObject = m_out.notEqual(
13978                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
13979                     m_out.loadPtr(loadStructure(value), m_heaps.Structure_globalObject));
13980             }
13981             results.append(m_out.anchor(isTruthyObject));
13982             m_out.jump(continuation);
13983 
13984             m_out.appendTo(notCellCase, int32Case);
13985             m_out.branch(
13986                 isInt32(value, provenType(edge) &amp; ~SpecCell),
13987                 unsure(int32Case), unsure(notInt32Case));
13988 
13989             m_out.appendTo(int32Case, notInt32Case);
13990             results.append(m_out.anchor(m_out.notZero32(unboxInt32(value))));
13991             m_out.jump(continuation);
13992 
13993             m_out.appendTo(notInt32Case, doubleCase);
13994             m_out.branch(
13995                 isNumber(value, provenType(edge) &amp; ~SpecCell),
13996                 unsure(doubleCase), unsure(notDoubleCase));
13997 
13998             m_out.appendTo(doubleCase, notDoubleCase);
13999             LValue doubleIsTruthy = m_out.doubleNotEqualAndOrdered(
14000                 unboxDouble(value), m_out.constDouble(0));
14001             results.append(m_out.anchor(doubleIsTruthy));
14002             m_out.jump(continuation);
14003 
14004             m_out.appendTo(notDoubleCase, continuation);
14005             LValue miscIsTruthy = m_out.equal(
14006                 value, m_out.constInt64(JSValue::encode(jsBoolean(true))));
14007             results.append(m_out.anchor(miscIsTruthy));
14008             m_out.jump(continuation);
14009 
14010             m_out.appendTo(continuation, lastNext);
14011             return m_out.phi(Int32, results);
14012         }
14013         default:
14014             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
14015             return 0;
14016         }
14017     }
14018 
14019     enum StringOrObjectMode {
14020         AllCellsAreFalse,
14021         CellCaseSpeculatesObject
14022     };
14023     enum EqualNullOrUndefinedMode {
14024         EqualNull,
14025         EqualUndefined,
14026         EqualNullOrUndefined,
14027         SpeculateNullOrUndefined
14028     };
14029     LValue equalNullOrUndefined(
14030         Edge edge, StringOrObjectMode cellMode, EqualNullOrUndefinedMode primitiveMode,
14031         OperandSpeculationMode operandMode = AutomaticOperandSpeculation)
14032     {
14033         bool validWatchpoint = masqueradesAsUndefinedWatchpointIsStillValid();
14034 
14035         LValue value = lowJSValue(edge, operandMode);
14036 
14037         LBasicBlock cellCase = m_out.newBlock();
14038         LBasicBlock primitiveCase = m_out.newBlock();
14039         LBasicBlock continuation = m_out.newBlock();
14040 
14041         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
14042 
14043         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
14044 
14045         Vector&lt;ValueFromBlock, 3&gt; results;
14046 
14047         switch (cellMode) {
14048         case AllCellsAreFalse:
14049             break;
14050         case CellCaseSpeculatesObject:
14051             FTL_TYPE_CHECK(
14052                 jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
14053             break;
14054         }
14055 
14056         if (validWatchpoint) {
14057             results.append(m_out.anchor(m_out.booleanFalse));
14058             m_out.jump(continuation);
14059         } else {
14060             LBasicBlock masqueradesCase =
14061                 m_out.newBlock();
14062 
14063             results.append(m_out.anchor(m_out.booleanFalse));
14064 
14065             m_out.branch(
14066                 m_out.testNonZero32(
14067                     m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
14068                     m_out.constInt32(MasqueradesAsUndefined)),
14069                 rarely(masqueradesCase), usually(continuation));
14070 
14071             m_out.appendTo(masqueradesCase, primitiveCase);
14072 
14073             LValue structure = loadStructure(value);
14074 
14075             results.append(m_out.anchor(
14076                 m_out.equal(
14077                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
14078                     m_out.loadPtr(structure, m_heaps.Structure_globalObject))));
14079             m_out.jump(continuation);
14080         }
14081 
14082         m_out.appendTo(primitiveCase, continuation);
14083 
14084         LValue primitiveResult;
14085         switch (primitiveMode) {
14086         case EqualNull:
14087             primitiveResult = m_out.equal(value, m_out.constInt64(ValueNull));
14088             break;
14089         case EqualUndefined:
14090             primitiveResult = m_out.equal(value, m_out.constInt64(ValueUndefined));
14091             break;
14092         case EqualNullOrUndefined:
14093             primitiveResult = isOther(value, provenType(edge));
14094             break;
14095         case SpeculateNullOrUndefined:
14096             FTL_TYPE_CHECK(
14097                 jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
14098             primitiveResult = m_out.booleanTrue;
14099             break;
14100         }
14101         results.append(m_out.anchor(primitiveResult));
14102         m_out.jump(continuation);
14103 
14104         m_out.appendTo(continuation, lastNext);
14105 
14106         return m_out.phi(Int32, results);
14107     }
14108 
14109     template&lt;typename FunctionType&gt;
14110     void contiguousPutByValOutOfBounds(
14111         FunctionType slowPathFunction, LValue base, LValue storage, LValue index, LValue value,
14112         LBasicBlock continuation)
14113     {
14114         if (!m_node-&gt;arrayMode().isInBounds()) {
14115             LBasicBlock notInBoundsCase =
14116                 m_out.newBlock();
14117             LBasicBlock performStore =
14118                 m_out.newBlock();
14119 
14120             LValue isNotInBounds = m_out.aboveOrEqual(
14121                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength));
14122             m_out.branch(isNotInBounds, unsure(notInBoundsCase), unsure(performStore));
14123 
14124             LBasicBlock lastNext = m_out.appendTo(notInBoundsCase, performStore);
14125 
14126             LValue isOutOfBounds = m_out.aboveOrEqual(
14127                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_vectorLength));
14128 
14129             if (!m_node-&gt;arrayMode().isOutOfBounds())
14130                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
14131             else {
14132                 LBasicBlock outOfBoundsCase =
14133                     m_out.newBlock();
14134                 LBasicBlock holeCase =
14135                     m_out.newBlock();
14136 
14137                 m_out.branch(isOutOfBounds, rarely(outOfBoundsCase), usually(holeCase));
14138 
14139                 LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
14140 
14141                 vmCall(
14142                     Void, m_out.operation(slowPathFunction),
14143                     m_callFrame, base, index, value);
14144 
14145                 m_out.jump(continuation);
14146 
14147                 m_out.appendTo(holeCase, innerLastNext);
14148             }
14149 
14150             m_out.store32(
14151                 m_out.add(index, m_out.int32One),
14152                 storage, m_heaps.Butterfly_publicLength);
14153 
14154             m_out.jump(performStore);
14155             m_out.appendTo(performStore, lastNext);
14156         }
14157     }
14158 
14159     LValue untagArrayPtr(LValue ptr, LValue size)
14160     {
14161 #if CPU(ARM64E)
14162         PatchpointValue* authenticate = m_out.patchpoint(pointerType());
14163         authenticate-&gt;appendSomeRegister(ptr);
14164         authenticate-&gt;append(size, B3::ValueRep(B3::ValueRep::SomeLateRegister));
14165         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14166             jit.move(params[1].gpr(), params[0].gpr());
14167             jit.untagArrayPtr(params[2].gpr(), params[0].gpr());
14168         });
14169         return authenticate;
14170 #else
14171         UNUSED_PARAM(size);
14172         return ptr;
14173 #endif
14174     }
14175 
14176     LValue removeArrayPtrTag(LValue ptr)
14177     {
14178 #if CPU(ARM64E)
14179         PatchpointValue* authenticate = m_out.patchpoint(pointerType());
14180         authenticate-&gt;appendSomeRegister(ptr);
14181         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14182             jit.move(params[1].gpr(), params[0].gpr());
14183             jit.removeArrayPtrTag(params[0].gpr());
14184         });
14185         return authenticate;
14186 #endif
14187         return ptr;
14188     }
14189 
14190     LValue caged(Gigacage::Kind kind, LValue ptr, LValue base)
14191     {
14192         auto doUntagArrayPtr = [&amp;](LValue taggedPtr) {
14193 #if CPU(ARM64E)
14194             if (kind == Gigacage::Primitive) {
14195                 LValue size = m_out.load32(base, m_heaps.JSArrayBufferView_length);
14196                 return untagArrayPtr(taggedPtr, size);
14197             }
14198             return ptr;
14199 #else
14200             UNUSED_PARAM(taggedPtr);
14201             return ptr;
14202 #endif
14203         };
14204 
14205 #if GIGACAGE_ENABLED
14206         if (!Gigacage::isEnabled(kind))
14207             return doUntagArrayPtr(ptr);
14208 
14209         if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
14210             if (vm().primitiveGigacageEnabled().isStillValid())
14211                 m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
14212             else
14213                 return doUntagArrayPtr(ptr);
14214         }
14215 
14216         LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
14217         LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
14218 
14219         LValue masked = m_out.bitAnd(ptr, mask);
14220         LValue result = m_out.add(masked, basePtr);
14221 
14222 #if CPU(ARM64E)
14223         if (kind == Gigacage::Primitive) {
14224             PatchpointValue* merge = m_out.patchpoint(pointerType());
14225             merge-&gt;append(result, B3::ValueRep(B3::ValueRep::SomeLateRegister));
14226             merge-&gt;appendSomeRegister(ptr);
14227             merge-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14228                 jit.move(params[2].gpr(), params[0].gpr());
14229                 jit.bitFieldInsert64(params[1].gpr(), 0, 64 - MacroAssembler::numberOfPACBits, params[0].gpr());
14230             });
14231 
14232             result = doUntagArrayPtr(merge);
14233         }
14234 #endif // CPU(ARM64E)
14235 
14236         // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
14237         // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
14238         // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
14239         // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
14240         // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
14241         // the basePtr constant. Hoisting that constant is worth a lot more perf than the reassociation. One
14242         // way to make this all work happily is to combine offset legalization with constant hoisting, and
14243         // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
14244         // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
14245         // and possibly other smart things if we want to be able to remove this opaque.
14246         // https://bugs.webkit.org/show_bug.cgi?id=175493
14247         return m_out.opaque(result);
14248 #endif
14249 
14250         UNUSED_PARAM(kind);
14251         UNUSED_PARAM(base);
14252         return doUntagArrayPtr(ptr);
14253     }
14254 
14255     void buildSwitch(SwitchData* data, LType type, LValue switchValue)
14256     {
14257         ASSERT(type == pointerType() || type == Int32);
14258 
14259         Vector&lt;SwitchCase&gt; cases;
14260         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
14261             SwitchCase newCase;
14262 
14263             if (type == pointerType()) {
14264                 newCase = SwitchCase(m_out.constIntPtr(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
14265                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
14266             } else if (type == Int32) {
14267                 newCase = SwitchCase(m_out.constInt32(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
14268                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
14269             } else
14270                 CRASH();
14271 
14272             cases.append(newCase);
14273         }
14274 
14275         m_out.switchInstruction(
14276             switchValue, cases,
14277             lowBlock(data-&gt;fallThrough.block), Weight(data-&gt;fallThrough.count));
14278     }
14279 
14280     void switchString(SwitchData* data, LValue string, Edge&amp; edge)
14281     {
14282         bool canDoBinarySwitch = true;
14283         unsigned totalLength = 0;
14284 
14285         for (DFG::SwitchCase myCase : data-&gt;cases) {
14286             StringImpl* string = myCase.value.stringImpl();
14287             if (!string-&gt;is8Bit()) {
14288                 canDoBinarySwitch = false;
14289                 break;
14290             }
14291             if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
14292                 canDoBinarySwitch = false;
14293                 break;
14294             }
14295             totalLength += string-&gt;length();
14296         }
14297 
14298         if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
14299             switchStringSlow(data, string);
14300             return;
14301         }
14302 
14303         LBasicBlock hasImplBlock = m_out.newBlock();
14304         LBasicBlock is8BitBlock = m_out.newBlock();
14305         LBasicBlock slowBlock = m_out.newBlock();
14306 
14307         m_out.branch(isRopeString(string, edge), unsure(slowBlock), unsure(hasImplBlock));
14308 
14309         LBasicBlock lastNext = m_out.appendTo(hasImplBlock, is8BitBlock);
14310 
14311         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
14312         LValue length = m_out.load32(stringImpl, m_heaps.StringImpl_length);
14313 
14314         m_out.branch(
14315             m_out.testIsZero32(
14316                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
14317                 m_out.constInt32(StringImpl::flagIs8Bit())),
14318             unsure(slowBlock), unsure(is8BitBlock));
14319 
14320         m_out.appendTo(is8BitBlock, slowBlock);
14321 
14322         LValue buffer = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
14323 
14324         // FIXME: We should propagate branch weight data to the cases of this switch.
14325         // https://bugs.webkit.org/show_bug.cgi?id=144368
14326 
14327         Vector&lt;StringSwitchCase&gt; cases;
14328         for (DFG::SwitchCase myCase : data-&gt;cases)
14329             cases.append(StringSwitchCase(myCase.value.stringImpl(), lowBlock(myCase.target.block)));
14330         std::sort(cases.begin(), cases.end());
14331         switchStringRecurse(data, buffer, length, cases, 0, 0, cases.size(), 0, false);
14332 
14333         m_out.appendTo(slowBlock, lastNext);
14334         switchStringSlow(data, string);
14335     }
14336 
14337     // The code for string switching is based closely on the same code in the DFG backend. While it
14338     // would be nice to reduce the amount of similar-looking code, it seems like this is one of
14339     // those algorithms where factoring out the common bits would result in more code than just
14340     // duplicating.
14341 
14342     struct StringSwitchCase {
14343         StringSwitchCase() { }
14344 
14345         StringSwitchCase(StringImpl* string, LBasicBlock target)
14346             : string(string)
14347             , target(target)
14348         {
14349         }
14350 
14351         bool operator&lt;(const StringSwitchCase&amp; other) const
14352         {
14353             return stringLessThan(*string, *other.string);
14354         }
14355 
14356         StringImpl* string;
14357         LBasicBlock target;
14358     };
14359 
14360     struct CharacterCase {
14361         CharacterCase()
14362             : character(0)
14363             , begin(0)
14364             , end(0)
14365         {
14366         }
14367 
14368         CharacterCase(LChar character, unsigned begin, unsigned end)
14369             : character(character)
14370             , begin(begin)
14371             , end(end)
14372         {
14373         }
14374 
14375         bool operator&lt;(const CharacterCase&amp; other) const
14376         {
14377             return character &lt; other.character;
14378         }
14379 
14380         LChar character;
14381         unsigned begin;
14382         unsigned end;
14383     };
14384 
14385     void switchStringRecurse(
14386         SwitchData* data, LValue buffer, LValue length, const Vector&lt;StringSwitchCase&gt;&amp; cases,
14387         unsigned numChecked, unsigned begin, unsigned end, unsigned alreadyCheckedLength,
14388         unsigned checkedExactLength)
14389     {
14390         LBasicBlock fallThrough = lowBlock(data-&gt;fallThrough.block);
14391 
14392         if (begin == end) {
14393             m_out.jump(fallThrough);
14394             return;
14395         }
14396 
14397         unsigned minLength = cases[begin].string-&gt;length();
14398         unsigned commonChars = minLength;
14399         bool allLengthsEqual = true;
14400         for (unsigned i = begin + 1; i &lt; end; ++i) {
14401             unsigned myCommonChars = numChecked;
14402             unsigned limit = std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
14403             for (unsigned j = numChecked; j &lt; limit; ++j) {
14404                 if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j))
14405                     break;
14406                 myCommonChars++;
14407             }
14408             commonChars = std::min(commonChars, myCommonChars);
14409             if (minLength != cases[i].string-&gt;length())
14410                 allLengthsEqual = false;
14411             minLength = std::min(minLength, cases[i].string-&gt;length());
14412         }
14413 
14414         if (checkedExactLength) {
14415             DFG_ASSERT(m_graph, m_node, alreadyCheckedLength == minLength, alreadyCheckedLength, minLength);
14416             DFG_ASSERT(m_graph, m_node, allLengthsEqual);
14417         }
14418 
14419         DFG_ASSERT(m_graph, m_node, minLength &gt;= commonChars, minLength, commonChars);
14420 
14421         if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
14422             m_out.check(m_out.below(length, m_out.constInt32(minLength)), unsure(fallThrough));
14423         if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
14424             m_out.check(m_out.notEqual(length, m_out.constInt32(minLength)), unsure(fallThrough));
14425 
14426         for (unsigned i = numChecked; i &lt; commonChars; ++i) {
14427             m_out.check(
14428                 m_out.notEqual(
14429                     m_out.load8ZeroExt32(buffer, m_heaps.characters8[i]),
14430                     m_out.constInt32(static_cast&lt;uint16_t&gt;(cases[begin].string-&gt;at(i)))),
14431                 unsure(fallThrough));
14432         }
14433 
14434         if (minLength == commonChars) {
14435             // This is the case where one of the cases is a prefix of all of the other cases.
14436             // We&#39;ve already checked that the input string is a prefix of all of the cases,
14437             // so we just check length to jump to that case.
14438 
14439             DFG_ASSERT(m_graph, m_node, cases[begin].string-&gt;length() == commonChars, cases[begin].string-&gt;length(), commonChars);
14440             for (unsigned i = begin + 1; i &lt; end; ++i)
14441                 DFG_ASSERT(m_graph, m_node, cases[i].string-&gt;length() &gt; commonChars, cases[i].string-&gt;length(), commonChars);
14442 
14443             if (allLengthsEqual) {
14444                 DFG_ASSERT(m_graph, m_node, end == begin + 1, end, begin);
14445                 m_out.jump(cases[begin].target);
14446                 return;
14447             }
14448 
14449             m_out.check(
14450                 m_out.equal(length, m_out.constInt32(commonChars)),
14451                 unsure(cases[begin].target));
14452 
14453             // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the length is
14454             // == commonChars. We get to this point if it is &gt;= minLength but not == commonChars.
14455             // Hence we know that it now must be &gt; minLength, i.e. that it&#39;s &gt;= minLength + 1.
14456             switchStringRecurse(
14457                 data, buffer, length, cases, commonChars, begin + 1, end, minLength + 1, false);
14458             return;
14459         }
14460 
14461         // At this point we know that the string is longer than commonChars, and we&#39;ve only verified
14462         // commonChars. Use a binary switch on the next unchecked character, i.e.
14463         // string[commonChars].
14464 
14465         DFG_ASSERT(m_graph, m_node, end &gt;= begin + 2, end, begin);
14466 
14467         LValue uncheckedChar = m_out.load8ZeroExt32(buffer, m_heaps.characters8[commonChars]);
14468 
14469         Vector&lt;CharacterCase&gt; characterCases;
14470         CharacterCase currentCase(cases[begin].string-&gt;at(commonChars), begin, begin + 1);
14471         for (unsigned i = begin + 1; i &lt; end; ++i) {
14472             LChar currentChar = cases[i].string-&gt;at(commonChars);
14473             if (currentChar != currentCase.character) {
14474                 currentCase.end = i;
14475                 characterCases.append(currentCase);
14476                 currentCase = CharacterCase(currentChar, i, i + 1);
14477             } else
14478                 currentCase.end = i + 1;
14479         }
14480         characterCases.append(currentCase);
14481 
14482         Vector&lt;LBasicBlock&gt; characterBlocks;
14483         for (unsigned i = characterCases.size(); i--;)
14484             characterBlocks.append(m_out.newBlock());
14485 
14486         Vector&lt;SwitchCase&gt; switchCases;
14487         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
14488             if (i)
14489                 DFG_ASSERT(m_graph, m_node, characterCases[i - 1].character &lt; characterCases[i].character);
14490             switchCases.append(SwitchCase(
14491                 m_out.constInt32(characterCases[i].character), characterBlocks[i], Weight()));
14492         }
14493         m_out.switchInstruction(uncheckedChar, switchCases, fallThrough, Weight());
14494 
14495         LBasicBlock lastNext = m_out.m_nextBlock;
14496         characterBlocks.append(lastNext); // Makes it convenient to set nextBlock.
14497         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
14498             m_out.appendTo(characterBlocks[i], characterBlocks[i + 1]);
14499             switchStringRecurse(
14500                 data, buffer, length, cases, commonChars + 1,
14501                 characterCases[i].begin, characterCases[i].end, minLength, allLengthsEqual);
14502         }
14503 
14504         DFG_ASSERT(m_graph, m_node, m_out.m_nextBlock == lastNext);
14505     }
14506 
14507     void switchStringSlow(SwitchData* data, LValue string)
14508     {
14509         // FIXME: We ought to be able to use computed gotos here. We would save the labels of the
14510         // blocks we want to jump to, and then request their addresses after compilation completes.
14511         // https://bugs.webkit.org/show_bug.cgi?id=144369
14512 
14513         LValue branchOffset = vmCall(
14514             Int32, m_out.operation(operationSwitchStringAndGetBranchOffset),
14515             m_callFrame, m_out.constIntPtr(data-&gt;switchTableIndex), string);
14516 
14517         StringJumpTable&amp; table = codeBlock()-&gt;stringSwitchJumpTable(data-&gt;switchTableIndex);
14518 
14519         Vector&lt;SwitchCase&gt; cases;
14520         // These may be negative, or zero, or probably other stuff, too. We don&#39;t want to mess with HashSet&#39;s corner cases and we don&#39;t really care about throughput here.
14521         StdUnorderedSet&lt;int32_t&gt; alreadyHandled;
14522         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
14523             // FIXME: The fact that we&#39;re using the bytecode&#39;s switch table means that the
14524             // following DFG IR transformation would be invalid.
14525             //
14526             // Original code:
14527             //     switch (v) {
14528             //     case &quot;foo&quot;:
14529             //     case &quot;bar&quot;:
14530             //         things();
14531             //         break;
14532             //     default:
14533             //         break;
14534             //     }
14535             //
14536             // New code:
14537             //     switch (v) {
14538             //     case &quot;foo&quot;:
14539             //         instrumentFoo();
14540             //         goto _things;
14541             //     case &quot;bar&quot;:
14542             //         instrumentBar();
14543             //     _things:
14544             //         things();
14545             //         break;
14546             //     default:
14547             //         break;
14548             //     }
14549             //
14550             // Luckily, we don&#39;t currently do any such transformation. But it&#39;s kind of silly that
14551             // this is an issue.
14552             // https://bugs.webkit.org/show_bug.cgi?id=144635
14553 
14554             DFG::SwitchCase myCase = data-&gt;cases[i];
14555             StringJumpTable::StringOffsetTable::iterator iter =
14556                 table.offsetTable.find(myCase.value.stringImpl());
14557             DFG_ASSERT(m_graph, m_node, iter != table.offsetTable.end());
14558 
14559             if (!alreadyHandled.insert(iter-&gt;value.branchOffset).second)
14560                 continue;
14561 
14562             cases.append(SwitchCase(
14563                 m_out.constInt32(iter-&gt;value.branchOffset),
14564                 lowBlock(myCase.target.block), Weight(myCase.target.count)));
14565         }
14566 
14567         m_out.switchInstruction(
14568             branchOffset, cases, lowBlock(data-&gt;fallThrough.block),
14569             Weight(data-&gt;fallThrough.count));
14570     }
14571 
14572     // Calls the functor at the point of code generation where we know what the result type is.
14573     // You can emit whatever code you like at that point. Expects you to terminate the basic block.
14574     // When buildTypeOf() returns, it will have terminated all basic blocks that it created. So, if
14575     // you aren&#39;t using this as the terminator of a high-level block, you should create your own
14576     // contination and set it as the nextBlock (m_out.insertNewBlocksBefore(continuation)) before
14577     // calling this. For example:
14578     //
14579     // LBasicBlock continuation = m_out.newBlock();
14580     // LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
14581     // buildTypeOf(
14582     //     child, value,
14583     //     [&amp;] (TypeofType type) {
14584     //          do things;
14585     //          m_out.jump(continuation);
14586     //     });
14587     // m_out.appendTo(continuation, lastNext);
14588     template&lt;typename Functor&gt;
14589     void buildTypeOf(Edge child, LValue value, const Functor&amp; functor)
14590     {
14591         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
14592 
14593         // Implements the following branching structure:
14594         //
14595         // if (is cell) {
14596         //     if (is object) {
14597         //         if (is function) {
14598         //             return function;
14599         //         } else if (doesn&#39;t have call trap and doesn&#39;t masquerade as undefined) {
14600         //             return object
14601         //         } else {
14602         //             return slowPath();
14603         //         }
14604         //     } else if (is string) {
14605         //         return string
14606         //     } else if (is bigint) {
14607         //         return bigint
14608         //     } else {
14609         //         return symbol
14610         //     }
14611         // } else if (is number) {
14612         //     return number
14613         // } else if (is null) {
14614         //     return object
14615         // } else if (is boolean) {
14616         //     return boolean
14617         // } else {
14618         //     return undefined
14619         // }
14620         //
14621         // FIXME: typeof Symbol should be more frequently seen than BigInt.
14622         // We should change the order of type detection based on this frequency.
14623         // https://bugs.webkit.org/show_bug.cgi?id=192650
14624 
14625         LBasicBlock cellCase = m_out.newBlock();
14626         LBasicBlock objectCase = m_out.newBlock();
14627         LBasicBlock functionCase = m_out.newBlock();
14628         LBasicBlock notFunctionCase = m_out.newBlock();
14629         LBasicBlock reallyObjectCase = m_out.newBlock();
14630         LBasicBlock slowPath = m_out.newBlock();
14631         LBasicBlock unreachable = m_out.newBlock();
14632         LBasicBlock notObjectCase = m_out.newBlock();
14633         LBasicBlock stringCase = m_out.newBlock();
14634         LBasicBlock notStringCase = m_out.newBlock();
14635         LBasicBlock bigIntCase = m_out.newBlock();
14636         LBasicBlock symbolCase = m_out.newBlock();
14637         LBasicBlock notCellCase = m_out.newBlock();
14638         LBasicBlock numberCase = m_out.newBlock();
14639         LBasicBlock notNumberCase = m_out.newBlock();
14640         LBasicBlock notNullCase = m_out.newBlock();
14641         LBasicBlock booleanCase = m_out.newBlock();
14642         LBasicBlock undefinedCase = m_out.newBlock();
14643 
14644         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
14645 
14646         LBasicBlock lastNext = m_out.appendTo(cellCase, objectCase);
14647         m_out.branch(isObject(value, provenType(child)), unsure(objectCase), unsure(notObjectCase));
14648 
14649         m_out.appendTo(objectCase, functionCase);
14650         m_out.branch(
14651             isFunction(value, provenType(child) &amp; SpecObject),
14652             unsure(functionCase), unsure(notFunctionCase));
14653 
14654         m_out.appendTo(functionCase, notFunctionCase);
14655         functor(TypeofType::Function);
14656 
14657         m_out.appendTo(notFunctionCase, reallyObjectCase);
14658         m_out.branch(
14659             isExoticForTypeof(value, provenType(child) &amp; (SpecObject - SpecFunction)),
14660             rarely(slowPath), usually(reallyObjectCase));
14661 
14662         m_out.appendTo(reallyObjectCase, slowPath);
14663         functor(TypeofType::Object);
14664 
14665         m_out.appendTo(slowPath, unreachable);
14666         VM&amp; vm = this-&gt;vm();
14667         LValue result = lazySlowPath(
14668             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14669                 return createLazyCallGenerator(vm,
14670                     operationTypeOfObjectAsTypeofType, locations[0].directGPR(),
14671                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
14672             }, value);
14673         Vector&lt;SwitchCase, 3&gt; cases;
14674         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Undefined)), undefinedCase));
14675         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Object)), reallyObjectCase));
14676         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Function)), functionCase));
14677         m_out.switchInstruction(m_out.castToInt32(result), cases, unreachable, Weight());
14678 
14679         m_out.appendTo(unreachable, notObjectCase);
14680         m_out.unreachable();
14681 
14682         m_out.appendTo(notObjectCase, stringCase);
14683         m_out.branch(
14684             isString(value, provenType(child) &amp; (SpecCell - SpecObject)),
14685             unsure(stringCase), unsure(notStringCase));
14686 
14687         m_out.appendTo(stringCase, notStringCase);
14688         functor(TypeofType::String);
14689 
14690         m_out.appendTo(notStringCase, bigIntCase);
14691         m_out.branch(
14692             isBigInt(value, provenType(child) &amp; (SpecCell - SpecObject - SpecString)),
14693             unsure(bigIntCase), unsure(symbolCase));
14694 
14695         m_out.appendTo(bigIntCase, symbolCase);
14696         functor(TypeofType::BigInt);
14697 
14698         m_out.appendTo(symbolCase, notCellCase);
14699         functor(TypeofType::Symbol);
14700 
14701         m_out.appendTo(notCellCase, numberCase);
14702         m_out.branch(
14703             isNumber(value, provenType(child) &amp; ~SpecCell),
14704             unsure(numberCase), unsure(notNumberCase));
14705 
14706         m_out.appendTo(numberCase, notNumberCase);
14707         functor(TypeofType::Number);
14708 
14709         m_out.appendTo(notNumberCase, notNullCase);
14710         LValue isNull;
14711         if (provenType(child) &amp; SpecOther)
14712             isNull = m_out.equal(value, m_out.constInt64(ValueNull));
14713         else
14714             isNull = m_out.booleanFalse;
14715         m_out.branch(isNull, unsure(reallyObjectCase), unsure(notNullCase));
14716 
14717         m_out.appendTo(notNullCase, booleanCase);
14718         m_out.branch(
14719             isBoolean(value, provenType(child) &amp; ~(SpecCell | SpecFullNumber)),
14720             unsure(booleanCase), unsure(undefinedCase));
14721 
14722         m_out.appendTo(booleanCase, undefinedCase);
14723         functor(TypeofType::Boolean);
14724 
14725         m_out.appendTo(undefinedCase, lastNext);
14726         functor(TypeofType::Undefined);
14727     }
14728 
14729     TypedPointer pointerIntoTypedArray(LValue storage, LValue index, TypedArrayType type)
14730     {
14731         LValue offset = m_out.shl(m_out.zeroExtPtr(index), m_out.constIntPtr(logElementSize(type)));
14732 
14733         return TypedPointer(
14734             m_heaps.typedArrayProperties,
14735             m_out.add(
14736                 storage,
14737                 offset
14738             ));
14739     }
14740 
14741     LValue loadFromIntTypedArray(TypedPointer pointer, TypedArrayType type)
14742     {
14743         switch (elementSize(type)) {
14744         case 1:
14745             return isSigned(type) ? m_out.load8SignExt32(pointer) : m_out.load8ZeroExt32(pointer);
14746         case 2:
14747             return isSigned(type) ? m_out.load16SignExt32(pointer) : m_out.load16ZeroExt32(pointer);
14748         case 4:
14749             return m_out.load32(pointer);
14750         default:
14751             DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
14752         }
14753     }
14754 
14755     Output::StoreType storeType(TypedArrayType type)
14756     {
14757         if (isInt(type)) {
14758             switch (elementSize(type)) {
14759             case 1:
14760                 return Output::Store32As8;
14761             case 2:
14762                 return Output::Store32As16;
14763             case 4:
14764                 return Output::Store32;
14765             default:
14766                 DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
14767                 return Output::Store32;
14768             }
14769         }
14770         switch (type) {
14771         case TypeFloat32:
14772             return Output::StoreFloat;
14773         case TypeFloat64:
14774             return Output::StoreDouble;
14775         default:
14776             DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
14777         }
14778     }
14779 
14780     void setIntTypedArrayLoadResult(LValue result, TypedArrayType type, bool canSpeculate = false)
14781     {
14782         if (elementSize(type) &lt; 4 || isSigned(type)) {
14783             setInt32(result);
14784             return;
14785         }
14786 
14787         if (m_node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
14788             speculate(
14789                 Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
14790             setInt32(result);
14791             return;
14792         }
14793 
14794         if (m_node-&gt;shouldSpeculateInt52()) {
14795             setStrictInt52(m_out.zeroExt(result, Int64));
14796             return;
14797         }
14798 
14799         setDouble(m_out.unsignedToDouble(result));
14800     }
14801 
14802     LValue getIntTypedArrayStoreOperand(Edge edge, bool isClamped = false)
14803     {
14804         LValue intValue;
14805         switch (edge.useKind()) {
14806         case Int52RepUse:
14807         case Int32Use: {
14808             if (edge.useKind() == Int32Use)
14809                 intValue = lowInt32(edge);
14810             else
14811                 intValue = m_out.castToInt32(lowStrictInt52(edge));
14812 
14813             if (isClamped) {
14814                 LBasicBlock atLeastZero = m_out.newBlock();
14815                 LBasicBlock continuation = m_out.newBlock();
14816 
14817                 Vector&lt;ValueFromBlock, 2&gt; intValues;
14818                 intValues.append(m_out.anchor(m_out.int32Zero));
14819                 m_out.branch(
14820                     m_out.lessThan(intValue, m_out.int32Zero),
14821                     unsure(continuation), unsure(atLeastZero));
14822 
14823                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, continuation);
14824 
14825                 intValues.append(m_out.anchor(m_out.select(
14826                     m_out.greaterThan(intValue, m_out.constInt32(255)),
14827                     m_out.constInt32(255),
14828                     intValue)));
14829                 m_out.jump(continuation);
14830 
14831                 m_out.appendTo(continuation, lastNext);
14832                 intValue = m_out.phi(Int32, intValues);
14833             }
14834             break;
14835         }
14836 
14837         case DoubleRepUse: {
14838             LValue doubleValue = lowDouble(edge);
14839 
14840             if (isClamped) {
14841                 LBasicBlock atLeastZero = m_out.newBlock();
14842                 LBasicBlock withinRange = m_out.newBlock();
14843                 LBasicBlock continuation = m_out.newBlock();
14844 
14845                 Vector&lt;ValueFromBlock, 3&gt; intValues;
14846                 intValues.append(m_out.anchor(m_out.int32Zero));
14847                 m_out.branch(
14848                     m_out.doubleLessThanOrUnordered(doubleValue, m_out.doubleZero),
14849                     unsure(continuation), unsure(atLeastZero));
14850 
14851                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, withinRange);
14852                 intValues.append(m_out.anchor(m_out.constInt32(255)));
14853                 m_out.branch(
14854                     m_out.doubleGreaterThan(doubleValue, m_out.constDouble(255)),
14855                     unsure(continuation), unsure(withinRange));
14856 
14857                 m_out.appendTo(withinRange, continuation);
14858                 intValues.append(m_out.anchor(m_out.doubleToInt(doubleValue)));
14859                 m_out.jump(continuation);
14860 
14861                 m_out.appendTo(continuation, lastNext);
14862                 intValue = m_out.phi(Int32, intValues);
14863             } else
14864                 intValue = doubleToInt32(doubleValue);
14865             break;
14866         }
14867 
14868         default:
14869             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
14870         }
14871 
14872         return intValue;
14873     }
14874 
14875     LValue doubleToInt32(LValue doubleValue, double low, double high, bool isSigned = true)
14876     {
14877         LBasicBlock greatEnough = m_out.newBlock();
14878         LBasicBlock withinRange = m_out.newBlock();
14879         LBasicBlock slowPath = m_out.newBlock();
14880         LBasicBlock continuation = m_out.newBlock();
14881 
14882         Vector&lt;ValueFromBlock, 2&gt; results;
14883 
14884         m_out.branch(
14885             m_out.doubleGreaterThanOrEqual(doubleValue, m_out.constDouble(low)),
14886             unsure(greatEnough), unsure(slowPath));
14887 
14888         LBasicBlock lastNext = m_out.appendTo(greatEnough, withinRange);
14889         m_out.branch(
14890             m_out.doubleLessThanOrEqual(doubleValue, m_out.constDouble(high)),
14891             unsure(withinRange), unsure(slowPath));
14892 
14893         m_out.appendTo(withinRange, slowPath);
14894         LValue fastResult;
14895         if (isSigned)
14896             fastResult = m_out.doubleToInt(doubleValue);
14897         else
14898             fastResult = m_out.doubleToUInt(doubleValue);
14899         results.append(m_out.anchor(fastResult));
14900         m_out.jump(continuation);
14901 
14902         m_out.appendTo(slowPath, continuation);
14903         results.append(m_out.anchor(m_out.call(Int32, m_out.operation(operationToInt32), doubleValue)));
14904         m_out.jump(continuation);
14905 
14906         m_out.appendTo(continuation, lastNext);
14907         return m_out.phi(Int32, results);
14908     }
14909 
14910     LValue doubleToInt32(LValue doubleValue)
14911     {
14912 #if CPU(ARM64)
14913         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics()) {
14914             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
14915             patchpoint-&gt;append(ConstrainedValue(doubleValue, B3::ValueRep::SomeRegister));
14916             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14917                 jit.convertDoubleToInt32UsingJavaScriptSemantics(params[1].fpr(), params[0].gpr());
14918             });
14919             patchpoint-&gt;effects = Effects::none();
14920             return patchpoint;
14921         }
14922 #endif
14923 
14924         if (hasSensibleDoubleToInt())
14925             return sensibleDoubleToInt32(doubleValue);
14926 
14927         double limit = pow(2, 31) - 1;
14928         return doubleToInt32(doubleValue, -limit, limit);
14929     }
14930 
14931     LValue sensibleDoubleToInt32(LValue doubleValue)
14932     {
14933         LBasicBlock slowPath = m_out.newBlock();
14934         LBasicBlock continuation = m_out.newBlock();
14935 
14936         LValue fastResultValue = m_out.doubleToInt(doubleValue);
14937         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
14938         m_out.branch(
14939             m_out.equal(fastResultValue, m_out.constInt32(0x80000000)),
14940             rarely(slowPath), usually(continuation));
14941 
14942         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
14943         ValueFromBlock slowResult = m_out.anchor(
14944             m_out.call(Int32, m_out.operation(operationToInt32SensibleSlow), doubleValue));
14945         m_out.jump(continuation);
14946 
14947         m_out.appendTo(continuation, lastNext);
14948         return m_out.phi(Int32, fastResult, slowResult);
14949     }
14950 
14951     // This is a mechanism for creating a code generator that fills in a gap in the code using our
14952     // own MacroAssembler. This is useful for slow paths that involve a lot of code and we don&#39;t want
14953     // to pay the price of B3 optimizing it. A lazy slow path will only be generated if it actually
14954     // executes. On the other hand, a lazy slow path always incurs the cost of two additional jumps.
14955     // Also, the lazy slow path&#39;s register allocation state is slaved to whatever B3 did, so you
14956     // have to use a ScratchRegisterAllocator to try to use some unused registers and you may have
14957     // to spill to top of stack if there aren&#39;t enough registers available.
14958     //
14959     // Lazy slow paths involve three different stages of execution. Each stage has unique
14960     // capabilities and knowledge. The stages are:
14961     //
14962     // 1) DFG-&gt;B3 lowering, i.e. code that runs in this phase. Lowering is the last time you will
14963     //    have access to LValues. If there is an LValue that needs to be fed as input to a lazy slow
14964     //    path, then you must pass it as an argument here (as one of the varargs arguments after the
14965     //    functor). But, lowering doesn&#39;t know which registers will be used for those LValues. Hence
14966     //    you pass a lambda to lazySlowPath() and that lambda will run during stage (2):
14967     //
14968     // 2) FTLCompile.cpp&#39;s fixFunctionBasedOnStackMaps. This code is the only stage at which we know
14969     //    the mapping from arguments passed to this method in (1) and the registers that B3
14970     //    selected for those arguments. You don&#39;t actually want to generate any code here, since then
14971     //    the slow path wouldn&#39;t actually be lazily generated. Instead, you want to save the
14972     //    registers being used for the arguments and defer code generation to stage (3) by creating
14973     //    and returning a LazySlowPath::Generator:
14974     //
14975     // 3) LazySlowPath&#39;s generate() method. This code runs in response to the lazy slow path
14976     //    executing for the first time. It will call the generator you created in stage (2).
14977     //
14978     // Note that each time you invoke stage (1), stage (2) may be invoked zero, one, or many times.
14979     // Stage (2) will usually be invoked once for stage (1). But, B3 may kill the code, in which
14980     // case stage (2) won&#39;t run. B3 may duplicate the code (for example via tail duplication),
14981     // leading to many calls to your stage (2) lambda. Stage (3) may be called zero or once for each
14982     // stage (2). It will be called zero times if the slow path never runs. This is what you hope for
14983     // whenever you use the lazySlowPath() mechanism.
14984     //
14985     // A typical use of lazySlowPath() will look like the example below, which just creates a slow
14986     // path that adds some value to the input and returns it.
14987     //
14988     // // Stage (1) is here. This is your last chance to figure out which LValues to use as inputs.
14989     // // Notice how we pass &quot;input&quot; as an argument to lazySlowPath().
14990     // LValue input = ...;
14991     // int addend = ...;
14992     // LValue output = lazySlowPath(
14993     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14994     //         // Stage (2) is here. This is your last chance to figure out which registers are used
14995     //         // for which values. Location zero is always the return value. You can ignore it if
14996     //         // you don&#39;t want to return anything. Location 1 is the register for the first
14997     //         // argument to the lazySlowPath(), i.e. &quot;input&quot;. Note that the Location object could
14998     //         // also hold an FPR, if you are passing a double.
14999     //         GPRReg outputGPR = locations[0].directGPR();
15000     //         GPRReg inputGPR = locations[1].directGPR();
15001     //         return LazySlowPath::createGenerator(
15002     //             [=] (CCallHelpers&amp; jit, LazySlowPath::GenerationParams&amp; params) {
15003     //                 // Stage (3) is here. This is when you generate code. You have access to the
15004     //                 // registers you collected in stage (2) because this lambda closes over those
15005     //                 // variables (outputGPR and inputGPR). You also have access to whatever extra
15006     //                 // data you collected in stage (1), such as the addend in this case.
15007     //                 jit.add32(TrustedImm32(addend), inputGPR, outputGPR);
15008     //                 // You have to end by jumping to done. There is nothing to fall through to.
15009     //                 // You can also jump to the exception handler (see LazySlowPath.h for more
15010     //                 // info). Note that currently you cannot OSR exit.
15011     //                 params.doneJumps.append(jit.jump());
15012     //             });
15013     //     },
15014     //     input);
15015     //
15016     // You can basically pass as many inputs as you like, either using this varargs form, or by
15017     // passing a Vector of LValues.
15018     //
15019     // Note that if your slow path is only doing a call, you can use the createLazyCallGenerator()
15020     // helper. For example:
15021     //
15022     // LValue input = ...;
15023     // LValue output = lazySlowPath(
15024     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
15025     //         return createLazyCallGenerator(
15026     //             operationDoThings, locations[0].directGPR(), locations[1].directGPR());
15027     //     }, input);
15028     //
15029     // Finally, note that all of the lambdas - both the stage (2) lambda and the stage (3) lambda -
15030     // run after the function that created them returns. Hence, you should not use by-reference
15031     // capture (i.e. [&amp;]) in any of these lambdas.
15032     template&lt;typename Functor, typename... ArgumentTypes&gt;
15033     PatchpointValue* lazySlowPath(const Functor&amp; functor, ArgumentTypes... arguments)
15034     {
15035         return lazySlowPath(functor, Vector&lt;LValue&gt;{ arguments... });
15036     }
15037 
15038     template&lt;typename Functor&gt;
15039     PatchpointValue* lazySlowPath(const Functor&amp; functor, const Vector&lt;LValue&gt;&amp; userArguments)
15040     {
15041         CodeOrigin origin = m_node-&gt;origin.semantic;
15042 
15043         PatchpointValue* result = m_out.patchpoint(B3::Int64);
15044         for (LValue arg : userArguments)
15045             result-&gt;append(ConstrainedValue(arg, B3::ValueRep::SomeRegister));
15046 
15047         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
15048             preparePatchpointForExceptions(result);
15049 
15050         result-&gt;clobber(RegisterSet::macroScratchRegisters());
15051         State* state = &amp;m_ftlState;
15052 
15053         result-&gt;setGenerator(
15054             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15055                 Vector&lt;Location&gt; locations;
15056                 for (const B3::ValueRep&amp; rep : params)
15057                     locations.append(Location::forValueRep(rep));
15058 
15059                 RefPtr&lt;LazySlowPath::Generator&gt; generator = functor(locations);
15060 
15061                 CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
15062                 CCallHelpers::Label done = jit.label();
15063 
15064                 RegisterSet usedRegisters = params.unavailableRegisters();
15065 
15066                 RefPtr&lt;ExceptionTarget&gt; exceptionTarget =
15067                     exceptionHandle-&gt;scheduleExitCreation(params);
15068 
15069                 // FIXME: As part of handling exceptions, we need to create a concrete OSRExit here.
15070                 // Doing so should automagically register late paths that emit exit thunks.
15071 
15072                 params.addLatePath(
15073                     [=] (CCallHelpers&amp; jit) {
15074                         AllowMacroScratchRegisterUsage allowScratch(jit);
15075                         patchableJump.m_jump.link(&amp;jit);
15076                         unsigned index = state-&gt;jitCode-&gt;lazySlowPaths.size();
15077                         state-&gt;jitCode-&gt;lazySlowPaths.append(nullptr);
15078                         jit.pushToSaveImmediateWithoutTouchingRegisters(
15079                             CCallHelpers::TrustedImm32(index));
15080                         CCallHelpers::Jump generatorJump = jit.jump();
15081 
15082                         // Note that so long as we&#39;re here, we don&#39;t really know if our late path
15083                         // runs before or after any other late paths that we might depend on, like
15084                         // the exception thunk.
15085 
15086                         RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode;
15087                         VM* vm = &amp;state-&gt;graph.m_vm;
15088 
15089                         jit.addLinkTask(
15090                             [=] (LinkBuffer&amp; linkBuffer) {
15091                                 linkBuffer.link(generatorJump,
15092                                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
15093 
15094                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = makeUnique&lt;LazySlowPath&gt;();
15095 
15096                                 auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
15097 
15098                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
15099 
15100                                 CallSiteIndex callSiteIndex =
15101                                     jitCode-&gt;common.addUniqueCallSiteIndex(origin);
15102 
15103                                 lazySlowPath-&gt;initialize(
15104                                         linkedPatchableJump, linkedDone,
15105                                         exceptionTarget-&gt;label(linkBuffer), usedRegisters,
15106                                         callSiteIndex, generator);
15107 
15108                                 jitCode-&gt;lazySlowPaths[index] = WTFMove(lazySlowPath);
15109                             });
15110                     });
15111             });
15112         return result;
15113     }
15114 
15115     void speculate(
15116         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition)
15117     {
15118         appendOSRExit(kind, lowValue, highValue, failCondition, m_origin);
15119     }
15120 
15121     void speculate(
15122         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition)
15123     {
15124         appendOSRExit(kind, lowValue, profile, failCondition, m_origin);
15125     }
15126 
15127     void terminate(ExitKind kind)
15128     {
15129         speculate(kind, noValue(), nullptr, m_out.booleanTrue);
15130         didAlreadyTerminate();
15131     }
15132 
15133     void didAlreadyTerminate()
15134     {
15135         m_state.setIsValid(false);
15136     }
15137 
15138     void simulatedTypeCheck(Edge highValue, SpeculatedType typesPassedThrough)
15139     {
15140         m_interpreter.filter(highValue, typesPassedThrough);
15141     }
15142 
15143     void typeCheck(
15144         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
15145         LValue failCondition, ExitKind exitKind = BadType)
15146     {
15147         appendTypeCheck(lowValue, highValue, typesPassedThrough, failCondition, exitKind);
15148     }
15149 
15150     void appendTypeCheck(
15151         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
15152         LValue failCondition, ExitKind exitKind)
15153     {
15154         if (!m_interpreter.needsTypeCheck(highValue, typesPassedThrough))
15155             return;
15156         ASSERT(mayHaveTypeCheck(highValue.useKind()));
15157         appendOSRExit(exitKind, lowValue, highValue.node(), failCondition, m_origin);
15158         m_interpreter.filter(highValue, typesPassedThrough);
15159     }
15160 
15161     LValue lowInt32(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15162     {
15163         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || (edge.useKind() == Int32Use || edge.useKind() == KnownInt32Use));
15164 
15165         if (edge-&gt;hasConstant()) {
15166             JSValue value = edge-&gt;asJSValue();
15167             simulatedTypeCheck(edge, SpecInt32Only);
15168             if (!value.isInt32()) {
15169                 if (mayHaveTypeCheck(edge.useKind()))
15170                     terminate(Uncountable);
15171                 return m_out.int32Zero;
15172             }
15173             LValue result = m_out.constInt32(value.asInt32());
15174             result-&gt;setOrigin(B3::Origin(edge.node()));
15175             return result;
15176         }
15177 
15178         LoweredNodeValue value = m_int32Values.get(edge.node());
15179         if (isValid(value)) {
15180             simulatedTypeCheck(edge, SpecInt32Only);
15181             return value.value();
15182         }
15183 
15184         value = m_strictInt52Values.get(edge.node());
15185         if (isValid(value))
15186             return strictInt52ToInt32(edge, value.value());
15187 
15188         value = m_int52Values.get(edge.node());
15189         if (isValid(value))
15190             return strictInt52ToInt32(edge, int52ToStrictInt52(value.value()));
15191 
15192         value = m_jsValueValues.get(edge.node());
15193         if (isValid(value)) {
15194             LValue boxedResult = value.value();
15195             FTL_TYPE_CHECK(
15196                 jsValueValue(boxedResult), edge, SpecInt32Only, isNotInt32(boxedResult));
15197             LValue result = unboxInt32(boxedResult);
15198             setInt32(edge.node(), result);
15199             return result;
15200         }
15201 
15202         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecInt32Only), provenType(edge));
15203         if (mayHaveTypeCheck(edge.useKind()))
15204             terminate(Uncountable);
15205         return m_out.int32Zero;
15206     }
15207 
15208     enum Int52Kind { StrictInt52, Int52 };
15209     LValue lowInt52(Edge edge, Int52Kind kind)
15210     {
15211         DFG_ASSERT(m_graph, m_node, edge.useKind() == Int52RepUse, edge.useKind());
15212 
15213         LoweredNodeValue value;
15214 
15215         switch (kind) {
15216         case Int52:
15217             value = m_int52Values.get(edge.node());
15218             if (isValid(value))
15219                 return value.value();
15220 
15221             value = m_strictInt52Values.get(edge.node());
15222             if (isValid(value))
15223                 return strictInt52ToInt52(value.value());
15224             break;
15225 
15226         case StrictInt52:
15227             value = m_strictInt52Values.get(edge.node());
15228             if (isValid(value))
15229                 return value.value();
15230 
15231             value = m_int52Values.get(edge.node());
15232             if (isValid(value))
15233                 return int52ToStrictInt52(value.value());
15234             break;
15235         }
15236 
15237         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
15238         if (mayHaveTypeCheck(edge.useKind()))
15239             terminate(Uncountable);
15240         return m_out.int64Zero;
15241     }
15242 
15243     LValue lowInt52(Edge edge)
15244     {
15245         return lowInt52(edge, Int52);
15246     }
15247 
15248     LValue lowStrictInt52(Edge edge)
15249     {
15250         return lowInt52(edge, StrictInt52);
15251     }
15252 
15253     bool betterUseStrictInt52(Node* node)
15254     {
15255         return !isValid(m_int52Values.get(node));
15256     }
15257     bool betterUseStrictInt52(Edge edge)
15258     {
15259         return betterUseStrictInt52(edge.node());
15260     }
15261     template&lt;typename T&gt;
15262     Int52Kind bestInt52Kind(T node)
15263     {
15264         return betterUseStrictInt52(node) ? StrictInt52 : Int52;
15265     }
15266     Int52Kind opposite(Int52Kind kind)
15267     {
15268         switch (kind) {
15269         case Int52:
15270             return StrictInt52;
15271         case StrictInt52:
15272             return Int52;
15273         }
15274         DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
15275         return Int52;
15276     }
15277 
15278     LValue lowWhicheverInt52(Edge edge, Int52Kind&amp; kind)
15279     {
15280         kind = bestInt52Kind(edge);
15281         return lowInt52(edge, kind);
15282     }
15283 
15284     LValue lowCell(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15285     {
15286         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || DFG::isCell(edge.useKind()), edge.useKind());
15287 
15288         if (edge-&gt;op() == JSConstant) {
15289             FrozenValue* value = edge-&gt;constant();
15290             simulatedTypeCheck(edge, SpecCellCheck);
15291             if (!value-&gt;value().isCell()) {
15292                 if (mayHaveTypeCheck(edge.useKind()))
15293                     terminate(Uncountable);
15294                 return m_out.intPtrZero;
15295             }
15296             LValue result = frozenPointer(value);
15297             result-&gt;setOrigin(B3::Origin(edge.node()));
15298             return result;
15299         }
15300 
15301         LoweredNodeValue value = m_jsValueValues.get(edge.node());
15302         if (isValid(value)) {
15303             LValue uncheckedValue = value.value();
15304             FTL_TYPE_CHECK(
15305                 jsValueValue(uncheckedValue), edge, SpecCellCheck, isNotCell(uncheckedValue));
15306             return uncheckedValue;
15307         }
15308 
15309         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecCellCheck), provenType(edge));
15310         if (mayHaveTypeCheck(edge.useKind()))
15311             terminate(Uncountable);
15312         return m_out.intPtrZero;
15313     }
15314 
15315     LValue lowObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15316     {
15317         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
15318 
15319         LValue result = lowCell(edge, mode);
15320         speculateObject(edge, result);
15321         return result;
15322     }
15323 
15324     LValue lowRegExpObject(Edge edge)
15325     {
15326         LValue result = lowCell(edge);
15327         speculateRegExpObject(edge, result);
15328         return result;
15329     }
15330 
15331     LValue lowMapObject(Edge edge)
15332     {
15333         LValue result = lowCell(edge);
15334         speculateMapObject(edge, result);
15335         return result;
15336     }
15337 
15338     LValue lowSetObject(Edge edge)
15339     {
15340         LValue result = lowCell(edge);
15341         speculateSetObject(edge, result);
15342         return result;
15343     }
15344 
15345     LValue lowWeakMapObject(Edge edge)
15346     {
15347         LValue result = lowCell(edge);
15348         speculateWeakMapObject(edge, result);
15349         return result;
15350     }
15351 
15352     LValue lowWeakSetObject(Edge edge)
15353     {
15354         LValue result = lowCell(edge);
15355         speculateWeakSetObject(edge, result);
15356         return result;
15357     }
15358 
15359     LValue lowDataViewObject(Edge edge)
15360     {
15361         LValue result = lowCell(edge);
15362         speculateDataViewObject(edge, result);
15363         return result;
15364     }
15365 
15366     LValue lowString(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15367     {
15368         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringUse || edge.useKind() == KnownStringUse || edge.useKind() == StringIdentUse);
15369 
15370         LValue result = lowCell(edge, mode);
15371         speculateString(edge, result);
15372         return result;
15373     }
15374 
15375     LValue lowStringIdent(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15376     {
15377         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringIdentUse);
15378 
15379         LValue string = lowString(edge, mode);
15380         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
15381         speculateStringIdent(edge, string, stringImpl);
15382         return stringImpl;
15383     }
15384 
15385     LValue lowSymbol(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15386     {
15387         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == SymbolUse);
15388 
15389         LValue result = lowCell(edge, mode);
15390         speculateSymbol(edge, result);
15391         return result;
15392     }
15393 
15394     LValue lowBigInt(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15395     {
15396         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BigIntUse);
15397 
15398         LValue result = lowCell(edge, mode);
15399         speculateBigInt(edge, result);
15400         return result;
15401     }
15402 
15403     LValue lowNonNullObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15404     {
15405         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
15406 
15407         LValue result = lowCell(edge, mode);
15408         speculateNonNullObject(edge, result);
15409         return result;
15410     }
15411 
15412     LValue lowBoolean(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15413     {
15414         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BooleanUse || edge.useKind() == KnownBooleanUse);
15415 
15416         if (edge-&gt;hasConstant()) {
15417             JSValue value = edge-&gt;asJSValue();
15418             simulatedTypeCheck(edge, SpecBoolean);
15419             if (!value.isBoolean()) {
15420                 if (mayHaveTypeCheck(edge.useKind()))
15421                     terminate(Uncountable);
15422                 return m_out.booleanFalse;
15423             }
15424             LValue result = m_out.constBool(value.asBoolean());
15425             result-&gt;setOrigin(B3::Origin(edge.node()));
15426             return result;
15427         }
15428 
15429         LoweredNodeValue value = m_booleanValues.get(edge.node());
15430         if (isValid(value)) {
15431             simulatedTypeCheck(edge, SpecBoolean);
15432             return value.value();
15433         }
15434 
15435         value = m_jsValueValues.get(edge.node());
15436         if (isValid(value)) {
15437             LValue unboxedResult = value.value();
15438             FTL_TYPE_CHECK(
15439                 jsValueValue(unboxedResult), edge, SpecBoolean, isNotBoolean(unboxedResult));
15440             LValue result = unboxBoolean(unboxedResult);
15441             setBoolean(edge.node(), result);
15442             return result;
15443         }
15444 
15445         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecBoolean), provenType(edge));
15446         if (mayHaveTypeCheck(edge.useKind()))
15447             terminate(Uncountable);
15448         return m_out.booleanFalse;
15449     }
15450 
15451     LValue lowDouble(Edge edge)
15452     {
15453         DFG_ASSERT(m_graph, m_node, isDouble(edge.useKind()), edge.useKind());
15454 
15455         LoweredNodeValue value = m_doubleValues.get(edge.node());
15456         if (isValid(value))
15457             return value.value();
15458         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
15459         if (mayHaveTypeCheck(edge.useKind()))
15460             terminate(Uncountable);
15461         return m_out.doubleZero;
15462     }
15463 
15464     LValue lowJSValue(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
15465     {
15466         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || edge.useKind() == UntypedUse, m_node-&gt;op(), edge.useKind());
15467         DFG_ASSERT(m_graph, m_node, !isDouble(edge.useKind()), m_node-&gt;op(), edge.useKind());
15468         DFG_ASSERT(m_graph, m_node, edge.useKind() != Int52RepUse, m_node-&gt;op(), edge.useKind());
15469 
15470         if (edge-&gt;hasConstant()) {
15471             LValue result = m_out.constInt64(JSValue::encode(edge-&gt;asJSValue()));
15472             result-&gt;setOrigin(B3::Origin(edge.node()));
15473             return result;
15474         }
15475 
15476         LoweredNodeValue value = m_jsValueValues.get(edge.node());
15477         if (isValid(value))
15478             return value.value();
15479 
15480         value = m_int32Values.get(edge.node());
15481         if (isValid(value)) {
15482             LValue result = boxInt32(value.value());
15483             setJSValue(edge.node(), result);
15484             return result;
15485         }
15486 
15487         value = m_booleanValues.get(edge.node());
15488         if (isValid(value)) {
15489             LValue result = boxBoolean(value.value());
15490             setJSValue(edge.node(), result);
15491             return result;
15492         }
15493 
15494         DFG_CRASH(m_graph, m_node, makeString(&quot;Value not defined: &quot;, String::number(edge.node()-&gt;index())).ascii().data());
15495         return 0;
15496     }
15497 
15498     LValue lowNotCell(Edge edge)
15499     {
15500         LValue result = lowJSValue(edge, ManualOperandSpeculation);
15501         FTL_TYPE_CHECK(jsValueValue(result), edge, ~SpecCellCheck, isCell(result));
15502         return result;
15503     }
15504 
15505     LValue lowStorage(Edge edge)
15506     {
15507         LoweredNodeValue value = m_storageValues.get(edge.node());
15508         if (isValid(value))
15509             return value.value();
15510 
15511         LValue result = lowCell(edge);
15512         setStorage(edge.node(), result);
15513         return result;
15514     }
15515 
15516     LValue strictInt52ToInt32(Edge edge, LValue value)
15517     {
15518         LValue result = m_out.castToInt32(value);
15519         FTL_TYPE_CHECK(
15520             noValue(), edge, SpecInt32Only,
15521             m_out.notEqual(m_out.signExt32To64(result), value));
15522         setInt32(edge.node(), result);
15523         return result;
15524     }
15525 
15526     LValue strictInt52ToDouble(LValue value)
15527     {
15528         return m_out.intToDouble(value);
15529     }
15530 
15531     LValue strictInt52ToJSValue(LValue value)
15532     {
15533         LBasicBlock isInt32 = m_out.newBlock();
15534         LBasicBlock isDouble = m_out.newBlock();
15535         LBasicBlock continuation = m_out.newBlock();
15536 
15537         Vector&lt;ValueFromBlock, 2&gt; results;
15538 
15539         LValue int32Value = m_out.castToInt32(value);
15540         m_out.branch(
15541             m_out.equal(m_out.signExt32To64(int32Value), value),
15542             unsure(isInt32), unsure(isDouble));
15543 
15544         LBasicBlock lastNext = m_out.appendTo(isInt32, isDouble);
15545 
15546         results.append(m_out.anchor(boxInt32(int32Value)));
15547         m_out.jump(continuation);
15548 
15549         m_out.appendTo(isDouble, continuation);
15550 
15551         results.append(m_out.anchor(boxDouble(m_out.intToDouble(value))));
15552         m_out.jump(continuation);
15553 
15554         m_out.appendTo(continuation, lastNext);
15555         return m_out.phi(Int64, results);
15556     }
15557 
15558     LValue strictInt52ToInt52(LValue value)
15559     {
15560         return m_out.shl(value, m_out.constInt64(JSValue::int52ShiftAmount));
15561     }
15562 
15563     LValue int52ToStrictInt52(LValue value)
15564     {
15565         return m_out.aShr(value, m_out.constInt64(JSValue::int52ShiftAmount));
15566     }
15567 
15568     LValue isInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
15569     {
15570         if (LValue proven = isProvenValue(type, SpecInt32Only))
15571             return proven;
15572         return m_out.aboveOrEqual(jsValue, m_tagTypeNumber);
15573     }
15574     LValue isNotInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
15575     {
15576         if (LValue proven = isProvenValue(type, ~SpecInt32Only))
15577             return proven;
15578         return m_out.below(jsValue, m_tagTypeNumber);
15579     }
15580     LValue unboxInt32(LValue jsValue)
15581     {
15582         return m_out.castToInt32(jsValue);
15583     }
15584     LValue boxInt32(LValue value)
15585     {
15586         return m_out.add(m_out.zeroExt(value, Int64), m_tagTypeNumber);
15587     }
15588 
15589     LValue isCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
15590     {
15591         if (LValue proven = isProvenValue(type, SpecCellCheck | SpecMisc))
15592             return proven;
15593         return m_out.testIsZero64(jsValue, m_tagTypeNumber);
15594     }
15595     LValue isNotCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
15596     {
15597         if (LValue proven = isProvenValue(type, ~(SpecCellCheck | SpecMisc)))
15598             return proven;
15599         return m_out.testNonZero64(jsValue, m_tagTypeNumber);
15600     }
15601 
15602     LValue unboxDouble(LValue jsValue, LValue* unboxedAsInt = nullptr)
15603     {
15604         LValue asInt = m_out.add(jsValue, m_tagTypeNumber);
15605         if (unboxedAsInt)
15606             *unboxedAsInt = asInt;
15607         return m_out.bitCast(asInt, Double);
15608     }
15609     LValue boxDouble(LValue doubleValue)
15610     {
15611         return m_out.sub(m_out.bitCast(doubleValue, Int64), m_tagTypeNumber);
15612     }
15613 
15614     LValue jsValueToStrictInt52(Edge edge, LValue boxedValue)
15615     {
15616         LBasicBlock intCase = m_out.newBlock();
15617         LBasicBlock doubleCase = m_out.newBlock();
15618         LBasicBlock continuation = m_out.newBlock();
15619 
15620         LValue isNotInt32;
15621         if (!m_interpreter.needsTypeCheck(edge, SpecInt32Only))
15622             isNotInt32 = m_out.booleanFalse;
15623         else if (!m_interpreter.needsTypeCheck(edge, ~SpecInt32Only))
15624             isNotInt32 = m_out.booleanTrue;
15625         else
15626             isNotInt32 = this-&gt;isNotInt32(boxedValue);
15627         m_out.branch(isNotInt32, unsure(doubleCase), unsure(intCase));
15628 
15629         LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
15630 
15631         ValueFromBlock intToInt52 = m_out.anchor(
15632             m_out.signExt32To64(unboxInt32(boxedValue)));
15633         m_out.jump(continuation);
15634 
15635         m_out.appendTo(doubleCase, continuation);
15636 
15637         LValue possibleResult = m_out.call(
15638             Int64, m_out.operation(operationConvertBoxedDoubleToInt52), boxedValue);
15639         FTL_TYPE_CHECK(
15640             jsValueValue(boxedValue), edge, SpecInt32Only | SpecAnyIntAsDouble,
15641             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
15642 
15643         ValueFromBlock doubleToInt52 = m_out.anchor(possibleResult);
15644         m_out.jump(continuation);
15645 
15646         m_out.appendTo(continuation, lastNext);
15647 
15648         return m_out.phi(Int64, intToInt52, doubleToInt52);
15649     }
15650 
15651     LValue doubleToStrictInt52(Edge edge, LValue value)
15652     {
15653         LValue possibleResult = m_out.call(
15654             Int64, m_out.operation(operationConvertDoubleToInt52), value);
15655         FTL_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,
15656             doubleValue(value), edge, SpecAnyIntAsDouble,
15657             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
15658 
15659         return possibleResult;
15660     }
15661 
15662     LValue convertDoubleToInt32(LValue value, bool shouldCheckNegativeZero)
15663     {
15664         LValue integerValue = m_out.doubleToInt(value);
15665         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
15666         LValue valueNotConvertibleToInteger = m_out.doubleNotEqualOrUnordered(value, integerValueConvertedToDouble);
15667         speculate(Overflow, FormattedValue(DataFormatDouble, value), m_node, valueNotConvertibleToInteger);
15668 
15669         if (shouldCheckNegativeZero) {
15670             LBasicBlock valueIsZero = m_out.newBlock();
15671             LBasicBlock continuation = m_out.newBlock();
15672             m_out.branch(m_out.isZero32(integerValue), unsure(valueIsZero), unsure(continuation));
15673 
15674             LBasicBlock lastNext = m_out.appendTo(valueIsZero, continuation);
15675 
15676             LValue doubleBitcastToInt64 = m_out.bitCast(value, Int64);
15677             LValue signBitSet = m_out.lessThan(doubleBitcastToInt64, m_out.constInt64(0));
15678 
15679             speculate(NegativeZero, FormattedValue(DataFormatDouble, value), m_node, signBitSet);
15680             m_out.jump(continuation);
15681             m_out.appendTo(continuation, lastNext);
15682         }
15683         return integerValue;
15684     }
15685 
15686     LValue isNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
15687     {
15688         if (LValue proven = isProvenValue(type, SpecFullNumber))
15689             return proven;
15690         return isNotCellOrMisc(jsValue);
15691     }
15692     LValue isNotNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
15693     {
15694         if (LValue proven = isProvenValue(type, ~SpecFullNumber))
15695             return proven;
15696         return isCellOrMisc(jsValue);
15697     }
15698 
15699     LValue isNotCell(LValue jsValue, SpeculatedType type = SpecFullTop)
15700     {
15701         if (LValue proven = isProvenValue(type, ~SpecCellCheck))
15702             return proven;
15703         return m_out.testNonZero64(jsValue, m_tagMask);
15704     }
15705 
15706     LValue isCell(LValue jsValue, SpeculatedType type = SpecFullTop)
15707     {
15708         if (LValue proven = isProvenValue(type, SpecCellCheck))
15709             return proven;
15710         return m_out.testIsZero64(jsValue, m_tagMask);
15711     }
15712 
15713     LValue isNotMisc(LValue value, SpeculatedType type = SpecFullTop)
15714     {
15715         if (LValue proven = isProvenValue(type, ~SpecMisc))
15716             return proven;
15717         return m_out.above(value, m_out.constInt64(TagBitTypeOther | TagBitBool | TagBitUndefined));
15718     }
15719 
15720     LValue isMisc(LValue value, SpeculatedType type = SpecFullTop)
15721     {
15722         if (LValue proven = isProvenValue(type, SpecMisc))
15723             return proven;
15724         return m_out.logicalNot(isNotMisc(value));
15725     }
15726 
15727     LValue isNotBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
15728     {
15729         if (LValue proven = isProvenValue(type, ~SpecBoolean))
15730             return proven;
15731         return m_out.testNonZero64(
15732             m_out.bitXor(jsValue, m_out.constInt64(ValueFalse)),
15733             m_out.constInt64(~1));
15734     }
15735     LValue isBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
15736     {
15737         if (LValue proven = isProvenValue(type, SpecBoolean))
15738             return proven;
15739         return m_out.logicalNot(isNotBoolean(jsValue));
15740     }
15741     LValue unboxBoolean(LValue jsValue)
15742     {
15743         // We want to use a cast that guarantees that B3 knows that even the integer
15744         // value is just 0 or 1. But for now we do it the dumb way.
15745         return m_out.notZero64(m_out.bitAnd(jsValue, m_out.constInt64(1)));
15746     }
15747     LValue boxBoolean(LValue value)
15748     {
15749         return m_out.select(
15750             value, m_out.constInt64(ValueTrue), m_out.constInt64(ValueFalse));
15751     }
15752 
15753     LValue isNotOther(LValue value, SpeculatedType type = SpecFullTop)
15754     {
15755         if (LValue proven = isProvenValue(type, ~SpecOther))
15756             return proven;
15757         return m_out.notEqual(
15758             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),
15759             m_out.constInt64(ValueNull));
15760     }
15761     LValue isOther(LValue value, SpeculatedType type = SpecFullTop)
15762     {
15763         if (LValue proven = isProvenValue(type, SpecOther))
15764             return proven;
15765         return m_out.equal(
15766             m_out.bitAnd(value, m_out.constInt64(~TagBitUndefined)),
15767             m_out.constInt64(ValueNull));
15768     }
15769 
15770     LValue isProvenValue(SpeculatedType provenType, SpeculatedType wantedType)
15771     {
15772         if (!(provenType &amp; ~wantedType))
15773             return m_out.booleanTrue;
15774         if (!(provenType &amp; wantedType))
15775             return m_out.booleanFalse;
15776         return nullptr;
15777     }
15778 
15779     void speculate(Edge edge)
15780     {
15781         switch (edge.useKind()) {
15782         case UntypedUse:
15783             break;
15784         case KnownInt32Use:
15785         case KnownStringUse:
15786         case KnownPrimitiveUse:
15787         case KnownOtherUse:
15788         case DoubleRepUse:
15789         case Int52RepUse:
15790         case KnownCellUse:
15791         case KnownBooleanUse:
15792             ASSERT(!m_interpreter.needsTypeCheck(edge));
15793             break;
15794         case Int32Use:
15795             speculateInt32(edge);
15796             break;
15797         case CellUse:
15798             speculateCell(edge);
15799             break;
15800         case CellOrOtherUse:
15801             speculateCellOrOther(edge);
15802             break;
15803         case AnyIntUse:
15804             speculateAnyInt(edge);
15805             break;
15806         case ObjectUse:
15807             speculateObject(edge);
15808             break;
15809         case ArrayUse:
15810             speculateArray(edge);
15811             break;
15812         case FunctionUse:
15813             speculateFunction(edge);
15814             break;
15815         case ObjectOrOtherUse:
15816             speculateObjectOrOther(edge);
15817             break;
15818         case FinalObjectUse:
15819             speculateFinalObject(edge);
15820             break;
15821         case RegExpObjectUse:
15822             speculateRegExpObject(edge);
15823             break;
15824         case ProxyObjectUse:
15825             speculateProxyObject(edge);
15826             break;
15827         case DerivedArrayUse:
15828             speculateDerivedArray(edge);
15829             break;
15830         case MapObjectUse:
15831             speculateMapObject(edge);
15832             break;
15833         case SetObjectUse:
15834             speculateSetObject(edge);
15835             break;
15836         case WeakMapObjectUse:
15837             speculateWeakMapObject(edge);
15838             break;
15839         case WeakSetObjectUse:
15840             speculateWeakSetObject(edge);
15841             break;
15842         case DataViewObjectUse:
15843             speculateDataViewObject(edge);
15844             break;
15845         case StringUse:
15846             speculateString(edge);
15847             break;
15848         case StringOrOtherUse:
15849             speculateStringOrOther(edge);
15850             break;
15851         case StringIdentUse:
15852             speculateStringIdent(edge);
15853             break;
15854         case SymbolUse:
15855             speculateSymbol(edge);
15856             break;
15857         case StringObjectUse:
15858             speculateStringObject(edge);
15859             break;
15860         case StringOrStringObjectUse:
15861             speculateStringOrStringObject(edge);
15862             break;
15863         case NumberUse:
15864             speculateNumber(edge);
15865             break;
15866         case RealNumberUse:
15867             speculateRealNumber(edge);
15868             break;
15869         case DoubleRepRealUse:
15870             speculateDoubleRepReal(edge);
15871             break;
15872         case DoubleRepAnyIntUse:
15873             speculateDoubleRepAnyInt(edge);
15874             break;
15875         case BooleanUse:
15876             speculateBoolean(edge);
15877             break;
15878         case BigIntUse:
15879             speculateBigInt(edge);
15880             break;
15881         case NotStringVarUse:
15882             speculateNotStringVar(edge);
15883             break;
15884         case NotSymbolUse:
15885             speculateNotSymbol(edge);
15886             break;
15887         case NotCellUse:
15888             speculateNotCell(edge);
15889             break;
15890         case OtherUse:
15891             speculateOther(edge);
15892             break;
15893         case MiscUse:
15894             speculateMisc(edge);
15895             break;
15896         default:
15897             DFG_CRASH(m_graph, m_node, &quot;Unsupported speculation use kind&quot;);
15898         }
15899     }
15900 
15901     void speculate(Node*, Edge edge)
15902     {
15903         speculate(edge);
15904     }
15905 
15906     void speculateInt32(Edge edge)
15907     {
15908         lowInt32(edge);
15909     }
15910 
15911     void speculateCell(Edge edge)
15912     {
15913         lowCell(edge);
15914     }
15915 
15916     void speculateNotCell(Edge edge)
15917     {
15918         if (!m_interpreter.needsTypeCheck(edge))
15919             return;
15920         lowNotCell(edge);
15921     }
15922 
15923     void speculateCellOrOther(Edge edge)
15924     {
15925         if (shouldNotHaveTypeCheck(edge.useKind()))
15926             return;
15927 
15928         LValue value = lowJSValue(edge, ManualOperandSpeculation);
15929 
15930         LBasicBlock isNotCell = m_out.newBlock();
15931         LBasicBlock continuation = m_out.newBlock();
15932 
15933         m_out.branch(isCell(value, provenType(edge)), unsure(continuation), unsure(isNotCell));
15934 
15935         LBasicBlock lastNext = m_out.appendTo(isNotCell, continuation);
15936         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
15937         m_out.jump(continuation);
15938 
15939         m_out.appendTo(continuation, lastNext);
15940     }
15941 
15942     void speculateAnyInt(Edge edge)
15943     {
15944         if (!m_interpreter.needsTypeCheck(edge))
15945             return;
15946 
15947         jsValueToStrictInt52(edge, lowJSValue(edge, ManualOperandSpeculation));
15948     }
15949 
15950     LValue isCellWithType(LValue cell, JSType queriedType, SpeculatedType speculatedTypeForQuery, SpeculatedType type = SpecFullTop)
15951     {
15952         if (LValue proven = isProvenValue(type &amp; SpecCell, speculatedTypeForQuery))
15953             return proven;
15954         return m_out.equal(
15955             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15956             m_out.constInt32(queriedType));
15957     }
15958 
15959     LValue isTypedArrayView(LValue cell, SpeculatedType type = SpecFullTop)
15960     {
15961         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecTypedArrayView))
15962             return proven;
15963         LValue jsType = m_out.sub(
15964             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15965             m_out.constInt32(FirstTypedArrayType));
15966         return m_out.below(
15967             jsType,
15968             m_out.constInt32(NumberOfTypedArrayTypesExcludingDataView));
15969     }
15970 
15971     LValue isObject(LValue cell, SpeculatedType type = SpecFullTop)
15972     {
15973         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecObject))
15974             return proven;
15975         return m_out.aboveOrEqual(
15976             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15977             m_out.constInt32(ObjectType));
15978     }
15979 
15980     LValue isNotObject(LValue cell, SpeculatedType type = SpecFullTop)
15981     {
15982         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecObject))
15983             return proven;
15984         return m_out.below(
15985             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
15986             m_out.constInt32(ObjectType));
15987     }
15988 
15989     LValue isNotString(LValue cell, SpeculatedType type = SpecFullTop)
15990     {
15991         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecString))
15992             return proven;
15993         return m_out.notEqual(
15994             m_out.load32(cell, m_heaps.JSCell_structureID),
15995             m_out.constInt32(vm().stringStructure-&gt;id()));
15996     }
15997 
15998     LValue isString(LValue cell, SpeculatedType type = SpecFullTop)
15999     {
16000         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecString))
16001             return proven;
16002         return m_out.equal(
16003             m_out.load32(cell, m_heaps.JSCell_structureID),
16004             m_out.constInt32(vm().stringStructure-&gt;id()));
16005     }
16006 
16007     LValue isRopeString(LValue string, Edge edge = Edge())
16008     {
16009         if (edge) {
16010             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16011                 return m_out.booleanFalse;
16012             if (JSValue value = provenValue(edge)) {
16013                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16014                     return m_out.booleanFalse;
16015             }
16016             String value = edge-&gt;tryGetString(m_graph);
16017             if (!value.isNull()) {
16018                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.
16019                 return m_out.booleanFalse;
16020             }
16021         }
16022 
16023         return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16024     }
16025 
16026     LValue isNotRopeString(LValue string, Edge edge = Edge())
16027     {
16028         if (edge) {
16029             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16030                 return m_out.booleanTrue;
16031             if (JSValue value = provenValue(edge)) {
16032                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16033                     return m_out.booleanTrue;
16034             }
16035             String value = edge-&gt;tryGetString(m_graph);
16036             if (!value.isNull()) {
16037                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.
16038                 return m_out.booleanTrue;
16039             }
16040         }
16041 
16042         return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16043     }
16044 
16045     LValue isNotSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16046     {
16047         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecSymbol))
16048             return proven;
16049         return m_out.notEqual(
16050             m_out.load32(cell, m_heaps.JSCell_structureID),
16051             m_out.constInt32(vm().symbolStructure-&gt;id()));
16052     }
16053 
16054     LValue isSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16055     {
16056         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecSymbol))
16057             return proven;
16058         return m_out.equal(
16059             m_out.load32(cell, m_heaps.JSCell_structureID),
16060             m_out.constInt32(vm().symbolStructure-&gt;id()));
16061     }
16062 
16063     LValue isNotBigInt(LValue cell, SpeculatedType type = SpecFullTop)
16064     {
16065         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecBigInt))
16066             return proven;
16067         return m_out.notEqual(
16068             m_out.load32(cell, m_heaps.JSCell_structureID),
16069             m_out.constInt32(vm().bigIntStructure-&gt;id()));
16070     }
16071 
16072     LValue isBigInt(LValue cell, SpeculatedType type = SpecFullTop)
16073     {
16074         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecBigInt))
16075             return proven;
16076         return m_out.equal(
16077             m_out.load32(cell, m_heaps.JSCell_structureID),
16078             m_out.constInt32(vm().bigIntStructure-&gt;id()));
16079     }
16080 
16081     LValue isArrayTypeForArrayify(LValue cell, ArrayMode arrayMode)
16082     {
16083         switch (arrayMode.type()) {
16084         case Array::Int32:
16085         case Array::Double:
16086         case Array::Contiguous:
16087         case Array::Undecided:
16088         case Array::ArrayStorage: {
16089             IndexingType indexingModeMask = IsArray | IndexingShapeMask;
16090             if (arrayMode.action() == Array::Write)
16091                 indexingModeMask |= CopyOnWrite;
16092 
16093             IndexingType shape = arrayMode.shapeMask();
16094             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
16095 
16096             switch (arrayMode.arrayClass()) {
16097             case Array::OriginalArray:
16098             case Array::OriginalCopyOnWriteArray:
16099                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
16100                 return nullptr;
16101 
16102             case Array::Array:
16103                 return m_out.equal(
16104                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
16105                     m_out.constInt32(IsArray | shape));
16106 
16107             case Array::NonArray:
16108             case Array::OriginalNonArray:
16109                 return m_out.equal(
16110                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
16111                     m_out.constInt32(shape));
16112 
16113             case Array::PossiblyArray:
16114                 return m_out.equal(
16115                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask &amp; ~IsArray)),
16116                     m_out.constInt32(shape));
16117             }
16118             break;
16119         }
16120 
16121         case Array::SlowPutArrayStorage: {
16122             ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
16123             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
16124 
16125             LBasicBlock trueCase = m_out.newBlock();
16126             LBasicBlock checkCase = m_out.newBlock();
16127             LBasicBlock continuation = m_out.newBlock();
16128 
16129             ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
16130             LValue isAnArrayStorageShape = m_out.belowOrEqual(
16131                 m_out.sub(
16132                     m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)),
16133                     m_out.constInt32(ArrayStorageShape)),
16134                 m_out.constInt32(SlowPutArrayStorageShape - ArrayStorageShape));
16135             m_out.branch(isAnArrayStorageShape, unsure(checkCase), unsure(continuation));
16136 
16137             LBasicBlock lastNext = m_out.appendTo(checkCase, trueCase);
16138             switch (arrayMode.arrayClass()) {
16139             case Array::OriginalArray:
16140             case Array::OriginalCopyOnWriteArray:
16141                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
16142                 return nullptr;
16143 
16144             case Array::Array:
16145                 m_out.branch(
16146                     m_out.testNonZero32(indexingType, m_out.constInt32(IsArray)),
16147                     unsure(trueCase), unsure(continuation));
16148                 break;
16149 
16150             case Array::NonArray:
16151             case Array::OriginalNonArray:
16152                 m_out.branch(
16153                     m_out.testIsZero32(indexingType, m_out.constInt32(IsArray)),
16154                     unsure(trueCase), unsure(continuation));
16155                 break;
16156 
16157             case Array::PossiblyArray:
16158                 m_out.jump(trueCase);
16159                 break;
16160             }
16161 
16162             m_out.appendTo(trueCase, continuation);
16163             ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
16164             m_out.jump(continuation);
16165 
16166             m_out.appendTo(continuation, lastNext);
16167             return m_out.phi(Int32, falseValue, trueValue);
16168         }
16169 
16170         default:
16171             break;
16172         }
16173         DFG_CRASH(m_graph, m_node, &quot;Corrupt array class&quot;);
16174     }
16175 
16176     LValue isArrayTypeForCheckArray(LValue cell, ArrayMode arrayMode)
16177     {
16178         switch (arrayMode.type()) {
16179         case Array::Int32:
16180         case Array::Double:
16181         case Array::Contiguous:
16182         case Array::Undecided:
16183         case Array::ArrayStorage:
16184         case Array::SlowPutArrayStorage:
16185             return isArrayTypeForArrayify(cell, arrayMode);
16186 
16187         case Array::DirectArguments:
16188             return m_out.equal(
16189                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16190                 m_out.constInt32(DirectArgumentsType));
16191 
16192         case Array::ScopedArguments:
16193             return m_out.equal(
16194                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16195                 m_out.constInt32(ScopedArgumentsType));
16196 
16197         default:
16198             return m_out.equal(
16199                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16200                 m_out.constInt32(typeForTypedArrayType(arrayMode.typedArrayType())));
16201         }
16202     }
16203 
16204     LValue isFunction(LValue cell, SpeculatedType type = SpecFullTop)
16205     {
16206         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecFunction))
16207             return proven;
16208         return isType(cell, JSFunctionType);
16209     }
16210     LValue isNotFunction(LValue cell, SpeculatedType type = SpecFullTop)
16211     {
16212         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecFunction))
16213             return proven;
16214         return isNotType(cell, JSFunctionType);
16215     }
16216 
16217     LValue isExoticForTypeof(LValue cell, SpeculatedType type = SpecFullTop)
16218     {
16219         if (!(type &amp; SpecObjectOther))
16220             return m_out.booleanFalse;
16221         return m_out.testNonZero32(
16222             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
16223             m_out.constInt32(MasqueradesAsUndefined | OverridesGetCallData));
16224     }
16225 
16226     LValue isType(LValue cell, JSType type)
16227     {
16228         return m_out.equal(
16229             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16230             m_out.constInt32(type));
16231     }
16232 
16233     LValue isNotType(LValue cell, JSType type)
16234     {
16235         return m_out.logicalNot(isType(cell, type));
16236     }
16237 
16238     void speculateObject(Edge edge, LValue cell)
16239     {
16240         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
16241     }
16242 
16243     void speculateObject(Edge edge)
16244     {
16245         speculateObject(edge, lowCell(edge));
16246     }
16247 
16248     void speculateArray(Edge edge, LValue cell)
16249     {
16250         FTL_TYPE_CHECK(
16251             jsValueValue(cell), edge, SpecArray, isNotType(cell, ArrayType));
16252     }
16253 
16254     void speculateArray(Edge edge)
16255     {
16256         speculateArray(edge, lowCell(edge));
16257     }
16258 
16259     void speculateFunction(Edge edge, LValue cell)
16260     {
16261         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecFunction, isNotFunction(cell));
16262     }
16263 
16264     void speculateFunction(Edge edge)
16265     {
16266         speculateFunction(edge, lowCell(edge));
16267     }
16268 
16269     void speculateObjectOrOther(Edge edge)
16270     {
16271         if (!m_interpreter.needsTypeCheck(edge))
16272             return;
16273 
16274         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16275 
16276         LBasicBlock cellCase = m_out.newBlock();
16277         LBasicBlock primitiveCase = m_out.newBlock();
16278         LBasicBlock continuation = m_out.newBlock();
16279 
16280         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
16281 
16282         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
16283 
16284         FTL_TYPE_CHECK(
16285             jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
16286 
16287         m_out.jump(continuation);
16288 
16289         m_out.appendTo(primitiveCase, continuation);
16290 
16291         FTL_TYPE_CHECK(
16292             jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
16293 
16294         m_out.jump(continuation);
16295 
16296         m_out.appendTo(continuation, lastNext);
16297     }
16298 
16299     void speculateFinalObject(Edge edge, LValue cell)
16300     {
16301         FTL_TYPE_CHECK(
16302             jsValueValue(cell), edge, SpecFinalObject, isNotType(cell, FinalObjectType));
16303     }
16304 
16305     void speculateFinalObject(Edge edge)
16306     {
16307         speculateFinalObject(edge, lowCell(edge));
16308     }
16309 
16310     void speculateRegExpObject(Edge edge, LValue cell)
16311     {
16312         FTL_TYPE_CHECK(
16313             jsValueValue(cell), edge, SpecRegExpObject, isNotType(cell, RegExpObjectType));
16314     }
16315 
16316     void speculateRegExpObject(Edge edge)
16317     {
16318         speculateRegExpObject(edge, lowCell(edge));
16319     }
16320 
16321     void speculateProxyObject(Edge edge, LValue cell)
16322     {
16323         FTL_TYPE_CHECK(
16324             jsValueValue(cell), edge, SpecProxyObject, isNotType(cell, ProxyObjectType));
16325     }
16326 
16327     void speculateProxyObject(Edge edge)
16328     {
16329         speculateProxyObject(edge, lowCell(edge));
16330     }
16331 
16332     void speculateDerivedArray(Edge edge, LValue cell)
16333     {
16334         FTL_TYPE_CHECK(
16335             jsValueValue(cell), edge, SpecDerivedArray, isNotType(cell, DerivedArrayType));
16336     }
16337 
16338     void speculateDerivedArray(Edge edge)
16339     {
16340         speculateDerivedArray(edge, lowCell(edge));
16341     }
16342 
16343     void speculateMapObject(Edge edge, LValue cell)
16344     {
16345         FTL_TYPE_CHECK(
16346             jsValueValue(cell), edge, SpecMapObject, isNotType(cell, JSMapType));
16347     }
16348 
16349     void speculateMapObject(Edge edge)
16350     {
16351         speculateMapObject(edge, lowCell(edge));
16352     }
16353 
16354     void speculateSetObject(Edge edge, LValue cell)
16355     {
16356         FTL_TYPE_CHECK(
16357             jsValueValue(cell), edge, SpecSetObject, isNotType(cell, JSSetType));
16358     }
16359 
16360     void speculateSetObject(Edge edge)
16361     {
16362         speculateSetObject(edge, lowCell(edge));
16363     }
16364 
16365     void speculateWeakMapObject(Edge edge, LValue cell)
16366     {
16367         FTL_TYPE_CHECK(
16368             jsValueValue(cell), edge, SpecWeakMapObject, isNotType(cell, JSWeakMapType));
16369     }
16370 
16371     void speculateWeakMapObject(Edge edge)
16372     {
16373         speculateWeakMapObject(edge, lowCell(edge));
16374     }
16375 
16376     void speculateWeakSetObject(Edge edge, LValue cell)
16377     {
16378         FTL_TYPE_CHECK(
16379             jsValueValue(cell), edge, SpecWeakSetObject, isNotType(cell, JSWeakSetType));
16380     }
16381 
16382     void speculateWeakSetObject(Edge edge)
16383     {
16384         speculateWeakSetObject(edge, lowCell(edge));
16385     }
16386 
16387     void speculateDataViewObject(Edge edge, LValue cell)
16388     {
16389         FTL_TYPE_CHECK(
16390             jsValueValue(cell), edge, SpecDataViewObject, isNotType(cell, DataViewType));
16391     }
16392 
16393     void speculateDataViewObject(Edge edge)
16394     {
16395         speculateDataViewObject(edge, lowCell(edge));
16396     }
16397 
16398     void speculateString(Edge edge, LValue cell)
16399     {
16400         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecString, isNotString(cell));
16401     }
16402 
16403     void speculateString(Edge edge)
16404     {
16405         speculateString(edge, lowCell(edge));
16406     }
16407 
16408     void speculateStringOrOther(Edge edge, LValue value)
16409     {
16410         if (!m_interpreter.needsTypeCheck(edge))
16411             return;
16412 
16413         LBasicBlock cellCase = m_out.newBlock();
16414         LBasicBlock notCellCase = m_out.newBlock();
16415         LBasicBlock continuation = m_out.newBlock();
16416 
16417         m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
16418 
16419         LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
16420 
16421         FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
16422 
16423         m_out.jump(continuation);
16424         m_out.appendTo(notCellCase, continuation);
16425 
16426         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
16427 
16428         m_out.jump(continuation);
16429         m_out.appendTo(continuation, lastNext);
16430     }
16431 
16432     void speculateStringOrOther(Edge edge)
16433     {
16434         speculateStringOrOther(edge, lowJSValue(edge, ManualOperandSpeculation));
16435     }
16436 
16437     void speculateStringIdent(Edge edge, LValue string, LValue stringImpl)
16438     {
16439         if (!m_interpreter.needsTypeCheck(edge, SpecStringIdent | ~SpecString))
16440             return;
16441 
16442         speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
16443         speculate(
16444             BadType, jsValueValue(string), edge.node(),
16445             m_out.testIsZero32(
16446                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
16447                 m_out.constInt32(StringImpl::flagIsAtom())));
16448         m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
16449     }
16450 
16451     void speculateStringIdent(Edge edge)
16452     {
16453         lowStringIdent(edge);
16454     }
16455 
16456     void speculateStringObject(Edge edge)
16457     {
16458         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16459             return;
16460 
16461         speculateStringObjectForCell(edge, lowCell(edge));
16462     }
16463 
16464     void speculateStringOrStringObject(Edge edge)
16465     {
16466         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16467             return;
16468 
16469         LValue cellBase = lowCell(edge);
16470         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
16471             return;
16472 
16473         LBasicBlock notString = m_out.newBlock();
16474         LBasicBlock continuation = m_out.newBlock();
16475 
16476         LValue type = m_out.load8ZeroExt32(cellBase, m_heaps.JSCell_typeInfoType);
16477         m_out.branch(
16478             m_out.equal(type, m_out.constInt32(StringType)),
16479             unsure(continuation), unsure(notString));
16480 
16481         LBasicBlock lastNext = m_out.appendTo(notString, continuation);
16482         speculate(
16483             BadType, jsValueValue(cellBase), edge.node(),
16484             m_out.notEqual(type, m_out.constInt32(StringObjectType)));
16485         m_out.jump(continuation);
16486 
16487         m_out.appendTo(continuation, lastNext);
16488         m_interpreter.filter(edge, SpecString | SpecStringObject);
16489     }
16490 
16491     void speculateStringObjectForCell(Edge edge, LValue cell)
16492     {
16493         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
16494             return;
16495 
16496         LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
16497         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecStringObject, m_out.notEqual(type, m_out.constInt32(StringObjectType)));
16498     }
16499 
16500     void speculateSymbol(Edge edge, LValue cell)
16501     {
16502         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecSymbol, isNotSymbol(cell));
16503     }
16504 
16505     void speculateSymbol(Edge edge)
16506     {
16507         speculateSymbol(edge, lowCell(edge));
16508     }
16509 
16510     void speculateBigInt(Edge edge, LValue cell)
16511     {
16512         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecBigInt, isNotBigInt(cell));
16513     }
16514 
16515     void speculateBigInt(Edge edge)
16516     {
16517         speculateBigInt(edge, lowCell(edge));
16518     }
16519 
16520     void speculateNonNullObject(Edge edge, LValue cell)
16521     {
16522         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
16523         if (masqueradesAsUndefinedWatchpointIsStillValid())
16524             return;
16525 
16526         speculate(
16527             BadType, jsValueValue(cell), edge.node(),
16528             m_out.testNonZero32(
16529                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
16530                 m_out.constInt32(MasqueradesAsUndefined)));
16531     }
16532 
16533     void speculateNumber(Edge edge)
16534     {
16535         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16536         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isNotNumber(value));
16537     }
16538 
16539     void speculateRealNumber(Edge edge)
16540     {
16541         // Do an early return here because lowDouble() can create a lot of control flow.
16542         if (!m_interpreter.needsTypeCheck(edge))
16543             return;
16544 
16545         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16546         LValue doubleValue = unboxDouble(value);
16547 
16548         LBasicBlock intCase = m_out.newBlock();
16549         LBasicBlock continuation = m_out.newBlock();
16550 
16551         m_out.branch(
16552             m_out.doubleEqual(doubleValue, doubleValue),
16553             usually(continuation), rarely(intCase));
16554 
16555         LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
16556 
16557         typeCheck(
16558             jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
16559             isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecFullDouble));
16560         m_out.jump(continuation);
16561 
16562         m_out.appendTo(continuation, lastNext);
16563     }
16564 
16565     void speculateDoubleRepReal(Edge edge)
16566     {
16567         // Do an early return here because lowDouble() can create a lot of control flow.
16568         if (!m_interpreter.needsTypeCheck(edge))
16569             return;
16570 
16571         LValue value = lowDouble(edge);
16572         FTL_TYPE_CHECK(
16573             doubleValue(value), edge, SpecDoubleReal,
16574             m_out.doubleNotEqualOrUnordered(value, value));
16575     }
16576 
16577     void speculateDoubleRepAnyInt(Edge edge)
16578     {
16579         if (!m_interpreter.needsTypeCheck(edge))
16580             return;
16581 
16582         doubleToStrictInt52(edge, lowDouble(edge));
16583     }
16584 
16585     void speculateBoolean(Edge edge)
16586     {
16587         lowBoolean(edge);
16588     }
16589 
16590     void speculateNotStringVar(Edge edge)
16591     {
16592         if (!m_interpreter.needsTypeCheck(edge, ~SpecStringVar))
16593             return;
16594 
16595         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16596 
16597         LBasicBlock isCellCase = m_out.newBlock();
16598         LBasicBlock isStringCase = m_out.newBlock();
16599         LBasicBlock continuation = m_out.newBlock();
16600 
16601         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
16602 
16603         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
16604         m_out.branch(isString(value, provenType(edge)), unsure(isStringCase), unsure(continuation));
16605 
16606         m_out.appendTo(isStringCase, continuation);
16607         speculateStringIdent(edge, value, m_out.loadPtr(value, m_heaps.JSString_value));
16608         m_out.jump(continuation);
16609 
16610         m_out.appendTo(continuation, lastNext);
16611     }
16612 
16613     void speculateNotSymbol(Edge edge)
16614     {
16615         if (!m_interpreter.needsTypeCheck(edge, ~SpecSymbol))
16616             return;
16617 
16618         ASSERT(mayHaveTypeCheck(edge.useKind()));
16619         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16620 
16621         LBasicBlock isCellCase = m_out.newBlock();
16622         LBasicBlock continuation = m_out.newBlock();
16623 
16624         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
16625 
16626         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
16627         speculate(BadType, jsValueValue(value), edge.node(), isSymbol(value));
16628         m_out.jump(continuation);
16629 
16630         m_out.appendTo(continuation, lastNext);
16631 
16632         m_interpreter.filter(edge, ~SpecSymbol);
16633     }
16634 
16635     void speculateOther(Edge edge)
16636     {
16637         if (!m_interpreter.needsTypeCheck(edge))
16638             return;
16639 
16640         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16641         typeCheck(jsValueValue(value), edge, SpecOther, isNotOther(value));
16642     }
16643 
16644     void speculateMisc(Edge edge)
16645     {
16646         if (!m_interpreter.needsTypeCheck(edge))
16647             return;
16648 
16649         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16650         typeCheck(jsValueValue(value), edge, SpecMisc, isNotMisc(value));
16651     }
16652 
16653     void speculateTypedArrayIsNotNeutered(LValue base)
16654     {
16655         LBasicBlock isWasteful = m_out.newBlock();
16656         LBasicBlock continuation = m_out.newBlock();
16657 
16658         LValue mode = m_out.load32(base, m_heaps.JSArrayBufferView_mode);
16659         m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
16660             unsure(isWasteful), unsure(continuation));
16661 
16662         LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
16663         LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);
16664         // FIXME: We could probably make this a mask.
16665         // https://bugs.webkit.org/show_bug.cgi?id=197701
16666         vector = removeArrayPtrTag(vector);
16667         speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
16668         m_out.jump(continuation);
16669 
16670         m_out.appendTo(continuation, lastNext);
16671     }
16672 
16673     bool masqueradesAsUndefinedWatchpointIsStillValid()
16674     {
16675         return m_graph.masqueradesAsUndefinedWatchpointIsStillValid(m_node-&gt;origin.semantic);
16676     }
16677 
16678     LValue loadCellState(LValue base)
16679     {
16680         return m_out.load8ZeroExt32(base, m_heaps.JSCell_cellState);
16681     }
16682 
16683     void emitStoreBarrier(LValue base, bool isFenced)
16684     {
16685         LBasicBlock recheckPath = nullptr;
16686         if (isFenced)
16687             recheckPath = m_out.newBlock();
16688         LBasicBlock slowPath = m_out.newBlock();
16689         LBasicBlock continuation = m_out.newBlock();
16690 
16691         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isFenced ? recheckPath : slowPath);
16692 
16693         LValue threshold;
16694         if (isFenced)
16695             threshold = m_out.load32(m_out.absolute(vm().heap.addressOfBarrierThreshold()));
16696         else
16697             threshold = m_out.constInt32(blackThreshold);
16698 
16699         m_out.branch(
16700             m_out.above(loadCellState(base), threshold),
16701             usually(continuation), rarely(isFenced ? recheckPath : slowPath));
16702 
16703         if (isFenced) {
16704             m_out.appendTo(recheckPath, slowPath);
16705 
16706             m_out.fence(&amp;m_heaps.root, &amp;m_heaps.JSCell_cellState);
16707 
16708             m_out.branch(
16709                 m_out.above(loadCellState(base), m_out.constInt32(blackThreshold)),
16710                 usually(continuation), rarely(slowPath));
16711         }
16712 
16713         m_out.appendTo(slowPath, continuation);
16714 
16715         LValue call = vmCall(Void, m_out.operation(operationWriteBarrierSlowPath), m_callFrame, base);
16716         m_heaps.decorateCCallRead(&amp;m_heaps.root, call);
16717         m_heaps.decorateCCallWrite(&amp;m_heaps.JSCell_cellState, call);
16718 
16719         m_out.jump(continuation);
16720 
16721         m_out.appendTo(continuation, lastNext);
16722     }
16723 
16724     void mutatorFence()
16725     {
16726         if (isX86()) {
16727             m_out.fence(&amp;m_heaps.root, nullptr);
16728             return;
16729         }
16730 
16731         LBasicBlock slowPath = m_out.newBlock();
16732         LBasicBlock continuation = m_out.newBlock();
16733 
16734         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
16735 
16736         m_out.branch(
16737             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
16738             rarely(slowPath), usually(continuation));
16739 
16740         m_out.appendTo(slowPath, continuation);
16741 
16742         m_out.fence(&amp;m_heaps.root, nullptr);
16743         m_out.jump(continuation);
16744 
16745         m_out.appendTo(continuation, lastNext);
16746     }
16747 
16748     void nukeStructureAndSetButterfly(LValue butterfly, LValue object)
16749     {
16750         if (isX86()) {
16751             m_out.store32(
16752                 m_out.bitOr(
16753                     m_out.load32(object, m_heaps.JSCell_structureID),
16754                     m_out.constInt32(nukedStructureIDBit())),
16755                 object, m_heaps.JSCell_structureID);
16756             m_out.fence(&amp;m_heaps.root, nullptr);
16757             m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16758             m_out.fence(&amp;m_heaps.root, nullptr);
16759             return;
16760         }
16761 
16762         LBasicBlock fastPath = m_out.newBlock();
16763         LBasicBlock slowPath = m_out.newBlock();
16764         LBasicBlock continuation = m_out.newBlock();
16765 
16766         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastPath);
16767 
16768         m_out.branch(
16769             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
16770             rarely(slowPath), usually(fastPath));
16771 
16772         m_out.appendTo(fastPath, slowPath);
16773 
16774         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16775         m_out.jump(continuation);
16776 
16777         m_out.appendTo(slowPath, continuation);
16778 
16779         m_out.store32(
16780             m_out.bitOr(
16781                 m_out.load32(object, m_heaps.JSCell_structureID),
16782                 m_out.constInt32(nukedStructureIDBit())),
16783             object, m_heaps.JSCell_structureID);
16784         m_out.fence(&amp;m_heaps.root, nullptr);
16785         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
16786         m_out.fence(&amp;m_heaps.root, nullptr);
16787         m_out.jump(continuation);
16788 
16789         m_out.appendTo(continuation, lastNext);
16790     }
16791 
16792     LValue preciseIndexMask64(LValue value, LValue index, LValue limit)
16793     {
16794         return m_out.bitAnd(
16795             value,
16796             m_out.aShr(
16797                 m_out.sub(
16798                     index,
16799                     m_out.opaque(limit)),
16800                 m_out.constInt32(63)));
16801     }
16802 
16803     LValue preciseIndexMask32(LValue value, LValue index, LValue limit)
16804     {
16805         return preciseIndexMask64(value, m_out.zeroExt(index, Int64), m_out.zeroExt(limit, Int64));
16806     }
16807 
16808     template&lt;typename... Args&gt;
16809     LValue vmCall(LType type, LValue function, Args&amp;&amp;... args)
16810     {
16811         callPreflight();
16812         LValue result = m_out.call(type, function, std::forward&lt;Args&gt;(args)...);
16813         if (mayExit(m_graph, m_node))
16814             callCheck();
16815         else {
16816             // We can&#39;t exit due to an exception, so we also can&#39;t throw an exception.
16817 #ifndef NDEBUG
16818             LBasicBlock crash = m_out.newBlock();
16819             LBasicBlock continuation = m_out.newBlock();
16820 
16821             LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16822             LValue hadException = m_out.notZero64(exception);
16823 
16824             m_out.branch(
16825                 hadException, rarely(crash), usually(continuation));
16826 
16827             LBasicBlock lastNext = m_out.appendTo(crash, continuation);
16828             m_out.unreachable();
16829 
16830             m_out.appendTo(continuation, lastNext);
16831 #endif
16832         }
16833         return result;
16834     }
16835 
16836     void callPreflight(CodeOrigin codeOrigin)
16837     {
16838         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(codeOrigin);
16839         m_out.store32(
16840             m_out.constInt32(callSiteIndex.bits()),
16841             tagFor(CallFrameSlot::argumentCount));
16842     }
16843 
16844     void callPreflight()
16845     {
16846         callPreflight(codeOriginDescriptionOfCallSite());
16847     }
16848 
16849     CodeOrigin codeOriginDescriptionOfCallSite() const
16850     {
16851         CodeOrigin codeOrigin = m_node-&gt;origin.semantic;
16852         if (m_node-&gt;op() == TailCallInlinedCaller
16853             || m_node-&gt;op() == TailCallVarargsInlinedCaller
16854             || m_node-&gt;op() == TailCallForwardVarargsInlinedCaller
16855             || m_node-&gt;op() == DirectTailCallInlinedCaller) {
16856             // This case arises when you have a situation like this:
16857             // foo makes a call to bar, bar is inlined in foo. bar makes a call
16858             // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
16859             // and jaz is inlined in baz. We want the callframe for jaz to appear to
16860             // have caller be bar.
16861             codeOrigin = *codeOrigin.inlineCallFrame()-&gt;getCallerSkippingTailCalls();
16862         }
16863 
16864         return codeOrigin;
16865     }
16866 
16867     void callCheck()
16868     {
16869         if (Options::useExceptionFuzz())
16870             m_out.call(Void, m_out.operation(operationExceptionFuzz), m_callFrame);
16871 
16872         LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
16873         LValue hadException = m_out.notZero64(exception);
16874 
16875         CodeOrigin opCatchOrigin;
16876         HandlerInfo* exceptionHandler;
16877         if (m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler)) {
16878             bool exitOK = true;
16879             bool isExceptionHandler = true;
16880             appendOSRExit(
16881                 ExceptionCheck, noValue(), nullptr, hadException,
16882                 m_origin.withForExitAndExitOK(opCatchOrigin, exitOK), isExceptionHandler);
16883             return;
16884         }
16885 
16886         LBasicBlock continuation = m_out.newBlock();
16887 
16888         m_out.branch(
16889             hadException, rarely(m_handleExceptions), usually(continuation));
16890 
16891         m_out.appendTo(continuation);
16892     }
16893 
16894     RefPtr&lt;PatchpointExceptionHandle&gt; preparePatchpointForExceptions(PatchpointValue* value)
16895     {
16896         CodeOrigin opCatchOrigin;
16897         HandlerInfo* exceptionHandler;
16898         bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
16899         if (!willCatchException)
16900             return PatchpointExceptionHandle::defaultHandle(m_ftlState);
16901 
16902         dataLogLnIf(verboseCompilationEnabled(), &quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());
16903 
16904         bool exitOK = true;
16905         NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
16906 
16907         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
16908 
16909         // Compute the offset into the StackmapGenerationParams where we will find the exit arguments
16910         // we are about to append. We need to account for both the children we&#39;ve already added, and
16911         // for the possibility of a result value if the patchpoint is not void.
16912         unsigned offset = value-&gt;numChildren();
16913         if (value-&gt;type() != Void)
16914             offset++;
16915 
16916         // Use LateColdAny to ensure that the stackmap arguments interfere with the patchpoint&#39;s
16917         // result and with any late-clobbered registers.
16918         value-&gt;appendVectorWithRep(
16919             buildExitArguments(exitDescriptor, opCatchOrigin, noValue()),
16920             ValueRep::LateColdAny);
16921 
16922         return PatchpointExceptionHandle::create(
16923             m_ftlState, exitDescriptor, origin, offset, *exceptionHandler);
16924     }
16925 
16926     LBasicBlock lowBlock(DFG::BasicBlock* block)
16927     {
16928         return m_blocks.get(block);
16929     }
16930 
16931     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, Node* highValue)
16932     {
16933         return appendOSRExitDescriptor(lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue));
16934     }
16935 
16936     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
16937     {
16938         return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
16939             lowValue.format(), profile,
16940             availabilityMap().m_locals.numberOfArguments(),
16941             availabilityMap().m_locals.numberOfLocals());
16942     }
16943 
16944     void appendOSRExit(
16945         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
16946         NodeOrigin origin, bool isExceptionHandler = false)
16947     {
16948         return appendOSRExit(kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue),
16949             failCondition, origin, isExceptionHandler);
16950     }
16951 
16952     void appendOSRExit(
16953         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
16954         NodeOrigin origin, bool isExceptionHandler = false)
16955     {
16956         dataLogLnIf(verboseCompilationEnabled(), &quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());
16957 
16958         DFG_ASSERT(m_graph, m_node, origin.exitOK);
16959 
16960         if (!isExceptionHandler
16961             &amp;&amp; Options::useOSRExitFuzz()
16962             &amp;&amp; canUseOSRExitFuzzing(m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic))
16963             &amp;&amp; doOSRExitFuzzing()) {
16964             LValue numberOfFuzzChecks = m_out.add(
16965                 m_out.load32(m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks)),
16966                 m_out.int32One);
16967 
16968             m_out.store32(numberOfFuzzChecks, m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks));
16969 
16970             if (unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter()) {
16971                 failCondition = m_out.bitOr(
16972                     failCondition,
16973                     m_out.aboveOrEqual(numberOfFuzzChecks, m_out.constInt32(atOrAfter)));
16974             }
16975             if (unsigned at = Options::fireOSRExitFuzzAt()) {
16976                 failCondition = m_out.bitOr(
16977                     failCondition,
16978                     m_out.equal(numberOfFuzzChecks, m_out.constInt32(at)));
16979             }
16980         }
16981 
16982         if (failCondition == m_out.booleanFalse)
16983             return;
16984 
16985         blessSpeculation(
16986             m_out.speculate(failCondition), kind, lowValue, profile, origin);
16987     }
16988 
16989     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, Node* highValue, NodeOrigin origin)
16990     {
16991         blessSpeculation(value, kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue), origin);
16992     }
16993 
16994     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, NodeOrigin origin)
16995     {
16996         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(lowValue, profile);
16997 
16998         value-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, lowValue));
16999 
17000         State* state = &amp;m_ftlState;
17001         value-&gt;setGenerator(
17002             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
17003                 exitDescriptor-&gt;emitOSRExit(
17004                     *state, kind, origin, jit, params, 0);
17005             });
17006     }
17007 
17008     StackmapArgumentList buildExitArguments(
17009         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, FormattedValue lowValue,
17010         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
17011     {
17012         StackmapArgumentList result;
17013         buildExitArguments(
17014             exitDescriptor, exitOrigin, result, lowValue, offsetOfExitArgumentsInStackmapLocations);
17015         return result;
17016     }
17017 
17018     void buildExitArguments(
17019         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, StackmapArgumentList&amp; arguments, FormattedValue lowValue,
17020         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
17021     {
17022         if (!!lowValue)
17023             arguments.append(lowValue.value());
17024 
17025         AvailabilityMap availabilityMap = this-&gt;availabilityMap();
17026         availabilityMap.pruneByLiveness(m_graph, exitOrigin);
17027 
17028         HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt; map;
17029         availabilityMap.forEachAvailability(
17030             [&amp;] (Availability availability) {
17031                 if (!availability.shouldUseNode())
17032                     return;
17033 
17034                 Node* node = availability.node();
17035                 if (!node-&gt;isPhantomAllocation())
17036                     return;
17037 
17038                 auto result = map.add(node, nullptr);
17039                 if (result.isNewEntry) {
17040                     result.iterator-&gt;value =
17041                         exitDescriptor-&gt;m_materializations.add(node-&gt;op(), node-&gt;origin.semantic);
17042                 }
17043             });
17044 
17045         for (unsigned i = 0; i &lt; exitDescriptor-&gt;m_values.size(); ++i) {
17046             int operand = exitDescriptor-&gt;m_values.operandForIndex(i);
17047 
17048             Availability availability = availabilityMap.m_locals[i];
17049 
17050             if (Options::validateFTLOSRExitLiveness()
17051                 &amp;&amp; m_graph.m_plan.mode() != FTLForOSREntryMode) {
17052 
17053                 if (availability.isDead() &amp;&amp; m_graph.isLiveInBytecode(VirtualRegister(operand), exitOrigin))
17054                     DFG_CRASH(m_graph, m_node, toCString(&quot;Live bytecode local not available: operand = &quot;, VirtualRegister(operand), &quot;, availability = &quot;, availability, &quot;, origin = &quot;, exitOrigin).data());
17055             }
17056             ExitValue exitValue = exitValueForAvailability(arguments, map, availability);
17057             if (exitValue.hasIndexInStackmapLocations())
17058                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
17059             exitDescriptor-&gt;m_values[i] = exitValue;
17060         }
17061 
17062         for (auto heapPair : availabilityMap.m_heap) {
17063             Node* node = heapPair.key.base();
17064             ExitTimeObjectMaterialization* materialization = map.get(node);
17065             if (!materialization)
17066                 DFG_CRASH(m_graph, m_node, toCString(&quot;Could not find materialization for &quot;, node, &quot; in &quot;, availabilityMap).data());
17067             ExitValue exitValue = exitValueForAvailability(arguments, map, heapPair.value);
17068             if (exitValue.hasIndexInStackmapLocations())
17069                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
17070             materialization-&gt;add(
17071                 heapPair.key.descriptor(),
17072                 exitValue);
17073         }
17074 
17075         if (verboseCompilationEnabled()) {
17076             dataLog(&quot;        Exit values: &quot;, exitDescriptor-&gt;m_values, &quot;\n&quot;);
17077             if (!exitDescriptor-&gt;m_materializations.isEmpty()) {
17078                 dataLog(&quot;        Materializations: \n&quot;);
17079                 for (ExitTimeObjectMaterialization* materialization : exitDescriptor-&gt;m_materializations)
17080                     dataLog(&quot;            &quot;, pointerDump(materialization), &quot;\n&quot;);
17081             }
17082         }
17083     }
17084 
17085     ExitValue exitValueForAvailability(
17086         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
17087         Availability availability)
17088     {
17089         FlushedAt flush = availability.flushedAt();
17090         switch (flush.format()) {
17091         case DeadFlush:
17092         case ConflictingFlush:
17093             if (availability.hasNode())
17094                 return exitValueForNode(arguments, map, availability.node());
17095 
17096             // This means that the value is dead. It could be dead in bytecode or it could have
17097             // been killed by our DCE, which can sometimes kill things even if they were live in
17098             // bytecode.
17099             return ExitValue::dead();
17100 
17101         case FlushedJSValue:
17102         case FlushedCell:
17103         case FlushedBoolean:
17104             return ExitValue::inJSStack(flush.virtualRegister());
17105 
17106         case FlushedInt32:
17107             return ExitValue::inJSStackAsInt32(flush.virtualRegister());
17108 
17109         case FlushedInt52:
17110             return ExitValue::inJSStackAsInt52(flush.virtualRegister());
17111 
17112         case FlushedDouble:
17113             return ExitValue::inJSStackAsDouble(flush.virtualRegister());
17114         }
17115 
17116         DFG_CRASH(m_graph, m_node, &quot;Invalid flush format&quot;);
17117         return ExitValue::dead();
17118     }
17119 
17120     ExitValue exitValueForNode(
17121         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
17122         Node* node)
17123     {
17124         // NOTE: In FTL-&gt;B3, we cannot generate code here, because m_output is positioned after the
17125         // stackmap value. Like all values, the stackmap value cannot use a child that is defined after
17126         // it.
17127 
17128         ASSERT(node-&gt;shouldGenerate());
17129         ASSERT(node-&gt;hasResult());
17130 
17131         if (node) {
17132             switch (node-&gt;op()) {
17133             case BottomValue:
17134                 // This might arise in object materializations. I actually doubt that it would,
17135                 // but it seems worthwhile to be conservative.
17136                 return ExitValue::dead();
17137 
17138             case JSConstant:
17139             case Int52Constant:
17140             case DoubleConstant:
17141                 return ExitValue::constant(node-&gt;asJSValue());
17142 
17143             default:
17144                 if (node-&gt;isPhantomAllocation())
17145                     return ExitValue::materializeNewObject(map.get(node));
17146                 break;
17147             }
17148         }
17149 
17150         LoweredNodeValue value = m_int32Values.get(node);
17151         if (isValid(value))
17152             return exitArgument(arguments, DataFormatInt32, value.value());
17153 
17154         value = m_int52Values.get(node);
17155         if (isValid(value))
17156             return exitArgument(arguments, DataFormatInt52, value.value());
17157 
17158         value = m_strictInt52Values.get(node);
17159         if (isValid(value))
17160             return exitArgument(arguments, DataFormatStrictInt52, value.value());
17161 
17162         value = m_booleanValues.get(node);
17163         if (isValid(value))
17164             return exitArgument(arguments, DataFormatBoolean, value.value());
17165 
17166         value = m_jsValueValues.get(node);
17167         if (isValid(value))
17168             return exitArgument(arguments, DataFormatJS, value.value());
17169 
17170         value = m_doubleValues.get(node);
17171         if (isValid(value))
17172             return exitArgument(arguments, DataFormatDouble, value.value());
17173 
17174         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
17175         return ExitValue::dead();
17176     }
17177 
17178     ExitValue exitArgument(StackmapArgumentList&amp; arguments, DataFormat format, LValue value)
17179     {
17180         ExitValue result = ExitValue::exitArgument(ExitArgument(format, arguments.size()));
17181         arguments.append(value);
17182         return result;
17183     }
17184 
17185     ExitValue exitValueForTailCall(StackmapArgumentList&amp; arguments, Node* node)
17186     {
17187         ASSERT(node-&gt;shouldGenerate());
17188         ASSERT(node-&gt;hasResult());
17189 
17190         switch (node-&gt;op()) {
17191         case JSConstant:
17192         case Int52Constant:
17193         case DoubleConstant:
17194             return ExitValue::constant(node-&gt;asJSValue());
17195 
17196         default:
17197             break;
17198         }
17199 
17200         LoweredNodeValue value = m_jsValueValues.get(node);
17201         if (isValid(value))
17202             return exitArgument(arguments, DataFormatJS, value.value());
17203 
17204         value = m_int32Values.get(node);
17205         if (isValid(value))
17206             return exitArgument(arguments, DataFormatJS, boxInt32(value.value()));
17207 
17208         value = m_booleanValues.get(node);
17209         if (isValid(value))
17210             return exitArgument(arguments, DataFormatJS, boxBoolean(value.value()));
17211 
17212         // Doubles and Int52 have been converted by ValueRep()
17213         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
17214     }
17215 
17216     void setInt32(Node* node, LValue value)
17217     {
17218         m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
17219     }
17220     void setInt52(Node* node, LValue value)
17221     {
17222         m_int52Values.set(node, LoweredNodeValue(value, m_highBlock));
17223     }
17224     void setStrictInt52(Node* node, LValue value)
17225     {
17226         m_strictInt52Values.set(node, LoweredNodeValue(value, m_highBlock));
17227     }
17228     void setInt52(Node* node, LValue value, Int52Kind kind)
17229     {
17230         switch (kind) {
17231         case Int52:
17232             setInt52(node, value);
17233             return;
17234 
17235         case StrictInt52:
17236             setStrictInt52(node, value);
17237             return;
17238         }
17239 
17240         DFG_CRASH(m_graph, m_node, &quot;Corrupt int52 kind&quot;);
17241     }
17242     void setJSValue(Node* node, LValue value)
17243     {
17244         m_jsValueValues.set(node, LoweredNodeValue(value, m_highBlock));
17245     }
17246     void setBoolean(Node* node, LValue value)
17247     {
17248         m_booleanValues.set(node, LoweredNodeValue(value, m_highBlock));
17249     }
17250     void setStorage(Node* node, LValue value)
17251     {
17252         m_storageValues.set(node, LoweredNodeValue(value, m_highBlock));
17253     }
17254     void setDouble(Node* node, LValue value)
17255     {
17256         m_doubleValues.set(node, LoweredNodeValue(value, m_highBlock));
17257     }
17258 
17259     void setInt32(LValue value)
17260     {
17261         setInt32(m_node, value);
17262     }
17263     void setInt52(LValue value)
17264     {
17265         setInt52(m_node, value);
17266     }
17267     void setStrictInt52(LValue value)
17268     {
17269         setStrictInt52(m_node, value);
17270     }
17271     void setInt52(LValue value, Int52Kind kind)
17272     {
17273         setInt52(m_node, value, kind);
17274     }
17275     void setJSValue(LValue value)
17276     {
17277         setJSValue(m_node, value);
17278     }
17279     void setBoolean(LValue value)
17280     {
17281         setBoolean(m_node, value);
17282     }
17283     void setStorage(LValue value)
17284     {
17285         setStorage(m_node, value);
17286     }
17287     void setDouble(LValue value)
17288     {
17289         setDouble(m_node, value);
17290     }
17291 
17292     bool isValid(const LoweredNodeValue&amp; value)
17293     {
17294         if (!value)
17295             return false;
17296         if (!m_graph.m_ssaDominators-&gt;dominates(value.block(), m_highBlock))
17297             return false;
17298         return true;
17299     }
17300 
17301     void keepAlive(LValue value)
17302     {
17303         PatchpointValue* patchpoint = m_out.patchpoint(Void);
17304         patchpoint-&gt;effects = Effects::none();
17305         patchpoint-&gt;effects.writesLocalState = true;
17306         patchpoint-&gt;effects.reads = HeapRange::top();
17307         patchpoint-&gt;append(value, ValueRep::ColdAny);
17308         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
17309     }
17310 
17311     void addWeakReference(JSCell* target)
17312     {
17313         m_graph.m_plan.weakReferences().addLazily(target);
17314     }
17315 
17316     LValue loadStructure(LValue value)
17317     {
17318         LValue structureID = m_out.load32(value, m_heaps.JSCell_structureID);
17319         LValue tableBase = m_out.loadPtr(m_out.absolute(vm().heap.structureIDTable().base()));
17320         LValue tableIndex = m_out.aShr(structureID, m_out.constInt32(StructureIDTable::s_numberOfEntropyBits));
17321         LValue entropyBits = m_out.shl(m_out.zeroExtPtr(structureID), m_out.constInt32(StructureIDTable::s_entropyBitsShiftForStructurePointer));
17322         TypedPointer address = m_out.baseIndex(m_heaps.structureTable, tableBase, m_out.zeroExtPtr(tableIndex));
17323         LValue encodedStructureBits = m_out.loadPtr(address);
17324         return m_out.bitXor(encodedStructureBits, entropyBits);
17325     }
17326 
17327     LValue weakPointer(JSCell* pointer)
17328     {
17329         addWeakReference(pointer);
17330         return m_out.weakPointer(m_graph, pointer);
17331     }
17332 
17333     LValue frozenPointer(FrozenValue* value)
17334     {
17335         return m_out.weakPointer(value);
17336     }
17337 
17338     LValue weakStructureID(RegisteredStructure structure)
17339     {
17340         return m_out.constInt32(structure-&gt;id());
17341     }
17342 
17343     LValue weakStructure(RegisteredStructure structure)
17344     {
17345         ASSERT(!!structure.get());
17346         return m_out.weakPointer(m_graph, structure.get());
17347     }
17348 
17349     TypedPointer addressFor(LValue base, int operand, ptrdiff_t offset = 0)
17350     {
17351         return m_out.address(base, m_heaps.variables[operand], offset);
17352     }
17353     TypedPointer payloadFor(LValue base, int operand)
17354     {
17355         return addressFor(base, operand, PayloadOffset);
17356     }
17357     TypedPointer tagFor(LValue base, int operand)
17358     {
17359         return addressFor(base, operand, TagOffset);
17360     }
17361     TypedPointer addressFor(int operand, ptrdiff_t offset = 0)
17362     {
17363         return addressFor(VirtualRegister(operand), offset);
17364     }
17365     TypedPointer addressFor(VirtualRegister operand, ptrdiff_t offset = 0)
17366     {
17367         if (operand.isLocal())
17368             return addressFor(m_captured, operand.offset(), offset);
17369         return addressFor(m_callFrame, operand.offset(), offset);
17370     }
17371     TypedPointer payloadFor(int operand)
17372     {
17373         return payloadFor(VirtualRegister(operand));
17374     }
17375     TypedPointer payloadFor(VirtualRegister operand)
17376     {
17377         return addressFor(operand, PayloadOffset);
17378     }
17379     TypedPointer tagFor(int operand)
17380     {
17381         return tagFor(VirtualRegister(operand));
17382     }
17383     TypedPointer tagFor(VirtualRegister operand)
17384     {
17385         return addressFor(operand, TagOffset);
17386     }
17387 
17388     AbstractValue abstractValue(Node* node)
17389     {
17390         return m_state.forNode(node);
17391     }
17392     AbstractValue abstractValue(Edge edge)
17393     {
17394         return abstractValue(edge.node());
17395     }
17396 
17397     SpeculatedType provenType(Node* node)
17398     {
17399         return abstractValue(node).m_type;
17400     }
17401     SpeculatedType provenType(Edge edge)
17402     {
17403         return provenType(edge.node());
17404     }
17405 
17406     JSValue provenValue(Node* node)
17407     {
17408         return abstractValue(node).m_value;
17409     }
17410     JSValue provenValue(Edge edge)
17411     {
17412         return provenValue(edge.node());
17413     }
17414 
17415     StructureAbstractValue abstractStructure(Node* node)
17416     {
17417         return abstractValue(node).m_structure;
17418     }
17419     StructureAbstractValue abstractStructure(Edge edge)
17420     {
17421         return abstractStructure(edge.node());
17422     }
17423 
17424     void crash()
17425     {
17426         crash(m_highBlock, m_node);
17427     }
17428     void crash(DFG::BasicBlock* block, Node* node)
17429     {
17430         BlockIndex blockIndex = block-&gt;index;
17431         unsigned nodeIndex = node ? node-&gt;index() : UINT_MAX;
17432 #if ASSERT_DISABLED
17433         m_out.patchpoint(Void)-&gt;setGenerator(
17434             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
17435                 AllowMacroScratchRegisterUsage allowScratch(jit);
17436 
17437                 jit.move(CCallHelpers::TrustedImm32(blockIndex), GPRInfo::regT0);
17438                 jit.move(CCallHelpers::TrustedImm32(nodeIndex), GPRInfo::regT1);
17439                 if (node)
17440                     jit.move(CCallHelpers::TrustedImm32(node-&gt;op()), GPRInfo::regT2);
17441                 jit.abortWithReason(FTLCrash);
17442             });
17443 #else
17444         m_out.call(
17445             Void,
17446             m_out.constIntPtr(ftlUnreachable),
17447             // We don&#39;t want the CodeBlock to have a weak pointer to itself because
17448             // that would cause it to always get collected.
17449             m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), m_out.constInt32(blockIndex),
17450             m_out.constInt32(nodeIndex));
17451 #endif
17452         m_out.unreachable();
17453     }
17454 
17455     AvailabilityMap&amp; availabilityMap() { return m_availabilityCalculator.m_availability; }
17456 
17457     VM&amp; vm() { return m_graph.m_vm; }
17458     CodeBlock* codeBlock() { return m_graph.m_codeBlock; }
17459 
17460     Graph&amp; m_graph;
17461     State&amp; m_ftlState;
17462     AbstractHeapRepository m_heaps;
17463     Output m_out;
17464     Procedure&amp; m_proc;
17465 
17466     LBasicBlock m_handleExceptions;
17467     HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
17468 
17469     LValue m_callFrame;
17470     LValue m_captured;
17471     LValue m_tagTypeNumber;
17472     LValue m_tagMask;
17473 
17474     HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
17475     HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
17476     HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
17477     HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
17478     HashMap&lt;Node*, LoweredNodeValue&gt; m_booleanValues;
17479     HashMap&lt;Node*, LoweredNodeValue&gt; m_storageValues;
17480     HashMap&lt;Node*, LoweredNodeValue&gt; m_doubleValues;
17481 
17482     HashMap&lt;Node*, LValue&gt; m_phis;
17483 
17484     LocalOSRAvailabilityCalculator m_availabilityCalculator;
17485 
17486     InPlaceAbstractState m_state;
17487     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
17488     DFG::BasicBlock* m_highBlock;
17489     DFG::BasicBlock* m_nextHighBlock;
17490     LBasicBlock m_nextLowBlock;
17491 
17492     enum IndexMaskingMode { IndexMaskingDisabled, IndexMaskingEnabled };
17493 
17494     IndexMaskingMode m_indexMaskingMode;
17495 
17496     NodeOrigin m_origin;
17497     unsigned m_nodeIndex;
17498     Node* m_node;
17499 
17500     // These are used for validating AI state.
17501     HashMap&lt;Node*, NodeSet&gt; m_liveInToNode;
17502     HashMap&lt;Node*, AbstractValue&gt; m_aiCheckedNodes;
17503     String m_graphDump;
17504 };
17505 
17506 } // anonymous namespace
17507 
17508 void lowerDFGToB3(State&amp; state)
17509 {
17510     LowerDFGToB3 lowering(state);
17511     lowering.lower();
17512 }
17513 
17514 } } // namespace JSC::FTL
17515 
17516 #endif // ENABLE(FTL_JIT)
17517 
    </pre>
  </body>
</html>